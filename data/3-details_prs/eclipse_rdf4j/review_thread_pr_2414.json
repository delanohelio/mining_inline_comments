{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwODEyNTc0", "number": 2414, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwMzo1NDoxNVrOEUV7gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjoxODo1OFrOEUZYiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NzY2Mjc0OnYy", "diffSide": "RIGHT", "path": "core/rio/api/src/test/resources/logback-test.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwMzo1NDoxNVrOG6h_4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwMzo1NDoxNVrOG6h_4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAyNzYxOA==", "bodyText": "locally change to debug to see results of writing on stdout in several tests. Don't forget to change back before committing to avoid blowing up the build log.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464027618", "createdAt": "2020-08-02T03:54:15Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/api/src/test/resources/logback-test.xml", "diffHunk": "@@ -5,6 +5,9 @@\n \t\t\t<pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %msg%n</pattern>\n \t\t</encoder>\n \t</appender>\n+\t<logger name=\"org.eclipse.rdf4j.rio\">\n+\t\t<level value=\"warn\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NzY2OTk1OnYy", "diffSide": "RIGHT", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwNDowNjoxN1rOG6iDJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwNDowNjoxN1rOG6iDJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAyODQ1NQ==", "bodyText": "All the changes in this file are just the result of me reverting some earlier attempts to fix the inlining issues. They're not really relevant as the ArrangedWriter class is no longer used and only left in place on the off-chance that some third party uses it (unlikely but you never know).", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464028455", "createdAt": "2020-08-02T04:06:17Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java", "diffHunk": "@@ -205,29 +203,27 @@ protected synchronized void consumeStatement(Statement st) throws RDFHandlerExce\n \t}\n \n \tprivate synchronized Statement nextStatement() {\n-\n-\t\tif (statementBySubject.isEmpty() && blanks.isEmpty()) {\n+\t\tif (stmtBySubject.isEmpty() && blanks.isEmpty()) {\n \t\t\tassert queueSize == 0;\n \t\t\treturn null;\n \t\t}\n-\t\tSet<Statement> statements = null;\n-\t\twhile (statements == null) {\n+\t\tSet<Statement> stmts = null;\n+\t\twhile (stmts == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODIwNDM3OnYy", "diffSide": "RIGHT", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo0OTo1NVrOG6mALw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMjo0MzoyNVrOG6oX4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzIzMQ==", "bodyText": "This looks like you've reverted quite a lot of history.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464093231", "createdAt": "2020-08-02T15:49:55Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java", "diffHunk": "@@ -298,105 +294,25 @@ private boolean isStillReferenced(SubjectInContext key) {\n \n \tprivate synchronized void queueStatement(Statement st) {\n \t\tSubjectInContext key = new SubjectInContext(st);\n-\t\tSet<Statement> stmts = statementBySubject.get(key);\n+\t\tSet<Statement> stmts = stmtBySubject.get(key);\n \t\tif (stmts == null && st.getSubject() instanceof BNode && !stack.contains(key)) {\n \t\t\tblanks.add(st);\n \t\t} else {\n \t\t\tif (stmts == null) {\n-\t\t\t\tstatementBySubject.put(key, stmts = new TreeSet<>(comparator));\n+\t\t\t\tstmtBySubject.put(key, stmts = new TreeSet<>(comparator));\n \t\t\t}\n \t\t\tstmts.add(st);\n \t\t}\n \t\tqueueSize++;\n \t}\n \n \tprivate synchronized void flushStatements() throws RDFHandlerException {\n-\t\tif (!statementBySubject.isEmpty() || !blanks.isEmpty()) {\n+\t\tif (!stmtBySubject.isEmpty() || !blanks.isEmpty()) {\n \t\t\tflushNamespaces();\n-\n-\t\t\t// used to store all the statements\n-\t\t\tArrayList<Statement> statements = new ArrayList<>();\n-\n-\t\t\t// used to store blank nodes along with the number of times they are used as an object in a statement.\n-\t\t\tMap<BNode, Integer> bNodeOccurrences = new HashMap<>();\n-\n \t\t\tStatement st;\n \t\t\twhile ((st = nextStatement()) != null) {\n-\t\t\t\tstatements.add(st);\n-\n-\t\t\t\tValue obj = st.getObject();\n-\n-\t\t\t\t// if the object in the statement is a blank node, we will update its number of occurrences\n-\t\t\t\tif (obj instanceof BNode) {\n-\t\t\t\t\tbNodeOccurrences.compute(\n-\t\t\t\t\t\t\t(BNode) obj,\n-\t\t\t\t\t\t\t(key, i) -> i == null ? 1 : i + 1\n-\t\t\t\t\t);\n-\n-\t\t\t\t\tif (bNodeOccurrences.get(obj) > 1) {\n-\t\t\t\t\t\tif (st.getSubject() instanceof BNode) {\n-\t\t\t\t\t\t\tnonInlinedNodes.add(st.getSubject());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tnonInlinedNodes.add(obj);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tdelegate.handleStatement(st);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMjA2Ng==", "bodyText": "It's really only two pull requests - yours and Miro's. In retrospect it wasn't really necessary but I wanted to start with a fresh perspective instead of continuing to build on patches that didn't completely solve the problems.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464132066", "createdAt": "2020-08-02T22:43:25Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java", "diffHunk": "@@ -298,105 +294,25 @@ private boolean isStillReferenced(SubjectInContext key) {\n \n \tprivate synchronized void queueStatement(Statement st) {\n \t\tSubjectInContext key = new SubjectInContext(st);\n-\t\tSet<Statement> stmts = statementBySubject.get(key);\n+\t\tSet<Statement> stmts = stmtBySubject.get(key);\n \t\tif (stmts == null && st.getSubject() instanceof BNode && !stack.contains(key)) {\n \t\t\tblanks.add(st);\n \t\t} else {\n \t\t\tif (stmts == null) {\n-\t\t\t\tstatementBySubject.put(key, stmts = new TreeSet<>(comparator));\n+\t\t\t\tstmtBySubject.put(key, stmts = new TreeSet<>(comparator));\n \t\t\t}\n \t\t\tstmts.add(st);\n \t\t}\n \t\tqueueSize++;\n \t}\n \n \tprivate synchronized void flushStatements() throws RDFHandlerException {\n-\t\tif (!statementBySubject.isEmpty() || !blanks.isEmpty()) {\n+\t\tif (!stmtBySubject.isEmpty() || !blanks.isEmpty()) {\n \t\t\tflushNamespaces();\n-\n-\t\t\t// used to store all the statements\n-\t\t\tArrayList<Statement> statements = new ArrayList<>();\n-\n-\t\t\t// used to store blank nodes along with the number of times they are used as an object in a statement.\n-\t\t\tMap<BNode, Integer> bNodeOccurrences = new HashMap<>();\n-\n \t\t\tStatement st;\n \t\t\twhile ((st = nextStatement()) != null) {\n-\t\t\t\tstatements.add(st);\n-\n-\t\t\t\tValue obj = st.getObject();\n-\n-\t\t\t\t// if the object in the statement is a blank node, we will update its number of occurrences\n-\t\t\t\tif (obj instanceof BNode) {\n-\t\t\t\t\tbNodeOccurrences.compute(\n-\t\t\t\t\t\t\t(BNode) obj,\n-\t\t\t\t\t\t\t(key, i) -> i == null ? 1 : i + 1\n-\t\t\t\t\t);\n-\n-\t\t\t\t\tif (bNodeOccurrences.get(obj) > 1) {\n-\t\t\t\t\t\tif (st.getSubject() instanceof BNode) {\n-\t\t\t\t\t\t\tnonInlinedNodes.add(st.getSubject());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tnonInlinedNodes.add(obj);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tdelegate.handleStatement(st);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzIzMQ=="}, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODIwNTYzOnYy", "diffSide": "RIGHT", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo1MTozMVrOG6mAyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMjo0NDowOFrOG6oYGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzM4NQ==", "bodyText": "These should be ArrayDeque, unless we expect them to grow very very large (since expanding the ArrayDeque gets costlier the bigger it is, talking millions of entries).", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464093385", "createdAt": "2020-08-02T15:51:31Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -70,12 +85,6 @@\n \tprotected Resource lastWrittenSubject;\n \tprotected IRI lastWrittenPredicate;\n \n-\t/**\n-\t * Always null\n-\t */\n-\t@Deprecated\n-\tprotected Model prettyPrintModel;\n-\n \tprivate final Deque<Resource> stack = new LinkedList<>();\n \tprivate final Deque<IRI> path = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMjEyMA==", "bodyText": "We've got a lot of pre-1.6 code in places :) Good point, will fix.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464132120", "createdAt": "2020-08-02T22:44:08Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -70,12 +85,6 @@\n \tprotected Resource lastWrittenSubject;\n \tprotected IRI lastWrittenPredicate;\n \n-\t/**\n-\t * Always null\n-\t */\n-\t@Deprecated\n-\tprotected Model prettyPrintModel;\n-\n \tprivate final Deque<Resource> stack = new LinkedList<>();\n \tprivate final Deque<IRI> path = new LinkedList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzM4NQ=="}, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODIwNjI2OnYy", "diffSide": "RIGHT", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo1MjoyNlrOG6mBFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMjo0NzoyMFrOG6oZUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzQ2Mw==", "bodyText": "You could just make it protected and then others could override this method if they have a better Model implementation they want to use.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464093463", "createdAt": "2020-08-02T15:52:26Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -108,6 +117,11 @@ public TurtleWriter(OutputStream out, ParsedIRI baseIRI) {\n \t\tthis.writer = new IndentingWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8));\n \t}\n \n+\t// TODO make injectable\n+\tprivate ModelFactory getModelFactory() {\n+\t\treturn new LinkedHashModelFactory();\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMjQzMw==", "bodyText": "Forgot about this. I prefer making it properly injectable instead of forcing people to subclass - I'll add a setter and also make it protected.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464132433", "createdAt": "2020-08-02T22:47:20Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -108,6 +117,11 @@ public TurtleWriter(OutputStream out, ParsedIRI baseIRI) {\n \t\tthis.writer = new IndentingWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8));\n \t}\n \n+\t// TODO make injectable\n+\tprivate ModelFactory getModelFactory() {\n+\t\treturn new LinkedHashModelFactory();\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzQ2Mw=="}, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODIxMTA4OnYy", "diffSide": "RIGHT", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo1NjoyNVrOG6mDOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMjo0OToxMlrOG6oZ5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDAxMA==", "bodyText": "Btw. If you use a long for bufferSize you can just set it to be Long.MAX_VALUE and you don't have to deal with -1 as a special case. Dunno if it would help, but it's a decent approach since you would run out of memory way before reaching that limit (minimum 4 611 686  terabytes).", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094010", "createdAt": "2020-08-02T15:56:25Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -145,6 +159,12 @@ public void startRDF() throws RDFHandlerException {\n \t\t\txsdStringToPlainLiteral = getWriterConfig().get(BasicWriterSettings.XSD_STRING_TO_PLAIN_LITERAL);\n \t\t\tprettyPrint = getWriterConfig().get(BasicWriterSettings.PRETTY_PRINT);\n \t\t\tinlineBNodes = getWriterConfig().get(BasicWriterSettings.INLINE_BLANK_NODES);\n+\n+\t\t\tif (isBuffering()) {\n+\t\t\t\tthis.bufferedStatements = getModelFactory().createEmptyModel();\n+\t\t\t\tthis.bufferSize = inlineBNodes ? -1 : DEFAULT_BUFFER_SIZE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMjU4MA==", "bodyText": "Good idea.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464132580", "createdAt": "2020-08-02T22:49:12Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -145,6 +159,12 @@ public void startRDF() throws RDFHandlerException {\n \t\t\txsdStringToPlainLiteral = getWriterConfig().get(BasicWriterSettings.XSD_STRING_TO_PLAIN_LITERAL);\n \t\t\tprettyPrint = getWriterConfig().get(BasicWriterSettings.PRETTY_PRINT);\n \t\t\tinlineBNodes = getWriterConfig().get(BasicWriterSettings.INLINE_BLANK_NODES);\n+\n+\t\t\tif (isBuffering()) {\n+\t\t\t\tthis.bufferedStatements = getModelFactory().createEmptyModel();\n+\t\t\t\tthis.bufferSize = inlineBNodes ? -1 : DEFAULT_BUFFER_SIZE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDAxMA=="}, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODIxMzI4OnYy", "diffSide": "RIGHT", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo1ODo0OVrOG6mEPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMjo0MTozMVrOG6oXRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDI3MQ==", "bodyText": "List handling in the pretty printed turtle code has always been bad. I should make some tests for that to see if you've fixed it now.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094271", "createdAt": "2020-08-02T15:58:49Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -256,57 +276,71 @@ protected void handleStatementInternal(Statement st, boolean endRDFCalled, boole\n \t\tResource subj = st.getSubject();\n \t\tIRI pred = st.getPredicate();\n \t\tValue obj = st.getObject();\n+\n \t\ttry {\n-\t\t\tif (subj.equals(lastWrittenSubject)) {\n-\t\t\t\tif (pred.equals(lastWrittenPredicate)) {\n-\t\t\t\t\t// Identical subject and predicate\n-\t\t\t\t\twriter.write(\",\");\n-\t\t\t\t\twrapLine(prettyPrint);\n-\t\t\t\t} else {\n-\t\t\t\t\t// Identical subject, new predicate\n-\t\t\t\t\twriter.write(\";\");\n-\t\t\t\t\twriter.writeEOL();\n-\n-\t\t\t\t\t// Write new predicate\n-\t\t\t\t\twriter.decreaseIndentation();\n-\t\t\t\t\twritePredicate(pred);\n-\t\t\t\t\twriter.increaseIndentation();\n-\t\t\t\t\twrapLine(true);\n-\t\t\t\t\tpath.removeLast();\n-\t\t\t\t\tpath.addLast(pred);\n-\t\t\t\t\tlastWrittenPredicate = pred;\n-\t\t\t\t}\n+\t\t\tif (inlineBNodes && (pred.equals(RDF.FIRST) || pred.equals(RDF.REST))) {\n+\t\t\t\thandleList(st);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMTkwOA==", "bodyText": "None of what I've done really touches the list handling I think - the only thing that changes is how it is invoked.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464131908", "createdAt": "2020-08-02T22:41:31Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -256,57 +276,71 @@ protected void handleStatementInternal(Statement st, boolean endRDFCalled, boole\n \t\tResource subj = st.getSubject();\n \t\tIRI pred = st.getPredicate();\n \t\tValue obj = st.getObject();\n+\n \t\ttry {\n-\t\t\tif (subj.equals(lastWrittenSubject)) {\n-\t\t\t\tif (pred.equals(lastWrittenPredicate)) {\n-\t\t\t\t\t// Identical subject and predicate\n-\t\t\t\t\twriter.write(\",\");\n-\t\t\t\t\twrapLine(prettyPrint);\n-\t\t\t\t} else {\n-\t\t\t\t\t// Identical subject, new predicate\n-\t\t\t\t\twriter.write(\";\");\n-\t\t\t\t\twriter.writeEOL();\n-\n-\t\t\t\t\t// Write new predicate\n-\t\t\t\t\twriter.decreaseIndentation();\n-\t\t\t\t\twritePredicate(pred);\n-\t\t\t\t\twriter.increaseIndentation();\n-\t\t\t\t\twrapLine(true);\n-\t\t\t\t\tpath.removeLast();\n-\t\t\t\t\tpath.addLast(pred);\n-\t\t\t\t\tlastWrittenPredicate = pred;\n-\t\t\t\t}\n+\t\t\tif (inlineBNodes && (pred.equals(RDF.FIRST) || pred.equals(RDF.REST))) {\n+\t\t\t\thandleList(st);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDI3MQ=="}, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODIxNjY1OnYy", "diffSide": "RIGHT", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjowMzowNFrOG6mFzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMjo0MTowNVrOG6oXIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDY3MQ==", "bodyText": "Does this now support pretty printing TriG? That would be awesome.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094671", "createdAt": "2020-08-02T16:03:04Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMTg3Mw==", "bodyText": "I didn't really check beyond testing that all TriG tests still succeed - I'm pretty sure TriGWriter already supported pretty printing to some extent though.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464131873", "createdAt": "2020-08-02T22:41:05Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDY3MQ=="}, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODIxNzgxOnYy", "diffSide": "RIGHT", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjowNDozNVrOG6mGXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMzowNDoxOFrOG6ofMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDgxMw==", "bodyText": "I wonder if this could be checked in some way. To assert that we're not calling this method from multiple threads.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094813", "createdAt": "2020-08-02T16:04:35Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMzkzOA==", "bodyText": "It's a private method, and expectations are documented. I'm not too worried about it tbh. I'll turn it into a javadoc comment though to be a bit more in-your-face about it.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464133938", "createdAt": "2020-08-02T23:04:18Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDgxMw=="}, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 277}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODIxOTE1OnYy", "diffSide": "RIGHT", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjowNjowN1rOG6mG9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjowNjowN1rOG6mG9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDk2NQ==", "bodyText": "Nice use of optional!", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094965", "createdAt": "2020-08-02T16:06:07Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 320}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODIyNTQ4OnYy", "diffSide": "RIGHT", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjoxNDoyMFrOG6mJ-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMzoxNzoxNFrOG6okMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NTczOA==", "bodyText": "Since these pieces of code are so similar I'm wondering if maybe you would prefer to use the java 8 streams grouping collector (https://www.baeldung.com/java-groupingby-collector) and then sort it so that rdf:type gets preference.\nA more performant alternative would be to sort contextData.getStatements(subject, null, null) by the predicate with preference to rdf:type and then grouping could be done by looking at the previous predicate.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464095738", "createdAt": "2020-08-02T16:14:20Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tprivate void processSubject(Model contextData, Resource subject, Set<Resource> processedSubjects) {\n+\t\tif (processedSubjects.contains(subject)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<IRI> processedPredicates = new HashSet<>();\n+\n+\t\t// give rdf:type preference over other predicates.\n+\t\tfor (Statement typeStatement : contextData.getStatements(subject, RDF.TYPE, null)) {\n+\t\t\tboolean canInlineObject = inlineValue(contextData, typeStatement.getObject());\n+\t\t\thandleStatementInternal(typeStatement, false,\n+\t\t\t\t\tinlineValue(contextData, typeStatement.getSubject()),\n+\t\t\t\t\tcanInlineObject);\n+\n+\t\t\tif (canInlineObject && typeStatement.getObject() instanceof BNode) {\n+\t\t\t\tprocessSubject(contextData, (BNode) typeStatement.getObject(), processedSubjects);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprocessedPredicates.add(RDF.TYPE);\n+\n+\t\t// retrieve other statement from this context with the same\n+\t\t// subject, and output them grouped by predicate\n+\t\tfor (Statement subjectStatement : contextData.getStatements(subject, null, null)) {\n+\t\t\tIRI predicate = subjectStatement.getPredicate();\n+\t\t\tif (!processedPredicates.contains(predicate)) {\n+\t\t\t\tfor (Statement toWrite : contextData.getStatements(subject, predicate, null)) {\n+\t\t\t\t\tboolean canInlineObject = inlineValue(contextData, toWrite.getObject());\n+\t\t\t\t\thandleStatementInternal(toWrite, false, inlineValue(contextData, toWrite.getSubject()),\n+\t\t\t\t\t\t\tcanInlineObject);\n+\t\t\t\t\tif (canInlineObject && toWrite.getObject() instanceof BNode) {\n+\t\t\t\t\t\tprocessSubject(contextData, (BNode) toWrite.getObject(), processedSubjects);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessedPredicates.add(predicate);\n+\t\t\t}\n+\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 359}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMjY2MQ==", "bodyText": "I'll take a look at DRYing this up a bit.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464132661", "createdAt": "2020-08-02T22:50:04Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tprivate void processSubject(Model contextData, Resource subject, Set<Resource> processedSubjects) {\n+\t\tif (processedSubjects.contains(subject)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<IRI> processedPredicates = new HashSet<>();\n+\n+\t\t// give rdf:type preference over other predicates.\n+\t\tfor (Statement typeStatement : contextData.getStatements(subject, RDF.TYPE, null)) {\n+\t\t\tboolean canInlineObject = inlineValue(contextData, typeStatement.getObject());\n+\t\t\thandleStatementInternal(typeStatement, false,\n+\t\t\t\t\tinlineValue(contextData, typeStatement.getSubject()),\n+\t\t\t\t\tcanInlineObject);\n+\n+\t\t\tif (canInlineObject && typeStatement.getObject() instanceof BNode) {\n+\t\t\t\tprocessSubject(contextData, (BNode) typeStatement.getObject(), processedSubjects);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprocessedPredicates.add(RDF.TYPE);\n+\n+\t\t// retrieve other statement from this context with the same\n+\t\t// subject, and output them grouped by predicate\n+\t\tfor (Statement subjectStatement : contextData.getStatements(subject, null, null)) {\n+\t\t\tIRI predicate = subjectStatement.getPredicate();\n+\t\t\tif (!processedPredicates.contains(predicate)) {\n+\t\t\t\tfor (Statement toWrite : contextData.getStatements(subject, predicate, null)) {\n+\t\t\t\t\tboolean canInlineObject = inlineValue(contextData, toWrite.getObject());\n+\t\t\t\t\thandleStatementInternal(toWrite, false, inlineValue(contextData, toWrite.getSubject()),\n+\t\t\t\t\t\t\tcanInlineObject);\n+\t\t\t\t\tif (canInlineObject && toWrite.getObject() instanceof BNode) {\n+\t\t\t\t\t\tprocessSubject(contextData, (BNode) toWrite.getObject(), processedSubjects);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessedPredicates.add(predicate);\n+\t\t\t}\n+\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NTczOA=="}, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 359}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzNTIxOA==", "bodyText": "I had a quick look at a streaming/sorting approach, but to be honest I'm not convinced I can easily come up with an alternative that is both more performant and also still easy to read/maintain. Not really worth investing too much time in right now I think. I have reorganized the code a little bit though to make it less repetitive.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464135218", "createdAt": "2020-08-02T23:17:14Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tprivate void processSubject(Model contextData, Resource subject, Set<Resource> processedSubjects) {\n+\t\tif (processedSubjects.contains(subject)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<IRI> processedPredicates = new HashSet<>();\n+\n+\t\t// give rdf:type preference over other predicates.\n+\t\tfor (Statement typeStatement : contextData.getStatements(subject, RDF.TYPE, null)) {\n+\t\t\tboolean canInlineObject = inlineValue(contextData, typeStatement.getObject());\n+\t\t\thandleStatementInternal(typeStatement, false,\n+\t\t\t\t\tinlineValue(contextData, typeStatement.getSubject()),\n+\t\t\t\t\tcanInlineObject);\n+\n+\t\t\tif (canInlineObject && typeStatement.getObject() instanceof BNode) {\n+\t\t\t\tprocessSubject(contextData, (BNode) typeStatement.getObject(), processedSubjects);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprocessedPredicates.add(RDF.TYPE);\n+\n+\t\t// retrieve other statement from this context with the same\n+\t\t// subject, and output them grouped by predicate\n+\t\tfor (Statement subjectStatement : contextData.getStatements(subject, null, null)) {\n+\t\t\tIRI predicate = subjectStatement.getPredicate();\n+\t\t\tif (!processedPredicates.contains(predicate)) {\n+\t\t\t\tfor (Statement toWrite : contextData.getStatements(subject, predicate, null)) {\n+\t\t\t\t\tboolean canInlineObject = inlineValue(contextData, toWrite.getObject());\n+\t\t\t\t\thandleStatementInternal(toWrite, false, inlineValue(contextData, toWrite.getSubject()),\n+\t\t\t\t\t\t\tcanInlineObject);\n+\t\t\t\t\tif (canInlineObject && toWrite.getObject() instanceof BNode) {\n+\t\t\t\t\t\tprocessSubject(contextData, (BNode) toWrite.getObject(), processedSubjects);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessedPredicates.add(predicate);\n+\t\t\t}\n+\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NTczOA=="}, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 359}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODIyNzA0OnYy", "diffSide": "RIGHT", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjoxNjoyM1rOG6mKtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjoxNzo0N1rOG6mLLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NTkyNQ==", "bodyText": "Maybe this should be canInlineValue to indicate that it checks if inlining is allowed.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464095925", "createdAt": "2020-08-02T16:16:23Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tprivate void processSubject(Model contextData, Resource subject, Set<Resource> processedSubjects) {\n+\t\tif (processedSubjects.contains(subject)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<IRI> processedPredicates = new HashSet<>();\n+\n+\t\t// give rdf:type preference over other predicates.\n+\t\tfor (Statement typeStatement : contextData.getStatements(subject, RDF.TYPE, null)) {\n+\t\t\tboolean canInlineObject = inlineValue(contextData, typeStatement.getObject());\n+\t\t\thandleStatementInternal(typeStatement, false,\n+\t\t\t\t\tinlineValue(contextData, typeStatement.getSubject()),\n+\t\t\t\t\tcanInlineObject);\n+\n+\t\t\tif (canInlineObject && typeStatement.getObject() instanceof BNode) {\n+\t\t\t\tprocessSubject(contextData, (BNode) typeStatement.getObject(), processedSubjects);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprocessedPredicates.add(RDF.TYPE);\n+\n+\t\t// retrieve other statement from this context with the same\n+\t\t// subject, and output them grouped by predicate\n+\t\tfor (Statement subjectStatement : contextData.getStatements(subject, null, null)) {\n+\t\t\tIRI predicate = subjectStatement.getPredicate();\n+\t\t\tif (!processedPredicates.contains(predicate)) {\n+\t\t\t\tfor (Statement toWrite : contextData.getStatements(subject, predicate, null)) {\n+\t\t\t\t\tboolean canInlineObject = inlineValue(contextData, toWrite.getObject());\n+\t\t\t\t\thandleStatementInternal(toWrite, false, inlineValue(contextData, toWrite.getSubject()),\n+\t\t\t\t\t\t\tcanInlineObject);\n+\t\t\t\t\tif (canInlineObject && toWrite.getObject() instanceof BNode) {\n+\t\t\t\t\t\tprocessSubject(contextData, (BNode) toWrite.getObject(), processedSubjects);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessedPredicates.add(predicate);\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\tprocessedSubjects.add(subject);\n+\t}\n+\n+\tprivate boolean inlineValue(Model contextData, Value v) {\n+\t\tif (!inlineBNodes) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (v instanceof BNode) {\n+\t\t\treturn (contextData.filter(null, null, v).size() <= 1);\n+\t\t}\n+\t\treturn true;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NjA0Nw==", "bodyText": "It's a nice and simple approach though. I like it a lot.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464096047", "createdAt": "2020-08-02T16:17:47Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tprivate void processSubject(Model contextData, Resource subject, Set<Resource> processedSubjects) {\n+\t\tif (processedSubjects.contains(subject)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<IRI> processedPredicates = new HashSet<>();\n+\n+\t\t// give rdf:type preference over other predicates.\n+\t\tfor (Statement typeStatement : contextData.getStatements(subject, RDF.TYPE, null)) {\n+\t\t\tboolean canInlineObject = inlineValue(contextData, typeStatement.getObject());\n+\t\t\thandleStatementInternal(typeStatement, false,\n+\t\t\t\t\tinlineValue(contextData, typeStatement.getSubject()),\n+\t\t\t\t\tcanInlineObject);\n+\n+\t\t\tif (canInlineObject && typeStatement.getObject() instanceof BNode) {\n+\t\t\t\tprocessSubject(contextData, (BNode) typeStatement.getObject(), processedSubjects);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprocessedPredicates.add(RDF.TYPE);\n+\n+\t\t// retrieve other statement from this context with the same\n+\t\t// subject, and output them grouped by predicate\n+\t\tfor (Statement subjectStatement : contextData.getStatements(subject, null, null)) {\n+\t\t\tIRI predicate = subjectStatement.getPredicate();\n+\t\t\tif (!processedPredicates.contains(predicate)) {\n+\t\t\t\tfor (Statement toWrite : contextData.getStatements(subject, predicate, null)) {\n+\t\t\t\t\tboolean canInlineObject = inlineValue(contextData, toWrite.getObject());\n+\t\t\t\t\thandleStatementInternal(toWrite, false, inlineValue(contextData, toWrite.getSubject()),\n+\t\t\t\t\t\t\tcanInlineObject);\n+\t\t\t\t\tif (canInlineObject && toWrite.getObject() instanceof BNode) {\n+\t\t\t\t\t\tprocessSubject(contextData, (BNode) toWrite.getObject(), processedSubjects);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessedPredicates.add(predicate);\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\tprocessedSubjects.add(subject);\n+\t}\n+\n+\tprivate boolean inlineValue(Model contextData, Value v) {\n+\t\tif (!inlineBNodes) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (v instanceof BNode) {\n+\t\t\treturn (contextData.filter(null, null, v).size() <= 1);\n+\t\t}\n+\t\treturn true;\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NTkyNQ=="}, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 372}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODIyODU3OnYy", "diffSide": "RIGHT", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjoxODo1OFrOG6mLeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMzowNzowMFrOG6ogPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NjEyMA==", "bodyText": "I'm wondering what happened to the buffer size value, shouldn't it be used in some form when deciding if we are buffering or not?", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464096120", "createdAt": "2020-08-02T16:18:58Z", "author": {"login": "hmottestad"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tprivate void processSubject(Model contextData, Resource subject, Set<Resource> processedSubjects) {\n+\t\tif (processedSubjects.contains(subject)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<IRI> processedPredicates = new HashSet<>();\n+\n+\t\t// give rdf:type preference over other predicates.\n+\t\tfor (Statement typeStatement : contextData.getStatements(subject, RDF.TYPE, null)) {\n+\t\t\tboolean canInlineObject = inlineValue(contextData, typeStatement.getObject());\n+\t\t\thandleStatementInternal(typeStatement, false,\n+\t\t\t\t\tinlineValue(contextData, typeStatement.getSubject()),\n+\t\t\t\t\tcanInlineObject);\n+\n+\t\t\tif (canInlineObject && typeStatement.getObject() instanceof BNode) {\n+\t\t\t\tprocessSubject(contextData, (BNode) typeStatement.getObject(), processedSubjects);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprocessedPredicates.add(RDF.TYPE);\n+\n+\t\t// retrieve other statement from this context with the same\n+\t\t// subject, and output them grouped by predicate\n+\t\tfor (Statement subjectStatement : contextData.getStatements(subject, null, null)) {\n+\t\t\tIRI predicate = subjectStatement.getPredicate();\n+\t\t\tif (!processedPredicates.contains(predicate)) {\n+\t\t\t\tfor (Statement toWrite : contextData.getStatements(subject, predicate, null)) {\n+\t\t\t\t\tboolean canInlineObject = inlineValue(contextData, toWrite.getObject());\n+\t\t\t\t\thandleStatementInternal(toWrite, false, inlineValue(contextData, toWrite.getSubject()),\n+\t\t\t\t\t\t\tcanInlineObject);\n+\t\t\t\t\tif (canInlineObject && toWrite.getObject() instanceof BNode) {\n+\t\t\t\t\t\tprocessSubject(contextData, (BNode) toWrite.getObject(), processedSubjects);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessedPredicates.add(predicate);\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\tprocessedSubjects.add(subject);\n+\t}\n+\n+\tprivate boolean inlineValue(Model contextData, Value v) {\n+\t\tif (!inlineBNodes) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (v instanceof BNode) {\n+\t\t\treturn (contextData.filter(null, null, v).size() <= 1);\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate boolean isBuffering() {\n+\t\treturn inlineBNodes || prettyPrint;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzNDIwNA==", "bodyText": "Buffer size value only influences the choice of when we flush the buffer. This private method is just meant to check if we are in fact using a buffer (which is what we do when we are either pretty-printing or inlining). It is in fact used to initialize the buffer as well, so it couldn't check the buffer size.", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464134204", "createdAt": "2020-08-02T23:07:00Z", "author": {"login": "jeenbroekstra"}, "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tprivate void processSubject(Model contextData, Resource subject, Set<Resource> processedSubjects) {\n+\t\tif (processedSubjects.contains(subject)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<IRI> processedPredicates = new HashSet<>();\n+\n+\t\t// give rdf:type preference over other predicates.\n+\t\tfor (Statement typeStatement : contextData.getStatements(subject, RDF.TYPE, null)) {\n+\t\t\tboolean canInlineObject = inlineValue(contextData, typeStatement.getObject());\n+\t\t\thandleStatementInternal(typeStatement, false,\n+\t\t\t\t\tinlineValue(contextData, typeStatement.getSubject()),\n+\t\t\t\t\tcanInlineObject);\n+\n+\t\t\tif (canInlineObject && typeStatement.getObject() instanceof BNode) {\n+\t\t\t\tprocessSubject(contextData, (BNode) typeStatement.getObject(), processedSubjects);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprocessedPredicates.add(RDF.TYPE);\n+\n+\t\t// retrieve other statement from this context with the same\n+\t\t// subject, and output them grouped by predicate\n+\t\tfor (Statement subjectStatement : contextData.getStatements(subject, null, null)) {\n+\t\t\tIRI predicate = subjectStatement.getPredicate();\n+\t\t\tif (!processedPredicates.contains(predicate)) {\n+\t\t\t\tfor (Statement toWrite : contextData.getStatements(subject, predicate, null)) {\n+\t\t\t\t\tboolean canInlineObject = inlineValue(contextData, toWrite.getObject());\n+\t\t\t\t\thandleStatementInternal(toWrite, false, inlineValue(contextData, toWrite.getSubject()),\n+\t\t\t\t\t\t\tcanInlineObject);\n+\t\t\t\t\tif (canInlineObject && toWrite.getObject() instanceof BNode) {\n+\t\t\t\t\t\tprocessSubject(contextData, (BNode) toWrite.getObject(), processedSubjects);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessedPredicates.add(predicate);\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\tprocessedSubjects.add(subject);\n+\t}\n+\n+\tprivate boolean inlineValue(Model contextData, Value v) {\n+\t\tif (!inlineBNodes) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (v instanceof BNode) {\n+\t\t\treturn (contextData.filter(null, null, v).size() <= 1);\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate boolean isBuffering() {\n+\t\treturn inlineBNodes || prettyPrint;\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NjEyMA=="}, "originalCommit": {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd"}, "originalPosition": 376}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1462, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}