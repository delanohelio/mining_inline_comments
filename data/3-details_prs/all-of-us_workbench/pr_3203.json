{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxNTU5MjEw", "number": 3203, "title": "[RW-4504, RW-4486][RISK=NO] Logs-based metric and dashboard tasks", "bodyText": "Add some more useful tasks to the toolkit:\n\ndelete service account keys (useful if you've left some around during debugging where you kill the  process before the cleanup code\nReplicate logs-based metric: we need to promote LBMs to other environments\nreplicate & list dashboards: the trickiest one, but a good chunk of the code is left over from December\n\ncall with (e.g.):\n./devops.rb -t list-dashboards -e /Users/jaycarlton/repos/workbench-devops/ops/inputs/monitoring_env_targets.json\n\nTIL:\n\nyou can't use a repeated field on a protobuf with a Ruby array, as it's not guaranteed to be typed consistently\nyou can use freeze to make sure you're not inadvertently mutating an object you need to pick at\nsometimes it's just easier to use an imperative style (e.g when it allows you to avoid protobuf niceties)\n\n\nPR checklist\n\n This PR meets the Acceptance Criteria in the JIRA story\n The JIRA story has been moved to Dev Review\n This PR includes appropriate unit tests\n I have run and tested this change locally\n If this includes an API change, I have updated the appropriate Swagger definitions and notified API consumers\n If this includes a new feature flag, I have created and linked new JIRA tickets to (a) turn on the feature flag and (b) remove it later", "createdAt": "2020-02-28T19:34:41Z", "url": "https://github.com/all-of-us/workbench/pull/3203", "merged": true, "mergeCommit": {"oid": "ef36b4cf53f091c3036cd6aa486ba17c4507def1"}, "closed": true, "closedAt": "2020-03-10T19:54:24Z", "author": {"login": "jaycarlton"}, "timelineItems": {"totalCount": 54, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6U9jMAH2gAyMzgxNTU5MjEwOmRhOGE3MjVmMDU5OTc3NzAxOGFkNGJmOGVmMTRiY2I3NGYzODAyNjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMX0_OAH2gAyMzgxNTU5MjEwOjI1ODAyYTQ4OWQzZjIwZDEyNTBmMjM3YzIzYTIxMmJjYTRlMGRmNDY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "da8a725f0599777018ad4bf8ef14bcb74f380262", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/da8a725f0599777018ad4bf8ef14bcb74f380262", "committedDate": "2020-01-14T18:07:52Z", "message": "cleaning some things up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2607b3d80c59dbaa905ce7da8cb015b4ac4e135", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/c2607b3d80c59dbaa905ce7da8cb015b4ac4e135", "committedDate": "2020-01-14T20:17:44Z", "message": "more fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f35c8f5ee2594fda1f1752ac591ff2f11d38595", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/6f35c8f5ee2594fda1f1752ac591ff2f11d38595", "committedDate": "2020-01-14T21:47:44Z", "message": "spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9805b747141f43e7ec5be4b8e06c6c4eec7e99d5", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/9805b747141f43e7ec5be4b8e06c6c4eec7e99d5", "committedDate": "2020-01-14T22:26:06Z", "message": "make string format thinner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dd1a1ad35ab1c54753ad36947f640dea9432dbf", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/7dd1a1ad35ab1c54753ad36947f640dea9432dbf", "committedDate": "2020-01-14T22:26:33Z", "message": "restore logging level"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "414905cd08fe8154f83451638aef23032c63f55e", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/414905cd08fe8154f83451638aef23032c63f55e", "committedDate": "2020-01-14T23:18:44Z", "message": "Fox in mocks our game is done sir"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9020032cc65f7e0fed788de49c36e3b80a015d5b", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/9020032cc65f7e0fed788de49c36e3b80a015d5b", "committedDate": "2020-01-15T02:30:34Z", "message": "spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be70469b636474e31867c108b5c8cd7b86d103eb", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/be70469b636474e31867c108b5c8cd7b86d103eb", "committedDate": "2020-01-15T17:05:46Z", "message": "merge master && switch set to list to match view.create signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a8c6c85d4ba54a996f29e462bdcc0c866c4acd4", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/8a8c6c85d4ba54a996f29e462bdcc0c866c4acd4", "committedDate": "2020-01-15T17:47:17Z", "message": "test tweak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfab77676c8621f7efa687f8cd53afd5d77861a9", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/dfab77676c8621f7efa687f8cd53afd5d77861a9", "committedDate": "2020-01-16T17:54:31Z", "message": "initial stab at ruby script"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c7fd01b59d929d7ea7e9c3e463dc339eb361b85", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/3c7fd01b59d929d7ea7e9c3e463dc339eb361b85", "committedDate": "2020-01-16T20:15:18Z", "message": "Merge branch 'master' into jaycarlton/RW-3918"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "462a8e9707fc9141f714b34fe676b2a0a22ecc66", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/462a8e9707fc9141f714b34fe676b2a0a22ecc66", "committedDate": "2020-02-20T18:58:57Z", "message": "merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12b278eef8be7555e829f636ab2246e4a7fd4800", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/12b278eef8be7555e829f636ab2246e4a7fd4800", "committedDate": "2020-02-20T19:03:55Z", "message": "move"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fab456c2b640ea1f4c29a7fda6e201e8205535ee", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/fab456c2b640ea1f4c29a7fda6e201e8205535ee", "committedDate": "2020-02-20T20:33:52Z", "message": "moved from other repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55c35fa8f7808db436afa9680e7bf71c145fb8a2", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/55c35fa8f7808db436afa9680e7bf71c145fb8a2", "committedDate": "2020-02-20T20:50:46Z", "message": "add .gitignore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7791bc21a73a43d4cfdd018020b52283ec91c718", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/7791bc21a73a43d4cfdd018020b52283ec91c718", "committedDate": "2020-02-20T23:04:11Z", "message": "progress...not quite right I don't think"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54be97b7698762dd9f595b2c3074e6b05555e9bc", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/54be97b7698762dd9f595b2c3074e6b05555e9bc", "committedDate": "2020-02-23T16:21:56Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1da257512bc0ff75926ff893e1ef0f9b42b1d61", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/a1da257512bc0ff75926ff893e1ef0f9b42b1d61", "committedDate": "2020-02-23T16:22:15Z", "message": "merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25c165657a3c93cb8082d5fe2ce5b76825521ae0", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/25c165657a3c93cb8082d5fe2ce5b76825521ae0", "committedDate": "2020-02-23T16:22:30Z", "message": "credentials path"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72364a5d9a15aa4b647084de7ab04509d7335279", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/72364a5d9a15aa4b647084de7ab04509d7335279", "committedDate": "2020-02-23T16:33:59Z", "message": "removing common"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a5220146e0c95e3fdd239d9b1dd101fd2e880df", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/6a5220146e0c95e3fdd239d9b1dd101fd2e880df", "committedDate": "2020-02-24T01:45:13Z", "message": "first mostly working version, setting all the SA's and not depending on any utils or project.rb code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17af8716fa0aef07d6a2689afdd22bce3a638338", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/17af8716fa0aef07d6a2689afdd22bce3a638338", "committedDate": "2020-02-24T01:50:30Z", "message": "fixes & updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa61a0defade2f4053ed1e263a20936c345fadd5", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/aa61a0defade2f4053ed1e263a20936c345fadd5", "committedDate": "2020-02-24T02:24:24Z", "message": "more counting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef4bf5d87f4edcf9c3f2079ae991a3935fa94004", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/ef4bf5d87f4edcf9c3f2079ae991a3935fa94004", "committedDate": "2020-02-24T14:08:43Z", "message": "remove stuff for later and organize a bit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d4393d093b4653b0a7eccebade7544e17248682", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/0d4393d093b4653b0a7eccebade7544e17248682", "committedDate": "2020-02-24T14:26:55Z", "message": "only one script in whole framework"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "044747dc026e5f2a1bebc92560f086a8de219469", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/044747dc026e5f2a1bebc92560f086a8de219469", "committedDate": "2020-02-24T15:35:42Z", "message": "docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b9ace2651ce543e2f2c6f1336de1ca46ad9cbfb", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/2b9ace2651ce543e2f2c6f1336de1ca46ad9cbfb", "committedDate": "2020-02-24T15:39:39Z", "message": "link to devops docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7931e1620905967ddcd3d3d55a9c4cf05a61d4ce", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/7931e1620905967ddcd3d3d55a9c4cf05a61d4ce", "committedDate": "2020-02-24T15:48:31Z", "message": "gem reqs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ab076f6089b515d3a5f916eb3959393409dc3b2", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/2ab076f6089b515d3a5f916eb3959393409dc3b2", "committedDate": "2020-02-24T20:20:48Z", "message": "add options parser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91172c58e451a63ba540de6ee1fd23aa73198e84", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/91172c58e451a63ba540de6ee1fd23aa73198e84", "committedDate": "2020-02-24T20:31:27Z", "message": "handle missing  parameters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5f49c90e5912e7137ed3f8ede63a5f2c94a381f", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/b5f49c90e5912e7137ed3f8ede63a5f2c94a381f", "committedDate": "2020-02-25T16:39:59Z", "message": "manage extra SA keys cleanly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0379ab140c65586ec82310490f6241c62e68dd5", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/a0379ab140c65586ec82310490f6241c62e68dd5", "committedDate": "2020-02-25T18:18:18Z", "message": "replicate log entry is working"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f105dc681faa33a4a296750111944e84de4848d", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/9f105dc681faa33a4a296750111944e84de4848d", "committedDate": "2020-02-25T19:09:32Z", "message": "misc fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b42a27cd08826901a2a0900b5225dfbfc59575f3", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/b42a27cd08826901a2a0900b5225dfbfc59575f3", "committedDate": "2020-02-25T23:31:29Z", "message": "renames and some simplifications"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "891e9a6e60b61d5d8324745026e1c393ec2680a4", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/891e9a6e60b61d5d8324745026e1c393ec2680a4", "committedDate": "2020-02-25T23:44:24Z", "message": "help stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "538dcfb8e73530e132cd73d34592363de6ea5294", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/538dcfb8e73530e132cd73d34592363de6ea5294", "committedDate": "2020-02-26T13:40:01Z", "message": "PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ecd57926b8d6ea67c7eeb10d47bbe7a95a086f4", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/1ecd57926b8d6ea67c7eeb10d47bbe7a95a086f4", "committedDate": "2020-02-26T17:38:12Z", "message": "merge changes from RW-3918"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa0d9a55fc8aa89836a462486cced408ba2189de", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/fa0d9a55fc8aa89836a462486cced408ba2189de", "committedDate": "2020-02-26T19:59:49Z", "message": "more ruby goodness"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e578b7eb43f07cae00da462657c47ef25736ef5", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/9e578b7eb43f07cae00da462657c47ef25736ef5", "committedDate": "2020-02-27T21:39:43Z", "message": "refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19bbc02ae564f197ffafe8b764cd1e2fd8427223", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/19bbc02ae564f197ffafe8b764cd1e2fd8427223", "committedDate": "2020-02-27T22:39:52Z", "message": "merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "535284bc003a552ba5dc00e5613ba58ef8149c8c", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/535284bc003a552ba5dc00e5613ba58ef8149c8c", "committedDate": "2020-02-28T15:59:59Z", "message": "fixup merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a83e95f3d0f499a887b5ca6724a4a84518e9eb09", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/a83e95f3d0f499a887b5ca6724a4a84518e9eb09", "committedDate": "2020-02-28T16:13:27Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6569b3c5499f380754f3553157f89f1a5418c514", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/6569b3c5499f380754f3553157f89f1a5418c514", "committedDate": "2020-02-28T17:49:42Z", "message": "first working-ish version of replicate dash"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b891cd1443f307797d9c6be262fb79ad6da4652e", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/b891cd1443f307797d9c6be262fb79ad6da4652e", "committedDate": "2020-02-28T19:20:45Z", "message": "merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a025ba4976d2262c75d8cb4438383cce0e76476f", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/a025ba4976d2262c75d8cb4438383cce0e76476f", "committedDate": "2020-02-28T19:29:11Z", "message": "kill duplicated file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60f8038979379d38beb11bf501a396355036fd7e", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/60f8038979379d38beb11bf501a396355036fd7e", "committedDate": "2020-03-09T12:45:55Z", "message": "merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/32b2bedf444dfdea28edb81318a81721ef9df992", "committedDate": "2020-03-09T12:52:42Z", "message": "codacy fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzA1NzI0", "url": "https://github.com/all-of-us/workbench/pull/3203#pullrequestreview-371305724", "createdAt": "2020-03-09T15:52:58Z", "commit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo1Mjo1OFrOFzugBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjoyNzoxOVrOFzv5gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4MzU1Nw==", "bodyText": "nit: in in -> in", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389783557", "createdAt": "2020-03-09T15:52:58Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/devops.rb", "diffHunk": "@@ -0,0 +1,75 @@\n+#!/usr/bin/env ruby\n+\n+require 'logger'\n+require 'optparse'\n+require 'ostruct'\n+\n+require_relative 'tasks/monitoring_assets'\n+require_relative 'tasks/dashboards'\n+require_relative 'tasks/logs_based_metrics'\n+require_relative 'tasks/service_accounts'\n+\n+# Single entry point for the devops framework. This is the only true Ruby Script file. The\n+# rest are classes.\n+#\n+# Based on input commands, this script delegates the work to  a task class, which should not need to\n+# know anything about environment variables such as ARGV, the run directory,  etc. Tasks should also avoid\n+# global variables like `logger`, so that we can control logging preferences from the top level.\n+\n+# TODO(jaycarlton): work out a scheme for task-specific options (i.e. subcommands)\n+def parse_options\n+  # options = OpenStruct.new\n+  # options.dry_run = true\n+  # options.envs_file = ENV['DEVOPS_TOOLKIT_ENVIRONMENTS_FILE']\n+  options = {}\n+  OptionParser.new do |parser|\n+    parser.on('-t', '--task [TASK]', String, 'Task to be in in each environment')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4Mzc0MQ==", "bodyText": "are the comments needed?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389783741", "createdAt": "2020-03-09T15:53:13Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/devops.rb", "diffHunk": "@@ -0,0 +1,75 @@\n+#!/usr/bin/env ruby\n+\n+require 'logger'\n+require 'optparse'\n+require 'ostruct'\n+\n+require_relative 'tasks/monitoring_assets'\n+require_relative 'tasks/dashboards'\n+require_relative 'tasks/logs_based_metrics'\n+require_relative 'tasks/service_accounts'\n+\n+# Single entry point for the devops framework. This is the only true Ruby Script file. The\n+# rest are classes.\n+#\n+# Based on input commands, this script delegates the work to  a task class, which should not need to\n+# know anything about environment variables such as ARGV, the run directory,  etc. Tasks should also avoid\n+# global variables like `logger`, so that we can control logging preferences from the top level.\n+\n+# TODO(jaycarlton): work out a scheme for task-specific options (i.e. subcommands)\n+def parse_options\n+  # options = OpenStruct.new", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NDAwNg==", "bodyText": "what does this argument do?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389784006", "createdAt": "2020-03-09T15:53:33Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/devops.rb", "diffHunk": "@@ -0,0 +1,75 @@\n+#!/usr/bin/env ruby\n+\n+require 'logger'\n+require 'optparse'\n+require 'ostruct'\n+\n+require_relative 'tasks/monitoring_assets'\n+require_relative 'tasks/dashboards'\n+require_relative 'tasks/logs_based_metrics'\n+require_relative 'tasks/service_accounts'\n+\n+# Single entry point for the devops framework. This is the only true Ruby Script file. The\n+# rest are classes.\n+#\n+# Based on input commands, this script delegates the work to  a task class, which should not need to\n+# know anything about environment variables such as ARGV, the run directory,  etc. Tasks should also avoid\n+# global variables like `logger`, so that we can control logging preferences from the top level.\n+\n+# TODO(jaycarlton): work out a scheme for task-specific options (i.e. subcommands)\n+def parse_options\n+  # options = OpenStruct.new\n+  # options.dry_run = true\n+  # options.envs_file = ENV['DEVOPS_TOOLKIT_ENVIRONMENTS_FILE']\n+  options = {}\n+  OptionParser.new do |parser|\n+    parser.on('-t', '--task [TASK]', String, 'Task to be in in each environment')\n+    parser.on('-x', '--require XYLOPHONE', 'xylophone')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NDk0Mg==", "bodyText": "I'd add an example to the comments for this arg and envs-file since environment can be an ambiguous term.", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389784942", "createdAt": "2020-03-09T15:54:57Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/devops.rb", "diffHunk": "@@ -0,0 +1,75 @@\n+#!/usr/bin/env ruby\n+\n+require 'logger'\n+require 'optparse'\n+require 'ostruct'\n+\n+require_relative 'tasks/monitoring_assets'\n+require_relative 'tasks/dashboards'\n+require_relative 'tasks/logs_based_metrics'\n+require_relative 'tasks/service_accounts'\n+\n+# Single entry point for the devops framework. This is the only true Ruby Script file. The\n+# rest are classes.\n+#\n+# Based on input commands, this script delegates the work to  a task class, which should not need to\n+# know anything about environment variables such as ARGV, the run directory,  etc. Tasks should also avoid\n+# global variables like `logger`, so that we can control logging preferences from the top level.\n+\n+# TODO(jaycarlton): work out a scheme for task-specific options (i.e. subcommands)\n+def parse_options\n+  # options = OpenStruct.new\n+  # options.dry_run = true\n+  # options.envs_file = ENV['DEVOPS_TOOLKIT_ENVIRONMENTS_FILE']\n+  options = {}\n+  OptionParser.new do |parser|\n+    parser.on('-t', '--task [TASK]', String, 'Task to be in in each environment')\n+    parser.on('-x', '--require XYLOPHONE', 'xylophone')\n+    parser.on('-e', '--envs-file [ENVS]', String, 'Path to environments JSON file.')\n+    parser.on('-s', '--source-uri [SOURCE-URI]', String, 'URI or FQ name for source asset')\n+    parser.on('-u', '--source-env [SOURCE-ENV]', String, 'Short name for source Environment (lowercase)')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MDcxMw==", "bodyText": "necessary comment?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389790713", "createdAt": "2020-03-09T16:03:19Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "diffHunk": "@@ -0,0 +1,153 @@\n+require 'google/cloud/monitoring/dashboard/v1'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+class Dashboards\n+  RESOURCE_NAMESPACE_PATTERN = /resource.label.\"namespace\"=\"\\w+\"/\n+  CUSTOM_DASHBOARD_FILTER = \"dashboard.name = starts_with(\\\"custom.googleapis.com/\\\")\"\n+\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'dry-run']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  # List all the custom dashboards in each environment\n+  def list\n+    @visitor.visit do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      dashboard_client.list_dashboards(env.formatted_project_number).each do |dash|\n+        @logger.info(\"#{dash.display_name}\\t#{self.class.dashboard_console_link(dash, env.project_id)}\")\n+        @logger.info(dash.to_json)\n+        dash.grid_layout.widgets.each do |widget|\n+          @logger.info(\"\\tChart \\\"#{widget.title}\\\"\")\n+        end\n+      end\n+    end\n+  end\n+\n+  # Take a dashboard from the source environment, tweak it for each target environment, and\n+  # create a copy.\n+  # TODO(jaycarlton) We have two replicate tasks already, and the pattern vis-a-vis the visitor\n+  # is the same. So we can think about making this replication visiting pattern part of the visitor\n+  # itself, or otherwise genericker than it is currently.\n+  def replicate\n+    source_dashboard = get_source_dashboard\n+    @logger.info(\"Retrieved source dashboard #{source_dashboard.to_json}\")\n+    copy_to_target_envs(source_dashboard)\n+  end\n+\n+  # Construct a link to the monitoring console. Note that in the IntelliJ debugger console,\n+  # these are clickable links. I don't see this out of the box in my OS's terminal though.\n+  def self.dashboard_console_link(dashboard, project_id)\n+    \"https://console.cloud.google.com/monitoring/dashboards/custom/#{dashboard_number(dashboard)}\" +\n+        \"?project=#{project_id}\"\n+  end\n+\n+  # The dashboard link requires the number to the far right in the name,\n+  # which  is formated like projects/<project_number>/dashboards/<dashboard_number>\n+  def self.dashboard_number(dashboard)\n+    dashboard.name.split('/')[-1]\n+  end\n+\n+  # Create the resource string/URI for a dashboard. The API expects the format\n+  # projects/{project_id_or_number}/dashboards/{dashboard_id}\n+  def self.dashboard_resource_path(env, dashboard_number)\n+    \"projects/#{env.project_number}/dashboards/#{dashboard_number}\"\n+  end\n+\n+  # Return true if this dashbaord is already present in the current environment.\n+  # Irritatingly, we can't just just get_dashboard for this, as it throws an exception if\n+  # it's not found.\n+  def self.dashboard_exists?(dashboard_client, env, dashboard_name)\n+    # all = dashboard_client.list_dashboards(env.formatted_project_number, filter: CUSTOM_DASHBOARD_FILTER)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MDc2NA==", "bodyText": "necessary comment?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389790764", "createdAt": "2020-03-09T16:03:25Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "diffHunk": "@@ -0,0 +1,153 @@\n+require 'google/cloud/monitoring/dashboard/v1'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+class Dashboards\n+  RESOURCE_NAMESPACE_PATTERN = /resource.label.\"namespace\"=\"\\w+\"/\n+  CUSTOM_DASHBOARD_FILTER = \"dashboard.name = starts_with(\\\"custom.googleapis.com/\\\")\"\n+\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'dry-run']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  # List all the custom dashboards in each environment\n+  def list\n+    @visitor.visit do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      dashboard_client.list_dashboards(env.formatted_project_number).each do |dash|\n+        @logger.info(\"#{dash.display_name}\\t#{self.class.dashboard_console_link(dash, env.project_id)}\")\n+        @logger.info(dash.to_json)\n+        dash.grid_layout.widgets.each do |widget|\n+          @logger.info(\"\\tChart \\\"#{widget.title}\\\"\")\n+        end\n+      end\n+    end\n+  end\n+\n+  # Take a dashboard from the source environment, tweak it for each target environment, and\n+  # create a copy.\n+  # TODO(jaycarlton) We have two replicate tasks already, and the pattern vis-a-vis the visitor\n+  # is the same. So we can think about making this replication visiting pattern part of the visitor\n+  # itself, or otherwise genericker than it is currently.\n+  def replicate\n+    source_dashboard = get_source_dashboard\n+    @logger.info(\"Retrieved source dashboard #{source_dashboard.to_json}\")\n+    copy_to_target_envs(source_dashboard)\n+  end\n+\n+  # Construct a link to the monitoring console. Note that in the IntelliJ debugger console,\n+  # these are clickable links. I don't see this out of the box in my OS's terminal though.\n+  def self.dashboard_console_link(dashboard, project_id)\n+    \"https://console.cloud.google.com/monitoring/dashboards/custom/#{dashboard_number(dashboard)}\" +\n+        \"?project=#{project_id}\"\n+  end\n+\n+  # The dashboard link requires the number to the far right in the name,\n+  # which  is formated like projects/<project_number>/dashboards/<dashboard_number>\n+  def self.dashboard_number(dashboard)\n+    dashboard.name.split('/')[-1]\n+  end\n+\n+  # Create the resource string/URI for a dashboard. The API expects the format\n+  # projects/{project_id_or_number}/dashboards/{dashboard_id}\n+  def self.dashboard_resource_path(env, dashboard_number)\n+    \"projects/#{env.project_number}/dashboards/#{dashboard_number}\"\n+  end\n+\n+  # Return true if this dashbaord is already present in the current environment.\n+  # Irritatingly, we can't just just get_dashboard for this, as it throws an exception if\n+  # it's not found.\n+  def self.dashboard_exists?(dashboard_client, env, dashboard_name)\n+    # all = dashboard_client.list_dashboards(env.formatted_project_number, filter: CUSTOM_DASHBOARD_FILTER)\n+    all = dashboard_client.list_dashboards(env.formatted_project_number)\n+    all.any? { |dash| dash.name == dashboard_name }\n+  end\n+\n+  private\n+\n+  def get_source_dashboard\n+    source_env = @visitor.env_map[@source_env_short_name]\n+    # source_env = @visitor.env_by_short_name(@source_env_short_name)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MjIzNQ==", "bodyText": "the visitor makes it seem like we're visiting multiple environments but only the last one is being returned as part of result. Is it just visiting one environment every time this is invoked?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389792235", "createdAt": "2020-03-09T16:05:39Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "diffHunk": "@@ -0,0 +1,153 @@\n+require 'google/cloud/monitoring/dashboard/v1'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+class Dashboards\n+  RESOURCE_NAMESPACE_PATTERN = /resource.label.\"namespace\"=\"\\w+\"/\n+  CUSTOM_DASHBOARD_FILTER = \"dashboard.name = starts_with(\\\"custom.googleapis.com/\\\")\"\n+\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'dry-run']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  # List all the custom dashboards in each environment\n+  def list\n+    @visitor.visit do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      dashboard_client.list_dashboards(env.formatted_project_number).each do |dash|\n+        @logger.info(\"#{dash.display_name}\\t#{self.class.dashboard_console_link(dash, env.project_id)}\")\n+        @logger.info(dash.to_json)\n+        dash.grid_layout.widgets.each do |widget|\n+          @logger.info(\"\\tChart \\\"#{widget.title}\\\"\")\n+        end\n+      end\n+    end\n+  end\n+\n+  # Take a dashboard from the source environment, tweak it for each target environment, and\n+  # create a copy.\n+  # TODO(jaycarlton) We have two replicate tasks already, and the pattern vis-a-vis the visitor\n+  # is the same. So we can think about making this replication visiting pattern part of the visitor\n+  # itself, or otherwise genericker than it is currently.\n+  def replicate\n+    source_dashboard = get_source_dashboard\n+    @logger.info(\"Retrieved source dashboard #{source_dashboard.to_json}\")\n+    copy_to_target_envs(source_dashboard)\n+  end\n+\n+  # Construct a link to the monitoring console. Note that in the IntelliJ debugger console,\n+  # these are clickable links. I don't see this out of the box in my OS's terminal though.\n+  def self.dashboard_console_link(dashboard, project_id)\n+    \"https://console.cloud.google.com/monitoring/dashboards/custom/#{dashboard_number(dashboard)}\" +\n+        \"?project=#{project_id}\"\n+  end\n+\n+  # The dashboard link requires the number to the far right in the name,\n+  # which  is formated like projects/<project_number>/dashboards/<dashboard_number>\n+  def self.dashboard_number(dashboard)\n+    dashboard.name.split('/')[-1]\n+  end\n+\n+  # Create the resource string/URI for a dashboard. The API expects the format\n+  # projects/{project_id_or_number}/dashboards/{dashboard_id}\n+  def self.dashboard_resource_path(env, dashboard_number)\n+    \"projects/#{env.project_number}/dashboards/#{dashboard_number}\"\n+  end\n+\n+  # Return true if this dashbaord is already present in the current environment.\n+  # Irritatingly, we can't just just get_dashboard for this, as it throws an exception if\n+  # it's not found.\n+  def self.dashboard_exists?(dashboard_client, env, dashboard_name)\n+    # all = dashboard_client.list_dashboards(env.formatted_project_number, filter: CUSTOM_DASHBOARD_FILTER)\n+    all = dashboard_client.list_dashboards(env.formatted_project_number)\n+    all.any? { |dash| dash.name == dashboard_name }\n+  end\n+\n+  private\n+\n+  def get_source_dashboard\n+    source_env = @visitor.env_map[@source_env_short_name]\n+    # source_env = @visitor.env_by_short_name(@source_env_short_name)\n+    result = nil\n+    @visitor.visit(source_env) do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      source_dashboard_path = self.class.dashboard_resource_path(env, @source_dashboard_number)\n+      result = dashboard_client.get_dashboard(source_dashboard_path)\n+      @logger.info(\"Template dashboard: display_name: #{result.display_name}, name: #{result.name}\")\n+      @logger.info(result)\n+    end\n+    result", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MjQwMQ==", "bodyText": "necessary comment?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389792401", "createdAt": "2020-03-09T16:05:56Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "diffHunk": "@@ -0,0 +1,153 @@\n+require 'google/cloud/monitoring/dashboard/v1'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+class Dashboards\n+  RESOURCE_NAMESPACE_PATTERN = /resource.label.\"namespace\"=\"\\w+\"/\n+  CUSTOM_DASHBOARD_FILTER = \"dashboard.name = starts_with(\\\"custom.googleapis.com/\\\")\"\n+\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'dry-run']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  # List all the custom dashboards in each environment\n+  def list\n+    @visitor.visit do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      dashboard_client.list_dashboards(env.formatted_project_number).each do |dash|\n+        @logger.info(\"#{dash.display_name}\\t#{self.class.dashboard_console_link(dash, env.project_id)}\")\n+        @logger.info(dash.to_json)\n+        dash.grid_layout.widgets.each do |widget|\n+          @logger.info(\"\\tChart \\\"#{widget.title}\\\"\")\n+        end\n+      end\n+    end\n+  end\n+\n+  # Take a dashboard from the source environment, tweak it for each target environment, and\n+  # create a copy.\n+  # TODO(jaycarlton) We have two replicate tasks already, and the pattern vis-a-vis the visitor\n+  # is the same. So we can think about making this replication visiting pattern part of the visitor\n+  # itself, or otherwise genericker than it is currently.\n+  def replicate\n+    source_dashboard = get_source_dashboard\n+    @logger.info(\"Retrieved source dashboard #{source_dashboard.to_json}\")\n+    copy_to_target_envs(source_dashboard)\n+  end\n+\n+  # Construct a link to the monitoring console. Note that in the IntelliJ debugger console,\n+  # these are clickable links. I don't see this out of the box in my OS's terminal though.\n+  def self.dashboard_console_link(dashboard, project_id)\n+    \"https://console.cloud.google.com/monitoring/dashboards/custom/#{dashboard_number(dashboard)}\" +\n+        \"?project=#{project_id}\"\n+  end\n+\n+  # The dashboard link requires the number to the far right in the name,\n+  # which  is formated like projects/<project_number>/dashboards/<dashboard_number>\n+  def self.dashboard_number(dashboard)\n+    dashboard.name.split('/')[-1]\n+  end\n+\n+  # Create the resource string/URI for a dashboard. The API expects the format\n+  # projects/{project_id_or_number}/dashboards/{dashboard_id}\n+  def self.dashboard_resource_path(env, dashboard_number)\n+    \"projects/#{env.project_number}/dashboards/#{dashboard_number}\"\n+  end\n+\n+  # Return true if this dashbaord is already present in the current environment.\n+  # Irritatingly, we can't just just get_dashboard for this, as it throws an exception if\n+  # it's not found.\n+  def self.dashboard_exists?(dashboard_client, env, dashboard_name)\n+    # all = dashboard_client.list_dashboards(env.formatted_project_number, filter: CUSTOM_DASHBOARD_FILTER)\n+    all = dashboard_client.list_dashboards(env.formatted_project_number)\n+    all.any? { |dash| dash.name == dashboard_name }\n+  end\n+\n+  private\n+\n+  def get_source_dashboard\n+    source_env = @visitor.env_map[@source_env_short_name]\n+    # source_env = @visitor.env_by_short_name(@source_env_short_name)\n+    result = nil\n+    @visitor.visit(source_env) do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      source_dashboard_path = self.class.dashboard_resource_path(env, @source_dashboard_number)\n+      result = dashboard_client.get_dashboard(source_dashboard_path)\n+      @logger.info(\"Template dashboard: display_name: #{result.display_name}, name: #{result.name}\")\n+      @logger.info(result)\n+    end\n+    result\n+  end\n+\n+  def copy_to_target_envs(source_dashboard)\n+    target_envs = @visitor.target_envs(@source_env_short_name) # environments.select { |env| env.short_name != @source_env_short_name }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5Mzc5Mg==", "bodyText": "comment?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389793792", "createdAt": "2020-03-09T16:08:06Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "diffHunk": "@@ -0,0 +1,153 @@\n+require 'google/cloud/monitoring/dashboard/v1'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+class Dashboards\n+  RESOURCE_NAMESPACE_PATTERN = /resource.label.\"namespace\"=\"\\w+\"/\n+  CUSTOM_DASHBOARD_FILTER = \"dashboard.name = starts_with(\\\"custom.googleapis.com/\\\")\"\n+\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'dry-run']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  # List all the custom dashboards in each environment\n+  def list\n+    @visitor.visit do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      dashboard_client.list_dashboards(env.formatted_project_number).each do |dash|\n+        @logger.info(\"#{dash.display_name}\\t#{self.class.dashboard_console_link(dash, env.project_id)}\")\n+        @logger.info(dash.to_json)\n+        dash.grid_layout.widgets.each do |widget|\n+          @logger.info(\"\\tChart \\\"#{widget.title}\\\"\")\n+        end\n+      end\n+    end\n+  end\n+\n+  # Take a dashboard from the source environment, tweak it for each target environment, and\n+  # create a copy.\n+  # TODO(jaycarlton) We have two replicate tasks already, and the pattern vis-a-vis the visitor\n+  # is the same. So we can think about making this replication visiting pattern part of the visitor\n+  # itself, or otherwise genericker than it is currently.\n+  def replicate\n+    source_dashboard = get_source_dashboard\n+    @logger.info(\"Retrieved source dashboard #{source_dashboard.to_json}\")\n+    copy_to_target_envs(source_dashboard)\n+  end\n+\n+  # Construct a link to the monitoring console. Note that in the IntelliJ debugger console,\n+  # these are clickable links. I don't see this out of the box in my OS's terminal though.\n+  def self.dashboard_console_link(dashboard, project_id)\n+    \"https://console.cloud.google.com/monitoring/dashboards/custom/#{dashboard_number(dashboard)}\" +\n+        \"?project=#{project_id}\"\n+  end\n+\n+  # The dashboard link requires the number to the far right in the name,\n+  # which  is formated like projects/<project_number>/dashboards/<dashboard_number>\n+  def self.dashboard_number(dashboard)\n+    dashboard.name.split('/')[-1]\n+  end\n+\n+  # Create the resource string/URI for a dashboard. The API expects the format\n+  # projects/{project_id_or_number}/dashboards/{dashboard_id}\n+  def self.dashboard_resource_path(env, dashboard_number)\n+    \"projects/#{env.project_number}/dashboards/#{dashboard_number}\"\n+  end\n+\n+  # Return true if this dashbaord is already present in the current environment.\n+  # Irritatingly, we can't just just get_dashboard for this, as it throws an exception if\n+  # it's not found.\n+  def self.dashboard_exists?(dashboard_client, env, dashboard_name)\n+    # all = dashboard_client.list_dashboards(env.formatted_project_number, filter: CUSTOM_DASHBOARD_FILTER)\n+    all = dashboard_client.list_dashboards(env.formatted_project_number)\n+    all.any? { |dash| dash.name == dashboard_name }\n+  end\n+\n+  private\n+\n+  def get_source_dashboard\n+    source_env = @visitor.env_map[@source_env_short_name]\n+    # source_env = @visitor.env_by_short_name(@source_env_short_name)\n+    result = nil\n+    @visitor.visit(source_env) do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      source_dashboard_path = self.class.dashboard_resource_path(env, @source_dashboard_number)\n+      result = dashboard_client.get_dashboard(source_dashboard_path)\n+      @logger.info(\"Template dashboard: display_name: #{result.display_name}, name: #{result.name}\")\n+      @logger.info(result)\n+    end\n+    result\n+  end\n+\n+  def copy_to_target_envs(source_dashboard)\n+    target_envs = @visitor.target_envs(@source_env_short_name) # environments.select { |env| env.short_name != @source_env_short_name }\n+    @visitor.visit(target_envs) do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+\n+      # Need to perform existence check with new environment's project number in the resource path.\n+      target_resource_path = self.class.dashboard_resource_path(env, self.class.dashboard_number(source_dashboard))\n+      if self.class.dashboard_exists?(dashboard_client, env, target_resource_path)\n+        @logger.warn(\"Skipping target env #{env.short_name} as #{source_dashboard.name} is already there.\")\n+        next\n+      end\n+\n+      # Customize this dashboard for the current environment. Typically this means setting the\n+      # namespace properly in all the charts and/or adjusting the title.\n+      replacement_dashboard = build_replacement_dashboard(env, source_dashboard, target_resource_path)\n+\n+      # add the dashboard to the project\n+      @logger.info(\"creating with parent: #{env.formatted_project_number}, dashboard name: #{replacement_dashboard.name}\")\n+      dashboard_client.create_dashboard(env.formatted_project_number, replacement_dashboard) do |created_dash|\n+        @logger.info(\"created dashboard: #{created_dash.to_json}\")\n+      end\n+    end\n+  end\n+\n+  def build_replacement_dashboard(env, source_dashboard, target_resource_path)\n+    # result = Google::Monitoring::Dashboard::V1::Dashboard.new", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5Mzg0OA==", "bodyText": "comment?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389793848", "createdAt": "2020-03-09T16:08:12Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "diffHunk": "@@ -0,0 +1,153 @@\n+require 'google/cloud/monitoring/dashboard/v1'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+class Dashboards\n+  RESOURCE_NAMESPACE_PATTERN = /resource.label.\"namespace\"=\"\\w+\"/\n+  CUSTOM_DASHBOARD_FILTER = \"dashboard.name = starts_with(\\\"custom.googleapis.com/\\\")\"\n+\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'dry-run']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  # List all the custom dashboards in each environment\n+  def list\n+    @visitor.visit do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      dashboard_client.list_dashboards(env.formatted_project_number).each do |dash|\n+        @logger.info(\"#{dash.display_name}\\t#{self.class.dashboard_console_link(dash, env.project_id)}\")\n+        @logger.info(dash.to_json)\n+        dash.grid_layout.widgets.each do |widget|\n+          @logger.info(\"\\tChart \\\"#{widget.title}\\\"\")\n+        end\n+      end\n+    end\n+  end\n+\n+  # Take a dashboard from the source environment, tweak it for each target environment, and\n+  # create a copy.\n+  # TODO(jaycarlton) We have two replicate tasks already, and the pattern vis-a-vis the visitor\n+  # is the same. So we can think about making this replication visiting pattern part of the visitor\n+  # itself, or otherwise genericker than it is currently.\n+  def replicate\n+    source_dashboard = get_source_dashboard\n+    @logger.info(\"Retrieved source dashboard #{source_dashboard.to_json}\")\n+    copy_to_target_envs(source_dashboard)\n+  end\n+\n+  # Construct a link to the monitoring console. Note that in the IntelliJ debugger console,\n+  # these are clickable links. I don't see this out of the box in my OS's terminal though.\n+  def self.dashboard_console_link(dashboard, project_id)\n+    \"https://console.cloud.google.com/monitoring/dashboards/custom/#{dashboard_number(dashboard)}\" +\n+        \"?project=#{project_id}\"\n+  end\n+\n+  # The dashboard link requires the number to the far right in the name,\n+  # which  is formated like projects/<project_number>/dashboards/<dashboard_number>\n+  def self.dashboard_number(dashboard)\n+    dashboard.name.split('/')[-1]\n+  end\n+\n+  # Create the resource string/URI for a dashboard. The API expects the format\n+  # projects/{project_id_or_number}/dashboards/{dashboard_id}\n+  def self.dashboard_resource_path(env, dashboard_number)\n+    \"projects/#{env.project_number}/dashboards/#{dashboard_number}\"\n+  end\n+\n+  # Return true if this dashbaord is already present in the current environment.\n+  # Irritatingly, we can't just just get_dashboard for this, as it throws an exception if\n+  # it's not found.\n+  def self.dashboard_exists?(dashboard_client, env, dashboard_name)\n+    # all = dashboard_client.list_dashboards(env.formatted_project_number, filter: CUSTOM_DASHBOARD_FILTER)\n+    all = dashboard_client.list_dashboards(env.formatted_project_number)\n+    all.any? { |dash| dash.name == dashboard_name }\n+  end\n+\n+  private\n+\n+  def get_source_dashboard\n+    source_env = @visitor.env_map[@source_env_short_name]\n+    # source_env = @visitor.env_by_short_name(@source_env_short_name)\n+    result = nil\n+    @visitor.visit(source_env) do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      source_dashboard_path = self.class.dashboard_resource_path(env, @source_dashboard_number)\n+      result = dashboard_client.get_dashboard(source_dashboard_path)\n+      @logger.info(\"Template dashboard: display_name: #{result.display_name}, name: #{result.name}\")\n+      @logger.info(result)\n+    end\n+    result\n+  end\n+\n+  def copy_to_target_envs(source_dashboard)\n+    target_envs = @visitor.target_envs(@source_env_short_name) # environments.select { |env| env.short_name != @source_env_short_name }\n+    @visitor.visit(target_envs) do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+\n+      # Need to perform existence check with new environment's project number in the resource path.\n+      target_resource_path = self.class.dashboard_resource_path(env, self.class.dashboard_number(source_dashboard))\n+      if self.class.dashboard_exists?(dashboard_client, env, target_resource_path)\n+        @logger.warn(\"Skipping target env #{env.short_name} as #{source_dashboard.name} is already there.\")\n+        next\n+      end\n+\n+      # Customize this dashboard for the current environment. Typically this means setting the\n+      # namespace properly in all the charts and/or adjusting the title.\n+      replacement_dashboard = build_replacement_dashboard(env, source_dashboard, target_resource_path)\n+\n+      # add the dashboard to the project\n+      @logger.info(\"creating with parent: #{env.formatted_project_number}, dashboard name: #{replacement_dashboard.name}\")\n+      dashboard_client.create_dashboard(env.formatted_project_number, replacement_dashboard) do |created_dash|\n+        @logger.info(\"created dashboard: #{created_dash.to_json}\")\n+      end\n+    end\n+  end\n+\n+  def build_replacement_dashboard(env, source_dashboard, target_resource_path)\n+    # result = Google::Monitoring::Dashboard::V1::Dashboard.new\n+    source_dashboard.freeze # avoid contaminating our source dashboard\n+    result = source_dashboard.dup\n+    result.etag = '' # populated by the create API\n+    result.name = target_resource_path\n+    # result.grid_layout = Google::Monitoring::Dashboard::V1::GridLayout.new", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwNDc2Mg==", "bodyText": "how does a metric's name relate to a dashboard number?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389804762", "createdAt": "2020-03-09T16:25:02Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/logs_based_metrics.rb", "diffHunk": "@@ -0,0 +1,68 @@\n+require 'google/cloud/logging'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+# Take a source environment and logs-based metric URI and replicate it across all target environments\n+# Note well: if two environments share a GCP project, this means they share a metrics namespace.\n+# If those projects share a log file (distinguished by MonitoredResource), then we dont' want to duplicate\n+# a metric into that shared environment.\n+class LogsBasedMetrics\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'replicate']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  def replicate\n+    # Visit the source environment and smuggle out a metric definition\n+    source_metric = get_source_metric\n+\n+    # Replicate to the other environments (all but source env)\n+    copy_to_target_envs(source_metric)\n+  end\n+\n+  private\n+\n+  # Fetch the source metric by name from the source environment\n+  def get_source_metric\n+    source_env = @visitor.env_by_short_name(@source_env_short_name)\n+    @logger.info(\"Source environment is #{source_env}\")\n+    source_metric = nil # extract from its environment\n+    @visitor.visit(source_env) do |env|\n+      logging_client = Google::Cloud::Logging.new({project: env.project_id})\n+      metrics = logging_client.metrics\n+      source_metric = metrics.select { |m| m.name == @source_dashboard_number }.first", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwNjQ2Ng==", "bodyText": "would this delete keys that are in active use by other developers?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389806466", "createdAt": "2020-03-09T16:27:19Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/service_accounts.rb", "diffHunk": "@@ -0,0 +1,61 @@\n+require 'open3'\n+\n+# This class avoids the GcpEnvironmentVisitor because we don't want to create or delete\n+# any new SA keys, and we're doing everything with the gcloud command line anyway.\n+class ServiceAccounts\n+  def initialize(options)\n+    envs_json = JSON.load(IO.read(options[:'envs-file']))\n+    @environments = envs_json['environments'].map { |env| GcpEnvironmentInfo.new(env) }\n+    @logger = options[:logger]\n+    @is_dry_run = options[:'dry-run'] ? true : false\n+  end\n+\n+  def list_keys\n+    @environments.each do |env|\n+      get_keys(env).each do |key|\n+        @logger.info(key)\n+      end\n+    end\n+  end\n+\n+  # This tool does not use the GcpEnvironmentVisitor, as it's specifically cleaning up after it.\n+  def delete_all_keys\n+    @environments.each do |env|\n+      keys = get_keys(env)\n+      keys.each do |key|\n+        if @is_dry_run == true\n+          @logger.info(\"would delete key #{key} for SA #{env.service_account} in project\")\n+        else\n+          delete_key(key, env)\n+        end\n+      end\n+    end\n+  end\n+\n+  # Get key JSON objects\n+  def get_keys(env)\n+    list_cmd = %W[gcloud iam service-accounts keys list", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a813efd0ea3f8c81d29e937ab731535a5693855", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/1a813efd0ea3f8c81d29e937ab731535a5693855", "committedDate": "2020-03-09T20:35:02Z", "message": "fix PR commentsn"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1c8e0598ac8e17a167592fb6431c07b3f4a11e1", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/b1c8e0598ac8e17a167592fb6431c07b3f4a11e1", "committedDate": "2020-03-09T21:22:11Z", "message": "rename to fix greedy IJ refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea1b9c48bb022dd51bf836aa8c93a1bacc0477d2", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/ea1b9c48bb022dd51bf836aa8c93a1bacc0477d2", "committedDate": "2020-03-10T18:01:19Z", "message": "update docs and add example file"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMjA0NTQy", "url": "https://github.com/all-of-us/workbench/pull/3203#pullrequestreview-372204542", "createdAt": "2020-03-10T18:13:18Z", "commit": {"oid": "ea1b9c48bb022dd51bf836aa8c93a1bacc0477d2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0f645619eddeeead26981f998ad3ec9c7c898ba", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/f0f645619eddeeead26981f998ad3ec9c7c898ba", "committedDate": "2020-03-10T19:25:45Z", "message": "merge master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25802a489d3f20d1250f237c23a212bca4e0df46", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/25802a489d3f20d1250f237c23a212bca4e0df46", "committedDate": "2020-03-10T19:38:52Z", "message": "codacy fixes"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3410, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}