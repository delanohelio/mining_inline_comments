{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0NjM2NDk2", "number": 3813, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzoyNTo0OFrOEQuVaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToyMDozNlrOERnrTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTcxODE2OnYy", "diffSide": "RIGHT", "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcf.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzoyNTo0OFrOG1CVUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo1ODozNVrOG1DkDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI2NTkzNw==", "bodyText": "stale comment I think - don't want to change the alleles", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r458265937", "createdAt": "2020-07-21T17:25:48Z", "author": {"login": "calbach"}, "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcf.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package org.pmiops.workbench.genomics;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypeBuilder;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.vcf.VCFHeader;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.VariantWalker;\n+import picard.cmdline.programgroups.VariantManipulationProgramGroup;\n+\n+@CommandLineProgramProperties(\n+    summary = \"Generates random variant alleles at the same contigs as an example VCF\",\n+    oneLineSummary = \"Randomizes a VCF\",\n+    programGroup = VariantManipulationProgramGroup.class\n+)\n+public class RandomizeVcf extends VariantWalker {\n+  @Argument(doc = \"Output vcf name.\",\n+      fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+      shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME)\n+  protected File outputVcf;\n+\n+  @Argument(doc = \"Sample name suffix.\",\n+      fullName = \"SAMPLE_NAME_SUFFIX\",\n+      shortName = \"S\"\n+  )\n+  protected static String sampleNameSuffix;\n+\n+  static Random random = new Random();\n+\n+  private VariantContextWriter vcfWriter;\n+\n+  @Override\n+  public void apply(VariantContext variant, ReadsContext readsContext,\n+      ReferenceContext referenceContext, FeatureContext featureContext) {\n+    vcfWriter.add(randomizeVariant(variant));\n+  }\n+\n+  @Override\n+  public void onTraversalStart() {\n+    final VCFHeader inputHeader = getHeaderForVariants();\n+    final List<String> newSampleNames = inputHeader.getSampleNamesInOrder().stream()\n+        .map(RandomizeVcf::appendSuffixToSampleName)\n+        .collect(Collectors.toList());\n+    final VCFHeader outputHeader = new VCFHeader(inputHeader.getMetaDataInInputOrder(), newSampleNames);\n+    vcfWriter = this.createVCFWriter(outputVcf);\n+    vcfWriter.writeHeader(outputHeader);\n+  }\n+\n+  @Override\n+  public void closeTool() {\n+    if ( vcfWriter != null ) {\n+      vcfWriter.close();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  protected static VariantContext randomizeVariant(VariantContext variant) {\n+    // This initializes most of the VariantContextBuilder fields to what they were in the original variant.\n+    // We just want to change the alleles, genotypes, and quality score.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1480bf2873536150fa23170ef6e82f31cf6d035"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4NjA5Mg==", "bodyText": "Yes, stale comment, thanks for the catch", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r458286092", "createdAt": "2020-07-21T17:58:35Z", "author": {"login": "als364"}, "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcf.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package org.pmiops.workbench.genomics;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypeBuilder;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.vcf.VCFHeader;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.VariantWalker;\n+import picard.cmdline.programgroups.VariantManipulationProgramGroup;\n+\n+@CommandLineProgramProperties(\n+    summary = \"Generates random variant alleles at the same contigs as an example VCF\",\n+    oneLineSummary = \"Randomizes a VCF\",\n+    programGroup = VariantManipulationProgramGroup.class\n+)\n+public class RandomizeVcf extends VariantWalker {\n+  @Argument(doc = \"Output vcf name.\",\n+      fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+      shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME)\n+  protected File outputVcf;\n+\n+  @Argument(doc = \"Sample name suffix.\",\n+      fullName = \"SAMPLE_NAME_SUFFIX\",\n+      shortName = \"S\"\n+  )\n+  protected static String sampleNameSuffix;\n+\n+  static Random random = new Random();\n+\n+  private VariantContextWriter vcfWriter;\n+\n+  @Override\n+  public void apply(VariantContext variant, ReadsContext readsContext,\n+      ReferenceContext referenceContext, FeatureContext featureContext) {\n+    vcfWriter.add(randomizeVariant(variant));\n+  }\n+\n+  @Override\n+  public void onTraversalStart() {\n+    final VCFHeader inputHeader = getHeaderForVariants();\n+    final List<String> newSampleNames = inputHeader.getSampleNamesInOrder().stream()\n+        .map(RandomizeVcf::appendSuffixToSampleName)\n+        .collect(Collectors.toList());\n+    final VCFHeader outputHeader = new VCFHeader(inputHeader.getMetaDataInInputOrder(), newSampleNames);\n+    vcfWriter = this.createVCFWriter(outputVcf);\n+    vcfWriter.writeHeader(outputHeader);\n+  }\n+\n+  @Override\n+  public void closeTool() {\n+    if ( vcfWriter != null ) {\n+      vcfWriter.close();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  protected static VariantContext randomizeVariant(VariantContext variant) {\n+    // This initializes most of the VariantContextBuilder fields to what they were in the original variant.\n+    // We just want to change the alleles, genotypes, and quality score.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI2NTkzNw=="}, "originalCommit": {"oid": "e1480bf2873536150fa23170ef6e82f31cf6d035"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTczNjA5OnYy", "diffSide": "RIGHT", "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcf.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzozMDoyM1rOG1CgmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzozMDoyM1rOG1CgmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI2ODgyNA==", "bodyText": "nit: looks like these builder methods can be chained", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r458268824", "createdAt": "2020-07-21T17:30:23Z", "author": {"login": "calbach"}, "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcf.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package org.pmiops.workbench.genomics;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypeBuilder;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.vcf.VCFHeader;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.VariantWalker;\n+import picard.cmdline.programgroups.VariantManipulationProgramGroup;\n+\n+@CommandLineProgramProperties(\n+    summary = \"Generates random variant alleles at the same contigs as an example VCF\",\n+    oneLineSummary = \"Randomizes a VCF\",\n+    programGroup = VariantManipulationProgramGroup.class\n+)\n+public class RandomizeVcf extends VariantWalker {\n+  @Argument(doc = \"Output vcf name.\",\n+      fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+      shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME)\n+  protected File outputVcf;\n+\n+  @Argument(doc = \"Sample name suffix.\",\n+      fullName = \"SAMPLE_NAME_SUFFIX\",\n+      shortName = \"S\"\n+  )\n+  protected static String sampleNameSuffix;\n+\n+  static Random random = new Random();\n+\n+  private VariantContextWriter vcfWriter;\n+\n+  @Override\n+  public void apply(VariantContext variant, ReadsContext readsContext,\n+      ReferenceContext referenceContext, FeatureContext featureContext) {\n+    vcfWriter.add(randomizeVariant(variant));\n+  }\n+\n+  @Override\n+  public void onTraversalStart() {\n+    final VCFHeader inputHeader = getHeaderForVariants();\n+    final List<String> newSampleNames = inputHeader.getSampleNamesInOrder().stream()\n+        .map(RandomizeVcf::appendSuffixToSampleName)\n+        .collect(Collectors.toList());\n+    final VCFHeader outputHeader = new VCFHeader(inputHeader.getMetaDataInInputOrder(), newSampleNames);\n+    vcfWriter = this.createVCFWriter(outputVcf);\n+    vcfWriter.writeHeader(outputHeader);\n+  }\n+\n+  @Override\n+  public void closeTool() {\n+    if ( vcfWriter != null ) {\n+      vcfWriter.close();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  protected static VariantContext randomizeVariant(VariantContext variant) {\n+    // This initializes most of the VariantContextBuilder fields to what they were in the original variant.\n+    // We just want to change the alleles, genotypes, and quality score.\n+    VariantContextBuilder variantContextBuilder = new VariantContextBuilder(variant);\n+    variantContextBuilder.alleles(variant.getAlleles());\n+\n+    List<Genotype> randomizedGenotypes = variant.getGenotypes()\n+        .stream()\n+        .map(genotype -> randomizeGenotype(variant, genotype))\n+        .collect(Collectors.toList());\n+    GenotypesContext randomizedGenotypesContext = GenotypesContext.create(new ArrayList<>(randomizedGenotypes));\n+\n+    variantContextBuilder.genotypes(randomizedGenotypesContext);\n+\n+    // We want kind of random error. If there's no error, have no error for the new variant as well.\n+    // If there's error, fuzz the error.\n+    if (variant.hasLog10PError()) {\n+      variantContextBuilder.log10PError(random.nextDouble() * variant.getLog10PError());\n+    }\n+\n+    return variantContextBuilder.make();\n+  }\n+\n+  protected static Genotype randomizeGenotype(VariantContext variantContext, Genotype genotype) {\n+    GenotypeBuilder genotypeBuilder = new GenotypeBuilder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1480bf2873536150fa23170ef6e82f31cf6d035"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTgwOTY2OnYy", "diffSide": "RIGHT", "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcf.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo0OTo1M1rOG1DPUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo1OTo0MlrOG1Dmyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MDc4Nw==", "bodyText": "opt: another way we could do this would be to take the global rate of no-call in the VCF file (just look it up manually and hardcode it here), then pick no call with the corresponding probability. This would probably be better since the current approach will result in strictly fewer no-calls w.r.t. the original VCF, and only in the same positions.\nI was curious so I looked at the frequencies of each genotype in the sample VCF:\n  27629 ./.\n1518493 0/0\n 106755 0/1\n 117349 1/0\n 138615 1/1\n   1123 2/2\n\nPerhaps this randomizer should also favor homozygous reference as well.", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r458280787", "createdAt": "2020-07-21T17:49:53Z", "author": {"login": "calbach"}, "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcf.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package org.pmiops.workbench.genomics;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypeBuilder;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.vcf.VCFHeader;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.VariantWalker;\n+import picard.cmdline.programgroups.VariantManipulationProgramGroup;\n+\n+@CommandLineProgramProperties(\n+    summary = \"Generates random variant alleles at the same contigs as an example VCF\",\n+    oneLineSummary = \"Randomizes a VCF\",\n+    programGroup = VariantManipulationProgramGroup.class\n+)\n+public class RandomizeVcf extends VariantWalker {\n+  @Argument(doc = \"Output vcf name.\",\n+      fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+      shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME)\n+  protected File outputVcf;\n+\n+  @Argument(doc = \"Sample name suffix.\",\n+      fullName = \"SAMPLE_NAME_SUFFIX\",\n+      shortName = \"S\"\n+  )\n+  protected static String sampleNameSuffix;\n+\n+  static Random random = new Random();\n+\n+  private VariantContextWriter vcfWriter;\n+\n+  @Override\n+  public void apply(VariantContext variant, ReadsContext readsContext,\n+      ReferenceContext referenceContext, FeatureContext featureContext) {\n+    vcfWriter.add(randomizeVariant(variant));\n+  }\n+\n+  @Override\n+  public void onTraversalStart() {\n+    final VCFHeader inputHeader = getHeaderForVariants();\n+    final List<String> newSampleNames = inputHeader.getSampleNamesInOrder().stream()\n+        .map(RandomizeVcf::appendSuffixToSampleName)\n+        .collect(Collectors.toList());\n+    final VCFHeader outputHeader = new VCFHeader(inputHeader.getMetaDataInInputOrder(), newSampleNames);\n+    vcfWriter = this.createVCFWriter(outputVcf);\n+    vcfWriter.writeHeader(outputHeader);\n+  }\n+\n+  @Override\n+  public void closeTool() {\n+    if ( vcfWriter != null ) {\n+      vcfWriter.close();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  protected static VariantContext randomizeVariant(VariantContext variant) {\n+    // This initializes most of the VariantContextBuilder fields to what they were in the original variant.\n+    // We just want to change the alleles, genotypes, and quality score.\n+    VariantContextBuilder variantContextBuilder = new VariantContextBuilder(variant);\n+    variantContextBuilder.alleles(variant.getAlleles());\n+\n+    List<Genotype> randomizedGenotypes = variant.getGenotypes()\n+        .stream()\n+        .map(genotype -> randomizeGenotype(variant, genotype))\n+        .collect(Collectors.toList());\n+    GenotypesContext randomizedGenotypesContext = GenotypesContext.create(new ArrayList<>(randomizedGenotypes));\n+\n+    variantContextBuilder.genotypes(randomizedGenotypesContext);\n+\n+    // We want kind of random error. If there's no error, have no error for the new variant as well.\n+    // If there's error, fuzz the error.\n+    if (variant.hasLog10PError()) {\n+      variantContextBuilder.log10PError(random.nextDouble() * variant.getLog10PError());\n+    }\n+\n+    return variantContextBuilder.make();\n+  }\n+\n+  protected static Genotype randomizeGenotype(VariantContext variantContext, Genotype genotype) {\n+    GenotypeBuilder genotypeBuilder = new GenotypeBuilder();\n+    genotypeBuilder.copy(genotype);\n+    genotypeBuilder.name(appendSuffixToSampleName(genotype.getSampleName()));\n+    genotypeBuilder.alleles(randomizeAlleles(variantContext, genotype.getAlleles()));\n+    return genotypeBuilder.make();\n+  }\n+\n+  @VisibleForTesting\n+  protected static List<Allele> randomizeAlleles(VariantContext variantContext, List<Allele> genotypeAlleles) {\n+    // The alleles list on the VariantContext has first the reference and then all possible alternates.\n+    // For each genotype, we pick from among those possible alternates (or we put a no-call.)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1480bf2873536150fa23170ef6e82f31cf6d035"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4Njc5NA==", "bodyText": "Thank you for doing that! Yeah, now that I have a process that works, I can spend some time futzing with the actual gt generation.", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r458286794", "createdAt": "2020-07-21T17:59:42Z", "author": {"login": "als364"}, "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcf.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package org.pmiops.workbench.genomics;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypeBuilder;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.vcf.VCFHeader;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.VariantWalker;\n+import picard.cmdline.programgroups.VariantManipulationProgramGroup;\n+\n+@CommandLineProgramProperties(\n+    summary = \"Generates random variant alleles at the same contigs as an example VCF\",\n+    oneLineSummary = \"Randomizes a VCF\",\n+    programGroup = VariantManipulationProgramGroup.class\n+)\n+public class RandomizeVcf extends VariantWalker {\n+  @Argument(doc = \"Output vcf name.\",\n+      fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+      shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME)\n+  protected File outputVcf;\n+\n+  @Argument(doc = \"Sample name suffix.\",\n+      fullName = \"SAMPLE_NAME_SUFFIX\",\n+      shortName = \"S\"\n+  )\n+  protected static String sampleNameSuffix;\n+\n+  static Random random = new Random();\n+\n+  private VariantContextWriter vcfWriter;\n+\n+  @Override\n+  public void apply(VariantContext variant, ReadsContext readsContext,\n+      ReferenceContext referenceContext, FeatureContext featureContext) {\n+    vcfWriter.add(randomizeVariant(variant));\n+  }\n+\n+  @Override\n+  public void onTraversalStart() {\n+    final VCFHeader inputHeader = getHeaderForVariants();\n+    final List<String> newSampleNames = inputHeader.getSampleNamesInOrder().stream()\n+        .map(RandomizeVcf::appendSuffixToSampleName)\n+        .collect(Collectors.toList());\n+    final VCFHeader outputHeader = new VCFHeader(inputHeader.getMetaDataInInputOrder(), newSampleNames);\n+    vcfWriter = this.createVCFWriter(outputVcf);\n+    vcfWriter.writeHeader(outputHeader);\n+  }\n+\n+  @Override\n+  public void closeTool() {\n+    if ( vcfWriter != null ) {\n+      vcfWriter.close();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  protected static VariantContext randomizeVariant(VariantContext variant) {\n+    // This initializes most of the VariantContextBuilder fields to what they were in the original variant.\n+    // We just want to change the alleles, genotypes, and quality score.\n+    VariantContextBuilder variantContextBuilder = new VariantContextBuilder(variant);\n+    variantContextBuilder.alleles(variant.getAlleles());\n+\n+    List<Genotype> randomizedGenotypes = variant.getGenotypes()\n+        .stream()\n+        .map(genotype -> randomizeGenotype(variant, genotype))\n+        .collect(Collectors.toList());\n+    GenotypesContext randomizedGenotypesContext = GenotypesContext.create(new ArrayList<>(randomizedGenotypes));\n+\n+    variantContextBuilder.genotypes(randomizedGenotypesContext);\n+\n+    // We want kind of random error. If there's no error, have no error for the new variant as well.\n+    // If there's error, fuzz the error.\n+    if (variant.hasLog10PError()) {\n+      variantContextBuilder.log10PError(random.nextDouble() * variant.getLog10PError());\n+    }\n+\n+    return variantContextBuilder.make();\n+  }\n+\n+  protected static Genotype randomizeGenotype(VariantContext variantContext, Genotype genotype) {\n+    GenotypeBuilder genotypeBuilder = new GenotypeBuilder();\n+    genotypeBuilder.copy(genotype);\n+    genotypeBuilder.name(appendSuffixToSampleName(genotype.getSampleName()));\n+    genotypeBuilder.alleles(randomizeAlleles(variantContext, genotype.getAlleles()));\n+    return genotypeBuilder.make();\n+  }\n+\n+  @VisibleForTesting\n+  protected static List<Allele> randomizeAlleles(VariantContext variantContext, List<Allele> genotypeAlleles) {\n+    // The alleles list on the VariantContext has first the reference and then all possible alternates.\n+    // For each genotype, we pick from among those possible alternates (or we put a no-call.)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MDc4Nw=="}, "originalCommit": {"oid": "e1480bf2873536150fa23170ef6e82f31cf6d035"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDQzMjg0OnYy", "diffSide": "LEFT", "path": ".gitignore", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxODo0NDo1N1rOG1vkZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxODo0NDo1N1rOG1vkZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwNzA3Nw==", "bodyText": "We don't have common-api anymore.", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459007077", "createdAt": "2020-07-22T18:44:57Z", "author": {"login": "als364"}, "path": ".gitignore", "diffHunk": "@@ -25,9 +26,7 @@ cron-emulator-err.log\n /api/src/generated\n /api/tools/build/*\n /api/bin\n-/common-api/.swagger-codegen/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35140bdd553be49972b88b24d88cee7648fc0455"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDQzNzg2OnYy", "diffSide": "RIGHT", "path": "api/gradle/wrapper/gradle-wrapper.properties", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxODo0NjoyMlrOG1vnmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxODo0NjoyMlrOG1vnmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwNzg5Ng==", "bodyText": "auto generated when refreshing gradle after creating the subproject", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459007896", "createdAt": "2020-07-22T18:46:22Z", "author": {"login": "als364"}, "path": "api/gradle/wrapper/gradle-wrapper.properties", "diffHunk": "@@ -1,6 +1,6 @@\n-#Thu May 10 14:42:28 CDT 2018\n+#Tue Jul 21 11:03:10 EDT 2020", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35140bdd553be49972b88b24d88cee7648fc0455"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODE4NjE0OnYy", "diffSide": "RIGHT", "path": "api/libproject/devstart.rb", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo0Njo0MVrOG2S-kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxODoyNDo1MlrOG2WccA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU4NzIxOQ==", "bodyText": "Does this generate an index as well? This seems like a necessary intermediate step between randomize and combine. If yes, worth adding a note to this. If not, would be great to have a README that shows the full list of steps to generate the multisample VCF (including the index creation.)", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459587219", "createdAt": "2020-07-23T16:46:41Z", "author": {"login": "calbach"}, "path": "api/libproject/devstart.rb", "diffHunk": "@@ -2580,3 +2580,71 @@ def start_api_and_incremental_build(cmd_name, args)\n   :description => \"Used internally by other commands.\",\n   :fn => ->(*args) { start_api_and_incremental_build(\"start-api-and-incremental-build\", args) }\n })\n+\n+def randomize_vcf(cmd_name, *args)\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--vcf [vcf]\",\n+      -> (opts, v) {opts.vcf = v},\n+      \"Input vcf to randomize. This vcf should be gzipped and its corresponding index file \" +\n+          \"should be in the same folder. The index file can be generated from a gzipped vcf \" +\n+          \"by running tabix -p vcf [vcf path]\"\n+  )\n+  op.add_option(\n+      \"--number-of-copies [n]\",\n+      -> (opts, n) {opts.n = n},\n+      \"How many random vcfs to generate.\"\n+  )\n+  op.add_option(\n+      \"--output-dir [out]\",\n+      -> (opts, o) {opts.out = o},\n+      \"Output dir in which to put randomized vcfs\"\n+  )\n+  op.parse.validate\n+\n+  for i in 1..op.opts.n.chomp.to_i\n+    basename = File.basename(op.opts.vcf, \".vcf.gz\")\n+    out = \"#{op.opts.out}#{basename}.#{i}.vcf\"\n+    app_args = \"-PappArgs=['-V#{op.opts.vcf}','-O#{out}','-S#{i}']\"\n+    Common.new.run_inline %W{./gradlew -p genomics randomizeVcf} + [app_args]\n+  end\n+end\n+\n+Common.register_command({\n+  :invocation => \"randomize-vcf\",\n+  :description => \"Given an example vcf and a number of copies to make, generates that many \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0NDAxNg==", "bodyText": "Yes, VariantContextWriters automatically create an index on file close. I'll update this comment. IMO a README is still worth it; I'll drop it in api/genomics", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459644016", "createdAt": "2020-07-23T18:24:52Z", "author": {"login": "als364"}, "path": "api/libproject/devstart.rb", "diffHunk": "@@ -2580,3 +2580,71 @@ def start_api_and_incremental_build(cmd_name, args)\n   :description => \"Used internally by other commands.\",\n   :fn => ->(*args) { start_api_and_incremental_build(\"start-api-and-incremental-build\", args) }\n })\n+\n+def randomize_vcf(cmd_name, *args)\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--vcf [vcf]\",\n+      -> (opts, v) {opts.vcf = v},\n+      \"Input vcf to randomize. This vcf should be gzipped and its corresponding index file \" +\n+          \"should be in the same folder. The index file can be generated from a gzipped vcf \" +\n+          \"by running tabix -p vcf [vcf path]\"\n+  )\n+  op.add_option(\n+      \"--number-of-copies [n]\",\n+      -> (opts, n) {opts.n = n},\n+      \"How many random vcfs to generate.\"\n+  )\n+  op.add_option(\n+      \"--output-dir [out]\",\n+      -> (opts, o) {opts.out = o},\n+      \"Output dir in which to put randomized vcfs\"\n+  )\n+  op.parse.validate\n+\n+  for i in 1..op.opts.n.chomp.to_i\n+    basename = File.basename(op.opts.vcf, \".vcf.gz\")\n+    out = \"#{op.opts.out}#{basename}.#{i}.vcf\"\n+    app_args = \"-PappArgs=['-V#{op.opts.vcf}','-O#{out}','-S#{i}']\"\n+    Common.new.run_inline %W{./gradlew -p genomics randomizeVcf} + [app_args]\n+  end\n+end\n+\n+Common.register_command({\n+  :invocation => \"randomize-vcf\",\n+  :description => \"Given an example vcf and a number of copies to make, generates that many \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU4NzIxOQ=="}, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODMwNTYxOnYy", "diffSide": "RIGHT", "path": "api/genomics/src/test/java/org/pmiops/workbench/genomics/RandomizeVcfTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxOTowNFrOG2UJgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxODoyMzozNFrOG2WZmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNjQwMA==", "bodyText": "nit: I'd probably just expose two constructors here, 1 default constructor, 1 that takes the sampleNameSuffix, used by the test (and @VisibleForTesting)", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459606400", "createdAt": "2020-07-23T17:19:04Z", "author": {"login": "calbach"}, "path": "api/genomics/src/test/java/org/pmiops/workbench/genomics/RandomizeVcfTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package org.pmiops.workbench.genomics;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import java.io.File;\n+import java.util.List;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class RandomizeVcfTest {\n+  private static final VCFFileReader reader =\n+      new VCFFileReader(new File(\"src/test/resources/NA12878_204126160130_R01C01.toy.vcf.gz\"));\n+  private static final VariantContext variantContext = reader.iterator().next();\n+  private static final RandomizeVcf randomizeVcf = new RandomizeVcf();\n+\n+  @BeforeClass\n+  public static void setUp() {\n+    randomizeVcf.sampleNameSuffix = \"0\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0MzI4OQ==", "bodyText": "oh that would make more sense wouldn't it", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459643289", "createdAt": "2020-07-23T18:23:34Z", "author": {"login": "als364"}, "path": "api/genomics/src/test/java/org/pmiops/workbench/genomics/RandomizeVcfTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package org.pmiops.workbench.genomics;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import java.io.File;\n+import java.util.List;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class RandomizeVcfTest {\n+  private static final VCFFileReader reader =\n+      new VCFFileReader(new File(\"src/test/resources/NA12878_204126160130_R01C01.toy.vcf.gz\"));\n+  private static final VariantContext variantContext = reader.iterator().next();\n+  private static final RandomizeVcf randomizeVcf = new RandomizeVcf();\n+\n+  @BeforeClass\n+  public static void setUp() {\n+    randomizeVcf.sampleNameSuffix = \"0\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNjQwMA=="}, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODMwODM0OnYy", "diffSide": "RIGHT", "path": "api/genomics/src/test/java/org/pmiops/workbench/genomics/RandomizeVcfTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxOTo1MFrOG2ULOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxOTo1MFrOG2ULOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNjg0MQ==", "bodyText": "nit: method names should be lower camel", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459606841", "createdAt": "2020-07-23T17:19:50Z", "author": {"login": "calbach"}, "path": "api/genomics/src/test/java/org/pmiops/workbench/genomics/RandomizeVcfTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package org.pmiops.workbench.genomics;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import java.io.File;\n+import java.util.List;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class RandomizeVcfTest {\n+  private static final VCFFileReader reader =\n+      new VCFFileReader(new File(\"src/test/resources/NA12878_204126160130_R01C01.toy.vcf.gz\"));\n+  private static final VariantContext variantContext = reader.iterator().next();\n+  private static final RandomizeVcf randomizeVcf = new RandomizeVcf();\n+\n+  @BeforeClass\n+  public static void setUp() {\n+    randomizeVcf.sampleNameSuffix = \"0\";\n+  }\n+\n+  @Test\n+  public void TestRandomizeVariant() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODMyODkwOnYy", "diffSide": "RIGHT", "path": "api/genomics/src/test/java/org/pmiops/workbench/genomics/RandomizeVcfTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoyNTozM1rOG2UX4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxODoyNDoxM1rOG2WbAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxMDA4MA==", "bodyText": "opt nit: you could probably reduce some nesting here by using stream flatMap. This basically lets you expand the current stream with more elements, i.e. map a small collection of genotypes into a larger collection alleles\n.getGenotypes()\n.stream()\n.flatMap(Genotype::getAlleles)\n.forEach(... assertion ...)", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459610080", "createdAt": "2020-07-23T17:25:33Z", "author": {"login": "calbach"}, "path": "api/genomics/src/test/java/org/pmiops/workbench/genomics/RandomizeVcfTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package org.pmiops.workbench.genomics;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import java.io.File;\n+import java.util.List;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class RandomizeVcfTest {\n+  private static final VCFFileReader reader =\n+      new VCFFileReader(new File(\"src/test/resources/NA12878_204126160130_R01C01.toy.vcf.gz\"));\n+  private static final VariantContext variantContext = reader.iterator().next();\n+  private static final RandomizeVcf randomizeVcf = new RandomizeVcf();\n+\n+  @BeforeClass\n+  public static void setUp() {\n+    randomizeVcf.sampleNameSuffix = \"0\";\n+  }\n+\n+  @Test\n+  public void TestRandomizeVariant() {\n+    VariantContext randomizedVariant = randomizeVcf.randomizeVariant(variantContext);\n+    // For each sample/GT in the variant...\n+    randomizedVariant\n+        .getGenotypes()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0MzY1MA==", "bodyText": "Oh yeah, that's true, thank you", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459643650", "createdAt": "2020-07-23T18:24:13Z", "author": {"login": "als364"}, "path": "api/genomics/src/test/java/org/pmiops/workbench/genomics/RandomizeVcfTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package org.pmiops.workbench.genomics;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import java.io.File;\n+import java.util.List;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class RandomizeVcfTest {\n+  private static final VCFFileReader reader =\n+      new VCFFileReader(new File(\"src/test/resources/NA12878_204126160130_R01C01.toy.vcf.gz\"));\n+  private static final VariantContext variantContext = reader.iterator().next();\n+  private static final RandomizeVcf randomizeVcf = new RandomizeVcf();\n+\n+  @BeforeClass\n+  public static void setUp() {\n+    randomizeVcf.sampleNameSuffix = \"0\";\n+  }\n+\n+  @Test\n+  public void TestRandomizeVariant() {\n+    VariantContext randomizedVariant = randomizeVcf.randomizeVariant(variantContext);\n+    // For each sample/GT in the variant...\n+    randomizedVariant\n+        .getGenotypes()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxMDA4MA=="}, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODMzNjU4OnYy", "diffSide": "RIGHT", "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcf.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoyNzoyOFrOG2Ucdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoyNzoyOFrOG2Ucdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxMTI1NQ==", "bodyText": "I recommend allowing the test to set a fixed seed to make the test more deterministic. See my comment in the test file for how you could plumb that through in a test constructor", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459611255", "createdAt": "2020-07-23T17:27:28Z", "author": {"login": "calbach"}, "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcf.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.pmiops.workbench.genomics;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypeBuilder;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.vcf.VCFHeader;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.VariantWalker;\n+import picard.cmdline.programgroups.VariantManipulationProgramGroup;\n+\n+@CommandLineProgramProperties(\n+    summary = \"Generates random variant alleles at the same contigs as an example VCF\",\n+    oneLineSummary = \"Randomizes a VCF\",\n+    programGroup = VariantManipulationProgramGroup.class)\n+public class RandomizeVcf extends VariantWalker {\n+  @Argument(\n+      doc = \"Output vcf name.\",\n+      fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+      shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME)\n+  protected File outputVcf;\n+\n+  @Argument(doc = \"Sample name suffix.\", fullName = \"SAMPLE_NAME_SUFFIX\", shortName = \"S\")\n+  protected String sampleNameSuffix;\n+\n+  private Random random = new Random();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODM4NDAxOnYy", "diffSide": "RIGHT", "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcf.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo0MDozNFrOG2U5zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxODoyMjozNVrOG2WXmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxODc2NQ==", "bodyText": "This works for now, we're not too concerned with errors at the moment - I'd probably put a comment with possible improvements or deficiencies. Specifically:\n\nI'm not sure about applying a fractional scaling to a log10 value. The net effect on the original error value will be amplified. Though I'm not familiar enough with these error ranges to know whether the output is something that's still within reason.\nthis currently should strictly reduce the value; most likely we would want to fuzz it in either direction, or just generate a new value altogether here, unrelated to the original.", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459618765", "createdAt": "2020-07-23T17:40:34Z", "author": {"login": "calbach"}, "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcf.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.pmiops.workbench.genomics;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypeBuilder;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.vcf.VCFHeader;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.VariantWalker;\n+import picard.cmdline.programgroups.VariantManipulationProgramGroup;\n+\n+@CommandLineProgramProperties(\n+    summary = \"Generates random variant alleles at the same contigs as an example VCF\",\n+    oneLineSummary = \"Randomizes a VCF\",\n+    programGroup = VariantManipulationProgramGroup.class)\n+public class RandomizeVcf extends VariantWalker {\n+  @Argument(\n+      doc = \"Output vcf name.\",\n+      fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+      shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME)\n+  protected File outputVcf;\n+\n+  @Argument(doc = \"Sample name suffix.\", fullName = \"SAMPLE_NAME_SUFFIX\", shortName = \"S\")\n+  protected String sampleNameSuffix;\n+\n+  private Random random = new Random();\n+\n+  private VariantContextWriter vcfWriter;\n+\n+  @Override\n+  public void apply(\n+      VariantContext variant,\n+      ReadsContext readsContext,\n+      ReferenceContext referenceContext,\n+      FeatureContext featureContext) {\n+    vcfWriter.add(randomizeVariant(variant));\n+  }\n+\n+  @Override\n+  public void onTraversalStart() {\n+    final VCFHeader inputHeader = getHeaderForVariants();\n+    final List<String> newSampleNames =\n+        inputHeader.getSampleNamesInOrder().stream()\n+            .map(this::appendSuffixToSampleName)\n+            .collect(Collectors.toList());\n+    final VCFHeader outputHeader =\n+        new VCFHeader(inputHeader.getMetaDataInInputOrder(), newSampleNames);\n+    vcfWriter = this.createVCFWriter(outputVcf);\n+    vcfWriter.writeHeader(outputHeader);\n+  }\n+\n+  @Override\n+  public void closeTool() {\n+    if (vcfWriter != null) {\n+      vcfWriter.close();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  protected VariantContext randomizeVariant(VariantContext variant) {\n+    // This initializes most of the VariantContextBuilder fields to what they were in the original\n+    // variant. We just want to change the genotypes and quality score.\n+    VariantContextBuilder variantContextBuilder = new VariantContextBuilder(variant);\n+    variantContextBuilder.alleles(variant.getAlleles());\n+\n+    List<Genotype> randomizedGenotypes =\n+        variant.getGenotypes().stream()\n+            .map(genotype -> randomizeGenotype(variant, genotype))\n+            .collect(Collectors.toList());\n+    GenotypesContext randomizedGenotypesContext =\n+        GenotypesContext.create(new ArrayList<>(randomizedGenotypes));\n+\n+    variantContextBuilder.genotypes(randomizedGenotypesContext);\n+\n+    // We want kind of random error. If there's no error, have no error for the new variant as well.\n+    // If there's error, fuzz the error.\n+    if (variant.hasLog10PError()) {\n+      variantContextBuilder.log10PError(random.nextDouble() * variant.getLog10PError());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0Mjc3Nw==", "bodyText": "Heh, I'm also not too sure about the usual error ranges. Might just remove this and put a follow-up ticket to investigate error fuzzing.", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459642777", "createdAt": "2020-07-23T18:22:35Z", "author": {"login": "als364"}, "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcf.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.pmiops.workbench.genomics;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypeBuilder;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.vcf.VCFHeader;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.VariantWalker;\n+import picard.cmdline.programgroups.VariantManipulationProgramGroup;\n+\n+@CommandLineProgramProperties(\n+    summary = \"Generates random variant alleles at the same contigs as an example VCF\",\n+    oneLineSummary = \"Randomizes a VCF\",\n+    programGroup = VariantManipulationProgramGroup.class)\n+public class RandomizeVcf extends VariantWalker {\n+  @Argument(\n+      doc = \"Output vcf name.\",\n+      fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+      shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME)\n+  protected File outputVcf;\n+\n+  @Argument(doc = \"Sample name suffix.\", fullName = \"SAMPLE_NAME_SUFFIX\", shortName = \"S\")\n+  protected String sampleNameSuffix;\n+\n+  private Random random = new Random();\n+\n+  private VariantContextWriter vcfWriter;\n+\n+  @Override\n+  public void apply(\n+      VariantContext variant,\n+      ReadsContext readsContext,\n+      ReferenceContext referenceContext,\n+      FeatureContext featureContext) {\n+    vcfWriter.add(randomizeVariant(variant));\n+  }\n+\n+  @Override\n+  public void onTraversalStart() {\n+    final VCFHeader inputHeader = getHeaderForVariants();\n+    final List<String> newSampleNames =\n+        inputHeader.getSampleNamesInOrder().stream()\n+            .map(this::appendSuffixToSampleName)\n+            .collect(Collectors.toList());\n+    final VCFHeader outputHeader =\n+        new VCFHeader(inputHeader.getMetaDataInInputOrder(), newSampleNames);\n+    vcfWriter = this.createVCFWriter(outputVcf);\n+    vcfWriter.writeHeader(outputHeader);\n+  }\n+\n+  @Override\n+  public void closeTool() {\n+    if (vcfWriter != null) {\n+      vcfWriter.close();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  protected VariantContext randomizeVariant(VariantContext variant) {\n+    // This initializes most of the VariantContextBuilder fields to what they were in the original\n+    // variant. We just want to change the genotypes and quality score.\n+    VariantContextBuilder variantContextBuilder = new VariantContextBuilder(variant);\n+    variantContextBuilder.alleles(variant.getAlleles());\n+\n+    List<Genotype> randomizedGenotypes =\n+        variant.getGenotypes().stream()\n+            .map(genotype -> randomizeGenotype(variant, genotype))\n+            .collect(Collectors.toList());\n+    GenotypesContext randomizedGenotypesContext =\n+        GenotypesContext.create(new ArrayList<>(randomizedGenotypes));\n+\n+    variantContextBuilder.genotypes(randomizedGenotypesContext);\n+\n+    // We want kind of random error. If there's no error, have no error for the new variant as well.\n+    // If there's error, fuzz the error.\n+    if (variant.hasLog10PError()) {\n+      variantContextBuilder.log10PError(random.nextDouble() * variant.getLog10PError());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxODc2NQ=="}, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODM4NzY5OnYy", "diffSide": "RIGHT", "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcfEntryPoint.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo0MTozMFrOG2U79g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxODoyMzoxNlrOG2WY9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxOTMxOA==", "bodyText": "opt: personal preference, but I think this could just go into the RandomizeVcf file directly, rather than having the separate entrypoint file. I don't feel strongly.", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459619318", "createdAt": "2020-07-23T17:41:30Z", "author": {"login": "calbach"}, "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcfEntryPoint.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package org.pmiops.workbench.genomics;\n+\n+public class RandomizeVcfEntryPoint {\n+  public static void main(String[] argv) {\n+    new RandomizeVcf().instanceMain(argv);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0MzEyNQ==", "bodyText": "I'll give a try; if it works I'll get rid of these. I do need the combine entry point cause I'm not extending anything from Picard", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459643125", "createdAt": "2020-07-23T18:23:16Z", "author": {"login": "als364"}, "path": "api/genomics/src/main/java/org/pmiops/workbench/genomics/RandomizeVcfEntryPoint.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package org.pmiops.workbench.genomics;\n+\n+public class RandomizeVcfEntryPoint {\n+  public static void main(String[] argv) {\n+    new RandomizeVcf().instanceMain(argv);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxOTMxOA=="}, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODM5NDE5OnYy", "diffSide": "RIGHT", "path": ".circleci/config.yml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo0MzoxMFrOG2U_2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMTozMzoyMVrOG2cVhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMDMxNQ==", "bodyText": "I don't understand - why would the below glob pickup the genomics test files? Or is that not the issue?", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459620315", "createdAt": "2020-07-23T17:43:10Z", "author": {"login": "calbach"}, "path": ".circleci/config.yml", "diffHunk": "@@ -321,15 +333,18 @@ jobs:\n           #   src/test/java/org/pmiops/*********/monitoring/LogsBasedMetricsServiceTest.java src/test/java/org/pmiops/*********/monitoring/MonitoringServiceTest.java\n           # Example of Gradle command after formatting:\n           #   gradle test --tests org.pmiops.*********.monitoring.LogsBasedMetricsServiceTest --tests org.pmiops.*********.monitoring.MonitoringServiceTest\n+          #\n+          # We exclude the :genomics:test task below because otherwise gradle will attempt to run all the regular API unit tests under the genomics\n+          # submodule and will be unable to find them and will barf", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0MTc4Mw==", "bodyText": "That is not the issue.\ngradle test, by default, runs all subtasks of gradle test. This, generally, makes sense - it's common for repos to have, like, a unitTest and integrationTest subtask and you'd want gradle test to run them all.  In this case, gradle test runs :test, :appengine-cron-emulator:test, and :genomics:test, since the latter two are submodules of the top-level gradle project.\nThe issue is that running this command like this passes $GRADLE_ARGS to every one of those subtasks with no regard for whether those tests exist in those projects. You end up getting gradle test :gradle:test --tests org.pmiops.workbench.DoesNotExistInThisClasspathTest.\nWhat I'm doing here isn't excluding the genomics test modules from being handed to gradle test, I'm excluding the genomics test subtask from executing. This command won't grab the genomics tests anyways because of how circleci tests glob works - it's not a regex on paths, it just starts looking from working_directory, and since the genomics tests are not under api/src/test/java they won't get picked up.\nHope that all makes sense. I've created another CircleCI step above to run just the genomics tests.", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459641783", "createdAt": "2020-07-23T18:20:43Z", "author": {"login": "als364"}, "path": ".circleci/config.yml", "diffHunk": "@@ -321,15 +333,18 @@ jobs:\n           #   src/test/java/org/pmiops/*********/monitoring/LogsBasedMetricsServiceTest.java src/test/java/org/pmiops/*********/monitoring/MonitoringServiceTest.java\n           # Example of Gradle command after formatting:\n           #   gradle test --tests org.pmiops.*********.monitoring.LogsBasedMetricsServiceTest --tests org.pmiops.*********.monitoring.MonitoringServiceTest\n+          #\n+          # We exclude the :genomics:test task below because otherwise gradle will attempt to run all the regular API unit tests under the genomics\n+          # submodule and will be unable to find them and will barf", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMDMxNQ=="}, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0MDU0OA==", "bodyText": "I see, thanks. My preferred fix would be gradle test --> gradle :test on this line (no -x), this only picks up the root test task which would have been more accurate to begin with but didn't matter until now. This way you're not needing to list out every subproject that has tests. I tested locally that this works.\nI would also clarify the above comment that it pertains specifically to the test filtering. If you filter down to 0 tests for a particular gradle test target, that's an error. This means it's impractical to use the test filter in combination with a multi-test gradle task.", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459740548", "createdAt": "2020-07-23T21:33:21Z", "author": {"login": "calbach"}, "path": ".circleci/config.yml", "diffHunk": "@@ -321,15 +333,18 @@ jobs:\n           #   src/test/java/org/pmiops/*********/monitoring/LogsBasedMetricsServiceTest.java src/test/java/org/pmiops/*********/monitoring/MonitoringServiceTest.java\n           # Example of Gradle command after formatting:\n           #   gradle test --tests org.pmiops.*********.monitoring.LogsBasedMetricsServiceTest --tests org.pmiops.*********.monitoring.MonitoringServiceTest\n+          #\n+          # We exclude the :genomics:test task below because otherwise gradle will attempt to run all the regular API unit tests under the genomics\n+          # submodule and will be unable to find them and will barf", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMDMxNQ=="}, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTExMzA4OnYy", "diffSide": "RIGHT", "path": "api/libproject/devstart.rb", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToyMDozNlrOG2b-ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTo0MToxMVrOG20SpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNDcxNA==", "bodyText": "opt: We have several other commands that need to prep args like this, I think the pattern could be reused here - or it may not be relevant if the flag construction for GATK is specialized:\n\n  \n    \n      workbench/api/libproject/devstart.rb\n    \n    \n         Line 1341\n      in\n      0ccccd0\n    \n    \n    \n    \n\n        \n          \n           flags = ([ \n        \n    \n  \n\n\nprobably there's enough instances to pull it into a helper eventually.", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r459734714", "createdAt": "2020-07-23T21:20:36Z", "author": {"login": "calbach"}, "path": "api/libproject/devstart.rb", "diffHunk": "@@ -2580,3 +2580,71 @@ def start_api_and_incremental_build(cmd_name, args)\n   :description => \"Used internally by other commands.\",\n   :fn => ->(*args) { start_api_and_incremental_build(\"start-api-and-incremental-build\", args) }\n })\n+\n+def randomize_vcf(cmd_name, *args)\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--vcf [vcf]\",\n+      -> (opts, v) {opts.vcf = v},\n+      \"Input vcf to randomize. This vcf should be gzipped and its corresponding index file \" +\n+          \"should be in the same folder. The index file can be generated from a gzipped vcf \" +\n+          \"by running tabix -p vcf [vcf path]\"\n+  )\n+  op.add_option(\n+      \"--number-of-copies [n]\",\n+      -> (opts, n) {opts.n = n},\n+      \"How many random vcfs to generate.\"\n+  )\n+  op.add_option(\n+      \"--output-dir [out]\",\n+      -> (opts, o) {opts.out = o},\n+      \"Output dir in which to put randomized vcfs\"\n+  )\n+  op.parse.validate\n+\n+  for i in 1..op.opts.n.chomp.to_i\n+    basename = File.basename(op.opts.vcf, \".vcf.gz\")\n+    out = \"#{op.opts.out}#{basename}.#{i}.vcf\"\n+    app_args = \"-PappArgs=['-V#{op.opts.vcf}','-O#{out}','-S#{i}']\"\n+    Common.new.run_inline %W{./gradlew -p genomics randomizeVcf} + [app_args]\n+  end\n+end\n+\n+Common.register_command({\n+  :invocation => \"randomize-vcf\",\n+  :description => \"Given an example vcf and a number of copies to make, generates that many \" +\n+    \"random copies in a given output directory\",\n+  :fn => ->(*args) { randomize_vcf(\"randomize-vcf\", *args) }\n+})\n+\n+def combine_vcfs(cmd_name, *args)\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--dir [dir]\",\n+      -> (opts, d) {opts.dir = d},\n+      \"Dir with vcfs to combine. vcfs should have corresponding index files in the same \" +\n+          \"folder.\"\n+  )\n+  op.add_option(\n+      \"--output [output]\",\n+      -> (opts, o) {opts.output = o},\n+      \"Path to output the combined vcf\"\n+  )\n+  op.parse.validate\n+\n+  app_args = \"-PappArgs=[\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMzAyOA==", "bodyText": "the flag construction for GATK is different than we do it and the flag construction for picard is differently different...", "url": "https://github.com/all-of-us/workbench/pull/3813#discussion_r460133028", "createdAt": "2020-07-24T15:41:11Z", "author": {"login": "als364"}, "path": "api/libproject/devstart.rb", "diffHunk": "@@ -2580,3 +2580,71 @@ def start_api_and_incremental_build(cmd_name, args)\n   :description => \"Used internally by other commands.\",\n   :fn => ->(*args) { start_api_and_incremental_build(\"start-api-and-incremental-build\", args) }\n })\n+\n+def randomize_vcf(cmd_name, *args)\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--vcf [vcf]\",\n+      -> (opts, v) {opts.vcf = v},\n+      \"Input vcf to randomize. This vcf should be gzipped and its corresponding index file \" +\n+          \"should be in the same folder. The index file can be generated from a gzipped vcf \" +\n+          \"by running tabix -p vcf [vcf path]\"\n+  )\n+  op.add_option(\n+      \"--number-of-copies [n]\",\n+      -> (opts, n) {opts.n = n},\n+      \"How many random vcfs to generate.\"\n+  )\n+  op.add_option(\n+      \"--output-dir [out]\",\n+      -> (opts, o) {opts.out = o},\n+      \"Output dir in which to put randomized vcfs\"\n+  )\n+  op.parse.validate\n+\n+  for i in 1..op.opts.n.chomp.to_i\n+    basename = File.basename(op.opts.vcf, \".vcf.gz\")\n+    out = \"#{op.opts.out}#{basename}.#{i}.vcf\"\n+    app_args = \"-PappArgs=['-V#{op.opts.vcf}','-O#{out}','-S#{i}']\"\n+    Common.new.run_inline %W{./gradlew -p genomics randomizeVcf} + [app_args]\n+  end\n+end\n+\n+Common.register_command({\n+  :invocation => \"randomize-vcf\",\n+  :description => \"Given an example vcf and a number of copies to make, generates that many \" +\n+    \"random copies in a given output directory\",\n+  :fn => ->(*args) { randomize_vcf(\"randomize-vcf\", *args) }\n+})\n+\n+def combine_vcfs(cmd_name, *args)\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--dir [dir]\",\n+      -> (opts, d) {opts.dir = d},\n+      \"Dir with vcfs to combine. vcfs should have corresponding index files in the same \" +\n+          \"folder.\"\n+  )\n+  op.add_option(\n+      \"--output [output]\",\n+      -> (opts, o) {opts.output = o},\n+      \"Path to output the combined vcf\"\n+  )\n+  op.parse.validate\n+\n+  app_args = \"-PappArgs=[\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNDcxNA=="}, "originalCommit": {"oid": "746966b6dbd2231c7e84dc80c024f41109d0e162"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2453, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}