{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxNTU5MjEw", "number": 3203, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo1Mjo1OFrODmWwbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjoyNzoxOFrODmXpbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTQ1MzI1OnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/devops.rb", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo1Mjo1OFrOFzugBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo1Mjo1OFrOFzugBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4MzU1Nw==", "bodyText": "nit: in in -> in", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389783557", "createdAt": "2020-03-09T15:52:58Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/devops.rb", "diffHunk": "@@ -0,0 +1,75 @@\n+#!/usr/bin/env ruby\n+\n+require 'logger'\n+require 'optparse'\n+require 'ostruct'\n+\n+require_relative 'tasks/monitoring_assets'\n+require_relative 'tasks/dashboards'\n+require_relative 'tasks/logs_based_metrics'\n+require_relative 'tasks/service_accounts'\n+\n+# Single entry point for the devops framework. This is the only true Ruby Script file. The\n+# rest are classes.\n+#\n+# Based on input commands, this script delegates the work to  a task class, which should not need to\n+# know anything about environment variables such as ARGV, the run directory,  etc. Tasks should also avoid\n+# global variables like `logger`, so that we can control logging preferences from the top level.\n+\n+# TODO(jaycarlton): work out a scheme for task-specific options (i.e. subcommands)\n+def parse_options\n+  # options = OpenStruct.new\n+  # options.dry_run = true\n+  # options.envs_file = ENV['DEVOPS_TOOLKIT_ENVIRONMENTS_FILE']\n+  options = {}\n+  OptionParser.new do |parser|\n+    parser.on('-t', '--task [TASK]', String, 'Task to be in in each environment')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTQ1NDUyOnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/devops.rb", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo1MzoxM1rOFzugvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMDowNjoxNlrOFz3hOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4Mzc0MQ==", "bodyText": "are the comments needed?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389783741", "createdAt": "2020-03-09T15:53:13Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/devops.rb", "diffHunk": "@@ -0,0 +1,75 @@\n+#!/usr/bin/env ruby\n+\n+require 'logger'\n+require 'optparse'\n+require 'ostruct'\n+\n+require_relative 'tasks/monitoring_assets'\n+require_relative 'tasks/dashboards'\n+require_relative 'tasks/logs_based_metrics'\n+require_relative 'tasks/service_accounts'\n+\n+# Single entry point for the devops framework. This is the only true Ruby Script file. The\n+# rest are classes.\n+#\n+# Based on input commands, this script delegates the work to  a task class, which should not need to\n+# know anything about environment variables such as ARGV, the run directory,  etc. Tasks should also avoid\n+# global variables like `logger`, so that we can control logging preferences from the top level.\n+\n+# TODO(jaycarlton): work out a scheme for task-specific options (i.e. subcommands)\n+def parse_options\n+  # options = OpenStruct.new", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzMTMyMw==", "bodyText": "nope. I spent more time than it's worth fooling with this argument parser. Hopefully it will be ripped out and replaced with something shared by all dev tooling.", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389931323", "createdAt": "2020-03-09T20:06:16Z", "author": {"login": "jaycarlton"}, "path": "ops/ruby/devops-toolkit/devops.rb", "diffHunk": "@@ -0,0 +1,75 @@\n+#!/usr/bin/env ruby\n+\n+require 'logger'\n+require 'optparse'\n+require 'ostruct'\n+\n+require_relative 'tasks/monitoring_assets'\n+require_relative 'tasks/dashboards'\n+require_relative 'tasks/logs_based_metrics'\n+require_relative 'tasks/service_accounts'\n+\n+# Single entry point for the devops framework. This is the only true Ruby Script file. The\n+# rest are classes.\n+#\n+# Based on input commands, this script delegates the work to  a task class, which should not need to\n+# know anything about environment variables such as ARGV, the run directory,  etc. Tasks should also avoid\n+# global variables like `logger`, so that we can control logging preferences from the top level.\n+\n+# TODO(jaycarlton): work out a scheme for task-specific options (i.e. subcommands)\n+def parse_options\n+  # options = OpenStruct.new", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4Mzc0MQ=="}, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTQ1NjQzOnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/devops.rb", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo1MzozM1rOFzuhxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMDowNjozOVrOFz3h8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NDAwNg==", "bodyText": "what does this argument do?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389784006", "createdAt": "2020-03-09T15:53:33Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/devops.rb", "diffHunk": "@@ -0,0 +1,75 @@\n+#!/usr/bin/env ruby\n+\n+require 'logger'\n+require 'optparse'\n+require 'ostruct'\n+\n+require_relative 'tasks/monitoring_assets'\n+require_relative 'tasks/dashboards'\n+require_relative 'tasks/logs_based_metrics'\n+require_relative 'tasks/service_accounts'\n+\n+# Single entry point for the devops framework. This is the only true Ruby Script file. The\n+# rest are classes.\n+#\n+# Based on input commands, this script delegates the work to  a task class, which should not need to\n+# know anything about environment variables such as ARGV, the run directory,  etc. Tasks should also avoid\n+# global variables like `logger`, so that we can control logging preferences from the top level.\n+\n+# TODO(jaycarlton): work out a scheme for task-specific options (i.e. subcommands)\n+def parse_options\n+  # options = OpenStruct.new\n+  # options.dry_run = true\n+  # options.envs_file = ENV['DEVOPS_TOOLKIT_ENVIRONMENTS_FILE']\n+  options = {}\n+  OptionParser.new do |parser|\n+    parser.on('-t', '--task [TASK]', String, 'Task to be in in each environment')\n+    parser.on('-x', '--require XYLOPHONE', 'xylophone')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzMTUwNg==", "bodyText": "I was trying to understand the docs, which seemed inconsistent.", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389931506", "createdAt": "2020-03-09T20:06:39Z", "author": {"login": "jaycarlton"}, "path": "ops/ruby/devops-toolkit/devops.rb", "diffHunk": "@@ -0,0 +1,75 @@\n+#!/usr/bin/env ruby\n+\n+require 'logger'\n+require 'optparse'\n+require 'ostruct'\n+\n+require_relative 'tasks/monitoring_assets'\n+require_relative 'tasks/dashboards'\n+require_relative 'tasks/logs_based_metrics'\n+require_relative 'tasks/service_accounts'\n+\n+# Single entry point for the devops framework. This is the only true Ruby Script file. The\n+# rest are classes.\n+#\n+# Based on input commands, this script delegates the work to  a task class, which should not need to\n+# know anything about environment variables such as ARGV, the run directory,  etc. Tasks should also avoid\n+# global variables like `logger`, so that we can control logging preferences from the top level.\n+\n+# TODO(jaycarlton): work out a scheme for task-specific options (i.e. subcommands)\n+def parse_options\n+  # options = OpenStruct.new\n+  # options.dry_run = true\n+  # options.envs_file = ENV['DEVOPS_TOOLKIT_ENVIRONMENTS_FILE']\n+  options = {}\n+  OptionParser.new do |parser|\n+    parser.on('-t', '--task [TASK]', String, 'Task to be in in each environment')\n+    parser.on('-x', '--require XYLOPHONE', 'xylophone')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NDAwNg=="}, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTQ2MjQwOnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/devops.rb", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo1NDo1N1rOFzulbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo1NDo1N1rOFzulbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NDk0Mg==", "bodyText": "I'd add an example to the comments for this arg and envs-file since environment can be an ambiguous term.", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389784942", "createdAt": "2020-03-09T15:54:57Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/devops.rb", "diffHunk": "@@ -0,0 +1,75 @@\n+#!/usr/bin/env ruby\n+\n+require 'logger'\n+require 'optparse'\n+require 'ostruct'\n+\n+require_relative 'tasks/monitoring_assets'\n+require_relative 'tasks/dashboards'\n+require_relative 'tasks/logs_based_metrics'\n+require_relative 'tasks/service_accounts'\n+\n+# Single entry point for the devops framework. This is the only true Ruby Script file. The\n+# rest are classes.\n+#\n+# Based on input commands, this script delegates the work to  a task class, which should not need to\n+# know anything about environment variables such as ARGV, the run directory,  etc. Tasks should also avoid\n+# global variables like `logger`, so that we can control logging preferences from the top level.\n+\n+# TODO(jaycarlton): work out a scheme for task-specific options (i.e. subcommands)\n+def parse_options\n+  # options = OpenStruct.new\n+  # options.dry_run = true\n+  # options.envs_file = ENV['DEVOPS_TOOLKIT_ENVIRONMENTS_FILE']\n+  options = {}\n+  OptionParser.new do |parser|\n+    parser.on('-t', '--task [TASK]', String, 'Task to be in in each environment')\n+    parser.on('-x', '--require XYLOPHONE', 'xylophone')\n+    parser.on('-e', '--envs-file [ENVS]', String, 'Path to environments JSON file.')\n+    parser.on('-s', '--source-uri [SOURCE-URI]', String, 'URI or FQ name for source asset')\n+    parser.on('-u', '--source-env [SOURCE-ENV]', String, 'Short name for source Environment (lowercase)')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTQ5OTIyOnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowMzoxOVrOFzu7-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMDowODozM1rOFz3lmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MDcxMw==", "bodyText": "necessary comment?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389790713", "createdAt": "2020-03-09T16:03:19Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "diffHunk": "@@ -0,0 +1,153 @@\n+require 'google/cloud/monitoring/dashboard/v1'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+class Dashboards\n+  RESOURCE_NAMESPACE_PATTERN = /resource.label.\"namespace\"=\"\\w+\"/\n+  CUSTOM_DASHBOARD_FILTER = \"dashboard.name = starts_with(\\\"custom.googleapis.com/\\\")\"\n+\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'dry-run']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  # List all the custom dashboards in each environment\n+  def list\n+    @visitor.visit do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      dashboard_client.list_dashboards(env.formatted_project_number).each do |dash|\n+        @logger.info(\"#{dash.display_name}\\t#{self.class.dashboard_console_link(dash, env.project_id)}\")\n+        @logger.info(dash.to_json)\n+        dash.grid_layout.widgets.each do |widget|\n+          @logger.info(\"\\tChart \\\"#{widget.title}\\\"\")\n+        end\n+      end\n+    end\n+  end\n+\n+  # Take a dashboard from the source environment, tweak it for each target environment, and\n+  # create a copy.\n+  # TODO(jaycarlton) We have two replicate tasks already, and the pattern vis-a-vis the visitor\n+  # is the same. So we can think about making this replication visiting pattern part of the visitor\n+  # itself, or otherwise genericker than it is currently.\n+  def replicate\n+    source_dashboard = get_source_dashboard\n+    @logger.info(\"Retrieved source dashboard #{source_dashboard.to_json}\")\n+    copy_to_target_envs(source_dashboard)\n+  end\n+\n+  # Construct a link to the monitoring console. Note that in the IntelliJ debugger console,\n+  # these are clickable links. I don't see this out of the box in my OS's terminal though.\n+  def self.dashboard_console_link(dashboard, project_id)\n+    \"https://console.cloud.google.com/monitoring/dashboards/custom/#{dashboard_number(dashboard)}\" +\n+        \"?project=#{project_id}\"\n+  end\n+\n+  # The dashboard link requires the number to the far right in the name,\n+  # which  is formated like projects/<project_number>/dashboards/<dashboard_number>\n+  def self.dashboard_number(dashboard)\n+    dashboard.name.split('/')[-1]\n+  end\n+\n+  # Create the resource string/URI for a dashboard. The API expects the format\n+  # projects/{project_id_or_number}/dashboards/{dashboard_id}\n+  def self.dashboard_resource_path(env, dashboard_number)\n+    \"projects/#{env.project_number}/dashboards/#{dashboard_number}\"\n+  end\n+\n+  # Return true if this dashbaord is already present in the current environment.\n+  # Irritatingly, we can't just just get_dashboard for this, as it throws an exception if\n+  # it's not found.\n+  def self.dashboard_exists?(dashboard_client, env, dashboard_name)\n+    # all = dashboard_client.list_dashboards(env.formatted_project_number, filter: CUSTOM_DASHBOARD_FILTER)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzMjQ0MA==", "bodyText": "good catch.", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389932440", "createdAt": "2020-03-09T20:08:33Z", "author": {"login": "jaycarlton"}, "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "diffHunk": "@@ -0,0 +1,153 @@\n+require 'google/cloud/monitoring/dashboard/v1'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+class Dashboards\n+  RESOURCE_NAMESPACE_PATTERN = /resource.label.\"namespace\"=\"\\w+\"/\n+  CUSTOM_DASHBOARD_FILTER = \"dashboard.name = starts_with(\\\"custom.googleapis.com/\\\")\"\n+\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'dry-run']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  # List all the custom dashboards in each environment\n+  def list\n+    @visitor.visit do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      dashboard_client.list_dashboards(env.formatted_project_number).each do |dash|\n+        @logger.info(\"#{dash.display_name}\\t#{self.class.dashboard_console_link(dash, env.project_id)}\")\n+        @logger.info(dash.to_json)\n+        dash.grid_layout.widgets.each do |widget|\n+          @logger.info(\"\\tChart \\\"#{widget.title}\\\"\")\n+        end\n+      end\n+    end\n+  end\n+\n+  # Take a dashboard from the source environment, tweak it for each target environment, and\n+  # create a copy.\n+  # TODO(jaycarlton) We have two replicate tasks already, and the pattern vis-a-vis the visitor\n+  # is the same. So we can think about making this replication visiting pattern part of the visitor\n+  # itself, or otherwise genericker than it is currently.\n+  def replicate\n+    source_dashboard = get_source_dashboard\n+    @logger.info(\"Retrieved source dashboard #{source_dashboard.to_json}\")\n+    copy_to_target_envs(source_dashboard)\n+  end\n+\n+  # Construct a link to the monitoring console. Note that in the IntelliJ debugger console,\n+  # these are clickable links. I don't see this out of the box in my OS's terminal though.\n+  def self.dashboard_console_link(dashboard, project_id)\n+    \"https://console.cloud.google.com/monitoring/dashboards/custom/#{dashboard_number(dashboard)}\" +\n+        \"?project=#{project_id}\"\n+  end\n+\n+  # The dashboard link requires the number to the far right in the name,\n+  # which  is formated like projects/<project_number>/dashboards/<dashboard_number>\n+  def self.dashboard_number(dashboard)\n+    dashboard.name.split('/')[-1]\n+  end\n+\n+  # Create the resource string/URI for a dashboard. The API expects the format\n+  # projects/{project_id_or_number}/dashboards/{dashboard_id}\n+  def self.dashboard_resource_path(env, dashboard_number)\n+    \"projects/#{env.project_number}/dashboards/#{dashboard_number}\"\n+  end\n+\n+  # Return true if this dashbaord is already present in the current environment.\n+  # Irritatingly, we can't just just get_dashboard for this, as it throws an exception if\n+  # it's not found.\n+  def self.dashboard_exists?(dashboard_client, env, dashboard_name)\n+    # all = dashboard_client.list_dashboards(env.formatted_project_number, filter: CUSTOM_DASHBOARD_FILTER)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MDcxMw=="}, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTQ5OTU3OnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowMzoyNVrOFzu8LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowMzoyNVrOFzu8LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MDc2NA==", "bodyText": "necessary comment?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389790764", "createdAt": "2020-03-09T16:03:25Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "diffHunk": "@@ -0,0 +1,153 @@\n+require 'google/cloud/monitoring/dashboard/v1'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+class Dashboards\n+  RESOURCE_NAMESPACE_PATTERN = /resource.label.\"namespace\"=\"\\w+\"/\n+  CUSTOM_DASHBOARD_FILTER = \"dashboard.name = starts_with(\\\"custom.googleapis.com/\\\")\"\n+\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'dry-run']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  # List all the custom dashboards in each environment\n+  def list\n+    @visitor.visit do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      dashboard_client.list_dashboards(env.formatted_project_number).each do |dash|\n+        @logger.info(\"#{dash.display_name}\\t#{self.class.dashboard_console_link(dash, env.project_id)}\")\n+        @logger.info(dash.to_json)\n+        dash.grid_layout.widgets.each do |widget|\n+          @logger.info(\"\\tChart \\\"#{widget.title}\\\"\")\n+        end\n+      end\n+    end\n+  end\n+\n+  # Take a dashboard from the source environment, tweak it for each target environment, and\n+  # create a copy.\n+  # TODO(jaycarlton) We have two replicate tasks already, and the pattern vis-a-vis the visitor\n+  # is the same. So we can think about making this replication visiting pattern part of the visitor\n+  # itself, or otherwise genericker than it is currently.\n+  def replicate\n+    source_dashboard = get_source_dashboard\n+    @logger.info(\"Retrieved source dashboard #{source_dashboard.to_json}\")\n+    copy_to_target_envs(source_dashboard)\n+  end\n+\n+  # Construct a link to the monitoring console. Note that in the IntelliJ debugger console,\n+  # these are clickable links. I don't see this out of the box in my OS's terminal though.\n+  def self.dashboard_console_link(dashboard, project_id)\n+    \"https://console.cloud.google.com/monitoring/dashboards/custom/#{dashboard_number(dashboard)}\" +\n+        \"?project=#{project_id}\"\n+  end\n+\n+  # The dashboard link requires the number to the far right in the name,\n+  # which  is formated like projects/<project_number>/dashboards/<dashboard_number>\n+  def self.dashboard_number(dashboard)\n+    dashboard.name.split('/')[-1]\n+  end\n+\n+  # Create the resource string/URI for a dashboard. The API expects the format\n+  # projects/{project_id_or_number}/dashboards/{dashboard_id}\n+  def self.dashboard_resource_path(env, dashboard_number)\n+    \"projects/#{env.project_number}/dashboards/#{dashboard_number}\"\n+  end\n+\n+  # Return true if this dashbaord is already present in the current environment.\n+  # Irritatingly, we can't just just get_dashboard for this, as it throws an exception if\n+  # it's not found.\n+  def self.dashboard_exists?(dashboard_client, env, dashboard_name)\n+    # all = dashboard_client.list_dashboards(env.formatted_project_number, filter: CUSTOM_DASHBOARD_FILTER)\n+    all = dashboard_client.list_dashboards(env.formatted_project_number)\n+    all.any? { |dash| dash.name == dashboard_name }\n+  end\n+\n+  private\n+\n+  def get_source_dashboard\n+    source_env = @visitor.env_map[@source_env_short_name]\n+    # source_env = @visitor.env_by_short_name(@source_env_short_name)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTUwOTExOnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowNTozOVrOFzvB6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowNTozOVrOFzvB6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MjIzNQ==", "bodyText": "the visitor makes it seem like we're visiting multiple environments but only the last one is being returned as part of result. Is it just visiting one environment every time this is invoked?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389792235", "createdAt": "2020-03-09T16:05:39Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "diffHunk": "@@ -0,0 +1,153 @@\n+require 'google/cloud/monitoring/dashboard/v1'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+class Dashboards\n+  RESOURCE_NAMESPACE_PATTERN = /resource.label.\"namespace\"=\"\\w+\"/\n+  CUSTOM_DASHBOARD_FILTER = \"dashboard.name = starts_with(\\\"custom.googleapis.com/\\\")\"\n+\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'dry-run']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  # List all the custom dashboards in each environment\n+  def list\n+    @visitor.visit do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      dashboard_client.list_dashboards(env.formatted_project_number).each do |dash|\n+        @logger.info(\"#{dash.display_name}\\t#{self.class.dashboard_console_link(dash, env.project_id)}\")\n+        @logger.info(dash.to_json)\n+        dash.grid_layout.widgets.each do |widget|\n+          @logger.info(\"\\tChart \\\"#{widget.title}\\\"\")\n+        end\n+      end\n+    end\n+  end\n+\n+  # Take a dashboard from the source environment, tweak it for each target environment, and\n+  # create a copy.\n+  # TODO(jaycarlton) We have two replicate tasks already, and the pattern vis-a-vis the visitor\n+  # is the same. So we can think about making this replication visiting pattern part of the visitor\n+  # itself, or otherwise genericker than it is currently.\n+  def replicate\n+    source_dashboard = get_source_dashboard\n+    @logger.info(\"Retrieved source dashboard #{source_dashboard.to_json}\")\n+    copy_to_target_envs(source_dashboard)\n+  end\n+\n+  # Construct a link to the monitoring console. Note that in the IntelliJ debugger console,\n+  # these are clickable links. I don't see this out of the box in my OS's terminal though.\n+  def self.dashboard_console_link(dashboard, project_id)\n+    \"https://console.cloud.google.com/monitoring/dashboards/custom/#{dashboard_number(dashboard)}\" +\n+        \"?project=#{project_id}\"\n+  end\n+\n+  # The dashboard link requires the number to the far right in the name,\n+  # which  is formated like projects/<project_number>/dashboards/<dashboard_number>\n+  def self.dashboard_number(dashboard)\n+    dashboard.name.split('/')[-1]\n+  end\n+\n+  # Create the resource string/URI for a dashboard. The API expects the format\n+  # projects/{project_id_or_number}/dashboards/{dashboard_id}\n+  def self.dashboard_resource_path(env, dashboard_number)\n+    \"projects/#{env.project_number}/dashboards/#{dashboard_number}\"\n+  end\n+\n+  # Return true if this dashbaord is already present in the current environment.\n+  # Irritatingly, we can't just just get_dashboard for this, as it throws an exception if\n+  # it's not found.\n+  def self.dashboard_exists?(dashboard_client, env, dashboard_name)\n+    # all = dashboard_client.list_dashboards(env.formatted_project_number, filter: CUSTOM_DASHBOARD_FILTER)\n+    all = dashboard_client.list_dashboards(env.formatted_project_number)\n+    all.any? { |dash| dash.name == dashboard_name }\n+  end\n+\n+  private\n+\n+  def get_source_dashboard\n+    source_env = @visitor.env_map[@source_env_short_name]\n+    # source_env = @visitor.env_by_short_name(@source_env_short_name)\n+    result = nil\n+    @visitor.visit(source_env) do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      source_dashboard_path = self.class.dashboard_resource_path(env, @source_dashboard_number)\n+      result = dashboard_client.get_dashboard(source_dashboard_path)\n+      @logger.info(\"Template dashboard: display_name: #{result.display_name}, name: #{result.name}\")\n+      @logger.info(result)\n+    end\n+    result", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTUxMDI5OnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowNTo1NlrOFzvCkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowNTo1NlrOFzvCkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MjQwMQ==", "bodyText": "necessary comment?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389792401", "createdAt": "2020-03-09T16:05:56Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "diffHunk": "@@ -0,0 +1,153 @@\n+require 'google/cloud/monitoring/dashboard/v1'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+class Dashboards\n+  RESOURCE_NAMESPACE_PATTERN = /resource.label.\"namespace\"=\"\\w+\"/\n+  CUSTOM_DASHBOARD_FILTER = \"dashboard.name = starts_with(\\\"custom.googleapis.com/\\\")\"\n+\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'dry-run']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  # List all the custom dashboards in each environment\n+  def list\n+    @visitor.visit do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      dashboard_client.list_dashboards(env.formatted_project_number).each do |dash|\n+        @logger.info(\"#{dash.display_name}\\t#{self.class.dashboard_console_link(dash, env.project_id)}\")\n+        @logger.info(dash.to_json)\n+        dash.grid_layout.widgets.each do |widget|\n+          @logger.info(\"\\tChart \\\"#{widget.title}\\\"\")\n+        end\n+      end\n+    end\n+  end\n+\n+  # Take a dashboard from the source environment, tweak it for each target environment, and\n+  # create a copy.\n+  # TODO(jaycarlton) We have two replicate tasks already, and the pattern vis-a-vis the visitor\n+  # is the same. So we can think about making this replication visiting pattern part of the visitor\n+  # itself, or otherwise genericker than it is currently.\n+  def replicate\n+    source_dashboard = get_source_dashboard\n+    @logger.info(\"Retrieved source dashboard #{source_dashboard.to_json}\")\n+    copy_to_target_envs(source_dashboard)\n+  end\n+\n+  # Construct a link to the monitoring console. Note that in the IntelliJ debugger console,\n+  # these are clickable links. I don't see this out of the box in my OS's terminal though.\n+  def self.dashboard_console_link(dashboard, project_id)\n+    \"https://console.cloud.google.com/monitoring/dashboards/custom/#{dashboard_number(dashboard)}\" +\n+        \"?project=#{project_id}\"\n+  end\n+\n+  # The dashboard link requires the number to the far right in the name,\n+  # which  is formated like projects/<project_number>/dashboards/<dashboard_number>\n+  def self.dashboard_number(dashboard)\n+    dashboard.name.split('/')[-1]\n+  end\n+\n+  # Create the resource string/URI for a dashboard. The API expects the format\n+  # projects/{project_id_or_number}/dashboards/{dashboard_id}\n+  def self.dashboard_resource_path(env, dashboard_number)\n+    \"projects/#{env.project_number}/dashboards/#{dashboard_number}\"\n+  end\n+\n+  # Return true if this dashbaord is already present in the current environment.\n+  # Irritatingly, we can't just just get_dashboard for this, as it throws an exception if\n+  # it's not found.\n+  def self.dashboard_exists?(dashboard_client, env, dashboard_name)\n+    # all = dashboard_client.list_dashboards(env.formatted_project_number, filter: CUSTOM_DASHBOARD_FILTER)\n+    all = dashboard_client.list_dashboards(env.formatted_project_number)\n+    all.any? { |dash| dash.name == dashboard_name }\n+  end\n+\n+  private\n+\n+  def get_source_dashboard\n+    source_env = @visitor.env_map[@source_env_short_name]\n+    # source_env = @visitor.env_by_short_name(@source_env_short_name)\n+    result = nil\n+    @visitor.visit(source_env) do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      source_dashboard_path = self.class.dashboard_resource_path(env, @source_dashboard_number)\n+      result = dashboard_client.get_dashboard(source_dashboard_path)\n+      @logger.info(\"Template dashboard: display_name: #{result.display_name}, name: #{result.name}\")\n+      @logger.info(result)\n+    end\n+    result\n+  end\n+\n+  def copy_to_target_envs(source_dashboard)\n+    target_envs = @visitor.target_envs(@source_env_short_name) # environments.select { |env| env.short_name != @source_env_short_name }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTUxODY5OnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowODowNlrOFzvIAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowODowNlrOFzvIAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5Mzc5Mg==", "bodyText": "comment?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389793792", "createdAt": "2020-03-09T16:08:06Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "diffHunk": "@@ -0,0 +1,153 @@\n+require 'google/cloud/monitoring/dashboard/v1'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+class Dashboards\n+  RESOURCE_NAMESPACE_PATTERN = /resource.label.\"namespace\"=\"\\w+\"/\n+  CUSTOM_DASHBOARD_FILTER = \"dashboard.name = starts_with(\\\"custom.googleapis.com/\\\")\"\n+\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'dry-run']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  # List all the custom dashboards in each environment\n+  def list\n+    @visitor.visit do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      dashboard_client.list_dashboards(env.formatted_project_number).each do |dash|\n+        @logger.info(\"#{dash.display_name}\\t#{self.class.dashboard_console_link(dash, env.project_id)}\")\n+        @logger.info(dash.to_json)\n+        dash.grid_layout.widgets.each do |widget|\n+          @logger.info(\"\\tChart \\\"#{widget.title}\\\"\")\n+        end\n+      end\n+    end\n+  end\n+\n+  # Take a dashboard from the source environment, tweak it for each target environment, and\n+  # create a copy.\n+  # TODO(jaycarlton) We have two replicate tasks already, and the pattern vis-a-vis the visitor\n+  # is the same. So we can think about making this replication visiting pattern part of the visitor\n+  # itself, or otherwise genericker than it is currently.\n+  def replicate\n+    source_dashboard = get_source_dashboard\n+    @logger.info(\"Retrieved source dashboard #{source_dashboard.to_json}\")\n+    copy_to_target_envs(source_dashboard)\n+  end\n+\n+  # Construct a link to the monitoring console. Note that in the IntelliJ debugger console,\n+  # these are clickable links. I don't see this out of the box in my OS's terminal though.\n+  def self.dashboard_console_link(dashboard, project_id)\n+    \"https://console.cloud.google.com/monitoring/dashboards/custom/#{dashboard_number(dashboard)}\" +\n+        \"?project=#{project_id}\"\n+  end\n+\n+  # The dashboard link requires the number to the far right in the name,\n+  # which  is formated like projects/<project_number>/dashboards/<dashboard_number>\n+  def self.dashboard_number(dashboard)\n+    dashboard.name.split('/')[-1]\n+  end\n+\n+  # Create the resource string/URI for a dashboard. The API expects the format\n+  # projects/{project_id_or_number}/dashboards/{dashboard_id}\n+  def self.dashboard_resource_path(env, dashboard_number)\n+    \"projects/#{env.project_number}/dashboards/#{dashboard_number}\"\n+  end\n+\n+  # Return true if this dashbaord is already present in the current environment.\n+  # Irritatingly, we can't just just get_dashboard for this, as it throws an exception if\n+  # it's not found.\n+  def self.dashboard_exists?(dashboard_client, env, dashboard_name)\n+    # all = dashboard_client.list_dashboards(env.formatted_project_number, filter: CUSTOM_DASHBOARD_FILTER)\n+    all = dashboard_client.list_dashboards(env.formatted_project_number)\n+    all.any? { |dash| dash.name == dashboard_name }\n+  end\n+\n+  private\n+\n+  def get_source_dashboard\n+    source_env = @visitor.env_map[@source_env_short_name]\n+    # source_env = @visitor.env_by_short_name(@source_env_short_name)\n+    result = nil\n+    @visitor.visit(source_env) do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      source_dashboard_path = self.class.dashboard_resource_path(env, @source_dashboard_number)\n+      result = dashboard_client.get_dashboard(source_dashboard_path)\n+      @logger.info(\"Template dashboard: display_name: #{result.display_name}, name: #{result.name}\")\n+      @logger.info(result)\n+    end\n+    result\n+  end\n+\n+  def copy_to_target_envs(source_dashboard)\n+    target_envs = @visitor.target_envs(@source_env_short_name) # environments.select { |env| env.short_name != @source_env_short_name }\n+    @visitor.visit(target_envs) do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+\n+      # Need to perform existence check with new environment's project number in the resource path.\n+      target_resource_path = self.class.dashboard_resource_path(env, self.class.dashboard_number(source_dashboard))\n+      if self.class.dashboard_exists?(dashboard_client, env, target_resource_path)\n+        @logger.warn(\"Skipping target env #{env.short_name} as #{source_dashboard.name} is already there.\")\n+        next\n+      end\n+\n+      # Customize this dashboard for the current environment. Typically this means setting the\n+      # namespace properly in all the charts and/or adjusting the title.\n+      replacement_dashboard = build_replacement_dashboard(env, source_dashboard, target_resource_path)\n+\n+      # add the dashboard to the project\n+      @logger.info(\"creating with parent: #{env.formatted_project_number}, dashboard name: #{replacement_dashboard.name}\")\n+      dashboard_client.create_dashboard(env.formatted_project_number, replacement_dashboard) do |created_dash|\n+        @logger.info(\"created dashboard: #{created_dash.to_json}\")\n+      end\n+    end\n+  end\n+\n+  def build_replacement_dashboard(env, source_dashboard, target_resource_path)\n+    # result = Google::Monitoring::Dashboard::V1::Dashboard.new", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTUxOTAxOnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowODoxMlrOFzvIOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowODoxMlrOFzvIOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5Mzg0OA==", "bodyText": "comment?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389793848", "createdAt": "2020-03-09T16:08:12Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/dashboards.rb", "diffHunk": "@@ -0,0 +1,153 @@\n+require 'google/cloud/monitoring/dashboard/v1'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+class Dashboards\n+  RESOURCE_NAMESPACE_PATTERN = /resource.label.\"namespace\"=\"\\w+\"/\n+  CUSTOM_DASHBOARD_FILTER = \"dashboard.name = starts_with(\\\"custom.googleapis.com/\\\")\"\n+\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'dry-run']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  # List all the custom dashboards in each environment\n+  def list\n+    @visitor.visit do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      dashboard_client.list_dashboards(env.formatted_project_number).each do |dash|\n+        @logger.info(\"#{dash.display_name}\\t#{self.class.dashboard_console_link(dash, env.project_id)}\")\n+        @logger.info(dash.to_json)\n+        dash.grid_layout.widgets.each do |widget|\n+          @logger.info(\"\\tChart \\\"#{widget.title}\\\"\")\n+        end\n+      end\n+    end\n+  end\n+\n+  # Take a dashboard from the source environment, tweak it for each target environment, and\n+  # create a copy.\n+  # TODO(jaycarlton) We have two replicate tasks already, and the pattern vis-a-vis the visitor\n+  # is the same. So we can think about making this replication visiting pattern part of the visitor\n+  # itself, or otherwise genericker than it is currently.\n+  def replicate\n+    source_dashboard = get_source_dashboard\n+    @logger.info(\"Retrieved source dashboard #{source_dashboard.to_json}\")\n+    copy_to_target_envs(source_dashboard)\n+  end\n+\n+  # Construct a link to the monitoring console. Note that in the IntelliJ debugger console,\n+  # these are clickable links. I don't see this out of the box in my OS's terminal though.\n+  def self.dashboard_console_link(dashboard, project_id)\n+    \"https://console.cloud.google.com/monitoring/dashboards/custom/#{dashboard_number(dashboard)}\" +\n+        \"?project=#{project_id}\"\n+  end\n+\n+  # The dashboard link requires the number to the far right in the name,\n+  # which  is formated like projects/<project_number>/dashboards/<dashboard_number>\n+  def self.dashboard_number(dashboard)\n+    dashboard.name.split('/')[-1]\n+  end\n+\n+  # Create the resource string/URI for a dashboard. The API expects the format\n+  # projects/{project_id_or_number}/dashboards/{dashboard_id}\n+  def self.dashboard_resource_path(env, dashboard_number)\n+    \"projects/#{env.project_number}/dashboards/#{dashboard_number}\"\n+  end\n+\n+  # Return true if this dashbaord is already present in the current environment.\n+  # Irritatingly, we can't just just get_dashboard for this, as it throws an exception if\n+  # it's not found.\n+  def self.dashboard_exists?(dashboard_client, env, dashboard_name)\n+    # all = dashboard_client.list_dashboards(env.formatted_project_number, filter: CUSTOM_DASHBOARD_FILTER)\n+    all = dashboard_client.list_dashboards(env.formatted_project_number)\n+    all.any? { |dash| dash.name == dashboard_name }\n+  end\n+\n+  private\n+\n+  def get_source_dashboard\n+    source_env = @visitor.env_map[@source_env_short_name]\n+    # source_env = @visitor.env_by_short_name(@source_env_short_name)\n+    result = nil\n+    @visitor.visit(source_env) do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+      source_dashboard_path = self.class.dashboard_resource_path(env, @source_dashboard_number)\n+      result = dashboard_client.get_dashboard(source_dashboard_path)\n+      @logger.info(\"Template dashboard: display_name: #{result.display_name}, name: #{result.name}\")\n+      @logger.info(result)\n+    end\n+    result\n+  end\n+\n+  def copy_to_target_envs(source_dashboard)\n+    target_envs = @visitor.target_envs(@source_env_short_name) # environments.select { |env| env.short_name != @source_env_short_name }\n+    @visitor.visit(target_envs) do |env|\n+      dashboard_client = Google::Cloud::Monitoring::Dashboard::V1::DashboardsServiceClient.new\n+\n+      # Need to perform existence check with new environment's project number in the resource path.\n+      target_resource_path = self.class.dashboard_resource_path(env, self.class.dashboard_number(source_dashboard))\n+      if self.class.dashboard_exists?(dashboard_client, env, target_resource_path)\n+        @logger.warn(\"Skipping target env #{env.short_name} as #{source_dashboard.name} is already there.\")\n+        next\n+      end\n+\n+      # Customize this dashboard for the current environment. Typically this means setting the\n+      # namespace properly in all the charts and/or adjusting the title.\n+      replacement_dashboard = build_replacement_dashboard(env, source_dashboard, target_resource_path)\n+\n+      # add the dashboard to the project\n+      @logger.info(\"creating with parent: #{env.formatted_project_number}, dashboard name: #{replacement_dashboard.name}\")\n+      dashboard_client.create_dashboard(env.formatted_project_number, replacement_dashboard) do |created_dash|\n+        @logger.info(\"created dashboard: #{created_dash.to_json}\")\n+      end\n+    end\n+  end\n+\n+  def build_replacement_dashboard(env, source_dashboard, target_resource_path)\n+    # result = Google::Monitoring::Dashboard::V1::Dashboard.new\n+    source_dashboard.freeze # avoid contaminating our source dashboard\n+    result = source_dashboard.dup\n+    result.etag = '' # populated by the create API\n+    result.name = target_resource_path\n+    # result.grid_layout = Google::Monitoring::Dashboard::V1::GridLayout.new", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTU4NzYxOnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/tasks/logs_based_metrics.rb", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjoyNTowMlrOFzvy2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo1MDo0NVrOFz3CiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwNDc2Mg==", "bodyText": "how does a metric's name relate to a dashboard number?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389804762", "createdAt": "2020-03-09T16:25:02Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/logs_based_metrics.rb", "diffHunk": "@@ -0,0 +1,68 @@\n+require 'google/cloud/logging'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+# Take a source environment and logs-based metric URI and replicate it across all target environments\n+# Note well: if two environments share a GCP project, this means they share a metrics namespace.\n+# If those projects share a log file (distinguished by MonitoredResource), then we dont' want to duplicate\n+# a metric into that shared environment.\n+class LogsBasedMetrics\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'replicate']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  def replicate\n+    # Visit the source environment and smuggle out a metric definition\n+    source_metric = get_source_metric\n+\n+    # Replicate to the other environments (all but source env)\n+    copy_to_target_envs(source_metric)\n+  end\n+\n+  private\n+\n+  # Fetch the source metric by name from the source environment\n+  def get_source_metric\n+    source_env = @visitor.env_by_short_name(@source_env_short_name)\n+    @logger.info(\"Source environment is #{source_env}\")\n+    source_metric = nil # extract from its environment\n+    @visitor.visit(source_env) do |env|\n+      logging_client = Google::Cloud::Logging.new({project: env.project_id})\n+      metrics = logging_client.metrics\n+      source_metric = metrics.select { |m| m.name == @source_dashboard_number }.first", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMzQ2NA==", "bodyText": "They're completely independent.  A metric might be represented on zero or dozens of dashboards.\nGoogle just assigns dashboard numbers randomly as far as I can tell in the console, but I have to pick them randomly.", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389923464", "createdAt": "2020-03-09T19:50:45Z", "author": {"login": "jaycarlton"}, "path": "ops/ruby/devops-toolkit/tasks/logs_based_metrics.rb", "diffHunk": "@@ -0,0 +1,68 @@\n+require 'google/cloud/logging'\n+require_relative 'lib/gcp_environment_visitor.rb'\n+\n+# Take a source environment and logs-based metric URI and replicate it across all target environments\n+# Note well: if two environments share a GCP project, this means they share a metrics namespace.\n+# If those projects share a log file (distinguished by MonitoredResource), then we dont' want to duplicate\n+# a metric into that shared environment.\n+class LogsBasedMetrics\n+  def initialize(options)\n+    @envs_file = options[:'envs-file']\n+    @source_dashboard_number = options[:'source-uri']\n+    @source_env_short_name = options[:'source-env']\n+    @logger = options[:logger] || Logger.new(STDOUT)\n+    @is_dry_run = options[:'replicate']\n+    @visitor = GcpEnvironmentVisitor.new(@envs_file, @logger)\n+  end\n+\n+  def replicate\n+    # Visit the source environment and smuggle out a metric definition\n+    source_metric = get_source_metric\n+\n+    # Replicate to the other environments (all but source env)\n+    copy_to_target_envs(source_metric)\n+  end\n+\n+  private\n+\n+  # Fetch the source metric by name from the source environment\n+  def get_source_metric\n+    source_env = @visitor.env_by_short_name(@source_env_short_name)\n+    @logger.info(\"Source environment is #{source_env}\")\n+    source_metric = nil # extract from its environment\n+    @visitor.visit(source_env) do |env|\n+      logging_client = Google::Cloud::Logging.new({project: env.project_id})\n+      metrics = logging_client.metrics\n+      source_metric = metrics.select { |m| m.name == @source_dashboard_number }.first", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwNDc2Mg=="}, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTU5OTE5OnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/tasks/service_accounts.rb", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjoyNzoxOVrOFzv5gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo1MTo0NlrOFz3Eig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwNjQ2Ng==", "bodyText": "would this delete keys that are in active use by other developers?", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389806466", "createdAt": "2020-03-09T16:27:19Z", "author": {"login": "ericsong"}, "path": "ops/ruby/devops-toolkit/tasks/service_accounts.rb", "diffHunk": "@@ -0,0 +1,61 @@\n+require 'open3'\n+\n+# This class avoids the GcpEnvironmentVisitor because we don't want to create or delete\n+# any new SA keys, and we're doing everything with the gcloud command line anyway.\n+class ServiceAccounts\n+  def initialize(options)\n+    envs_json = JSON.load(IO.read(options[:'envs-file']))\n+    @environments = envs_json['environments'].map { |env| GcpEnvironmentInfo.new(env) }\n+    @logger = options[:logger]\n+    @is_dry_run = options[:'dry-run'] ? true : false\n+  end\n+\n+  def list_keys\n+    @environments.each do |env|\n+      get_keys(env).each do |key|\n+        @logger.info(key)\n+      end\n+    end\n+  end\n+\n+  # This tool does not use the GcpEnvironmentVisitor, as it's specifically cleaning up after it.\n+  def delete_all_keys\n+    @environments.each do |env|\n+      keys = get_keys(env)\n+      keys.each do |key|\n+        if @is_dry_run == true\n+          @logger.info(\"would delete key #{key} for SA #{env.service_account} in project\")\n+        else\n+          delete_key(key, env)\n+        end\n+      end\n+    end\n+  end\n+\n+  # Get key JSON objects\n+  def get_keys(env)\n+    list_cmd = %W[gcloud iam service-accounts keys list", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMzk3OA==", "bodyText": "Yes. It's not for the faint of heart. I don't think there's a way to list keys that only I created.\nThe only reason this is needed is for debugging when you trap the process but forget to let it resume so it can delete the exact key it created.", "url": "https://github.com/all-of-us/workbench/pull/3203#discussion_r389923978", "createdAt": "2020-03-09T19:51:46Z", "author": {"login": "jaycarlton"}, "path": "ops/ruby/devops-toolkit/tasks/service_accounts.rb", "diffHunk": "@@ -0,0 +1,61 @@\n+require 'open3'\n+\n+# This class avoids the GcpEnvironmentVisitor because we don't want to create or delete\n+# any new SA keys, and we're doing everything with the gcloud command line anyway.\n+class ServiceAccounts\n+  def initialize(options)\n+    envs_json = JSON.load(IO.read(options[:'envs-file']))\n+    @environments = envs_json['environments'].map { |env| GcpEnvironmentInfo.new(env) }\n+    @logger = options[:logger]\n+    @is_dry_run = options[:'dry-run'] ? true : false\n+  end\n+\n+  def list_keys\n+    @environments.each do |env|\n+      get_keys(env).each do |key|\n+        @logger.info(key)\n+      end\n+    end\n+  end\n+\n+  # This tool does not use the GcpEnvironmentVisitor, as it's specifically cleaning up after it.\n+  def delete_all_keys\n+    @environments.each do |env|\n+      keys = get_keys(env)\n+      keys.each do |key|\n+        if @is_dry_run == true\n+          @logger.info(\"would delete key #{key} for SA #{env.service_account} in project\")\n+        else\n+          delete_key(key, env)\n+        end\n+      end\n+    end\n+  end\n+\n+  # Get key JSON objects\n+  def get_keys(env)\n+    list_cmd = %W[gcloud iam service-accounts keys list", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwNjQ2Ng=="}, "originalCommit": {"oid": "32b2bedf444dfdea28edb81318a81721ef9df992"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3177, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}