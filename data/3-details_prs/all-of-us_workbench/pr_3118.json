{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczODk3MTMx", "number": 3118, "title": "[risk=no]Institution DB/Model updates on the road toward RW-4259", "bodyText": "Description:\nDoes NOT resolve RW-4259.  This is just refactoring, partially to help make that easier.  Thanks to @freemabd who did the majority of the work.\nTIL a lot:\n\nRW best practices are to annotate the accessors, not the fields.  This lets us add extra logic which Hibernate will use.\nLAZY vs EAGER fetch types affect functionality, not just resource usage.  (TODO: look into this more)\nHibernate does not work well when you reassign collections it's managing.  Always use add/remove/set/clear functions on the collection in-place.\nIt may be necessary to assign bidirectional links in both directions, but it is not always necessary to sever the link in both directions.\n\nTODO: look into this much more.  There's a lot of subtlety here.\n\n\n\n\nPR checklist\n\n This PR meets the Acceptance Criteria in the JIRA story\n The JIRA story has been moved to Dev Review\n This PR includes appropriate unit tests\n I have run and tested this change locally\n If this includes an API change, I have updated the appropriate Swagger definitions and notified API consumers\n If this includes a new feature flag, I have created and linked new JIRA tickets to (a) turn on the feature flag and (b) remove it later", "createdAt": "2020-02-11T21:41:56Z", "url": "https://github.com/all-of-us/workbench/pull/3118", "merged": true, "mergeCommit": {"oid": "7a811c9b5824a7bec95704cd3df0b4d8ab1a950e"}, "closed": true, "closedAt": "2020-02-13T01:47:48Z", "author": {"login": "jmthibault79"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDYxGAAH2gAyMzczODk3MTMxOjk0ZTVlMjgxMmQ0NTVjZjU4MWI2ZWUyMjk1ZGZlOGUzNTY4NDY2YjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDu1_yAH2gAyMzczODk3MTMxOjg2YjY4NGY5OGExYzE5YmNmYmNjZTdiZmJhOGZkNzZlMDhhMGY0MTI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "94e5e2812d455cf581b6ee2295dfe8e3568466b3", "author": {"user": {"login": "jmthibault79", "name": null}}, "url": "https://github.com/all-of-us/workbench/commit/94e5e2812d455cf581b6ee2295dfe8e3568466b3", "committedDate": "2020-02-11T21:39:12Z", "message": "REFACTOR better interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2528ac3643a5d3298fe94ebe3e12234cf9cb1eb", "author": {"user": {"login": "jmthibault79", "name": null}}, "url": "https://github.com/all-of-us/workbench/commit/f2528ac3643a5d3298fe94ebe3e12234cf9cb1eb", "committedDate": "2020-02-11T21:39:12Z", "message": "REFACTOR attempt at better Spring with much help from Brian\n\nnot working\n\ndoes not work - move column notions to accessors\n\nmoving annotations to getter/setters.\n\nbetter tests\n\nemail domains and addrs are NotNull\nremove DB ids from equality checks\n\nattempted fix by reusing collection\n\nfixing persistence of Institution.\n\nfixing tests.\n\nadding cascade to foreign keys, and updating tests.\n\nadding comment\n\nsmall test updates\n\nfun with sets\n\nserviceImpl refactor\n\nmini test update\n\ncredit to Brian"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "author": {"user": {"login": "jmthibault79", "name": null}}, "url": "https://github.com/all-of-us/workbench/commit/e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "committedDate": "2020-02-11T21:39:12Z", "message": "fun with builders"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MDE3Nzk4", "url": "https://github.com/all-of-us/workbench/pull/3118#pullrequestreview-357017798", "createdAt": "2020-02-11T21:42:43Z", "commit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0Mjo0M1rOFoaOCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0Mjo0M1rOFoaOCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxNjkzOA==", "bodyText": "adds delete cascade", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377916938", "createdAt": "2020-02-11T21:42:43Z", "author": {"login": "jmthibault79"}, "path": "api/db/changelog/db.changelog-126-institution-foreign-key.xml", "diffHunk": "@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<databaseChangeLog\n+  xmlns=\"http://www.liquibase.org/xml/ns/dbchangelog/1.9\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://www.liquibase.org/xml/ns/dbchangelog/1.9\n+                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-1.9.xsd\">\n+  <changeSet author=\"brianfreeman\" id=\"changelog-126-institution-foreign-key\">\n+\n+    <dropForeignKeyConstraint\n+      baseTableName=\"institution_email_domain\"\n+      constraintName=\"fk_institution_email_domain\"/>\n+\n+    <addForeignKeyConstraint baseColumnNames=\"institution_id\"\n+      baseTableName=\"institution_email_domain\"\n+      constraintName=\"fk_institution_email_domain\"\n+      onDelete=\"CASCADE\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MDE4MDQw", "url": "https://github.com/all-of-us/workbench/pull/3118#pullrequestreview-357018040", "createdAt": "2020-02-11T21:43:07Z", "commit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0MzowN1rOFoaO5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0MzowN1rOFoaO5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxNzE1Ng==", "bodyText": "These are now fully managed by DbInstitution", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377917156", "createdAt": "2020-02-11T21:43:07Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/InstitutionEmailAddressDao.java", "diffHunk": "@@ -1,16 +0,0 @@\n-package org.pmiops.workbench.db.dao;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MDE5MjQy", "url": "https://github.com/all-of-us/workbench/pull/3118#pullrequestreview-357019242", "createdAt": "2020-02-11T21:45:04Z", "commit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0NTowNFrOFoaSyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0NTowNFrOFoaSyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxODE1NQ==", "bodyText": "RW best practices are to annotate the accessors, not the fields.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377918155", "createdAt": "2020-02-11T21:45:04Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,41 +12,35 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MDIxMDIy", "url": "https://github.com/all-of-us/workbench/pull/3118#pullrequestreview-357021022", "createdAt": "2020-02-11T21:47:59Z", "commit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0Nzo1OVrOFoaYOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0Nzo1OVrOFoaYOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxOTU0Ng==", "bodyText": "EAGER fetching is key to making this work correctly.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377919546", "createdAt": "2020-02-11T21:47:59Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MDIyODI1", "url": "https://github.com/all-of-us/workbench/pull/3118#pullrequestreview-357022825", "createdAt": "2020-02-11T21:50:50Z", "commit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1MDo1MFrOFoad8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1MDo1MFrOFoad8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTAwOA==", "bodyText": "Need to make the connection in both directions, but we only need to break it in one.  It is NOT necessary to make this null when removing.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377921008", "createdAt": "2020-02-11T21:50:50Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 145}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MDIzOTcx", "url": "https://github.com/all-of-us/workbench/pull/3118#pullrequestreview-357023971", "createdAt": "2020-02-11T21:52:46Z", "commit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1Mjo0NlrOFoahgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1Mjo0NlrOFoahgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTkyMg==", "bodyText": "API Model <-> DB Model conversions are now fully independent of DB state!\nTODO (not in this PR) move conversions out of here into a MapStruct mapper.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377921922", "createdAt": "2020-02-11T21:52:46Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,50 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MDM4ODU4", "url": "https://github.com/all-of-us/workbench/pull/3118#pullrequestreview-357038858", "createdAt": "2020-02-11T22:18:51Z", "commit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoxODo1MVrOFobPRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjozNzoxNlrOFobuZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMzYzNw==", "bodyText": "Huh, you don't have to give it the key column names. Neat.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377933637", "createdAt": "2020-02-11T22:18:51Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxOTU0Ng=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNDIyMw==", "bodyText": "nit: why are you calling the map variable address instead of ed or similar? I didn't think domains were addresses.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377934223", "createdAt": "2020-02-11T22:20:17Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTAwOA=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNTA3Mg==", "bodyText": "Can you explain at a higher level what this function is trying to accomplish? That is, why are we doing multiple set intersections? And why do we need a set difference if emailAddresses is a set to begin with? I thought adding an existing item was a no-op.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377935072", "createdAt": "2020-02-11T22:22:05Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution emailDomains(Set<DbInstitutionEmailDomain> emailDomains) {\n+    setEmailDomains(emailDomains);\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNjI1Ng==", "bodyText": "For clarity, I would make a public nested Builder class and put this there? An example is here. Though I guess you still need your no-arg ctor \ud83e\udd14 .\nAnyway, I wouldn't make an alias function (a non-overload with the same body) unless there's a compelling reason.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377936256", "createdAt": "2020-02-11T22:24:45Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution emailDomains(Set<DbInstitutionEmailDomain> emailDomains) {\n+    setEmailDomains(emailDomains);\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailAddresses the new set of addresses for this Institution\n+   */\n+  public void setEmailAddresses(final Set<DbInstitutionEmailAddress> emailAddresses) {\n+    final Set<DbInstitutionEmailAddress> attachedAddresses =\n+        emailAddresses.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailAddresses.retainAll(attachedAddresses);\n+    this.emailAddresses.addAll(Sets.difference(attachedAddresses, this.emailAddresses));\n+  }\n+\n+  /** Builder method to help streamline the building of a DbInstitution. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzE3NA==", "bodyText": "If this is nullable, should we return Optional<Long>?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377937174", "createdAt": "2020-02-11T22:26:44Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "diffHunk": "@@ -15,51 +15,57 @@\n @Table(name = \"institution_email_address\")\n public class DbInstitutionEmailAddress {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_email_address_id\")\n   private long institutionEmailAddressId;\n-\n-  @ManyToOne(fetch = FetchType.LAZY)\n-  @JoinColumn(name = \"institution_id\")\n   private DbInstitution institution;\n-\n-  @Column(name = \"email_address\", nullable = false)\n   private String emailAddress;\n \n   public DbInstitutionEmailAddress() {}\n \n-  public DbInstitutionEmailAddress(DbInstitution institution, String emailAddress) {\n-    this.institution = institution;\n-    this.emailAddress = emailAddress;\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_email_address_id\")\n+  public long getInstitutionEmailAddressId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzgxMg==", "bodyText": "I'd probably put this on the dao itself as a default List<Institution> getAllInstitutions() so all services using it get the benefit.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377937812", "createdAt": "2020-02-11T22:28:22Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -19,34 +17,27 @@\n public class InstitutionServiceImpl implements InstitutionService {\n \n   private final InstitutionDao institutionDao;\n-  private final InstitutionEmailDomainDao institutionEmailDomainDao;\n-  private final InstitutionEmailAddressDao institutionEmailAddressDao;\n \n   @Autowired\n-  InstitutionServiceImpl(\n-      InstitutionDao institutionDao,\n-      InstitutionEmailDomainDao institutionEmailDomainDao,\n-      InstitutionEmailAddressDao institutionEmailAddressDao) {\n+  InstitutionServiceImpl(InstitutionDao institutionDao) {\n     this.institutionDao = institutionDao;\n-    this.institutionEmailDomainDao = institutionEmailDomainDao;\n-    this.institutionEmailAddressDao = institutionEmailAddressDao;\n   }\n \n   @Override\n   public List<Institution> getInstitutions() {\n     return StreamSupport.stream(institutionDao.findAll().spliterator(), false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzODc2NQ==", "bodyText": "With the db objects, we can (and I think should) avoid returning null for collections. We don't have a choice with the generated classes though.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377938765", "createdAt": "2020-02-11T22:30:40Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,50 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {\n+    return updateDbObject(new DbInstitution(), modelObject);\n   }\n \n-  private DbInstitution saveInstitutionEmailPatterns(\n-      final Institution modelClass, final DbInstitution dbClass) {\n-\n-    institutionEmailDomainDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                dbClass.setEmailDomains(\n-                    institutionEmailDomainDao.save(\n-                        domains.stream()\n-                            .map(domain -> new DbInstitutionEmailDomain(dbClass, domain))\n-                            .collect(Collectors.toSet()))));\n-\n-    institutionEmailAddressDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                dbClass.setEmailAddresses(\n-                    institutionEmailAddressDao.save(\n-                        addresses.stream()\n-                            .map(address -> new DbInstitutionEmailAddress(dbClass, address))\n-                            .collect(Collectors.toSet()))));\n-\n-    return institutionDao.save(dbClass);\n+  private DbInstitution updateDbObject(\n+      final DbInstitution dbObject, final Institution modelObject) {\n+    return dbObject\n+        .shortName(modelObject.getShortName())\n+        .displayName(modelObject.getDisplayName())\n+        .organizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .organizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .emailDomains(\n+            Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n+                .collect(Collectors.toSet()))\n+        .emailAddresses(\n+            Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(address -> new DbInstitutionEmailAddress().setEmailAddress(address))\n+                .collect(Collectors.toSet()));\n   }\n \n-  private Institution toModelClass(final DbInstitution dbClass) {\n-    final Institution institution =\n-        new Institution()\n-            .shortName(dbClass.getShortName())\n-            .displayName(dbClass.getDisplayName())\n-            .organizationTypeEnum(\n-                DbStorageEnums.organizationTypeFromStorage(dbClass.getOrganizationTypeEnum()))\n-            .organizationTypeOtherText(dbClass.getOrganizationTypeOtherText());\n-\n-    Optional.ofNullable(dbClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                institution.emailDomains(\n-                    domains.stream()\n-                        .map(DbInstitutionEmailDomain::getEmailDomain)\n-                        .collect(Collectors.toList())));\n-\n-    Optional.ofNullable(dbClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                institution.emailAddresses(\n-                    addresses.stream()\n-                        .map(DbInstitutionEmailAddress::getEmailAddress)\n-                        .collect(Collectors.toList())));\n-\n-    return institution;\n+  private Institution toModel(final DbInstitution dbObject) {\n+    return new Institution()\n+        .shortName(dbObject.getShortName())\n+        .displayName(dbObject.getDisplayName())\n+        .organizationTypeEnum(dbObject.getOrganizationTypeEnum())\n+        .organizationTypeOtherText(dbObject.getOrganizationTypeOtherText())\n+        .emailDomains(\n+            Optional.ofNullable(dbObject.getEmailDomains()).orElse(Collections.emptySet()).stream()\n+                .map(DbInstitutionEmailDomain::getEmailDomain)\n+                .collect(Collectors.toList()))\n+        .emailAddresses(\n+            Optional.ofNullable(dbObject.getEmailAddresses()).orElse(Collections.emptySet())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzOTcyMA==", "bodyText": "code under test shouldn't really be executed in setup() if we can avoid it. It's just for mocks and fixtures.  You'll still fail your tests if it blows up, but you should ideally have assertions after important steps, especially in a test_save() method.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377939720", "createdAt": "2020-02-11T22:32:56Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,175 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().shortName(\"Broad\").displayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Stream.of(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"))\n+            .collect(Collectors.toCollection(HashSet::new));\n+    emailDomains =\n+        Stream.of(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"))\n+            .collect(Collectors.toCollection(HashSet::new));\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .shortName(\"Broad1\")\n+                .displayName(\"The Broad Institute\")\n+                .emailAddresses(emailAddresses)\n+                .emailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    // no need to call save since we have a setup method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MTYwNQ==", "bodyText": "So if you want to use the builder paradigm, you could make a billed() method that fills in missing array values and other defaultable things.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377941605", "createdAt": "2020-02-11T22:37:16Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/institution/InstitutionServiceTest.java", "diffHunk": "@@ -49,25 +59,32 @@ public void test_deleteInstitution() {\n \n   @Test\n   public void test_getInstitutions() {\n-    assertThat(service.getInstitutions()).containsExactlyElementsIn(ImmutableList.of(testInst));\n+    assertThat(service.getInstitutions()).containsExactly(testInstAfterRT);\n \n     final Institution otherInst =\n-        new Institution().shortName(\"otherInst\").displayName(\"The Institution of testing\");\n+        new Institution()\n+            .shortName(\"otherInst\")\n+            .displayName(\"The Institution of testing\")\n+            .emailDomains(new ArrayList<>())\n+            .emailAddresses(new ArrayList<>());\n     service.createInstitution(otherInst);\n-    assertThat(service.getInstitutions())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+    assertThat(service.getInstitutions()).containsExactly(testInstAfterRT, otherInst);\n \n     service.deleteInstitution(testInst.getShortName());\n-    assertThat(service.getInstitutions()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+    assertThat(service.getInstitutions()).containsExactly(otherInst);\n   }\n \n   @Test\n   public void test_getInstitution() {\n-    assertThat(service.getInstitution(testInst.getShortName())).hasValue(testInst);\n+    assertThat(service.getInstitution(testInst.getShortName())).hasValue(testInstAfterRT);\n     assertThat(service.getInstitution(\"otherInst\")).isEmpty();\n \n     final Institution otherInst =\n-        new Institution().shortName(\"otherInst\").displayName(\"The Institution of testing\");\n+        new Institution()\n+            .shortName(\"otherInst\")\n+            .displayName(\"The Institution of testing\")\n+            .emailAddresses(new ArrayList<>())\n+            .emailDomains(new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca97d6668f3876555913abff738d0e6b85df9f83", "author": {"user": {"login": "jmthibault79", "name": null}}, "url": "https://github.com/all-of-us/workbench/commit/ca97d6668f3876555913abff738d0e6b85df9f83", "committedDate": "2020-02-12T19:03:24Z", "message": "slopypaste"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f57cc06f9a6d56d1778af71597b437de0126548", "author": {"user": {"login": "jmthibault79", "name": null}}, "url": "https://github.com/all-of-us/workbench/commit/6f57cc06f9a6d56d1778af71597b437de0126548", "committedDate": "2020-02-12T19:08:49Z", "message": "Add comment describing what setEmailAddresses/Domains do conceptually\nMark addr/domain IDs as not nullable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4798fc20be7f8105d744fe6ca350e6d3e21358e", "author": {"user": {"login": "jmthibault79", "name": null}}, "url": "https://github.com/all-of-us/workbench/commit/e4798fc20be7f8105d744fe6ca350e6d3e21358e", "committedDate": "2020-02-12T19:18:22Z", "message": "Don't need to check these for nullability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3fcee2a6fdce8b8ae16c7560dcfc32792f02051", "author": {"user": {"login": "jmthibault79", "name": null}}, "url": "https://github.com/all-of-us/workbench/commit/f3fcee2a6fdce8b8ae16c7560dcfc32792f02051", "committedDate": "2020-02-12T19:25:27Z", "message": "merge builder/non-builder accessors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea", "author": {"user": {"login": "jmthibault79", "name": null}}, "url": "https://github.com/all-of-us/workbench/commit/60dc18e11f89fb07ccc38815528dee50fad881ea", "committedDate": "2020-02-12T19:39:06Z", "message": "test_save() does its own saving"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3NzM5NDI1", "url": "https://github.com/all-of-us/workbench/pull/3118#pullrequestreview-357739425", "createdAt": "2020-02-12T19:48:09Z", "commit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTo0ODowOVrOFo8TqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTo0ODowOVrOFo8TqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3NTQzMw==", "bodyText": "This will also not be null but an empty collection.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378475433", "createdAt": "2020-02-12T19:48:09Z", "author": {"login": "freemabd"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -69,16 +69,16 @@ private DbInstitution newDbObject(final Institution modelObject) {\n   private DbInstitution updateDbObject(\n       final DbInstitution dbObject, final Institution modelObject) {\n     return dbObject\n-        .shortName(modelObject.getShortName())\n-        .displayName(modelObject.getDisplayName())\n-        .organizationTypeEnum(modelObject.getOrganizationTypeEnum())\n-        .organizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n-        .emailDomains(\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(\n             Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n                 .stream()\n                 .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n                 .collect(Collectors.toSet()))\n-        .emailAddresses(\n+        .setEmailAddresses(\n             Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3ODE2MTc4", "url": "https://github.com/all-of-us/workbench/pull/3118#pullrequestreview-357816178", "createdAt": "2020-02-12T21:54:54Z", "commit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3ODE4MjI2", "url": "https://github.com/all-of-us/workbench/pull/3118#pullrequestreview-357818226", "createdAt": "2020-02-12T21:58:11Z", "commit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "state": "APPROVED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1ODoxMVrOFpAC4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjozMTo0MVrOFpA8Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNjY3NQ==", "bodyText": "Do you not need to have a Hibernate annotation for this like @Id?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378536675", "createdAt": "2020-02-12T21:58:11Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNzIzOA==", "bodyText": "Do we have a doc for those practices yet?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378537238", "createdAt": "2020-02-12T21:59:21Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,41 +12,35 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxODE1NQ=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNzc1MQ==", "bodyText": "So should we assert that the enum value is actually other when setting this? Should we just go ahead and update it if we're setting this? They're a package deal.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378537751", "createdAt": "2020-02-12T22:00:30Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzODU0NA==", "bodyText": "Yay for fluent methods.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378538544", "createdAt": "2020-02-12T22:02:11Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0MDk0Mg==", "bodyText": "This looks like you're manually doing Hibernate's job. It seems really odd to me for an entity to take in a set of things it owns, then modify them and save them. I'd much rather see immutable email domain objects being pointed to by this set, unless you have a really urgent reason to work with domains but not the institution. Like where in the UI would you even have such an issue?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378540942", "createdAt": "2020-02-12T22:07:23Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0MjAyMA==", "bodyText": "Are these all addresses belonging to the institution's users from anywhere in the system? I wouldn't have thought to look for that here; it's more of a service method thing in our current pattern. Could you equivalently expose a set of DbUser objects? I don't really know when we do one versus the other.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378542020", "createdAt": "2020-02-12T22:09:43Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0Mjg1MA==", "bodyText": "So the intention of this function is to replace all matching email addresses with updated ones (not sure what other fields that would involve). If this isn't bound directly to the table(s), then I'm confused about the use case.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378542850", "createdAt": "2020-02-12T22:11:40Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailAddresses = emailAddresses", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0MzMwOA==", "bodyText": "does this save new ones to the database?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378543308", "createdAt": "2020-02-12T22:12:41Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailAddresses = emailAddresses\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailAddresses the new set of addresses for this Institution\n+   */\n+  public DbInstitution setEmailAddresses(final Set<DbInstitutionEmailAddress> emailAddresses) {\n+    final Set<DbInstitutionEmailAddress> attachedAddresses =\n+        emailAddresses.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailAddresses.retainAll(attachedAddresses);\n+    this.emailAddresses.addAll(Sets.difference(attachedAddresses, this.emailAddresses));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NDQ5NQ==", "bodyText": "I think you should only define entity objects where it makes sense to your application to use as a standalone object. As in something you think of. If it's just a table row (with no more real abstraction), then you may be able to absorb it into the containing entity.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378544495", "createdAt": "2020-02-12T22:15:30Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "diffHunk": "@@ -15,51 +15,58 @@\n @Table(name = \"institution_email_address\")\n public class DbInstitutionEmailAddress {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_email_address_id\")\n   private long institutionEmailAddressId;\n-\n-  @ManyToOne(fetch = FetchType.LAZY)\n-  @JoinColumn(name = \"institution_id\")\n   private DbInstitution institution;\n-\n-  @Column(name = \"email_address\", nullable = false)\n   private String emailAddress;\n \n   public DbInstitutionEmailAddress() {}\n \n-  public DbInstitutionEmailAddress(DbInstitution institution, String emailAddress) {\n-    this.institution = institution;\n-    this.emailAddress = emailAddress;\n+  @Id", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NDg2OA==", "bodyText": "So this class allows the same email address to belong to more than one institution?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378544868", "createdAt": "2020-02-12T22:16:22Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "diffHunk": "@@ -15,51 +15,58 @@\n @Table(name = \"institution_email_address\")\n public class DbInstitutionEmailAddress {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_email_address_id\")\n   private long institutionEmailAddressId;\n-\n-  @ManyToOne(fetch = FetchType.LAZY)\n-  @JoinColumn(name = \"institution_id\")\n   private DbInstitution institution;\n-\n-  @Column(name = \"email_address\", nullable = false)\n   private String emailAddress;\n \n   public DbInstitutionEmailAddress() {}\n \n-  public DbInstitutionEmailAddress(DbInstitution institution, String emailAddress) {\n-    this.institution = institution;\n-    this.emailAddress = emailAddress;\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_email_address_id\", nullable = false)\n+  public long getInstitutionEmailAddressId() {\n+    return institutionEmailAddressId;\n   }\n \n+  public DbInstitutionEmailAddress setInstitutionEmailAddressId(long institutionEmailAddressId) {\n+    this.institutionEmailAddressId = institutionEmailAddressId;\n+    return this;\n+  }\n+\n+  @ManyToOne(cascade = CascadeType.ALL)\n+  @JoinColumn(name = \"institution_id\", nullable = false)\n   public DbInstitution getInstitution() {\n     return institution;\n   }\n \n+  public DbInstitutionEmailAddress setInstitution(DbInstitution institution) {\n+    this.institution = institution;\n+    return this;\n+  }\n+\n+  @Column(name = \"email_address\", nullable = false)\n   public String getEmailAddress() {\n     return emailAddress;\n   }\n \n+  public DbInstitutionEmailAddress setEmailAddress(String emailAddress) {\n+    this.emailAddress = emailAddress;\n+    return this;\n+  }\n+\n   @Override\n   public boolean equals(Object o) {\n-    if (this == o) {\n-      return true;\n-    }\n-    if (!(o instanceof DbInstitutionEmailAddress)) {\n-      return false;\n-    }\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n \n     DbInstitutionEmailAddress that = (DbInstitutionEmailAddress) o;\n \n-    return institutionEmailAddressId == that.institutionEmailAddressId\n-        && institution.equals(that.institution)\n-        && emailAddress.equals(that.emailAddress);\n+    return Objects.equals(institution, that.institution)\n+        && Objects.equals(emailAddress, that.emailAddress);\n   }\n \n   @Override\n   public int hashCode() {\n-    return Objects.hash(institutionEmailAddressId, institution, emailAddress);\n+    return Objects.hash(institution, emailAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NTE0MA==", "bodyText": "I think we should validate that the incoming emailAddress doesn't already have a different institution. Otherwise this is destructive to that institution's map of the world.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378545140", "createdAt": "2020-02-12T22:17:01Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailAddresses = emailAddresses\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailAddresses the new set of addresses for this Institution\n+   */\n+  public DbInstitution setEmailAddresses(final Set<DbInstitutionEmailAddress> emailAddresses) {\n+    final Set<DbInstitutionEmailAddress> attachedAddresses =\n+        emailAddresses.stream()\n+            .map(address -> address.setInstitution(this))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NTYyNQ==", "bodyText": "You mean of the type? Good point. In practice there's not much cyclical dependence added but you're right.\nThis is why I think we need a DataManager layer.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378545625", "createdAt": "2020-02-12T22:18:15Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -19,34 +17,27 @@\n public class InstitutionServiceImpl implements InstitutionService {\n \n   private final InstitutionDao institutionDao;\n-  private final InstitutionEmailDomainDao institutionEmailDomainDao;\n-  private final InstitutionEmailAddressDao institutionEmailAddressDao;\n \n   @Autowired\n-  InstitutionServiceImpl(\n-      InstitutionDao institutionDao,\n-      InstitutionEmailDomainDao institutionEmailDomainDao,\n-      InstitutionEmailAddressDao institutionEmailAddressDao) {\n+  InstitutionServiceImpl(InstitutionDao institutionDao) {\n     this.institutionDao = institutionDao;\n-    this.institutionEmailDomainDao = institutionEmailDomainDao;\n-    this.institutionEmailAddressDao = institutionEmailAddressDao;\n   }\n \n   @Override\n   public List<Institution> getInstitutions() {\n     return StreamSupport.stream(institutionDao.findAll().spliterator(), false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzgxMg=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NjExMQ==", "bodyText": "I had a proposal for API object factories to help with that, but it didn't make it far.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378546111", "createdAt": "2020-02-12T22:19:25Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -69,16 +69,16 @@ private DbInstitution newDbObject(final Institution modelObject) {\n   private DbInstitution updateDbObject(\n       final DbInstitution dbObject, final Institution modelObject) {\n     return dbObject\n-        .shortName(modelObject.getShortName())\n-        .displayName(modelObject.getDisplayName())\n-        .organizationTypeEnum(modelObject.getOrganizationTypeEnum())\n-        .organizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n-        .emailDomains(\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(\n             Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n                 .stream()\n                 .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n                 .collect(Collectors.toSet()))\n-        .emailAddresses(\n+        .setEmailAddresses(\n             Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3NTQzMw=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NjYyMA==", "bodyText": "I like chained stream statements, but I have trouble reading nested streams. What would you think about making little helper methods to process the email domains and addresses?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378546620", "createdAt": "2020-02-12T22:20:33Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,49 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {\n+    return updateDbObject(new DbInstitution(), modelObject);\n   }\n \n-  private DbInstitution saveInstitutionEmailPatterns(\n-      final Institution modelClass, final DbInstitution dbClass) {\n-\n-    institutionEmailDomainDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                dbClass.setEmailDomains(\n-                    institutionEmailDomainDao.save(\n-                        domains.stream()\n-                            .map(domain -> new DbInstitutionEmailDomain(dbClass, domain))\n-                            .collect(Collectors.toSet()))));\n-\n-    institutionEmailAddressDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                dbClass.setEmailAddresses(\n-                    institutionEmailAddressDao.save(\n-                        addresses.stream()\n-                            .map(address -> new DbInstitutionEmailAddress(dbClass, address))\n-                            .collect(Collectors.toSet()))));\n-\n-    return institutionDao.save(dbClass);\n+  private DbInstitution updateDbObject(\n+      final DbInstitution dbObject, final Institution modelObject) {\n+    return dbObject\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NzI3Mg==", "bodyText": "If the dbObject is already known, then why not fill in both the address and institution here? It wold simplify your setEmailAddresses() method as well.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378547272", "createdAt": "2020-02-12T22:22:04Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,49 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {\n+    return updateDbObject(new DbInstitution(), modelObject);\n   }\n \n-  private DbInstitution saveInstitutionEmailPatterns(\n-      final Institution modelClass, final DbInstitution dbClass) {\n-\n-    institutionEmailDomainDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                dbClass.setEmailDomains(\n-                    institutionEmailDomainDao.save(\n-                        domains.stream()\n-                            .map(domain -> new DbInstitutionEmailDomain(dbClass, domain))\n-                            .collect(Collectors.toSet()))));\n-\n-    institutionEmailAddressDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                dbClass.setEmailAddresses(\n-                    institutionEmailAddressDao.save(\n-                        addresses.stream()\n-                            .map(address -> new DbInstitutionEmailAddress(dbClass, address))\n-                            .collect(Collectors.toSet()))));\n-\n-    return institutionDao.save(dbClass);\n+  private DbInstitution updateDbObject(\n+      final DbInstitution dbObject, final Institution modelObject) {\n+    return dbObject\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(\n+            Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n+                .collect(Collectors.toSet()))\n+        .setEmailAddresses(\n+            Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(address -> new DbInstitutionEmailAddress().setEmailAddress(address))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0ODUxMg==", "bodyText": "nit: maybe savedWithEmail?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378548512", "createdAt": "2020-02-12T22:25:07Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0ODg1Mw==", "bodyText": "nit: if findOne wold return Optional, that'd be great.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378548853", "createdAt": "2020-02-12T22:25:51Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0OTU0Nw==", "bodyText": "these are a mouthful and also very hard to distinguish (b/c the different letters are in the middle). Maybe simpleInstitution and emailPopulatedInstition or something?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378549547", "createdAt": "2020-02-12T22:27:23Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDA0OQ==", "bodyText": "Why can't this setEmailAddresses simply take in a collection of Strings? It could do the construction and population of the dbInstitution reference in one place so the caller doesn't have to.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378550049", "createdAt": "2020-02-12T22:28:30Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDQzMw==", "bodyText": "please overwrite the arg passed to save().", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378550433", "createdAt": "2020-02-12T22:29:30Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n+\n+  @Test\n+  public void test_updateWithExistingEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n \n-    DbInstitution otherInst = new DbInstitution(\"Verily\", \"An Alphabet Company\");\n-    otherInst = institutionDao.save(otherInst);\n-    assertThat(institutionDao.findOneByShortName(\"Verily\")).hasValue(otherInst);\n+  @Test\n+  public void test_updateRemoveAllEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses = Sets.newHashSet();\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDc0Mg==", "bodyText": "please make the test data more representative, e.g., auburn.edu.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378550742", "createdAt": "2020-02-12T22:30:16Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n+\n+  @Test\n+  public void test_updateWithExistingEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n \n-    DbInstitution otherInst = new DbInstitution(\"Verily\", \"An Alphabet Company\");\n-    otherInst = institutionDao.save(otherInst);\n-    assertThat(institutionDao.findOneByShortName(\"Verily\")).hasValue(otherInst);\n+  @Test\n+  public void test_updateRemoveAllEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses = Sets.newHashSet();\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailDomains() {\n+    Set<DbInstitutionEmailDomain> newEmailDomains =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain1\"),\n+            new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailDomains(newEmailDomains);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).containsExactlyElementsIn(newEmailDomains);\n+  }\n+\n+  @Test\n+  public void test_updateWithExistingEmailDomains() {\n+    Set<DbInstitutionEmailDomain> newEmailDomains =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MTM2Ng==", "bodyText": "nit: make args look like email addresses\nAlso, we need some testing of the sharing (if allowed) of addresses across institutions.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378551366", "createdAt": "2020-02-12T22:31:41Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n+\n+  @Test\n+  public void test_updateWithExistingEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 150}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cafc03c11ca9aeb3f980a93e3872e09aa389ff6c", "author": {"user": {"login": "jmthibault79", "name": null}}, "url": "https://github.com/all-of-us/workbench/commit/cafc03c11ca9aeb3f980a93e3872e09aa389ff6c", "committedDate": "2020-02-12T22:52:26Z", "message": "test renaming and data updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cb2b950524c7be2713c9e48707c05bc5c781d19", "author": {"user": {"login": "jmthibault79", "name": null}}, "url": "https://github.com/all-of-us/workbench/commit/6cb2b950524c7be2713c9e48707c05bc5c781d19", "committedDate": "2020-02-12T22:57:03Z", "message": "protect against save() munging and be explicit that dupe emails are OK"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86b684f98a1c19bcfbcce7bfba8fd76e08a0f412", "author": {"user": {"login": "jmthibault79", "name": null}}, "url": "https://github.com/all-of-us/workbench/commit/86b684f98a1c19bcfbcce7bfba8fd76e08a0f412", "committedDate": "2020-02-12T23:22:28Z", "message": "lint"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3561, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}