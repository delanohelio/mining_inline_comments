{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3NTIzMzkx", "number": 3160, "title": "[RW-4464][risk=low] Plumb proper agent details to audit system", "bodyText": "Two-pronged fix:\n\nPlumb the proper agent details through higher interfaces. After looking more closely, it was clear that the default of \"administrator\" was incorrect in most cases here.\nProduce null (injectable as Optional) if there is no user. Longer term fix might use a different wrapper object for this. This should make the failure mode clearer and provides a pattern if we need this in the future. Longer term fix is https://precisionmedicineinitiative.atlassian.net/browse/RW-4496\n\nLearnings:\n\nOptional has special magic semantics in Spring, it can be used to express an \"optional\" injected dependency, as described here.\n\nThis means that providing an Optional typed Bean is problematic, I couldn't get it working properly\nA Provider<Optional> doesn't appear to be a thing that I could get working\nProvider<Optional> works\nEven if your injected bean type is totally bogus, injecting Optional works for an empty optional\n\n\nA Provider is allowed to produce a null value.\nA Bean cannot be declared as an Optional type, as far as I could tell.", "createdAt": "2020-02-20T02:59:36Z", "url": "https://github.com/all-of-us/workbench/pull/3160", "merged": true, "mergeCommit": {"oid": "85a687fd0aedcba68a4af3586d37b54e45e2aefd"}, "closed": true, "closedAt": "2020-02-21T23:11:03Z", "author": {"login": "calbach"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGCKNDgBqjMwNTQxOTA1MjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcGnCwQABqjMwNjIwNTg5NTU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e98b08738f40ad8db34cde73b235803bc97d82b3", "author": {"user": {"login": "calbach", "name": "CH Albach"}}, "url": "https://github.com/all-of-us/workbench/commit/e98b08738f40ad8db34cde73b235803bc97d82b3", "committedDate": "2020-02-20T02:57:10Z", "message": "Try test, verification not working.... Kotlin?"}, "afterCommit": {"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc", "author": {"user": {"login": "calbach", "name": "CH Albach"}}, "url": "https://github.com/all-of-us/workbench/commit/2fc92ba2aadb6e277625c2ba6050b74205e880cc", "committedDate": "2020-02-20T03:00:30Z", "message": "Try test, verification not working.... Kotlin?"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxOTA2MDU3", "url": "https://github.com/all-of-us/workbench/pull/3160#pullrequestreview-361906057", "createdAt": "2020-02-20T13:39:38Z", "commit": {"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzozOTozOVrOFsTnoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzo1MzoxNFrOFsUGeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMzEwNQ==", "bodyText": "Maybe pull this preamble into its own helper, unless you're sure none of the other methods need to do this.", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382003105", "createdAt": "2020-02-20T13:39:39Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditAdapterImpl.java", "diffHunk": "@@ -39,13 +42,29 @@ public UserServiceAuditAdapterImpl(\n \n   @Override\n   public void fireUpdateDataAccessAction(\n-      DbUser targetUser, DataAccessLevel dataAccessLevel, DataAccessLevel previousDataAccessLevel) {\n+      DbUser targetUser,\n+      DataAccessLevel dataAccessLevel,\n+      DataAccessLevel previousDataAccessLevel,\n+      AgentType agentType) {\n+    // In the event of an offline cronjob, the request may have been made anonymously and there is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDM0MQ==", "bodyText": "nit: typically the pattern I use with optionals adn builders is\nagent.ifPresent(eventBuilder::agentEmailMaybe). Downside is you have to declare the builder.", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382004341", "createdAt": "2020-02-20T13:41:52Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditAdapterImpl.java", "diffHunk": "@@ -39,13 +42,29 @@ public UserServiceAuditAdapterImpl(\n \n   @Override\n   public void fireUpdateDataAccessAction(\n-      DbUser targetUser, DataAccessLevel dataAccessLevel, DataAccessLevel previousDataAccessLevel) {\n+      DbUser targetUser,\n+      DataAccessLevel dataAccessLevel,\n+      DataAccessLevel previousDataAccessLevel,\n+      AgentType agentType) {\n+    // In the event of an offline cronjob, the request may have been made anonymously and there is\n+    // no user identity. This should only happen for system agent driven audit events.\n+    Optional<DbUser> agent = Optional.ofNullable(dbUserProvider.get());\n+    if (agent.isPresent() && AgentType.SYSTEM == agentType) {\n+      log.warning(\n+          String.format(\n+              \"found unexpected request scope user '%s' for SYSTEM agent audit action\",\n+              agent.get().getUsername()));\n+    } else if (!agent.isPresent() && AgentType.SYSTEM != agentType) {\n+      log.warning(\n+          String.format(\"missing request scope user for audit action agent type of %s\", agentType));\n+    }\n+\n     actionAuditService.send(\n         ActionAuditEvent.builder()\n             .timestamp(clock.millis())\n-            .agentType(AgentType.ADMINISTRATOR)\n-            .agentId(dbUserProvider.get().getUserId())\n-            .agentEmailMaybe(dbUserProvider.get().getUsername())\n+            .agentType(agentType)\n+            .agentId(agent.map(DbUser::getUserId).orElse(0L))\n+            .agentEmailMaybe(agent.map(DbUser::getUsername).orElse(null))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDk3MA==", "bodyText": "So if we had a cron that happened to set this bypass time for some reason,  we'd. have to fix this one too.", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382004970", "createdAt": "2020-02-20T13:42:55Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditAdapterImpl.java", "diffHunk": "@@ -61,12 +80,13 @@ public void fireAdministrativeBypassTime(\n       long userId,\n       BypassTimeTargetProperty bypassTimeTargetProperty,\n       Optional<Instant> bypassTime) {\n+    DbUser adminUser = dbUserProvider.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNTk5MQ==", "bodyText": "Ideally we could keep the footprint smaller, so that callers don't need to know anything about the audit system. Would injecting the class @gjuggler mentioned help here? Could come later.", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382005991", "createdAt": "2020-02-20T13:44:39Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/api/OfflineUserController.java", "diffHunk": "@@ -74,9 +75,9 @@ private boolean timestampsEqual(Timestamp a, Timestamp b) {\n \n         DbUser updatedUser;\n         if (workbenchConfigProvider.get().featureFlags.enableMoodleV2Api) {\n-          updatedUser = userService.syncComplianceTrainingStatusV2(user);\n+          updatedUser = userService.syncComplianceTrainingStatusV2(user, AgentType.SYSTEM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNzQ3MA==", "bodyText": "I really think null beans are an anti-pattern. I expect them to be there when they're injected, but maybe i've just. been naive. If we do. need this, then I recommend moving to OptionalProvider, so it's. obvious.\nCan we not make UserAuthentication. and Userinfoplus a bit smarter so they don't have to be. null?", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382007470", "createdAt": "2020-02-20T13:47:03Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/config/WebMvcConfig.java", "diffHunk": "@@ -48,18 +49,28 @@\n   @Bean\n   @RequestScope(proxyMode = ScopedProxyMode.DEFAULT)\n   public UserAuthentication userAuthentication() {\n-    return (UserAuthentication) SecurityContextHolder.getContext().getAuthentication();\n+    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n+    if (auth == null) {\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNzgzMQ==", "bodyText": "Could we make a fake DbUser instance to represent the system?", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382007831", "createdAt": "2020-02-20T13:47:41Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/config/WebMvcConfig.java", "diffHunk": "@@ -48,18 +49,28 @@\n   @Bean\n   @RequestScope(proxyMode = ScopedProxyMode.DEFAULT)\n   public UserAuthentication userAuthentication() {\n-    return (UserAuthentication) SecurityContextHolder.getContext().getAuthentication();\n+    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n+    if (auth == null) {\n+      return null;\n+    }\n+    return (UserAuthentication) auth;\n   }\n \n   @Bean\n   @RequestScope(proxyMode = ScopedProxyMode.DEFAULT)\n   public Userinfoplus userInfo(UserAuthentication userAuthentication) {\n+    if (userAuthentication == null) {\n+      return null;\n+    }\n     return userAuthentication.getPrincipal();\n   }\n \n   @Bean\n   @RequestScope(proxyMode = ScopedProxyMode.DEFAULT)\n   public DbUser user(UserAuthentication userAuthentication) {\n+    if (userAuthentication == null) {\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwODUxNw==", "bodyText": "Oh, interesting. So there are up to 3 valid values for agent type.", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382008517", "createdAt": "2020-02-20T13:48:52Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -842,12 +851,12 @@ public DbUser syncEraCommonsStatusUsingImpersonation(DbUser user)\n \n   @Override\n   public void syncTwoFactorAuthStatus() {\n-    syncTwoFactorAuthStatus(userProvider.get());\n+    syncTwoFactorAuthStatus(userProvider.get(), AgentType.USER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxMDM3MA==", "bodyText": "If this isn't working, it might be due to an incompatibility in some of the Mockito stuff. Things like captors return null when the mockito contract requires non-null. There are some examples in the kotlin test files\n    @Test\n    fun testDeleteUserProfile() {\n        profileAuditAdapter!!.fireDeleteAction(USER_ID, USER_EMAIL)\n        argumentCaptor<ActionAuditEvent>().apply {\n            verify(mockActionAuditService).send(capture())\n            val eventSent = firstValue\n\n            assertThat(eventSent.targetType).isEqualTo(TargetType.PROFILE)\n            assertThat(eventSent.agentType).isEqualTo(AgentType.USER)\n            assertThat(eventSent.agentId).isEqualTo(USER_ID)\n            assertThat(eventSent.targetIdMaybe).isEqualTo(USER_ID)\n            assertThat(eventSent.actionType).isEqualTo(ActionType.DELETE)\n//...\n\nBut this would be the first time we've had this problem in Java AFAIK. Does this work with standard matchers or captors?\n@ericsong thoughts?", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382010370", "createdAt": "2020-02-20T13:52:08Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditorTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.verify;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent;\n+import org.pmiops.workbench.actionaudit.ActionAuditService;\n+import org.pmiops.workbench.actionaudit.AgentType;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.model.DataAccessLevel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.context.annotation.Primary;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class UserServiceAuditorTest {\n+  static DbUser USER = null;\n+\n+  @TestConfiguration\n+  @Import({UserServiceAuditAdapterImpl.class, ActionAuditTestConfig.class})\n+  @MockBean(ActionAuditService.class)\n+  static class Configuration {\n+    @Primary\n+    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n+    public DbUser getUser() {\n+      return USER;\n+    }\n+  }\n+\n+  @Autowired UserServiceAuditor userServiceAuditor;\n+  @Autowired ActionAuditService mockActionAuditService;\n+\n+  @After\n+  public void tearDown() {\n+    USER = null;\n+  }\n+\n+  private static DbUser createUser() {\n+    final DbUser user = new DbUser();\n+    user.setUserId(3L);\n+    user.setUsername(\"foo@gmail.com\");\n+    return user;\n+  }\n+\n+  @Test\n+  public void testFireUpdateDataAccessAction_userAgent() {\n+    USER = createUser();\n+    userServiceAuditor.fireUpdateDataAccessAction(\n+        USER, DataAccessLevel.UNREGISTERED, DataAccessLevel.REGISTERED, AgentType.USER);\n+    verify(mockActionAuditService)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxMTAwMQ==", "bodyText": "nit: prefer the tightest match, e.g. any(AgentType.class), anyString(), etc. This helps avoid false positives when overloads come into play.", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382011001", "createdAt": "2020-02-20T13:53:14Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/api/OfflineUserControllerTest.java", "diffHunk": "@@ -83,69 +83,73 @@ public void testBulkSyncTrainingStatusV1()\n       throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n     workbenchConfig.featureFlags.enableMoodleV2Api = false;\n     // Mock out the service under test to simply return the passed user argument.\n-    doAnswer(i -> i.getArgument(0)).when(userService).syncComplianceTrainingStatusV1(any());\n+    doAnswer(i -> i.getArgument(0)).when(userService).syncComplianceTrainingStatusV1(any(), any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzAyMjEx", "url": "https://github.com/all-of-us/workbench/pull/3160#pullrequestreview-362702211", "createdAt": "2020-02-21T15:17:35Z", "commit": {"oid": "1fe26e6835dc272c67497054e7e20805edd770cf"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNToxNzozNVrOFs6W8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNToyNjo1OFrOFs6rsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjYzNzgxMQ==", "bodyText": "Can you please have a block for unhandled agent types? (A switch may be better actually)", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382637811", "createdAt": "2020-02-21T15:17:35Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditAdapterImpl.java", "diffHunk": "@@ -20,32 +21,50 @@\n @Service\n public class UserServiceAuditAdapterImpl implements UserServiceAuditor {\n \n+  private static final Logger log = Logger.getLogger(UserServiceAuditAdapterImpl.class.getName());\n+\n   private final ActionAuditService actionAuditService;\n   private final Clock clock;\n-  private Provider<DbUser> dbUserProvider;\n   private Provider<String> actionIdProvider;\n+  private Provider<Optional<DbUser>> dbUserOptionalProvider;\n \n   @Autowired\n   public UserServiceAuditAdapterImpl(\n       ActionAuditService actionAuditService,\n       Clock clock,\n-      Provider<DbUser> dbUserProvider,\n-      @Qualifier(\"ACTION_ID\") Provider<String> actionIdProvider) {\n+      @Qualifier(\"ACTION_ID\") Provider<String> actionIdProvider,\n+      Provider<Optional<DbUser>> dbUserOptionalProvider) {\n     this.actionAuditService = actionAuditService;\n     this.clock = clock;\n-    this.dbUserProvider = dbUserProvider;\n     this.actionIdProvider = actionIdProvider;\n+    this.dbUserOptionalProvider = dbUserOptionalProvider;\n   }\n \n   @Override\n   public void fireUpdateDataAccessAction(\n-      DbUser targetUser, DataAccessLevel dataAccessLevel, DataAccessLevel previousDataAccessLevel) {\n+      DbUser targetUser,\n+      DataAccessLevel dataAccessLevel,\n+      DataAccessLevel previousDataAccessLevel,\n+      AgentType agentType) {\n+    // In the event of an offline cronjob, the request may have been made anonymously and there is\n+    // no user identity. This should only happen for system agent driven audit events.\n+    Optional<DbUser> agent = dbUserOptionalProvider.get();\n+    if (agent.isPresent() && AgentType.SYSTEM == agentType) {\n+      log.warning(\n+          String.format(\n+              \"found unexpected request scope user '%s' for SYSTEM agent audit action\",\n+              agent.get().getUsername()));\n+    } else if (!agent.isPresent() && AgentType.SYSTEM != agentType) {\n+      log.warning(\n+          String.format(\"missing request scope user for audit action agent type of %s\", agentType));\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fe26e6835dc272c67497054e7e20805edd770cf"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0MDA0Mw==", "bodyText": "Would you mind going ahead and filing a spike ticket for this question and the design sketch you mentioned about RequestAuthenticationInfo? I agree it's not a short term priority.", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382640043", "createdAt": "2020-02-21T15:21:39Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/api/OfflineUserController.java", "diffHunk": "@@ -74,9 +75,9 @@ private boolean timestampsEqual(Timestamp a, Timestamp b) {\n \n         DbUser updatedUser;\n         if (workbenchConfigProvider.get().featureFlags.enableMoodleV2Api) {\n-          updatedUser = userService.syncComplianceTrainingStatusV2(user);\n+          updatedUser = userService.syncComplianceTrainingStatusV2(user, AgentType.SYSTEM);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNTk5MQ=="}, "originalCommit": {"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0MzEyMQ==", "bodyText": "This is interesting. It's a bit strange at first, but looks a bit cleaner than using an ArgumentCaptor. Though in the latter case you can write separate assertions on the thing passed in, whereas here I suppose it's up to Mockito to format the error information.", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382643121", "createdAt": "2020-02-21T15:26:58Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditorTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.verify;\n+\n+import java.time.Clock;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent;\n+import org.pmiops.workbench.actionaudit.ActionAuditService;\n+import org.pmiops.workbench.actionaudit.AgentType;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.model.DataAccessLevel;\n+import org.pmiops.workbench.test.FakeClock;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class UserServiceAuditorTest {\n+  static DbUser USER = null;\n+\n+  @TestConfiguration\n+  @Import({UserServiceAuditAdapterImpl.class})\n+  @MockBean(ActionAuditService.class)\n+  static class Configuration {\n+    @Bean\n+    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n+    public DbUser getUser() {\n+      return USER;\n+    }\n+\n+    @Bean(name = \"ACTION_ID\")\n+    public String getActionId() {\n+      return ActionAuditTestConfig.ACTION_ID;\n+    }\n+\n+    @Bean\n+    public Clock getClock() {\n+      return new FakeClock(ActionAuditTestConfig.INSTANT);\n+    }\n+  }\n+\n+  @Autowired UserServiceAuditor userServiceAuditor;\n+  @Autowired ActionAuditService mockActionAuditService;\n+\n+  @After\n+  public void tearDown() {\n+    USER = null;\n+  }\n+\n+  private static DbUser createUser() {\n+    final DbUser user = new DbUser();\n+    user.setUserId(3L);\n+    user.setUsername(\"foo@gmail.com\");\n+    return user;\n+  }\n+\n+  @Test\n+  public void testFireUpdateDataAccessAction_userAgent() {\n+    USER = createUser();\n+    userServiceAuditor.fireUpdateDataAccessAction(\n+        USER, DataAccessLevel.UNREGISTERED, DataAccessLevel.REGISTERED, AgentType.USER);\n+    verify(mockActionAuditService)\n+        .send(\n+            argThat(\n+                (ActionAuditEvent a) ->\n+                    a.getAgentId() == USER.getUserId()\n+                        && USER.getUsername().equals(a.getAgentEmailMaybe())\n+                        && a.getAgentType() == AgentType.USER));\n+  }\n+\n+  @Test\n+  public void testFireUpdateDataAccessAction_systemAgent() {\n+    userServiceAuditor.fireUpdateDataAccessAction(\n+        createUser(), DataAccessLevel.UNREGISTERED, DataAccessLevel.REGISTERED, AgentType.SYSTEM);\n+    verify(mockActionAuditService)\n+        .send(\n+            argThat(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fe26e6835dc272c67497054e7e20805edd770cf"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyODU4NjEy", "url": "https://github.com/all-of-us/workbench/pull/3160#pullrequestreview-362858612", "createdAt": "2020-02-21T19:19:41Z", "commit": {"oid": "515a75d02c79ef56e9519ae02e1cc8fa5605cf8d"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxOToxOTo0MVrOFtB1VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxOTo0MTozOVrOFtCc7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2MDI3Ng==", "bodyText": "Yeah, that's odd.", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382760276", "createdAt": "2020-02-21T19:19:41Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditServiceImpl.kt", "diffHunk": "@@ -5,13 +5,13 @@ import com.google.cloud.logging.LogEntry\n import com.google.cloud.logging.Logging\n import com.google.cloud.logging.Payload.JsonPayload\n import com.google.cloud.logging.Severity\n+import org.pmiops.workbench.config.WorkbenchConfig", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "515a75d02c79ef56e9519ae02e1cc8fa5605cf8d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2MTY1NQ==", "bodyText": "you should be able to leave this null now. Looks like the local convention is to explicitly set the optionals for clarity. Otherwise I'd generally say to leave out the args that have defaults.", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382761655", "createdAt": "2020-02-21T19:22:39Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/EgressEventAuditorImpl.kt", "diffHunk": "@@ -154,7 +154,7 @@ constructor(\n                 actionId = actionIdProvider.get(),\n                 actionType = ActionType.DETECT_HIGH_EGRESS_EVENT,\n                 agentType = AgentType.SYSTEM,\n-                agentId = 0,\n+                agentIdMaybe = 0,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "515a75d02c79ef56e9519ae02e1cc8fa5605cf8d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2MjE0OQ==", "bodyText": "How do you determine the preferred argument order?", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382762149", "createdAt": "2020-02-21T19:23:44Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditAdapterImpl.java", "diffHunk": "@@ -20,32 +22,37 @@\n @Service\n public class UserServiceAuditAdapterImpl implements UserServiceAuditor {\n \n+  private static final Logger log = Logger.getLogger(UserServiceAuditAdapterImpl.class.getName());\n+\n   private final ActionAuditService actionAuditService;\n   private final Clock clock;\n-  private Provider<DbUser> dbUserProvider;\n   private Provider<String> actionIdProvider;\n+  private Provider<DbUser> dbUserProvider;\n \n   @Autowired\n   public UserServiceAuditAdapterImpl(\n       ActionAuditService actionAuditService,\n       Clock clock,\n-      Provider<DbUser> dbUserProvider,\n-      @Qualifier(\"ACTION_ID\") Provider<String> actionIdProvider) {\n+      @Qualifier(\"ACTION_ID\") Provider<String> actionIdProvider,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "515a75d02c79ef56e9519ae02e1cc8fa5605cf8d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2MzgxNQ==", "bodyText": "Not likely in the short term I guess, but there's nothing baked in to prevent that, right? Like if we needed to do a batch access change because we added or removed an access level.\nNot worth worrying about right now.", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382763815", "createdAt": "2020-02-21T19:27:02Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditAdapterImpl.java", "diffHunk": "@@ -61,12 +80,13 @@ public void fireAdministrativeBypassTime(\n       long userId,\n       BypassTimeTargetProperty bypassTimeTargetProperty,\n       Optional<Instant> bypassTime) {\n+    DbUser adminUser = dbUserProvider.get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDk3MA=="}, "originalCommit": {"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2OTQ5MQ==", "bodyText": "This is much cleaner, thanks.\nOnly thing that would be neater would be to inject the agent somehow, but I'm guessing that's not trivial because of threading and auth concerns.", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382769491", "createdAt": "2020-02-21T19:39:36Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserService.java", "diffHunk": "@@ -71,21 +72,21 @@ DbUser syncComplianceTrainingStatusV1()\n       throws org.pmiops.workbench.moodle.ApiException, NotFoundException;\n \n   @Deprecated\n-  DbUser syncComplianceTrainingStatusV1(DbUser user)\n+  DbUser syncComplianceTrainingStatusV1(DbUser user, Agent agent)\n       throws org.pmiops.workbench.moodle.ApiException, NotFoundException;\n \n   DbUser syncComplianceTrainingStatusV2()\n       throws org.pmiops.workbench.moodle.ApiException, NotFoundException;\n \n-  DbUser syncComplianceTrainingStatusV2(DbUser user)\n+  DbUser syncComplianceTrainingStatusV2(DbUser user, Agent agent)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "515a75d02c79ef56e9519ae02e1cc8fa5605cf8d"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3MDQxNQ==", "bodyText": "aside: I wonder if it's worth changing agentEmail to agentUsername everywhere (except in what's sent to Stackdriver). For another day.", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382770415", "createdAt": "2020-02-21T19:41:39Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditorTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Mockito.verify;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent;\n+import org.pmiops.workbench.actionaudit.ActionAuditService;\n+import org.pmiops.workbench.actionaudit.Agent;\n+import org.pmiops.workbench.actionaudit.AgentType;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.model.DataAccessLevel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class UserServiceAuditorTest {\n+  @TestConfiguration\n+  @Import({UserServiceAuditAdapterImpl.class, ActionAuditTestConfig.class})\n+  @MockBean(ActionAuditService.class)\n+  static class Configuration {}\n+\n+  @Captor ArgumentCaptor<ActionAuditEvent> eventArg;\n+\n+  @Autowired UserServiceAuditor userServiceAuditor;\n+  @Autowired ActionAuditService mockActionAuditService;\n+\n+  private static DbUser createUser() {\n+    final DbUser user = new DbUser();\n+    user.setUserId(3L);\n+    user.setUsername(\"foo@gmail.com\");\n+    return user;\n+  }\n+\n+  @Test\n+  public void testFireUpdateDataAccessAction_userAgent() {\n+    DbUser user = createUser();\n+    userServiceAuditor.fireUpdateDataAccessAction(\n+        user, DataAccessLevel.UNREGISTERED, DataAccessLevel.REGISTERED, Agent.asUser(user));\n+    verify(mockActionAuditService).send(eventArg.capture());\n+\n+    ActionAuditEvent event = eventArg.getValue();\n+    assertThat(event.getAgentType()).isEqualTo(AgentType.USER);\n+    assertThat(event.getAgentIdMaybe()).isEqualTo(user.getUserId());\n+    assertThat(event.getAgentEmailMaybe()).isEqualTo(user.getUsername());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "515a75d02c79ef56e9519ae02e1cc8fa5605cf8d"}, "originalPosition": 51}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7965f7ec1050bbcb0721784d89720397df162730", "author": {"user": {"login": "calbach", "name": "CH Albach"}}, "url": "https://github.com/all-of-us/workbench/commit/7965f7ec1050bbcb0721784d89720397df162730", "committedDate": "2020-02-21T21:58:48Z", "message": "Plumb proper agent type, nullable user"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8650c6b0656ebc51d29a5646e11d2bd297c0ad4a", "author": {"user": {"login": "calbach", "name": "CH Albach"}}, "url": "https://github.com/all-of-us/workbench/commit/8650c6b0656ebc51d29a5646e11d2bd297c0ad4a", "committedDate": "2020-02-21T21:58:48Z", "message": "Try test, verification not working.... Kotlin?"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a117b67b36207496e56d28afd1964dd1a27abbfe", "author": {"user": {"login": "calbach", "name": "CH Albach"}}, "url": "https://github.com/all-of-us/workbench/commit/a117b67b36207496e56d28afd1964dd1a27abbfe", "committedDate": "2020-02-21T21:58:48Z", "message": "PR fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06d4d9056bc3c61145a44794d4b8277bca6d3b69", "author": {"user": {"login": "calbach", "name": "CH Albach"}}, "url": "https://github.com/all-of-us/workbench/commit/06d4d9056bc3c61145a44794d4b8277bca6d3b69", "committedDate": "2020-02-21T21:58:48Z", "message": "Refactor agent and optional agent id"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "386f5dd4e21c55a6ad588c047f8a98feb8061835", "author": {"user": {"login": "calbach", "name": "CH Albach"}}, "url": "https://github.com/all-of-us/workbench/commit/386f5dd4e21c55a6ad588c047f8a98feb8061835", "committedDate": "2020-02-21T21:58:48Z", "message": "PR feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "016d3cf08de1eea12d8c81535a21f233ece74e5e", "author": {"user": {"login": "calbach", "name": "CH Albach"}}, "url": "https://github.com/all-of-us/workbench/commit/016d3cf08de1eea12d8c81535a21f233ece74e5e", "committedDate": "2020-02-21T20:02:43Z", "message": "PR feedback"}, "afterCommit": {"oid": "386f5dd4e21c55a6ad588c047f8a98feb8061835", "author": {"user": {"login": "calbach", "name": "CH Albach"}}, "url": "https://github.com/all-of-us/workbench/commit/386f5dd4e21c55a6ad588c047f8a98feb8061835", "committedDate": "2020-02-21T21:58:48Z", "message": "PR feedback"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3611, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}