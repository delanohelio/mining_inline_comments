{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2NDYxNzAw", "number": 3570, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTozMTo0NVrOD8Pn5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTo0OToyMFrOD8P7YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDk3MTI0OnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTozMTo0NVrOGVERNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTozMTo0NVrOGVERNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0MzIyMw==", "bodyText": "other..", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424743223", "createdAt": "2020-05-13T21:31:45Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "diffHunk": "@@ -1,65 +1,227 @@\n require \"google/cloud/monitoring\"\n require 'logger'\n+require 'json'\n \n require_relative \"./lib/service_account_manager\"\n require_relative './lib/gcp_environment_visitor'\n \n CUSTOM_METRIC_FILTER = \"metric.type = starts_with(\\\"custom.googleapis.com/\\\")\"\n LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/\\\")\"\n USER_LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/user/\\\")\"\n+FILE_SUFFIXES = {:yaml => '.yaml', :json => '.json'}\n \n class MonitoringAssets\n-  def initialize(envs_path, logger = Logger.new(STDOUT))\n+  def initialize(envs_path, output_dir='.', logger = Logger.new(STDOUT), output_format = :yaml)\n     @visitor = GcpEnvironmentVisitor.new(envs_path, logger)\n+    @output_dir = output_dir\n     @logger = logger\n+    @output_format = output_format\n   end\n \n+  attr_accessor(:current_env, :metric_client, :project_path, :alert_client)\n+  attr_reader(:visitor, :logger, :output_dir)\n+\n   # Demonstrate a simple usage of the AouEnvironmentVisitor with a few read-only operations\n   # on monitoring things in all the environments.\n   def inventory\n-    @visitor.visit do |env|\n+    visit_envs do |env_bundle|\n       counts  = {}\n-      metric_client = Google::Cloud::Monitoring::Metric.new\n-      metric_project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(env.project_id)\n+      # pp env_bundle\n+      # exit\n+      metric_client = @metric_client\n \n-      resources = metric_client.list_monitored_resource_descriptors(metric_project_path)\n-      @logger.info(\"found #{resources.count} monitored resources\")\n+      resources = metric_client.list_monitored_resource_descriptors(@project_path)\n+      logger.info(\"found #{resources.count} monitored resources\")\n       counts['monitored_resources'] = resources.count\n \n-      all_metrics = metric_client.list_metric_descriptors(metric_project_path)\n+      all_metrics = metric_client.list_metric_descriptors(@project_path)\n       counts['metric_descriptors'] =  all_metrics.count\n-      @logger.info(\"found #{all_metrics.count} metric descriptors\")\n+      logger.info(\"found #{all_metrics.count} metric descriptors\")\n \n-      custom_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: CUSTOM_METRIC_FILTER})\n-      @logger.info(\"found  #{custom_metrics.count} custom metrics\")\n+      custom_metrics = metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+      logger.info(\"found  #{custom_metrics.count} custom metrics\")\n       counts['custom_metrics'] = custom_metrics.count\n       custom_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      user_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+      user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n       counts['user_logs_based_metrics'] = user_logs_based_metrics.count\n-      @logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n+      logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n \n       user_logs_based_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      total_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: LOGS_BASED_METRIC_FILTER})\n-      @logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n+      total_logs_based_metrics = metric_client.list_metric_descriptors(@project_path, {filter: LOGS_BASED_METRIC_FILTER})\n+      logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n \n-      alerts_client = Google::Cloud::Monitoring::V3::AlertPolicyServiceClient.new\n-      policies = alerts_client.list_alert_policies(env.formatted_project_name)\n-      @logger.info(\"found #{policies.count} alerting policies\")\n+      policies = @alert_client.list_alert_policies(@project_path)\n+      logger.info(\"found #{policies.count} alerting policies\")\n       counts['policies'] = policies.count\n \n       policies.each do |policy|\n-        @logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n+        logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n       end\n \n-      @logger.info(\"Total counts for #{env.short_name}: #{counts}\")\n+      logger.info(\"Total counts for #{@current_env.short_name}: #{counts}\")\n+    end\n+  end\n+\n+  DO_BACKUP_ALL = false # TODO(jaycarlton): make this an option\n+\n+  # For every environment in the envs_file, fetch all items of interest from the appropriate\n+  # Stackdriver APIs. (Note that in future we may wish to broaden this to other )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDk3ODY3OnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTozNDoxOFrOGVEVqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMzoxNDozOVrOGVGtsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0NDM2Mw==", "bodyText": "I assume adding this twice was not intentional", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424744363", "createdAt": "2020-05-13T21:34:18Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "diffHunk": "@@ -1,65 +1,227 @@\n require \"google/cloud/monitoring\"\n require 'logger'\n+require 'json'\n \n require_relative \"./lib/service_account_manager\"\n require_relative './lib/gcp_environment_visitor'\n \n CUSTOM_METRIC_FILTER = \"metric.type = starts_with(\\\"custom.googleapis.com/\\\")\"\n LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/\\\")\"\n USER_LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/user/\\\")\"\n+FILE_SUFFIXES = {:yaml => '.yaml', :json => '.json'}\n \n class MonitoringAssets\n-  def initialize(envs_path, logger = Logger.new(STDOUT))\n+  def initialize(envs_path, output_dir='.', logger = Logger.new(STDOUT), output_format = :yaml)\n     @visitor = GcpEnvironmentVisitor.new(envs_path, logger)\n+    @output_dir = output_dir\n     @logger = logger\n+    @output_format = output_format\n   end\n \n+  attr_accessor(:current_env, :metric_client, :project_path, :alert_client)\n+  attr_reader(:visitor, :logger, :output_dir)\n+\n   # Demonstrate a simple usage of the AouEnvironmentVisitor with a few read-only operations\n   # on monitoring things in all the environments.\n   def inventory\n-    @visitor.visit do |env|\n+    visit_envs do |env_bundle|\n       counts  = {}\n-      metric_client = Google::Cloud::Monitoring::Metric.new\n-      metric_project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(env.project_id)\n+      # pp env_bundle\n+      # exit\n+      metric_client = @metric_client\n \n-      resources = metric_client.list_monitored_resource_descriptors(metric_project_path)\n-      @logger.info(\"found #{resources.count} monitored resources\")\n+      resources = metric_client.list_monitored_resource_descriptors(@project_path)\n+      logger.info(\"found #{resources.count} monitored resources\")\n       counts['monitored_resources'] = resources.count\n \n-      all_metrics = metric_client.list_metric_descriptors(metric_project_path)\n+      all_metrics = metric_client.list_metric_descriptors(@project_path)\n       counts['metric_descriptors'] =  all_metrics.count\n-      @logger.info(\"found #{all_metrics.count} metric descriptors\")\n+      logger.info(\"found #{all_metrics.count} metric descriptors\")\n \n-      custom_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: CUSTOM_METRIC_FILTER})\n-      @logger.info(\"found  #{custom_metrics.count} custom metrics\")\n+      custom_metrics = metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+      logger.info(\"found  #{custom_metrics.count} custom metrics\")\n       counts['custom_metrics'] = custom_metrics.count\n       custom_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      user_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+      user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n       counts['user_logs_based_metrics'] = user_logs_based_metrics.count\n-      @logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n+      logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n \n       user_logs_based_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      total_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: LOGS_BASED_METRIC_FILTER})\n-      @logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n+      total_logs_based_metrics = metric_client.list_metric_descriptors(@project_path, {filter: LOGS_BASED_METRIC_FILTER})\n+      logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n \n-      alerts_client = Google::Cloud::Monitoring::V3::AlertPolicyServiceClient.new\n-      policies = alerts_client.list_alert_policies(env.formatted_project_name)\n-      @logger.info(\"found #{policies.count} alerting policies\")\n+      policies = @alert_client.list_alert_policies(@project_path)\n+      logger.info(\"found #{policies.count} alerting policies\")\n       counts['policies'] = policies.count\n \n       policies.each do |policy|\n-        @logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n+        logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n       end\n \n-      @logger.info(\"Total counts for #{env.short_name}: #{counts}\")\n+      logger.info(\"Total counts for #{@current_env.short_name}: #{counts}\")\n+    end\n+  end\n+\n+  DO_BACKUP_ALL = false # TODO(jaycarlton): make this an option\n+\n+  # For every environment in the envs_file, fetch all items of interest from the appropriate\n+  # Stackdriver APIs. (Note that in future we may wish to broaden this to other )\n+  def backup_config\n+    visit_envs do |env_bundle|\n+      backup_alert_policies\n+      if DO_BACKUP_ALL\n+        backup_all_metrics\n+      else\n+        backup_custom_metrics\n+        backup_user_logs_based_metrics\n+      end\n+      backup_dashboards\n+      backup_group_members\n+      backup_monitored_resources\n+      backup_notification_channels\n+      backup_notification_channels", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc4MzI4Mw==", "bodyText": "good catch", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424783283", "createdAt": "2020-05-13T23:14:39Z", "author": {"login": "jaycarlton"}, "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "diffHunk": "@@ -1,65 +1,227 @@\n require \"google/cloud/monitoring\"\n require 'logger'\n+require 'json'\n \n require_relative \"./lib/service_account_manager\"\n require_relative './lib/gcp_environment_visitor'\n \n CUSTOM_METRIC_FILTER = \"metric.type = starts_with(\\\"custom.googleapis.com/\\\")\"\n LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/\\\")\"\n USER_LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/user/\\\")\"\n+FILE_SUFFIXES = {:yaml => '.yaml', :json => '.json'}\n \n class MonitoringAssets\n-  def initialize(envs_path, logger = Logger.new(STDOUT))\n+  def initialize(envs_path, output_dir='.', logger = Logger.new(STDOUT), output_format = :yaml)\n     @visitor = GcpEnvironmentVisitor.new(envs_path, logger)\n+    @output_dir = output_dir\n     @logger = logger\n+    @output_format = output_format\n   end\n \n+  attr_accessor(:current_env, :metric_client, :project_path, :alert_client)\n+  attr_reader(:visitor, :logger, :output_dir)\n+\n   # Demonstrate a simple usage of the AouEnvironmentVisitor with a few read-only operations\n   # on monitoring things in all the environments.\n   def inventory\n-    @visitor.visit do |env|\n+    visit_envs do |env_bundle|\n       counts  = {}\n-      metric_client = Google::Cloud::Monitoring::Metric.new\n-      metric_project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(env.project_id)\n+      # pp env_bundle\n+      # exit\n+      metric_client = @metric_client\n \n-      resources = metric_client.list_monitored_resource_descriptors(metric_project_path)\n-      @logger.info(\"found #{resources.count} monitored resources\")\n+      resources = metric_client.list_monitored_resource_descriptors(@project_path)\n+      logger.info(\"found #{resources.count} monitored resources\")\n       counts['monitored_resources'] = resources.count\n \n-      all_metrics = metric_client.list_metric_descriptors(metric_project_path)\n+      all_metrics = metric_client.list_metric_descriptors(@project_path)\n       counts['metric_descriptors'] =  all_metrics.count\n-      @logger.info(\"found #{all_metrics.count} metric descriptors\")\n+      logger.info(\"found #{all_metrics.count} metric descriptors\")\n \n-      custom_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: CUSTOM_METRIC_FILTER})\n-      @logger.info(\"found  #{custom_metrics.count} custom metrics\")\n+      custom_metrics = metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+      logger.info(\"found  #{custom_metrics.count} custom metrics\")\n       counts['custom_metrics'] = custom_metrics.count\n       custom_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      user_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+      user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n       counts['user_logs_based_metrics'] = user_logs_based_metrics.count\n-      @logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n+      logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n \n       user_logs_based_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      total_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: LOGS_BASED_METRIC_FILTER})\n-      @logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n+      total_logs_based_metrics = metric_client.list_metric_descriptors(@project_path, {filter: LOGS_BASED_METRIC_FILTER})\n+      logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n \n-      alerts_client = Google::Cloud::Monitoring::V3::AlertPolicyServiceClient.new\n-      policies = alerts_client.list_alert_policies(env.formatted_project_name)\n-      @logger.info(\"found #{policies.count} alerting policies\")\n+      policies = @alert_client.list_alert_policies(@project_path)\n+      logger.info(\"found #{policies.count} alerting policies\")\n       counts['policies'] = policies.count\n \n       policies.each do |policy|\n-        @logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n+        logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n       end\n \n-      @logger.info(\"Total counts for #{env.short_name}: #{counts}\")\n+      logger.info(\"Total counts for #{@current_env.short_name}: #{counts}\")\n+    end\n+  end\n+\n+  DO_BACKUP_ALL = false # TODO(jaycarlton): make this an option\n+\n+  # For every environment in the envs_file, fetch all items of interest from the appropriate\n+  # Stackdriver APIs. (Note that in future we may wish to broaden this to other )\n+  def backup_config\n+    visit_envs do |env_bundle|\n+      backup_alert_policies\n+      if DO_BACKUP_ALL\n+        backup_all_metrics\n+      else\n+        backup_custom_metrics\n+        backup_user_logs_based_metrics\n+      end\n+      backup_dashboards\n+      backup_group_members\n+      backup_monitored_resources\n+      backup_notification_channels\n+      backup_notification_channels", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0NDM2Mw=="}, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDk4NDY3OnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTozNjozN1rOGVEZiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTozNjozN1rOGVEZiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0NTM1Mw==", "bodyText": "nit: newline", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424745353", "createdAt": "2020-05-13T21:36:37Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "diffHunk": "@@ -1,65 +1,227 @@\n require \"google/cloud/monitoring\"\n require 'logger'\n+require 'json'\n \n require_relative \"./lib/service_account_manager\"\n require_relative './lib/gcp_environment_visitor'\n \n CUSTOM_METRIC_FILTER = \"metric.type = starts_with(\\\"custom.googleapis.com/\\\")\"\n LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/\\\")\"\n USER_LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/user/\\\")\"\n+FILE_SUFFIXES = {:yaml => '.yaml', :json => '.json'}\n \n class MonitoringAssets\n-  def initialize(envs_path, logger = Logger.new(STDOUT))\n+  def initialize(envs_path, output_dir='.', logger = Logger.new(STDOUT), output_format = :yaml)\n     @visitor = GcpEnvironmentVisitor.new(envs_path, logger)\n+    @output_dir = output_dir\n     @logger = logger\n+    @output_format = output_format\n   end\n \n+  attr_accessor(:current_env, :metric_client, :project_path, :alert_client)\n+  attr_reader(:visitor, :logger, :output_dir)\n+\n   # Demonstrate a simple usage of the AouEnvironmentVisitor with a few read-only operations\n   # on monitoring things in all the environments.\n   def inventory\n-    @visitor.visit do |env|\n+    visit_envs do |env_bundle|\n       counts  = {}\n-      metric_client = Google::Cloud::Monitoring::Metric.new\n-      metric_project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(env.project_id)\n+      # pp env_bundle\n+      # exit\n+      metric_client = @metric_client\n \n-      resources = metric_client.list_monitored_resource_descriptors(metric_project_path)\n-      @logger.info(\"found #{resources.count} monitored resources\")\n+      resources = metric_client.list_monitored_resource_descriptors(@project_path)\n+      logger.info(\"found #{resources.count} monitored resources\")\n       counts['monitored_resources'] = resources.count\n \n-      all_metrics = metric_client.list_metric_descriptors(metric_project_path)\n+      all_metrics = metric_client.list_metric_descriptors(@project_path)\n       counts['metric_descriptors'] =  all_metrics.count\n-      @logger.info(\"found #{all_metrics.count} metric descriptors\")\n+      logger.info(\"found #{all_metrics.count} metric descriptors\")\n \n-      custom_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: CUSTOM_METRIC_FILTER})\n-      @logger.info(\"found  #{custom_metrics.count} custom metrics\")\n+      custom_metrics = metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+      logger.info(\"found  #{custom_metrics.count} custom metrics\")\n       counts['custom_metrics'] = custom_metrics.count\n       custom_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      user_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+      user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n       counts['user_logs_based_metrics'] = user_logs_based_metrics.count\n-      @logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n+      logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n \n       user_logs_based_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      total_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: LOGS_BASED_METRIC_FILTER})\n-      @logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n+      total_logs_based_metrics = metric_client.list_metric_descriptors(@project_path, {filter: LOGS_BASED_METRIC_FILTER})\n+      logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n \n-      alerts_client = Google::Cloud::Monitoring::V3::AlertPolicyServiceClient.new\n-      policies = alerts_client.list_alert_policies(env.formatted_project_name)\n-      @logger.info(\"found #{policies.count} alerting policies\")\n+      policies = @alert_client.list_alert_policies(@project_path)\n+      logger.info(\"found #{policies.count} alerting policies\")\n       counts['policies'] = policies.count\n \n       policies.each do |policy|\n-        @logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n+        logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n       end\n \n-      @logger.info(\"Total counts for #{env.short_name}: #{counts}\")\n+      logger.info(\"Total counts for #{@current_env.short_name}: #{counts}\")\n+    end\n+  end\n+\n+  DO_BACKUP_ALL = false # TODO(jaycarlton): make this an option\n+\n+  # For every environment in the envs_file, fetch all items of interest from the appropriate\n+  # Stackdriver APIs. (Note that in future we may wish to broaden this to other )\n+  def backup_config\n+    visit_envs do |env_bundle|\n+      backup_alert_policies\n+      if DO_BACKUP_ALL\n+        backup_all_metrics\n+      else\n+        backup_custom_metrics\n+        backup_user_logs_based_metrics\n+      end\n+      backup_dashboards\n+      backup_group_members\n+      backup_monitored_resources\n+      backup_notification_channels\n+      backup_notification_channels\n     end\n+  end\n+\n+  private\n+\n+  def backup_alert_policies\n+    policies = @alert_client.list_alert_policies(@project_path)\n+    backup_assets(policies)\n+  end\n+\n+  def backup_custom_metrics\n+    custom_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+    backup_assets(custom_metrics)\n+  end\n+\n+  def backup_dashboards\n+    dashboards = @dashboard_client.list_dashboards(@current_env.formatted_project_number)\n+    backup_assets(dashboards)\n+  end\n+  def backup_user_logs_based_metrics", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDk5MjUyOnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTozOToyNFrOGVEefQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMzoxNDo1NVrOGVGt_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0NjYyMQ==", "bodyText": "Interesting, first time seeing this syntax", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424746621", "createdAt": "2020-05-13T21:39:24Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "diffHunk": "@@ -1,65 +1,227 @@\n require \"google/cloud/monitoring\"\n require 'logger'\n+require 'json'\n \n require_relative \"./lib/service_account_manager\"\n require_relative './lib/gcp_environment_visitor'\n \n CUSTOM_METRIC_FILTER = \"metric.type = starts_with(\\\"custom.googleapis.com/\\\")\"\n LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/\\\")\"\n USER_LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/user/\\\")\"\n+FILE_SUFFIXES = {:yaml => '.yaml', :json => '.json'}\n \n class MonitoringAssets\n-  def initialize(envs_path, logger = Logger.new(STDOUT))\n+  def initialize(envs_path, output_dir='.', logger = Logger.new(STDOUT), output_format = :yaml)\n     @visitor = GcpEnvironmentVisitor.new(envs_path, logger)\n+    @output_dir = output_dir\n     @logger = logger\n+    @output_format = output_format\n   end\n \n+  attr_accessor(:current_env, :metric_client, :project_path, :alert_client)\n+  attr_reader(:visitor, :logger, :output_dir)\n+\n   # Demonstrate a simple usage of the AouEnvironmentVisitor with a few read-only operations\n   # on monitoring things in all the environments.\n   def inventory\n-    @visitor.visit do |env|\n+    visit_envs do |env_bundle|\n       counts  = {}\n-      metric_client = Google::Cloud::Monitoring::Metric.new\n-      metric_project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(env.project_id)\n+      # pp env_bundle\n+      # exit\n+      metric_client = @metric_client\n \n-      resources = metric_client.list_monitored_resource_descriptors(metric_project_path)\n-      @logger.info(\"found #{resources.count} monitored resources\")\n+      resources = metric_client.list_monitored_resource_descriptors(@project_path)\n+      logger.info(\"found #{resources.count} monitored resources\")\n       counts['monitored_resources'] = resources.count\n \n-      all_metrics = metric_client.list_metric_descriptors(metric_project_path)\n+      all_metrics = metric_client.list_metric_descriptors(@project_path)\n       counts['metric_descriptors'] =  all_metrics.count\n-      @logger.info(\"found #{all_metrics.count} metric descriptors\")\n+      logger.info(\"found #{all_metrics.count} metric descriptors\")\n \n-      custom_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: CUSTOM_METRIC_FILTER})\n-      @logger.info(\"found  #{custom_metrics.count} custom metrics\")\n+      custom_metrics = metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+      logger.info(\"found  #{custom_metrics.count} custom metrics\")\n       counts['custom_metrics'] = custom_metrics.count\n       custom_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      user_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+      user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n       counts['user_logs_based_metrics'] = user_logs_based_metrics.count\n-      @logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n+      logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n \n       user_logs_based_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      total_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: LOGS_BASED_METRIC_FILTER})\n-      @logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n+      total_logs_based_metrics = metric_client.list_metric_descriptors(@project_path, {filter: LOGS_BASED_METRIC_FILTER})\n+      logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n \n-      alerts_client = Google::Cloud::Monitoring::V3::AlertPolicyServiceClient.new\n-      policies = alerts_client.list_alert_policies(env.formatted_project_name)\n-      @logger.info(\"found #{policies.count} alerting policies\")\n+      policies = @alert_client.list_alert_policies(@project_path)\n+      logger.info(\"found #{policies.count} alerting policies\")\n       counts['policies'] = policies.count\n \n       policies.each do |policy|\n-        @logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n+        logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n       end\n \n-      @logger.info(\"Total counts for #{env.short_name}: #{counts}\")\n+      logger.info(\"Total counts for #{@current_env.short_name}: #{counts}\")\n+    end\n+  end\n+\n+  DO_BACKUP_ALL = false # TODO(jaycarlton): make this an option\n+\n+  # For every environment in the envs_file, fetch all items of interest from the appropriate\n+  # Stackdriver APIs. (Note that in future we may wish to broaden this to other )\n+  def backup_config\n+    visit_envs do |env_bundle|\n+      backup_alert_policies\n+      if DO_BACKUP_ALL\n+        backup_all_metrics\n+      else\n+        backup_custom_metrics\n+        backup_user_logs_based_metrics\n+      end\n+      backup_dashboards\n+      backup_group_members\n+      backup_monitored_resources\n+      backup_notification_channels\n+      backup_notification_channels\n     end\n+  end\n+\n+  private\n+\n+  def backup_alert_policies\n+    policies = @alert_client.list_alert_policies(@project_path)\n+    backup_assets(policies)\n+  end\n+\n+  def backup_custom_metrics\n+    custom_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+    backup_assets(custom_metrics)\n+  end\n+\n+  def backup_dashboards\n+    dashboards = @dashboard_client.list_dashboards(@current_env.formatted_project_number)\n+    backup_assets(dashboards)\n+  end\n+  def backup_user_logs_based_metrics\n+    user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+    backup_assets(user_logs_based_metrics)\n+  end\n+\n+  def backup_monitored_resources\n+    resources = @metric_client.list_monitored_resource_descriptors(@project_path)\n+    backup_assets(resources)\n+  end\n+\n+  # Grab all the metrics, including very many defined by Google and partners. This method is here\n+  # more for completeness and to allow introspection/navigation of them than anything else, as we\n+  # can't write to these to restore them.\n+  def backup_all_metrics\n+    metrics = @metric_client.list_metric_descriptors(@project_path)\n+    backup_assets(metrics)\n+  end\n+\n+  def backup_group_members\n+    members = @group_client.list_groups(@project_path)\n+    backup_assets(members)\n+  end\n+\n+  def backup_notification_channels\n+    channels = @notification_channel_client.list_notification_channels(@project_path)\n+    backup_assets(channels)\n+  end\n+\n+  # Backup a collection of Stackdriver assets\n+  def backup_assets(assets)\n+    assets.each(&method(:backup_asset))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc4MzM1Nw==", "bodyText": "Yeah the IDE did that for me on a refactor.", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424783357", "createdAt": "2020-05-13T23:14:55Z", "author": {"login": "jaycarlton"}, "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "diffHunk": "@@ -1,65 +1,227 @@\n require \"google/cloud/monitoring\"\n require 'logger'\n+require 'json'\n \n require_relative \"./lib/service_account_manager\"\n require_relative './lib/gcp_environment_visitor'\n \n CUSTOM_METRIC_FILTER = \"metric.type = starts_with(\\\"custom.googleapis.com/\\\")\"\n LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/\\\")\"\n USER_LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/user/\\\")\"\n+FILE_SUFFIXES = {:yaml => '.yaml', :json => '.json'}\n \n class MonitoringAssets\n-  def initialize(envs_path, logger = Logger.new(STDOUT))\n+  def initialize(envs_path, output_dir='.', logger = Logger.new(STDOUT), output_format = :yaml)\n     @visitor = GcpEnvironmentVisitor.new(envs_path, logger)\n+    @output_dir = output_dir\n     @logger = logger\n+    @output_format = output_format\n   end\n \n+  attr_accessor(:current_env, :metric_client, :project_path, :alert_client)\n+  attr_reader(:visitor, :logger, :output_dir)\n+\n   # Demonstrate a simple usage of the AouEnvironmentVisitor with a few read-only operations\n   # on monitoring things in all the environments.\n   def inventory\n-    @visitor.visit do |env|\n+    visit_envs do |env_bundle|\n       counts  = {}\n-      metric_client = Google::Cloud::Monitoring::Metric.new\n-      metric_project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(env.project_id)\n+      # pp env_bundle\n+      # exit\n+      metric_client = @metric_client\n \n-      resources = metric_client.list_monitored_resource_descriptors(metric_project_path)\n-      @logger.info(\"found #{resources.count} monitored resources\")\n+      resources = metric_client.list_monitored_resource_descriptors(@project_path)\n+      logger.info(\"found #{resources.count} monitored resources\")\n       counts['monitored_resources'] = resources.count\n \n-      all_metrics = metric_client.list_metric_descriptors(metric_project_path)\n+      all_metrics = metric_client.list_metric_descriptors(@project_path)\n       counts['metric_descriptors'] =  all_metrics.count\n-      @logger.info(\"found #{all_metrics.count} metric descriptors\")\n+      logger.info(\"found #{all_metrics.count} metric descriptors\")\n \n-      custom_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: CUSTOM_METRIC_FILTER})\n-      @logger.info(\"found  #{custom_metrics.count} custom metrics\")\n+      custom_metrics = metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+      logger.info(\"found  #{custom_metrics.count} custom metrics\")\n       counts['custom_metrics'] = custom_metrics.count\n       custom_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      user_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+      user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n       counts['user_logs_based_metrics'] = user_logs_based_metrics.count\n-      @logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n+      logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n \n       user_logs_based_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      total_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: LOGS_BASED_METRIC_FILTER})\n-      @logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n+      total_logs_based_metrics = metric_client.list_metric_descriptors(@project_path, {filter: LOGS_BASED_METRIC_FILTER})\n+      logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n \n-      alerts_client = Google::Cloud::Monitoring::V3::AlertPolicyServiceClient.new\n-      policies = alerts_client.list_alert_policies(env.formatted_project_name)\n-      @logger.info(\"found #{policies.count} alerting policies\")\n+      policies = @alert_client.list_alert_policies(@project_path)\n+      logger.info(\"found #{policies.count} alerting policies\")\n       counts['policies'] = policies.count\n \n       policies.each do |policy|\n-        @logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n+        logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n       end\n \n-      @logger.info(\"Total counts for #{env.short_name}: #{counts}\")\n+      logger.info(\"Total counts for #{@current_env.short_name}: #{counts}\")\n+    end\n+  end\n+\n+  DO_BACKUP_ALL = false # TODO(jaycarlton): make this an option\n+\n+  # For every environment in the envs_file, fetch all items of interest from the appropriate\n+  # Stackdriver APIs. (Note that in future we may wish to broaden this to other )\n+  def backup_config\n+    visit_envs do |env_bundle|\n+      backup_alert_policies\n+      if DO_BACKUP_ALL\n+        backup_all_metrics\n+      else\n+        backup_custom_metrics\n+        backup_user_logs_based_metrics\n+      end\n+      backup_dashboards\n+      backup_group_members\n+      backup_monitored_resources\n+      backup_notification_channels\n+      backup_notification_channels\n     end\n+  end\n+\n+  private\n+\n+  def backup_alert_policies\n+    policies = @alert_client.list_alert_policies(@project_path)\n+    backup_assets(policies)\n+  end\n+\n+  def backup_custom_metrics\n+    custom_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+    backup_assets(custom_metrics)\n+  end\n+\n+  def backup_dashboards\n+    dashboards = @dashboard_client.list_dashboards(@current_env.formatted_project_number)\n+    backup_assets(dashboards)\n+  end\n+  def backup_user_logs_based_metrics\n+    user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+    backup_assets(user_logs_based_metrics)\n+  end\n+\n+  def backup_monitored_resources\n+    resources = @metric_client.list_monitored_resource_descriptors(@project_path)\n+    backup_assets(resources)\n+  end\n+\n+  # Grab all the metrics, including very many defined by Google and partners. This method is here\n+  # more for completeness and to allow introspection/navigation of them than anything else, as we\n+  # can't write to these to restore them.\n+  def backup_all_metrics\n+    metrics = @metric_client.list_metric_descriptors(@project_path)\n+    backup_assets(metrics)\n+  end\n+\n+  def backup_group_members\n+    members = @group_client.list_groups(@project_path)\n+    backup_assets(members)\n+  end\n+\n+  def backup_notification_channels\n+    channels = @notification_channel_client.list_notification_channels(@project_path)\n+    backup_assets(channels)\n+  end\n+\n+  # Backup a collection of Stackdriver assets\n+  def backup_assets(assets)\n+    assets.each(&method(:backup_asset))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0NjYyMQ=="}, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTAwNTM2OnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTo0Mzo0OVrOGVEmag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMzoxODowN1rOGVGx2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0ODY1MA==", "bodyText": "project_path is initialized twice here", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424748650", "createdAt": "2020-05-13T21:43:49Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "diffHunk": "@@ -1,65 +1,227 @@\n require \"google/cloud/monitoring\"\n require 'logger'\n+require 'json'\n \n require_relative \"./lib/service_account_manager\"\n require_relative './lib/gcp_environment_visitor'\n \n CUSTOM_METRIC_FILTER = \"metric.type = starts_with(\\\"custom.googleapis.com/\\\")\"\n LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/\\\")\"\n USER_LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/user/\\\")\"\n+FILE_SUFFIXES = {:yaml => '.yaml', :json => '.json'}\n \n class MonitoringAssets\n-  def initialize(envs_path, logger = Logger.new(STDOUT))\n+  def initialize(envs_path, output_dir='.', logger = Logger.new(STDOUT), output_format = :yaml)\n     @visitor = GcpEnvironmentVisitor.new(envs_path, logger)\n+    @output_dir = output_dir\n     @logger = logger\n+    @output_format = output_format\n   end\n \n+  attr_accessor(:current_env, :metric_client, :project_path, :alert_client)\n+  attr_reader(:visitor, :logger, :output_dir)\n+\n   # Demonstrate a simple usage of the AouEnvironmentVisitor with a few read-only operations\n   # on monitoring things in all the environments.\n   def inventory\n-    @visitor.visit do |env|\n+    visit_envs do |env_bundle|\n       counts  = {}\n-      metric_client = Google::Cloud::Monitoring::Metric.new\n-      metric_project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(env.project_id)\n+      # pp env_bundle\n+      # exit\n+      metric_client = @metric_client\n \n-      resources = metric_client.list_monitored_resource_descriptors(metric_project_path)\n-      @logger.info(\"found #{resources.count} monitored resources\")\n+      resources = metric_client.list_monitored_resource_descriptors(@project_path)\n+      logger.info(\"found #{resources.count} monitored resources\")\n       counts['monitored_resources'] = resources.count\n \n-      all_metrics = metric_client.list_metric_descriptors(metric_project_path)\n+      all_metrics = metric_client.list_metric_descriptors(@project_path)\n       counts['metric_descriptors'] =  all_metrics.count\n-      @logger.info(\"found #{all_metrics.count} metric descriptors\")\n+      logger.info(\"found #{all_metrics.count} metric descriptors\")\n \n-      custom_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: CUSTOM_METRIC_FILTER})\n-      @logger.info(\"found  #{custom_metrics.count} custom metrics\")\n+      custom_metrics = metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+      logger.info(\"found  #{custom_metrics.count} custom metrics\")\n       counts['custom_metrics'] = custom_metrics.count\n       custom_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      user_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+      user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n       counts['user_logs_based_metrics'] = user_logs_based_metrics.count\n-      @logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n+      logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n \n       user_logs_based_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      total_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: LOGS_BASED_METRIC_FILTER})\n-      @logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n+      total_logs_based_metrics = metric_client.list_metric_descriptors(@project_path, {filter: LOGS_BASED_METRIC_FILTER})\n+      logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n \n-      alerts_client = Google::Cloud::Monitoring::V3::AlertPolicyServiceClient.new\n-      policies = alerts_client.list_alert_policies(env.formatted_project_name)\n-      @logger.info(\"found #{policies.count} alerting policies\")\n+      policies = @alert_client.list_alert_policies(@project_path)\n+      logger.info(\"found #{policies.count} alerting policies\")\n       counts['policies'] = policies.count\n \n       policies.each do |policy|\n-        @logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n+        logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n       end\n \n-      @logger.info(\"Total counts for #{env.short_name}: #{counts}\")\n+      logger.info(\"Total counts for #{@current_env.short_name}: #{counts}\")\n+    end\n+  end\n+\n+  DO_BACKUP_ALL = false # TODO(jaycarlton): make this an option\n+\n+  # For every environment in the envs_file, fetch all items of interest from the appropriate\n+  # Stackdriver APIs. (Note that in future we may wish to broaden this to other )\n+  def backup_config\n+    visit_envs do |env_bundle|\n+      backup_alert_policies\n+      if DO_BACKUP_ALL\n+        backup_all_metrics\n+      else\n+        backup_custom_metrics\n+        backup_user_logs_based_metrics\n+      end\n+      backup_dashboards\n+      backup_group_members\n+      backup_monitored_resources\n+      backup_notification_channels\n+      backup_notification_channels\n     end\n+  end\n+\n+  private\n+\n+  def backup_alert_policies\n+    policies = @alert_client.list_alert_policies(@project_path)\n+    backup_assets(policies)\n+  end\n+\n+  def backup_custom_metrics\n+    custom_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+    backup_assets(custom_metrics)\n+  end\n+\n+  def backup_dashboards\n+    dashboards = @dashboard_client.list_dashboards(@current_env.formatted_project_number)\n+    backup_assets(dashboards)\n+  end\n+  def backup_user_logs_based_metrics\n+    user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+    backup_assets(user_logs_based_metrics)\n+  end\n+\n+  def backup_monitored_resources\n+    resources = @metric_client.list_monitored_resource_descriptors(@project_path)\n+    backup_assets(resources)\n+  end\n+\n+  # Grab all the metrics, including very many defined by Google and partners. This method is here\n+  # more for completeness and to allow introspection/navigation of them than anything else, as we\n+  # can't write to these to restore them.\n+  def backup_all_metrics\n+    metrics = @metric_client.list_metric_descriptors(@project_path)\n+    backup_assets(metrics)\n+  end\n+\n+  def backup_group_members\n+    members = @group_client.list_groups(@project_path)\n+    backup_assets(members)\n+  end\n+\n+  def backup_notification_channels\n+    channels = @notification_channel_client.list_notification_channels(@project_path)\n+    backup_assets(channels)\n+  end\n+\n+  # Backup a collection of Stackdriver assets\n+  def backup_assets(assets)\n+    assets.each(&method(:backup_asset))\n+  end\n+\n+  # Backup the cloud asset to a file in a path based on its fully\n+  # qualified name and a filename from the based on the current time.\n+  def backup_asset(asset)\n+    full_path = File.join(make_output_path(asset), make_file_name)\n+    logger.info(\"Writing #{asset.display_name} to #{full_path}\")\n+    text = serialize(asset)\n+    IO.write(full_path, text)\n+  end\n+\n+  # Serialize the Stackdriver object instance to a persistent format such as YAML or JSON\n+  def serialize(asset)\n+    case @output_format\n+    when :yaml\n+      return to_pretty_yaml(asset)\n+    when :json\n+      return to_pretty_json(asset)\n+    else\n+      @logger.WARN(\"Unrecognized output format '#{@output_format}'\")\n+      return asset.to_s\n+    end\n+  end\n+\n+  # In order to generate JSON correctly (e.g. with camelCase and only the fields Stackdriver actually\n+  # wants to expose), we need to call the asset's internal to_json() override. This gives correct\n+  # JSON (per the REST API) suitable for reuse. We then parse that JSON and re-render it prettily.\n+  def to_pretty_json(asset)\n+    reparsed_hash = to_hash(asset)\n+    JSON.pretty_generate(reparsed_hash)\n+  end\n+\n+  # Use the asset's internal to_json() to give conventional fields for the appropriate APIs\n+  # and make a hash from that.\n+  def to_hash(asset)\n+    inline_json = asset.to_json\n+    JSON.parse(inline_json)\n+  end\n+\n+  # Build a YAML representation of the asset, based on its internally-defined JSON representation\n+  # and not simply the default hash's default yaml.\n+  def to_pretty_yaml(asset)\n+    to_hash(asset).to_yaml\n+  end\n+\n+  # Generate a file name based on the current 24-hour time. This will\n+  # sort such that later times are later alphabetically.\n+  def make_file_name\n+    DateTime.now.strftime(\"%FT%T\").gsub(':', '-') + FILE_SUFFIXES[@output_format]\n+  end\n+\n+  # Private visitor that makes the distracting client initializations for each environment. The\n+  # client constructors take project details from the global scope.\n+  # TODO(jaycarlton): explicitly provide constructor parameters for the clients so refactoring\n+  # becomes easier\n+  def visit_envs\n+    visitor.visit do |env|\n+      @current_env = env\n+\n+      # Stackdriver clients. Note that somehow the initialization order matters here. I suspect it\n+      # has to do with library-wide state getting pulled into the constrctors.\n+      @metric_client = Google::Cloud::Monitoring::Metric.new\n+      @project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(@current_env.project_id)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc4NDM0NA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424784344", "createdAt": "2020-05-13T23:18:07Z", "author": {"login": "jaycarlton"}, "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "diffHunk": "@@ -1,65 +1,227 @@\n require \"google/cloud/monitoring\"\n require 'logger'\n+require 'json'\n \n require_relative \"./lib/service_account_manager\"\n require_relative './lib/gcp_environment_visitor'\n \n CUSTOM_METRIC_FILTER = \"metric.type = starts_with(\\\"custom.googleapis.com/\\\")\"\n LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/\\\")\"\n USER_LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/user/\\\")\"\n+FILE_SUFFIXES = {:yaml => '.yaml', :json => '.json'}\n \n class MonitoringAssets\n-  def initialize(envs_path, logger = Logger.new(STDOUT))\n+  def initialize(envs_path, output_dir='.', logger = Logger.new(STDOUT), output_format = :yaml)\n     @visitor = GcpEnvironmentVisitor.new(envs_path, logger)\n+    @output_dir = output_dir\n     @logger = logger\n+    @output_format = output_format\n   end\n \n+  attr_accessor(:current_env, :metric_client, :project_path, :alert_client)\n+  attr_reader(:visitor, :logger, :output_dir)\n+\n   # Demonstrate a simple usage of the AouEnvironmentVisitor with a few read-only operations\n   # on monitoring things in all the environments.\n   def inventory\n-    @visitor.visit do |env|\n+    visit_envs do |env_bundle|\n       counts  = {}\n-      metric_client = Google::Cloud::Monitoring::Metric.new\n-      metric_project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(env.project_id)\n+      # pp env_bundle\n+      # exit\n+      metric_client = @metric_client\n \n-      resources = metric_client.list_monitored_resource_descriptors(metric_project_path)\n-      @logger.info(\"found #{resources.count} monitored resources\")\n+      resources = metric_client.list_monitored_resource_descriptors(@project_path)\n+      logger.info(\"found #{resources.count} monitored resources\")\n       counts['monitored_resources'] = resources.count\n \n-      all_metrics = metric_client.list_metric_descriptors(metric_project_path)\n+      all_metrics = metric_client.list_metric_descriptors(@project_path)\n       counts['metric_descriptors'] =  all_metrics.count\n-      @logger.info(\"found #{all_metrics.count} metric descriptors\")\n+      logger.info(\"found #{all_metrics.count} metric descriptors\")\n \n-      custom_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: CUSTOM_METRIC_FILTER})\n-      @logger.info(\"found  #{custom_metrics.count} custom metrics\")\n+      custom_metrics = metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+      logger.info(\"found  #{custom_metrics.count} custom metrics\")\n       counts['custom_metrics'] = custom_metrics.count\n       custom_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      user_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+      user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n       counts['user_logs_based_metrics'] = user_logs_based_metrics.count\n-      @logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n+      logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n \n       user_logs_based_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      total_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: LOGS_BASED_METRIC_FILTER})\n-      @logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n+      total_logs_based_metrics = metric_client.list_metric_descriptors(@project_path, {filter: LOGS_BASED_METRIC_FILTER})\n+      logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n \n-      alerts_client = Google::Cloud::Monitoring::V3::AlertPolicyServiceClient.new\n-      policies = alerts_client.list_alert_policies(env.formatted_project_name)\n-      @logger.info(\"found #{policies.count} alerting policies\")\n+      policies = @alert_client.list_alert_policies(@project_path)\n+      logger.info(\"found #{policies.count} alerting policies\")\n       counts['policies'] = policies.count\n \n       policies.each do |policy|\n-        @logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n+        logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n       end\n \n-      @logger.info(\"Total counts for #{env.short_name}: #{counts}\")\n+      logger.info(\"Total counts for #{@current_env.short_name}: #{counts}\")\n+    end\n+  end\n+\n+  DO_BACKUP_ALL = false # TODO(jaycarlton): make this an option\n+\n+  # For every environment in the envs_file, fetch all items of interest from the appropriate\n+  # Stackdriver APIs. (Note that in future we may wish to broaden this to other )\n+  def backup_config\n+    visit_envs do |env_bundle|\n+      backup_alert_policies\n+      if DO_BACKUP_ALL\n+        backup_all_metrics\n+      else\n+        backup_custom_metrics\n+        backup_user_logs_based_metrics\n+      end\n+      backup_dashboards\n+      backup_group_members\n+      backup_monitored_resources\n+      backup_notification_channels\n+      backup_notification_channels\n     end\n+  end\n+\n+  private\n+\n+  def backup_alert_policies\n+    policies = @alert_client.list_alert_policies(@project_path)\n+    backup_assets(policies)\n+  end\n+\n+  def backup_custom_metrics\n+    custom_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+    backup_assets(custom_metrics)\n+  end\n+\n+  def backup_dashboards\n+    dashboards = @dashboard_client.list_dashboards(@current_env.formatted_project_number)\n+    backup_assets(dashboards)\n+  end\n+  def backup_user_logs_based_metrics\n+    user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+    backup_assets(user_logs_based_metrics)\n+  end\n+\n+  def backup_monitored_resources\n+    resources = @metric_client.list_monitored_resource_descriptors(@project_path)\n+    backup_assets(resources)\n+  end\n+\n+  # Grab all the metrics, including very many defined by Google and partners. This method is here\n+  # more for completeness and to allow introspection/navigation of them than anything else, as we\n+  # can't write to these to restore them.\n+  def backup_all_metrics\n+    metrics = @metric_client.list_metric_descriptors(@project_path)\n+    backup_assets(metrics)\n+  end\n+\n+  def backup_group_members\n+    members = @group_client.list_groups(@project_path)\n+    backup_assets(members)\n+  end\n+\n+  def backup_notification_channels\n+    channels = @notification_channel_client.list_notification_channels(@project_path)\n+    backup_assets(channels)\n+  end\n+\n+  # Backup a collection of Stackdriver assets\n+  def backup_assets(assets)\n+    assets.each(&method(:backup_asset))\n+  end\n+\n+  # Backup the cloud asset to a file in a path based on its fully\n+  # qualified name and a filename from the based on the current time.\n+  def backup_asset(asset)\n+    full_path = File.join(make_output_path(asset), make_file_name)\n+    logger.info(\"Writing #{asset.display_name} to #{full_path}\")\n+    text = serialize(asset)\n+    IO.write(full_path, text)\n+  end\n+\n+  # Serialize the Stackdriver object instance to a persistent format such as YAML or JSON\n+  def serialize(asset)\n+    case @output_format\n+    when :yaml\n+      return to_pretty_yaml(asset)\n+    when :json\n+      return to_pretty_json(asset)\n+    else\n+      @logger.WARN(\"Unrecognized output format '#{@output_format}'\")\n+      return asset.to_s\n+    end\n+  end\n+\n+  # In order to generate JSON correctly (e.g. with camelCase and only the fields Stackdriver actually\n+  # wants to expose), we need to call the asset's internal to_json() override. This gives correct\n+  # JSON (per the REST API) suitable for reuse. We then parse that JSON and re-render it prettily.\n+  def to_pretty_json(asset)\n+    reparsed_hash = to_hash(asset)\n+    JSON.pretty_generate(reparsed_hash)\n+  end\n+\n+  # Use the asset's internal to_json() to give conventional fields for the appropriate APIs\n+  # and make a hash from that.\n+  def to_hash(asset)\n+    inline_json = asset.to_json\n+    JSON.parse(inline_json)\n+  end\n+\n+  # Build a YAML representation of the asset, based on its internally-defined JSON representation\n+  # and not simply the default hash's default yaml.\n+  def to_pretty_yaml(asset)\n+    to_hash(asset).to_yaml\n+  end\n+\n+  # Generate a file name based on the current 24-hour time. This will\n+  # sort such that later times are later alphabetically.\n+  def make_file_name\n+    DateTime.now.strftime(\"%FT%T\").gsub(':', '-') + FILE_SUFFIXES[@output_format]\n+  end\n+\n+  # Private visitor that makes the distracting client initializations for each environment. The\n+  # client constructors take project details from the global scope.\n+  # TODO(jaycarlton): explicitly provide constructor parameters for the clients so refactoring\n+  # becomes easier\n+  def visit_envs\n+    visitor.visit do |env|\n+      @current_env = env\n+\n+      # Stackdriver clients. Note that somehow the initialization order matters here. I suspect it\n+      # has to do with library-wide state getting pulled into the constrctors.\n+      @metric_client = Google::Cloud::Monitoring::Metric.new\n+      @project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(@current_env.project_id)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0ODY1MA=="}, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTAyMTEyOnYy", "diffSide": "RIGHT", "path": "ops/ruby/devops-toolkit/README.md", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTo0OToyMFrOGVEwLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMzo0MTo0M1rOGXK9sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MTE0OA==", "bodyText": "This is separably from the implementation details of the tool, but where do you intend to archive these? It sounds like it's too large to want to put this into any of our git repos.", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424751148", "createdAt": "2020-05-13T21:49:20Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/README.md", "diffHunk": "@@ -70,6 +70,14 @@ bundle install\n ## Tasks\n A variety of tasks (sub-commands) are available via the required `-t` option. Here  are their\n brief descriptions:\n+- `backup-config`: Generate JSON or YAML files for each Stackdriver asset (other GCP assets TBD),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc4NDIwNQ==", "bodyText": "So there was a discussion a while back where @gjuggler mentioned that have achieved \"configuration as code\" for Stackdriver, and I've been looking for a way to make that an actual reality. https://precisionmedicineinitiative.atlassian.net/browse/RW-4946 is the task for the periodic archival. The simplest approach is to just make a zip file and post it every day and delete the Nth oldest, so they just rotate.\nIf I can output straight to BigQuery that would be even better.", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424784205", "createdAt": "2020-05-13T23:17:43Z", "author": {"login": "jaycarlton"}, "path": "ops/ruby/devops-toolkit/README.md", "diffHunk": "@@ -70,6 +70,14 @@ bundle install\n ## Tasks\n A variety of tasks (sub-commands) are available via the required `-t` option. Here  are their\n brief descriptions:\n+- `backup-config`: Generate JSON or YAML files for each Stackdriver asset (other GCP assets TBD),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MTE0OA=="}, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE0MDE0MQ==", "bodyText": "My understanding of config-as-code is that the git repo is the canonical archive of config, same as our code. Maybe I'm missing something here, though. Is there something different about our Stackdriver monitoring setup that makes it necessary to pull things back down from Google and archive them?", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r425140141", "createdAt": "2020-05-14T13:34:04Z", "author": {"login": "gjuggler"}, "path": "ops/ruby/devops-toolkit/README.md", "diffHunk": "@@ -70,6 +70,14 @@ bundle install\n ## Tasks\n A variety of tasks (sub-commands) are available via the required `-t` option. Here  are their\n brief descriptions:\n+- `backup-config`: Generate JSON or YAML files for each Stackdriver asset (other GCP assets TBD),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MTE0OA=="}, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIwODA2OA==", "bodyText": "You have to have a systematic way of keeping up with it. The first step is mirroring what Stackdriver has locally, then archiving that, then restoring it. To put it into git is doable, though you'd want to strip out non-custom things more aggressively.\nI'm not sure what form the \"config\" was expected to take if not this JSON or XML version. Either we start with that or build it with a template (which I may do next).\nIf the goal is to make the stored config the source of truth, then there needs to be some kind of reloading or two-way synchronizing happening periodically.\nThe work on the fetching pattern should be useful on the uploading step too though.", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r425208068", "createdAt": "2020-05-14T15:03:37Z", "author": {"login": "jaycarlton"}, "path": "ops/ruby/devops-toolkit/README.md", "diffHunk": "@@ -70,6 +70,14 @@ bundle install\n ## Tasks\n A variety of tasks (sub-commands) are available via the required `-t` option. Here  are their\n brief descriptions:\n+- `backup-config`: Generate JSON or YAML files for each Stackdriver asset (other GCP assets TBD),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MTE0OA=="}, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0OTExMA==", "bodyText": "If we want to put it in git, I can make a place in workbench-devops and do another PR there. I'd change the name structure to remove the multiple-files-per-config-named-after-timestamp and let git do the hard work on diffing, etc. (Sorting the arbitrarily ordered keys when writing the files will help here).\nHaving it directly in git is clearly the ideal from a config-as-code standpoint.\nMoving from here to Terraform templates would be another increment of work.", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r426749110", "createdAt": "2020-05-18T16:25:05Z", "author": {"login": "jaycarlton"}, "path": "ops/ruby/devops-toolkit/README.md", "diffHunk": "@@ -70,6 +70,14 @@ bundle install\n ## Tasks\n A variety of tasks (sub-commands) are available via the required `-t` option. Here  are their\n brief descriptions:\n+- `backup-config`: Generate JSON or YAML files for each Stackdriver asset (other GCP assets TBD),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MTE0OA=="}, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MDE3NQ==", "bodyText": "The \"code-as-config\" model would typically treat the code as the source of truth, with a one way sync from code -> deployed system. There would be no two-way sync. This simplification also allows you to templatize/parameterize these configs so that you're not managing N fully attenuated configs for N environments. Some one-time bootstrapping of these configs is fine, but that's probably a oneoff manual process.\nI have the same question as Greg, which I don't think was answered above, which is why it is necessary to sync from Stackdriver -> code config, or maintain a mechanism for performing any kind of two-way sync.", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r426770175", "createdAt": "2020-05-18T17:01:02Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/README.md", "diffHunk": "@@ -70,6 +70,14 @@ bundle install\n ## Tasks\n A variety of tasks (sub-commands) are available via the required `-t` option. Here  are their\n brief descriptions:\n+- `backup-config`: Generate JSON or YAML files for each Stackdriver asset (other GCP assets TBD),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MTE0OA=="}, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4OTEyMw==", "bodyText": "People like to fiddle with graphs and dashboards, and adjust levels and queries interactively. It would be very painful to lock down the console and only allow text edits.\nWith this tool, we can periodically (or right after a fiddling session) pull the configs, write them on top of what's in github, and PR the differences.\nIt would never have occurred to me to do a one-way only sync with an interactive, graphical tool (with such a relatively low-level API). Yes, the config is the source of truth, but prior to its existence we need a systematic way to pull it and arrange it.\nOf course going up is just in the inverse of coming down. You still need to organize the config in some manner, and having it in the same form that the API wants is a plus. But since the input of the up direction is a subset of the output from the down direction, it was natural to do the down direction first. Plus, it let me get a handle on how much stuff we were working with.\nFinally, this tool should work for every GCP project that uses Stackdriver, not just ours, so a self-bootstrapping capability is a big plus.", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r426789123", "createdAt": "2020-05-18T17:35:55Z", "author": {"login": "jaycarlton"}, "path": "ops/ruby/devops-toolkit/README.md", "diffHunk": "@@ -70,6 +70,14 @@ bundle install\n ## Tasks\n A variety of tasks (sub-commands) are available via the required `-t` option. Here  are their\n brief descriptions:\n+- `backup-config`: Generate JSON or YAML files for each Stackdriver asset (other GCP assets TBD),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MTE0OA=="}, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk1MDA2NQ==", "bodyText": "Sorry, has the overall strategy you're describing already been discussed and agreed upon? Or are we having this discussion now from first principles? If this PR is aligned with what you and @gjuggler have already discussed, I won't block this. @gjuggler you can approve now if this is the case.\nI don't think the code is the source of truth in the model you're describing. It's derived/pulled from the live config defined in the UI. If we're treating the UI as source of truth, I'd prefer not to check these configs into git as they must lag behind the UI by definition and are likely to go out of sync. If we want to drive all of the monitoring configs using a config-as-code approach, I think the way I'd expect this to work would be:\n\nprefer to isolate any \"fiddling\" to explicit personal/sandbox/experimental dashboards or to freeform query editors\nUse a query editor to build dashboards / alert policies\nWhen you're done, pull the JSON/yaml representation of this out, and convert it into a templated form as a PR, such that they are appropriately parameterized for all relevant environments\nRight before merging the PR, push the canonical configs to all environments\nYou should expect any changes you make to the production configs outside of git (via the UI) may be blown away on the next monitoring config push\n\nIf we're using the UI as the source of truth, and periodically archiving our configs outside of source control, that sounds fine if that's the pragmatic way forward.", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r426950065", "createdAt": "2020-05-18T23:41:43Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/README.md", "diffHunk": "@@ -70,6 +70,14 @@ bundle install\n ## Tasks\n A variety of tasks (sub-commands) are available via the required `-t` option. Here  are their\n brief descriptions:\n+- `backup-config`: Generate JSON or YAML files for each Stackdriver asset (other GCP assets TBD),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MTE0OA=="}, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2916, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}