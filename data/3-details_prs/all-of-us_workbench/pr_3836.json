{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4ODg5NTg2", "number": 3836, "title": "[RW-4595][risk=no] Add attributes to sidebar", "bodyText": "Opens the sidebar to the attributes form when any criteria that require attributes are selected.\nPhysical Measurements:\n\nLabs and Measurements:\n\nSurveys:\n\n\nPR checklist\n\n This PR meets the Acceptance Criteria in the JIRA story\n The JIRA story has been moved to Dev Review\n I have run and tested this change locally\n If this includes a UI change, I have taken screen recordings or screenshots of the new behavior and notified the PO and UX designer", "createdAt": "2020-07-30T05:45:28Z", "url": "https://github.com/all-of-us/workbench/pull/3836", "merged": true, "mergeCommit": {"oid": "1c9c2674cd35a5402a999df4bc6f3f7f3538e1a4"}, "closed": true, "closedAt": "2020-08-07T05:07:43Z", "author": {"login": "dolbeew"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc55SMzAFqTQ1ODA4OTQ2NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc8c3XKgH2gAyNDU4ODg5NTg2OmMzZmVjMWUzMmM5NDU2NmUwZGFiODIwMjZmYWI4NjI3NmRjYmFkYWM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MDg5NDY1", "url": "https://github.com/all-of-us/workbench/pull/3836#pullrequestreview-458089465", "createdAt": "2020-07-30T05:54:39Z", "commit": {"oid": "7bb4a2ee9e488c8551354fb4b3f81c0edf84295f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNTo1NDo0MFrOG5UHRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNjowMToxNFrOG5UPGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc1MTU1Ng==", "bodyText": "Changed to check with exists() instead of length. For some reason, length was returning as 2 after I moved the icon into the array, possibly a side effect of having the data-test-id directly on the FontAwesomeIcon component?", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r462751556", "createdAt": "2020-07-30T05:54:40Z", "author": {"login": "dolbeew"}, "path": "ui/src/app/components/help-sidebar.spec.tsx", "diffHunk": "@@ -78,18 +83,18 @@ describe('HelpSidebar', () => {\n     wrapper.find({'data-test-id': 'Share-menu-item'}).first().simulate('click');\n     expect(shareSpy).toHaveBeenCalled();\n   });\n-  it('should hide workspace icon if on critera search page', async () => {\n+  it('should hide workspace icon if on critera search page', async() => {\n     const wrapper = component();\n     currentCohortCriteriaStore.next([]);\n     await waitOneTickAndUpdate(wrapper);\n-    expect(wrapper.find({'data-test-id': 'workspace-menu-button'}).length).toBe(0);\n-    expect(wrapper.find({'data-test-id': 'criteria-icon'}).length).toBe(1);\n+    expect(wrapper.find({'data-test-id': 'workspace-menu-button'}).exists()).toBe(false);\n+    expect(wrapper.find({'data-test-id': 'help-sidebar-icon-0'}).exists()).toBe(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb4a2ee9e488c8551354fb4b3f81c0edf84295f"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc1MzU2MQ==", "bodyText": "This probably has some overlap with #3822. I included it here to test the transition between the selection list and attributes form", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r462753561", "createdAt": "2020-07-30T06:01:14Z", "author": {"login": "dolbeew"}, "path": "ui/src/app/components/help-sidebar.tsx", "diffHunk": "@@ -528,14 +574,20 @@ export const HelpSidebar = fp.flow(withCurrentWorkspace(), withUserProfile(), wi\n             <div style={contentStyle('annotations')}>\n               {participant && <SidebarContent />}\n             </div>\n-            <div style={styles.footer}>\n+            <div style={contentStyle('criteria')}>\n+              {!!attributesSelection\n+                ? <AttributesPageV2 close={() => attributesSelectionStore.next(undefined)} node={attributesSelection}/>\n+                : <SelectionList back={() => {}} selections={[]}/>\n+              }\n+            </div>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb4a2ee9e488c8551354fb4b3f81c0edf84295f"}, "originalPosition": 192}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9096fb65eedf70e682bd7c57340f1edf44db2539", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/9096fb65eedf70e682bd7c57340f1edf44db2539", "committedDate": "2020-07-30T06:03:52Z", "message": "RW-4595 linting"}, "afterCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/e597892259182af04699d6dcc7249138ec0faff4", "committedDate": "2020-08-04T14:51:28Z", "message": "RW-4595 adjustments after rebase"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxODcyMjA3", "url": "https://github.com/all-of-us/workbench/pull/3836#pullrequestreview-461872207", "createdAt": "2020-08-05T17:22:35Z", "commit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzoyMjozNVrOG8TWvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzoyMjozNVrOG8TWvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4NDg2Mw==", "bodyText": "Where is this flag used?", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465884863", "createdAt": "2020-08-05T17:22:35Z", "author": {"login": "NehaBroad"}, "path": "api/config/config_local.json", "diffHunk": "@@ -104,7 +104,7 @@\n     \"enableEventDateModifier\": false,\n     \"useNewShibbolethService\": true,\n     \"enableResearchPurposePrompt\": true,\n-    \"enableCohortBuilderV2\": false\n+    \"enableCohortBuilderV2\": true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxODc4MDQz", "url": "https://github.com/all-of-us/workbench/pull/3836#pullrequestreview-461878043", "createdAt": "2020-08-05T17:30:33Z", "commit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzozMDozM1rOG8Tokw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzozMDozM1rOG8Tokw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4OTQyNw==", "bodyText": "Optional: We can make setAttributes an optional Prop property in tree.component and not pass anything here (not even () => {}, that will make it easier for us to clean later as well :)", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465889427", "createdAt": "2020-08-05T17:30:33Z", "author": {"login": "NehaBroad"}, "path": "ui/src/app/cohort-search/cohort-search/cohort-search.component.tsx", "diffHunk": "@@ -376,26 +366,15 @@ export class CohortSearch extends React.Component<Props, State> {\n                       select={this.addSelection}\n                       selectedIds={selectedIds}\n                       selectOption={this.setAutocompleteSelection}\n-                      setAttributes={this.setAttributes}\n+                      setAttributes={() => {}} // setAttributes no longer needed in V2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxODgzMzEx", "url": "https://github.com/all-of-us/workbench/pull/3836#pullrequestreview-461883311", "createdAt": "2020-08-05T17:38:02Z", "commit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzozODowM1rOG8T41g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzozODowM1rOG8T41g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5MzU5MA==", "bodyText": "nit: space", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465893590", "createdAt": "2020-08-05T17:38:03Z", "author": {"login": "NehaBroad"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,610 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '8px',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const{form} = this.state;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 200}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxODgzODE3", "url": "https://github.com/all-of-us/workbench/pull/3836#pullrequestreview-461883817", "createdAt": "2020-08-05T17:38:49Z", "commit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzozODo0OVrOG8T6ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzozODo0OVrOG8T6ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5Mzk4OQ==", "bodyText": "interesting whats the + for?", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465893989", "createdAt": "2020-08-05T17:38:49Z", "author": {"login": "NehaBroad"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,610 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '8px',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const{form} = this.state;\n+      if (this.hasRange) {\n+        this.getAttributes();\n+      } else {\n+        form.num = subtype === CriteriaSubType[CriteriaSubType.BP]\n+          ? JSON.parse(JSON.stringify(PREDEFINED_ATTRIBUTES.BP_DETAIL))\n+          : [{name: subtype, operator: 'ANY', operands: []}];\n+        this.setState({form, count: this.nodeCount, loading: false});\n+      }\n+    }\n+\n+    getAttributes() {\n+      const {node: {conceptId}} = this.props;\n+      const{form} = this.state;\n+      const {cdrVersionId} = currentWorkspaceStore.getValue();\n+      cohortBuilderApi().findCriteriaAttributeByConceptId(+cdrVersionId, conceptId).then(resp => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 215}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxODg3ODUx", "url": "https://github.com/all-of-us/workbench/pull/3836#pullrequestreview-461887851", "createdAt": "2020-08-05T17:44:31Z", "commit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzo0NDozMVrOG8UG9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzo0NDozMVrOG8UG9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5NzIwNA==", "bodyText": "can we use isPhysicalMeasurement here", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465897204", "createdAt": "2020-08-05T17:44:31Z", "author": {"login": "NehaBroad"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,610 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '8px',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const{form} = this.state;\n+      if (this.hasRange) {\n+        this.getAttributes();\n+      } else {\n+        form.num = subtype === CriteriaSubType[CriteriaSubType.BP]\n+          ? JSON.parse(JSON.stringify(PREDEFINED_ATTRIBUTES.BP_DETAIL))\n+          : [{name: subtype, operator: 'ANY', operands: []}];\n+        this.setState({form, count: this.nodeCount, loading: false});\n+      }\n+    }\n+\n+    getAttributes() {\n+      const {node: {conceptId}} = this.props;\n+      const{form} = this.state;\n+      const {cdrVersionId} = currentWorkspaceStore.getValue();\n+      cohortBuilderApi().findCriteriaAttributeByConceptId(+cdrVersionId, conceptId).then(resp => {\n+        resp.items.forEach(attr => {\n+          if (attr.type === AttrName[AttrName.NUM]) {\n+            // NUM attributes set the min and max range for the number inputs in the attributes form\n+            if (!form.num.length) {\n+              form.num.push({\n+                name: AttrName.NUM,\n+                operator: this.isSurvey ? 'ANY' : null,\n+                operands: [],\n+                conceptId: conceptId,\n+                [attr.conceptName]: parseInt(attr.estCount, 10)\n+              });\n+            } else {\n+              form.num[0][attr.conceptName] = parseInt(attr.estCount, 10);\n+            }\n+          } else {\n+            // CAT attributes are displayed as checkboxes in the attributes form\n+            if (parseInt(attr.estCount, 10) > 0) {\n+              attr['checked'] = false;\n+              form.cat.push(attr);\n+            }\n+          }\n+        });\n+        const count = this.isSurvey ? this.nodeCount : null;\n+        this.setState({count, form, loading: false});\n+      });\n+    }\n+\n+    toggleCheckbox(checked: boolean) {\n+      const {form} = this.state;\n+      let {node: {count}} = this.props;\n+      if (checked) {\n+        form.exists = true;\n+        form.num = form.num.map(attr =>\n+          ({...attr, operator: this.isPhysicalMeasurement ? 'ANY' : null, operands: []}));\n+        form.cat = form.cat.map(attr => ({...attr, checked: false}));\n+      } else {\n+        count = null;\n+        form.exists = false;\n+      }\n+      this.setState({form, count});\n+    }\n+\n+    selectChange(attributeIndex: number, value: string) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operator = value;\n+      if (this.isBloodPressure) {\n+        // for blood pressure, either both operators have to be 'ANY' OR neither can be 'ANY'\n+        const otherAttribute = attributeIndex === 0 ? 1 : 0;\n+        if (value === 'ANY') {\n+          form.num[otherAttribute].operator = 'ANY';\n+          form.num[otherAttribute].operands = form.num[attributeIndex].operands = [];\n+        } else if (form.num[otherAttribute].operator === 'ANY') {\n+          form.num[otherAttribute].operator = value;\n+        }\n+      } else if (value === 'ANY') {\n+        form.num[attributeIndex].operands = [];\n+      }\n+      if (value !== Operator[Operator.BETWEEN]) {\n+        // delete second operand if it exists\n+        form.num[attributeIndex].operands.splice(1);\n+      }\n+      const count = value === 'ANY' ? this.nodeCount : null;\n+      this.setState({form, count});\n+    }\n+\n+    inputChange(input: string, attributeIndex: number, operandIndex: number) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operands[operandIndex] = sanitizeNumericalInput(input);\n+      this.setState({form, count: null});\n+    }\n+\n+    checkboxChange(checked: boolean, index: number) {\n+      const {form} = this.state;\n+      form.cat[index].checked = checked;\n+      this.setState({form});\n+    }\n+\n+    validateForm() {\n+      const {form} = this.state;\n+      let formErrors = new Set(), formValid = true, operatorSelected = true;\n+      if (form.exists) {\n+        return {formValid, formErrors};\n+      }\n+      formErrors = form.num.reduce((acc, attr) => {\n+        const {MIN, MAX, operator} = attr;\n+        const operands = attr.operands.map(op => parseInt(op, 10));\n+        switch (operator) {\n+          case null:\n+            operatorSelected = false;\n+            return acc;\n+          case 'ANY':\n+            return acc;\n+          case Operator.BETWEEN:\n+            if (operands.length < 2) {\n+              formValid = false;\n+            }\n+            break;\n+          default:\n+            if (operands.length === 0) {\n+              formValid = false;\n+            }\n+        }\n+        if (operands.includes(NaN)) {\n+          formValid = false;\n+          acc.add('Form can only accept valid numbers');\n+        }\n+        if (this.isPhysicalMeasurement && operands.some(op => op < 0)) {\n+          formValid = false;\n+          acc.add('Form cannot accept negative values');\n+        }\n+        if (this.hasRange && operands.some(op => op < MIN || op > MAX)) {\n+          formValid = false;\n+          acc.add(`Values must be between ${MIN.toLocaleString()} and ${MAX.toLocaleString()}`);\n+        }\n+        return acc;\n+      }, formErrors);\n+      // The second condition sets formValid to false if this is a Measurements attribute with no operator selected from the dropdown and\n+      // no categorical checkboxes checked\n+      formValid = formValid && !(this.isMeasurement && !operatorSelected && !form.cat.some(attr => attr.checked));\n+      return {formErrors, formValid};\n+    }\n+\n+    get nodeCount() {\n+      const {node: {count, parentId}} = this.props;\n+      if (this.isSurvey) {\n+        const parent = ppiQuestions.getValue()[parentId];\n+        return !!parent ? parent.count : null;\n+      } else {\n+        return count;\n+      }\n+    }\n+\n+    get paramId() {\n+      const {node: {conceptId, id}} = this.props;\n+      const {form} = this.state;\n+      const code = form.exists ? 'Any' : form.num.reduce((acc, attr) => {\n+        if (attr.operator) {\n+          acc += optionUtil[attr.operator].code;\n+        }\n+        return acc;\n+      }, '');\n+      return `param${(conceptId || id) + code}`;\n+    }\n+\n+    get displayName() {\n+      const {node: {name}} = this.props;\n+      return stripHtml(name);\n+    }\n+\n+    get paramWithAttributes() {\n+      const {node, node: {name, subtype}} = this.props;\n+      const {form} = this.state;\n+      let paramName;\n+      const attrs = [];\n+      if (form.exists) {\n+        paramName = name + ` (${optionUtil.ANY.display})`;\n+      } else {\n+        form.num.filter(at => at.operator).forEach(({operator, operands, conceptId}) => {\n+          const attr = {name: AttrName.NUM, operator, operands};\n+          if (subtype === CriteriaSubType.BP) {\n+            attr['conceptId'] = conceptId;\n+          }\n+          if (attr.operator === 'ANY' && subtype === CriteriaSubType.BP) {\n+            attr.name = AttrName.ANY;\n+            attr.operands = [];\n+            delete attr.operator;\n+            attrs.push(attr);\n+          } else if (attr.operator !== 'ANY') {\n+            attrs.push(attr);\n+          }\n+        });\n+        if (form.cat.some(at => at.checked)) {\n+          const catOperands = form.cat.reduce((checked, current) => {\n+            if (current.checked) {\n+              checked.push(current.valueAsConceptId.toString());\n+            }\n+            return checked;\n+          }, []);\n+          attrs.push({name: AttrName.CAT, operator: Operator.IN, operands: catOperands});\n+        }\n+        paramName = this.paramName;\n+      }\n+      return {...node, parameterId: this.paramId, name: paramName, attributes: attrs};\n+    }\n+\n+    get paramName() {\n+      const {node} = this.props;\n+      const {form} = this.state;\n+      const selectionDisplay = [];\n+      let name = '';\n+      form.num.filter(at => at.operator).forEach((attr, i) => {\n+        if (attr.operator === 'ANY') {\n+          if (i === 0) {\n+            name += optionUtil.ANY.display;\n+          }\n+        } else {\n+          if (i > 0) {\n+            name += ' / ';\n+          }\n+          if (node.subtype === CriteriaSubType.BP) {\n+            name += attr.name + ' ';\n+          }\n+          name += optionUtil[attr.operator].display + attr.operands.map(op => parseInt(op, 10).toLocaleString()).join('-');\n+        }\n+      });\n+      if (name !== '') {\n+        selectionDisplay.push(name);\n+      }\n+      form.cat.filter(ca => ca.checked).forEach(attr => selectionDisplay.push(attr.conceptName));\n+      const nodeName = this.isSurvey ? ppiQuestions.getValue()[node.parentId].name : node.name;\n+      return nodeName + ' (' + selectionDisplay.join(', ') +\n+        (this.isPhysicalMeasurement && form.num[0].operator !== AttrName.ANY ? PM_UNITS[node.subtype] : '') + ')';\n+    }\n+\n+    requestPreview() {\n+      this.setState({count: null, calculating: true, countError: false});\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Calculate');\n+      }\n+      const cdrVersionId = +(currentWorkspaceStore.getValue().cdrVersionId);\n+      const request = {\n+        excludes: [],\n+        includes: [{\n+          items: [{\n+            type: param.domainId,\n+            searchParameters: [mapParameter(param)],\n+            modifiers: []\n+          }],\n+          temporal: false\n+        }],\n+        dataFilters: []\n+      };\n+      cohortBuilderApi().countParticipants(cdrVersionId, request).then(response => {\n+        this.setState({count: response, calculating: false});\n+      }, () => {\n+        this.setState({calculating: false, countError: true});\n+      });\n+    }\n+\n+    addParameterToSearchItem() {\n+      const {close} = this.props;\n+      let {criteria} = this.props;\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Add');\n+      }\n+      criteria = criteria.filter(crit => crit.parameterId !== param.parameterId);\n+      currentCohortCriteriaStore.next([...criteria, param]);\n+      close();\n+    }\n+\n+    trackEvent(subtype: string, eventType: string) {\n+      triggerEvent(\n+        'Cohort Builder Search',\n+        'Click',\n+        `Physical Measurements - ${subTypeToTitle(subtype)} - ${eventType}`\n+      );\n+    }\n+\n+    get hasUnits() {\n+      const {node: {subtype}} = this.props;\n+      return typeof PM_UNITS[subtype] !== 'undefined';\n+    }\n+\n+    get isMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.MEASUREMENT;\n+    }\n+\n+    get isPhysicalMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.PHYSICALMEASUREMENT;\n+    }\n+\n+    get isSurvey() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.SURVEY;\n+    }\n+\n+    get isBloodPressure() {\n+      const {node: {subtype}} = this.props;\n+      return subtype === CriteriaSubType.BP;\n+    }\n+\n+    get hasRange() {\n+      return this.isMeasurement || this.isSurvey;\n+    }\n+\n+    render() {\n+      const {close, node: {domainId, name, parentId, subtype}} = this.props;\n+      const {calculating, count, countError, form, loading, options} = this.state;\n+      const {formErrors, formValid} = this.validateForm();\n+      const disableAdd = calculating || !formValid;\n+      const disableCalculate = disableAdd || form.exists || form.num.every(attr => attr.operator === 'ANY');\n+      return (loading ?\n+        <SpinnerOverlay/> :\n+        <div style={{marginTop: '0.5rem'}}>\n+          <h3 style={{fontWeight: 600, margin: '0 0 0.5rem', textTransform: 'capitalize'}}>\n+            {domainId === DomainType.PHYSICALMEASUREMENT.toString() ? name : domainId.toString().toLowerCase()} Detail", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 517}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxODg4NzQw", "url": "https://github.com/all-of-us/workbench/pull/3836#pullrequestreview-461888740", "createdAt": "2020-08-05T17:45:48Z", "commit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzo0NTo0OFrOG8UJ3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzo0NTo0OFrOG8UJ3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5Nzk0OA==", "bodyText": "Question: Can we use validate in this form?", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465897948", "createdAt": "2020-08-05T17:45:48Z", "author": {"login": "NehaBroad"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,610 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '8px',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const{form} = this.state;\n+      if (this.hasRange) {\n+        this.getAttributes();\n+      } else {\n+        form.num = subtype === CriteriaSubType[CriteriaSubType.BP]\n+          ? JSON.parse(JSON.stringify(PREDEFINED_ATTRIBUTES.BP_DETAIL))\n+          : [{name: subtype, operator: 'ANY', operands: []}];\n+        this.setState({form, count: this.nodeCount, loading: false});\n+      }\n+    }\n+\n+    getAttributes() {\n+      const {node: {conceptId}} = this.props;\n+      const{form} = this.state;\n+      const {cdrVersionId} = currentWorkspaceStore.getValue();\n+      cohortBuilderApi().findCriteriaAttributeByConceptId(+cdrVersionId, conceptId).then(resp => {\n+        resp.items.forEach(attr => {\n+          if (attr.type === AttrName[AttrName.NUM]) {\n+            // NUM attributes set the min and max range for the number inputs in the attributes form\n+            if (!form.num.length) {\n+              form.num.push({\n+                name: AttrName.NUM,\n+                operator: this.isSurvey ? 'ANY' : null,\n+                operands: [],\n+                conceptId: conceptId,\n+                [attr.conceptName]: parseInt(attr.estCount, 10)\n+              });\n+            } else {\n+              form.num[0][attr.conceptName] = parseInt(attr.estCount, 10);\n+            }\n+          } else {\n+            // CAT attributes are displayed as checkboxes in the attributes form\n+            if (parseInt(attr.estCount, 10) > 0) {\n+              attr['checked'] = false;\n+              form.cat.push(attr);\n+            }\n+          }\n+        });\n+        const count = this.isSurvey ? this.nodeCount : null;\n+        this.setState({count, form, loading: false});\n+      });\n+    }\n+\n+    toggleCheckbox(checked: boolean) {\n+      const {form} = this.state;\n+      let {node: {count}} = this.props;\n+      if (checked) {\n+        form.exists = true;\n+        form.num = form.num.map(attr =>\n+          ({...attr, operator: this.isPhysicalMeasurement ? 'ANY' : null, operands: []}));\n+        form.cat = form.cat.map(attr => ({...attr, checked: false}));\n+      } else {\n+        count = null;\n+        form.exists = false;\n+      }\n+      this.setState({form, count});\n+    }\n+\n+    selectChange(attributeIndex: number, value: string) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operator = value;\n+      if (this.isBloodPressure) {\n+        // for blood pressure, either both operators have to be 'ANY' OR neither can be 'ANY'\n+        const otherAttribute = attributeIndex === 0 ? 1 : 0;\n+        if (value === 'ANY') {\n+          form.num[otherAttribute].operator = 'ANY';\n+          form.num[otherAttribute].operands = form.num[attributeIndex].operands = [];\n+        } else if (form.num[otherAttribute].operator === 'ANY') {\n+          form.num[otherAttribute].operator = value;\n+        }\n+      } else if (value === 'ANY') {\n+        form.num[attributeIndex].operands = [];\n+      }\n+      if (value !== Operator[Operator.BETWEEN]) {\n+        // delete second operand if it exists\n+        form.num[attributeIndex].operands.splice(1);\n+      }\n+      const count = value === 'ANY' ? this.nodeCount : null;\n+      this.setState({form, count});\n+    }\n+\n+    inputChange(input: string, attributeIndex: number, operandIndex: number) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operands[operandIndex] = sanitizeNumericalInput(input);\n+      this.setState({form, count: null});\n+    }\n+\n+    checkboxChange(checked: boolean, index: number) {\n+      const {form} = this.state;\n+      form.cat[index].checked = checked;\n+      this.setState({form});\n+    }\n+\n+    validateForm() {\n+      const {form} = this.state;\n+      let formErrors = new Set(), formValid = true, operatorSelected = true;\n+      if (form.exists) {\n+        return {formValid, formErrors};\n+      }\n+      formErrors = form.num.reduce((acc, attr) => {\n+        const {MIN, MAX, operator} = attr;\n+        const operands = attr.operands.map(op => parseInt(op, 10));\n+        switch (operator) {\n+          case null:\n+            operatorSelected = false;\n+            return acc;\n+          case 'ANY':\n+            return acc;\n+          case Operator.BETWEEN:\n+            if (operands.length < 2) {\n+              formValid = false;\n+            }\n+            break;\n+          default:\n+            if (operands.length === 0) {\n+              formValid = false;\n+            }\n+        }\n+        if (operands.includes(NaN)) {\n+          formValid = false;\n+          acc.add('Form can only accept valid numbers');\n+        }\n+        if (this.isPhysicalMeasurement && operands.some(op => op < 0)) {\n+          formValid = false;\n+          acc.add('Form cannot accept negative values');\n+        }\n+        if (this.hasRange && operands.some(op => op < MIN || op > MAX)) {\n+          formValid = false;\n+          acc.add(`Values must be between ${MIN.toLocaleString()} and ${MAX.toLocaleString()}`);\n+        }\n+        return acc;\n+      }, formErrors);\n+      // The second condition sets formValid to false if this is a Measurements attribute with no operator selected from the dropdown and\n+      // no categorical checkboxes checked\n+      formValid = formValid && !(this.isMeasurement && !operatorSelected && !form.cat.some(attr => attr.checked));\n+      return {formErrors, formValid};\n+    }\n+\n+    get nodeCount() {\n+      const {node: {count, parentId}} = this.props;\n+      if (this.isSurvey) {\n+        const parent = ppiQuestions.getValue()[parentId];\n+        return !!parent ? parent.count : null;\n+      } else {\n+        return count;\n+      }\n+    }\n+\n+    get paramId() {\n+      const {node: {conceptId, id}} = this.props;\n+      const {form} = this.state;\n+      const code = form.exists ? 'Any' : form.num.reduce((acc, attr) => {\n+        if (attr.operator) {\n+          acc += optionUtil[attr.operator].code;\n+        }\n+        return acc;\n+      }, '');\n+      return `param${(conceptId || id) + code}`;\n+    }\n+\n+    get displayName() {\n+      const {node: {name}} = this.props;\n+      return stripHtml(name);\n+    }\n+\n+    get paramWithAttributes() {\n+      const {node, node: {name, subtype}} = this.props;\n+      const {form} = this.state;\n+      let paramName;\n+      const attrs = [];\n+      if (form.exists) {\n+        paramName = name + ` (${optionUtil.ANY.display})`;\n+      } else {\n+        form.num.filter(at => at.operator).forEach(({operator, operands, conceptId}) => {\n+          const attr = {name: AttrName.NUM, operator, operands};\n+          if (subtype === CriteriaSubType.BP) {\n+            attr['conceptId'] = conceptId;\n+          }\n+          if (attr.operator === 'ANY' && subtype === CriteriaSubType.BP) {\n+            attr.name = AttrName.ANY;\n+            attr.operands = [];\n+            delete attr.operator;\n+            attrs.push(attr);\n+          } else if (attr.operator !== 'ANY') {\n+            attrs.push(attr);\n+          }\n+        });\n+        if (form.cat.some(at => at.checked)) {\n+          const catOperands = form.cat.reduce((checked, current) => {\n+            if (current.checked) {\n+              checked.push(current.valueAsConceptId.toString());\n+            }\n+            return checked;\n+          }, []);\n+          attrs.push({name: AttrName.CAT, operator: Operator.IN, operands: catOperands});\n+        }\n+        paramName = this.paramName;\n+      }\n+      return {...node, parameterId: this.paramId, name: paramName, attributes: attrs};\n+    }\n+\n+    get paramName() {\n+      const {node} = this.props;\n+      const {form} = this.state;\n+      const selectionDisplay = [];\n+      let name = '';\n+      form.num.filter(at => at.operator).forEach((attr, i) => {\n+        if (attr.operator === 'ANY') {\n+          if (i === 0) {\n+            name += optionUtil.ANY.display;\n+          }\n+        } else {\n+          if (i > 0) {\n+            name += ' / ';\n+          }\n+          if (node.subtype === CriteriaSubType.BP) {\n+            name += attr.name + ' ';\n+          }\n+          name += optionUtil[attr.operator].display + attr.operands.map(op => parseInt(op, 10).toLocaleString()).join('-');\n+        }\n+      });\n+      if (name !== '') {\n+        selectionDisplay.push(name);\n+      }\n+      form.cat.filter(ca => ca.checked).forEach(attr => selectionDisplay.push(attr.conceptName));\n+      const nodeName = this.isSurvey ? ppiQuestions.getValue()[node.parentId].name : node.name;\n+      return nodeName + ' (' + selectionDisplay.join(', ') +\n+        (this.isPhysicalMeasurement && form.num[0].operator !== AttrName.ANY ? PM_UNITS[node.subtype] : '') + ')';\n+    }\n+\n+    requestPreview() {\n+      this.setState({count: null, calculating: true, countError: false});\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Calculate');\n+      }\n+      const cdrVersionId = +(currentWorkspaceStore.getValue().cdrVersionId);\n+      const request = {\n+        excludes: [],\n+        includes: [{\n+          items: [{\n+            type: param.domainId,\n+            searchParameters: [mapParameter(param)],\n+            modifiers: []\n+          }],\n+          temporal: false\n+        }],\n+        dataFilters: []\n+      };\n+      cohortBuilderApi().countParticipants(cdrVersionId, request).then(response => {\n+        this.setState({count: response, calculating: false});\n+      }, () => {\n+        this.setState({calculating: false, countError: true});\n+      });\n+    }\n+\n+    addParameterToSearchItem() {\n+      const {close} = this.props;\n+      let {criteria} = this.props;\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Add');\n+      }\n+      criteria = criteria.filter(crit => crit.parameterId !== param.parameterId);\n+      currentCohortCriteriaStore.next([...criteria, param]);\n+      close();\n+    }\n+\n+    trackEvent(subtype: string, eventType: string) {\n+      triggerEvent(\n+        'Cohort Builder Search',\n+        'Click',\n+        `Physical Measurements - ${subTypeToTitle(subtype)} - ${eventType}`\n+      );\n+    }\n+\n+    get hasUnits() {\n+      const {node: {subtype}} = this.props;\n+      return typeof PM_UNITS[subtype] !== 'undefined';\n+    }\n+\n+    get isMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.MEASUREMENT;\n+    }\n+\n+    get isPhysicalMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.PHYSICALMEASUREMENT;\n+    }\n+\n+    get isSurvey() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.SURVEY;\n+    }\n+\n+    get isBloodPressure() {\n+      const {node: {subtype}} = this.props;\n+      return subtype === CriteriaSubType.BP;\n+    }\n+\n+    get hasRange() {\n+      return this.isMeasurement || this.isSurvey;\n+    }\n+\n+    render() {\n+      const {close, node: {domainId, name, parentId, subtype}} = this.props;\n+      const {calculating, count, countError, form, loading, options} = this.state;\n+      const {formErrors, formValid} = this.validateForm();\n+      const disableAdd = calculating || !formValid;\n+      const disableCalculate = disableAdd || form.exists || form.num.every(attr => attr.operator === 'ANY');\n+      return (loading ?\n+        <SpinnerOverlay/> :\n+        <div style={{marginTop: '0.5rem'}}>\n+          <h3 style={{fontWeight: 600, margin: '0 0 0.5rem', textTransform: 'capitalize'}}>\n+            {domainId === DomainType.PHYSICALMEASUREMENT.toString() ? name : domainId.toString().toLowerCase()} Detail\n+          </h3>\n+          {countError && <div style={styles.error}>\n+            <ClrIcon style={{margin: '0 0.5rem 0 0.25rem'}} className='is-solid'\n+              shape='exclamation-triangle' size='22'/>\n+            Sorry, the request cannot be completed.\n+          </div>}\n+          {!!formErrors.size && <div style={styles.errors}>\n+            {Array.from(formErrors).map((err, e) => <div key={e} style={styles.errorItem}>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 525}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzY1OTIz", "url": "https://github.com/all-of-us/workbench/pull/3836#pullrequestreview-462765923", "createdAt": "2020-08-06T18:16:55Z", "commit": {"oid": "bd98b4518f573de4ec67ff69c0cef7c9bfbe6652"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODoxNjo1NVrOG8-_JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODoxNjo1NVrOG8-_JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5OTcxNw==", "bodyText": "Optional: Curious if we can use loadash here like:\neg. var object = { 'a': [{ 'b': { 'c': 3 } }] };\n_.set(object, 'a[0].b.c', 4);", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r466599717", "createdAt": "2020-08-06T18:16:55Z", "author": {"login": "NehaBroad"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,609 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const {form} = this.state;\n+      if (this.hasRange) {\n+        this.getAttributes();\n+      } else {\n+        form.num = subtype === CriteriaSubType[CriteriaSubType.BP]\n+          ? JSON.parse(JSON.stringify(PREDEFINED_ATTRIBUTES.BP_DETAIL))\n+          : [{name: subtype, operator: 'ANY', operands: []}];\n+        this.setState({form, count: this.nodeCount, loading: false});\n+      }\n+    }\n+\n+    getAttributes() {\n+      const {node: {conceptId}} = this.props;\n+      const{form} = this.state;\n+      const {cdrVersionId} = currentWorkspaceStore.getValue();\n+      cohortBuilderApi().findCriteriaAttributeByConceptId(+cdrVersionId, conceptId).then(resp => {\n+        resp.items.forEach(attr => {\n+          if (attr.type === AttrName[AttrName.NUM]) {\n+            // NUM attributes set the min and max range for the number inputs in the attributes form\n+            if (!form.num.length) {\n+              form.num.push({\n+                name: AttrName.NUM,\n+                operator: this.isSurvey ? 'ANY' : null,\n+                operands: [],\n+                conceptId: conceptId,\n+                [attr.conceptName]: parseInt(attr.estCount, 10)\n+              });\n+            } else {\n+              form.num[0][attr.conceptName] = parseInt(attr.estCount, 10);\n+            }\n+          } else {\n+            // CAT attributes are displayed as checkboxes in the attributes form\n+            if (parseInt(attr.estCount, 10) > 0) {\n+              attr['checked'] = false;\n+              form.cat.push(attr);\n+            }\n+          }\n+        });\n+        const count = this.isSurvey ? this.nodeCount : null;\n+        this.setState({count, form, loading: false});\n+      });\n+    }\n+\n+    toggleCheckbox(checked: boolean) {\n+      const {form} = this.state;\n+      let {node: {count}} = this.props;\n+      if (checked) {\n+        form.exists = true;\n+        form.num = form.num.map(attr =>\n+          ({...attr, operator: this.isPhysicalMeasurement ? 'ANY' : null, operands: []}));\n+        form.cat = form.cat.map(attr => ({...attr, checked: false}));\n+      } else {\n+        count = null;\n+        form.exists = false;\n+      }\n+      this.setState({form, count});\n+    }\n+\n+    selectChange(attributeIndex: number, value: string) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operator = value;\n+      if (this.isBloodPressure) {\n+        // for blood pressure, either both operators have to be 'ANY' OR neither can be 'ANY'\n+        const otherAttribute = attributeIndex === 0 ? 1 : 0;\n+        if (value === 'ANY') {\n+          form.num[otherAttribute].operator = 'ANY';\n+          form.num[otherAttribute].operands = form.num[attributeIndex].operands = [];\n+        } else if (form.num[otherAttribute].operator === 'ANY') {\n+          form.num[otherAttribute].operator = value;\n+        }\n+      } else if (value === 'ANY') {\n+        form.num[attributeIndex].operands = [];\n+      }\n+      if (value !== Operator[Operator.BETWEEN]) {\n+        // delete second operand if it exists\n+        form.num[attributeIndex].operands.splice(1);\n+      }\n+      const count = value === 'ANY' ? this.nodeCount : null;\n+      this.setState({form, count});\n+    }\n+\n+    inputChange(input: string, attributeIndex: number, operandIndex: number) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operands[operandIndex] = sanitizeNumericalInput(input);\n+      this.setState({form, count: null});\n+    }\n+\n+    checkboxChange(checked: boolean, index: number) {\n+      const {form} = this.state;\n+      form.cat[index].checked = checked;\n+      this.setState({form});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd98b4518f573de4ec67ff69c0cef7c9bfbe6652"}, "originalPosition": 289}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzY2OTc1", "url": "https://github.com/all-of-us/workbench/pull/3836#pullrequestreview-462766975", "createdAt": "2020-08-06T18:18:32Z", "commit": {"oid": "bd98b4518f573de4ec67ff69c0cef7c9bfbe6652"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "783ad36a13b72adc26a5fa4ddcfc5d425d2cbc11", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/783ad36a13b72adc26a5fa4ddcfc5d425d2cbc11", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 duplicate AttributesPage component"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df600303849d226ca385409b42fdb88480061511", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/df600303849d226ca385409b42fdb88480061511", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 create store for attributes selections"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6a339ab8f98d01280853982784dcbe471f8f867", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/e6a339ab8f98d01280853982784dcbe471f8f867", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 styles for attributes sidebar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "167deee1442caabd329f4c3ee5531e2527ebb8d3", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/167deee1442caabd329f4c3ee5531e2527ebb8d3", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 more styles and layout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b963bf2c0b228eca90ce61e55ac61d169209f82c", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/b963bf2c0b228eca90ce61e55ac61d169209f82c", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 handle changing attribute nodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c03a8e1200b35183dba38257348cbc5a92378af", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/8c03a8e1200b35183dba38257348cbc5a92378af", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 add close and back icons"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "954f94aa1651e6706db991a4989603ec3bf712f7", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/954f94aa1651e6706db991a4989603ec3bf712f7", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 add attributes v2 to hierarchy view"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a21835b473d2d5b59058d34da3ecd83a6a19fd3", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/2a21835b473d2d5b59058d34da3ecd83a6a19fd3", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 linting, cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aec68d836f8c31cebdf8d9053d961381670e12a0", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/aec68d836f8c31cebdf8d9053d961381670e12a0", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 fix ui tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3f93b67cbe5c28d62b06b5290fbe6198b34007c", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/c3f93b67cbe5c28d62b06b5290fbe6198b34007c", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 linting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "359a53a9e5e252ae415c28207ee58eef93fe5d7a", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/359a53a9e5e252ae415c28207ee58eef93fe5d7a", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 adjustments after rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de05f994e069f2ebc567265b88d1e8b8b87bea9d", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/de05f994e069f2ebc567265b88d1e8b8b87bea9d", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 pr feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56456d7b6adb8fe6d3a5cadd5f8c55c79650df9b", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/56456d7b6adb8fe6d3a5cadd5f8c55c79650df9b", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 adjust error styles"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bd98b4518f573de4ec67ff69c0cef7c9bfbe6652", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/bd98b4518f573de4ec67ff69c0cef7c9bfbe6652", "committedDate": "2020-08-06T16:50:50Z", "message": "RW-4595 adjust error styles"}, "afterCommit": {"oid": "56456d7b6adb8fe6d3a5cadd5f8c55c79650df9b", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/56456d7b6adb8fe6d3a5cadd5f8c55c79650df9b", "committedDate": "2020-08-06T22:04:43Z", "message": "RW-4595 adjust error styles"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3fec1e32c94566e0dab82026fab86276dcbadac", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/c3fec1e32c94566e0dab82026fab86276dcbadac", "committedDate": "2020-08-07T04:39:21Z", "message": "RW-4595 disable local feature flag"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4515, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}