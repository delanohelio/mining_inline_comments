{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3MzQ0Mjg4", "number": 3248, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMzozMDoyMFrODo9WEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMzozNjozOFrODo9Zjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Mjc0NzA3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/elasticsearch/AggregationUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMzozMDoyMFrOF31O2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNDo1OTozNFrOF4JAkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA4ODE1Mw==", "bodyText": "nit: fix newline", "url": "https://github.com/all-of-us/workbench/pull/3248#discussion_r394088153", "createdAt": "2020-03-18T03:30:20Z", "author": {"login": "calbach"}, "path": "api/src/main/java/org/pmiops/workbench/elasticsearch/AggregationUtils.java", "diffHunk": "@@ -10,50 +10,64 @@\n import org.elasticsearch.search.aggregations.bucket.range.ParsedDateRange;\n import org.elasticsearch.search.aggregations.bucket.range.Range;\n import org.elasticsearch.search.aggregations.bucket.terms.Terms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.pmiops.workbench.model.AgeType;\n import org.pmiops.workbench.model.DemoChartInfo;\n+import org.pmiops.workbench.model.GenderOrSexType;\n \n public class AggregationUtils {\n \n   public static final String RANGE_18_44 = \"18-44\";\n   public static final String RANGE_45_64 = \"45-64\";\n   public static final String RANGE_GT_65 = \"65\";\n   public static final String DATE = \"d_\";\n-  public static final String GENDER = \"g_\";\n+  public static final String GENDER_OR_SEX = \"g_or_s_\";\n   public static final String RACE = \"r_\";\n \n   /**\n    * Build aggregations for demographic charting based on date range, gender and race. The bucket\n    * aggregations compute and return the number of documents that \"fell into\" each bucket.\n    */\n-  public static AggregationBuilder buildDemoChartAggregation(String ageRange) {\n+  public static AggregationBuilder buildDemoChartAggregation(\n+      GenderOrSexType genderOrSexType, AgeType ageType, String ageRange) {\n     String[] ages = ageRange.split(\"-\");\n-    LocalDate start = null;\n-    // use the low end of the age range to calculate the end of the date range\n-    LocalDate end = ElasticUtils.todayMinusYears(Integer.parseInt(ages[0]));\n-    if (ages.length > 1) {\n-      // use high end of the age range to calculate the start of the date range\n-      // need to add 1 year to adjust the start date to beginning of age range\n-      start = ElasticUtils.todayMinusYears(Integer.parseInt(ages[1]) + 1);\n-    }\n+    // use Integer values of age ranges when calculating age at consent or age at cdr\n+    Integer lo = Integer.valueOf(ages[0]);\n+    Integer hi = (ages.length > 1) ? Integer.valueOf(ages[1]) : null;\n+\n+    // use high endDate of the age range to calculate the startDate of the date range\n+    // need to add 1 year to adjust the startDate date to beginning of age range\n+    LocalDate startDate = (hi != null) ? ElasticUtils.todayMinusYears(hi + 1) : null;\n+    // use the low endDate of the age range to calculate the endDate of the date range\n+    // when calculating age from date of birth\n+    LocalDate endDate = ElasticUtils.todayMinusYears(lo);\n \n-    // Added order to gender and race buckets. Therefore the UI code can expect consistent results\n-    // between BQ(sql ordered by gender, race, age) and elastic\n-    return AggregationBuilders.dateRange(DATE + ageRange)\n-        .field(\"birth_datetime\")\n-        .format(\"yyyy-MM-dd\")\n-        .addRange((start == null) ? null : start.toString(), end.toString())\n-        .subAggregation(\n-            AggregationBuilders.terms(GENDER + ageRange)\n-                .field(\"gender_concept_name\")\n-                .order(BucketOrder.key(true))\n-                .subAggregation(\n-                    AggregationBuilders.terms(RACE + ageRange)\n-                        .field(\"race_concept_name\")\n-                        .order(BucketOrder.key(true))\n-                        // This eliminates the race buckets with 0 counts. Without this param\n-                        // elastic\n-                        // returns all race buckets regardless of count.\n-                        .minDocCount(1)));\n+    boolean isGender = GenderOrSexType.GENDER.equals(genderOrSexType);\n+    boolean isAgeAtConsent = AgeType.AGE_AT_CONSENT.equals(ageType);\n+    // Added order to gender/sex and race buckets. Therefore the UI code can expect consistent\n+    // results\n+    // between BQ(sql ordered by gender/sex, race, age) and elastic", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b076ec4849272d4e1979211d6a2edbdad843dfd4"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQxMjE3Nw==", "bodyText": "Done.", "url": "https://github.com/all-of-us/workbench/pull/3248#discussion_r394412177", "createdAt": "2020-03-18T14:59:34Z", "author": {"login": "freemabd"}, "path": "api/src/main/java/org/pmiops/workbench/elasticsearch/AggregationUtils.java", "diffHunk": "@@ -10,50 +10,64 @@\n import org.elasticsearch.search.aggregations.bucket.range.ParsedDateRange;\n import org.elasticsearch.search.aggregations.bucket.range.Range;\n import org.elasticsearch.search.aggregations.bucket.terms.Terms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.pmiops.workbench.model.AgeType;\n import org.pmiops.workbench.model.DemoChartInfo;\n+import org.pmiops.workbench.model.GenderOrSexType;\n \n public class AggregationUtils {\n \n   public static final String RANGE_18_44 = \"18-44\";\n   public static final String RANGE_45_64 = \"45-64\";\n   public static final String RANGE_GT_65 = \"65\";\n   public static final String DATE = \"d_\";\n-  public static final String GENDER = \"g_\";\n+  public static final String GENDER_OR_SEX = \"g_or_s_\";\n   public static final String RACE = \"r_\";\n \n   /**\n    * Build aggregations for demographic charting based on date range, gender and race. The bucket\n    * aggregations compute and return the number of documents that \"fell into\" each bucket.\n    */\n-  public static AggregationBuilder buildDemoChartAggregation(String ageRange) {\n+  public static AggregationBuilder buildDemoChartAggregation(\n+      GenderOrSexType genderOrSexType, AgeType ageType, String ageRange) {\n     String[] ages = ageRange.split(\"-\");\n-    LocalDate start = null;\n-    // use the low end of the age range to calculate the end of the date range\n-    LocalDate end = ElasticUtils.todayMinusYears(Integer.parseInt(ages[0]));\n-    if (ages.length > 1) {\n-      // use high end of the age range to calculate the start of the date range\n-      // need to add 1 year to adjust the start date to beginning of age range\n-      start = ElasticUtils.todayMinusYears(Integer.parseInt(ages[1]) + 1);\n-    }\n+    // use Integer values of age ranges when calculating age at consent or age at cdr\n+    Integer lo = Integer.valueOf(ages[0]);\n+    Integer hi = (ages.length > 1) ? Integer.valueOf(ages[1]) : null;\n+\n+    // use high endDate of the age range to calculate the startDate of the date range\n+    // need to add 1 year to adjust the startDate date to beginning of age range\n+    LocalDate startDate = (hi != null) ? ElasticUtils.todayMinusYears(hi + 1) : null;\n+    // use the low endDate of the age range to calculate the endDate of the date range\n+    // when calculating age from date of birth\n+    LocalDate endDate = ElasticUtils.todayMinusYears(lo);\n \n-    // Added order to gender and race buckets. Therefore the UI code can expect consistent results\n-    // between BQ(sql ordered by gender, race, age) and elastic\n-    return AggregationBuilders.dateRange(DATE + ageRange)\n-        .field(\"birth_datetime\")\n-        .format(\"yyyy-MM-dd\")\n-        .addRange((start == null) ? null : start.toString(), end.toString())\n-        .subAggregation(\n-            AggregationBuilders.terms(GENDER + ageRange)\n-                .field(\"gender_concept_name\")\n-                .order(BucketOrder.key(true))\n-                .subAggregation(\n-                    AggregationBuilders.terms(RACE + ageRange)\n-                        .field(\"race_concept_name\")\n-                        .order(BucketOrder.key(true))\n-                        // This eliminates the race buckets with 0 counts. Without this param\n-                        // elastic\n-                        // returns all race buckets regardless of count.\n-                        .minDocCount(1)));\n+    boolean isGender = GenderOrSexType.GENDER.equals(genderOrSexType);\n+    boolean isAgeAtConsent = AgeType.AGE_AT_CONSENT.equals(ageType);\n+    // Added order to gender/sex and race buckets. Therefore the UI code can expect consistent\n+    // results\n+    // between BQ(sql ordered by gender/sex, race, age) and elastic", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA4ODE1Mw=="}, "originalCommit": {"oid": "b076ec4849272d4e1979211d6a2edbdad843dfd4"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Mjc1MzgwOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/pmiops/workbench/elasticsearch/ElasticFiltersTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMzozNTowNFrOF31TIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNTowMjoxM1rOF4JIeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA4OTI0OQ==", "bodyText": "Hm - did this change? Or was this a bug?", "url": "https://github.com/all-of-us/workbench/pull/3248#discussion_r394089249", "createdAt": "2020-03-18T03:35:04Z", "author": {"login": "calbach"}, "path": "api/src/test/java/org/pmiops/workbench/elasticsearch/ElasticFiltersTest.java", "diffHunk": "@@ -925,18 +927,50 @@ public void testAgeQuery() {\n             new SearchRequest()\n                 .addIncludesItem(\n                     new SearchGroup()\n-                        .addItemsItem(new SearchGroupItem().addSearchParametersItem(ethParam))));\n+                        .addItemsItem(new SearchGroupItem().addSearchParametersItem(ageParam))));\n     BoolQueryBuilder ageBuilder =\n         QueryBuilders.boolQuery()\n             .filter(QueryBuilders.termQuery(\"is_deceased\", false))\n             .filter(\n                 QueryBuilders.rangeQuery(\"birth_datetime\")\n-                    .gt(left)\n+                    .gte(left)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b076ec4849272d4e1979211d6a2edbdad843dfd4"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQxNDIwMg==", "bodyText": "A bug. So participants that have birthdays today wouldn't be included in the left most range.", "url": "https://github.com/all-of-us/workbench/pull/3248#discussion_r394414202", "createdAt": "2020-03-18T15:02:13Z", "author": {"login": "freemabd"}, "path": "api/src/test/java/org/pmiops/workbench/elasticsearch/ElasticFiltersTest.java", "diffHunk": "@@ -925,18 +927,50 @@ public void testAgeQuery() {\n             new SearchRequest()\n                 .addIncludesItem(\n                     new SearchGroup()\n-                        .addItemsItem(new SearchGroupItem().addSearchParametersItem(ethParam))));\n+                        .addItemsItem(new SearchGroupItem().addSearchParametersItem(ageParam))));\n     BoolQueryBuilder ageBuilder =\n         QueryBuilders.boolQuery()\n             .filter(QueryBuilders.termQuery(\"is_deceased\", false))\n             .filter(\n                 QueryBuilders.rangeQuery(\"birth_datetime\")\n-                    .gt(left)\n+                    .gte(left)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA4OTI0OQ=="}, "originalCommit": {"oid": "b076ec4849272d4e1979211d6a2edbdad843dfd4"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Mjc1NTk5OnYy", "diffSide": "RIGHT", "path": "api/tools/src/main/java/org/pmiops/workbench/tools/elastic/ElasticSearchIndexer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMzozNjozOFrOF31UgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNTowMjozNVrOF4JJpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA4OTYwMQ==", "bodyText": "Owch. Will check for an update on synthetic data this week. We need to be able to rerun the latest curation pipeline at a bare minimum even if we can't easily make data improvements yet.", "url": "https://github.com/all-of-us/workbench/pull/3248#discussion_r394089601", "createdAt": "2020-03-18T03:36:38Z", "author": {"login": "calbach"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/elastic/ElasticSearchIndexer.java", "diffHunk": "@@ -306,9 +306,11 @@ private void createIndex(CommandLine opts) throws IOException, InterruptedExcept\n   }\n \n   private String getPersonBigQuerySQL(String bqDataset, int inverseProb) throws IOException {\n+    // Synth dataset doesn't contain sex_at_birth, so we use gender as a fix", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b076ec4849272d4e1979211d6a2edbdad843dfd4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQxNDUwMQ==", "bodyText": "Agreed.", "url": "https://github.com/all-of-us/workbench/pull/3248#discussion_r394414501", "createdAt": "2020-03-18T15:02:35Z", "author": {"login": "freemabd"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/elastic/ElasticSearchIndexer.java", "diffHunk": "@@ -306,9 +306,11 @@ private void createIndex(CommandLine opts) throws IOException, InterruptedExcept\n   }\n \n   private String getPersonBigQuerySQL(String bqDataset, int inverseProb) throws IOException {\n+    // Synth dataset doesn't contain sex_at_birth, so we use gender as a fix", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA4OTYwMQ=="}, "originalCommit": {"oid": "b076ec4849272d4e1979211d6a2edbdad843dfd4"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3229, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}