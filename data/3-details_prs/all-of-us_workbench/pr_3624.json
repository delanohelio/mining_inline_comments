{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1MTk1NzM3", "number": 3624, "title": "[RW-4921][RISK=NO] User Audit Log API", "bodyText": "Follow-up to workspace adit log endpoint.\nAdd an endpoint for the audit history for a given user, both as an agent or a target (e.g. for COLLABORATE_TO events).\nRename the authority from WORKSPACES_VIEW to RESEARCHER_DATA_VIEW so we can use it more broadly (and avoid using ACCESS_ADMIN for read-only user admin endpoints).\nIntroduce a bundled, object-oriented format corresponding more closely to the object structure actually audited. That is, it coalesces rows with the same Action ID, and bundles those by Agent/Target/ActionType tuples.\nThe structure for an individual action looks like\n{\n      \"actionId\": \"c5d24027-7e9a-469c-9622-ab37dc33bbd1\",\n      \"actionTime\": null,\n      \"eventBundles\": [\n        {\n          \"header\": {\n            \"actionType\": \"CREATE\",\n            \"agent\": {\n              \"agentId\": 1,\n              \"agentType\": \"USER\",\n              \"agentUsername\": \"joel@fake-research-aou.org\"\n            },\n            \"target\": {\n              \"targetId\": 2,\n              \"targetType\": \"WORKSPACE\"\n            }\n          },\n          \"propertyChanges\": [\n            {\n              \"targetProperty\": \"population_details\",\n              \"previousValue\": null,\n              \"newValue\": \"\"\n            },\n            {\n              \"targetProperty\": \"cdr_version_id\",\n              \"previousValue\": null,\n              \"newValue\": \"2\"\n            },\n            {\n              \"targetProperty\": \"commercial_purpose\",\n              \"previousValue\": null,\n              \"newValue\": \"false\"\n            }\n     }\n}\n\n\nPR checklist\n\n This PR meets the Acceptance Criteria in the JIRA story\n The JIRA story has been moved to Dev Review\n This PR includes appropriate unit tests\n I have run and tested this change locally\n I have run the E2E tests on ths change against my local UI + API server with yarn test-local\n If this includes a UI change, I have taken screen recordings or screenshots of the new behavior and notified the PO and UX designer\n If this includes an API change, I have updated the appropriate Swagger definitions and notified API consumers\n If this includes a new feature flag, I have created and linked new JIRA tickets to (a) turn on the feature flag and (b) remove it later", "createdAt": "2020-05-29T16:14:08Z", "url": "https://github.com/all-of-us/workbench/pull/3624", "merged": true, "mergeCommit": {"oid": "a067b5160de37983b1f5e10fd44e0c1a92a3d920"}, "closed": true, "closedAt": "2020-06-03T21:00:17Z", "author": {"login": "jaycarlton"}, "timelineItems": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjKR2pgH2gAyNDI1MTk1NzM3Ojk0N2I3OTQyNjdlOWFlZTUzNGYyNmVhZDQ1ZWFlYTc2MDFhZDdhZDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnvhJGAH2gAyNDI1MTk1NzM3Ojg5Yjc1Y2U2ZjBmMjU2MjBlZDM3Y2JiYTZjYzZhNDQwZmUzYWMyNjY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "947b794267e9aee534f26ead45eaea7601ad7ad4", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/947b794267e9aee534f26ead45eaea7601ad7ad4", "committedDate": "2020-05-20T14:51:59Z", "message": "most of the types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a7dc3fc5696f77e27af01eb5b887a02c8fc7c40", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/7a7dc3fc5696f77e27af01eb5b887a02c8fc7c40", "committedDate": "2020-05-20T17:22:05Z", "message": "first cut at querying"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "283383d854b2a1def54a53ae54688b4bdf22e3bb", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/283383d854b2a1def54a53ae54688b4bdf22e3bb", "committedDate": "2020-05-20T17:22:47Z", "message": "spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7da66e72450e2bb08554323593a4275498f58ccc", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/7da66e72450e2bb08554323593a4275498f58ccc", "committedDate": "2020-05-20T22:28:31Z", "message": "first working version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09ab27c9e19d1635d4324f5d5442077b869ba7b8", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/09ab27c9e19d1635d4324f5d5442077b869ba7b8", "committedDate": "2020-05-21T12:43:33Z", "message": "comment out"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8055fa186cfd307f91a95c3f7c5c601cd4ceb364", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/8055fa186cfd307f91a95c3f7c5c601cd4ceb364", "committedDate": "2020-05-21T12:46:32Z", "message": "fix path [skip ci]"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d71b7d0503470fedbbf794a40581942885f5fcb", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/9d71b7d0503470fedbbf794a40581942885f5fcb", "committedDate": "2020-05-21T15:52:15Z", "message": "start on unit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17a9c1f948e7d47b841dc00906a8d3c84f274b52", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/17a9c1f948e7d47b841dc00906a8d3c84f274b52", "committedDate": "2020-05-21T20:59:39Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "991ad868ce4f8c686718fd48e0cd3266af0435d3", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/991ad868ce4f8c686718fd48e0cd3266af0435d3", "committedDate": "2020-05-21T21:40:38Z", "message": "fix datetime comparison"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "244bf8a82376359e2e7c3a68afc03518f88f6aee", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/244bf8a82376359e2e7c3a68afc03518f88f6aee", "committedDate": "2020-05-21T22:32:05Z", "message": "no result test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dc97b1d64eb8aef54f926f245debfb2973efc27", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/2dc97b1d64eb8aef54f926f245debfb2973efc27", "committedDate": "2020-05-26T13:59:45Z", "message": "add more methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e30da7e8e7c53a1c2f1726ec18099067823bf0cf", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/e30da7e8e7c53a1c2f1726ec18099067823bf0cf", "committedDate": "2020-05-26T14:12:58Z", "message": "update description"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1b76260834a181721fc33a502d12c49219d7837", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/c1b76260834a181721fc33a502d12c49219d7837", "committedDate": "2020-05-26T17:50:25Z", "message": "test improvements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "179ae60005e7b90d3912ffb88838e0e8bed3538b", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/179ae60005e7b90d3912ffb88838e0e8bed3538b", "committedDate": "2020-05-26T19:32:27Z", "message": "make more readable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76857e11f40671678ead337e36b71453c3b75f11", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/76857e11f40671678ead337e36b71453c3b75f11", "committedDate": "2020-05-26T19:49:40Z", "message": "docs and tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1612bd29ab7ecfe4b4190cecc78f27ccb54009b", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/b1612bd29ab7ecfe4b4190cecc78f27ccb54009b", "committedDate": "2020-05-27T18:46:08Z", "message": "Merge branch 'master' into jaycarlton/RW-4921"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c3e6993620f3d334569219163acfa7032985478", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/9c3e6993620f3d334569219163acfa7032985478", "committedDate": "2020-05-27T21:17:52Z", "message": "comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "991043e62ce222bd3ebd5cd70d94a1ed96f16070", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/991043e62ce222bd3ebd5cd70d94a1ed96f16070", "committedDate": "2020-05-28T14:56:14Z", "message": "most of the recommendations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1188d90284767cfe44d339a0d06318cf9f9b346", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/b1188d90284767cfe44d339a0d06318cf9f9b346", "committedDate": "2020-05-28T16:08:02Z", "message": "fixup formats"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "085d5d1db8e450d189679e3f881af832a28d2516", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/085d5d1db8e450d189679e3f881af832a28d2516", "committedDate": "2020-05-28T17:22:23Z", "message": "spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35691b7d37692adc2e95d2cea33c305b92f57f9f", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/35691b7d37692adc2e95d2cea33c305b92f57f9f", "committedDate": "2020-05-28T20:49:59Z", "message": "Merge branch 'master' into jaycarlton/RW-4921"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44aa886bb5d801d873bafc98ba430e27e448ddc8", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/44aa886bb5d801d873bafc98ba430e27e448ddc8", "committedDate": "2020-05-28T21:27:01Z", "message": "make room for new new api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b39cefc0742832e243489257d358096759d79e1", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/8b39cefc0742832e243489257d358096759d79e1", "committedDate": "2020-05-28T21:35:28Z", "message": "test stuff [skip ci]"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f89a5097043108758b6aa9f0828ed2a8ac673793", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/f89a5097043108758b6aa9f0828ed2a8ac673793", "committedDate": "2020-05-29T15:55:50Z", "message": "mapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a1f37fddc29c63285484663a5415a5b24792dc7", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/8a1f37fddc29c63285484663a5415a5b24792dc7", "committedDate": "2020-05-29T18:02:57Z", "message": "[skip ci]"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50d0a537e381fa752fc22292e827c0a2652d5835", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/50d0a537e381fa752fc22292e827c0a2652d5835", "committedDate": "2020-05-29T19:29:44Z", "message": "audit helper snippet"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e874228818ded9b5a4ef66e5024b60f3a4b41365", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/e874228818ded9b5a4ef66e5024b60f3a4b41365", "committedDate": "2020-06-01T18:09:07Z", "message": "rename WORKSPACES_VIEW and remove ordinals"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6c53e2921865aac0198727df221c63a07fa3760", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/f6c53e2921865aac0198727df221c63a07fa3760", "committedDate": "2020-06-01T18:40:41Z", "message": "use first part of email address only"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bd9c6f19a3aba1dad5bc50995e96d94d7596d84", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/0bd9c6f19a3aba1dad5bc50995e96d94d7596d84", "committedDate": "2020-06-01T19:32:10Z", "message": "fix capitalization and rename. don't create empty property change objects"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aefa74c949b05cd09e9e2f8fa4b1c45e27a33cfc", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/aefa74c949b05cd09e9e2f8fa4b1c45e27a33cfc", "committedDate": "2020-06-01T21:00:26Z", "message": "test for mapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa3e83aa31bdcace7c6956ccad986cae63fc85e4", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/fa3e83aa31bdcace7c6956ccad986cae63fc85e4", "committedDate": "2020-06-02T14:08:32Z", "message": "Merge branch 'master' into jaycarlton/userQueryApi"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c5df815d9f02d5a654a8c9c13cea16190537c50", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/1c5df815d9f02d5a654a8c9c13cea16190537c50", "committedDate": "2020-06-02T17:40:02Z", "message": "spotless & test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "committedDate": "2020-06-02T17:50:23Z", "message": "remove bash snippet"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83168668b74f5f4717f5830bc39e0b4ed00c5e8e", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/83168668b74f5f4717f5830bc39e0b4ed00c5e8e", "committedDate": "2020-06-02T18:00:34Z", "message": "description updates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDkzODM4", "url": "https://github.com/all-of-us/workbench/pull/3624#pullrequestreview-423093838", "createdAt": "2020-06-02T22:13:46Z", "commit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "state": "APPROVED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMjoxMzo0N1rOGeFvTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDoxOTowOFrOGeIFgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNDQ5NQ==", "bodyText": "typo: adit", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434204495", "createdAt": "2020-06-02T22:13:47Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapper.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.TableResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.Streams;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.elasticsearch.common.Strings;\n+import org.mapstruct.Mapper;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTarget;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.pmiops.workbench.utils.FieldValues;\n+\n+@Mapper(config = MapStructConfig.class)\n+public interface AuditLogEntryMapper {\n+  AuditAgent logEntryToAgent(AuditLogEntry auditLogEntry);\n+\n+  default AuditEventBundleHeader logEntryToEventBundleHeader(AuditLogEntry auditLogEntry) {\n+    return new AuditEventBundleHeader()\n+        .target(logEntryToTarget(auditLogEntry))\n+        .agent(logEntryToAgent(auditLogEntry))\n+        .actionType(auditLogEntry.getActionType());\n+  }\n+\n+  AuditTarget logEntryToTarget(AuditLogEntry auditLogEntry);\n+\n+  /**\n+   * Build an AuditTargetPropertyChange object from the relevant fields in the AuditLogEntry, unless\n+   * all of those are null, in which case return an empty optional\n+   *\n+   * @param auditLogEntry\n+   * @return\n+   */\n+  default Optional<AuditTargetPropertyChange> logEntryToTargetPropertyChange(\n+      AuditLogEntry auditLogEntry) {\n+    if ((Strings.isNullOrEmpty(auditLogEntry.getTargetProperty())\n+            && Strings.isNullOrEmpty(auditLogEntry.getPreviousValue()))\n+        && Strings.isNullOrEmpty(auditLogEntry.getNewValue())) {\n+      return Optional.empty();\n+    } else {\n+      return Optional.of(\n+          new AuditTargetPropertyChange()\n+              .targetProperty(auditLogEntry.getTargetProperty())\n+              .previousValue(auditLogEntry.getPreviousValue())\n+              .newValue(auditLogEntry.getNewValue()));\n+    }\n+  }\n+\n+  default List<AuditAction> logEntriesToActions(List<AuditLogEntry> logEntries) {\n+    final Multimap<String, AuditLogEntry> actionIdToRows =\n+        Multimaps.index(logEntries, AuditLogEntry::getActionId);\n+    return actionIdToRows.asMap().values().stream()\n+        .map(this::buildAuditAction)\n+        .collect(ImmutableList.toImmutableList());\n+  }\n+\n+  /**\n+   * @param logEntries Collection of AuditLogEntry objectsthat have a common Action ID, which should\n+   *     be the same event time, given the unofficial but surprisingly harshly enforced non-schema\n+   *     schama.\n+   */\n+  default AuditAction buildAuditAction(Collection<AuditLogEntry> logEntries) {\n+    final AuditLogEntry firstEntry =\n+        logEntries.stream()\n+            .findFirst()\n+            .orElseThrow(\n+                () -> new IllegalArgumentException(\"logEntries collection must not be empty\"));\n+\n+    final AuditAction result =\n+        new AuditAction().actionId(firstEntry.getActionId()).actionTime(firstEntry.getEventTime());\n+\n+    final Multimap<AuditEventBundleHeader, AuditLogEntry> headerToLogEntries =\n+        Multimaps.index(logEntries, this::logEntryToEventBundleHeader);\n+    final List<AuditEventBundle> eventBundles =\n+        headerToLogEntries.asMap().entrySet().stream()\n+            .map(e -> buildEventBundle(e.getKey(), e.getValue()))\n+            .collect(Collectors.toList());\n+\n+    return result.eventBundles(eventBundles);\n+  }\n+\n+  default AuditEventBundle buildEventBundle(\n+      AuditEventBundleHeader header, Collection<AuditLogEntry> logEntries) {\n+    return new AuditEventBundle()\n+        .header(header)\n+        .propertyChanges(\n+            logEntries.stream()\n+                .map(this::logEntryToTargetPropertyChange)\n+                .flatMap(Streams::stream)\n+                .collect(Collectors.toList()));\n+  }\n+\n+  default AuditLogEntry fieldValueListToAditLogEntry(FieldValueList row) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNTI3NQ==", "bodyText": "there's a lot of duplication between the two queryStrings.  What can we reuse?", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434205275", "createdAt": "2020-06-02T22:15:52Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditQueryServiceImpl.java", "diffHunk": "@@ -1,137 +1,153 @@\n package org.pmiops.workbench.actionaudit;\n \n-import com.google.cloud.bigquery.FieldValueList;\n import com.google.cloud.bigquery.QueryJobConfiguration;\n import com.google.cloud.bigquery.QueryParameterValue;\n import com.google.cloud.bigquery.StandardSQLTypeName;\n import com.google.cloud.bigquery.TableResult;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.stream.StreamSupport;\n import javax.inject.Provider;\n import org.joda.time.DateTime;\n import org.pmiops.workbench.api.BigQueryService;\n import org.pmiops.workbench.config.WorkbenchConfig;\n import org.pmiops.workbench.config.WorkbenchConfig.ActionAuditConfig;\n import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.UserAuditLogQueryResponse;\n import org.pmiops.workbench.model.WorkspaceAuditLogQueryResponse;\n-import org.pmiops.workbench.utils.FieldValues;\n+import org.pmiops.workbench.utils.mappers.AuditLogEntryMapper;\n import org.springframework.stereotype.Service;\n \n @Service\n public class ActionAuditQueryServiceImpl implements ActionAuditQueryService {\n \n   private static final int MICROSECONDS_IN_MILLISECOND = 1000;\n+  private static final long MAX_QUERY_LIMIT = 1000L;\n \n-  enum Parameters {\n-    LIMIT(\"limit\"),\n-    WORKSPACE_DB_ID(\"workspace_db_id\"),\n-    AFTER_INCLUSIVE(\"after_inclusive\"),\n-    BEFORE_EXCLUSIVE(\"before_exclusive\");\n-\n-    private String name;\n-\n-    Parameters(String name) {\n-      this.name = name;\n-    }\n-\n-    public String getName() {\n-      return name;\n-    }\n-  }\n-\n+  private final AuditLogEntryMapper auditLogEntryMapper;\n   private final BigQueryService bigQueryService;\n   private final Provider<WorkbenchConfig> workbenchConfigProvider;\n \n-  private static final long MAX_QUERY_LIMIT = 1000L;\n-  // The table name can't be in a QueryParameterValue, so we substitute it with String.format()\n-  private static final String WORKSPACE_EVENTS_QUERY_STRING_FORMAT =\n-      \"SELECT\\n\"\n-          + \"  TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) as event_time,\\n\"\n-          + \"  jsonPayload.agent_type AS agent_type,\\n\"\n-          + \"  CAST(jsonPayload.agent_id AS INT64) AS agent_id,\\n\"\n-          + \"  jsonPayload.agent_email AS agent_username,\\n\"\n-          + \"  jsonPayload.action_id AS action_id,\\n\"\n-          + \"  jsonPayload.action_type AS action_type,\\n\"\n-          + \"  jsonPayload.target_type AS target_type,\\n\"\n-          + \"  CAST(jsonPayload.target_id AS INT64) AS target_id,\\n\"\n-          + \"  jsonPayload.target_property AS target_property,\\n\"\n-          + \"  jsonPayload.prev_value AS prev_value,\\n\"\n-          + \"  jsonPayload.new_value AS new_value\\n\"\n-          + \"FROM %s\\n\"\n-          + \"WHERE jsonPayload.target_id = @workspace_db_id AND\\n\"\n-          + \"  jsonPayload.target_type = 'WORKSPACE' AND\\n\"\n-          + \"  @after_inclusive <= TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) AND\\n\"\n-          + \"  TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) < @before_exclusive\\n\"\n-          + \"ORDER BY event_time, agent_id, action_id\\n\"\n-          + \"LIMIT @limit\";\n-\n   public ActionAuditQueryServiceImpl(\n-      BigQueryService bigQueryService, Provider<WorkbenchConfig> workbenchConfigProvider) {\n+      AuditLogEntryMapper auditLogEntryMapper,\n+      BigQueryService bigQueryService,\n+      Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.auditLogEntryMapper = auditLogEntryMapper;\n     this.bigQueryService = bigQueryService;\n     this.workbenchConfigProvider = workbenchConfigProvider;\n   }\n \n   @Override\n   public WorkspaceAuditLogQueryResponse queryEventsForWorkspace(\n-      long workspaceDatabaseId, long limit, DateTime afterInclusive, DateTime beforeExclusive) {\n-    final ActionAuditConfig actionAuditConfig = workbenchConfigProvider.get().actionAudit;\n-    final String fullyQualifiedTableName =\n-        String.format(\n-            \"`%s.%s.%s`\",\n-            workbenchConfigProvider.get().server.projectId,\n-            actionAuditConfig.bigQueryDataset,\n-            actionAuditConfig.bigQueryTable);\n+      long workspaceDatabaseId, long limit, DateTime after, DateTime before) {\n \n     final String queryString =\n-        String.format(WORKSPACE_EVENTS_QUERY_STRING_FORMAT, fullyQualifiedTableName);\n+        String.format(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNTg2Mg==", "bodyText": "is this the only one that was added?  looks like it", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434205862", "createdAt": "2020-06-02T22:17:26Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/api/ProfileController.java", "diffHunk": "@@ -187,60 +190,63 @@ public DbDemographicSurvey apply(DemographicSurvey demographicSurvey) {\n \n   private static final long MAX_BILLING_PROJECT_CREATION_ATTEMPTS = 5;\n \n+  private final ActionAuditQueryService actionAuditQueryService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNjEwNA==", "bodyText": "any idea what this comment meant?", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434206104", "createdAt": "2020-06-02T22:18:08Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/api/ProfileController.java", "diffHunk": "@@ -871,10 +877,33 @@ private void updateBypass(long userId, AccessBypassRequest request) {\n     log.log(Level.WARNING, \"Deleting profile: user email: \" + user.getUsername());\n     directoryService.deleteUser(user.getUsername().split(\"@\")[0]);\n     userDao.delete(user.getUserId());\n-    profileAuditor.fireDeleteAction(\n-        user.getUserId(),\n-        user.getUsername()); // not sure if user profider will survive the next line", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNzQ4Ng==", "bodyText": "The fully constructed username would be better here", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434207486", "createdAt": "2020-06-02T22:22:04Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/api/ProfileController.java", "diffHunk": "@@ -871,10 +877,33 @@ private void updateBypass(long userId, AccessBypassRequest request) {\n     log.log(Level.WARNING, \"Deleting profile: user email: \" + user.getUsername());\n     directoryService.deleteUser(user.getUsername().split(\"@\")[0]);\n     userDao.delete(user.getUserId());\n-    profileAuditor.fireDeleteAction(\n-        user.getUserId(),\n-        user.getUsername()); // not sure if user profider will survive the next line\n+    profileAuditor.fireDeleteAction(user.getUserId(), user.getUsername());\n \n     return ResponseEntity.status(HttpStatus.NO_CONTENT).build();\n   }\n+\n+  @Override\n+  public ResponseEntity<UserAuditLogQueryResponse> getAuditLogEntries(\n+      String usernameWithoutGsuiteDomain,\n+      Integer limit,\n+      Long afterMillis,\n+      Long beforeMillisNullable) {\n+    final String username =\n+        String.format(\n+            \"%s@%s\",\n+            usernameWithoutGsuiteDomain,\n+            workbenchConfigProvider.get().googleDirectoryService.gSuiteDomain);\n+    final long userDatabaseId =\n+        Optional.ofNullable(userDao.findUserByUsername(username))\n+            .map(DbUser::getUserId)\n+            .orElseThrow(\n+                () ->\n+                    new NotFoundException(\n+                        String.format(\"User %s not found\", usernameWithoutGsuiteDomain)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwODYzMA==", "bodyText": "update the comments in workbench-api.yaml to match the new name", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434208630", "createdAt": "2020-06-02T22:25:18Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/workspaceadmin/WorkspaceAdminController.java", "diffHunk": "@@ -70,7 +70,7 @@ public WorkspaceAdminController(\n   }\n \n   @Override\n-  @AuthorityRequired({Authority.WORKSPACES_VIEW})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwOTEwMQ==", "bodyText": "Please check our constellation of googledocs for references to this value.", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434209101", "createdAt": "2020-06-02T22:26:33Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbStorageEnums.java", "diffHunk": "@@ -97,7 +97,7 @@ public static Short archivalStatusToStorage(ArchivalStatus s) {\n           .put(Authority.COMMUNICATIONS_ADMIN, (short) 4)\n           .put(Authority.SECURITY_ADMIN, (short) 5)\n           .put(Authority.INSTITUTION_ADMIN, (short) 6)\n-          .put(Authority.WORKSPACES_VIEW, (short) 7)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyODc2Nw==", "bodyText": "what if these objects don't have a common ID or don't have a common event time?\nIt seems that this is an important assumption/requirement for your use case, so maybe it should be enforced along with the non-empty condition.", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434228767", "createdAt": "2020-06-02T23:27:25Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapper.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.TableResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.Streams;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.elasticsearch.common.Strings;\n+import org.mapstruct.Mapper;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTarget;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.pmiops.workbench.utils.FieldValues;\n+\n+@Mapper(config = MapStructConfig.class)\n+public interface AuditLogEntryMapper {\n+  AuditAgent logEntryToAgent(AuditLogEntry auditLogEntry);\n+\n+  default AuditEventBundleHeader logEntryToEventBundleHeader(AuditLogEntry auditLogEntry) {\n+    return new AuditEventBundleHeader()\n+        .target(logEntryToTarget(auditLogEntry))\n+        .agent(logEntryToAgent(auditLogEntry))\n+        .actionType(auditLogEntry.getActionType());\n+  }\n+\n+  AuditTarget logEntryToTarget(AuditLogEntry auditLogEntry);\n+\n+  /**\n+   * Build an AuditTargetPropertyChange object from the relevant fields in the AuditLogEntry, unless\n+   * all of those are null, in which case return an empty optional\n+   *\n+   * @param auditLogEntry\n+   * @return\n+   */\n+  default Optional<AuditTargetPropertyChange> logEntryToTargetPropertyChange(\n+      AuditLogEntry auditLogEntry) {\n+    if ((Strings.isNullOrEmpty(auditLogEntry.getTargetProperty())\n+            && Strings.isNullOrEmpty(auditLogEntry.getPreviousValue()))\n+        && Strings.isNullOrEmpty(auditLogEntry.getNewValue())) {\n+      return Optional.empty();\n+    } else {\n+      return Optional.of(\n+          new AuditTargetPropertyChange()\n+              .targetProperty(auditLogEntry.getTargetProperty())\n+              .previousValue(auditLogEntry.getPreviousValue())\n+              .newValue(auditLogEntry.getNewValue()));\n+    }\n+  }\n+\n+  default List<AuditAction> logEntriesToActions(List<AuditLogEntry> logEntries) {\n+    final Multimap<String, AuditLogEntry> actionIdToRows =\n+        Multimaps.index(logEntries, AuditLogEntry::getActionId);\n+    return actionIdToRows.asMap().values().stream()\n+        .map(this::buildAuditAction)\n+        .collect(ImmutableList.toImmutableList());\n+  }\n+\n+  /**\n+   * @param logEntries Collection of AuditLogEntry objectsthat have a common Action ID, which should", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzODQxMQ==", "bodyText": "oh it's cause you're grouping by action ID.  ok then.", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434238411", "createdAt": "2020-06-03T00:01:58Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapper.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.TableResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.Streams;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.elasticsearch.common.Strings;\n+import org.mapstruct.Mapper;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTarget;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.pmiops.workbench.utils.FieldValues;\n+\n+@Mapper(config = MapStructConfig.class)\n+public interface AuditLogEntryMapper {\n+  AuditAgent logEntryToAgent(AuditLogEntry auditLogEntry);\n+\n+  default AuditEventBundleHeader logEntryToEventBundleHeader(AuditLogEntry auditLogEntry) {\n+    return new AuditEventBundleHeader()\n+        .target(logEntryToTarget(auditLogEntry))\n+        .agent(logEntryToAgent(auditLogEntry))\n+        .actionType(auditLogEntry.getActionType());\n+  }\n+\n+  AuditTarget logEntryToTarget(AuditLogEntry auditLogEntry);\n+\n+  /**\n+   * Build an AuditTargetPropertyChange object from the relevant fields in the AuditLogEntry, unless\n+   * all of those are null, in which case return an empty optional\n+   *\n+   * @param auditLogEntry\n+   * @return\n+   */\n+  default Optional<AuditTargetPropertyChange> logEntryToTargetPropertyChange(\n+      AuditLogEntry auditLogEntry) {\n+    if ((Strings.isNullOrEmpty(auditLogEntry.getTargetProperty())\n+            && Strings.isNullOrEmpty(auditLogEntry.getPreviousValue()))\n+        && Strings.isNullOrEmpty(auditLogEntry.getNewValue())) {\n+      return Optional.empty();\n+    } else {\n+      return Optional.of(\n+          new AuditTargetPropertyChange()\n+              .targetProperty(auditLogEntry.getTargetProperty())\n+              .previousValue(auditLogEntry.getPreviousValue())\n+              .newValue(auditLogEntry.getNewValue()));\n+    }\n+  }\n+\n+  default List<AuditAction> logEntriesToActions(List<AuditLogEntry> logEntries) {\n+    final Multimap<String, AuditLogEntry> actionIdToRows =\n+        Multimaps.index(logEntries, AuditLogEntry::getActionId);\n+    return actionIdToRows.asMap().values().stream()\n+        .map(this::buildAuditAction)\n+        .collect(ImmutableList.toImmutableList());\n+  }\n+\n+  /**\n+   * @param logEntries Collection of AuditLogEntry objectsthat have a common Action ID, which should", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyODc2Nw=="}, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MDM5Ng==", "bodyText": "typo", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434240396", "createdAt": "2020-06-03T00:09:30Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/resources/workbench-api.yaml", "diffHunk": "@@ -7367,6 +7421,35 @@ definitions:\n           ID in the MySQL database and BigQuery Audit Database for the workspace queried.\n         type: integer\n         format: int64\n+  UserAuditLogQueryResponse:\n+    type: object\n+    description: >\n+      Represents the results of a query into the audit dataset in BigQery without", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MDY0Mw==", "bodyText": "typos: multiple and close paren)", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434240643", "createdAt": "2020-06-03T00:10:19Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/resources/workbench-api.yaml", "diffHunk": "@@ -7435,3 +7518,72 @@ definitions:\n           Type of target. Described by the enum TargetType (which is not generated). Left as string\n           since BigQuery doesn't enforce the enum membership.\n         type: string\n+  AuditAction:\n+    type: object\n+    description: >\n+      A user or system action in the audit system. May contain multiple agents, targets, and action\n+      types.\n+    properties:\n+      actionId:\n+        description: Unique ID for this action. Used for grouping similar events under a\n+          single action, though in this representation we're returning a straight list of rows.\n+          This is technically a UUID, but this may change in the future (to a shorter random string),\n+          so we only type it as a String.\n+        type: string\n+      actionTime:\n+        description: Time of the earliest event (row) for this action.\n+        type: string\n+        format: date-time\n+      eventBundles:\n+        type: array\n+        items:\n+          \"$ref\": \"#/definitions/AuditEventBundle\"\n+  AuditEventBundle:\n+    description: >\n+      Composite header for an AuditAction's sub-actions. Useful as a map key, plus it contains\n+      information about the agent, target, and action type (of which there can be multiplpe per", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MTk3NQ==", "bodyText": "can also assert for this", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434241975", "createdAt": "2020-06-03T00:15:15Z", "author": {"login": "jmthibault79"}, "path": "api/src/test/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapperTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.pmiops.workbench.actionaudit.auditors.ActionAuditTestConfig.ACTION_ID;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.util.Optional;\n+import org.joda.time.DateTime;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class AuditLogEntryMapperTest {\n+\n+  public static final long AGENT_ID = 101L;\n+  public static final String USER_AGENT_TYPE = \"USER\";\n+  public static final String AGENT_USERNAME = \"paul@beatles.info\";\n+  public static final long TARGET_ID = 202L;\n+  public static final String ACTION_TYPE_DELETE = \"DELETE\";\n+  public static final String TARGET_TYPE_WORKSPACE = \"WORKSPACE\";\n+  public static final String TARGET_PROPERTY = \"title\";\n+  public static final String PREVIOUS_VALUE = \"District 5\";\n+  public static final String NEW_VALUE = \"The Mighty Ducks\";\n+  public static final String LOGIN_ACTION_TYPE = \"LOGIN\";\n+  public static final DateTime EVENT_TIME = new DateTime(1579013840545L);\n+  public static final String WORKBENCH_TARGET_TYPE = \"WORKBENCH\";\n+  @Autowired private AuditLogEntryMapper auditLogEntryMapper;\n+\n+  @TestConfiguration\n+  @Import({AuditLogEntryMapperImpl.class})\n+  public static class Config {}\n+\n+  @Test\n+  public void testLogEntryToAgent() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .actionType(\"CREATE\")\n+            .agentId(AGENT_ID)\n+            .agentType(USER_AGENT_TYPE)\n+            .agentUsername(AGENT_USERNAME);\n+    final AuditAgent auditAgent = auditLogEntryMapper.logEntryToAgent(logEntry);\n+    assertThat(auditAgent.getAgentId()).isEqualTo(AGENT_ID);\n+    assertThat(auditAgent.getAgentType()).isEqualTo(USER_AGENT_TYPE);\n+    assertThat(auditAgent.getAgentUsername()).isEqualTo(AGENT_USERNAME);\n+  }\n+\n+  @Test\n+  public void testLogEntryToEventBundleHeader() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .agentId(AGENT_ID)\n+            .agentUsername(AGENT_USERNAME)\n+            .agentType(USER_AGENT_TYPE)\n+            .actionType(ACTION_TYPE_DELETE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MjU3Mg==", "bodyText": "could do map(::getPreviousValue).isEmpty() instead", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434242572", "createdAt": "2020-06-03T00:17:31Z", "author": {"login": "jmthibault79"}, "path": "api/src/test/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapperTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.pmiops.workbench.actionaudit.auditors.ActionAuditTestConfig.ACTION_ID;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.util.Optional;\n+import org.joda.time.DateTime;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class AuditLogEntryMapperTest {\n+\n+  public static final long AGENT_ID = 101L;\n+  public static final String USER_AGENT_TYPE = \"USER\";\n+  public static final String AGENT_USERNAME = \"paul@beatles.info\";\n+  public static final long TARGET_ID = 202L;\n+  public static final String ACTION_TYPE_DELETE = \"DELETE\";\n+  public static final String TARGET_TYPE_WORKSPACE = \"WORKSPACE\";\n+  public static final String TARGET_PROPERTY = \"title\";\n+  public static final String PREVIOUS_VALUE = \"District 5\";\n+  public static final String NEW_VALUE = \"The Mighty Ducks\";\n+  public static final String LOGIN_ACTION_TYPE = \"LOGIN\";\n+  public static final DateTime EVENT_TIME = new DateTime(1579013840545L);\n+  public static final String WORKBENCH_TARGET_TYPE = \"WORKBENCH\";\n+  @Autowired private AuditLogEntryMapper auditLogEntryMapper;\n+\n+  @TestConfiguration\n+  @Import({AuditLogEntryMapperImpl.class})\n+  public static class Config {}\n+\n+  @Test\n+  public void testLogEntryToAgent() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .actionType(\"CREATE\")\n+            .agentId(AGENT_ID)\n+            .agentType(USER_AGENT_TYPE)\n+            .agentUsername(AGENT_USERNAME);\n+    final AuditAgent auditAgent = auditLogEntryMapper.logEntryToAgent(logEntry);\n+    assertThat(auditAgent.getAgentId()).isEqualTo(AGENT_ID);\n+    assertThat(auditAgent.getAgentType()).isEqualTo(USER_AGENT_TYPE);\n+    assertThat(auditAgent.getAgentUsername()).isEqualTo(AGENT_USERNAME);\n+  }\n+\n+  @Test\n+  public void testLogEntryToEventBundleHeader() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .agentId(AGENT_ID)\n+            .agentUsername(AGENT_USERNAME)\n+            .agentType(USER_AGENT_TYPE)\n+            .actionType(ACTION_TYPE_DELETE)\n+            .targetId(TARGET_ID)\n+            .targetType(TARGET_TYPE_WORKSPACE);\n+    final AuditEventBundleHeader header = auditLogEntryMapper.logEntryToEventBundleHeader(logEntry);\n+    assertThat(header.getActionType()).isEqualTo(ACTION_TYPE_DELETE);\n+    assertThat(header.getAgent().getAgentUsername()).isEqualTo(AGENT_USERNAME);\n+    assertThat(header.getAgent().getAgentType()).isEqualTo(USER_AGENT_TYPE);\n+    assertThat(header.getAgent().getAgentId()).isEqualTo(AGENT_ID);\n+    assertThat(header.getTarget().getTargetId()).isEqualTo(TARGET_ID);\n+    assertThat(header.getTarget().getTargetType()).isEqualTo(TARGET_TYPE_WORKSPACE);\n+  }\n+\n+  @Test\n+  public void testLogEntryToTargetPropertyChange() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .targetProperty(TARGET_PROPERTY)\n+            .previousValue(PREVIOUS_VALUE)\n+            .newValue(NEW_VALUE);\n+    final Optional<AuditTargetPropertyChange> propertyMaybe =\n+        auditLogEntryMapper.logEntryToTargetPropertyChange(logEntry);\n+    assertThat(propertyMaybe).isPresent();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getTargetProperty))\n+        .hasValue(TARGET_PROPERTY);\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getPreviousValue))\n+        .hasValue(PREVIOUS_VALUE);\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getNewValue)).hasValue(NEW_VALUE);\n+  }\n+\n+  @Test\n+  public void testLogEntryToTargetPropertyChange_createdValue() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry().targetProperty(TARGET_PROPERTY).previousValue(null).newValue(NEW_VALUE);\n+    final Optional<AuditTargetPropertyChange> propertyMaybe =\n+        auditLogEntryMapper.logEntryToTargetPropertyChange(logEntry);\n+    assertThat(propertyMaybe).isPresent();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getTargetProperty))\n+        .hasValue(TARGET_PROPERTY);\n+    assertThat(propertyMaybe.get().getPreviousValue()).isNull();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0Mjk0NA==", "bodyText": "a test with multiple bundles would be good", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434242944", "createdAt": "2020-06-03T00:19:08Z", "author": {"login": "jmthibault79"}, "path": "api/src/test/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapperTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.pmiops.workbench.actionaudit.auditors.ActionAuditTestConfig.ACTION_ID;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.util.Optional;\n+import org.joda.time.DateTime;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class AuditLogEntryMapperTest {\n+\n+  public static final long AGENT_ID = 101L;\n+  public static final String USER_AGENT_TYPE = \"USER\";\n+  public static final String AGENT_USERNAME = \"paul@beatles.info\";\n+  public static final long TARGET_ID = 202L;\n+  public static final String ACTION_TYPE_DELETE = \"DELETE\";\n+  public static final String TARGET_TYPE_WORKSPACE = \"WORKSPACE\";\n+  public static final String TARGET_PROPERTY = \"title\";\n+  public static final String PREVIOUS_VALUE = \"District 5\";\n+  public static final String NEW_VALUE = \"The Mighty Ducks\";\n+  public static final String LOGIN_ACTION_TYPE = \"LOGIN\";\n+  public static final DateTime EVENT_TIME = new DateTime(1579013840545L);\n+  public static final String WORKBENCH_TARGET_TYPE = \"WORKBENCH\";\n+  @Autowired private AuditLogEntryMapper auditLogEntryMapper;\n+\n+  @TestConfiguration\n+  @Import({AuditLogEntryMapperImpl.class})\n+  public static class Config {}\n+\n+  @Test\n+  public void testLogEntryToAgent() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .actionType(\"CREATE\")\n+            .agentId(AGENT_ID)\n+            .agentType(USER_AGENT_TYPE)\n+            .agentUsername(AGENT_USERNAME);\n+    final AuditAgent auditAgent = auditLogEntryMapper.logEntryToAgent(logEntry);\n+    assertThat(auditAgent.getAgentId()).isEqualTo(AGENT_ID);\n+    assertThat(auditAgent.getAgentType()).isEqualTo(USER_AGENT_TYPE);\n+    assertThat(auditAgent.getAgentUsername()).isEqualTo(AGENT_USERNAME);\n+  }\n+\n+  @Test\n+  public void testLogEntryToEventBundleHeader() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .agentId(AGENT_ID)\n+            .agentUsername(AGENT_USERNAME)\n+            .agentType(USER_AGENT_TYPE)\n+            .actionType(ACTION_TYPE_DELETE)\n+            .targetId(TARGET_ID)\n+            .targetType(TARGET_TYPE_WORKSPACE);\n+    final AuditEventBundleHeader header = auditLogEntryMapper.logEntryToEventBundleHeader(logEntry);\n+    assertThat(header.getActionType()).isEqualTo(ACTION_TYPE_DELETE);\n+    assertThat(header.getAgent().getAgentUsername()).isEqualTo(AGENT_USERNAME);\n+    assertThat(header.getAgent().getAgentType()).isEqualTo(USER_AGENT_TYPE);\n+    assertThat(header.getAgent().getAgentId()).isEqualTo(AGENT_ID);\n+    assertThat(header.getTarget().getTargetId()).isEqualTo(TARGET_ID);\n+    assertThat(header.getTarget().getTargetType()).isEqualTo(TARGET_TYPE_WORKSPACE);\n+  }\n+\n+  @Test\n+  public void testLogEntryToTargetPropertyChange() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .targetProperty(TARGET_PROPERTY)\n+            .previousValue(PREVIOUS_VALUE)\n+            .newValue(NEW_VALUE);\n+    final Optional<AuditTargetPropertyChange> propertyMaybe =\n+        auditLogEntryMapper.logEntryToTargetPropertyChange(logEntry);\n+    assertThat(propertyMaybe).isPresent();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getTargetProperty))\n+        .hasValue(TARGET_PROPERTY);\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getPreviousValue))\n+        .hasValue(PREVIOUS_VALUE);\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getNewValue)).hasValue(NEW_VALUE);\n+  }\n+\n+  @Test\n+  public void testLogEntryToTargetPropertyChange_createdValue() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry().targetProperty(TARGET_PROPERTY).previousValue(null).newValue(NEW_VALUE);\n+    final Optional<AuditTargetPropertyChange> propertyMaybe =\n+        auditLogEntryMapper.logEntryToTargetPropertyChange(logEntry);\n+    assertThat(propertyMaybe).isPresent();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getTargetProperty))\n+        .hasValue(TARGET_PROPERTY);\n+    assertThat(propertyMaybe.get().getPreviousValue()).isNull();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getNewValue)).hasValue(NEW_VALUE);\n+  }\n+\n+  /**\n+   * At the moment, and historically, we write empty stings to the audit stream for things like\n+   * workspace properties (when empty). Make sure they propagate, unless/until we tighten things\n+   * upstream.\n+   */\n+  @Test\n+  public void testLogEntryToTargetPropertyChange_toleratesEmptyString() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry().targetProperty(TARGET_PROPERTY).previousValue(null).newValue(\"\");\n+    final Optional<AuditTargetPropertyChange> propertyMaybe =\n+        auditLogEntryMapper.logEntryToTargetPropertyChange(logEntry);\n+    assertThat(propertyMaybe).isPresent();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getTargetProperty))\n+        .hasValue(TARGET_PROPERTY);\n+    assertThat(propertyMaybe.get().getPreviousValue()).isNull();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getNewValue)).hasValue(\"\");\n+  }\n+\n+  @Test\n+  public void testLogEntryToTargetPropertyChange_emptyIfNoProperty() {\n+    assertThat(auditLogEntryMapper.logEntryToTargetPropertyChange(new AuditLogEntry())).isEmpty();\n+  }\n+\n+  @Test\n+  public void testBuildAuditAction_loginAction() {\n+    final AuditAction auditAction =\n+        auditLogEntryMapper.buildAuditAction(\n+            ImmutableList.of(\n+                new AuditLogEntry()\n+                    .actionId(ACTION_ID)\n+                    .actionType(LOGIN_ACTION_TYPE)\n+                    .agentId(AGENT_ID)\n+                    .agentType(USER_AGENT_TYPE)\n+                    .agentUsername(AGENT_USERNAME)\n+                    .eventTime(EVENT_TIME)\n+                    .newValue(null)\n+                    .previousValue(null)\n+                    .targetId(null)\n+                    .targetProperty(null)\n+                    .targetType(WORKBENCH_TARGET_TYPE)));\n+    assertThat(auditAction.getActionId()).isEqualTo(ACTION_ID);\n+    assertThat(auditAction.getActionTime()).isEqualTo(EVENT_TIME);\n+\n+    assertThat(auditAction.getEventBundles()).hasSize(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 150}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "084ad619010bc3baf58a1c10db6a65f0f38aea94", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/084ad619010bc3baf58a1c10db6a65f0f38aea94", "committedDate": "2020-06-03T16:16:02Z", "message": "Merge branch 'master' into jaycarlton/userQueryApi"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNzIyMDM1", "url": "https://github.com/all-of-us/workbench/pull/3624#pullrequestreview-423722035", "createdAt": "2020-06-03T16:19:17Z", "commit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjoxOToxN1rOGejjtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjozNzoxNFrOGekSCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5MzA0NA==", "bodyText": "Yeah...I'm trying not to get too fancy here without using a real DSL for query building. However, it's easy enough to split out the select statement, timestamp checks, and limit.", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434693044", "createdAt": "2020-06-03T16:19:17Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditQueryServiceImpl.java", "diffHunk": "@@ -1,137 +1,153 @@\n package org.pmiops.workbench.actionaudit;\n \n-import com.google.cloud.bigquery.FieldValueList;\n import com.google.cloud.bigquery.QueryJobConfiguration;\n import com.google.cloud.bigquery.QueryParameterValue;\n import com.google.cloud.bigquery.StandardSQLTypeName;\n import com.google.cloud.bigquery.TableResult;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.stream.StreamSupport;\n import javax.inject.Provider;\n import org.joda.time.DateTime;\n import org.pmiops.workbench.api.BigQueryService;\n import org.pmiops.workbench.config.WorkbenchConfig;\n import org.pmiops.workbench.config.WorkbenchConfig.ActionAuditConfig;\n import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.UserAuditLogQueryResponse;\n import org.pmiops.workbench.model.WorkspaceAuditLogQueryResponse;\n-import org.pmiops.workbench.utils.FieldValues;\n+import org.pmiops.workbench.utils.mappers.AuditLogEntryMapper;\n import org.springframework.stereotype.Service;\n \n @Service\n public class ActionAuditQueryServiceImpl implements ActionAuditQueryService {\n \n   private static final int MICROSECONDS_IN_MILLISECOND = 1000;\n+  private static final long MAX_QUERY_LIMIT = 1000L;\n \n-  enum Parameters {\n-    LIMIT(\"limit\"),\n-    WORKSPACE_DB_ID(\"workspace_db_id\"),\n-    AFTER_INCLUSIVE(\"after_inclusive\"),\n-    BEFORE_EXCLUSIVE(\"before_exclusive\");\n-\n-    private String name;\n-\n-    Parameters(String name) {\n-      this.name = name;\n-    }\n-\n-    public String getName() {\n-      return name;\n-    }\n-  }\n-\n+  private final AuditLogEntryMapper auditLogEntryMapper;\n   private final BigQueryService bigQueryService;\n   private final Provider<WorkbenchConfig> workbenchConfigProvider;\n \n-  private static final long MAX_QUERY_LIMIT = 1000L;\n-  // The table name can't be in a QueryParameterValue, so we substitute it with String.format()\n-  private static final String WORKSPACE_EVENTS_QUERY_STRING_FORMAT =\n-      \"SELECT\\n\"\n-          + \"  TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) as event_time,\\n\"\n-          + \"  jsonPayload.agent_type AS agent_type,\\n\"\n-          + \"  CAST(jsonPayload.agent_id AS INT64) AS agent_id,\\n\"\n-          + \"  jsonPayload.agent_email AS agent_username,\\n\"\n-          + \"  jsonPayload.action_id AS action_id,\\n\"\n-          + \"  jsonPayload.action_type AS action_type,\\n\"\n-          + \"  jsonPayload.target_type AS target_type,\\n\"\n-          + \"  CAST(jsonPayload.target_id AS INT64) AS target_id,\\n\"\n-          + \"  jsonPayload.target_property AS target_property,\\n\"\n-          + \"  jsonPayload.prev_value AS prev_value,\\n\"\n-          + \"  jsonPayload.new_value AS new_value\\n\"\n-          + \"FROM %s\\n\"\n-          + \"WHERE jsonPayload.target_id = @workspace_db_id AND\\n\"\n-          + \"  jsonPayload.target_type = 'WORKSPACE' AND\\n\"\n-          + \"  @after_inclusive <= TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) AND\\n\"\n-          + \"  TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) < @before_exclusive\\n\"\n-          + \"ORDER BY event_time, agent_id, action_id\\n\"\n-          + \"LIMIT @limit\";\n-\n   public ActionAuditQueryServiceImpl(\n-      BigQueryService bigQueryService, Provider<WorkbenchConfig> workbenchConfigProvider) {\n+      AuditLogEntryMapper auditLogEntryMapper,\n+      BigQueryService bigQueryService,\n+      Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.auditLogEntryMapper = auditLogEntryMapper;\n     this.bigQueryService = bigQueryService;\n     this.workbenchConfigProvider = workbenchConfigProvider;\n   }\n \n   @Override\n   public WorkspaceAuditLogQueryResponse queryEventsForWorkspace(\n-      long workspaceDatabaseId, long limit, DateTime afterInclusive, DateTime beforeExclusive) {\n-    final ActionAuditConfig actionAuditConfig = workbenchConfigProvider.get().actionAudit;\n-    final String fullyQualifiedTableName =\n-        String.format(\n-            \"`%s.%s.%s`\",\n-            workbenchConfigProvider.get().server.projectId,\n-            actionAuditConfig.bigQueryDataset,\n-            actionAuditConfig.bigQueryTable);\n+      long workspaceDatabaseId, long limit, DateTime after, DateTime before) {\n \n     final String queryString =\n-        String.format(WORKSPACE_EVENTS_QUERY_STRING_FORMAT, fullyQualifiedTableName);\n+        String.format(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNTI3NQ=="}, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5MzgwMA==", "bodyText": "yes I believe so. When alphabetizing, you exchange a one-time ugly diff for better merge management in the future and easier-to-find items.", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434693800", "createdAt": "2020-06-03T16:20:25Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/api/ProfileController.java", "diffHunk": "@@ -187,60 +190,63 @@ public DbDemographicSurvey apply(DemographicSurvey demographicSurvey) {\n \n   private static final long MAX_BILLING_PROJECT_CREATION_ATTEMPTS = 5;\n \n+  private final ActionAuditQueryService actionAuditQueryService;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNTg2Mg=="}, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5NTY4Mg==", "bodyText": "I originally wrote it, and at the time I was fighting with the user provider and understanding how the scopes work. In particular, you can shoot yourself in the foot if you manage to use a provider outside of its intended scope, and it's also possible to confuse the administrator deleting the user with the user being deleted if you're not careful.\nIt doesn't add any clarity anymore though so I nixed it.", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434695682", "createdAt": "2020-06-03T16:23:10Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/api/ProfileController.java", "diffHunk": "@@ -871,10 +877,33 @@ private void updateBypass(long userId, AccessBypassRequest request) {\n     log.log(Level.WARNING, \"Deleting profile: user email: \" + user.getUsername());\n     directoryService.deleteUser(user.getUsername().split(\"@\")[0]);\n     userDao.delete(user.getUserId());\n-    profileAuditor.fireDeleteAction(\n-        user.getUserId(),\n-        user.getUsername()); // not sure if user profider will survive the next line", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNjEwNA=="}, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5NjM4OA==", "bodyText": "yes, that's an immediate post-merge activity.", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434696388", "createdAt": "2020-06-03T16:24:06Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbStorageEnums.java", "diffHunk": "@@ -97,7 +97,7 @@ public static Short archivalStatusToStorage(ArchivalStatus s) {\n           .put(Authority.COMMUNICATIONS_ADMIN, (short) 4)\n           .put(Authority.SECURITY_ADMIN, (short) 5)\n           .put(Authority.INSTITUTION_ADMIN, (short) 6)\n-          .put(Authority.WORKSPACES_VIEW, (short) 7)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwOTEwMQ=="}, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5NzY4MA==", "bodyText": "I thought about doing that. Initially these were private methods, but then everything seemed to fit better on the mapper, but I don't believe it's possible to create a private helper method on a mapper.\nTechnically, they could have different event times due to an upstream bug, but I don't feel like it's appropriate to enforce that here. Maybe a cron to scan the BQ dataset now and then for sanity would suffice there.", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434697680", "createdAt": "2020-06-03T16:25:58Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapper.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.TableResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.Streams;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.elasticsearch.common.Strings;\n+import org.mapstruct.Mapper;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTarget;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.pmiops.workbench.utils.FieldValues;\n+\n+@Mapper(config = MapStructConfig.class)\n+public interface AuditLogEntryMapper {\n+  AuditAgent logEntryToAgent(AuditLogEntry auditLogEntry);\n+\n+  default AuditEventBundleHeader logEntryToEventBundleHeader(AuditLogEntry auditLogEntry) {\n+    return new AuditEventBundleHeader()\n+        .target(logEntryToTarget(auditLogEntry))\n+        .agent(logEntryToAgent(auditLogEntry))\n+        .actionType(auditLogEntry.getActionType());\n+  }\n+\n+  AuditTarget logEntryToTarget(AuditLogEntry auditLogEntry);\n+\n+  /**\n+   * Build an AuditTargetPropertyChange object from the relevant fields in the AuditLogEntry, unless\n+   * all of those are null, in which case return an empty optional\n+   *\n+   * @param auditLogEntry\n+   * @return\n+   */\n+  default Optional<AuditTargetPropertyChange> logEntryToTargetPropertyChange(\n+      AuditLogEntry auditLogEntry) {\n+    if ((Strings.isNullOrEmpty(auditLogEntry.getTargetProperty())\n+            && Strings.isNullOrEmpty(auditLogEntry.getPreviousValue()))\n+        && Strings.isNullOrEmpty(auditLogEntry.getNewValue())) {\n+      return Optional.empty();\n+    } else {\n+      return Optional.of(\n+          new AuditTargetPropertyChange()\n+              .targetProperty(auditLogEntry.getTargetProperty())\n+              .previousValue(auditLogEntry.getPreviousValue())\n+              .newValue(auditLogEntry.getNewValue()));\n+    }\n+  }\n+\n+  default List<AuditAction> logEntriesToActions(List<AuditLogEntry> logEntries) {\n+    final Multimap<String, AuditLogEntry> actionIdToRows =\n+        Multimaps.index(logEntries, AuditLogEntry::getActionId);\n+    return actionIdToRows.asMap().values().stream()\n+        .map(this::buildAuditAction)\n+        .collect(ImmutableList.toImmutableList());\n+  }\n+\n+  /**\n+   * @param logEntries Collection of AuditLogEntry objectsthat have a common Action ID, which should", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyODc2Nw=="}, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcwMzg5Mg==", "bodyText": "I couldn't find which one is missing. (Not all fields are set, since some are irrelevant).", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434703892", "createdAt": "2020-06-03T16:35:41Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapperTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.pmiops.workbench.actionaudit.auditors.ActionAuditTestConfig.ACTION_ID;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.util.Optional;\n+import org.joda.time.DateTime;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class AuditLogEntryMapperTest {\n+\n+  public static final long AGENT_ID = 101L;\n+  public static final String USER_AGENT_TYPE = \"USER\";\n+  public static final String AGENT_USERNAME = \"paul@beatles.info\";\n+  public static final long TARGET_ID = 202L;\n+  public static final String ACTION_TYPE_DELETE = \"DELETE\";\n+  public static final String TARGET_TYPE_WORKSPACE = \"WORKSPACE\";\n+  public static final String TARGET_PROPERTY = \"title\";\n+  public static final String PREVIOUS_VALUE = \"District 5\";\n+  public static final String NEW_VALUE = \"The Mighty Ducks\";\n+  public static final String LOGIN_ACTION_TYPE = \"LOGIN\";\n+  public static final DateTime EVENT_TIME = new DateTime(1579013840545L);\n+  public static final String WORKBENCH_TARGET_TYPE = \"WORKBENCH\";\n+  @Autowired private AuditLogEntryMapper auditLogEntryMapper;\n+\n+  @TestConfiguration\n+  @Import({AuditLogEntryMapperImpl.class})\n+  public static class Config {}\n+\n+  @Test\n+  public void testLogEntryToAgent() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .actionType(\"CREATE\")\n+            .agentId(AGENT_ID)\n+            .agentType(USER_AGENT_TYPE)\n+            .agentUsername(AGENT_USERNAME);\n+    final AuditAgent auditAgent = auditLogEntryMapper.logEntryToAgent(logEntry);\n+    assertThat(auditAgent.getAgentId()).isEqualTo(AGENT_ID);\n+    assertThat(auditAgent.getAgentType()).isEqualTo(USER_AGENT_TYPE);\n+    assertThat(auditAgent.getAgentUsername()).isEqualTo(AGENT_USERNAME);\n+  }\n+\n+  @Test\n+  public void testLogEntryToEventBundleHeader() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .agentId(AGENT_ID)\n+            .agentUsername(AGENT_USERNAME)\n+            .agentType(USER_AGENT_TYPE)\n+            .actionType(ACTION_TYPE_DELETE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MTk3NQ=="}, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcwNDkwNA==", "bodyText": "\ud83d\udcaf", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434704904", "createdAt": "2020-06-03T16:37:14Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapperTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.pmiops.workbench.actionaudit.auditors.ActionAuditTestConfig.ACTION_ID;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.util.Optional;\n+import org.joda.time.DateTime;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class AuditLogEntryMapperTest {\n+\n+  public static final long AGENT_ID = 101L;\n+  public static final String USER_AGENT_TYPE = \"USER\";\n+  public static final String AGENT_USERNAME = \"paul@beatles.info\";\n+  public static final long TARGET_ID = 202L;\n+  public static final String ACTION_TYPE_DELETE = \"DELETE\";\n+  public static final String TARGET_TYPE_WORKSPACE = \"WORKSPACE\";\n+  public static final String TARGET_PROPERTY = \"title\";\n+  public static final String PREVIOUS_VALUE = \"District 5\";\n+  public static final String NEW_VALUE = \"The Mighty Ducks\";\n+  public static final String LOGIN_ACTION_TYPE = \"LOGIN\";\n+  public static final DateTime EVENT_TIME = new DateTime(1579013840545L);\n+  public static final String WORKBENCH_TARGET_TYPE = \"WORKBENCH\";\n+  @Autowired private AuditLogEntryMapper auditLogEntryMapper;\n+\n+  @TestConfiguration\n+  @Import({AuditLogEntryMapperImpl.class})\n+  public static class Config {}\n+\n+  @Test\n+  public void testLogEntryToAgent() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .actionType(\"CREATE\")\n+            .agentId(AGENT_ID)\n+            .agentType(USER_AGENT_TYPE)\n+            .agentUsername(AGENT_USERNAME);\n+    final AuditAgent auditAgent = auditLogEntryMapper.logEntryToAgent(logEntry);\n+    assertThat(auditAgent.getAgentId()).isEqualTo(AGENT_ID);\n+    assertThat(auditAgent.getAgentType()).isEqualTo(USER_AGENT_TYPE);\n+    assertThat(auditAgent.getAgentUsername()).isEqualTo(AGENT_USERNAME);\n+  }\n+\n+  @Test\n+  public void testLogEntryToEventBundleHeader() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .agentId(AGENT_ID)\n+            .agentUsername(AGENT_USERNAME)\n+            .agentType(USER_AGENT_TYPE)\n+            .actionType(ACTION_TYPE_DELETE)\n+            .targetId(TARGET_ID)\n+            .targetType(TARGET_TYPE_WORKSPACE);\n+    final AuditEventBundleHeader header = auditLogEntryMapper.logEntryToEventBundleHeader(logEntry);\n+    assertThat(header.getActionType()).isEqualTo(ACTION_TYPE_DELETE);\n+    assertThat(header.getAgent().getAgentUsername()).isEqualTo(AGENT_USERNAME);\n+    assertThat(header.getAgent().getAgentType()).isEqualTo(USER_AGENT_TYPE);\n+    assertThat(header.getAgent().getAgentId()).isEqualTo(AGENT_ID);\n+    assertThat(header.getTarget().getTargetId()).isEqualTo(TARGET_ID);\n+    assertThat(header.getTarget().getTargetType()).isEqualTo(TARGET_TYPE_WORKSPACE);\n+  }\n+\n+  @Test\n+  public void testLogEntryToTargetPropertyChange() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .targetProperty(TARGET_PROPERTY)\n+            .previousValue(PREVIOUS_VALUE)\n+            .newValue(NEW_VALUE);\n+    final Optional<AuditTargetPropertyChange> propertyMaybe =\n+        auditLogEntryMapper.logEntryToTargetPropertyChange(logEntry);\n+    assertThat(propertyMaybe).isPresent();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getTargetProperty))\n+        .hasValue(TARGET_PROPERTY);\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getPreviousValue))\n+        .hasValue(PREVIOUS_VALUE);\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getNewValue)).hasValue(NEW_VALUE);\n+  }\n+\n+  @Test\n+  public void testLogEntryToTargetPropertyChange_createdValue() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry().targetProperty(TARGET_PROPERTY).previousValue(null).newValue(NEW_VALUE);\n+    final Optional<AuditTargetPropertyChange> propertyMaybe =\n+        auditLogEntryMapper.logEntryToTargetPropertyChange(logEntry);\n+    assertThat(propertyMaybe).isPresent();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getTargetProperty))\n+        .hasValue(TARGET_PROPERTY);\n+    assertThat(propertyMaybe.get().getPreviousValue()).isNull();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MjU3Mg=="}, "originalCommit": {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd"}, "originalPosition": 103}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5ed5f6cba4000a30307b91552af8a6abc4ec6bc", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/e5ed5f6cba4000a30307b91552af8a6abc4ec6bc", "committedDate": "2020-06-03T16:50:52Z", "message": "consolidate query strings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89b75ce6f0f25620ed37cbba6cc6a440fe3ac266", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/89b75ce6f0f25620ed37cbba6cc6a440fe3ac266", "committedDate": "2020-06-03T20:30:52Z", "message": "new tests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4804, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}