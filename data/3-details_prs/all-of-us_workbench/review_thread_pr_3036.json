{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NjY3MDcx", "number": 3036, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNDo0MTowNFrODagbHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwNDowMDoxNVrODbGGiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTIwNzk3OnYy", "diffSide": "RIGHT", "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNDo0MTowNFrOFhfv3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQyMzoxODoyN1rOFhs6rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2NzQ4Ng==", "bodyText": "nit: I might name these arguments, even the null ones, for readability.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r370667486", "createdAt": "2020-01-24T14:41:04Z", "author": {"login": "jaycarlton"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,42 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call = client.getClusterCall(parts[0], parts[1], null, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4MzI0Ng==", "bodyText": "Done for parts[0], parts[1]. For the nulls, I prefer to comment rather than having placeholder variables.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r370883246", "createdAt": "2020-01-24T23:18:27Z", "author": {"login": "calbach"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,42 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call = client.getClusterCall(parts[0], parts[1], null, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2NzQ4Ng=="}, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTIxMjMwOnYy", "diffSide": "RIGHT", "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNDo0MjowOVrOFhfycQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxODo0MzowOVrOFiwRPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2ODE0NQ==", "bodyText": "nit: why not allow the caller to specify an output stream?", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r370668145", "createdAt": "2020-01-24T14:42:09Z", "author": {"login": "jaycarlton"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,42 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call = client.getClusterCall(parts[0], parts[1], null, null);\n+    ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);\n+\n+    // Parse the response as well so we can log specific structured fields.\n+    Cluster cluster = PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), Cluster.class);\n+\n+    System.out.println(PRETTY_GSON.toJson(resp.getData()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4MzU3Ng==", "bodyText": "Why? Use of this function is pretty tightly scoped to just this CLI in this file, probably indefinitely - I don't see an advantage to generalizing this.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r370883576", "createdAt": "2020-01-24T23:20:10Z", "author": {"login": "calbach"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,42 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call = client.getClusterCall(parts[0], parts[1], null, null);\n+    ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);\n+\n+    // Parse the response as well so we can log specific structured fields.\n+    Cluster cluster = PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), Cluster.class);\n+\n+    System.out.println(PRETTY_GSON.toJson(resp.getData()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2ODE0NQ=="}, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5Nzc2Mw==", "bodyText": "System.out calls won't go to stackdriver logging, right? I guess that's what was curious. Maybe it needn't, since this is just for inspection. There might be a requirement for auditing administrative exploration of a cluster eventually though.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371597763", "createdAt": "2020-01-28T03:46:37Z", "author": {"login": "jaycarlton"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,42 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call = client.getClusterCall(parts[0], parts[1], null, null);\n+    ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);\n+\n+    // Parse the response as well so we can log specific structured fields.\n+    Cluster cluster = PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), Cluster.class);\n+\n+    System.out.println(PRETTY_GSON.toJson(resp.getData()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2ODE0NQ=="}, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4Njc0OQ==", "bodyText": "This is running on a dev workstation, none of these logs are going to Stackdriver. As of now we have audit logging of any remote actions such as the creation of the key and calls to GCS etc. It would be nice to have audit logging in these tools as well - definitely outside the scope of this PR.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371986749", "createdAt": "2020-01-28T18:43:09Z", "author": {"login": "calbach"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,42 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call = client.getClusterCall(parts[0], parts[1], null, null);\n+    ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);\n+\n+    // Parse the response as well so we can log specific structured fields.\n+    Cluster cluster = PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), Cluster.class);\n+\n+    System.out.println(PRETTY_GSON.toJson(resp.getData()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2ODE0NQ=="}, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTIxNzc2OnYy", "diffSide": "RIGHT", "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNDo0Mzo0OVrOFhf11g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOToxOTowOVrOFixX1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2OTAxNA==", "bodyText": "should this specify that you should run this on your cluster?", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r370669014", "createdAt": "2020-01-24T14:43:49Z", "author": {"login": "jaycarlton"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,42 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call = client.getClusterCall(parts[0], parts[1], null, null);\n+    ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);\n+\n+    // Parse the response as well so we can log specific structured fields.\n+    Cluster cluster = PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), Cluster.class);\n+\n+    System.out.println(PRETTY_GSON.toJson(resp.getData()));\n+    System.out.printf(\"\\n\\nTo inspect logs in cloud storage, run the following:\\n\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4NDExMA==", "bodyText": "No - you aren't supposed to do that (and permissions wise, this should probably be impossible to run on a workbench Leo cluster). This is intended for execution on a dev workstation.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r370884110", "createdAt": "2020-01-24T23:22:26Z", "author": {"login": "calbach"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,42 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call = client.getClusterCall(parts[0], parts[1], null, null);\n+    ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);\n+\n+    // Parse the response as well so we can log specific structured fields.\n+    Cluster cluster = PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), Cluster.class);\n+\n+    System.out.println(PRETTY_GSON.toJson(resp.getData()));\n+    System.out.printf(\"\\n\\nTo inspect logs in cloud storage, run the following:\\n\\n\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2OTAxNA=="}, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM4NTAzMg==", "bodyText": "Oh, then I missed the point of why we're printing out stuff to be copied and executed later. The idea is that the logs are protected at a higher level than you necessarily have when you're running this, and/or they're too voluminous to dump to the terminal.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371385032", "createdAt": "2020-01-27T17:42:07Z", "author": {"login": "jaycarlton"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,42 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call = client.getClusterCall(parts[0], parts[1], null, null);\n+    ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);\n+\n+    // Parse the response as well so we can log specific structured fields.\n+    Cluster cluster = PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), Cluster.class);\n+\n+    System.out.println(PRETTY_GSON.toJson(resp.getData()));\n+    System.out.printf(\"\\n\\nTo inspect logs in cloud storage, run the following:\\n\\n\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2OTAxNA=="}, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwOTUzMg==", "bodyText": "I've added a bit more instruction to this output. If you decide to run them, these commands get you to effectively a debug session. Human decisions are required because there are multiple log files you might want to look at, and we don't want to depend on the Leo-specific directory structure / naming.\nAfter typing this out, it would good to automate more of this. Once I have https://precisionmedicineinitiative.atlassian.net/browse/PD-4740, I'll revisit this and glob out all the files in the directory, then give a simple commandline someone could use to copy/cat the logs if desired.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371409532", "createdAt": "2020-01-27T18:33:14Z", "author": {"login": "calbach"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,42 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call = client.getClusterCall(parts[0], parts[1], null, null);\n+    ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);\n+\n+    // Parse the response as well so we can log specific structured fields.\n+    Cluster cluster = PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), Cluster.class);\n+\n+    System.out.println(PRETTY_GSON.toJson(resp.getData()));\n+    System.out.printf(\"\\n\\nTo inspect logs in cloud storage, run the following:\\n\\n\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2OTAxNA=="}, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5ODIwMg==", "bodyText": "Oh that's interesting about the SA tokens.\nDo you think it would make sense to define a group for all the developers who need to go on-call? I know they tend not to want to do that unless there are ~3 or more accounts that need whatever access it might be. It just seems like managing the next person to join the team would be much simpler if it were just adding them to an oncall group.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371598202", "createdAt": "2020-01-28T03:49:13Z", "author": {"login": "jaycarlton"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,42 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call = client.getClusterCall(parts[0], parts[1], null, null);\n+    ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);\n+\n+    // Parse the response as well so we can log specific structured fields.\n+    Cluster cluster = PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), Cluster.class);\n+\n+    System.out.println(PRETTY_GSON.toJson(resp.getData()));\n+    System.out.printf(\"\\n\\nTo inspect logs in cloud storage, run the following:\\n\\n\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2OTAxNA=="}, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwNDgyMw==", "bodyText": "Groups have been disallowed for IAM policy control by security, as I understand it. I'm going to ask about this on the security call to get clearer rationale on why that's the case since it is very limiting (tried today but ran out of time).", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r372004823", "createdAt": "2020-01-28T19:19:09Z", "author": {"login": "calbach"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,42 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call = client.getClusterCall(parts[0], parts[1], null, null);\n+    ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);\n+\n+    // Parse the response as well so we can log specific structured fields.\n+    Cluster cluster = PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), Cluster.class);\n+\n+    System.out.println(PRETTY_GSON.toJson(resp.getData()));\n+    System.out.printf(\"\\n\\nTo inspect logs in cloud storage, run the following:\\n\\n\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2OTAxNA=="}, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTIxOTgzOnYy", "diffSide": "RIGHT", "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNDo0NDozMVrOFhf3Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNzo0NzozMVrOFiLtcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2OTMzNA==", "bodyText": "aside: Do we not yet have an argument parser for Java like we do in Ruby?", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r370669334", "createdAt": "2020-01-24T14:44:31Z", "author": {"login": "jaycarlton"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -140,13 +186,23 @@ private static void deleteClusters(\n   public CommandLineRunner run() {\n     return (args) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4NDQ0Nw==", "bodyText": "We do, but it hasn't been backfilled to these older CLIs yet. I've filed https://precisionmedicineinitiative.atlassian.net/browse/RW-4340 for that. This situation could also use some more thought - having a ruby layer of flag parsing feeding into a duplicate Java layer of flag parsing is a sad state of affairs.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r370884447", "createdAt": "2020-01-24T23:24:01Z", "author": {"login": "calbach"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -140,13 +186,23 @@ private static void deleteClusters(\n   public CommandLineRunner run() {\n     return (args) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2OTMzNA=="}, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM4Nzc2MQ==", "bodyText": "I'd be interested to chat. we're looking at the same issue with ops tooling.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371387761", "createdAt": "2020-01-27T17:47:31Z", "author": {"login": "jaycarlton"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -140,13 +186,23 @@ private static void deleteClusters(\n   public CommandLineRunner run() {\n     return (args) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2OTMzNA=="}, "originalCommit": {"oid": "592402f73700fb7e872a53f93b5f75904b3b7d96"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzM0NDUxOnYy", "diffSide": "RIGHT", "path": "api/libproject/devstart.rb", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwMzoyNTo1NVrOFiYUEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxODoyMTo1MlrOFivmsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NDI1Ng==", "bodyText": "I'm surprised there's not an even more succinct way to bind the option value to an attribute.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371594256", "createdAt": "2020-01-28T03:25:55Z", "author": {"login": "jaycarlton"}, "path": "api/libproject/devstart.rb", "diffHunk": "@@ -1301,6 +1301,60 @@ def delete_clusters(cmd_name, *args)\n   :fn => ->(*args) { delete_clusters(\"delete-clusters\", *args) }\n })\n \n+def describe_cluster(cmd_name, *args)\n+  ensure_docker cmd_name, args\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--id [CLUSTER_ID]\",\n+      ->(opts, v) { opts.cluster_id = v},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk3NTg1Nw==", "bodyText": "IMO this option binder pattern has been good enough to get the job done, but I'm sure it can be improved.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371975857", "createdAt": "2020-01-28T18:21:52Z", "author": {"login": "calbach"}, "path": "api/libproject/devstart.rb", "diffHunk": "@@ -1301,6 +1301,60 @@ def delete_clusters(cmd_name, *args)\n   :fn => ->(*args) { delete_clusters(\"delete-clusters\", *args) }\n })\n \n+def describe_cluster(cmd_name, *args)\n+  ensure_docker cmd_name, args\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--id [CLUSTER_ID]\",\n+      ->(opts, v) { opts.cluster_id = v},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NDI1Ng=="}, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzM0NTg2OnYy", "diffSide": "RIGHT", "path": "api/libproject/devstart.rb", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwMzoyNzowMlrOFiYU6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzo0MTowMFrOFi4bxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NDQ3Mg==", "bodyText": "nit: We should have a standard validator with a bit more descriptive message when a required parameter is missing.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371594472", "createdAt": "2020-01-28T03:27:02Z", "author": {"login": "jaycarlton"}, "path": "api/libproject/devstart.rb", "diffHunk": "@@ -1301,6 +1301,60 @@ def delete_clusters(cmd_name, *args)\n   :fn => ->(*args) { delete_clusters(\"delete-clusters\", *args) }\n })\n \n+def describe_cluster(cmd_name, *args)\n+  ensure_docker cmd_name, args\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--id [CLUSTER_ID]\",\n+      ->(opts, v) { opts.cluster_id = v},\n+      \"Required cluster ID to describe, e.g. 'aou-test-f1-1/all-of-us'\")\n+  op.add_option(\n+      \"--project [project]\",\n+      ->(opts, v) { opts.project = v},\n+      \"Optional project ID; by default will infer the project form the cluster ID\")\n+  op.add_validator ->(opts) { raise ArgumentError unless opts.cluster_id }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEyMDUxNw==", "bodyText": "Agreed. But not in scope for this PR as there are ~10 unrelated usages of this same pattern.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r372120517", "createdAt": "2020-01-28T23:41:00Z", "author": {"login": "calbach"}, "path": "api/libproject/devstart.rb", "diffHunk": "@@ -1301,6 +1301,60 @@ def delete_clusters(cmd_name, *args)\n   :fn => ->(*args) { delete_clusters(\"delete-clusters\", *args) }\n })\n \n+def describe_cluster(cmd_name, *args)\n+  ensure_docker cmd_name, args\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--id [CLUSTER_ID]\",\n+      ->(opts, v) { opts.cluster_id = v},\n+      \"Required cluster ID to describe, e.g. 'aou-test-f1-1/all-of-us'\")\n+  op.add_option(\n+      \"--project [project]\",\n+      ->(opts, v) { opts.project = v},\n+      \"Optional project ID; by default will infer the project form the cluster ID\")\n+  op.add_validator ->(opts) { raise ArgumentError unless opts.cluster_id }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NDQ3Mg=="}, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzM0OTcwOnYy", "diffSide": "RIGHT", "path": "api/libproject/devstart.rb", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwMzozMDo0MVrOFiYXOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzozNzoxMVrOFi4W7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NTA2Ng==", "bodyText": "How are you handling local vs test here? Or do you not need to?", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371595066", "createdAt": "2020-01-28T03:30:41Z", "author": {"login": "jaycarlton"}, "path": "api/libproject/devstart.rb", "diffHunk": "@@ -1301,6 +1301,60 @@ def delete_clusters(cmd_name, *args)\n   :fn => ->(*args) { delete_clusters(\"delete-clusters\", *args) }\n })\n \n+def describe_cluster(cmd_name, *args)\n+  ensure_docker cmd_name, args\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--id [CLUSTER_ID]\",\n+      ->(opts, v) { opts.cluster_id = v},\n+      \"Required cluster ID to describe, e.g. 'aou-test-f1-1/all-of-us'\")\n+  op.add_option(\n+      \"--project [project]\",\n+      ->(opts, v) { opts.project = v},\n+      \"Optional project ID; by default will infer the project form the cluster ID\")\n+  op.add_validator ->(opts) { raise ArgumentError unless opts.cluster_id }\n+  op.parse.validate\n+\n+  # Infer the project from the cluster ID project ID. If for some reason, the\n+  # target cluster ID does not conform to the current billing prefix (e.g. if we\n+  # changed the prefix), --project will override this.\n+  common = Common.new\n+  project_from_cluster = nil\n+  ENVIRONMENTS.each_key do |env|\n+    if op.opts.cluster_id.start_with?(get_billing_project_prefix(env))\n+      # Take the most specific prefix match, since prod is a substring of the others.\n+      if not project_from_cluster or project_from_cluster.length < env.length\n+        project_from_cluster = env", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExOTI3Ng==", "bodyText": "Good catch, worth handling here. Added coverage, though there's a tech debt ticket to make sure we have better uniform handling of local vs test commands.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r372119276", "createdAt": "2020-01-28T23:37:11Z", "author": {"login": "calbach"}, "path": "api/libproject/devstart.rb", "diffHunk": "@@ -1301,6 +1301,60 @@ def delete_clusters(cmd_name, *args)\n   :fn => ->(*args) { delete_clusters(\"delete-clusters\", *args) }\n })\n \n+def describe_cluster(cmd_name, *args)\n+  ensure_docker cmd_name, args\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--id [CLUSTER_ID]\",\n+      ->(opts, v) { opts.cluster_id = v},\n+      \"Required cluster ID to describe, e.g. 'aou-test-f1-1/all-of-us'\")\n+  op.add_option(\n+      \"--project [project]\",\n+      ->(opts, v) { opts.project = v},\n+      \"Optional project ID; by default will infer the project form the cluster ID\")\n+  op.add_validator ->(opts) { raise ArgumentError unless opts.cluster_id }\n+  op.parse.validate\n+\n+  # Infer the project from the cluster ID project ID. If for some reason, the\n+  # target cluster ID does not conform to the current billing prefix (e.g. if we\n+  # changed the prefix), --project will override this.\n+  common = Common.new\n+  project_from_cluster = nil\n+  ENVIRONMENTS.each_key do |env|\n+    if op.opts.cluster_id.start_with?(get_billing_project_prefix(env))\n+      # Take the most specific prefix match, since prod is a substring of the others.\n+      if not project_from_cluster or project_from_cluster.length < env.length\n+        project_from_cluster = env", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NTA2Ng=="}, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzM1NTI2OnYy", "diffSide": "RIGHT", "path": "api/libproject/devstart.rb", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwMzozNTo1M1rOFiYatQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxODoyNzowMlrOFivxhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NTk1Nw==", "bodyText": "Is it possible to pull out the command into a separate Ruby script or class so that we don't keep adding . code to devstart.rb? Presumably you'd just have to leave behind this command registration.\naside: it's kind of annoying that we need two levels of registration, one in Common and another with WbOptionsParser. I wonder if there's something more generic that could handle multiple levels of commands a la gcloud.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371595957", "createdAt": "2020-01-28T03:35:53Z", "author": {"login": "jaycarlton"}, "path": "api/libproject/devstart.rb", "diffHunk": "@@ -1301,6 +1301,60 @@ def delete_clusters(cmd_name, *args)\n   :fn => ->(*args) { delete_clusters(\"delete-clusters\", *args) }\n })\n \n+def describe_cluster(cmd_name, *args)\n+  ensure_docker cmd_name, args\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--id [CLUSTER_ID]\",\n+      ->(opts, v) { opts.cluster_id = v},\n+      \"Required cluster ID to describe, e.g. 'aou-test-f1-1/all-of-us'\")\n+  op.add_option(\n+      \"--project [project]\",\n+      ->(opts, v) { opts.project = v},\n+      \"Optional project ID; by default will infer the project form the cluster ID\")\n+  op.add_validator ->(opts) { raise ArgumentError unless opts.cluster_id }\n+  op.parse.validate\n+\n+  # Infer the project from the cluster ID project ID. If for some reason, the\n+  # target cluster ID does not conform to the current billing prefix (e.g. if we\n+  # changed the prefix), --project will override this.\n+  common = Common.new\n+  project_from_cluster = nil\n+  ENVIRONMENTS.each_key do |env|\n+    if op.opts.cluster_id.start_with?(get_billing_project_prefix(env))\n+      # Take the most specific prefix match, since prod is a substring of the others.\n+      if not project_from_cluster or project_from_cluster.length < env.length\n+        project_from_cluster = env\n+      end\n+    end\n+  end\n+  common.warning \"unable to determine project by cluster ID\" unless project_from_cluster\n+  unless op.opts.project\n+    op.opts.project = project_from_cluster\n+  end\n+\n+  # Add the GcloudContext after setting up the project parameter to avoid\n+  # earlier validation failures.\n+  gcc = GcloudContextV2.new(op)\n+  op.parse.validate\n+  gcc.validate\n+\n+  api_url = get_leo_api_url(gcc.project)\n+  ServiceAccountContext.new(gcc.project).run do |ctx|\n+    common = Common.new\n+    common.run_inline %W{\n+       gradle manageClusters\n+      -PappArgs=['describe','#{api_url}','#{gcc.project}','#{ctx.service_account}','#{op.opts.cluster_id}']}\n+  end\n+end\n+\n+Common.register_command({", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk3ODYzMA==", "bodyText": "This file could likely be split up into multiple files, probably including the registration piece.\nI agree there is duplication there, though I don't think I'd say that we're \"registering\" anything with the WbOptionsParser, we're just configuring the flags.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371978630", "createdAt": "2020-01-28T18:27:02Z", "author": {"login": "calbach"}, "path": "api/libproject/devstart.rb", "diffHunk": "@@ -1301,6 +1301,60 @@ def delete_clusters(cmd_name, *args)\n   :fn => ->(*args) { delete_clusters(\"delete-clusters\", *args) }\n })\n \n+def describe_cluster(cmd_name, *args)\n+  ensure_docker cmd_name, args\n+  op = WbOptionsParser.new(cmd_name, args)\n+  op.add_option(\n+      \"--id [CLUSTER_ID]\",\n+      ->(opts, v) { opts.cluster_id = v},\n+      \"Required cluster ID to describe, e.g. 'aou-test-f1-1/all-of-us'\")\n+  op.add_option(\n+      \"--project [project]\",\n+      ->(opts, v) { opts.project = v},\n+      \"Optional project ID; by default will infer the project form the cluster ID\")\n+  op.add_validator ->(opts) { raise ArgumentError unless opts.cluster_id }\n+  op.parse.validate\n+\n+  # Infer the project from the cluster ID project ID. If for some reason, the\n+  # target cluster ID does not conform to the current billing prefix (e.g. if we\n+  # changed the prefix), --project will override this.\n+  common = Common.new\n+  project_from_cluster = nil\n+  ENVIRONMENTS.each_key do |env|\n+    if op.opts.cluster_id.start_with?(get_billing_project_prefix(env))\n+      # Take the most specific prefix match, since prod is a substring of the others.\n+      if not project_from_cluster or project_from_cluster.length < env.length\n+        project_from_cluster = env\n+      end\n+    end\n+  end\n+  common.warning \"unable to determine project by cluster ID\" unless project_from_cluster\n+  unless op.opts.project\n+    op.opts.project = project_from_cluster\n+  end\n+\n+  # Add the GcloudContext after setting up the project parameter to avoid\n+  # earlier validation failures.\n+  gcc = GcloudContextV2.new(op)\n+  op.parse.validate\n+  gcc.validate\n+\n+  api_url = get_leo_api_url(gcc.project)\n+  ServiceAccountContext.new(gcc.project).run do |ctx|\n+    common = Common.new\n+    common.run_inline %W{\n+       gradle manageClusters\n+      -PappArgs=['describe','#{api_url}','#{gcc.project}','#{ctx.service_account}','#{op.opts.cluster_id}']}\n+  end\n+end\n+\n+Common.register_command({", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NTk1Nw=="}, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzM1OTgyOnYy", "diffSide": "RIGHT", "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwMzo0MDoxOVrOFiYddQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxODoyNzozMFrOFivybA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NjY2MQ==", "bodyText": "nit: This looks like the kind of list you might want in an Enum, so that you can add description, friendly name, or whatever other metadata you like to the arguments. It also lets you be a bit more type-safe, so no one can pass in an unsupported argument.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371596661", "createdAt": "2020-01-28T03:40:19Z", "author": {"login": "jaycarlton"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -41,6 +46,11 @@\n         \"https://www.googleapis.com/auth/userinfo.profile\",\n         \"https://www.googleapis.com/auth/userinfo.email\"\n       };\n+  private static final List<String> DESCRIBE_ARG_NAMES =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk3ODg2MA==", "bodyText": "I'd rather just use flags here, as I referenced in the ticket I filed.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371978860", "createdAt": "2020-01-28T18:27:30Z", "author": {"login": "calbach"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -41,6 +46,11 @@\n         \"https://www.googleapis.com/auth/userinfo.profile\",\n         \"https://www.googleapis.com/auth/userinfo.email\"\n       };\n+  private static final List<String> DESCRIBE_ARG_NAMES =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NjY2MQ=="}, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzM2MTk4OnYy", "diffSide": "RIGHT", "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwMzo0MjozOFrOFiYe5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOToxNjowMlrOFixRuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NzAzMQ==", "bodyText": "I wonder if it's worth making a shell command in devstart that's just a straight pass-through. If the args are only going to have one source of truth, I'd probably want that to be the code that responds to them, i.e. this file. Plus, ideally we should be able to run this just as easily from outside a ruby dispatching system; we needn't depend on it.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371597031", "createdAt": "2020-01-28T03:42:38Z", "author": {"login": "jaycarlton"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -155,9 +219,11 @@ public CommandLineRunner run() {\n         case \"delete\":\n           // User-friendly command-line parsing is done in devstart.rb, so we do only simple", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwMzI1Ng==", "bodyText": "The ruby layer currently handles authenticating as any necessary SA and/or setting up cloud SQL proxy. This requires some degree of flag parsing. The rest could potentially be pass-through, if the options parser allowed that.\nBeyond that, it also handles entering into a docker context (or not).", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r372003256", "createdAt": "2020-01-28T19:16:02Z", "author": {"login": "calbach"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -155,9 +219,11 @@ public CommandLineRunner run() {\n         case \"delete\":\n           // User-friendly command-line parsing is done in devstart.rb, so we do only simple", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NzAzMQ=="}, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzM2NDUwOnYy", "diffSide": "RIGHT", "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwMzo0NTowMlrOFiYggA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOToyMDo1NFrOFixbKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NzQ0MA==", "bodyText": "nit: this logic seems like it should be in a utility class so that services can use it if they need to. You wouldn't want those to depend on tools I wouldn't think.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371597440", "createdAt": "2020-01-28T03:45:02Z", "author": {"login": "jaycarlton"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,50 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwNTY3Mg==", "bodyText": "It's an idiosyncrasy of the ID format accepted by the command-line tool, it doesn't have any kind of broader significance, unless we decide to use this format in other CLIs (currently, this is the only one that cares about clusters).", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r372005672", "createdAt": "2020-01-28T19:20:54Z", "author": {"login": "calbach"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,50 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NzQ0MA=="}, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzM4MTIxOnYy", "diffSide": "RIGHT", "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwNDowMDoxNVrOFiYqsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxODo0MToxOVrOFiwNsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYwMDA1MQ==", "bodyText": "If I'm reading this right, you can set an explicit expiration time by passing validBeforeTime, but I think it's only for the REST API and not the gcloud command.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371600051", "createdAt": "2020-01-28T04:00:15Z", "author": {"login": "jaycarlton"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,50 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+    String clusterProject = parts[0];\n+    String clusterName = parts[1];\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call =\n+        client.getClusterCall(\n+            clusterProject,\n+            clusterName,\n+            /* progressListener */ null,\n+            /* progressRequestListener */ null);\n+    ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);\n+\n+    // Parse the response as well so we can log specific structured fields.\n+    Cluster cluster = PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), Cluster.class);\n+\n+    System.out.println(PRETTY_GSON.toJson(resp.getData()));\n+    System.out.printf(\"\\n\\nTo inspect logs in cloud storage, run the following:\\n\\n\");\n+\n+    // TODO(PD-4740): Use impersonation here instead.\n+    String keyPath = String.format(\"/tmp/%s-key.json\", workbenchProjectId);\n+    System.out.printf(\n+        \"    gcloud iam service-accounts keys create %s --iam-account %s\\n\",\n+        keyPath, workbenchServiceAccount);\n+    System.out.printf(\"    gcloud auth activate-service-account --key-file %s\\n\\n\", keyPath);\n+    System.out.printf(\"    gsutil ls gs://%s/**\\n\", cluster.getStagingBucket());\n+    System.out.printf(\"    gsutil cat ... # inspect or copy logs\\n\\n\");\n+    System.out.printf(\"    # Delete the key when done\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4NTg0Mg==", "bodyText": "Nice find, but yes - I don't see this supported by the gcloud command. Per above PD-4740 the plan is to switch this to impersonation anyways so its moot.", "url": "https://github.com/all-of-us/workbench/pull/3036#discussion_r371985842", "createdAt": "2020-01-28T18:41:19Z", "author": {"login": "calbach"}, "path": "api/tools/src/main/java/org/pmiops/workbench/tools/ManageClusters.java", "diffHunk": "@@ -91,6 +101,50 @@ private static void listClusters(String apiUrl) throws IOException, ApiException\n     System.out.println(String.format(\"listed %d clusters\", count.get()));\n   }\n \n+  private static void describeCluster(\n+      String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String clusterId)\n+      throws IOException, ApiException {\n+    String[] parts = clusterId.split(\"/\");\n+    if (parts.length != 2) {\n+      System.err.println(\n+          String.format(\n+              \"given cluster ID '%s' is invalid, wanted format 'project/clusterName'\", clusterId));\n+      return;\n+    }\n+    String clusterProject = parts[0];\n+    String clusterName = parts[1];\n+\n+    // Leo's getCluster API swagger tends to be outdated; issue a raw getCluster request to ensure\n+    // we get all available information for debugging.\n+    ClusterApi client = newApiClient(apiUrl);\n+    com.squareup.okhttp.Call call =\n+        client.getClusterCall(\n+            clusterProject,\n+            clusterName,\n+            /* progressListener */ null,\n+            /* progressRequestListener */ null);\n+    ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);\n+\n+    // Parse the response as well so we can log specific structured fields.\n+    Cluster cluster = PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), Cluster.class);\n+\n+    System.out.println(PRETTY_GSON.toJson(resp.getData()));\n+    System.out.printf(\"\\n\\nTo inspect logs in cloud storage, run the following:\\n\\n\");\n+\n+    // TODO(PD-4740): Use impersonation here instead.\n+    String keyPath = String.format(\"/tmp/%s-key.json\", workbenchProjectId);\n+    System.out.printf(\n+        \"    gcloud iam service-accounts keys create %s --iam-account %s\\n\",\n+        keyPath, workbenchServiceAccount);\n+    System.out.printf(\"    gcloud auth activate-service-account --key-file %s\\n\\n\", keyPath);\n+    System.out.printf(\"    gsutil ls gs://%s/**\\n\", cluster.getStagingBucket());\n+    System.out.printf(\"    gsutil cat ... # inspect or copy logs\\n\\n\");\n+    System.out.printf(\"    # Delete the key when done\\n\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYwMDA1MQ=="}, "originalCommit": {"oid": "fcd6e319c5a1e6191e255e6c6b2d5c421b5c8705"}, "originalPosition": 82}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3491, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}