{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NTUyMTMx", "number": 3032, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyNzowMVrODaTT-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDozMTo0OFrODa5aDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTA1OTc5OnYy", "diffSide": "RIGHT", "path": "api/config/config_local.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyNzowMVrOFhLmeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyNzowMVrOFhLmeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzNzQwMQ==", "bodyText": "Enabled this so I can actually test these changes. 'bypass all' should still work.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370337401", "createdAt": "2020-01-23T20:27:01Z", "author": {"login": "als364"}, "path": "api/config/config_local.json", "diffHunk": "@@ -74,7 +74,7 @@\n     \"enableMoodleBackend\": true\n   },\n   \"access\": {\n-    \"enableComplianceTraining\": false,\n+    \"enableComplianceTraining\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbb3a5a298cbf80282f117b86ac7a4665b9e976e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTA2MTYxOnYy", "diffSide": "RIGHT", "path": "api/config/config_test.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyNzo0OFrOFhLnuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyNzo0OFrOFhLnuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzNzcyMw==", "bodyText": "Why not also enable enableComplianceTraining on test?", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370337723", "createdAt": "2020-01-23T20:27:48Z", "author": {"login": "jaycarlton"}, "path": "api/config/config_test.json", "diffHunk": "@@ -84,7 +84,8 @@\n     \"unsafeAllowDeleteUser\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbb3a5a298cbf80282f117b86ac7a4665b9e976e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTA2NDAwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/google/CloudStorageServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyODozOFrOFhLpOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyODozOFrOFhLpOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzODEwNg==", "bodyText": "names up for debate. it's easy enough to change this, but the keys are different and I do have to go push files around in GCS to change the name.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370338106", "createdAt": "2020-01-23T20:28:38Z", "author": {"login": "als364"}, "path": "api/src/main/java/org/pmiops/workbench/google/CloudStorageServiceImpl.java", "diffHunk": "@@ -47,7 +47,11 @@ public String readMandrillApiKey() {\n \n   @Override\n   public String getMoodleApiKey() {\n-    return readCredentialsBucketString(\"moodle-key.txt\");\n+    if (configProvider.get().featureFlags.enableMoodleV2Api) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbb3a5a298cbf80282f117b86ac7a4665b9e976e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTA2NDc2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyODo1OFrOFhLpuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyODo1OFrOFhLpuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzODIzMg==", "bodyText": "Why did we move to the deprecated class here? Should this method be marked deprecated as well?", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370338232", "createdAt": "2020-01-23T20:28:58Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceService.java", "diffHunk": "@@ -22,5 +24,16 @@\n    * @return list of badges/completed training by user\n    * @throws ApiException\n    */\n-  List<BadgeDetails> getUserBadge(int userMoodleId) throws ApiException;\n+  List<BadgeDetailsDeprecated> getUserBadge(int userMoodleId) throws ApiException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fae3b654761a25daf0d901b6302d3d67db04bdf"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTA2NzYzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDozMDowM1rOFhLrnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDozMDowM1rOFhLrnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzODcxOQ==", "bodyText": "Can you please return an empty map instead of null? Otherwise, the next best thing is Optional<Map>, which is no less awkward. In general, if I call a method returning a collection in Java, I don't expect nor do I check for null.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370338719", "createdAt": "2020-01-23T20:30:03Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -84,4 +92,33 @@ public Integer getMoodleId(String email) throws ApiException {\n     }\n     return response.getBadges();\n   }\n+\n+  @Override\n+  public Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException {\n+    if (!enableMoodleCalls()) {\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fae3b654761a25daf0d901b6302d3d67db04bdf"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTA3MjM3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDozMTo1NFrOFhLuvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDozMTo1NFrOFhLuvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzOTUxNg==", "bodyText": "Please log this at a WARNING level (or at least INFO), so that we can track this down.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370339516", "createdAt": "2020-01-23T20:31:54Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -84,4 +92,33 @@ public Integer getMoodleId(String email) throws ApiException {\n     }\n     return response.getBadges();\n   }\n+\n+  @Override\n+  public Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException {\n+    if (!enableMoodleCalls()) {\n+      return null;\n+    }\n+\n+    UserBadgeResponse response =\n+        moodleApiProvider.get().getMoodleBadge(RESPONSE_FORMAT, getToken(), email);\n+    if (response.getException() != null && response.getException().equals(MOODLE_EXCEPTION)) {\n+      if (response.getErrorcode().equals(MOODLE_USER_NOT_ALLOWED_ERROR_CODE)) {\n+        throw new ApiException(HttpStatus.NOT_FOUND.value(), response.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fae3b654761a25daf0d901b6302d3d67db04bdf"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTA3NzM1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDozNDowN1rOFhLyBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDozNDowN1rOFhLyBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0MDM1Ng==", "bodyText": "This function is over a hundred lines long now. Can we split it into 4-5 pieces? I generally consider 20-line functions in need of a haircut.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370340356", "createdAt": "2020-01-23T20:34:07Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -555,46 +557,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fae3b654761a25daf0d901b6302d3d67db04bdf"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTA4MjQwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDozNjowNFrOFhL1NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDozNjowNFrOFhL1NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0MTE3Mw==", "bodyText": "Please add a clearComplianceTrainingCompletion() and clearComplianceTrainingExpiration() methods on DbUser so you don't have to pass null as your only argument. This will also help sweep the nullability of the timestamp under the rug in the entity class, so at the service level we don't need to think about it.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370341173", "createdAt": "2020-01-23T20:36:04Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -555,46 +557,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;\n+      if (configProvider.get().featureFlags.enableMoodleV2Api) {\n+        Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(email);\n+        if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+          BadgeDetails badge =\n+              userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+          expiryEpoch =\n+              badge.getGlobalexpiration() == null\n+                  ? badge.getDateexpire()\n+                  : badge.getGlobalexpiration();\n+        } else {\n+          // Moodle has not returned research ethics training information for the given user --\n+          // we should clear the user's training completion and expiration time.\n+          dbUser.setComplianceTrainingCompletionTime(null);\n+          dbUser.setComplianceTrainingExpirationTime(null);\n+        }\n+      } else {\n+        List<BadgeDetailsDeprecated> badgeResponse = complianceService.getUserBadge(moodleId);\n+        // The assumption here is that the User will always get 1 badge which will be AoU\n+        if (badgeResponse != null && badgeResponse.size() > 0) {\n+          BadgeDetailsDeprecated badge = badgeResponse.get(0);\n+          expiryEpoch = badge.getDateexpire();\n+        } else {\n+          // Moodle has returned zero badges for the given user -- we should clear the user's\n+          // training completion & expiration time.\n+          dbUser.setComplianceTrainingCompletionTime(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fae3b654761a25daf0d901b6302d3d67db04bdf"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTA5OTUwOnYy", "diffSide": "RIGHT", "path": "api/src/main/generated/org/pmiops/workbench/utils/WorkspaceMapperImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDo0MjoxN1rOFhL_fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQyMjoxMjozMFrOFhr1jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0MzgwNQ==", "bodyText": "The mapper impl files are generated at compile time, and should not be checked into source control.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370343805", "createdAt": "2020-01-23T20:42:17Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/generated/org/pmiops/workbench/utils/WorkspaceMapperImpl.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.pmiops.workbench.utils;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import javax.annotation.Generated;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.db.model.DbWorkspace;\n+import org.pmiops.workbench.firecloud.model.FirecloudWorkspace;\n+import org.pmiops.workbench.model.ResearchPurpose;\n+import org.pmiops.workbench.model.SpecificPopulationEnum;\n+import org.pmiops.workbench.model.UserRole;\n+import org.pmiops.workbench.model.Workspace;\n+import org.pmiops.workbench.utils.mappers.CommonMappers;\n+import org.springframework.stereotype.Component;\n+\n+@Generated(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2NTU1MA==", "bodyText": "something is clearly broken with gitignore.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370865550", "createdAt": "2020-01-24T22:12:30Z", "author": {"login": "als364"}, "path": "api/src/main/generated/org/pmiops/workbench/utils/WorkspaceMapperImpl.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.pmiops.workbench.utils;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import javax.annotation.Generated;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.db.model.DbWorkspace;\n+import org.pmiops.workbench.firecloud.model.FirecloudWorkspace;\n+import org.pmiops.workbench.model.ResearchPurpose;\n+import org.pmiops.workbench.model.SpecificPopulationEnum;\n+import org.pmiops.workbench.model.UserRole;\n+import org.pmiops.workbench.model.Workspace;\n+import org.pmiops.workbench.utils.mappers.CommonMappers;\n+import org.springframework.stereotype.Component;\n+\n+@Generated(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0MzgwNQ=="}, "originalCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTEwMjA2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDo0MzoxM1rOFhMBFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDo0MzoxM1rOFhMBFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NDIxNQ==", "bodyText": "There's lots of nesting and mutable state going on here, which makes it easy to write bugs.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370344215", "createdAt": "2020-01-23T20:43:13Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -582,46 +584,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;\n+      if (configProvider.get().featureFlags.enableMoodleV2Api) {\n+        Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(email);\n+        if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+          BadgeDetails badge =\n+              userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+          expiryEpoch =\n+              badge.getGlobalexpiration() == null\n+                  ? badge.getDateexpire()\n+                  : badge.getGlobalexpiration();\n+        } else {\n+          // Moodle has not returned research ethics training information for the given user --\n+          // we should clear the user's training completion and expiration time.\n+          dbUser.setComplianceTrainingCompletionTime(null);\n+          dbUser.setComplianceTrainingExpirationTime(null);\n+        }\n+      } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTEwMzkxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/google/CloudStorageServiceImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDo0Mzo1NFrOFhMCJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNjozOTo0NFrOFiJdpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NDQ4NQ==", "bodyText": "Please put these constants into a config file, and also rename them to indicate v1 vs v2 somehow.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370344485", "createdAt": "2020-01-23T20:43:54Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/google/CloudStorageServiceImpl.java", "diffHunk": "@@ -47,7 +47,12 @@ public String readMandrillApiKey() {\n \n   @Override\n   public String getMoodleApiKey() {\n-    return getCredentialsBucketString(\"moodle-key.txt\");\n+    if(configProvider.get().featureFlags.enableMoodleV2Api) {\n+      return getCredentialsBucketString(\"moodle.txt\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM0NzE0Mg==", "bodyText": "We don't yet have application config patterns, which is where these might need to go, or a parent JSON file that individual environments could override. I would still rename the credentials files moodle-key-v1.txt and moodle-key-v2.txt (or leave the current one alone).", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371347142", "createdAt": "2020-01-27T16:33:20Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/google/CloudStorageServiceImpl.java", "diffHunk": "@@ -47,7 +47,12 @@ public String readMandrillApiKey() {\n \n   @Override\n   public String getMoodleApiKey() {\n-    return getCredentialsBucketString(\"moodle-key.txt\");\n+    if(configProvider.get().featureFlags.enableMoodleV2Api) {\n+      return getCredentialsBucketString(\"moodle.txt\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NDQ4NQ=="}, "originalCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM1MDk0OA==", "bodyText": "Because we push these creds manually to google buckets I have to leave the current one alone for the meantime. I can rename the new one v2 though.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371350948", "createdAt": "2020-01-27T16:39:44Z", "author": {"login": "als364"}, "path": "api/src/main/java/org/pmiops/workbench/google/CloudStorageServiceImpl.java", "diffHunk": "@@ -47,7 +47,12 @@ public String readMandrillApiKey() {\n \n   @Override\n   public String getMoodleApiKey() {\n-    return getCredentialsBucketString(\"moodle-key.txt\");\n+    if(configProvider.get().featureFlags.enableMoodleV2Api) {\n+      return getCredentialsBucketString(\"moodle.txt\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NDQ4NQ=="}, "originalCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTExMTc3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDo0Njo0N1rOFhMG4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDo0Njo0N1rOFhMG4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NTY5Ng==", "bodyText": "I'm wondering why the badge- and moodle-specific logic needs to live in the UserService.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370345696", "createdAt": "2020-01-23T20:46:47Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -582,46 +584,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;\n+      if (configProvider.get().featureFlags.enableMoodleV2Api) {\n+        Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(email);\n+        if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+          BadgeDetails badge =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTExNjA3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDo0ODowNVrOFhMJZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDo0ODowNVrOFhMJZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NjM0MQ==", "bodyText": "Please make expiryEpoch an Optional, since it's not guaranteed to be there. You can do that with badgeResponse.stream().findFirst(), so you get rid of the scary get(0).", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370346341", "createdAt": "2020-01-23T20:48:05Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -582,46 +584,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;\n+      if (configProvider.get().featureFlags.enableMoodleV2Api) {\n+        Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(email);\n+        if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+          BadgeDetails badge =\n+              userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+          expiryEpoch =\n+              badge.getGlobalexpiration() == null\n+                  ? badge.getDateexpire()\n+                  : badge.getGlobalexpiration();\n+        } else {\n+          // Moodle has not returned research ethics training information for the given user --\n+          // we should clear the user's training completion and expiration time.\n+          dbUser.setComplianceTrainingCompletionTime(null);\n+          dbUser.setComplianceTrainingExpirationTime(null);\n+        }\n+      } else {\n+        List<BadgeDetailsDeprecated> badgeResponse = complianceService.getUserBadge(moodleId);\n+        // The assumption here is that the User will always get 1 badge which will be AoU\n+        if (badgeResponse != null && badgeResponse.size() > 0) {\n+          BadgeDetailsDeprecated badge = badgeResponse.get(0);\n+          expiryEpoch = badge.getDateexpire();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MjYzOTU4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwMDoyNTo1MVrOFhtqyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwMDoyNTo1MVrOFhtqyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5NTU2Mw==", "bodyText": "Please also add the @Deprecated annotation, which will make this more obvious. I'd probably just name it getUserBadgeV1(), in case you have to support more than one deprecated version. Let's hope not.\nThere's also a @deprecated javadoc annotation FWIW.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370895563", "createdAt": "2020-01-25T00:25:51Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceService.java", "diffHunk": "@@ -24,7 +24,7 @@\n    * @return list of badges/completed training by user\n    * @throws ApiException\n    */\n-  List<BadgeDetailsDeprecated> getUserBadge(int userMoodleId) throws ApiException;\n+  List<BadgeDetailsDeprecated> getUserBadgeDeprecated(int userMoodleId) throws ApiException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzA1NTEzOnYy", "diffSide": "RIGHT", "path": "api/config/config_local.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxOToxMDo1M1rOFhxA4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNjo1OToxOFrOFiKLlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDM2OQ==", "bodyText": "This new configuration pattern doesn't feel right to me.\nFirst, and I think most importantly, it introduces inconsistency with the way we handle filenames for other credentials / keys in downstream systems. (In all cases, the filenames are code-level constants and the credentials bucket path is generated from the cloud project name.) This adds mental burden for an oncall engineer trying to understand what lives where. Now doesn't feel like a great time to create new patterns like this \u2013\u00a0especially considering our existing convention has been around for ~3 years and hasn't caused any notable issues.\nAside from the inconsistency argument, I think it's incorrect to be storing two versions of the Moodle creds filename in the per-environment config. No environment should ever be using both of these filenames, right? At most we should have one field that varies by environment, and have each environment switch from \"moodle-key\" --> \"moodle-credentials-key\" when the v2 Moodle API is enabled. (But even with that solution, we'd effectively have two redundant flags controlling the same switch in environment behavior: featureFlags.enableMoodleV2Api and moodle.credentialsKeyFilename.)\nIt looks like this change was introduced in response to comments from @jaycarlton. Maybe we can quickly sync up on this today.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370950369", "createdAt": "2020-01-25T19:10:53Z", "author": {"login": "gjuggler"}, "path": "api/config/config_local.json", "diffHunk": "@@ -73,10 +73,12 @@\n   },\n   \"moodle\": {\n     \"host\": \"aoudev.nnlm.gov\",\n-    \"enableMoodleBackend\": true\n+    \"enableMoodleBackend\": true,\n+    \"credentialsKeyDeprecated\": \"moodle-key.txt\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM2MjcwOA==", "bodyText": "Coming back to this: post-renaming, I don't feel as strongly about this. Given we'll rip most of this stuff out once the v2 has launched to prod, that gives us a chance to reassess this pattern in a ~month's time anyway.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371362708", "createdAt": "2020-01-27T16:59:18Z", "author": {"login": "gjuggler"}, "path": "api/config/config_local.json", "diffHunk": "@@ -73,10 +73,12 @@\n   },\n   \"moodle\": {\n     \"host\": \"aoudev.nnlm.gov\",\n-    \"enableMoodleBackend\": true\n+    \"enableMoodleBackend\": true,\n+    \"credentialsKeyDeprecated\": \"moodle-key.txt\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDM2OQ=="}, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzA1NzkzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/api/OfflineUserController.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxOToxODoyOFrOFhxCRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxOToxODoyOFrOFhxCRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDcyNQ==", "bodyText": "Terminology note / nitpick: I think we should be consistent in how we're referring to v1 vs. v2 of the API.\nThe config feature flag implies we're treating these as \"v1\" vs \"v2\", but the code implies we're treating these as \"the deprecated version\" versus \"the current version\".\nMy slight preference would be to align on the v1-v2 distinction, partly because \"deprecated\" is long-winded, and partly because it's more clearly referring to different API versions.\nObviously, once this has rolled to prod and we clean up the feature flag, this would go back to having no distinction at all.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370950725", "createdAt": "2020-01-25T19:18:28Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/api/OfflineUserController.java", "diffHunk": "@@ -66,7 +73,12 @@ private boolean timestampsEqual(Timestamp a, Timestamp b) {\n         Timestamp oldTime = user.getComplianceTrainingCompletionTime();\n         DataAccessLevel oldLevel = user.getDataAccessLevelEnum();\n \n-        DbUser updatedUser = userService.syncComplianceTrainingStatus(user);\n+        DbUser updatedUser;\n+        if(workbenchConfigProvider.get().featureFlags.enableMoodleV2Api) {\n+          updatedUser = userService.syncComplianceTrainingStatus(user);\n+        } else {\n+          updatedUser = userService.syncComplianceTrainingStatusDeprecated(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzA1ODUyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxOToyMDoxM1rOFhxCnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNjoxOToxM1rOFiItWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDgxMg==", "bodyText": "[Naming super-nitpick] When I first read this method name, I thought the parameter would be a username. But the \"byName\" is saying something about the return map, not the parameter.\nIt might be slightly cleaner to call this \"getUserBadgesByBadgeName\", or maybe \"getUserBadgesMap\" which is more concise but less specific.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370950812", "createdAt": "2020-01-25T19:20:13Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceService.java", "diffHunk": "@@ -22,5 +24,16 @@\n    * @return list of badges/completed training by user\n    * @throws ApiException\n    */\n-  List<BadgeDetails> getUserBadge(int userMoodleId) throws ApiException;\n+  List<BadgeDetailsDeprecated> getUserBadgeDeprecated(int userMoodleId) throws ApiException;\n+\n+  /**\n+   * Get details about the Research Ethics Training and the Data Use Agreement badges for a user\n+   *\n+   * @param email\n+   * @return map of badge name to badge details\n+   * @throws ApiException\n+   */\n+  Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMzODU4NQ==", "bodyText": "I'm happy being verbose as long as I can tab-complete names", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371338585", "createdAt": "2020-01-27T16:19:13Z", "author": {"login": "als364"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceService.java", "diffHunk": "@@ -22,5 +24,16 @@\n    * @return list of badges/completed training by user\n    * @throws ApiException\n    */\n-  List<BadgeDetails> getUserBadge(int userMoodleId) throws ApiException;\n+  List<BadgeDetailsDeprecated> getUserBadgeDeprecated(int userMoodleId) throws ApiException;\n+\n+  /**\n+   * Get details about the Research Ethics Training and the Data Use Agreement badges for a user\n+   *\n+   * @param email\n+   * @return map of badge name to badge details\n+   * @throws ApiException\n+   */\n+  Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDgxMg=="}, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzA1OTcwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxOToyMzoyMFrOFhxDKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNTo1Mzo1OVrOFiHwBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDk1NQ==", "bodyText": "[Naming nit] Inconsistency here: the map is called \"badges by name\", but the key variables are called \"fields\". Consider aligning everything with the \"name\" terminology, e.g. rename the constants to\nDATA_USE_AGREEMENT_BADGE or\nDUA_BADGE_NAME\nor something similar.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370950955", "createdAt": "2020-01-25T19:23:20Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -84,4 +96,34 @@ public Integer getMoodleId(String email) throws ApiException {\n     }\n     return response.getBadges();\n   }\n+\n+  @Override\n+  public Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException {\n+    if (!enableMoodleCalls()) {\n+      return new HashMap<>();\n+    }\n+\n+    UserBadgeResponse response =\n+        moodleApiProvider.get().getMoodleBadge(RESPONSE_FORMAT, getToken(), email);\n+    if (response.getException() != null && response.getException().equals(MOODLE_EXCEPTION)) {\n+      logger.warning(response.getMessage());\n+      if (response.getErrorcode().equals(MOODLE_USER_NOT_ALLOWED_ERROR_CODE)) {\n+        throw new ApiException(HttpStatus.NOT_FOUND.value(), response.getMessage());\n+      } else {\n+        throw new ApiException(response.getMessage());\n+      }\n+    }\n+    Map<String, BadgeDetails> userBadgesByName = new HashMap<>();\n+    if (response.getDua() != null) {\n+      userBadgesByName.put(DUA_FIELD, response.getDua());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMyMjg4Nw==", "bodyText": "This is probably a holdover from how Zak and/or Moodle talks about the data they return.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371322887", "createdAt": "2020-01-27T15:53:59Z", "author": {"login": "als364"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -84,4 +96,34 @@ public Integer getMoodleId(String email) throws ApiException {\n     }\n     return response.getBadges();\n   }\n+\n+  @Override\n+  public Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException {\n+    if (!enableMoodleCalls()) {\n+      return new HashMap<>();\n+    }\n+\n+    UserBadgeResponse response =\n+        moodleApiProvider.get().getMoodleBadge(RESPONSE_FORMAT, getToken(), email);\n+    if (response.getException() != null && response.getException().equals(MOODLE_EXCEPTION)) {\n+      logger.warning(response.getMessage());\n+      if (response.getErrorcode().equals(MOODLE_USER_NOT_ALLOWED_ERROR_CODE)) {\n+        throw new ApiException(HttpStatus.NOT_FOUND.value(), response.getMessage());\n+      } else {\n+        throw new ApiException(response.getMessage());\n+      }\n+    }\n+    Map<String, BadgeDetails> userBadgesByName = new HashMap<>();\n+    if (response.getDua() != null) {\n+      userBadgesByName.put(DUA_FIELD, response.getDua());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDk1NQ=="}, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzA3NTU2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQyMDowNDoyMFrOFhxLLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNjozODozN1rOFiJbHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzAwNg==", "bodyText": "Shouldn't these lines be in the form: u.setFoo(dbUser.getFoo())", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370953006", "createdAt": "2020-01-25T20:04:20Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -646,6 +648,78 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n     }\n   }\n \n+  /** Syncs the current user's training status from Moodle. */\n+  public DbUser syncComplianceTrainingStatus() throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    return syncComplianceTrainingStatus(userProvider.get());\n+  }\n+\n+  /**\n+   * Updates the given user's training status from Moodle.\n+   *\n+   * <p>We can fetch Moodle data for arbitrary users since we use an API key to access Moodle,\n+   * rather than user-specific OAuth tokens.\n+   *\n+   * <p>Using the user's email, we can get their badges from Moodle's APIs. If the badges are marked\n+   * valid, we store their completion/expiration dates in the database. If they are marked invalid,\n+   * we clear the completion/expiration dates from the database as the user will need to complete a\n+   * new training.\n+   */\n+  public DbUser syncComplianceTrainingStatus(DbUser dbUser) throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    // Skip sync for service account user rows.\n+    if (isServiceAccount(dbUser)) {\n+      return dbUser;\n+    }\n+\n+    try {\n+      Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n+      Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(dbUser.getUsername());\n+      if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+        BadgeDetails complianceBadge = userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+        if(complianceBadge.getValid()) {\n+          if (dbUser.getComplianceTrainingCompletionTime() == null) {\n+            // The badge was previously invalid and is now valid.\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          } else if (!dbUser.getComplianceTrainingExpirationTime().equals(new Timestamp(complianceBadge.getDateexpire()))) {\n+            // The badge was previously valid, but has a new expiration date (and so is a new training)\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          }\n+          // Always update the expiration time.\n+          dbUser.setComplianceTrainingExpirationTime(new Timestamp(complianceBadge.getDateexpire()));\n+        }\n+        else {\n+          // The current badge is invalid or expired, the training must be completed or retaken.\n+          dbUser.clearComplianceTrainingCompletionTime();\n+          dbUser.clearComplianceTrainingExpirationTime();\n+        }\n+      }\n+      else {\n+        // There is no record of this person having taken the training.\n+        dbUser.clearComplianceTrainingCompletionTime();\n+        dbUser.clearComplianceTrainingExpirationTime();\n+      }\n+\n+      return updateUserWithRetries(\n+          u -> {\n+            u.setComplianceTrainingExpirationTime(u.getComplianceTrainingExpirationTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMyOTE0Mg==", "bodyText": "dbUser is u here. I just kind of cargo culted this block over from the last function.\nLooking at updateUserWithRetries now, it applies the function passed to it to the user passed to it and also sets lastModifiedTime and enforces data access level changes as a side effect of aforementioned function.\nThese Moodle functions are the only place we do something like this - everywhere else we pass in a value unattached to the dbUser we're changing.  I think that, as originally intended, this function was mean to apply changes calculated elsewhere and we're just mutating dbUser so as to not have to think about nullity semantics\nWhat do you think about something like:\nTimestamp newComplianceTrainingCompletionTime = null;\nTimestamp newComplianceTrainingExpirationTime = null;\n{...}\nif (badge valid) {\n    if (badge was previously invalid and is now valid) {\n        newComplianceTrainingCompletionTime = now\n    } else if (old expiry time is not new expiry time) {\n        newComplianceTrainingCompletionTime = now\n    }\n    newComplianceTrainingExpirationTime = badgeExpiryDate\n}\n// get rid of all the lines nulling out timestamps and get rid of those 'clear' functions\n{...}\nreturn updateUserWithRetries(u -> {\n    u.setComplianceTrainingCompletionTime(newComplianceTrainingCompletionTime);\n    u.setComplianceTrainingExpirationTime(newComplianceTrainingExpirationTime);\n}, dbUser);", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371329142", "createdAt": "2020-01-27T16:03:40Z", "author": {"login": "als364"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -646,6 +648,78 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n     }\n   }\n \n+  /** Syncs the current user's training status from Moodle. */\n+  public DbUser syncComplianceTrainingStatus() throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    return syncComplianceTrainingStatus(userProvider.get());\n+  }\n+\n+  /**\n+   * Updates the given user's training status from Moodle.\n+   *\n+   * <p>We can fetch Moodle data for arbitrary users since we use an API key to access Moodle,\n+   * rather than user-specific OAuth tokens.\n+   *\n+   * <p>Using the user's email, we can get their badges from Moodle's APIs. If the badges are marked\n+   * valid, we store their completion/expiration dates in the database. If they are marked invalid,\n+   * we clear the completion/expiration dates from the database as the user will need to complete a\n+   * new training.\n+   */\n+  public DbUser syncComplianceTrainingStatus(DbUser dbUser) throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    // Skip sync for service account user rows.\n+    if (isServiceAccount(dbUser)) {\n+      return dbUser;\n+    }\n+\n+    try {\n+      Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n+      Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(dbUser.getUsername());\n+      if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+        BadgeDetails complianceBadge = userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+        if(complianceBadge.getValid()) {\n+          if (dbUser.getComplianceTrainingCompletionTime() == null) {\n+            // The badge was previously invalid and is now valid.\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          } else if (!dbUser.getComplianceTrainingExpirationTime().equals(new Timestamp(complianceBadge.getDateexpire()))) {\n+            // The badge was previously valid, but has a new expiration date (and so is a new training)\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          }\n+          // Always update the expiration time.\n+          dbUser.setComplianceTrainingExpirationTime(new Timestamp(complianceBadge.getDateexpire()));\n+        }\n+        else {\n+          // The current badge is invalid or expired, the training must be completed or retaken.\n+          dbUser.clearComplianceTrainingCompletionTime();\n+          dbUser.clearComplianceTrainingExpirationTime();\n+        }\n+      }\n+      else {\n+        // There is no record of this person having taken the training.\n+        dbUser.clearComplianceTrainingCompletionTime();\n+        dbUser.clearComplianceTrainingExpirationTime();\n+      }\n+\n+      return updateUserWithRetries(\n+          u -> {\n+            u.setComplianceTrainingExpirationTime(u.getComplianceTrainingExpirationTime());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzAwNg=="}, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM0MTM4Mw==", "bodyText": "\ud83d\udc4d That approach seems much better, especially if it's more consistent with how we do it elsewhere.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371341383", "createdAt": "2020-01-27T16:23:51Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -646,6 +648,78 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n     }\n   }\n \n+  /** Syncs the current user's training status from Moodle. */\n+  public DbUser syncComplianceTrainingStatus() throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    return syncComplianceTrainingStatus(userProvider.get());\n+  }\n+\n+  /**\n+   * Updates the given user's training status from Moodle.\n+   *\n+   * <p>We can fetch Moodle data for arbitrary users since we use an API key to access Moodle,\n+   * rather than user-specific OAuth tokens.\n+   *\n+   * <p>Using the user's email, we can get their badges from Moodle's APIs. If the badges are marked\n+   * valid, we store their completion/expiration dates in the database. If they are marked invalid,\n+   * we clear the completion/expiration dates from the database as the user will need to complete a\n+   * new training.\n+   */\n+  public DbUser syncComplianceTrainingStatus(DbUser dbUser) throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    // Skip sync for service account user rows.\n+    if (isServiceAccount(dbUser)) {\n+      return dbUser;\n+    }\n+\n+    try {\n+      Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n+      Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(dbUser.getUsername());\n+      if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+        BadgeDetails complianceBadge = userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+        if(complianceBadge.getValid()) {\n+          if (dbUser.getComplianceTrainingCompletionTime() == null) {\n+            // The badge was previously invalid and is now valid.\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          } else if (!dbUser.getComplianceTrainingExpirationTime().equals(new Timestamp(complianceBadge.getDateexpire()))) {\n+            // The badge was previously valid, but has a new expiration date (and so is a new training)\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          }\n+          // Always update the expiration time.\n+          dbUser.setComplianceTrainingExpirationTime(new Timestamp(complianceBadge.getDateexpire()));\n+        }\n+        else {\n+          // The current badge is invalid or expired, the training must be completed or retaken.\n+          dbUser.clearComplianceTrainingCompletionTime();\n+          dbUser.clearComplianceTrainingExpirationTime();\n+        }\n+      }\n+      else {\n+        // There is no record of this person having taken the training.\n+        dbUser.clearComplianceTrainingCompletionTime();\n+        dbUser.clearComplianceTrainingExpirationTime();\n+      }\n+\n+      return updateUserWithRetries(\n+          u -> {\n+            u.setComplianceTrainingExpirationTime(u.getComplianceTrainingExpirationTime());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzAwNg=="}, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM0NjEzNg==", "bodyText": "nit: This still feels more badgey than usery, and like the kind of thing that could go in its own little service. While we have a very wide data model for the user table, we don't have to make its service know everything about how to calculate those columns.\nFWIW, there are a handful of things whose recalculation is triggered on every user \"change\", and that's one of the main motivations of the withRetries() stuff.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371346136", "createdAt": "2020-01-27T16:31:39Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -646,6 +648,78 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n     }\n   }\n \n+  /** Syncs the current user's training status from Moodle. */\n+  public DbUser syncComplianceTrainingStatus() throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    return syncComplianceTrainingStatus(userProvider.get());\n+  }\n+\n+  /**\n+   * Updates the given user's training status from Moodle.\n+   *\n+   * <p>We can fetch Moodle data for arbitrary users since we use an API key to access Moodle,\n+   * rather than user-specific OAuth tokens.\n+   *\n+   * <p>Using the user's email, we can get their badges from Moodle's APIs. If the badges are marked\n+   * valid, we store their completion/expiration dates in the database. If they are marked invalid,\n+   * we clear the completion/expiration dates from the database as the user will need to complete a\n+   * new training.\n+   */\n+  public DbUser syncComplianceTrainingStatus(DbUser dbUser) throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    // Skip sync for service account user rows.\n+    if (isServiceAccount(dbUser)) {\n+      return dbUser;\n+    }\n+\n+    try {\n+      Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n+      Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(dbUser.getUsername());\n+      if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+        BadgeDetails complianceBadge = userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+        if(complianceBadge.getValid()) {\n+          if (dbUser.getComplianceTrainingCompletionTime() == null) {\n+            // The badge was previously invalid and is now valid.\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          } else if (!dbUser.getComplianceTrainingExpirationTime().equals(new Timestamp(complianceBadge.getDateexpire()))) {\n+            // The badge was previously valid, but has a new expiration date (and so is a new training)\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          }\n+          // Always update the expiration time.\n+          dbUser.setComplianceTrainingExpirationTime(new Timestamp(complianceBadge.getDateexpire()));\n+        }\n+        else {\n+          // The current badge is invalid or expired, the training must be completed or retaken.\n+          dbUser.clearComplianceTrainingCompletionTime();\n+          dbUser.clearComplianceTrainingExpirationTime();\n+        }\n+      }\n+      else {\n+        // There is no record of this person having taken the training.\n+        dbUser.clearComplianceTrainingCompletionTime();\n+        dbUser.clearComplianceTrainingExpirationTime();\n+      }\n+\n+      return updateUserWithRetries(\n+          u -> {\n+            u.setComplianceTrainingExpirationTime(u.getComplianceTrainingExpirationTime());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzAwNg=="}, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM1MDMwMQ==", "bodyText": "I'd be ok with moving it, but I'd rather do so after deprecating the old call so that I don't have to either have the v1 and v2 in separate places or move the deprecated function.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371350301", "createdAt": "2020-01-27T16:38:37Z", "author": {"login": "als364"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -646,6 +648,78 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n     }\n   }\n \n+  /** Syncs the current user's training status from Moodle. */\n+  public DbUser syncComplianceTrainingStatus() throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    return syncComplianceTrainingStatus(userProvider.get());\n+  }\n+\n+  /**\n+   * Updates the given user's training status from Moodle.\n+   *\n+   * <p>We can fetch Moodle data for arbitrary users since we use an API key to access Moodle,\n+   * rather than user-specific OAuth tokens.\n+   *\n+   * <p>Using the user's email, we can get their badges from Moodle's APIs. If the badges are marked\n+   * valid, we store their completion/expiration dates in the database. If they are marked invalid,\n+   * we clear the completion/expiration dates from the database as the user will need to complete a\n+   * new training.\n+   */\n+  public DbUser syncComplianceTrainingStatus(DbUser dbUser) throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    // Skip sync for service account user rows.\n+    if (isServiceAccount(dbUser)) {\n+      return dbUser;\n+    }\n+\n+    try {\n+      Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n+      Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(dbUser.getUsername());\n+      if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+        BadgeDetails complianceBadge = userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+        if(complianceBadge.getValid()) {\n+          if (dbUser.getComplianceTrainingCompletionTime() == null) {\n+            // The badge was previously invalid and is now valid.\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          } else if (!dbUser.getComplianceTrainingExpirationTime().equals(new Timestamp(complianceBadge.getDateexpire()))) {\n+            // The badge was previously valid, but has a new expiration date (and so is a new training)\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          }\n+          // Always update the expiration time.\n+          dbUser.setComplianceTrainingExpirationTime(new Timestamp(complianceBadge.getDateexpire()));\n+        }\n+        else {\n+          // The current badge is invalid or expired, the training must be completed or retaken.\n+          dbUser.clearComplianceTrainingCompletionTime();\n+          dbUser.clearComplianceTrainingExpirationTime();\n+        }\n+      }\n+      else {\n+        // There is no record of this person having taken the training.\n+        dbUser.clearComplianceTrainingCompletionTime();\n+        dbUser.clearComplianceTrainingExpirationTime();\n+      }\n+\n+      return updateUserWithRetries(\n+          u -> {\n+            u.setComplianceTrainingExpirationTime(u.getComplianceTrainingExpirationTime());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzAwNg=="}, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzA3NjAxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQyMDowNTozNVrOFhxLZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNjoxMzo1NVrOFiIg7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzA2Mw==", "bodyText": "I think it would be helpful to have this log for other types of error codes too \u2013\u00a0maybe bump this up a couple lines outside of the if-else block?", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370953063", "createdAt": "2020-01-25T20:05:35Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -646,6 +648,78 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n     }\n   }\n \n+  /** Syncs the current user's training status from Moodle. */\n+  public DbUser syncComplianceTrainingStatus() throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    return syncComplianceTrainingStatus(userProvider.get());\n+  }\n+\n+  /**\n+   * Updates the given user's training status from Moodle.\n+   *\n+   * <p>We can fetch Moodle data for arbitrary users since we use an API key to access Moodle,\n+   * rather than user-specific OAuth tokens.\n+   *\n+   * <p>Using the user's email, we can get their badges from Moodle's APIs. If the badges are marked\n+   * valid, we store their completion/expiration dates in the database. If they are marked invalid,\n+   * we clear the completion/expiration dates from the database as the user will need to complete a\n+   * new training.\n+   */\n+  public DbUser syncComplianceTrainingStatus(DbUser dbUser) throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    // Skip sync for service account user rows.\n+    if (isServiceAccount(dbUser)) {\n+      return dbUser;\n+    }\n+\n+    try {\n+      Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n+      Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(dbUser.getUsername());\n+      if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+        BadgeDetails complianceBadge = userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+        if(complianceBadge.getValid()) {\n+          if (dbUser.getComplianceTrainingCompletionTime() == null) {\n+            // The badge was previously invalid and is now valid.\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          } else if (!dbUser.getComplianceTrainingExpirationTime().equals(new Timestamp(complianceBadge.getDateexpire()))) {\n+            // The badge was previously valid, but has a new expiration date (and so is a new training)\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          }\n+          // Always update the expiration time.\n+          dbUser.setComplianceTrainingExpirationTime(new Timestamp(complianceBadge.getDateexpire()));\n+        }\n+        else {\n+          // The current badge is invalid or expired, the training must be completed or retaken.\n+          dbUser.clearComplianceTrainingCompletionTime();\n+          dbUser.clearComplianceTrainingExpirationTime();\n+        }\n+      }\n+      else {\n+        // There is no record of this person having taken the training.\n+        dbUser.clearComplianceTrainingCompletionTime();\n+        dbUser.clearComplianceTrainingExpirationTime();\n+      }\n+\n+      return updateUserWithRetries(\n+          u -> {\n+            u.setComplianceTrainingExpirationTime(u.getComplianceTrainingExpirationTime());\n+            u.setComplianceTrainingCompletionTime(u.getComplianceTrainingCompletionTime());\n+            return u;\n+          },\n+          dbUser);\n+    } catch (NumberFormatException e) {\n+      log.severe(\"Incorrect date expire format from Moodle\");\n+      throw e;\n+    } catch (org.pmiops.workbench.moodle.ApiException ex) {\n+      if (ex.getCode() == HttpStatus.NOT_FOUND.value()) {\n+        log.severe(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMzNTQwNA==", "bodyText": "I'll put a different log but this one is for a specific reason, the message is just unclear", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371335404", "createdAt": "2020-01-27T16:13:55Z", "author": {"login": "als364"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -646,6 +648,78 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n     }\n   }\n \n+  /** Syncs the current user's training status from Moodle. */\n+  public DbUser syncComplianceTrainingStatus() throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    return syncComplianceTrainingStatus(userProvider.get());\n+  }\n+\n+  /**\n+   * Updates the given user's training status from Moodle.\n+   *\n+   * <p>We can fetch Moodle data for arbitrary users since we use an API key to access Moodle,\n+   * rather than user-specific OAuth tokens.\n+   *\n+   * <p>Using the user's email, we can get their badges from Moodle's APIs. If the badges are marked\n+   * valid, we store their completion/expiration dates in the database. If they are marked invalid,\n+   * we clear the completion/expiration dates from the database as the user will need to complete a\n+   * new training.\n+   */\n+  public DbUser syncComplianceTrainingStatus(DbUser dbUser) throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    // Skip sync for service account user rows.\n+    if (isServiceAccount(dbUser)) {\n+      return dbUser;\n+    }\n+\n+    try {\n+      Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n+      Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(dbUser.getUsername());\n+      if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+        BadgeDetails complianceBadge = userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+        if(complianceBadge.getValid()) {\n+          if (dbUser.getComplianceTrainingCompletionTime() == null) {\n+            // The badge was previously invalid and is now valid.\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          } else if (!dbUser.getComplianceTrainingExpirationTime().equals(new Timestamp(complianceBadge.getDateexpire()))) {\n+            // The badge was previously valid, but has a new expiration date (and so is a new training)\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          }\n+          // Always update the expiration time.\n+          dbUser.setComplianceTrainingExpirationTime(new Timestamp(complianceBadge.getDateexpire()));\n+        }\n+        else {\n+          // The current badge is invalid or expired, the training must be completed or retaken.\n+          dbUser.clearComplianceTrainingCompletionTime();\n+          dbUser.clearComplianceTrainingExpirationTime();\n+        }\n+      }\n+      else {\n+        // There is no record of this person having taken the training.\n+        dbUser.clearComplianceTrainingCompletionTime();\n+        dbUser.clearComplianceTrainingExpirationTime();\n+      }\n+\n+      return updateUserWithRetries(\n+          u -> {\n+            u.setComplianceTrainingExpirationTime(u.getComplianceTrainingExpirationTime());\n+            u.setComplianceTrainingCompletionTime(u.getComplianceTrainingCompletionTime());\n+            return u;\n+          },\n+          dbUser);\n+    } catch (NumberFormatException e) {\n+      log.severe(\"Incorrect date expire format from Moodle\");\n+      throw e;\n+    } catch (org.pmiops.workbench.moodle.ApiException ex) {\n+      if (ex.getCode() == HttpStatus.NOT_FOUND.value()) {\n+        log.severe(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzA2Mw=="}, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NTMwMTI0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDozMTo0OFrOFiEqDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNjoxODo0OFrOFiIsVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MjIwNQ==", "bodyText": "Hmm. Somehow, the workspace mapper impl file lives in a genenrated dir, which explians why it doesn't get picked up: workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/WorkspaceMapperImpl.java\nI don't believe we want to . mask *Impl.java, as it would match lots fo our implementation services.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371272205", "createdAt": "2020-01-27T14:31:48Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -1,14 +1,20 @@\n package org.pmiops.workbench.compliance;\n \n+import java.util.HashMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMzODMyNw==", "bodyText": "What is this comment in reference to? I don't think it is actually about importing HashMap", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371338327", "createdAt": "2020-01-27T16:18:48Z", "author": {"login": "als364"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -1,14 +1,20 @@\n package org.pmiops.workbench.compliance;\n \n+import java.util.HashMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MjIwNQ=="}, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 3}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3483, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}