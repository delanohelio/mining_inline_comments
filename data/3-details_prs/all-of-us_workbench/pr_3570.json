{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2NDYxNzAw", "number": 3570, "title": "[RW-4934][risk=no] Task to archive Stackdriver configuration as JSON or YAML", "bodyText": "This task visits all the passed-in environments and lists assets of various types and saves them to JSON. Note that if there are no filters, it's about a 25 MB zip file.\nFiles are written to directories generated by their formal GCP identifiers, which conveniently include the project names. I use a sortable timestamp (sans slashes and colons) for the file names.\nRun this with\n./devops.rb --task=backup-config --envs-file=monitoring_env_targets.json --output-dir=~/scratch/config_dump\n\nThe input file should be this file or a subset of it for our projects. It's a good idea to make a copy and drop local so it doesn't run all the test environment fetches twice.\nOutput archive is on Google Drive.\nI just realized Stackdriver names dashboards using the project number and not the project ID. I'm thinking about changing things so that we have a directory for each environment's short name above projects so at least they stay together.\n\nNote that if you run it in IntelliJ you get nice hyperlinks to the files created.\n\n\nPR checklist\n\n This PR meets the Acceptance Criteria in the JIRA story\n The JIRA story has been moved to Dev Review\n This PR includes appropriate unit tests\n I have run and tested this change locally\n I have run the E2E tests on ths change against my local UI + API server with yarn test-local\n If this includes a UI change, I have taken screen recordings or screenshots of the new behavior and notified the PO and UX designer\n If this includes an API change, I have updated the appropriate Swagger definitions and notified API consumers\n If this includes a new feature flag, I have created and linked new JIRA tickets to (a) turn on the feature flag and (b) remove it later", "createdAt": "2020-05-12T03:25:26Z", "url": "https://github.com/all-of-us/workbench/pull/3570", "merged": true, "mergeCommit": {"oid": "c9954a3324c268d71eb00176d2d00e8f6138d39d"}, "closed": true, "closedAt": "2020-05-19T19:27:02Z", "author": {"login": "jaycarlton"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcgXRMFgH2gAyNDE2NDYxNzAwOjhhZmZmYWUzM2M4MjBhZDY2ZDdmMTE4MjYyMDUzNmQ0ODZiOTBiNmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABci3OgkAFqTQxNDYzMDc2Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8afffae33c820ad66d7f1182620536d486b90b6e", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/8afffae33c820ad66d7f1182620536d486b90b6e", "committedDate": "2020-05-11T22:18:15Z", "message": "first working version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fed750db3a9e1977efed23454a70803be8590b72", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/fed750db3a9e1977efed23454a70803be8590b72", "committedDate": "2020-05-11T22:36:36Z", "message": "fix the path order"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02f8f317c71436dd5603b2ed10c44d1f105579b3", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/02f8f317c71436dd5603b2ed10c44d1f105579b3", "committedDate": "2020-05-11T22:58:42Z", "message": "new folder structure, but filename has slashes in the date string"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b66e6992968b74eaccbaf9a1413988253720a8ef", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/b66e6992968b74eaccbaf9a1413988253720a8ef", "committedDate": "2020-05-12T01:22:39Z", "message": "fix filenames"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbbe7517d758496efe58ce6e67fdc99bdd4ac0a7", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/bbbe7517d758496efe58ce6e67fdc99bdd4ac0a7", "committedDate": "2020-05-12T02:13:16Z", "message": "fixes & add groups and notification channels"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbd3a364df8621b0c7aa6702ecfeedd76e2bb562", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/cbd3a364df8621b0c7aa6702ecfeedd76e2bb562", "committedDate": "2020-05-12T03:03:50Z", "message": "uncomment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3186aa27e685e22c409346eb52579c5eef62dc2", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/f3186aa27e685e22c409346eb52579c5eef62dc2", "committedDate": "2020-05-12T03:20:35Z", "message": "pretty print JSON using a hash"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ff3c7157e8d38e17a926f1f937f2f02a7ed4056", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/6ff3c7157e8d38e17a926f1f937f2f02a7ed4056", "committedDate": "2020-05-12T14:59:33Z", "message": "fix yaml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cd6153e4fa0e8fde00b5c63a526d6c26ad7e0e7", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/4cd6153e4fa0e8fde00b5c63a526d6c26ad7e0e7", "committedDate": "2020-05-12T21:54:39Z", "message": "no need to change the Gemfile"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "425481d172c63a38c97b7785745cd0c455e4182c", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/425481d172c63a38c97b7785745cd0c455e4182c", "committedDate": "2020-05-12T21:57:55Z", "message": "restore default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ea1e7adb704eb6f3527f08fab13d6ada51006ea", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/4ea1e7adb704eb6f3527f08fab13d6ada51006ea", "committedDate": "2020-05-12T22:13:00Z", "message": "fix format switch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45e726d41e9052cf1709d8113407585291742e43", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/45e726d41e9052cf1709d8113407585291742e43", "committedDate": "2020-05-12T22:18:31Z", "message": "readme update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e3263858fb80cd1dcf1465fddbf3812a9925366", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/0e3263858fb80cd1dcf1465fddbf3812a9925366", "committedDate": "2020-05-12T22:47:49Z", "message": "dashboards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "755bae78bd7e05d435b583dd9841913b3b4af371", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/755bae78bd7e05d435b583dd9841913b3b4af371", "committedDate": "2020-05-13T15:45:26Z", "message": "Merge branch 'master' into jaycarlton/RW-4934"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820", "committedDate": "2020-05-13T16:16:07Z", "message": "fix client initialization and JSON and YAML conventions for camelCase and only supported field"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMzE0NzM2", "url": "https://github.com/all-of-us/workbench/pull/3570#pullrequestreview-411314736", "createdAt": "2020-05-13T21:31:45Z", "commit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTozMTo0NVrOGVERNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTo0OToyMFrOGVEwLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0MzIyMw==", "bodyText": "other..", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424743223", "createdAt": "2020-05-13T21:31:45Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "diffHunk": "@@ -1,65 +1,227 @@\n require \"google/cloud/monitoring\"\n require 'logger'\n+require 'json'\n \n require_relative \"./lib/service_account_manager\"\n require_relative './lib/gcp_environment_visitor'\n \n CUSTOM_METRIC_FILTER = \"metric.type = starts_with(\\\"custom.googleapis.com/\\\")\"\n LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/\\\")\"\n USER_LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/user/\\\")\"\n+FILE_SUFFIXES = {:yaml => '.yaml', :json => '.json'}\n \n class MonitoringAssets\n-  def initialize(envs_path, logger = Logger.new(STDOUT))\n+  def initialize(envs_path, output_dir='.', logger = Logger.new(STDOUT), output_format = :yaml)\n     @visitor = GcpEnvironmentVisitor.new(envs_path, logger)\n+    @output_dir = output_dir\n     @logger = logger\n+    @output_format = output_format\n   end\n \n+  attr_accessor(:current_env, :metric_client, :project_path, :alert_client)\n+  attr_reader(:visitor, :logger, :output_dir)\n+\n   # Demonstrate a simple usage of the AouEnvironmentVisitor with a few read-only operations\n   # on monitoring things in all the environments.\n   def inventory\n-    @visitor.visit do |env|\n+    visit_envs do |env_bundle|\n       counts  = {}\n-      metric_client = Google::Cloud::Monitoring::Metric.new\n-      metric_project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(env.project_id)\n+      # pp env_bundle\n+      # exit\n+      metric_client = @metric_client\n \n-      resources = metric_client.list_monitored_resource_descriptors(metric_project_path)\n-      @logger.info(\"found #{resources.count} monitored resources\")\n+      resources = metric_client.list_monitored_resource_descriptors(@project_path)\n+      logger.info(\"found #{resources.count} monitored resources\")\n       counts['monitored_resources'] = resources.count\n \n-      all_metrics = metric_client.list_metric_descriptors(metric_project_path)\n+      all_metrics = metric_client.list_metric_descriptors(@project_path)\n       counts['metric_descriptors'] =  all_metrics.count\n-      @logger.info(\"found #{all_metrics.count} metric descriptors\")\n+      logger.info(\"found #{all_metrics.count} metric descriptors\")\n \n-      custom_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: CUSTOM_METRIC_FILTER})\n-      @logger.info(\"found  #{custom_metrics.count} custom metrics\")\n+      custom_metrics = metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+      logger.info(\"found  #{custom_metrics.count} custom metrics\")\n       counts['custom_metrics'] = custom_metrics.count\n       custom_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      user_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+      user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n       counts['user_logs_based_metrics'] = user_logs_based_metrics.count\n-      @logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n+      logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n \n       user_logs_based_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      total_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: LOGS_BASED_METRIC_FILTER})\n-      @logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n+      total_logs_based_metrics = metric_client.list_metric_descriptors(@project_path, {filter: LOGS_BASED_METRIC_FILTER})\n+      logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n \n-      alerts_client = Google::Cloud::Monitoring::V3::AlertPolicyServiceClient.new\n-      policies = alerts_client.list_alert_policies(env.formatted_project_name)\n-      @logger.info(\"found #{policies.count} alerting policies\")\n+      policies = @alert_client.list_alert_policies(@project_path)\n+      logger.info(\"found #{policies.count} alerting policies\")\n       counts['policies'] = policies.count\n \n       policies.each do |policy|\n-        @logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n+        logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n       end\n \n-      @logger.info(\"Total counts for #{env.short_name}: #{counts}\")\n+      logger.info(\"Total counts for #{@current_env.short_name}: #{counts}\")\n+    end\n+  end\n+\n+  DO_BACKUP_ALL = false # TODO(jaycarlton): make this an option\n+\n+  # For every environment in the envs_file, fetch all items of interest from the appropriate\n+  # Stackdriver APIs. (Note that in future we may wish to broaden this to other )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0NDM2Mw==", "bodyText": "I assume adding this twice was not intentional", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424744363", "createdAt": "2020-05-13T21:34:18Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "diffHunk": "@@ -1,65 +1,227 @@\n require \"google/cloud/monitoring\"\n require 'logger'\n+require 'json'\n \n require_relative \"./lib/service_account_manager\"\n require_relative './lib/gcp_environment_visitor'\n \n CUSTOM_METRIC_FILTER = \"metric.type = starts_with(\\\"custom.googleapis.com/\\\")\"\n LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/\\\")\"\n USER_LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/user/\\\")\"\n+FILE_SUFFIXES = {:yaml => '.yaml', :json => '.json'}\n \n class MonitoringAssets\n-  def initialize(envs_path, logger = Logger.new(STDOUT))\n+  def initialize(envs_path, output_dir='.', logger = Logger.new(STDOUT), output_format = :yaml)\n     @visitor = GcpEnvironmentVisitor.new(envs_path, logger)\n+    @output_dir = output_dir\n     @logger = logger\n+    @output_format = output_format\n   end\n \n+  attr_accessor(:current_env, :metric_client, :project_path, :alert_client)\n+  attr_reader(:visitor, :logger, :output_dir)\n+\n   # Demonstrate a simple usage of the AouEnvironmentVisitor with a few read-only operations\n   # on monitoring things in all the environments.\n   def inventory\n-    @visitor.visit do |env|\n+    visit_envs do |env_bundle|\n       counts  = {}\n-      metric_client = Google::Cloud::Monitoring::Metric.new\n-      metric_project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(env.project_id)\n+      # pp env_bundle\n+      # exit\n+      metric_client = @metric_client\n \n-      resources = metric_client.list_monitored_resource_descriptors(metric_project_path)\n-      @logger.info(\"found #{resources.count} monitored resources\")\n+      resources = metric_client.list_monitored_resource_descriptors(@project_path)\n+      logger.info(\"found #{resources.count} monitored resources\")\n       counts['monitored_resources'] = resources.count\n \n-      all_metrics = metric_client.list_metric_descriptors(metric_project_path)\n+      all_metrics = metric_client.list_metric_descriptors(@project_path)\n       counts['metric_descriptors'] =  all_metrics.count\n-      @logger.info(\"found #{all_metrics.count} metric descriptors\")\n+      logger.info(\"found #{all_metrics.count} metric descriptors\")\n \n-      custom_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: CUSTOM_METRIC_FILTER})\n-      @logger.info(\"found  #{custom_metrics.count} custom metrics\")\n+      custom_metrics = metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+      logger.info(\"found  #{custom_metrics.count} custom metrics\")\n       counts['custom_metrics'] = custom_metrics.count\n       custom_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      user_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+      user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n       counts['user_logs_based_metrics'] = user_logs_based_metrics.count\n-      @logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n+      logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n \n       user_logs_based_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      total_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: LOGS_BASED_METRIC_FILTER})\n-      @logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n+      total_logs_based_metrics = metric_client.list_metric_descriptors(@project_path, {filter: LOGS_BASED_METRIC_FILTER})\n+      logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n \n-      alerts_client = Google::Cloud::Monitoring::V3::AlertPolicyServiceClient.new\n-      policies = alerts_client.list_alert_policies(env.formatted_project_name)\n-      @logger.info(\"found #{policies.count} alerting policies\")\n+      policies = @alert_client.list_alert_policies(@project_path)\n+      logger.info(\"found #{policies.count} alerting policies\")\n       counts['policies'] = policies.count\n \n       policies.each do |policy|\n-        @logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n+        logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n       end\n \n-      @logger.info(\"Total counts for #{env.short_name}: #{counts}\")\n+      logger.info(\"Total counts for #{@current_env.short_name}: #{counts}\")\n+    end\n+  end\n+\n+  DO_BACKUP_ALL = false # TODO(jaycarlton): make this an option\n+\n+  # For every environment in the envs_file, fetch all items of interest from the appropriate\n+  # Stackdriver APIs. (Note that in future we may wish to broaden this to other )\n+  def backup_config\n+    visit_envs do |env_bundle|\n+      backup_alert_policies\n+      if DO_BACKUP_ALL\n+        backup_all_metrics\n+      else\n+        backup_custom_metrics\n+        backup_user_logs_based_metrics\n+      end\n+      backup_dashboards\n+      backup_group_members\n+      backup_monitored_resources\n+      backup_notification_channels\n+      backup_notification_channels", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0NTM1Mw==", "bodyText": "nit: newline", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424745353", "createdAt": "2020-05-13T21:36:37Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "diffHunk": "@@ -1,65 +1,227 @@\n require \"google/cloud/monitoring\"\n require 'logger'\n+require 'json'\n \n require_relative \"./lib/service_account_manager\"\n require_relative './lib/gcp_environment_visitor'\n \n CUSTOM_METRIC_FILTER = \"metric.type = starts_with(\\\"custom.googleapis.com/\\\")\"\n LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/\\\")\"\n USER_LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/user/\\\")\"\n+FILE_SUFFIXES = {:yaml => '.yaml', :json => '.json'}\n \n class MonitoringAssets\n-  def initialize(envs_path, logger = Logger.new(STDOUT))\n+  def initialize(envs_path, output_dir='.', logger = Logger.new(STDOUT), output_format = :yaml)\n     @visitor = GcpEnvironmentVisitor.new(envs_path, logger)\n+    @output_dir = output_dir\n     @logger = logger\n+    @output_format = output_format\n   end\n \n+  attr_accessor(:current_env, :metric_client, :project_path, :alert_client)\n+  attr_reader(:visitor, :logger, :output_dir)\n+\n   # Demonstrate a simple usage of the AouEnvironmentVisitor with a few read-only operations\n   # on monitoring things in all the environments.\n   def inventory\n-    @visitor.visit do |env|\n+    visit_envs do |env_bundle|\n       counts  = {}\n-      metric_client = Google::Cloud::Monitoring::Metric.new\n-      metric_project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(env.project_id)\n+      # pp env_bundle\n+      # exit\n+      metric_client = @metric_client\n \n-      resources = metric_client.list_monitored_resource_descriptors(metric_project_path)\n-      @logger.info(\"found #{resources.count} monitored resources\")\n+      resources = metric_client.list_monitored_resource_descriptors(@project_path)\n+      logger.info(\"found #{resources.count} monitored resources\")\n       counts['monitored_resources'] = resources.count\n \n-      all_metrics = metric_client.list_metric_descriptors(metric_project_path)\n+      all_metrics = metric_client.list_metric_descriptors(@project_path)\n       counts['metric_descriptors'] =  all_metrics.count\n-      @logger.info(\"found #{all_metrics.count} metric descriptors\")\n+      logger.info(\"found #{all_metrics.count} metric descriptors\")\n \n-      custom_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: CUSTOM_METRIC_FILTER})\n-      @logger.info(\"found  #{custom_metrics.count} custom metrics\")\n+      custom_metrics = metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+      logger.info(\"found  #{custom_metrics.count} custom metrics\")\n       counts['custom_metrics'] = custom_metrics.count\n       custom_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      user_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+      user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n       counts['user_logs_based_metrics'] = user_logs_based_metrics.count\n-      @logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n+      logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n \n       user_logs_based_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      total_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: LOGS_BASED_METRIC_FILTER})\n-      @logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n+      total_logs_based_metrics = metric_client.list_metric_descriptors(@project_path, {filter: LOGS_BASED_METRIC_FILTER})\n+      logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n \n-      alerts_client = Google::Cloud::Monitoring::V3::AlertPolicyServiceClient.new\n-      policies = alerts_client.list_alert_policies(env.formatted_project_name)\n-      @logger.info(\"found #{policies.count} alerting policies\")\n+      policies = @alert_client.list_alert_policies(@project_path)\n+      logger.info(\"found #{policies.count} alerting policies\")\n       counts['policies'] = policies.count\n \n       policies.each do |policy|\n-        @logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n+        logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n       end\n \n-      @logger.info(\"Total counts for #{env.short_name}: #{counts}\")\n+      logger.info(\"Total counts for #{@current_env.short_name}: #{counts}\")\n+    end\n+  end\n+\n+  DO_BACKUP_ALL = false # TODO(jaycarlton): make this an option\n+\n+  # For every environment in the envs_file, fetch all items of interest from the appropriate\n+  # Stackdriver APIs. (Note that in future we may wish to broaden this to other )\n+  def backup_config\n+    visit_envs do |env_bundle|\n+      backup_alert_policies\n+      if DO_BACKUP_ALL\n+        backup_all_metrics\n+      else\n+        backup_custom_metrics\n+        backup_user_logs_based_metrics\n+      end\n+      backup_dashboards\n+      backup_group_members\n+      backup_monitored_resources\n+      backup_notification_channels\n+      backup_notification_channels\n     end\n+  end\n+\n+  private\n+\n+  def backup_alert_policies\n+    policies = @alert_client.list_alert_policies(@project_path)\n+    backup_assets(policies)\n+  end\n+\n+  def backup_custom_metrics\n+    custom_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+    backup_assets(custom_metrics)\n+  end\n+\n+  def backup_dashboards\n+    dashboards = @dashboard_client.list_dashboards(@current_env.formatted_project_number)\n+    backup_assets(dashboards)\n+  end\n+  def backup_user_logs_based_metrics", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0NjYyMQ==", "bodyText": "Interesting, first time seeing this syntax", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424746621", "createdAt": "2020-05-13T21:39:24Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "diffHunk": "@@ -1,65 +1,227 @@\n require \"google/cloud/monitoring\"\n require 'logger'\n+require 'json'\n \n require_relative \"./lib/service_account_manager\"\n require_relative './lib/gcp_environment_visitor'\n \n CUSTOM_METRIC_FILTER = \"metric.type = starts_with(\\\"custom.googleapis.com/\\\")\"\n LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/\\\")\"\n USER_LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/user/\\\")\"\n+FILE_SUFFIXES = {:yaml => '.yaml', :json => '.json'}\n \n class MonitoringAssets\n-  def initialize(envs_path, logger = Logger.new(STDOUT))\n+  def initialize(envs_path, output_dir='.', logger = Logger.new(STDOUT), output_format = :yaml)\n     @visitor = GcpEnvironmentVisitor.new(envs_path, logger)\n+    @output_dir = output_dir\n     @logger = logger\n+    @output_format = output_format\n   end\n \n+  attr_accessor(:current_env, :metric_client, :project_path, :alert_client)\n+  attr_reader(:visitor, :logger, :output_dir)\n+\n   # Demonstrate a simple usage of the AouEnvironmentVisitor with a few read-only operations\n   # on monitoring things in all the environments.\n   def inventory\n-    @visitor.visit do |env|\n+    visit_envs do |env_bundle|\n       counts  = {}\n-      metric_client = Google::Cloud::Monitoring::Metric.new\n-      metric_project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(env.project_id)\n+      # pp env_bundle\n+      # exit\n+      metric_client = @metric_client\n \n-      resources = metric_client.list_monitored_resource_descriptors(metric_project_path)\n-      @logger.info(\"found #{resources.count} monitored resources\")\n+      resources = metric_client.list_monitored_resource_descriptors(@project_path)\n+      logger.info(\"found #{resources.count} monitored resources\")\n       counts['monitored_resources'] = resources.count\n \n-      all_metrics = metric_client.list_metric_descriptors(metric_project_path)\n+      all_metrics = metric_client.list_metric_descriptors(@project_path)\n       counts['metric_descriptors'] =  all_metrics.count\n-      @logger.info(\"found #{all_metrics.count} metric descriptors\")\n+      logger.info(\"found #{all_metrics.count} metric descriptors\")\n \n-      custom_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: CUSTOM_METRIC_FILTER})\n-      @logger.info(\"found  #{custom_metrics.count} custom metrics\")\n+      custom_metrics = metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+      logger.info(\"found  #{custom_metrics.count} custom metrics\")\n       counts['custom_metrics'] = custom_metrics.count\n       custom_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      user_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+      user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n       counts['user_logs_based_metrics'] = user_logs_based_metrics.count\n-      @logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n+      logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n \n       user_logs_based_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      total_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: LOGS_BASED_METRIC_FILTER})\n-      @logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n+      total_logs_based_metrics = metric_client.list_metric_descriptors(@project_path, {filter: LOGS_BASED_METRIC_FILTER})\n+      logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n \n-      alerts_client = Google::Cloud::Monitoring::V3::AlertPolicyServiceClient.new\n-      policies = alerts_client.list_alert_policies(env.formatted_project_name)\n-      @logger.info(\"found #{policies.count} alerting policies\")\n+      policies = @alert_client.list_alert_policies(@project_path)\n+      logger.info(\"found #{policies.count} alerting policies\")\n       counts['policies'] = policies.count\n \n       policies.each do |policy|\n-        @logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n+        logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n       end\n \n-      @logger.info(\"Total counts for #{env.short_name}: #{counts}\")\n+      logger.info(\"Total counts for #{@current_env.short_name}: #{counts}\")\n+    end\n+  end\n+\n+  DO_BACKUP_ALL = false # TODO(jaycarlton): make this an option\n+\n+  # For every environment in the envs_file, fetch all items of interest from the appropriate\n+  # Stackdriver APIs. (Note that in future we may wish to broaden this to other )\n+  def backup_config\n+    visit_envs do |env_bundle|\n+      backup_alert_policies\n+      if DO_BACKUP_ALL\n+        backup_all_metrics\n+      else\n+        backup_custom_metrics\n+        backup_user_logs_based_metrics\n+      end\n+      backup_dashboards\n+      backup_group_members\n+      backup_monitored_resources\n+      backup_notification_channels\n+      backup_notification_channels\n     end\n+  end\n+\n+  private\n+\n+  def backup_alert_policies\n+    policies = @alert_client.list_alert_policies(@project_path)\n+    backup_assets(policies)\n+  end\n+\n+  def backup_custom_metrics\n+    custom_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+    backup_assets(custom_metrics)\n+  end\n+\n+  def backup_dashboards\n+    dashboards = @dashboard_client.list_dashboards(@current_env.formatted_project_number)\n+    backup_assets(dashboards)\n+  end\n+  def backup_user_logs_based_metrics\n+    user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+    backup_assets(user_logs_based_metrics)\n+  end\n+\n+  def backup_monitored_resources\n+    resources = @metric_client.list_monitored_resource_descriptors(@project_path)\n+    backup_assets(resources)\n+  end\n+\n+  # Grab all the metrics, including very many defined by Google and partners. This method is here\n+  # more for completeness and to allow introspection/navigation of them than anything else, as we\n+  # can't write to these to restore them.\n+  def backup_all_metrics\n+    metrics = @metric_client.list_metric_descriptors(@project_path)\n+    backup_assets(metrics)\n+  end\n+\n+  def backup_group_members\n+    members = @group_client.list_groups(@project_path)\n+    backup_assets(members)\n+  end\n+\n+  def backup_notification_channels\n+    channels = @notification_channel_client.list_notification_channels(@project_path)\n+    backup_assets(channels)\n+  end\n+\n+  # Backup a collection of Stackdriver assets\n+  def backup_assets(assets)\n+    assets.each(&method(:backup_asset))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0ODY1MA==", "bodyText": "project_path is initialized twice here", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424748650", "createdAt": "2020-05-13T21:43:49Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/tasks/monitoring_assets.rb", "diffHunk": "@@ -1,65 +1,227 @@\n require \"google/cloud/monitoring\"\n require 'logger'\n+require 'json'\n \n require_relative \"./lib/service_account_manager\"\n require_relative './lib/gcp_environment_visitor'\n \n CUSTOM_METRIC_FILTER = \"metric.type = starts_with(\\\"custom.googleapis.com/\\\")\"\n LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/\\\")\"\n USER_LOGS_BASED_METRIC_FILTER = \"metric.type = starts_with(\\\"logging.googleapis.com/user/\\\")\"\n+FILE_SUFFIXES = {:yaml => '.yaml', :json => '.json'}\n \n class MonitoringAssets\n-  def initialize(envs_path, logger = Logger.new(STDOUT))\n+  def initialize(envs_path, output_dir='.', logger = Logger.new(STDOUT), output_format = :yaml)\n     @visitor = GcpEnvironmentVisitor.new(envs_path, logger)\n+    @output_dir = output_dir\n     @logger = logger\n+    @output_format = output_format\n   end\n \n+  attr_accessor(:current_env, :metric_client, :project_path, :alert_client)\n+  attr_reader(:visitor, :logger, :output_dir)\n+\n   # Demonstrate a simple usage of the AouEnvironmentVisitor with a few read-only operations\n   # on monitoring things in all the environments.\n   def inventory\n-    @visitor.visit do |env|\n+    visit_envs do |env_bundle|\n       counts  = {}\n-      metric_client = Google::Cloud::Monitoring::Metric.new\n-      metric_project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(env.project_id)\n+      # pp env_bundle\n+      # exit\n+      metric_client = @metric_client\n \n-      resources = metric_client.list_monitored_resource_descriptors(metric_project_path)\n-      @logger.info(\"found #{resources.count} monitored resources\")\n+      resources = metric_client.list_monitored_resource_descriptors(@project_path)\n+      logger.info(\"found #{resources.count} monitored resources\")\n       counts['monitored_resources'] = resources.count\n \n-      all_metrics = metric_client.list_metric_descriptors(metric_project_path)\n+      all_metrics = metric_client.list_metric_descriptors(@project_path)\n       counts['metric_descriptors'] =  all_metrics.count\n-      @logger.info(\"found #{all_metrics.count} metric descriptors\")\n+      logger.info(\"found #{all_metrics.count} metric descriptors\")\n \n-      custom_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: CUSTOM_METRIC_FILTER})\n-      @logger.info(\"found  #{custom_metrics.count} custom metrics\")\n+      custom_metrics = metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+      logger.info(\"found  #{custom_metrics.count} custom metrics\")\n       counts['custom_metrics'] = custom_metrics.count\n       custom_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      user_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+      user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n       counts['user_logs_based_metrics'] = user_logs_based_metrics.count\n-      @logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n+      logger.info(\"found  #{user_logs_based_metrics.count} user-defined  logs-based metrics\")\n \n       user_logs_based_metrics.each do |metric|\n-        @logger.info(\"\\t#{metric.name}: #{metric.description}\")\n+        logger.info(\"\\t#{metric.name}: #{metric.description}\")\n       end\n \n-      total_logs_based_metrics = metric_client.list_metric_descriptors(metric_project_path, {filter: LOGS_BASED_METRIC_FILTER})\n-      @logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n+      total_logs_based_metrics = metric_client.list_metric_descriptors(@project_path, {filter: LOGS_BASED_METRIC_FILTER})\n+      logger.info(\"found  #{total_logs_based_metrics.count} total logs-based metrics\")\n \n-      alerts_client = Google::Cloud::Monitoring::V3::AlertPolicyServiceClient.new\n-      policies = alerts_client.list_alert_policies(env.formatted_project_name)\n-      @logger.info(\"found #{policies.count} alerting policies\")\n+      policies = @alert_client.list_alert_policies(@project_path)\n+      logger.info(\"found #{policies.count} alerting policies\")\n       counts['policies'] = policies.count\n \n       policies.each do |policy|\n-        @logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n+        logger.info(\"\\t#{policy.display_name}, #{policy.name}, #{policy.conditions.count} conditions\")\n       end\n \n-      @logger.info(\"Total counts for #{env.short_name}: #{counts}\")\n+      logger.info(\"Total counts for #{@current_env.short_name}: #{counts}\")\n+    end\n+  end\n+\n+  DO_BACKUP_ALL = false # TODO(jaycarlton): make this an option\n+\n+  # For every environment in the envs_file, fetch all items of interest from the appropriate\n+  # Stackdriver APIs. (Note that in future we may wish to broaden this to other )\n+  def backup_config\n+    visit_envs do |env_bundle|\n+      backup_alert_policies\n+      if DO_BACKUP_ALL\n+        backup_all_metrics\n+      else\n+        backup_custom_metrics\n+        backup_user_logs_based_metrics\n+      end\n+      backup_dashboards\n+      backup_group_members\n+      backup_monitored_resources\n+      backup_notification_channels\n+      backup_notification_channels\n     end\n+  end\n+\n+  private\n+\n+  def backup_alert_policies\n+    policies = @alert_client.list_alert_policies(@project_path)\n+    backup_assets(policies)\n+  end\n+\n+  def backup_custom_metrics\n+    custom_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: CUSTOM_METRIC_FILTER})\n+    backup_assets(custom_metrics)\n+  end\n+\n+  def backup_dashboards\n+    dashboards = @dashboard_client.list_dashboards(@current_env.formatted_project_number)\n+    backup_assets(dashboards)\n+  end\n+  def backup_user_logs_based_metrics\n+    user_logs_based_metrics = @metric_client.list_metric_descriptors(@project_path, {filter: USER_LOGS_BASED_METRIC_FILTER})\n+    backup_assets(user_logs_based_metrics)\n+  end\n+\n+  def backup_monitored_resources\n+    resources = @metric_client.list_monitored_resource_descriptors(@project_path)\n+    backup_assets(resources)\n+  end\n+\n+  # Grab all the metrics, including very many defined by Google and partners. This method is here\n+  # more for completeness and to allow introspection/navigation of them than anything else, as we\n+  # can't write to these to restore them.\n+  def backup_all_metrics\n+    metrics = @metric_client.list_metric_descriptors(@project_path)\n+    backup_assets(metrics)\n+  end\n+\n+  def backup_group_members\n+    members = @group_client.list_groups(@project_path)\n+    backup_assets(members)\n+  end\n+\n+  def backup_notification_channels\n+    channels = @notification_channel_client.list_notification_channels(@project_path)\n+    backup_assets(channels)\n+  end\n+\n+  # Backup a collection of Stackdriver assets\n+  def backup_assets(assets)\n+    assets.each(&method(:backup_asset))\n+  end\n+\n+  # Backup the cloud asset to a file in a path based on its fully\n+  # qualified name and a filename from the based on the current time.\n+  def backup_asset(asset)\n+    full_path = File.join(make_output_path(asset), make_file_name)\n+    logger.info(\"Writing #{asset.display_name} to #{full_path}\")\n+    text = serialize(asset)\n+    IO.write(full_path, text)\n+  end\n+\n+  # Serialize the Stackdriver object instance to a persistent format such as YAML or JSON\n+  def serialize(asset)\n+    case @output_format\n+    when :yaml\n+      return to_pretty_yaml(asset)\n+    when :json\n+      return to_pretty_json(asset)\n+    else\n+      @logger.WARN(\"Unrecognized output format '#{@output_format}'\")\n+      return asset.to_s\n+    end\n+  end\n+\n+  # In order to generate JSON correctly (e.g. with camelCase and only the fields Stackdriver actually\n+  # wants to expose), we need to call the asset's internal to_json() override. This gives correct\n+  # JSON (per the REST API) suitable for reuse. We then parse that JSON and re-render it prettily.\n+  def to_pretty_json(asset)\n+    reparsed_hash = to_hash(asset)\n+    JSON.pretty_generate(reparsed_hash)\n+  end\n+\n+  # Use the asset's internal to_json() to give conventional fields for the appropriate APIs\n+  # and make a hash from that.\n+  def to_hash(asset)\n+    inline_json = asset.to_json\n+    JSON.parse(inline_json)\n+  end\n+\n+  # Build a YAML representation of the asset, based on its internally-defined JSON representation\n+  # and not simply the default hash's default yaml.\n+  def to_pretty_yaml(asset)\n+    to_hash(asset).to_yaml\n+  end\n+\n+  # Generate a file name based on the current 24-hour time. This will\n+  # sort such that later times are later alphabetically.\n+  def make_file_name\n+    DateTime.now.strftime(\"%FT%T\").gsub(':', '-') + FILE_SUFFIXES[@output_format]\n+  end\n+\n+  # Private visitor that makes the distracting client initializations for each environment. The\n+  # client constructors take project details from the global scope.\n+  # TODO(jaycarlton): explicitly provide constructor parameters for the clients so refactoring\n+  # becomes easier\n+  def visit_envs\n+    visitor.visit do |env|\n+      @current_env = env\n+\n+      # Stackdriver clients. Note that somehow the initialization order matters here. I suspect it\n+      # has to do with library-wide state getting pulled into the constrctors.\n+      @metric_client = Google::Cloud::Monitoring::Metric.new\n+      @project_path = Google::Cloud::Monitoring::V3::MetricServiceClient.project_path(@current_env.project_id)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MTE0OA==", "bodyText": "This is separably from the implementation details of the tool, but where do you intend to archive these? It sounds like it's too large to want to put this into any of our git repos.", "url": "https://github.com/all-of-us/workbench/pull/3570#discussion_r424751148", "createdAt": "2020-05-13T21:49:20Z", "author": {"login": "calbach"}, "path": "ops/ruby/devops-toolkit/README.md", "diffHunk": "@@ -70,6 +70,14 @@ bundle install\n ## Tasks\n A variety of tasks (sub-commands) are available via the required `-t` option. Here  are their\n brief descriptions:\n+- `backup-config`: Generate JSON or YAML files for each Stackdriver asset (other GCP assets TBD),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e31f16c7e3bbfff5cc82bb0fdf22d6e772fe9820"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb341acab97e88419aa0a9ee3abeff49b2ea1829", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/cb341acab97e88419aa0a9ee3abeff49b2ea1829", "committedDate": "2020-05-14T16:06:50Z", "message": "dashboard name fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e2badc6aab266e496c84a8bb6d8015f2632e9d5", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/1e2badc6aab266e496c84a8bb6d8015f2632e9d5", "committedDate": "2020-05-18T16:16:39Z", "message": "Merge branch 'master' into jaycarlton/RW-4934"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7f31b68991026c6f17a4281fc02903197c12c70", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/e7f31b68991026c6f17a4281fc02903197c12c70", "committedDate": "2020-05-18T16:29:51Z", "message": "fix dashboard dirs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1383d448843e6bf1fb9f986fbc06c0507f0fc1e", "author": {"user": {"login": "jaycarlton", "name": "Jay Carlton"}}, "url": "https://github.com/all-of-us/workbench/commit/c1383d448843e6bf1fb9f986fbc06c0507f0fc1e", "committedDate": "2020-05-18T16:46:30Z", "message": "don't back up monitored resources, as they're read-only"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjMwNzY2", "url": "https://github.com/all-of-us/workbench/pull/3570#pullrequestreview-414630766", "createdAt": "2020-05-19T16:40:08Z", "commit": {"oid": "c1383d448843e6bf1fb9f986fbc06c0507f0fc1e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3135, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}