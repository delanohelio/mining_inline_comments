{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NTUyMTMx", "number": 3032, "title": "[risk=no][RW-2957] Moodle v2 API Integration", "bodyText": "Our Moodle integration is going to release a new API endpoint specific to AoU RW. This PR introduces functionality, behind a feature flag, to call that endpoint, and deprecates the calls to the old endpoint. This functionality has been manually tested against the Moodle test server, including tests for scheduled and unscheduled expiry of a training.\n--\nPR checklist\n\n This PR meets the Acceptance Criteria in the JIRA story\n The JIRA story has been moved to Dev Review\n This PR includes appropriate unit tests\n I have run and tested this change locally\n If this includes an API change, I have updated the appropriate Swagger definitions and notified API consumers\n If this includes a new feature flag, I have created and linked new JIRA tickets to (a) turn on the feature flag and (b) remove it later\n\nhttps://precisionmedicineinitiative.atlassian.net/browse/RW-4316\nhttps://precisionmedicineinitiative.atlassian.net/browse/RW-4317", "createdAt": "2020-01-23T20:26:42Z", "url": "https://github.com/all-of-us/workbench/pull/3032", "merged": true, "mergeCommit": {"oid": "a9fe3295ccc8e4e4377e13b2d98046ddf98c93f3"}, "closed": true, "closedAt": "2020-01-29T20:01:39Z", "author": {"login": "als364"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9QX19AFqTM0NzU4NTAxMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_LYrSABqjI5OTA4NTQ4NDQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NTg1MDEx", "url": "https://github.com/all-of-us/workbench/pull/3032#pullrequestreview-347585011", "createdAt": "2020-01-23T20:27:01Z", "commit": {"oid": "fbb3a5a298cbf80282f117b86ac7a4665b9e976e"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyNzowMVrOFhLmeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyODozOFrOFhLpOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzNzQwMQ==", "bodyText": "Enabled this so I can actually test these changes. 'bypass all' should still work.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370337401", "createdAt": "2020-01-23T20:27:01Z", "author": {"login": "als364"}, "path": "api/config/config_local.json", "diffHunk": "@@ -74,7 +74,7 @@\n     \"enableMoodleBackend\": true\n   },\n   \"access\": {\n-    \"enableComplianceTraining\": false,\n+    \"enableComplianceTraining\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbb3a5a298cbf80282f117b86ac7a4665b9e976e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzODEwNg==", "bodyText": "names up for debate. it's easy enough to change this, but the keys are different and I do have to go push files around in GCS to change the name.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370338106", "createdAt": "2020-01-23T20:28:38Z", "author": {"login": "als364"}, "path": "api/src/main/java/org/pmiops/workbench/google/CloudStorageServiceImpl.java", "diffHunk": "@@ -47,7 +47,11 @@ public String readMandrillApiKey() {\n \n   @Override\n   public String getMoodleApiKey() {\n-    return readCredentialsBucketString(\"moodle-key.txt\");\n+    if (configProvider.get().featureFlags.enableMoodleV2Api) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbb3a5a298cbf80282f117b86ac7a4665b9e976e"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0fae3b654761a25daf0d901b6302d3d67db04bdf", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/0fae3b654761a25daf0d901b6302d3d67db04bdf", "committedDate": "2020-01-23T20:27:22Z", "message": "test and local in sync..."}, "afterCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/e79eb7e8593888376eee7c6dc8aeca6ff3b82be1", "committedDate": "2020-01-23T20:37:22Z", "message": "test and local in sync..."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NTg1NDE4", "url": "https://github.com/all-of-us/workbench/pull/3032#pullrequestreview-347585418", "createdAt": "2020-01-23T20:27:47Z", "commit": {"oid": "fbb3a5a298cbf80282f117b86ac7a4665b9e976e"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyNzo0OFrOFhLnuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDo0ODowNVrOFhMJZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzNzcyMw==", "bodyText": "Why not also enable enableComplianceTraining on test?", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370337723", "createdAt": "2020-01-23T20:27:48Z", "author": {"login": "jaycarlton"}, "path": "api/config/config_test.json", "diffHunk": "@@ -84,7 +84,8 @@\n     \"unsafeAllowDeleteUser\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbb3a5a298cbf80282f117b86ac7a4665b9e976e"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzODIzMg==", "bodyText": "Why did we move to the deprecated class here? Should this method be marked deprecated as well?", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370338232", "createdAt": "2020-01-23T20:28:58Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceService.java", "diffHunk": "@@ -22,5 +24,16 @@\n    * @return list of badges/completed training by user\n    * @throws ApiException\n    */\n-  List<BadgeDetails> getUserBadge(int userMoodleId) throws ApiException;\n+  List<BadgeDetailsDeprecated> getUserBadge(int userMoodleId) throws ApiException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fae3b654761a25daf0d901b6302d3d67db04bdf"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzODcxOQ==", "bodyText": "Can you please return an empty map instead of null? Otherwise, the next best thing is Optional<Map>, which is no less awkward. In general, if I call a method returning a collection in Java, I don't expect nor do I check for null.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370338719", "createdAt": "2020-01-23T20:30:03Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -84,4 +92,33 @@ public Integer getMoodleId(String email) throws ApiException {\n     }\n     return response.getBadges();\n   }\n+\n+  @Override\n+  public Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException {\n+    if (!enableMoodleCalls()) {\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fae3b654761a25daf0d901b6302d3d67db04bdf"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzOTUxNg==", "bodyText": "Please log this at a WARNING level (or at least INFO), so that we can track this down.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370339516", "createdAt": "2020-01-23T20:31:54Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -84,4 +92,33 @@ public Integer getMoodleId(String email) throws ApiException {\n     }\n     return response.getBadges();\n   }\n+\n+  @Override\n+  public Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException {\n+    if (!enableMoodleCalls()) {\n+      return null;\n+    }\n+\n+    UserBadgeResponse response =\n+        moodleApiProvider.get().getMoodleBadge(RESPONSE_FORMAT, getToken(), email);\n+    if (response.getException() != null && response.getException().equals(MOODLE_EXCEPTION)) {\n+      if (response.getErrorcode().equals(MOODLE_USER_NOT_ALLOWED_ERROR_CODE)) {\n+        throw new ApiException(HttpStatus.NOT_FOUND.value(), response.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fae3b654761a25daf0d901b6302d3d67db04bdf"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0MDM1Ng==", "bodyText": "This function is over a hundred lines long now. Can we split it into 4-5 pieces? I generally consider 20-line functions in need of a haircut.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370340356", "createdAt": "2020-01-23T20:34:07Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -555,46 +557,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fae3b654761a25daf0d901b6302d3d67db04bdf"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0MTE3Mw==", "bodyText": "Please add a clearComplianceTrainingCompletion() and clearComplianceTrainingExpiration() methods on DbUser so you don't have to pass null as your only argument. This will also help sweep the nullability of the timestamp under the rug in the entity class, so at the service level we don't need to think about it.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370341173", "createdAt": "2020-01-23T20:36:04Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -555,46 +557,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;\n+      if (configProvider.get().featureFlags.enableMoodleV2Api) {\n+        Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(email);\n+        if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+          BadgeDetails badge =\n+              userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+          expiryEpoch =\n+              badge.getGlobalexpiration() == null\n+                  ? badge.getDateexpire()\n+                  : badge.getGlobalexpiration();\n+        } else {\n+          // Moodle has not returned research ethics training information for the given user --\n+          // we should clear the user's training completion and expiration time.\n+          dbUser.setComplianceTrainingCompletionTime(null);\n+          dbUser.setComplianceTrainingExpirationTime(null);\n+        }\n+      } else {\n+        List<BadgeDetailsDeprecated> badgeResponse = complianceService.getUserBadge(moodleId);\n+        // The assumption here is that the User will always get 1 badge which will be AoU\n+        if (badgeResponse != null && badgeResponse.size() > 0) {\n+          BadgeDetailsDeprecated badge = badgeResponse.get(0);\n+          expiryEpoch = badge.getDateexpire();\n+        } else {\n+          // Moodle has returned zero badges for the given user -- we should clear the user's\n+          // training completion & expiration time.\n+          dbUser.setComplianceTrainingCompletionTime(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fae3b654761a25daf0d901b6302d3d67db04bdf"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0MzgwNQ==", "bodyText": "The mapper impl files are generated at compile time, and should not be checked into source control.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370343805", "createdAt": "2020-01-23T20:42:17Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/generated/org/pmiops/workbench/utils/WorkspaceMapperImpl.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.pmiops.workbench.utils;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import javax.annotation.Generated;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.db.model.DbWorkspace;\n+import org.pmiops.workbench.firecloud.model.FirecloudWorkspace;\n+import org.pmiops.workbench.model.ResearchPurpose;\n+import org.pmiops.workbench.model.SpecificPopulationEnum;\n+import org.pmiops.workbench.model.UserRole;\n+import org.pmiops.workbench.model.Workspace;\n+import org.pmiops.workbench.utils.mappers.CommonMappers;\n+import org.springframework.stereotype.Component;\n+\n+@Generated(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NDIxNQ==", "bodyText": "There's lots of nesting and mutable state going on here, which makes it easy to write bugs.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370344215", "createdAt": "2020-01-23T20:43:13Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -582,46 +584,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;\n+      if (configProvider.get().featureFlags.enableMoodleV2Api) {\n+        Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(email);\n+        if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+          BadgeDetails badge =\n+              userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+          expiryEpoch =\n+              badge.getGlobalexpiration() == null\n+                  ? badge.getDateexpire()\n+                  : badge.getGlobalexpiration();\n+        } else {\n+          // Moodle has not returned research ethics training information for the given user --\n+          // we should clear the user's training completion and expiration time.\n+          dbUser.setComplianceTrainingCompletionTime(null);\n+          dbUser.setComplianceTrainingExpirationTime(null);\n+        }\n+      } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NDQ4NQ==", "bodyText": "Please put these constants into a config file, and also rename them to indicate v1 vs v2 somehow.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370344485", "createdAt": "2020-01-23T20:43:54Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/google/CloudStorageServiceImpl.java", "diffHunk": "@@ -47,7 +47,12 @@ public String readMandrillApiKey() {\n \n   @Override\n   public String getMoodleApiKey() {\n-    return getCredentialsBucketString(\"moodle-key.txt\");\n+    if(configProvider.get().featureFlags.enableMoodleV2Api) {\n+      return getCredentialsBucketString(\"moodle.txt\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NTY5Ng==", "bodyText": "I'm wondering why the badge- and moodle-specific logic needs to live in the UserService.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370345696", "createdAt": "2020-01-23T20:46:47Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -582,46 +584,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;\n+      if (configProvider.get().featureFlags.enableMoodleV2Api) {\n+        Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(email);\n+        if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+          BadgeDetails badge =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NjM0MQ==", "bodyText": "Please make expiryEpoch an Optional, since it's not guaranteed to be there. You can do that with badgeResponse.stream().findFirst(), so you get rid of the scary get(0).", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370346341", "createdAt": "2020-01-23T20:48:05Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -582,46 +584,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;\n+      if (configProvider.get().featureFlags.enableMoodleV2Api) {\n+        Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(email);\n+        if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+          BadgeDetails badge =\n+              userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+          expiryEpoch =\n+              badge.getGlobalexpiration() == null\n+                  ? badge.getDateexpire()\n+                  : badge.getGlobalexpiration();\n+        } else {\n+          // Moodle has not returned research ethics training information for the given user --\n+          // we should clear the user's training completion and expiration time.\n+          dbUser.setComplianceTrainingCompletionTime(null);\n+          dbUser.setComplianceTrainingExpirationTime(null);\n+        }\n+      } else {\n+        List<BadgeDetailsDeprecated> badgeResponse = complianceService.getUserBadge(moodleId);\n+        // The assumption here is that the User will always get 1 badge which will be AoU\n+        if (badgeResponse != null && badgeResponse.size() > 0) {\n+          BadgeDetailsDeprecated badge = badgeResponse.get(0);\n+          expiryEpoch = badge.getDateexpire();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MjkxMTYy", "url": "https://github.com/all-of-us/workbench/pull/3032#pullrequestreview-348291162", "createdAt": "2020-01-25T00:25:51Z", "commit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwMDoyNTo1MVrOFhtqyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDozMTo0OFrOFiEqDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5NTU2Mw==", "bodyText": "Please also add the @Deprecated annotation, which will make this more obvious. I'd probably just name it getUserBadgeV1(), in case you have to support more than one deprecated version. Let's hope not.\nThere's also a @deprecated javadoc annotation FWIW.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370895563", "createdAt": "2020-01-25T00:25:51Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceService.java", "diffHunk": "@@ -24,7 +24,7 @@\n    * @return list of badges/completed training by user\n    * @throws ApiException\n    */\n-  List<BadgeDetailsDeprecated> getUserBadge(int userMoodleId) throws ApiException;\n+  List<BadgeDetailsDeprecated> getUserBadgeDeprecated(int userMoodleId) throws ApiException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MjIwNQ==", "bodyText": "Hmm. Somehow, the workspace mapper impl file lives in a genenrated dir, which explians why it doesn't get picked up: workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/WorkspaceMapperImpl.java\nI don't believe we want to . mask *Impl.java, as it would match lots fo our implementation services.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371272205", "createdAt": "2020-01-27T14:31:48Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -1,14 +1,20 @@\n package org.pmiops.workbench.compliance;\n \n+import java.util.HashMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MzQwNjQ1", "url": "https://github.com/all-of-us/workbench/pull/3032#pullrequestreview-348340645", "createdAt": "2020-01-25T19:10:53Z", "commit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxOToxMDo1M1rOFhxA4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQyMDowNTozNVrOFhxLZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDM2OQ==", "bodyText": "This new configuration pattern doesn't feel right to me.\nFirst, and I think most importantly, it introduces inconsistency with the way we handle filenames for other credentials / keys in downstream systems. (In all cases, the filenames are code-level constants and the credentials bucket path is generated from the cloud project name.) This adds mental burden for an oncall engineer trying to understand what lives where. Now doesn't feel like a great time to create new patterns like this \u2013\u00a0especially considering our existing convention has been around for ~3 years and hasn't caused any notable issues.\nAside from the inconsistency argument, I think it's incorrect to be storing two versions of the Moodle creds filename in the per-environment config. No environment should ever be using both of these filenames, right? At most we should have one field that varies by environment, and have each environment switch from \"moodle-key\" --> \"moodle-credentials-key\" when the v2 Moodle API is enabled. (But even with that solution, we'd effectively have two redundant flags controlling the same switch in environment behavior: featureFlags.enableMoodleV2Api and moodle.credentialsKeyFilename.)\nIt looks like this change was introduced in response to comments from @jaycarlton. Maybe we can quickly sync up on this today.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370950369", "createdAt": "2020-01-25T19:10:53Z", "author": {"login": "gjuggler"}, "path": "api/config/config_local.json", "diffHunk": "@@ -73,10 +73,12 @@\n   },\n   \"moodle\": {\n     \"host\": \"aoudev.nnlm.gov\",\n-    \"enableMoodleBackend\": true\n+    \"enableMoodleBackend\": true,\n+    \"credentialsKeyDeprecated\": \"moodle-key.txt\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDcyNQ==", "bodyText": "Terminology note / nitpick: I think we should be consistent in how we're referring to v1 vs. v2 of the API.\nThe config feature flag implies we're treating these as \"v1\" vs \"v2\", but the code implies we're treating these as \"the deprecated version\" versus \"the current version\".\nMy slight preference would be to align on the v1-v2 distinction, partly because \"deprecated\" is long-winded, and partly because it's more clearly referring to different API versions.\nObviously, once this has rolled to prod and we clean up the feature flag, this would go back to having no distinction at all.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370950725", "createdAt": "2020-01-25T19:18:28Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/api/OfflineUserController.java", "diffHunk": "@@ -66,7 +73,12 @@ private boolean timestampsEqual(Timestamp a, Timestamp b) {\n         Timestamp oldTime = user.getComplianceTrainingCompletionTime();\n         DataAccessLevel oldLevel = user.getDataAccessLevelEnum();\n \n-        DbUser updatedUser = userService.syncComplianceTrainingStatus(user);\n+        DbUser updatedUser;\n+        if(workbenchConfigProvider.get().featureFlags.enableMoodleV2Api) {\n+          updatedUser = userService.syncComplianceTrainingStatus(user);\n+        } else {\n+          updatedUser = userService.syncComplianceTrainingStatusDeprecated(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDgxMg==", "bodyText": "[Naming super-nitpick] When I first read this method name, I thought the parameter would be a username. But the \"byName\" is saying something about the return map, not the parameter.\nIt might be slightly cleaner to call this \"getUserBadgesByBadgeName\", or maybe \"getUserBadgesMap\" which is more concise but less specific.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370950812", "createdAt": "2020-01-25T19:20:13Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceService.java", "diffHunk": "@@ -22,5 +24,16 @@\n    * @return list of badges/completed training by user\n    * @throws ApiException\n    */\n-  List<BadgeDetails> getUserBadge(int userMoodleId) throws ApiException;\n+  List<BadgeDetailsDeprecated> getUserBadgeDeprecated(int userMoodleId) throws ApiException;\n+\n+  /**\n+   * Get details about the Research Ethics Training and the Data Use Agreement badges for a user\n+   *\n+   * @param email\n+   * @return map of badge name to badge details\n+   * @throws ApiException\n+   */\n+  Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDk1NQ==", "bodyText": "[Naming nit] Inconsistency here: the map is called \"badges by name\", but the key variables are called \"fields\". Consider aligning everything with the \"name\" terminology, e.g. rename the constants to\nDATA_USE_AGREEMENT_BADGE or\nDUA_BADGE_NAME\nor something similar.", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370950955", "createdAt": "2020-01-25T19:23:20Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -84,4 +96,34 @@ public Integer getMoodleId(String email) throws ApiException {\n     }\n     return response.getBadges();\n   }\n+\n+  @Override\n+  public Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException {\n+    if (!enableMoodleCalls()) {\n+      return new HashMap<>();\n+    }\n+\n+    UserBadgeResponse response =\n+        moodleApiProvider.get().getMoodleBadge(RESPONSE_FORMAT, getToken(), email);\n+    if (response.getException() != null && response.getException().equals(MOODLE_EXCEPTION)) {\n+      logger.warning(response.getMessage());\n+      if (response.getErrorcode().equals(MOODLE_USER_NOT_ALLOWED_ERROR_CODE)) {\n+        throw new ApiException(HttpStatus.NOT_FOUND.value(), response.getMessage());\n+      } else {\n+        throw new ApiException(response.getMessage());\n+      }\n+    }\n+    Map<String, BadgeDetails> userBadgesByName = new HashMap<>();\n+    if (response.getDua() != null) {\n+      userBadgesByName.put(DUA_FIELD, response.getDua());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzAwNg==", "bodyText": "Shouldn't these lines be in the form: u.setFoo(dbUser.getFoo())", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370953006", "createdAt": "2020-01-25T20:04:20Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -646,6 +648,78 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n     }\n   }\n \n+  /** Syncs the current user's training status from Moodle. */\n+  public DbUser syncComplianceTrainingStatus() throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    return syncComplianceTrainingStatus(userProvider.get());\n+  }\n+\n+  /**\n+   * Updates the given user's training status from Moodle.\n+   *\n+   * <p>We can fetch Moodle data for arbitrary users since we use an API key to access Moodle,\n+   * rather than user-specific OAuth tokens.\n+   *\n+   * <p>Using the user's email, we can get their badges from Moodle's APIs. If the badges are marked\n+   * valid, we store their completion/expiration dates in the database. If they are marked invalid,\n+   * we clear the completion/expiration dates from the database as the user will need to complete a\n+   * new training.\n+   */\n+  public DbUser syncComplianceTrainingStatus(DbUser dbUser) throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    // Skip sync for service account user rows.\n+    if (isServiceAccount(dbUser)) {\n+      return dbUser;\n+    }\n+\n+    try {\n+      Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n+      Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(dbUser.getUsername());\n+      if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+        BadgeDetails complianceBadge = userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+        if(complianceBadge.getValid()) {\n+          if (dbUser.getComplianceTrainingCompletionTime() == null) {\n+            // The badge was previously invalid and is now valid.\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          } else if (!dbUser.getComplianceTrainingExpirationTime().equals(new Timestamp(complianceBadge.getDateexpire()))) {\n+            // The badge was previously valid, but has a new expiration date (and so is a new training)\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          }\n+          // Always update the expiration time.\n+          dbUser.setComplianceTrainingExpirationTime(new Timestamp(complianceBadge.getDateexpire()));\n+        }\n+        else {\n+          // The current badge is invalid or expired, the training must be completed or retaken.\n+          dbUser.clearComplianceTrainingCompletionTime();\n+          dbUser.clearComplianceTrainingExpirationTime();\n+        }\n+      }\n+      else {\n+        // There is no record of this person having taken the training.\n+        dbUser.clearComplianceTrainingCompletionTime();\n+        dbUser.clearComplianceTrainingExpirationTime();\n+      }\n+\n+      return updateUserWithRetries(\n+          u -> {\n+            u.setComplianceTrainingExpirationTime(u.getComplianceTrainingExpirationTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzA2Mw==", "bodyText": "I think it would be helpful to have this log for other types of error codes too \u2013\u00a0maybe bump this up a couple lines outside of the if-else block?", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370953063", "createdAt": "2020-01-25T20:05:35Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -646,6 +648,78 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n     }\n   }\n \n+  /** Syncs the current user's training status from Moodle. */\n+  public DbUser syncComplianceTrainingStatus() throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    return syncComplianceTrainingStatus(userProvider.get());\n+  }\n+\n+  /**\n+   * Updates the given user's training status from Moodle.\n+   *\n+   * <p>We can fetch Moodle data for arbitrary users since we use an API key to access Moodle,\n+   * rather than user-specific OAuth tokens.\n+   *\n+   * <p>Using the user's email, we can get their badges from Moodle's APIs. If the badges are marked\n+   * valid, we store their completion/expiration dates in the database. If they are marked invalid,\n+   * we clear the completion/expiration dates from the database as the user will need to complete a\n+   * new training.\n+   */\n+  public DbUser syncComplianceTrainingStatus(DbUser dbUser) throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    // Skip sync for service account user rows.\n+    if (isServiceAccount(dbUser)) {\n+      return dbUser;\n+    }\n+\n+    try {\n+      Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n+      Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(dbUser.getUsername());\n+      if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+        BadgeDetails complianceBadge = userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+        if(complianceBadge.getValid()) {\n+          if (dbUser.getComplianceTrainingCompletionTime() == null) {\n+            // The badge was previously invalid and is now valid.\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          } else if (!dbUser.getComplianceTrainingExpirationTime().equals(new Timestamp(complianceBadge.getDateexpire()))) {\n+            // The badge was previously valid, but has a new expiration date (and so is a new training)\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          }\n+          // Always update the expiration time.\n+          dbUser.setComplianceTrainingExpirationTime(new Timestamp(complianceBadge.getDateexpire()));\n+        }\n+        else {\n+          // The current badge is invalid or expired, the training must be completed or retaken.\n+          dbUser.clearComplianceTrainingCompletionTime();\n+          dbUser.clearComplianceTrainingExpirationTime();\n+        }\n+      }\n+      else {\n+        // There is no record of this person having taken the training.\n+        dbUser.clearComplianceTrainingCompletionTime();\n+        dbUser.clearComplianceTrainingExpirationTime();\n+      }\n+\n+      return updateUserWithRetries(\n+          u -> {\n+            u.setComplianceTrainingExpirationTime(u.getComplianceTrainingExpirationTime());\n+            u.setComplianceTrainingCompletionTime(u.getComplianceTrainingCompletionTime());\n+            return u;\n+          },\n+          dbUser);\n+    } catch (NumberFormatException e) {\n+      log.severe(\"Incorrect date expire format from Moodle\");\n+      throw e;\n+    } catch (org.pmiops.workbench.moodle.ApiException ex) {\n+      if (ex.getCode() == HttpStatus.NOT_FOUND.value()) {\n+        log.severe(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f81728e28a0f64597e24129deb0de4a0909fefe8"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4ODIzMTk2", "url": "https://github.com/all-of-us/workbench/pull/3032#pullrequestreview-348823196", "createdAt": "2020-01-27T16:59:58Z", "commit": {"oid": "73e740f6274e3d6aabc97fc2fdb4c1864c0339f0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4ODI0NzQ3", "url": "https://github.com/all-of-us/workbench/pull/3032#pullrequestreview-348824747", "createdAt": "2020-01-27T17:02:08Z", "commit": {"oid": "73e740f6274e3d6aabc97fc2fdb4c1864c0339f0"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd0dedb85c19b65293c698c59039f13e370d2f39", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/cd0dedb85c19b65293c698c59039f13e370d2f39", "committedDate": "2020-01-29T19:47:37Z", "message": "add feature flag, first pass on implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ced91dc6dbb8149e962dd2910b39d3c9ee4fa151", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/ced91dc6dbb8149e962dd2910b39d3c9ee4fa151", "committedDate": "2020-01-29T19:47:37Z", "message": "actually hitting v2 server"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25381e8b897c8fd01ca628c0f836d732a37d7de5", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/25381e8b897c8fd01ca628c0f836d732a37d7de5", "committedDate": "2020-01-29T19:47:38Z", "message": "change v1 to deprecated"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa9ac275508ad60ef7a4573bd51da12319de35fe", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/fa9ac275508ad60ef7a4573bd51da12319de35fe", "committedDate": "2020-01-29T19:47:51Z", "message": "test in sync with local"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "874cbea22a2b98406609a6dcf1ce0037d9a7ea39", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/874cbea22a2b98406609a6dcf1ce0037d9a7ea39", "committedDate": "2020-01-29T19:47:51Z", "message": "correct comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e46c180b822b77bea1971eee21ea0cafc1f91a52", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/e46c180b822b77bea1971eee21ea0cafc1f91a52", "committedDate": "2020-01-29T19:47:51Z", "message": "remove v1s..."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c11c83e14a4b9b661f614107d87e437f43102535", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/c11c83e14a4b9b661f614107d87e437f43102535", "committedDate": "2020-01-29T19:47:51Z", "message": "spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "809f68ca85b2a50343444cc199b0babcd1a78d3a", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/809f68ca85b2a50343444cc199b0babcd1a78d3a", "committedDate": "2020-01-29T19:47:51Z", "message": "new test, remove snark, remove print statements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26950b849183645a0b9cf983ab2743d365549c8f", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/26950b849183645a0b9cf983ab2743d365549c8f", "committedDate": "2020-01-29T19:47:51Z", "message": "globalexpiration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24bc835dcbe9b6f993f19d30117962ee7bc49f95", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/24bc835dcbe9b6f993f19d30117962ee7bc49f95", "committedDate": "2020-01-29T19:47:51Z", "message": "better tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b39593bfb6021f14166976b2973e3223262bf43e", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/b39593bfb6021f14166976b2973e3223262bf43e", "committedDate": "2020-01-29T19:47:51Z", "message": "test and local in sync..."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7b96c03ade23a09fc370b2fa14dd2b242d9d744", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/e7b96c03ade23a09fc370b2fa14dd2b242d9d744", "committedDate": "2020-01-29T19:47:51Z", "message": "some review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9992b0497cee291b8261fd411efc37da4f8621ff", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/9992b0497cee291b8261fd411efc37da4f8621ff", "committedDate": "2020-01-29T19:47:51Z", "message": "two separate functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef10a957237dec79600927e10500c0817b30442e", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/ef10a957237dec79600927e10500c0817b30442e", "committedDate": "2020-01-29T19:47:51Z", "message": "intify"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "701412b57611710c9af2472640fa7fa40f39700c", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/701412b57611710c9af2472640fa7fa40f39700c", "committedDate": "2020-01-29T19:47:51Z", "message": "wtf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49f4fe8ee265dd05948f88af2dcbd9f5127f3ab0", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/49f4fe8ee265dd05948f88af2dcbd9f5127f3ab0", "committedDate": "2020-01-29T19:47:51Z", "message": "ugh further cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fc7c21747b5cac76b89bba069c82f8966e2d732", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/6fc7c21747b5cac76b89bba069c82f8966e2d732", "committedDate": "2020-01-29T19:47:51Z", "message": "one more Deprecated tag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8dfa5d3da04703c9762f4d229bccb3c94b18a94", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/c8dfa5d3da04703c9762f4d229bccb3c94b18a94", "committedDate": "2020-01-29T19:47:51Z", "message": "second round of feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e05c99bdb8e86cc86654f10f710a0f3b5a99bace", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/e05c99bdb8e86cc86654f10f710a0f3b5a99bace", "committedDate": "2020-01-29T19:47:51Z", "message": "offlineusercontrollertest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a2fa2f052fcf7a06369ba7cf9a5d24718b185a1", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/5a2fa2f052fcf7a06369ba7cf9a5d24718b185a1", "committedDate": "2020-01-29T19:47:51Z", "message": "rename a couple more Deprecateds, rename new moodle credential key in buckets"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b02fc96ca55d0d776b28127e735e1fa330a8225", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/6b02fc96ca55d0d776b28127e735e1fa330a8225", "committedDate": "2020-01-29T19:47:51Z", "message": "stateful bad four legs good"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e19901eb2bd32d0bf57d0ec17b7fc644bde23670", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/e19901eb2bd32d0bf57d0ec17b7fc644bde23670", "committedDate": "2020-01-29T19:47:51Z", "message": "spotless"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c6f1813c7a7e598e88de80cf3b449b25366e3cad", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/c6f1813c7a7e598e88de80cf3b449b25366e3cad", "committedDate": "2020-01-29T19:38:06Z", "message": "spotless"}, "afterCommit": {"oid": "e19901eb2bd32d0bf57d0ec17b7fc644bde23670", "author": {"user": null}, "url": "https://github.com/all-of-us/workbench/commit/e19901eb2bd32d0bf57d0ec17b7fc644bde23670", "committedDate": "2020-01-29T19:47:51Z", "message": "spotless"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3722, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}