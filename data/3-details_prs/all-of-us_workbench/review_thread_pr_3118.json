{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczODk3MTMx", "number": 3118, "reviewThreads": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0Mjo0M1rODe-Nzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjozMTo0MVrODfWwRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODAzMjE0OnYy", "diffSide": "RIGHT", "path": "api/db/changelog/db.changelog-126-institution-foreign-key.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0Mjo0M1rOFoaOCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0Mjo0M1rOFoaOCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxNjkzOA==", "bodyText": "adds delete cascade", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377916938", "createdAt": "2020-02-11T21:42:43Z", "author": {"login": "jmthibault79"}, "path": "api/db/changelog/db.changelog-126-institution-foreign-key.xml", "diffHunk": "@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<databaseChangeLog\n+  xmlns=\"http://www.liquibase.org/xml/ns/dbchangelog/1.9\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://www.liquibase.org/xml/ns/dbchangelog/1.9\n+                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-1.9.xsd\">\n+  <changeSet author=\"brianfreeman\" id=\"changelog-126-institution-foreign-key\">\n+\n+    <dropForeignKeyConstraint\n+      baseTableName=\"institution_email_domain\"\n+      constraintName=\"fk_institution_email_domain\"/>\n+\n+    <addForeignKeyConstraint baseColumnNames=\"institution_id\"\n+      baseTableName=\"institution_email_domain\"\n+      constraintName=\"fk_institution_email_domain\"\n+      onDelete=\"CASCADE\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODAzMzU1OnYy", "diffSide": "LEFT", "path": "api/src/main/java/org/pmiops/workbench/db/dao/InstitutionEmailAddressDao.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0MzowN1rOFoaO5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0MzowN1rOFoaO5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxNzE1Ng==", "bodyText": "These are now fully managed by DbInstitution", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377917156", "createdAt": "2020-02-11T21:43:07Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/dao/InstitutionEmailAddressDao.java", "diffHunk": "@@ -1,16 +0,0 @@\n-package org.pmiops.workbench.db.dao;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODAzOTY3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0NTowNFrOFoaSyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjozNjowNVrOFpBC_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxODE1NQ==", "bodyText": "RW best practices are to annotate the accessors, not the fields.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377918155", "createdAt": "2020-02-11T21:45:04Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,41 +12,35 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNzIzOA==", "bodyText": "Do we have a doc for those practices yet?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378537238", "createdAt": "2020-02-12T21:59:21Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,41 +12,35 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxODE1NQ=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MzA4NA==", "bodyText": "I will start one", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378553084", "createdAt": "2020-02-12T22:36:05Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,41 +12,35 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxODE1NQ=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODA0ODQ2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo0Nzo1OVrOFoaYOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoxODo1MVrOFobPRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxOTU0Ng==", "bodyText": "EAGER fetching is key to making this work correctly.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377919546", "createdAt": "2020-02-11T21:47:59Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMzYzNw==", "bodyText": "Huh, you don't have to give it the key column names. Neat.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377933637", "createdAt": "2020-02-11T22:18:51Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxOTU0Ng=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODA1NzExOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1MDo1MFrOFoad8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTowMToxMVrOFo6yaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTAwOA==", "bodyText": "Need to make the connection in both directions, but we only need to break it in one.  It is NOT necessary to make this null when removing.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377921008", "createdAt": "2020-02-11T21:50:50Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNDIyMw==", "bodyText": "nit: why are you calling the map variable address instead of ed or similar? I didn't think domains were addresses.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377934223", "createdAt": "2020-02-11T22:20:17Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTAwOA=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ1MDUzOQ==", "bodyText": "copypasta.  good catch.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378450539", "createdAt": "2020-02-12T19:01:11Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTAwOA=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODA2Mjc2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1Mjo0NlrOFoahgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1Mjo0NlrOFoahgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTkyMg==", "bodyText": "API Model <-> DB Model conversions are now fully independent of DB state!\nTODO (not in this PR) move conversions out of here into a MapStruct mapper.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377921922", "createdAt": "2020-02-11T21:52:46Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,50 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODE0NDI0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoyMjowNVrOFobU4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTozMDoxN1rOFo7uhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNTA3Mg==", "bodyText": "Can you explain at a higher level what this function is trying to accomplish? That is, why are we doing multiple set intersections? And why do we need a set difference if emailAddresses is a set to begin with? I thought adding an existing item was a no-op.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377935072", "createdAt": "2020-02-11T22:22:05Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution emailDomains(Set<DbInstitutionEmailDomain> emailDomains) {\n+    setEmailDomains(emailDomains);\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ2NTkyNg==", "bodyText": "Added a comment.  Effectively it is doing a simple set assignment.\nFor the last step, we could add the difference or the whole set again.  Should be identical.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378465926", "createdAt": "2020-02-12T19:30:17Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution emailDomains(Set<DbInstitutionEmailDomain> emailDomains) {\n+    setEmailDomains(emailDomains);\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNTA3Mg=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODE1MTY3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoyNDo0NVrOFobZgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTozMDozNFrOFo7vJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNjI1Ng==", "bodyText": "For clarity, I would make a public nested Builder class and put this there? An example is here. Though I guess you still need your no-arg ctor \ud83e\udd14 .\nAnyway, I wouldn't make an alias function (a non-overload with the same body) unless there's a compelling reason.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377936256", "createdAt": "2020-02-11T22:24:45Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution emailDomains(Set<DbInstitutionEmailDomain> emailDomains) {\n+    setEmailDomains(emailDomains);\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailAddresses the new set of addresses for this Institution\n+   */\n+  public void setEmailAddresses(final Set<DbInstitutionEmailAddress> emailAddresses) {\n+    final Set<DbInstitutionEmailAddress> attachedAddresses =\n+        emailAddresses.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailAddresses.retainAll(attachedAddresses);\n+    this.emailAddresses.addAll(Sets.difference(attachedAddresses, this.emailAddresses));\n+  }\n+\n+  /** Builder method to help streamline the building of a DbInstitution. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ2NjA4NA==", "bodyText": "Merged these to avoid confusion", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378466084", "createdAt": "2020-02-12T19:30:34Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution emailDomains(Set<DbInstitutionEmailDomain> emailDomains) {\n+    setEmailDomains(emailDomains);\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailAddresses the new set of addresses for this Institution\n+   */\n+  public void setEmailAddresses(final Set<DbInstitutionEmailAddress> emailAddresses) {\n+    final Set<DbInstitutionEmailAddress> attachedAddresses =\n+        emailAddresses.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailAddresses.retainAll(attachedAddresses);\n+    this.emailAddresses.addAll(Sets.difference(attachedAddresses, this.emailAddresses));\n+  }\n+\n+  /** Builder method to help streamline the building of a DbInstitution. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNjI1Ng=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODE1Nzc0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoyNjo0NFrOFobdFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1NjoyN1rOFo__yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzE3NA==", "bodyText": "If this is nullable, should we return Optional<Long>?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377937174", "createdAt": "2020-02-11T22:26:44Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "diffHunk": "@@ -15,51 +15,57 @@\n @Table(name = \"institution_email_address\")\n public class DbInstitutionEmailAddress {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_email_address_id\")\n   private long institutionEmailAddressId;\n-\n-  @ManyToOne(fetch = FetchType.LAZY)\n-  @JoinColumn(name = \"institution_id\")\n   private DbInstitution institution;\n-\n-  @Column(name = \"email_address\", nullable = false)\n   private String emailAddress;\n \n   public DbInstitutionEmailAddress() {}\n \n-  public DbInstitutionEmailAddress(DbInstitution institution, String emailAddress) {\n-    this.institution = institution;\n-    this.emailAddress = emailAddress;\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_email_address_id\")\n+  public long getInstitutionEmailAddressId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ2NjIxMg==", "bodyText": "It is not nullable.  Thanks for the catch.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378466212", "createdAt": "2020-02-12T19:30:48Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "diffHunk": "@@ -15,51 +15,57 @@\n @Table(name = \"institution_email_address\")\n public class DbInstitutionEmailAddress {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_email_address_id\")\n   private long institutionEmailAddressId;\n-\n-  @ManyToOne(fetch = FetchType.LAZY)\n-  @JoinColumn(name = \"institution_id\")\n   private DbInstitution institution;\n-\n-  @Column(name = \"email_address\", nullable = false)\n   private String emailAddress;\n \n   public DbInstitutionEmailAddress() {}\n \n-  public DbInstitutionEmailAddress(DbInstitution institution, String emailAddress) {\n-    this.institution = institution;\n-    this.emailAddress = emailAddress;\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_email_address_id\")\n+  public long getInstitutionEmailAddressId() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzE3NA=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTg4MA==", "bodyText": "Oh I thought it was boxed. nvm.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378535880", "createdAt": "2020-02-12T21:56:27Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "diffHunk": "@@ -15,51 +15,57 @@\n @Table(name = \"institution_email_address\")\n public class DbInstitutionEmailAddress {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_email_address_id\")\n   private long institutionEmailAddressId;\n-\n-  @ManyToOne(fetch = FetchType.LAZY)\n-  @JoinColumn(name = \"institution_id\")\n   private DbInstitution institution;\n-\n-  @Column(name = \"email_address\", nullable = false)\n   private String emailAddress;\n \n   public DbInstitutionEmailAddress() {}\n \n-  public DbInstitutionEmailAddress(DbInstitution institution, String emailAddress) {\n-    this.institution = institution;\n-    this.emailAddress = emailAddress;\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_email_address_id\")\n+  public long getInstitutionEmailAddressId() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzE3NA=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODE2MTgyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoyODoyMlrOFobflA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoxODoxNVrOFpAl2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzgxMg==", "bodyText": "I'd probably put this on the dao itself as a default List<Institution> getAllInstitutions() so all services using it get the benefit.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377937812", "createdAt": "2020-02-11T22:28:22Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -19,34 +17,27 @@\n public class InstitutionServiceImpl implements InstitutionService {\n \n   private final InstitutionDao institutionDao;\n-  private final InstitutionEmailDomainDao institutionEmailDomainDao;\n-  private final InstitutionEmailAddressDao institutionEmailAddressDao;\n \n   @Autowired\n-  InstitutionServiceImpl(\n-      InstitutionDao institutionDao,\n-      InstitutionEmailDomainDao institutionEmailDomainDao,\n-      InstitutionEmailAddressDao institutionEmailAddressDao) {\n+  InstitutionServiceImpl(InstitutionDao institutionDao) {\n     this.institutionDao = institutionDao;\n-    this.institutionEmailDomainDao = institutionEmailDomainDao;\n-    this.institutionEmailAddressDao = institutionEmailAddressDao;\n   }\n \n   @Override\n   public List<Institution> getInstitutions() {\n     return StreamSupport.stream(institutionDao.findAll().spliterator(), false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ1NzU4Ng==", "bodyText": "Should our DAO level be aware of our API?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378457586", "createdAt": "2020-02-12T19:14:43Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -19,34 +17,27 @@\n public class InstitutionServiceImpl implements InstitutionService {\n \n   private final InstitutionDao institutionDao;\n-  private final InstitutionEmailDomainDao institutionEmailDomainDao;\n-  private final InstitutionEmailAddressDao institutionEmailAddressDao;\n \n   @Autowired\n-  InstitutionServiceImpl(\n-      InstitutionDao institutionDao,\n-      InstitutionEmailDomainDao institutionEmailDomainDao,\n-      InstitutionEmailAddressDao institutionEmailAddressDao) {\n+  InstitutionServiceImpl(InstitutionDao institutionDao) {\n     this.institutionDao = institutionDao;\n-    this.institutionEmailDomainDao = institutionEmailDomainDao;\n-    this.institutionEmailAddressDao = institutionEmailAddressDao;\n   }\n \n   @Override\n   public List<Institution> getInstitutions() {\n     return StreamSupport.stream(institutionDao.findAll().spliterator(), false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzgxMg=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NTYyNQ==", "bodyText": "You mean of the type? Good point. In practice there's not much cyclical dependence added but you're right.\nThis is why I think we need a DataManager layer.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378545625", "createdAt": "2020-02-12T22:18:15Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -19,34 +17,27 @@\n public class InstitutionServiceImpl implements InstitutionService {\n \n   private final InstitutionDao institutionDao;\n-  private final InstitutionEmailDomainDao institutionEmailDomainDao;\n-  private final InstitutionEmailAddressDao institutionEmailAddressDao;\n \n   @Autowired\n-  InstitutionServiceImpl(\n-      InstitutionDao institutionDao,\n-      InstitutionEmailDomainDao institutionEmailDomainDao,\n-      InstitutionEmailAddressDao institutionEmailAddressDao) {\n+  InstitutionServiceImpl(InstitutionDao institutionDao) {\n     this.institutionDao = institutionDao;\n-    this.institutionEmailDomainDao = institutionEmailDomainDao;\n-    this.institutionEmailAddressDao = institutionEmailAddressDao;\n   }\n \n   @Override\n   public List<Institution> getInstitutions() {\n     return StreamSupport.stream(institutionDao.findAll().spliterator(), false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzgxMg=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODE2ODAzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjozMDo0MFrOFobjTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTozMTowOFrOFo7wYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzODc2NQ==", "bodyText": "With the db objects, we can (and I think should) avoid returning null for collections. We don't have a choice with the generated classes though.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377938765", "createdAt": "2020-02-11T22:30:40Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,50 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {\n+    return updateDbObject(new DbInstitution(), modelObject);\n   }\n \n-  private DbInstitution saveInstitutionEmailPatterns(\n-      final Institution modelClass, final DbInstitution dbClass) {\n-\n-    institutionEmailDomainDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                dbClass.setEmailDomains(\n-                    institutionEmailDomainDao.save(\n-                        domains.stream()\n-                            .map(domain -> new DbInstitutionEmailDomain(dbClass, domain))\n-                            .collect(Collectors.toSet()))));\n-\n-    institutionEmailAddressDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                dbClass.setEmailAddresses(\n-                    institutionEmailAddressDao.save(\n-                        addresses.stream()\n-                            .map(address -> new DbInstitutionEmailAddress(dbClass, address))\n-                            .collect(Collectors.toSet()))));\n-\n-    return institutionDao.save(dbClass);\n+  private DbInstitution updateDbObject(\n+      final DbInstitution dbObject, final Institution modelObject) {\n+    return dbObject\n+        .shortName(modelObject.getShortName())\n+        .displayName(modelObject.getDisplayName())\n+        .organizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .organizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .emailDomains(\n+            Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n+                .collect(Collectors.toSet()))\n+        .emailAddresses(\n+            Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(address -> new DbInstitutionEmailAddress().setEmailAddress(address))\n+                .collect(Collectors.toSet()));\n   }\n \n-  private Institution toModelClass(final DbInstitution dbClass) {\n-    final Institution institution =\n-        new Institution()\n-            .shortName(dbClass.getShortName())\n-            .displayName(dbClass.getDisplayName())\n-            .organizationTypeEnum(\n-                DbStorageEnums.organizationTypeFromStorage(dbClass.getOrganizationTypeEnum()))\n-            .organizationTypeOtherText(dbClass.getOrganizationTypeOtherText());\n-\n-    Optional.ofNullable(dbClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                institution.emailDomains(\n-                    domains.stream()\n-                        .map(DbInstitutionEmailDomain::getEmailDomain)\n-                        .collect(Collectors.toList())));\n-\n-    Optional.ofNullable(dbClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                institution.emailAddresses(\n-                    addresses.stream()\n-                        .map(DbInstitutionEmailAddress::getEmailAddress)\n-                        .collect(Collectors.toList())));\n-\n-    return institution;\n+  private Institution toModel(final DbInstitution dbObject) {\n+    return new Institution()\n+        .shortName(dbObject.getShortName())\n+        .displayName(dbObject.getDisplayName())\n+        .organizationTypeEnum(dbObject.getOrganizationTypeEnum())\n+        .organizationTypeOtherText(dbObject.getOrganizationTypeOtherText())\n+        .emailDomains(\n+            Optional.ofNullable(dbObject.getEmailDomains()).orElse(Collections.emptySet()).stream()\n+                .map(DbInstitutionEmailDomain::getEmailDomain)\n+                .collect(Collectors.toList()))\n+        .emailAddresses(\n+            Optional.ofNullable(dbObject.getEmailAddresses()).orElse(Collections.emptySet())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAwMzc5Nw==", "bodyText": "Actually dbObject.getEmailAddresses() should never be null, since emailAddresses is initialized -> https://github.com/all-of-us/workbench/blob/joel/hibernate-institution/api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java#L28-L28 Hibernate also calls the setEmailAddresses(final Set emailAddresses) with an empty collection if no emailAddresses exist. This test verifies this: https://github.com/all-of-us/workbench/blob/joel/hibernate-institution/api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java#L64-L64", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378003797", "createdAt": "2020-02-12T02:01:35Z", "author": {"login": "freemabd"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,50 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {\n+    return updateDbObject(new DbInstitution(), modelObject);\n   }\n \n-  private DbInstitution saveInstitutionEmailPatterns(\n-      final Institution modelClass, final DbInstitution dbClass) {\n-\n-    institutionEmailDomainDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                dbClass.setEmailDomains(\n-                    institutionEmailDomainDao.save(\n-                        domains.stream()\n-                            .map(domain -> new DbInstitutionEmailDomain(dbClass, domain))\n-                            .collect(Collectors.toSet()))));\n-\n-    institutionEmailAddressDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                dbClass.setEmailAddresses(\n-                    institutionEmailAddressDao.save(\n-                        addresses.stream()\n-                            .map(address -> new DbInstitutionEmailAddress(dbClass, address))\n-                            .collect(Collectors.toSet()))));\n-\n-    return institutionDao.save(dbClass);\n+  private DbInstitution updateDbObject(\n+      final DbInstitution dbObject, final Institution modelObject) {\n+    return dbObject\n+        .shortName(modelObject.getShortName())\n+        .displayName(modelObject.getDisplayName())\n+        .organizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .organizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .emailDomains(\n+            Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n+                .collect(Collectors.toSet()))\n+        .emailAddresses(\n+            Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(address -> new DbInstitutionEmailAddress().setEmailAddress(address))\n+                .collect(Collectors.toSet()));\n   }\n \n-  private Institution toModelClass(final DbInstitution dbClass) {\n-    final Institution institution =\n-        new Institution()\n-            .shortName(dbClass.getShortName())\n-            .displayName(dbClass.getDisplayName())\n-            .organizationTypeEnum(\n-                DbStorageEnums.organizationTypeFromStorage(dbClass.getOrganizationTypeEnum()))\n-            .organizationTypeOtherText(dbClass.getOrganizationTypeOtherText());\n-\n-    Optional.ofNullable(dbClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                institution.emailDomains(\n-                    domains.stream()\n-                        .map(DbInstitutionEmailDomain::getEmailDomain)\n-                        .collect(Collectors.toList())));\n-\n-    Optional.ofNullable(dbClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                institution.emailAddresses(\n-                    addresses.stream()\n-                        .map(DbInstitutionEmailAddress::getEmailAddress)\n-                        .collect(Collectors.toList())));\n-\n-    return institution;\n+  private Institution toModel(final DbInstitution dbObject) {\n+    return new Institution()\n+        .shortName(dbObject.getShortName())\n+        .displayName(dbObject.getDisplayName())\n+        .organizationTypeEnum(dbObject.getOrganizationTypeEnum())\n+        .organizationTypeOtherText(dbObject.getOrganizationTypeOtherText())\n+        .emailDomains(\n+            Optional.ofNullable(dbObject.getEmailDomains()).orElse(Collections.emptySet()).stream()\n+                .map(DbInstitutionEmailDomain::getEmailDomain)\n+                .collect(Collectors.toList()))\n+        .emailAddresses(\n+            Optional.ofNullable(dbObject.getEmailAddresses()).orElse(Collections.emptySet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzODc2NQ=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ2NjQwMQ==", "bodyText": "Good point - updated", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378466401", "createdAt": "2020-02-12T19:31:08Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,50 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {\n+    return updateDbObject(new DbInstitution(), modelObject);\n   }\n \n-  private DbInstitution saveInstitutionEmailPatterns(\n-      final Institution modelClass, final DbInstitution dbClass) {\n-\n-    institutionEmailDomainDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                dbClass.setEmailDomains(\n-                    institutionEmailDomainDao.save(\n-                        domains.stream()\n-                            .map(domain -> new DbInstitutionEmailDomain(dbClass, domain))\n-                            .collect(Collectors.toSet()))));\n-\n-    institutionEmailAddressDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                dbClass.setEmailAddresses(\n-                    institutionEmailAddressDao.save(\n-                        addresses.stream()\n-                            .map(address -> new DbInstitutionEmailAddress(dbClass, address))\n-                            .collect(Collectors.toSet()))));\n-\n-    return institutionDao.save(dbClass);\n+  private DbInstitution updateDbObject(\n+      final DbInstitution dbObject, final Institution modelObject) {\n+    return dbObject\n+        .shortName(modelObject.getShortName())\n+        .displayName(modelObject.getDisplayName())\n+        .organizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .organizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .emailDomains(\n+            Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n+                .collect(Collectors.toSet()))\n+        .emailAddresses(\n+            Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(address -> new DbInstitutionEmailAddress().setEmailAddress(address))\n+                .collect(Collectors.toSet()));\n   }\n \n-  private Institution toModelClass(final DbInstitution dbClass) {\n-    final Institution institution =\n-        new Institution()\n-            .shortName(dbClass.getShortName())\n-            .displayName(dbClass.getDisplayName())\n-            .organizationTypeEnum(\n-                DbStorageEnums.organizationTypeFromStorage(dbClass.getOrganizationTypeEnum()))\n-            .organizationTypeOtherText(dbClass.getOrganizationTypeOtherText());\n-\n-    Optional.ofNullable(dbClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                institution.emailDomains(\n-                    domains.stream()\n-                        .map(DbInstitutionEmailDomain::getEmailDomain)\n-                        .collect(Collectors.toList())));\n-\n-    Optional.ofNullable(dbClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                institution.emailAddresses(\n-                    addresses.stream()\n-                        .map(DbInstitutionEmailAddress::getEmailAddress)\n-                        .collect(Collectors.toList())));\n-\n-    return institution;\n+  private Institution toModel(final DbInstitution dbObject) {\n+    return new Institution()\n+        .shortName(dbObject.getShortName())\n+        .displayName(dbObject.getDisplayName())\n+        .organizationTypeEnum(dbObject.getOrganizationTypeEnum())\n+        .organizationTypeOtherText(dbObject.getOrganizationTypeOtherText())\n+        .emailDomains(\n+            Optional.ofNullable(dbObject.getEmailDomains()).orElse(Collections.emptySet()).stream()\n+                .map(DbInstitutionEmailDomain::getEmailDomain)\n+                .collect(Collectors.toList()))\n+        .emailAddresses(\n+            Optional.ofNullable(dbObject.getEmailAddresses()).orElse(Collections.emptySet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzODc2NQ=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODE3NDE3OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjozMjo1NlrOFobnCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTo0MDoyOFrOFo8DPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzOTcyMA==", "bodyText": "code under test shouldn't really be executed in setup() if we can avoid it. It's just for mocks and fixtures.  You'll still fail your tests if it blows up, but you should ideally have assertions after important steps, especially in a test_save() method.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377939720", "createdAt": "2020-02-11T22:32:56Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,175 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().shortName(\"Broad\").displayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Stream.of(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"))\n+            .collect(Collectors.toCollection(HashSet::new));\n+    emailDomains =\n+        Stream.of(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"))\n+            .collect(Collectors.toCollection(HashSet::new));\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .shortName(\"Broad1\")\n+                .displayName(\"The Broad Institute\")\n+                .emailAddresses(emailAddresses)\n+                .emailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    // no need to call save since we have a setup method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3MTIzMA==", "bodyText": "updated", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378471230", "createdAt": "2020-02-12T19:40:28Z", "author": {"login": "jmthibault79"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,175 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().shortName(\"Broad\").displayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Stream.of(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"))\n+            .collect(Collectors.toCollection(HashSet::new));\n+    emailDomains =\n+        Stream.of(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"))\n+            .collect(Collectors.toCollection(HashSet::new));\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .shortName(\"Broad1\")\n+                .displayName(\"The Broad Institute\")\n+                .emailAddresses(emailAddresses)\n+                .emailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    // no need to call save since we have a setup method.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzOTcyMA=="}, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODE4NjY1OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/pmiops/workbench/institution/InstitutionServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjozNzoxNlrOFobuZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjozNzoxNlrOFobuZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MTYwNQ==", "bodyText": "So if you want to use the builder paradigm, you could make a billed() method that fills in missing array values and other defaultable things.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377941605", "createdAt": "2020-02-11T22:37:16Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/institution/InstitutionServiceTest.java", "diffHunk": "@@ -49,25 +59,32 @@ public void test_deleteInstitution() {\n \n   @Test\n   public void test_getInstitutions() {\n-    assertThat(service.getInstitutions()).containsExactlyElementsIn(ImmutableList.of(testInst));\n+    assertThat(service.getInstitutions()).containsExactly(testInstAfterRT);\n \n     final Institution otherInst =\n-        new Institution().shortName(\"otherInst\").displayName(\"The Institution of testing\");\n+        new Institution()\n+            .shortName(\"otherInst\")\n+            .displayName(\"The Institution of testing\")\n+            .emailDomains(new ArrayList<>())\n+            .emailAddresses(new ArrayList<>());\n     service.createInstitution(otherInst);\n-    assertThat(service.getInstitutions())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+    assertThat(service.getInstitutions()).containsExactly(testInstAfterRT, otherInst);\n \n     service.deleteInstitution(testInst.getShortName());\n-    assertThat(service.getInstitutions()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+    assertThat(service.getInstitutions()).containsExactly(otherInst);\n   }\n \n   @Test\n   public void test_getInstitution() {\n-    assertThat(service.getInstitution(testInst.getShortName())).hasValue(testInst);\n+    assertThat(service.getInstitution(testInst.getShortName())).hasValue(testInstAfterRT);\n     assertThat(service.getInstitution(\"otherInst\")).isEmpty();\n \n     final Institution otherInst =\n-        new Institution().shortName(\"otherInst\").displayName(\"The Institution of testing\");\n+        new Institution()\n+            .shortName(\"otherInst\")\n+            .displayName(\"The Institution of testing\")\n+            .emailAddresses(new ArrayList<>())\n+            .emailDomains(new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTU4MjA5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTo0ODowOVrOFo8TqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoxOToyNVrOFpAnvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3NTQzMw==", "bodyText": "This will also not be null but an empty collection.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378475433", "createdAt": "2020-02-12T19:48:09Z", "author": {"login": "freemabd"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -69,16 +69,16 @@ private DbInstitution newDbObject(final Institution modelObject) {\n   private DbInstitution updateDbObject(\n       final DbInstitution dbObject, final Institution modelObject) {\n     return dbObject\n-        .shortName(modelObject.getShortName())\n-        .displayName(modelObject.getDisplayName())\n-        .organizationTypeEnum(modelObject.getOrganizationTypeEnum())\n-        .organizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n-        .emailDomains(\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(\n             Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n                 .stream()\n                 .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n                 .collect(Collectors.toSet()))\n-        .emailAddresses(\n+        .setEmailAddresses(\n             Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ4MDc2NQ==", "bodyText": "I don't think we can guarantee this because it's generated by Swagger with a null default:\n  private List<String> emailAddresses = null;", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378480765", "createdAt": "2020-02-12T19:58:22Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -69,16 +69,16 @@ private DbInstitution newDbObject(final Institution modelObject) {\n   private DbInstitution updateDbObject(\n       final DbInstitution dbObject, final Institution modelObject) {\n     return dbObject\n-        .shortName(modelObject.getShortName())\n-        .displayName(modelObject.getDisplayName())\n-        .organizationTypeEnum(modelObject.getOrganizationTypeEnum())\n-        .organizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n-        .emailDomains(\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(\n             Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n                 .stream()\n                 .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n                 .collect(Collectors.toSet()))\n-        .emailAddresses(\n+        .setEmailAddresses(\n             Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3NTQzMw=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ4MzA3NA==", "bodyText": "gotcha", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378483074", "createdAt": "2020-02-12T20:03:00Z", "author": {"login": "freemabd"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -69,16 +69,16 @@ private DbInstitution newDbObject(final Institution modelObject) {\n   private DbInstitution updateDbObject(\n       final DbInstitution dbObject, final Institution modelObject) {\n     return dbObject\n-        .shortName(modelObject.getShortName())\n-        .displayName(modelObject.getDisplayName())\n-        .organizationTypeEnum(modelObject.getOrganizationTypeEnum())\n-        .organizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n-        .emailDomains(\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(\n             Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n                 .stream()\n                 .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n                 .collect(Collectors.toSet()))\n-        .emailAddresses(\n+        .setEmailAddresses(\n             Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3NTQzMw=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NjExMQ==", "bodyText": "I had a proposal for API object factories to help with that, but it didn't make it far.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378546111", "createdAt": "2020-02-12T22:19:25Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -69,16 +69,16 @@ private DbInstitution newDbObject(final Institution modelObject) {\n   private DbInstitution updateDbObject(\n       final DbInstitution dbObject, final Institution modelObject) {\n     return dbObject\n-        .shortName(modelObject.getShortName())\n-        .displayName(modelObject.getDisplayName())\n-        .organizationTypeEnum(modelObject.getOrganizationTypeEnum())\n-        .organizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n-        .emailDomains(\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(\n             Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n                 .stream()\n                 .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n                 .collect(Collectors.toSet()))\n-        .emailAddresses(\n+        .setEmailAddresses(\n             Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3NTQzMw=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk2MjI2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1ODoxMVrOFpAC4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1ODoxMVrOFpAC4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNjY3NQ==", "bodyText": "Do you not need to have a Hibernate annotation for this like @Id?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378536675", "createdAt": "2020-02-12T21:58:11Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk2ODc5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjowMDozMFrOFpAHFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo0MDowMVrOFpBJQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNzc1MQ==", "bodyText": "So should we assert that the enum value is actually other when setting this? Should we just go ahead and update it if we're setting this? They're a package deal.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378537751", "createdAt": "2020-02-12T22:00:30Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NDY4OQ==", "bodyText": "We have no real requirement for this, so I'm keeping it loose to avoid added complexity.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378554689", "createdAt": "2020-02-12T22:40:01Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNzc1MQ=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk3MzY0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjowMjoxMVrOFpAKMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjowMjoxMVrOFpAKMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzODU0NA==", "bodyText": "Yay for fluent methods.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378538544", "createdAt": "2020-02-12T22:02:11Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk4ODQwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjowNzoyM1rOFpATjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjowNzoyM1rOFpATjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0MDk0Mg==", "bodyText": "This looks like you're manually doing Hibernate's job. It seems really odd to me for an entity to take in a set of things it owns, then modify them and save them. I'd much rather see immutable email domain objects being pointed to by this set, unless you have a really urgent reason to work with domains but not the institution. Like where in the UI would you even have such an issue?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378540942", "createdAt": "2020-02-12T22:07:23Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk5NTE5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjowOTo0M1rOFpAXxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo0MTo0M1rOFpBL4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0MjAyMA==", "bodyText": "Are these all addresses belonging to the institution's users from anywhere in the system? I wouldn't have thought to look for that here; it's more of a service method thing in our current pattern. Could you equivalently expose a set of DbUser objects? I don't really know when we do one versus the other.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378542020", "createdAt": "2020-02-12T22:09:43Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NTM2Mw==", "bodyText": "No.  These are the \"allowed\" emails from https://docs.google.com/document/d/1--wtRB14DK1qAMiz1mlEx12nT4HoUfYRjNkwQJwsycA/edit#heading=h.b5vt06vb56bp", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378555363", "createdAt": "2020-02-12T22:41:43Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0MjAyMA=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjAwMDE4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoxMTo0MFrOFpAbAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoxMTo0MFrOFpAbAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0Mjg1MA==", "bodyText": "So the intention of this function is to replace all matching email addresses with updated ones (not sure what other fields that would involve). If this isn't bound directly to the table(s), then I'm confused about the use case.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378542850", "createdAt": "2020-02-12T22:11:40Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailAddresses = emailAddresses", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjAwMzAxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoxMjo0MVrOFpAczA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo0MjoxMVrOFpBMmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0MzMwOA==", "bodyText": "does this save new ones to the database?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378543308", "createdAt": "2020-02-12T22:12:41Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailAddresses = emailAddresses\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailAddresses the new set of addresses for this Institution\n+   */\n+  public DbInstitution setEmailAddresses(final Set<DbInstitutionEmailAddress> emailAddresses) {\n+    final Set<DbInstitutionEmailAddress> attachedAddresses =\n+        emailAddresses.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailAddresses.retainAll(attachedAddresses);\n+    this.emailAddresses.addAll(Sets.difference(attachedAddresses, this.emailAddresses));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NTU0Ng==", "bodyText": "yes", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378555546", "createdAt": "2020-02-12T22:42:11Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailAddresses = emailAddresses\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailAddresses the new set of addresses for this Institution\n+   */\n+  public DbInstitution setEmailAddresses(final Set<DbInstitutionEmailAddress> emailAddresses) {\n+    final Set<DbInstitutionEmailAddress> attachedAddresses =\n+        emailAddresses.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailAddresses.retainAll(attachedAddresses);\n+    this.emailAddresses.addAll(Sets.difference(attachedAddresses, this.emailAddresses));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0MzMwOA=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjAxMDE2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoxNTozMFrOFpAhbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo0NzoyNlrOFpBUfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NDQ5NQ==", "bodyText": "I think you should only define entity objects where it makes sense to your application to use as a standalone object. As in something you think of. If it's just a table row (with no more real abstraction), then you may be able to absorb it into the containing entity.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378544495", "createdAt": "2020-02-12T22:15:30Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "diffHunk": "@@ -15,51 +15,58 @@\n @Table(name = \"institution_email_address\")\n public class DbInstitutionEmailAddress {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_email_address_id\")\n   private long institutionEmailAddressId;\n-\n-  @ManyToOne(fetch = FetchType.LAZY)\n-  @JoinColumn(name = \"institution_id\")\n   private DbInstitution institution;\n-\n-  @Column(name = \"email_address\", nullable = false)\n   private String emailAddress;\n \n   public DbInstitutionEmailAddress() {}\n \n-  public DbInstitutionEmailAddress(DbInstitution institution, String emailAddress) {\n-    this.institution = institution;\n-    this.emailAddress = emailAddress;\n+  @Id", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NzU2Nw==", "bodyText": "How would we specify which data table to use for that?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378557567", "createdAt": "2020-02-12T22:47:26Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "diffHunk": "@@ -15,51 +15,58 @@\n @Table(name = \"institution_email_address\")\n public class DbInstitutionEmailAddress {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_email_address_id\")\n   private long institutionEmailAddressId;\n-\n-  @ManyToOne(fetch = FetchType.LAZY)\n-  @JoinColumn(name = \"institution_id\")\n   private DbInstitution institution;\n-\n-  @Column(name = \"email_address\", nullable = false)\n   private String emailAddress;\n \n   public DbInstitutionEmailAddress() {}\n \n-  public DbInstitutionEmailAddress(DbInstitution institution, String emailAddress) {\n-    this.institution = institution;\n-    this.emailAddress = emailAddress;\n+  @Id", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NDQ5NQ=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjAxMjMxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoxNjoyMlrOFpAi5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo0MzoxM1rOFpBOKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NDg2OA==", "bodyText": "So this class allows the same email address to belong to more than one institution?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378544868", "createdAt": "2020-02-12T22:16:22Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "diffHunk": "@@ -15,51 +15,58 @@\n @Table(name = \"institution_email_address\")\n public class DbInstitutionEmailAddress {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_email_address_id\")\n   private long institutionEmailAddressId;\n-\n-  @ManyToOne(fetch = FetchType.LAZY)\n-  @JoinColumn(name = \"institution_id\")\n   private DbInstitution institution;\n-\n-  @Column(name = \"email_address\", nullable = false)\n   private String emailAddress;\n \n   public DbInstitutionEmailAddress() {}\n \n-  public DbInstitutionEmailAddress(DbInstitution institution, String emailAddress) {\n-    this.institution = institution;\n-    this.emailAddress = emailAddress;\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_email_address_id\", nullable = false)\n+  public long getInstitutionEmailAddressId() {\n+    return institutionEmailAddressId;\n   }\n \n+  public DbInstitutionEmailAddress setInstitutionEmailAddressId(long institutionEmailAddressId) {\n+    this.institutionEmailAddressId = institutionEmailAddressId;\n+    return this;\n+  }\n+\n+  @ManyToOne(cascade = CascadeType.ALL)\n+  @JoinColumn(name = \"institution_id\", nullable = false)\n   public DbInstitution getInstitution() {\n     return institution;\n   }\n \n+  public DbInstitutionEmailAddress setInstitution(DbInstitution institution) {\n+    this.institution = institution;\n+    return this;\n+  }\n+\n+  @Column(name = \"email_address\", nullable = false)\n   public String getEmailAddress() {\n     return emailAddress;\n   }\n \n+  public DbInstitutionEmailAddress setEmailAddress(String emailAddress) {\n+    this.emailAddress = emailAddress;\n+    return this;\n+  }\n+\n   @Override\n   public boolean equals(Object o) {\n-    if (this == o) {\n-      return true;\n-    }\n-    if (!(o instanceof DbInstitutionEmailAddress)) {\n-      return false;\n-    }\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n \n     DbInstitutionEmailAddress that = (DbInstitutionEmailAddress) o;\n \n-    return institutionEmailAddressId == that.institutionEmailAddressId\n-        && institution.equals(that.institution)\n-        && emailAddress.equals(that.emailAddress);\n+    return Objects.equals(institution, that.institution)\n+        && Objects.equals(emailAddress, that.emailAddress);\n   }\n \n   @Override\n   public int hashCode() {\n-    return Objects.hash(institutionEmailAddressId, institution, emailAddress);\n+    return Objects.hash(institution, emailAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NTk0NA==", "bodyText": "yes.  We have no requirement to exclude this.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378555944", "createdAt": "2020-02-12T22:43:13Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "diffHunk": "@@ -15,51 +15,58 @@\n @Table(name = \"institution_email_address\")\n public class DbInstitutionEmailAddress {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_email_address_id\")\n   private long institutionEmailAddressId;\n-\n-  @ManyToOne(fetch = FetchType.LAZY)\n-  @JoinColumn(name = \"institution_id\")\n   private DbInstitution institution;\n-\n-  @Column(name = \"email_address\", nullable = false)\n   private String emailAddress;\n \n   public DbInstitutionEmailAddress() {}\n \n-  public DbInstitutionEmailAddress(DbInstitution institution, String emailAddress) {\n-    this.institution = institution;\n-    this.emailAddress = emailAddress;\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_email_address_id\", nullable = false)\n+  public long getInstitutionEmailAddressId() {\n+    return institutionEmailAddressId;\n   }\n \n+  public DbInstitutionEmailAddress setInstitutionEmailAddressId(long institutionEmailAddressId) {\n+    this.institutionEmailAddressId = institutionEmailAddressId;\n+    return this;\n+  }\n+\n+  @ManyToOne(cascade = CascadeType.ALL)\n+  @JoinColumn(name = \"institution_id\", nullable = false)\n   public DbInstitution getInstitution() {\n     return institution;\n   }\n \n+  public DbInstitutionEmailAddress setInstitution(DbInstitution institution) {\n+    this.institution = institution;\n+    return this;\n+  }\n+\n+  @Column(name = \"email_address\", nullable = false)\n   public String getEmailAddress() {\n     return emailAddress;\n   }\n \n+  public DbInstitutionEmailAddress setEmailAddress(String emailAddress) {\n+    this.emailAddress = emailAddress;\n+    return this;\n+  }\n+\n   @Override\n   public boolean equals(Object o) {\n-    if (this == o) {\n-      return true;\n-    }\n-    if (!(o instanceof DbInstitutionEmailAddress)) {\n-      return false;\n-    }\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n \n     DbInstitutionEmailAddress that = (DbInstitutionEmailAddress) o;\n \n-    return institutionEmailAddressId == that.institutionEmailAddressId\n-        && institution.equals(that.institution)\n-        && emailAddress.equals(that.emailAddress);\n+    return Objects.equals(institution, that.institution)\n+        && Objects.equals(emailAddress, that.emailAddress);\n   }\n \n   @Override\n   public int hashCode() {\n-    return Objects.hash(institutionEmailAddressId, institution, emailAddress);\n+    return Objects.hash(institution, emailAddress);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NDg2OA=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjAxNDA2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoxNzowMVrOFpAj9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo0Mzo1MVrOFpBPHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NTE0MA==", "bodyText": "I think we should validate that the incoming emailAddress doesn't already have a different institution. Otherwise this is destructive to that institution's map of the world.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378545140", "createdAt": "2020-02-12T22:17:01Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailAddresses = emailAddresses\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailAddresses the new set of addresses for this Institution\n+   */\n+  public DbInstitution setEmailAddresses(final Set<DbInstitutionEmailAddress> emailAddresses) {\n+    final Set<DbInstitutionEmailAddress> attachedAddresses =\n+        emailAddresses.stream()\n+            .map(address -> address.setInstitution(this))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NjE4OQ==", "bodyText": "That is not how this works.  See the design doc.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378556189", "createdAt": "2020-02-12T22:43:51Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailAddresses = emailAddresses\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailAddresses the new set of addresses for this Institution\n+   */\n+  public DbInstitution setEmailAddresses(final Set<DbInstitutionEmailAddress> emailAddresses) {\n+    final Set<DbInstitutionEmailAddress> attachedAddresses =\n+        emailAddresses.stream()\n+            .map(address -> address.setInstitution(this))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NTE0MA=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjAyMzM1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoyMDozM1rOFpApvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo0NDoyN1rOFpBQDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NjYyMA==", "bodyText": "I like chained stream statements, but I have trouble reading nested streams. What would you think about making little helper methods to process the email domains and addresses?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378546620", "createdAt": "2020-02-12T22:20:33Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,49 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {\n+    return updateDbObject(new DbInstitution(), modelObject);\n   }\n \n-  private DbInstitution saveInstitutionEmailPatterns(\n-      final Institution modelClass, final DbInstitution dbClass) {\n-\n-    institutionEmailDomainDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                dbClass.setEmailDomains(\n-                    institutionEmailDomainDao.save(\n-                        domains.stream()\n-                            .map(domain -> new DbInstitutionEmailDomain(dbClass, domain))\n-                            .collect(Collectors.toSet()))));\n-\n-    institutionEmailAddressDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                dbClass.setEmailAddresses(\n-                    institutionEmailAddressDao.save(\n-                        addresses.stream()\n-                            .map(address -> new DbInstitutionEmailAddress(dbClass, address))\n-                            .collect(Collectors.toSet()))));\n-\n-    return institutionDao.save(dbClass);\n+  private DbInstitution updateDbObject(\n+      final DbInstitution dbObject, final Institution modelObject) {\n+    return dbObject\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NjQyOQ==", "bodyText": "That is coming tomorrow when I convert to MapStruct", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378556429", "createdAt": "2020-02-12T22:44:27Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,49 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {\n+    return updateDbObject(new DbInstitution(), modelObject);\n   }\n \n-  private DbInstitution saveInstitutionEmailPatterns(\n-      final Institution modelClass, final DbInstitution dbClass) {\n-\n-    institutionEmailDomainDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                dbClass.setEmailDomains(\n-                    institutionEmailDomainDao.save(\n-                        domains.stream()\n-                            .map(domain -> new DbInstitutionEmailDomain(dbClass, domain))\n-                            .collect(Collectors.toSet()))));\n-\n-    institutionEmailAddressDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                dbClass.setEmailAddresses(\n-                    institutionEmailAddressDao.save(\n-                        addresses.stream()\n-                            .map(address -> new DbInstitutionEmailAddress(dbClass, address))\n-                            .collect(Collectors.toSet()))));\n-\n-    return institutionDao.save(dbClass);\n+  private DbInstitution updateDbObject(\n+      final DbInstitution dbObject, final Institution modelObject) {\n+    return dbObject\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NjYyMA=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjAyNzU1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoyMjowNFrOFpAsSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo0ODozMVrOFpBWUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NzI3Mg==", "bodyText": "If the dbObject is already known, then why not fill in both the address and institution here? It wold simplify your setEmailAddresses() method as well.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378547272", "createdAt": "2020-02-12T22:22:04Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,49 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {\n+    return updateDbObject(new DbInstitution(), modelObject);\n   }\n \n-  private DbInstitution saveInstitutionEmailPatterns(\n-      final Institution modelClass, final DbInstitution dbClass) {\n-\n-    institutionEmailDomainDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                dbClass.setEmailDomains(\n-                    institutionEmailDomainDao.save(\n-                        domains.stream()\n-                            .map(domain -> new DbInstitutionEmailDomain(dbClass, domain))\n-                            .collect(Collectors.toSet()))));\n-\n-    institutionEmailAddressDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                dbClass.setEmailAddresses(\n-                    institutionEmailAddressDao.save(\n-                        addresses.stream()\n-                            .map(address -> new DbInstitutionEmailAddress(dbClass, address))\n-                            .collect(Collectors.toSet()))));\n-\n-    return institutionDao.save(dbClass);\n+  private DbInstitution updateDbObject(\n+      final DbInstitution dbObject, final Institution modelObject) {\n+    return dbObject\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(\n+            Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n+                .collect(Collectors.toSet()))\n+        .setEmailAddresses(\n+            Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(address -> new DbInstitutionEmailAddress().setEmailAddress(address))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1ODAzMg==", "bodyText": "I'm not following", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378558032", "createdAt": "2020-02-12T22:48:31Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,49 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {\n+    return updateDbObject(new DbInstitution(), modelObject);\n   }\n \n-  private DbInstitution saveInstitutionEmailPatterns(\n-      final Institution modelClass, final DbInstitution dbClass) {\n-\n-    institutionEmailDomainDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                dbClass.setEmailDomains(\n-                    institutionEmailDomainDao.save(\n-                        domains.stream()\n-                            .map(domain -> new DbInstitutionEmailDomain(dbClass, domain))\n-                            .collect(Collectors.toSet()))));\n-\n-    institutionEmailAddressDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                dbClass.setEmailAddresses(\n-                    institutionEmailAddressDao.save(\n-                        addresses.stream()\n-                            .map(address -> new DbInstitutionEmailAddress(dbClass, address))\n-                            .collect(Collectors.toSet()))));\n-\n-    return institutionDao.save(dbClass);\n+  private DbInstitution updateDbObject(\n+      final DbInstitution dbObject, final Institution modelObject) {\n+    return dbObject\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(\n+            Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n+                .collect(Collectors.toSet()))\n+        .setEmailAddresses(\n+            Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(address -> new DbInstitutionEmailAddress().setEmailAddress(address))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NzI3Mg=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjAzNDkyOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoyNTowN1rOFpAxIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo1MDozOVrOFpBZpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0ODUxMg==", "bodyText": "nit: maybe savedWithEmail?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378548512", "createdAt": "2020-02-12T22:25:07Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1ODg4NA==", "bodyText": "ok", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378558884", "createdAt": "2020-02-12T22:50:39Z", "author": {"login": "jmthibault79"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0ODUxMg=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjAzNzAyOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoyNTo1MVrOFpAydQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo1OToxMFrOFpBm4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0ODg1Mw==", "bodyText": "nit: if findOne wold return Optional, that'd be great.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378548853", "createdAt": "2020-02-12T22:25:51Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2MjI3Mw==", "bodyText": "findOne() is built-in to CrudRepository.\nthe main accessor for client code findOneByShortName() does return an optional.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378562273", "createdAt": "2020-02-12T22:59:10Z", "author": {"login": "jmthibault79"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0ODg1Mw=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjA0MTI5OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoyNzoyM1rOFpA1Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo1MDo1MlrOFpBZ_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0OTU0Nw==", "bodyText": "these are a mouthful and also very hard to distinguish (b/c the different letters are in the middle). Maybe simpleInstitution and emailPopulatedInstition or something?", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378549547", "createdAt": "2020-02-12T22:27:23Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1ODk3NQ==", "bodyText": "will update", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378558975", "createdAt": "2020-02-12T22:50:52Z", "author": {"login": "jmthibault79"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0OTU0Nw=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjA0NDI4OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoyODozMFrOFpA3IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDoxNjoxMFrOFpVXgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDA0OQ==", "bodyText": "Why can't this setEmailAddresses simply take in a collection of Strings? It could do the construction and population of the dbInstitution reference in one place so the caller doesn't have to.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378550049", "createdAt": "2020-02-12T22:28:30Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2Mjk2OQ==", "bodyText": "Now that is an interesting idea.  I'll look into it.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378562969", "createdAt": "2020-02-12T23:00:52Z", "author": {"login": "jmthibault79"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDA0OQ=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2OTg5NQ==", "bodyText": "This does not appear to be possible with accessor-based Hibernate.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378569895", "createdAt": "2020-02-12T23:21:01Z", "author": {"login": "jmthibault79"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDA0OQ=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2OTA1MA==", "bodyText": "\u2639\ufe0f I thought the new hotness was field-based https://pmi-engteam.slack.com/archives/CPC84FQRF/p1580305523002500?thread_ts=1580305523.002500. I guess the jury is still out, but this is one more reason to do it on the properties I would think.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378869050", "createdAt": "2020-02-13T13:48:01Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDA0OQ=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg4NjAxOA==", "bodyText": "I also came to that incorrect conclusion based on that conversation.  I have updated the conversation hopefully to avoid further confusion.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378886018", "createdAt": "2020-02-13T14:16:10Z", "author": {"login": "jmthibault79"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDA0OQ=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjA0NjY3OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjoyOTozMFrOFpA4oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo1OToyNVrOFpBnSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDQzMw==", "bodyText": "please overwrite the arg passed to save().", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378550433", "createdAt": "2020-02-12T22:29:30Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n+\n+  @Test\n+  public void test_updateWithExistingEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n \n-    DbInstitution otherInst = new DbInstitution(\"Verily\", \"An Alphabet Company\");\n-    otherInst = institutionDao.save(otherInst);\n-    assertThat(institutionDao.findOneByShortName(\"Verily\")).hasValue(otherInst);\n+  @Test\n+  public void test_updateRemoveAllEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses = Sets.newHashSet();\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2MjM3Ng==", "bodyText": "good catch", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378562376", "createdAt": "2020-02-12T22:59:25Z", "author": {"login": "jmthibault79"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n+\n+  @Test\n+  public void test_updateWithExistingEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n \n-    DbInstitution otherInst = new DbInstitution(\"Verily\", \"An Alphabet Company\");\n-    otherInst = institutionDao.save(otherInst);\n-    assertThat(institutionDao.findOneByShortName(\"Verily\")).hasValue(otherInst);\n+  @Test\n+  public void test_updateRemoveAllEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses = Sets.newHashSet();\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDQzMw=="}, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjA0ODYyOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjozMDoxNlrOFpA51g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjozMDoxNlrOFpA51g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDc0Mg==", "bodyText": "please make the test data more representative, e.g., auburn.edu.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378550742", "createdAt": "2020-02-12T22:30:16Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n+\n+  @Test\n+  public void test_updateWithExistingEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n \n-    DbInstitution otherInst = new DbInstitution(\"Verily\", \"An Alphabet Company\");\n-    otherInst = institutionDao.save(otherInst);\n-    assertThat(institutionDao.findOneByShortName(\"Verily\")).hasValue(otherInst);\n+  @Test\n+  public void test_updateRemoveAllEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses = Sets.newHashSet();\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailDomains() {\n+    Set<DbInstitutionEmailDomain> newEmailDomains =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain1\"),\n+            new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailDomains(newEmailDomains);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).containsExactlyElementsIn(newEmailDomains);\n+  }\n+\n+  @Test\n+  public void test_updateWithExistingEmailDomains() {\n+    Set<DbInstitutionEmailDomain> newEmailDomains =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjA1MjU0OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjozMTo0MVrOFpA8Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjozMTo0MVrOFpA8Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MTM2Ng==", "bodyText": "nit: make args look like email addresses\nAlso, we need some testing of the sharing (if allowed) of addresses across institutions.", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378551366", "createdAt": "2020-02-12T22:31:41Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n+\n+  @Test\n+  public void test_updateWithExistingEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea"}, "originalPosition": 150}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3317, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}