{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4ODg5NTg2", "number": 3836, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNTo1NDo0MFrOETh8kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODoxNjo1NVrOEV8MAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTE0NTc5OnYy", "diffSide": "RIGHT", "path": "ui/src/app/components/help-sidebar.spec.tsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNTo1NDo0MFrOG5UHRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNTo1NDo0MFrOG5UHRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc1MTU1Ng==", "bodyText": "Changed to check with exists() instead of length. For some reason, length was returning as 2 after I moved the icon into the array, possibly a side effect of having the data-test-id directly on the FontAwesomeIcon component?", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r462751556", "createdAt": "2020-07-30T05:54:40Z", "author": {"login": "dolbeew"}, "path": "ui/src/app/components/help-sidebar.spec.tsx", "diffHunk": "@@ -78,18 +83,18 @@ describe('HelpSidebar', () => {\n     wrapper.find({'data-test-id': 'Share-menu-item'}).first().simulate('click');\n     expect(shareSpy).toHaveBeenCalled();\n   });\n-  it('should hide workspace icon if on critera search page', async () => {\n+  it('should hide workspace icon if on critera search page', async() => {\n     const wrapper = component();\n     currentCohortCriteriaStore.next([]);\n     await waitOneTickAndUpdate(wrapper);\n-    expect(wrapper.find({'data-test-id': 'workspace-menu-button'}).length).toBe(0);\n-    expect(wrapper.find({'data-test-id': 'criteria-icon'}).length).toBe(1);\n+    expect(wrapper.find({'data-test-id': 'workspace-menu-button'}).exists()).toBe(false);\n+    expect(wrapper.find({'data-test-id': 'help-sidebar-icon-0'}).exists()).toBe(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb4a2ee9e488c8551354fb4b3f81c0edf84295f"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTE1OTA4OnYy", "diffSide": "RIGHT", "path": "ui/src/app/components/help-sidebar.tsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNjowMToxNFrOG5UPGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNjowMToxNFrOG5UPGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc1MzU2MQ==", "bodyText": "This probably has some overlap with #3822. I included it here to test the transition between the selection list and attributes form", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r462753561", "createdAt": "2020-07-30T06:01:14Z", "author": {"login": "dolbeew"}, "path": "ui/src/app/components/help-sidebar.tsx", "diffHunk": "@@ -528,14 +574,20 @@ export const HelpSidebar = fp.flow(withCurrentWorkspace(), withUserProfile(), wi\n             <div style={contentStyle('annotations')}>\n               {participant && <SidebarContent />}\n             </div>\n-            <div style={styles.footer}>\n+            <div style={contentStyle('criteria')}>\n+              {!!attributesSelection\n+                ? <AttributesPageV2 close={() => attributesSelectionStore.next(undefined)} node={attributesSelection}/>\n+                : <SelectionList back={() => {}} selections={[]}/>\n+              }\n+            </div>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb4a2ee9e488c8551354fb4b3f81c0edf84295f"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTg2OTE1OnYy", "diffSide": "RIGHT", "path": "api/config/config_local.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzoyMjozNVrOG8TWvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTo1NzowN1rOG8YcKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4NDg2Mw==", "bodyText": "Where is this flag used?", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465884863", "createdAt": "2020-08-05T17:22:35Z", "author": {"login": "NehaBroad"}, "path": "api/config/config_local.json", "diffHunk": "@@ -104,7 +104,7 @@\n     \"enableEventDateModifier\": false,\n     \"useNewShibbolethService\": true,\n     \"enableResearchPurposePrompt\": true,\n-    \"enableCohortBuilderV2\": false\n+    \"enableCohortBuilderV2\": true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2ODE2OQ==", "bodyText": "In this PR, it's only used in the TreeNode component when the attributes icon is clicked. Most of these changes will already be behind the flag.\nAlso, this flag flip will not get merged with this PR. It was enabled only for local testing, and I'll disable after approval and before merging.", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465968169", "createdAt": "2020-08-05T19:57:07Z", "author": {"login": "dolbeew"}, "path": "api/config/config_local.json", "diffHunk": "@@ -104,7 +104,7 @@\n     \"enableEventDateModifier\": false,\n     \"useNewShibbolethService\": true,\n     \"enableResearchPurposePrompt\": true,\n-    \"enableCohortBuilderV2\": false\n+    \"enableCohortBuilderV2\": true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4NDg2Mw=="}, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTg5NzA5OnYy", "diffSide": "RIGHT", "path": "ui/src/app/cohort-search/cohort-search/cohort-search.component.tsx", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzozMDozM1rOG8Tokw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDowODoxNlrOG8Yzmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4OTQyNw==", "bodyText": "Optional: We can make setAttributes an optional Prop property in tree.component and not pass anything here (not even () => {}, that will make it easier for us to clean later as well :)", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465889427", "createdAt": "2020-08-05T17:30:33Z", "author": {"login": "NehaBroad"}, "path": "ui/src/app/cohort-search/cohort-search/cohort-search.component.tsx", "diffHunk": "@@ -376,26 +366,15 @@ export class CohortSearch extends React.Component<Props, State> {\n                       select={this.addSelection}\n                       selectedIds={selectedIds}\n                       selectOption={this.setAutocompleteSelection}\n-                      setAttributes={this.setAttributes}\n+                      setAttributes={() => {}} // setAttributes no longer needed in V2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3NDE3MQ==", "bodyText": "Good idea, done.", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465974171", "createdAt": "2020-08-05T20:08:16Z", "author": {"login": "dolbeew"}, "path": "ui/src/app/cohort-search/cohort-search/cohort-search.component.tsx", "diffHunk": "@@ -376,26 +366,15 @@ export class CohortSearch extends React.Component<Props, State> {\n                       select={this.addSelection}\n                       selectedIds={selectedIds}\n                       selectOption={this.setAutocompleteSelection}\n-                      setAttributes={this.setAttributes}\n+                      setAttributes={() => {}} // setAttributes no longer needed in V2", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4OTQyNw=="}, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTkyMjA4OnYy", "diffSide": "RIGHT", "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzozODowM1rOG8T41g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTo1ODo1OVrOG8YgMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5MzU5MA==", "bodyText": "nit: space", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465893590", "createdAt": "2020-08-05T17:38:03Z", "author": {"login": "NehaBroad"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,610 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '8px',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const{form} = this.state;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2OTIwMw==", "bodyText": "Fixed", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465969203", "createdAt": "2020-08-05T19:58:59Z", "author": {"login": "dolbeew"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,610 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '8px',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const{form} = this.state;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5MzU5MA=="}, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTkyNDU2OnYy", "diffSide": "RIGHT", "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzozODo0OVrOG8T6ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDowMDowMVrOG8YikA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5Mzk4OQ==", "bodyText": "interesting whats the + for?", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465893989", "createdAt": "2020-08-05T17:38:49Z", "author": {"login": "NehaBroad"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,610 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '8px',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const{form} = this.state;\n+      if (this.hasRange) {\n+        this.getAttributes();\n+      } else {\n+        form.num = subtype === CriteriaSubType[CriteriaSubType.BP]\n+          ? JSON.parse(JSON.stringify(PREDEFINED_ATTRIBUTES.BP_DETAIL))\n+          : [{name: subtype, operator: 'ANY', operands: []}];\n+        this.setState({form, count: this.nodeCount, loading: false});\n+      }\n+    }\n+\n+    getAttributes() {\n+      const {node: {conceptId}} = this.props;\n+      const{form} = this.state;\n+      const {cdrVersionId} = currentWorkspaceStore.getValue();\n+      cohortBuilderApi().findCriteriaAttributeByConceptId(+cdrVersionId, conceptId).then(resp => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2OTgwOA==", "bodyText": "Just converts cdrVersionId from a string to a number for the API call.", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465969808", "createdAt": "2020-08-05T20:00:01Z", "author": {"login": "dolbeew"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,610 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '8px',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const{form} = this.state;\n+      if (this.hasRange) {\n+        this.getAttributes();\n+      } else {\n+        form.num = subtype === CriteriaSubType[CriteriaSubType.BP]\n+          ? JSON.parse(JSON.stringify(PREDEFINED_ATTRIBUTES.BP_DETAIL))\n+          : [{name: subtype, operator: 'ANY', operands: []}];\n+        this.setState({form, count: this.nodeCount, loading: false});\n+      }\n+    }\n+\n+    getAttributes() {\n+      const {node: {conceptId}} = this.props;\n+      const{form} = this.state;\n+      const {cdrVersionId} = currentWorkspaceStore.getValue();\n+      cohortBuilderApi().findCriteriaAttributeByConceptId(+cdrVersionId, conceptId).then(resp => {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5Mzk4OQ=="}, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTk0NTEwOnYy", "diffSide": "RIGHT", "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzo0NDozMVrOG8UG9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDowMjozOVrOG8YoFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5NzIwNA==", "bodyText": "can we use isPhysicalMeasurement here", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465897204", "createdAt": "2020-08-05T17:44:31Z", "author": {"login": "NehaBroad"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,610 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '8px',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const{form} = this.state;\n+      if (this.hasRange) {\n+        this.getAttributes();\n+      } else {\n+        form.num = subtype === CriteriaSubType[CriteriaSubType.BP]\n+          ? JSON.parse(JSON.stringify(PREDEFINED_ATTRIBUTES.BP_DETAIL))\n+          : [{name: subtype, operator: 'ANY', operands: []}];\n+        this.setState({form, count: this.nodeCount, loading: false});\n+      }\n+    }\n+\n+    getAttributes() {\n+      const {node: {conceptId}} = this.props;\n+      const{form} = this.state;\n+      const {cdrVersionId} = currentWorkspaceStore.getValue();\n+      cohortBuilderApi().findCriteriaAttributeByConceptId(+cdrVersionId, conceptId).then(resp => {\n+        resp.items.forEach(attr => {\n+          if (attr.type === AttrName[AttrName.NUM]) {\n+            // NUM attributes set the min and max range for the number inputs in the attributes form\n+            if (!form.num.length) {\n+              form.num.push({\n+                name: AttrName.NUM,\n+                operator: this.isSurvey ? 'ANY' : null,\n+                operands: [],\n+                conceptId: conceptId,\n+                [attr.conceptName]: parseInt(attr.estCount, 10)\n+              });\n+            } else {\n+              form.num[0][attr.conceptName] = parseInt(attr.estCount, 10);\n+            }\n+          } else {\n+            // CAT attributes are displayed as checkboxes in the attributes form\n+            if (parseInt(attr.estCount, 10) > 0) {\n+              attr['checked'] = false;\n+              form.cat.push(attr);\n+            }\n+          }\n+        });\n+        const count = this.isSurvey ? this.nodeCount : null;\n+        this.setState({count, form, loading: false});\n+      });\n+    }\n+\n+    toggleCheckbox(checked: boolean) {\n+      const {form} = this.state;\n+      let {node: {count}} = this.props;\n+      if (checked) {\n+        form.exists = true;\n+        form.num = form.num.map(attr =>\n+          ({...attr, operator: this.isPhysicalMeasurement ? 'ANY' : null, operands: []}));\n+        form.cat = form.cat.map(attr => ({...attr, checked: false}));\n+      } else {\n+        count = null;\n+        form.exists = false;\n+      }\n+      this.setState({form, count});\n+    }\n+\n+    selectChange(attributeIndex: number, value: string) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operator = value;\n+      if (this.isBloodPressure) {\n+        // for blood pressure, either both operators have to be 'ANY' OR neither can be 'ANY'\n+        const otherAttribute = attributeIndex === 0 ? 1 : 0;\n+        if (value === 'ANY') {\n+          form.num[otherAttribute].operator = 'ANY';\n+          form.num[otherAttribute].operands = form.num[attributeIndex].operands = [];\n+        } else if (form.num[otherAttribute].operator === 'ANY') {\n+          form.num[otherAttribute].operator = value;\n+        }\n+      } else if (value === 'ANY') {\n+        form.num[attributeIndex].operands = [];\n+      }\n+      if (value !== Operator[Operator.BETWEEN]) {\n+        // delete second operand if it exists\n+        form.num[attributeIndex].operands.splice(1);\n+      }\n+      const count = value === 'ANY' ? this.nodeCount : null;\n+      this.setState({form, count});\n+    }\n+\n+    inputChange(input: string, attributeIndex: number, operandIndex: number) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operands[operandIndex] = sanitizeNumericalInput(input);\n+      this.setState({form, count: null});\n+    }\n+\n+    checkboxChange(checked: boolean, index: number) {\n+      const {form} = this.state;\n+      form.cat[index].checked = checked;\n+      this.setState({form});\n+    }\n+\n+    validateForm() {\n+      const {form} = this.state;\n+      let formErrors = new Set(), formValid = true, operatorSelected = true;\n+      if (form.exists) {\n+        return {formValid, formErrors};\n+      }\n+      formErrors = form.num.reduce((acc, attr) => {\n+        const {MIN, MAX, operator} = attr;\n+        const operands = attr.operands.map(op => parseInt(op, 10));\n+        switch (operator) {\n+          case null:\n+            operatorSelected = false;\n+            return acc;\n+          case 'ANY':\n+            return acc;\n+          case Operator.BETWEEN:\n+            if (operands.length < 2) {\n+              formValid = false;\n+            }\n+            break;\n+          default:\n+            if (operands.length === 0) {\n+              formValid = false;\n+            }\n+        }\n+        if (operands.includes(NaN)) {\n+          formValid = false;\n+          acc.add('Form can only accept valid numbers');\n+        }\n+        if (this.isPhysicalMeasurement && operands.some(op => op < 0)) {\n+          formValid = false;\n+          acc.add('Form cannot accept negative values');\n+        }\n+        if (this.hasRange && operands.some(op => op < MIN || op > MAX)) {\n+          formValid = false;\n+          acc.add(`Values must be between ${MIN.toLocaleString()} and ${MAX.toLocaleString()}`);\n+        }\n+        return acc;\n+      }, formErrors);\n+      // The second condition sets formValid to false if this is a Measurements attribute with no operator selected from the dropdown and\n+      // no categorical checkboxes checked\n+      formValid = formValid && !(this.isMeasurement && !operatorSelected && !form.cat.some(attr => attr.checked));\n+      return {formErrors, formValid};\n+    }\n+\n+    get nodeCount() {\n+      const {node: {count, parentId}} = this.props;\n+      if (this.isSurvey) {\n+        const parent = ppiQuestions.getValue()[parentId];\n+        return !!parent ? parent.count : null;\n+      } else {\n+        return count;\n+      }\n+    }\n+\n+    get paramId() {\n+      const {node: {conceptId, id}} = this.props;\n+      const {form} = this.state;\n+      const code = form.exists ? 'Any' : form.num.reduce((acc, attr) => {\n+        if (attr.operator) {\n+          acc += optionUtil[attr.operator].code;\n+        }\n+        return acc;\n+      }, '');\n+      return `param${(conceptId || id) + code}`;\n+    }\n+\n+    get displayName() {\n+      const {node: {name}} = this.props;\n+      return stripHtml(name);\n+    }\n+\n+    get paramWithAttributes() {\n+      const {node, node: {name, subtype}} = this.props;\n+      const {form} = this.state;\n+      let paramName;\n+      const attrs = [];\n+      if (form.exists) {\n+        paramName = name + ` (${optionUtil.ANY.display})`;\n+      } else {\n+        form.num.filter(at => at.operator).forEach(({operator, operands, conceptId}) => {\n+          const attr = {name: AttrName.NUM, operator, operands};\n+          if (subtype === CriteriaSubType.BP) {\n+            attr['conceptId'] = conceptId;\n+          }\n+          if (attr.operator === 'ANY' && subtype === CriteriaSubType.BP) {\n+            attr.name = AttrName.ANY;\n+            attr.operands = [];\n+            delete attr.operator;\n+            attrs.push(attr);\n+          } else if (attr.operator !== 'ANY') {\n+            attrs.push(attr);\n+          }\n+        });\n+        if (form.cat.some(at => at.checked)) {\n+          const catOperands = form.cat.reduce((checked, current) => {\n+            if (current.checked) {\n+              checked.push(current.valueAsConceptId.toString());\n+            }\n+            return checked;\n+          }, []);\n+          attrs.push({name: AttrName.CAT, operator: Operator.IN, operands: catOperands});\n+        }\n+        paramName = this.paramName;\n+      }\n+      return {...node, parameterId: this.paramId, name: paramName, attributes: attrs};\n+    }\n+\n+    get paramName() {\n+      const {node} = this.props;\n+      const {form} = this.state;\n+      const selectionDisplay = [];\n+      let name = '';\n+      form.num.filter(at => at.operator).forEach((attr, i) => {\n+        if (attr.operator === 'ANY') {\n+          if (i === 0) {\n+            name += optionUtil.ANY.display;\n+          }\n+        } else {\n+          if (i > 0) {\n+            name += ' / ';\n+          }\n+          if (node.subtype === CriteriaSubType.BP) {\n+            name += attr.name + ' ';\n+          }\n+          name += optionUtil[attr.operator].display + attr.operands.map(op => parseInt(op, 10).toLocaleString()).join('-');\n+        }\n+      });\n+      if (name !== '') {\n+        selectionDisplay.push(name);\n+      }\n+      form.cat.filter(ca => ca.checked).forEach(attr => selectionDisplay.push(attr.conceptName));\n+      const nodeName = this.isSurvey ? ppiQuestions.getValue()[node.parentId].name : node.name;\n+      return nodeName + ' (' + selectionDisplay.join(', ') +\n+        (this.isPhysicalMeasurement && form.num[0].operator !== AttrName.ANY ? PM_UNITS[node.subtype] : '') + ')';\n+    }\n+\n+    requestPreview() {\n+      this.setState({count: null, calculating: true, countError: false});\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Calculate');\n+      }\n+      const cdrVersionId = +(currentWorkspaceStore.getValue().cdrVersionId);\n+      const request = {\n+        excludes: [],\n+        includes: [{\n+          items: [{\n+            type: param.domainId,\n+            searchParameters: [mapParameter(param)],\n+            modifiers: []\n+          }],\n+          temporal: false\n+        }],\n+        dataFilters: []\n+      };\n+      cohortBuilderApi().countParticipants(cdrVersionId, request).then(response => {\n+        this.setState({count: response, calculating: false});\n+      }, () => {\n+        this.setState({calculating: false, countError: true});\n+      });\n+    }\n+\n+    addParameterToSearchItem() {\n+      const {close} = this.props;\n+      let {criteria} = this.props;\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Add');\n+      }\n+      criteria = criteria.filter(crit => crit.parameterId !== param.parameterId);\n+      currentCohortCriteriaStore.next([...criteria, param]);\n+      close();\n+    }\n+\n+    trackEvent(subtype: string, eventType: string) {\n+      triggerEvent(\n+        'Cohort Builder Search',\n+        'Click',\n+        `Physical Measurements - ${subTypeToTitle(subtype)} - ${eventType}`\n+      );\n+    }\n+\n+    get hasUnits() {\n+      const {node: {subtype}} = this.props;\n+      return typeof PM_UNITS[subtype] !== 'undefined';\n+    }\n+\n+    get isMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.MEASUREMENT;\n+    }\n+\n+    get isPhysicalMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.PHYSICALMEASUREMENT;\n+    }\n+\n+    get isSurvey() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.SURVEY;\n+    }\n+\n+    get isBloodPressure() {\n+      const {node: {subtype}} = this.props;\n+      return subtype === CriteriaSubType.BP;\n+    }\n+\n+    get hasRange() {\n+      return this.isMeasurement || this.isSurvey;\n+    }\n+\n+    render() {\n+      const {close, node: {domainId, name, parentId, subtype}} = this.props;\n+      const {calculating, count, countError, form, loading, options} = this.state;\n+      const {formErrors, formValid} = this.validateForm();\n+      const disableAdd = calculating || !formValid;\n+      const disableCalculate = disableAdd || form.exists || form.num.every(attr => attr.operator === 'ANY');\n+      return (loading ?\n+        <SpinnerOverlay/> :\n+        <div style={{marginTop: '0.5rem'}}>\n+          <h3 style={{fontWeight: 600, margin: '0 0 0.5rem', textTransform: 'capitalize'}}>\n+            {domainId === DomainType.PHYSICALMEASUREMENT.toString() ? name : domainId.toString().toLowerCase()} Detail", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 517}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3MTIyMg==", "bodyText": "Good call, done.", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465971222", "createdAt": "2020-08-05T20:02:39Z", "author": {"login": "dolbeew"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,610 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '8px',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const{form} = this.state;\n+      if (this.hasRange) {\n+        this.getAttributes();\n+      } else {\n+        form.num = subtype === CriteriaSubType[CriteriaSubType.BP]\n+          ? JSON.parse(JSON.stringify(PREDEFINED_ATTRIBUTES.BP_DETAIL))\n+          : [{name: subtype, operator: 'ANY', operands: []}];\n+        this.setState({form, count: this.nodeCount, loading: false});\n+      }\n+    }\n+\n+    getAttributes() {\n+      const {node: {conceptId}} = this.props;\n+      const{form} = this.state;\n+      const {cdrVersionId} = currentWorkspaceStore.getValue();\n+      cohortBuilderApi().findCriteriaAttributeByConceptId(+cdrVersionId, conceptId).then(resp => {\n+        resp.items.forEach(attr => {\n+          if (attr.type === AttrName[AttrName.NUM]) {\n+            // NUM attributes set the min and max range for the number inputs in the attributes form\n+            if (!form.num.length) {\n+              form.num.push({\n+                name: AttrName.NUM,\n+                operator: this.isSurvey ? 'ANY' : null,\n+                operands: [],\n+                conceptId: conceptId,\n+                [attr.conceptName]: parseInt(attr.estCount, 10)\n+              });\n+            } else {\n+              form.num[0][attr.conceptName] = parseInt(attr.estCount, 10);\n+            }\n+          } else {\n+            // CAT attributes are displayed as checkboxes in the attributes form\n+            if (parseInt(attr.estCount, 10) > 0) {\n+              attr['checked'] = false;\n+              form.cat.push(attr);\n+            }\n+          }\n+        });\n+        const count = this.isSurvey ? this.nodeCount : null;\n+        this.setState({count, form, loading: false});\n+      });\n+    }\n+\n+    toggleCheckbox(checked: boolean) {\n+      const {form} = this.state;\n+      let {node: {count}} = this.props;\n+      if (checked) {\n+        form.exists = true;\n+        form.num = form.num.map(attr =>\n+          ({...attr, operator: this.isPhysicalMeasurement ? 'ANY' : null, operands: []}));\n+        form.cat = form.cat.map(attr => ({...attr, checked: false}));\n+      } else {\n+        count = null;\n+        form.exists = false;\n+      }\n+      this.setState({form, count});\n+    }\n+\n+    selectChange(attributeIndex: number, value: string) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operator = value;\n+      if (this.isBloodPressure) {\n+        // for blood pressure, either both operators have to be 'ANY' OR neither can be 'ANY'\n+        const otherAttribute = attributeIndex === 0 ? 1 : 0;\n+        if (value === 'ANY') {\n+          form.num[otherAttribute].operator = 'ANY';\n+          form.num[otherAttribute].operands = form.num[attributeIndex].operands = [];\n+        } else if (form.num[otherAttribute].operator === 'ANY') {\n+          form.num[otherAttribute].operator = value;\n+        }\n+      } else if (value === 'ANY') {\n+        form.num[attributeIndex].operands = [];\n+      }\n+      if (value !== Operator[Operator.BETWEEN]) {\n+        // delete second operand if it exists\n+        form.num[attributeIndex].operands.splice(1);\n+      }\n+      const count = value === 'ANY' ? this.nodeCount : null;\n+      this.setState({form, count});\n+    }\n+\n+    inputChange(input: string, attributeIndex: number, operandIndex: number) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operands[operandIndex] = sanitizeNumericalInput(input);\n+      this.setState({form, count: null});\n+    }\n+\n+    checkboxChange(checked: boolean, index: number) {\n+      const {form} = this.state;\n+      form.cat[index].checked = checked;\n+      this.setState({form});\n+    }\n+\n+    validateForm() {\n+      const {form} = this.state;\n+      let formErrors = new Set(), formValid = true, operatorSelected = true;\n+      if (form.exists) {\n+        return {formValid, formErrors};\n+      }\n+      formErrors = form.num.reduce((acc, attr) => {\n+        const {MIN, MAX, operator} = attr;\n+        const operands = attr.operands.map(op => parseInt(op, 10));\n+        switch (operator) {\n+          case null:\n+            operatorSelected = false;\n+            return acc;\n+          case 'ANY':\n+            return acc;\n+          case Operator.BETWEEN:\n+            if (operands.length < 2) {\n+              formValid = false;\n+            }\n+            break;\n+          default:\n+            if (operands.length === 0) {\n+              formValid = false;\n+            }\n+        }\n+        if (operands.includes(NaN)) {\n+          formValid = false;\n+          acc.add('Form can only accept valid numbers');\n+        }\n+        if (this.isPhysicalMeasurement && operands.some(op => op < 0)) {\n+          formValid = false;\n+          acc.add('Form cannot accept negative values');\n+        }\n+        if (this.hasRange && operands.some(op => op < MIN || op > MAX)) {\n+          formValid = false;\n+          acc.add(`Values must be between ${MIN.toLocaleString()} and ${MAX.toLocaleString()}`);\n+        }\n+        return acc;\n+      }, formErrors);\n+      // The second condition sets formValid to false if this is a Measurements attribute with no operator selected from the dropdown and\n+      // no categorical checkboxes checked\n+      formValid = formValid && !(this.isMeasurement && !operatorSelected && !form.cat.some(attr => attr.checked));\n+      return {formErrors, formValid};\n+    }\n+\n+    get nodeCount() {\n+      const {node: {count, parentId}} = this.props;\n+      if (this.isSurvey) {\n+        const parent = ppiQuestions.getValue()[parentId];\n+        return !!parent ? parent.count : null;\n+      } else {\n+        return count;\n+      }\n+    }\n+\n+    get paramId() {\n+      const {node: {conceptId, id}} = this.props;\n+      const {form} = this.state;\n+      const code = form.exists ? 'Any' : form.num.reduce((acc, attr) => {\n+        if (attr.operator) {\n+          acc += optionUtil[attr.operator].code;\n+        }\n+        return acc;\n+      }, '');\n+      return `param${(conceptId || id) + code}`;\n+    }\n+\n+    get displayName() {\n+      const {node: {name}} = this.props;\n+      return stripHtml(name);\n+    }\n+\n+    get paramWithAttributes() {\n+      const {node, node: {name, subtype}} = this.props;\n+      const {form} = this.state;\n+      let paramName;\n+      const attrs = [];\n+      if (form.exists) {\n+        paramName = name + ` (${optionUtil.ANY.display})`;\n+      } else {\n+        form.num.filter(at => at.operator).forEach(({operator, operands, conceptId}) => {\n+          const attr = {name: AttrName.NUM, operator, operands};\n+          if (subtype === CriteriaSubType.BP) {\n+            attr['conceptId'] = conceptId;\n+          }\n+          if (attr.operator === 'ANY' && subtype === CriteriaSubType.BP) {\n+            attr.name = AttrName.ANY;\n+            attr.operands = [];\n+            delete attr.operator;\n+            attrs.push(attr);\n+          } else if (attr.operator !== 'ANY') {\n+            attrs.push(attr);\n+          }\n+        });\n+        if (form.cat.some(at => at.checked)) {\n+          const catOperands = form.cat.reduce((checked, current) => {\n+            if (current.checked) {\n+              checked.push(current.valueAsConceptId.toString());\n+            }\n+            return checked;\n+          }, []);\n+          attrs.push({name: AttrName.CAT, operator: Operator.IN, operands: catOperands});\n+        }\n+        paramName = this.paramName;\n+      }\n+      return {...node, parameterId: this.paramId, name: paramName, attributes: attrs};\n+    }\n+\n+    get paramName() {\n+      const {node} = this.props;\n+      const {form} = this.state;\n+      const selectionDisplay = [];\n+      let name = '';\n+      form.num.filter(at => at.operator).forEach((attr, i) => {\n+        if (attr.operator === 'ANY') {\n+          if (i === 0) {\n+            name += optionUtil.ANY.display;\n+          }\n+        } else {\n+          if (i > 0) {\n+            name += ' / ';\n+          }\n+          if (node.subtype === CriteriaSubType.BP) {\n+            name += attr.name + ' ';\n+          }\n+          name += optionUtil[attr.operator].display + attr.operands.map(op => parseInt(op, 10).toLocaleString()).join('-');\n+        }\n+      });\n+      if (name !== '') {\n+        selectionDisplay.push(name);\n+      }\n+      form.cat.filter(ca => ca.checked).forEach(attr => selectionDisplay.push(attr.conceptName));\n+      const nodeName = this.isSurvey ? ppiQuestions.getValue()[node.parentId].name : node.name;\n+      return nodeName + ' (' + selectionDisplay.join(', ') +\n+        (this.isPhysicalMeasurement && form.num[0].operator !== AttrName.ANY ? PM_UNITS[node.subtype] : '') + ')';\n+    }\n+\n+    requestPreview() {\n+      this.setState({count: null, calculating: true, countError: false});\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Calculate');\n+      }\n+      const cdrVersionId = +(currentWorkspaceStore.getValue().cdrVersionId);\n+      const request = {\n+        excludes: [],\n+        includes: [{\n+          items: [{\n+            type: param.domainId,\n+            searchParameters: [mapParameter(param)],\n+            modifiers: []\n+          }],\n+          temporal: false\n+        }],\n+        dataFilters: []\n+      };\n+      cohortBuilderApi().countParticipants(cdrVersionId, request).then(response => {\n+        this.setState({count: response, calculating: false});\n+      }, () => {\n+        this.setState({calculating: false, countError: true});\n+      });\n+    }\n+\n+    addParameterToSearchItem() {\n+      const {close} = this.props;\n+      let {criteria} = this.props;\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Add');\n+      }\n+      criteria = criteria.filter(crit => crit.parameterId !== param.parameterId);\n+      currentCohortCriteriaStore.next([...criteria, param]);\n+      close();\n+    }\n+\n+    trackEvent(subtype: string, eventType: string) {\n+      triggerEvent(\n+        'Cohort Builder Search',\n+        'Click',\n+        `Physical Measurements - ${subTypeToTitle(subtype)} - ${eventType}`\n+      );\n+    }\n+\n+    get hasUnits() {\n+      const {node: {subtype}} = this.props;\n+      return typeof PM_UNITS[subtype] !== 'undefined';\n+    }\n+\n+    get isMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.MEASUREMENT;\n+    }\n+\n+    get isPhysicalMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.PHYSICALMEASUREMENT;\n+    }\n+\n+    get isSurvey() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.SURVEY;\n+    }\n+\n+    get isBloodPressure() {\n+      const {node: {subtype}} = this.props;\n+      return subtype === CriteriaSubType.BP;\n+    }\n+\n+    get hasRange() {\n+      return this.isMeasurement || this.isSurvey;\n+    }\n+\n+    render() {\n+      const {close, node: {domainId, name, parentId, subtype}} = this.props;\n+      const {calculating, count, countError, form, loading, options} = this.state;\n+      const {formErrors, formValid} = this.validateForm();\n+      const disableAdd = calculating || !formValid;\n+      const disableCalculate = disableAdd || form.exists || form.num.every(attr => attr.operator === 'ANY');\n+      return (loading ?\n+        <SpinnerOverlay/> :\n+        <div style={{marginTop: '0.5rem'}}>\n+          <h3 style={{fontWeight: 600, margin: '0 0 0.5rem', textTransform: 'capitalize'}}>\n+            {domainId === DomainType.PHYSICALMEASUREMENT.toString() ? name : domainId.toString().toLowerCase()} Detail", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5NzIwNA=="}, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 517}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTk0OTY4OnYy", "diffSide": "RIGHT", "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzo0NTo0OFrOG8UJ3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTowNTozM1rOG83tRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5Nzk0OA==", "bodyText": "Question: Can we use validate in this form?", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465897948", "createdAt": "2020-08-05T17:45:48Z", "author": {"login": "NehaBroad"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,610 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '8px',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const{form} = this.state;\n+      if (this.hasRange) {\n+        this.getAttributes();\n+      } else {\n+        form.num = subtype === CriteriaSubType[CriteriaSubType.BP]\n+          ? JSON.parse(JSON.stringify(PREDEFINED_ATTRIBUTES.BP_DETAIL))\n+          : [{name: subtype, operator: 'ANY', operands: []}];\n+        this.setState({form, count: this.nodeCount, loading: false});\n+      }\n+    }\n+\n+    getAttributes() {\n+      const {node: {conceptId}} = this.props;\n+      const{form} = this.state;\n+      const {cdrVersionId} = currentWorkspaceStore.getValue();\n+      cohortBuilderApi().findCriteriaAttributeByConceptId(+cdrVersionId, conceptId).then(resp => {\n+        resp.items.forEach(attr => {\n+          if (attr.type === AttrName[AttrName.NUM]) {\n+            // NUM attributes set the min and max range for the number inputs in the attributes form\n+            if (!form.num.length) {\n+              form.num.push({\n+                name: AttrName.NUM,\n+                operator: this.isSurvey ? 'ANY' : null,\n+                operands: [],\n+                conceptId: conceptId,\n+                [attr.conceptName]: parseInt(attr.estCount, 10)\n+              });\n+            } else {\n+              form.num[0][attr.conceptName] = parseInt(attr.estCount, 10);\n+            }\n+          } else {\n+            // CAT attributes are displayed as checkboxes in the attributes form\n+            if (parseInt(attr.estCount, 10) > 0) {\n+              attr['checked'] = false;\n+              form.cat.push(attr);\n+            }\n+          }\n+        });\n+        const count = this.isSurvey ? this.nodeCount : null;\n+        this.setState({count, form, loading: false});\n+      });\n+    }\n+\n+    toggleCheckbox(checked: boolean) {\n+      const {form} = this.state;\n+      let {node: {count}} = this.props;\n+      if (checked) {\n+        form.exists = true;\n+        form.num = form.num.map(attr =>\n+          ({...attr, operator: this.isPhysicalMeasurement ? 'ANY' : null, operands: []}));\n+        form.cat = form.cat.map(attr => ({...attr, checked: false}));\n+      } else {\n+        count = null;\n+        form.exists = false;\n+      }\n+      this.setState({form, count});\n+    }\n+\n+    selectChange(attributeIndex: number, value: string) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operator = value;\n+      if (this.isBloodPressure) {\n+        // for blood pressure, either both operators have to be 'ANY' OR neither can be 'ANY'\n+        const otherAttribute = attributeIndex === 0 ? 1 : 0;\n+        if (value === 'ANY') {\n+          form.num[otherAttribute].operator = 'ANY';\n+          form.num[otherAttribute].operands = form.num[attributeIndex].operands = [];\n+        } else if (form.num[otherAttribute].operator === 'ANY') {\n+          form.num[otherAttribute].operator = value;\n+        }\n+      } else if (value === 'ANY') {\n+        form.num[attributeIndex].operands = [];\n+      }\n+      if (value !== Operator[Operator.BETWEEN]) {\n+        // delete second operand if it exists\n+        form.num[attributeIndex].operands.splice(1);\n+      }\n+      const count = value === 'ANY' ? this.nodeCount : null;\n+      this.setState({form, count});\n+    }\n+\n+    inputChange(input: string, attributeIndex: number, operandIndex: number) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operands[operandIndex] = sanitizeNumericalInput(input);\n+      this.setState({form, count: null});\n+    }\n+\n+    checkboxChange(checked: boolean, index: number) {\n+      const {form} = this.state;\n+      form.cat[index].checked = checked;\n+      this.setState({form});\n+    }\n+\n+    validateForm() {\n+      const {form} = this.state;\n+      let formErrors = new Set(), formValid = true, operatorSelected = true;\n+      if (form.exists) {\n+        return {formValid, formErrors};\n+      }\n+      formErrors = form.num.reduce((acc, attr) => {\n+        const {MIN, MAX, operator} = attr;\n+        const operands = attr.operands.map(op => parseInt(op, 10));\n+        switch (operator) {\n+          case null:\n+            operatorSelected = false;\n+            return acc;\n+          case 'ANY':\n+            return acc;\n+          case Operator.BETWEEN:\n+            if (operands.length < 2) {\n+              formValid = false;\n+            }\n+            break;\n+          default:\n+            if (operands.length === 0) {\n+              formValid = false;\n+            }\n+        }\n+        if (operands.includes(NaN)) {\n+          formValid = false;\n+          acc.add('Form can only accept valid numbers');\n+        }\n+        if (this.isPhysicalMeasurement && operands.some(op => op < 0)) {\n+          formValid = false;\n+          acc.add('Form cannot accept negative values');\n+        }\n+        if (this.hasRange && operands.some(op => op < MIN || op > MAX)) {\n+          formValid = false;\n+          acc.add(`Values must be between ${MIN.toLocaleString()} and ${MAX.toLocaleString()}`);\n+        }\n+        return acc;\n+      }, formErrors);\n+      // The second condition sets formValid to false if this is a Measurements attribute with no operator selected from the dropdown and\n+      // no categorical checkboxes checked\n+      formValid = formValid && !(this.isMeasurement && !operatorSelected && !form.cat.some(attr => attr.checked));\n+      return {formErrors, formValid};\n+    }\n+\n+    get nodeCount() {\n+      const {node: {count, parentId}} = this.props;\n+      if (this.isSurvey) {\n+        const parent = ppiQuestions.getValue()[parentId];\n+        return !!parent ? parent.count : null;\n+      } else {\n+        return count;\n+      }\n+    }\n+\n+    get paramId() {\n+      const {node: {conceptId, id}} = this.props;\n+      const {form} = this.state;\n+      const code = form.exists ? 'Any' : form.num.reduce((acc, attr) => {\n+        if (attr.operator) {\n+          acc += optionUtil[attr.operator].code;\n+        }\n+        return acc;\n+      }, '');\n+      return `param${(conceptId || id) + code}`;\n+    }\n+\n+    get displayName() {\n+      const {node: {name}} = this.props;\n+      return stripHtml(name);\n+    }\n+\n+    get paramWithAttributes() {\n+      const {node, node: {name, subtype}} = this.props;\n+      const {form} = this.state;\n+      let paramName;\n+      const attrs = [];\n+      if (form.exists) {\n+        paramName = name + ` (${optionUtil.ANY.display})`;\n+      } else {\n+        form.num.filter(at => at.operator).forEach(({operator, operands, conceptId}) => {\n+          const attr = {name: AttrName.NUM, operator, operands};\n+          if (subtype === CriteriaSubType.BP) {\n+            attr['conceptId'] = conceptId;\n+          }\n+          if (attr.operator === 'ANY' && subtype === CriteriaSubType.BP) {\n+            attr.name = AttrName.ANY;\n+            attr.operands = [];\n+            delete attr.operator;\n+            attrs.push(attr);\n+          } else if (attr.operator !== 'ANY') {\n+            attrs.push(attr);\n+          }\n+        });\n+        if (form.cat.some(at => at.checked)) {\n+          const catOperands = form.cat.reduce((checked, current) => {\n+            if (current.checked) {\n+              checked.push(current.valueAsConceptId.toString());\n+            }\n+            return checked;\n+          }, []);\n+          attrs.push({name: AttrName.CAT, operator: Operator.IN, operands: catOperands});\n+        }\n+        paramName = this.paramName;\n+      }\n+      return {...node, parameterId: this.paramId, name: paramName, attributes: attrs};\n+    }\n+\n+    get paramName() {\n+      const {node} = this.props;\n+      const {form} = this.state;\n+      const selectionDisplay = [];\n+      let name = '';\n+      form.num.filter(at => at.operator).forEach((attr, i) => {\n+        if (attr.operator === 'ANY') {\n+          if (i === 0) {\n+            name += optionUtil.ANY.display;\n+          }\n+        } else {\n+          if (i > 0) {\n+            name += ' / ';\n+          }\n+          if (node.subtype === CriteriaSubType.BP) {\n+            name += attr.name + ' ';\n+          }\n+          name += optionUtil[attr.operator].display + attr.operands.map(op => parseInt(op, 10).toLocaleString()).join('-');\n+        }\n+      });\n+      if (name !== '') {\n+        selectionDisplay.push(name);\n+      }\n+      form.cat.filter(ca => ca.checked).forEach(attr => selectionDisplay.push(attr.conceptName));\n+      const nodeName = this.isSurvey ? ppiQuestions.getValue()[node.parentId].name : node.name;\n+      return nodeName + ' (' + selectionDisplay.join(', ') +\n+        (this.isPhysicalMeasurement && form.num[0].operator !== AttrName.ANY ? PM_UNITS[node.subtype] : '') + ')';\n+    }\n+\n+    requestPreview() {\n+      this.setState({count: null, calculating: true, countError: false});\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Calculate');\n+      }\n+      const cdrVersionId = +(currentWorkspaceStore.getValue().cdrVersionId);\n+      const request = {\n+        excludes: [],\n+        includes: [{\n+          items: [{\n+            type: param.domainId,\n+            searchParameters: [mapParameter(param)],\n+            modifiers: []\n+          }],\n+          temporal: false\n+        }],\n+        dataFilters: []\n+      };\n+      cohortBuilderApi().countParticipants(cdrVersionId, request).then(response => {\n+        this.setState({count: response, calculating: false});\n+      }, () => {\n+        this.setState({calculating: false, countError: true});\n+      });\n+    }\n+\n+    addParameterToSearchItem() {\n+      const {close} = this.props;\n+      let {criteria} = this.props;\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Add');\n+      }\n+      criteria = criteria.filter(crit => crit.parameterId !== param.parameterId);\n+      currentCohortCriteriaStore.next([...criteria, param]);\n+      close();\n+    }\n+\n+    trackEvent(subtype: string, eventType: string) {\n+      triggerEvent(\n+        'Cohort Builder Search',\n+        'Click',\n+        `Physical Measurements - ${subTypeToTitle(subtype)} - ${eventType}`\n+      );\n+    }\n+\n+    get hasUnits() {\n+      const {node: {subtype}} = this.props;\n+      return typeof PM_UNITS[subtype] !== 'undefined';\n+    }\n+\n+    get isMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.MEASUREMENT;\n+    }\n+\n+    get isPhysicalMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.PHYSICALMEASUREMENT;\n+    }\n+\n+    get isSurvey() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.SURVEY;\n+    }\n+\n+    get isBloodPressure() {\n+      const {node: {subtype}} = this.props;\n+      return subtype === CriteriaSubType.BP;\n+    }\n+\n+    get hasRange() {\n+      return this.isMeasurement || this.isSurvey;\n+    }\n+\n+    render() {\n+      const {close, node: {domainId, name, parentId, subtype}} = this.props;\n+      const {calculating, count, countError, form, loading, options} = this.state;\n+      const {formErrors, formValid} = this.validateForm();\n+      const disableAdd = calculating || !formValid;\n+      const disableCalculate = disableAdd || form.exists || form.num.every(attr => attr.operator === 'ANY');\n+      return (loading ?\n+        <SpinnerOverlay/> :\n+        <div style={{marginTop: '0.5rem'}}>\n+          <h3 style={{fontWeight: 600, margin: '0 0 0.5rem', textTransform: 'capitalize'}}>\n+            {domainId === DomainType.PHYSICALMEASUREMENT.toString() ? name : domainId.toString().toLowerCase()} Detail\n+          </h3>\n+          {countError && <div style={styles.error}>\n+            <ClrIcon style={{margin: '0 0.5rem 0 0.25rem'}} className='is-solid'\n+              shape='exclamation-triangle' size='22'/>\n+            Sorry, the request cannot be completed.\n+          </div>}\n+          {!!formErrors.size && <div style={styles.errors}>\n+            {Array.from(formErrors).map((err, e) => <div key={e} style={styles.errorItem}>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 525}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3Mjk4Mg==", "bodyText": "I know I tried using it here at some point, possibly when I converted to React. Can't remember for sure, but I want to say it was easier to get the error messaging and styles how we wanted them just writing custom validation. I'll have to take another look at it though.", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r465972982", "createdAt": "2020-08-05T20:05:46Z", "author": {"login": "dolbeew"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,610 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '8px',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const{form} = this.state;\n+      if (this.hasRange) {\n+        this.getAttributes();\n+      } else {\n+        form.num = subtype === CriteriaSubType[CriteriaSubType.BP]\n+          ? JSON.parse(JSON.stringify(PREDEFINED_ATTRIBUTES.BP_DETAIL))\n+          : [{name: subtype, operator: 'ANY', operands: []}];\n+        this.setState({form, count: this.nodeCount, loading: false});\n+      }\n+    }\n+\n+    getAttributes() {\n+      const {node: {conceptId}} = this.props;\n+      const{form} = this.state;\n+      const {cdrVersionId} = currentWorkspaceStore.getValue();\n+      cohortBuilderApi().findCriteriaAttributeByConceptId(+cdrVersionId, conceptId).then(resp => {\n+        resp.items.forEach(attr => {\n+          if (attr.type === AttrName[AttrName.NUM]) {\n+            // NUM attributes set the min and max range for the number inputs in the attributes form\n+            if (!form.num.length) {\n+              form.num.push({\n+                name: AttrName.NUM,\n+                operator: this.isSurvey ? 'ANY' : null,\n+                operands: [],\n+                conceptId: conceptId,\n+                [attr.conceptName]: parseInt(attr.estCount, 10)\n+              });\n+            } else {\n+              form.num[0][attr.conceptName] = parseInt(attr.estCount, 10);\n+            }\n+          } else {\n+            // CAT attributes are displayed as checkboxes in the attributes form\n+            if (parseInt(attr.estCount, 10) > 0) {\n+              attr['checked'] = false;\n+              form.cat.push(attr);\n+            }\n+          }\n+        });\n+        const count = this.isSurvey ? this.nodeCount : null;\n+        this.setState({count, form, loading: false});\n+      });\n+    }\n+\n+    toggleCheckbox(checked: boolean) {\n+      const {form} = this.state;\n+      let {node: {count}} = this.props;\n+      if (checked) {\n+        form.exists = true;\n+        form.num = form.num.map(attr =>\n+          ({...attr, operator: this.isPhysicalMeasurement ? 'ANY' : null, operands: []}));\n+        form.cat = form.cat.map(attr => ({...attr, checked: false}));\n+      } else {\n+        count = null;\n+        form.exists = false;\n+      }\n+      this.setState({form, count});\n+    }\n+\n+    selectChange(attributeIndex: number, value: string) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operator = value;\n+      if (this.isBloodPressure) {\n+        // for blood pressure, either both operators have to be 'ANY' OR neither can be 'ANY'\n+        const otherAttribute = attributeIndex === 0 ? 1 : 0;\n+        if (value === 'ANY') {\n+          form.num[otherAttribute].operator = 'ANY';\n+          form.num[otherAttribute].operands = form.num[attributeIndex].operands = [];\n+        } else if (form.num[otherAttribute].operator === 'ANY') {\n+          form.num[otherAttribute].operator = value;\n+        }\n+      } else if (value === 'ANY') {\n+        form.num[attributeIndex].operands = [];\n+      }\n+      if (value !== Operator[Operator.BETWEEN]) {\n+        // delete second operand if it exists\n+        form.num[attributeIndex].operands.splice(1);\n+      }\n+      const count = value === 'ANY' ? this.nodeCount : null;\n+      this.setState({form, count});\n+    }\n+\n+    inputChange(input: string, attributeIndex: number, operandIndex: number) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operands[operandIndex] = sanitizeNumericalInput(input);\n+      this.setState({form, count: null});\n+    }\n+\n+    checkboxChange(checked: boolean, index: number) {\n+      const {form} = this.state;\n+      form.cat[index].checked = checked;\n+      this.setState({form});\n+    }\n+\n+    validateForm() {\n+      const {form} = this.state;\n+      let formErrors = new Set(), formValid = true, operatorSelected = true;\n+      if (form.exists) {\n+        return {formValid, formErrors};\n+      }\n+      formErrors = form.num.reduce((acc, attr) => {\n+        const {MIN, MAX, operator} = attr;\n+        const operands = attr.operands.map(op => parseInt(op, 10));\n+        switch (operator) {\n+          case null:\n+            operatorSelected = false;\n+            return acc;\n+          case 'ANY':\n+            return acc;\n+          case Operator.BETWEEN:\n+            if (operands.length < 2) {\n+              formValid = false;\n+            }\n+            break;\n+          default:\n+            if (operands.length === 0) {\n+              formValid = false;\n+            }\n+        }\n+        if (operands.includes(NaN)) {\n+          formValid = false;\n+          acc.add('Form can only accept valid numbers');\n+        }\n+        if (this.isPhysicalMeasurement && operands.some(op => op < 0)) {\n+          formValid = false;\n+          acc.add('Form cannot accept negative values');\n+        }\n+        if (this.hasRange && operands.some(op => op < MIN || op > MAX)) {\n+          formValid = false;\n+          acc.add(`Values must be between ${MIN.toLocaleString()} and ${MAX.toLocaleString()}`);\n+        }\n+        return acc;\n+      }, formErrors);\n+      // The second condition sets formValid to false if this is a Measurements attribute with no operator selected from the dropdown and\n+      // no categorical checkboxes checked\n+      formValid = formValid && !(this.isMeasurement && !operatorSelected && !form.cat.some(attr => attr.checked));\n+      return {formErrors, formValid};\n+    }\n+\n+    get nodeCount() {\n+      const {node: {count, parentId}} = this.props;\n+      if (this.isSurvey) {\n+        const parent = ppiQuestions.getValue()[parentId];\n+        return !!parent ? parent.count : null;\n+      } else {\n+        return count;\n+      }\n+    }\n+\n+    get paramId() {\n+      const {node: {conceptId, id}} = this.props;\n+      const {form} = this.state;\n+      const code = form.exists ? 'Any' : form.num.reduce((acc, attr) => {\n+        if (attr.operator) {\n+          acc += optionUtil[attr.operator].code;\n+        }\n+        return acc;\n+      }, '');\n+      return `param${(conceptId || id) + code}`;\n+    }\n+\n+    get displayName() {\n+      const {node: {name}} = this.props;\n+      return stripHtml(name);\n+    }\n+\n+    get paramWithAttributes() {\n+      const {node, node: {name, subtype}} = this.props;\n+      const {form} = this.state;\n+      let paramName;\n+      const attrs = [];\n+      if (form.exists) {\n+        paramName = name + ` (${optionUtil.ANY.display})`;\n+      } else {\n+        form.num.filter(at => at.operator).forEach(({operator, operands, conceptId}) => {\n+          const attr = {name: AttrName.NUM, operator, operands};\n+          if (subtype === CriteriaSubType.BP) {\n+            attr['conceptId'] = conceptId;\n+          }\n+          if (attr.operator === 'ANY' && subtype === CriteriaSubType.BP) {\n+            attr.name = AttrName.ANY;\n+            attr.operands = [];\n+            delete attr.operator;\n+            attrs.push(attr);\n+          } else if (attr.operator !== 'ANY') {\n+            attrs.push(attr);\n+          }\n+        });\n+        if (form.cat.some(at => at.checked)) {\n+          const catOperands = form.cat.reduce((checked, current) => {\n+            if (current.checked) {\n+              checked.push(current.valueAsConceptId.toString());\n+            }\n+            return checked;\n+          }, []);\n+          attrs.push({name: AttrName.CAT, operator: Operator.IN, operands: catOperands});\n+        }\n+        paramName = this.paramName;\n+      }\n+      return {...node, parameterId: this.paramId, name: paramName, attributes: attrs};\n+    }\n+\n+    get paramName() {\n+      const {node} = this.props;\n+      const {form} = this.state;\n+      const selectionDisplay = [];\n+      let name = '';\n+      form.num.filter(at => at.operator).forEach((attr, i) => {\n+        if (attr.operator === 'ANY') {\n+          if (i === 0) {\n+            name += optionUtil.ANY.display;\n+          }\n+        } else {\n+          if (i > 0) {\n+            name += ' / ';\n+          }\n+          if (node.subtype === CriteriaSubType.BP) {\n+            name += attr.name + ' ';\n+          }\n+          name += optionUtil[attr.operator].display + attr.operands.map(op => parseInt(op, 10).toLocaleString()).join('-');\n+        }\n+      });\n+      if (name !== '') {\n+        selectionDisplay.push(name);\n+      }\n+      form.cat.filter(ca => ca.checked).forEach(attr => selectionDisplay.push(attr.conceptName));\n+      const nodeName = this.isSurvey ? ppiQuestions.getValue()[node.parentId].name : node.name;\n+      return nodeName + ' (' + selectionDisplay.join(', ') +\n+        (this.isPhysicalMeasurement && form.num[0].operator !== AttrName.ANY ? PM_UNITS[node.subtype] : '') + ')';\n+    }\n+\n+    requestPreview() {\n+      this.setState({count: null, calculating: true, countError: false});\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Calculate');\n+      }\n+      const cdrVersionId = +(currentWorkspaceStore.getValue().cdrVersionId);\n+      const request = {\n+        excludes: [],\n+        includes: [{\n+          items: [{\n+            type: param.domainId,\n+            searchParameters: [mapParameter(param)],\n+            modifiers: []\n+          }],\n+          temporal: false\n+        }],\n+        dataFilters: []\n+      };\n+      cohortBuilderApi().countParticipants(cdrVersionId, request).then(response => {\n+        this.setState({count: response, calculating: false});\n+      }, () => {\n+        this.setState({calculating: false, countError: true});\n+      });\n+    }\n+\n+    addParameterToSearchItem() {\n+      const {close} = this.props;\n+      let {criteria} = this.props;\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Add');\n+      }\n+      criteria = criteria.filter(crit => crit.parameterId !== param.parameterId);\n+      currentCohortCriteriaStore.next([...criteria, param]);\n+      close();\n+    }\n+\n+    trackEvent(subtype: string, eventType: string) {\n+      triggerEvent(\n+        'Cohort Builder Search',\n+        'Click',\n+        `Physical Measurements - ${subTypeToTitle(subtype)} - ${eventType}`\n+      );\n+    }\n+\n+    get hasUnits() {\n+      const {node: {subtype}} = this.props;\n+      return typeof PM_UNITS[subtype] !== 'undefined';\n+    }\n+\n+    get isMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.MEASUREMENT;\n+    }\n+\n+    get isPhysicalMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.PHYSICALMEASUREMENT;\n+    }\n+\n+    get isSurvey() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.SURVEY;\n+    }\n+\n+    get isBloodPressure() {\n+      const {node: {subtype}} = this.props;\n+      return subtype === CriteriaSubType.BP;\n+    }\n+\n+    get hasRange() {\n+      return this.isMeasurement || this.isSurvey;\n+    }\n+\n+    render() {\n+      const {close, node: {domainId, name, parentId, subtype}} = this.props;\n+      const {calculating, count, countError, form, loading, options} = this.state;\n+      const {formErrors, formValid} = this.validateForm();\n+      const disableAdd = calculating || !formValid;\n+      const disableCalculate = disableAdd || form.exists || form.num.every(attr => attr.operator === 'ANY');\n+      return (loading ?\n+        <SpinnerOverlay/> :\n+        <div style={{marginTop: '0.5rem'}}>\n+          <h3 style={{fontWeight: 600, margin: '0 0 0.5rem', textTransform: 'capitalize'}}>\n+            {domainId === DomainType.PHYSICALMEASUREMENT.toString() ? name : domainId.toString().toLowerCase()} Detail\n+          </h3>\n+          {countError && <div style={styles.error}>\n+            <ClrIcon style={{margin: '0 0.5rem 0 0.25rem'}} className='is-solid'\n+              shape='exclamation-triangle' size='22'/>\n+            Sorry, the request cannot be completed.\n+          </div>}\n+          {!!formErrors.size && <div style={styles.errors}>\n+            {Array.from(formErrors).map((err, e) => <div key={e} style={styles.errorItem}>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5Nzk0OA=="}, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 525}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ4MDQ1Mw==", "bodyText": "I think the main issue is that the form is dynamic, so depending on the type of attribute and the operator selected, there could be 1-4 values that need to be passed in to the validate() function.\nAlso, we need to validate values differently for different domains. Physical measurements values just need to be positive but attributes for Measurements have a specific range that can include negative numbers.\nThere's probably a way to do it, but seems like a decent amount work and I would prefer to handle it separately instead of including here. I can make a ticket for that.", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r466480453", "createdAt": "2020-08-06T15:05:33Z", "author": {"login": "dolbeew"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,610 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '8px',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0.5rem',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const{form} = this.state;\n+      if (this.hasRange) {\n+        this.getAttributes();\n+      } else {\n+        form.num = subtype === CriteriaSubType[CriteriaSubType.BP]\n+          ? JSON.parse(JSON.stringify(PREDEFINED_ATTRIBUTES.BP_DETAIL))\n+          : [{name: subtype, operator: 'ANY', operands: []}];\n+        this.setState({form, count: this.nodeCount, loading: false});\n+      }\n+    }\n+\n+    getAttributes() {\n+      const {node: {conceptId}} = this.props;\n+      const{form} = this.state;\n+      const {cdrVersionId} = currentWorkspaceStore.getValue();\n+      cohortBuilderApi().findCriteriaAttributeByConceptId(+cdrVersionId, conceptId).then(resp => {\n+        resp.items.forEach(attr => {\n+          if (attr.type === AttrName[AttrName.NUM]) {\n+            // NUM attributes set the min and max range for the number inputs in the attributes form\n+            if (!form.num.length) {\n+              form.num.push({\n+                name: AttrName.NUM,\n+                operator: this.isSurvey ? 'ANY' : null,\n+                operands: [],\n+                conceptId: conceptId,\n+                [attr.conceptName]: parseInt(attr.estCount, 10)\n+              });\n+            } else {\n+              form.num[0][attr.conceptName] = parseInt(attr.estCount, 10);\n+            }\n+          } else {\n+            // CAT attributes are displayed as checkboxes in the attributes form\n+            if (parseInt(attr.estCount, 10) > 0) {\n+              attr['checked'] = false;\n+              form.cat.push(attr);\n+            }\n+          }\n+        });\n+        const count = this.isSurvey ? this.nodeCount : null;\n+        this.setState({count, form, loading: false});\n+      });\n+    }\n+\n+    toggleCheckbox(checked: boolean) {\n+      const {form} = this.state;\n+      let {node: {count}} = this.props;\n+      if (checked) {\n+        form.exists = true;\n+        form.num = form.num.map(attr =>\n+          ({...attr, operator: this.isPhysicalMeasurement ? 'ANY' : null, operands: []}));\n+        form.cat = form.cat.map(attr => ({...attr, checked: false}));\n+      } else {\n+        count = null;\n+        form.exists = false;\n+      }\n+      this.setState({form, count});\n+    }\n+\n+    selectChange(attributeIndex: number, value: string) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operator = value;\n+      if (this.isBloodPressure) {\n+        // for blood pressure, either both operators have to be 'ANY' OR neither can be 'ANY'\n+        const otherAttribute = attributeIndex === 0 ? 1 : 0;\n+        if (value === 'ANY') {\n+          form.num[otherAttribute].operator = 'ANY';\n+          form.num[otherAttribute].operands = form.num[attributeIndex].operands = [];\n+        } else if (form.num[otherAttribute].operator === 'ANY') {\n+          form.num[otherAttribute].operator = value;\n+        }\n+      } else if (value === 'ANY') {\n+        form.num[attributeIndex].operands = [];\n+      }\n+      if (value !== Operator[Operator.BETWEEN]) {\n+        // delete second operand if it exists\n+        form.num[attributeIndex].operands.splice(1);\n+      }\n+      const count = value === 'ANY' ? this.nodeCount : null;\n+      this.setState({form, count});\n+    }\n+\n+    inputChange(input: string, attributeIndex: number, operandIndex: number) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operands[operandIndex] = sanitizeNumericalInput(input);\n+      this.setState({form, count: null});\n+    }\n+\n+    checkboxChange(checked: boolean, index: number) {\n+      const {form} = this.state;\n+      form.cat[index].checked = checked;\n+      this.setState({form});\n+    }\n+\n+    validateForm() {\n+      const {form} = this.state;\n+      let formErrors = new Set(), formValid = true, operatorSelected = true;\n+      if (form.exists) {\n+        return {formValid, formErrors};\n+      }\n+      formErrors = form.num.reduce((acc, attr) => {\n+        const {MIN, MAX, operator} = attr;\n+        const operands = attr.operands.map(op => parseInt(op, 10));\n+        switch (operator) {\n+          case null:\n+            operatorSelected = false;\n+            return acc;\n+          case 'ANY':\n+            return acc;\n+          case Operator.BETWEEN:\n+            if (operands.length < 2) {\n+              formValid = false;\n+            }\n+            break;\n+          default:\n+            if (operands.length === 0) {\n+              formValid = false;\n+            }\n+        }\n+        if (operands.includes(NaN)) {\n+          formValid = false;\n+          acc.add('Form can only accept valid numbers');\n+        }\n+        if (this.isPhysicalMeasurement && operands.some(op => op < 0)) {\n+          formValid = false;\n+          acc.add('Form cannot accept negative values');\n+        }\n+        if (this.hasRange && operands.some(op => op < MIN || op > MAX)) {\n+          formValid = false;\n+          acc.add(`Values must be between ${MIN.toLocaleString()} and ${MAX.toLocaleString()}`);\n+        }\n+        return acc;\n+      }, formErrors);\n+      // The second condition sets formValid to false if this is a Measurements attribute with no operator selected from the dropdown and\n+      // no categorical checkboxes checked\n+      formValid = formValid && !(this.isMeasurement && !operatorSelected && !form.cat.some(attr => attr.checked));\n+      return {formErrors, formValid};\n+    }\n+\n+    get nodeCount() {\n+      const {node: {count, parentId}} = this.props;\n+      if (this.isSurvey) {\n+        const parent = ppiQuestions.getValue()[parentId];\n+        return !!parent ? parent.count : null;\n+      } else {\n+        return count;\n+      }\n+    }\n+\n+    get paramId() {\n+      const {node: {conceptId, id}} = this.props;\n+      const {form} = this.state;\n+      const code = form.exists ? 'Any' : form.num.reduce((acc, attr) => {\n+        if (attr.operator) {\n+          acc += optionUtil[attr.operator].code;\n+        }\n+        return acc;\n+      }, '');\n+      return `param${(conceptId || id) + code}`;\n+    }\n+\n+    get displayName() {\n+      const {node: {name}} = this.props;\n+      return stripHtml(name);\n+    }\n+\n+    get paramWithAttributes() {\n+      const {node, node: {name, subtype}} = this.props;\n+      const {form} = this.state;\n+      let paramName;\n+      const attrs = [];\n+      if (form.exists) {\n+        paramName = name + ` (${optionUtil.ANY.display})`;\n+      } else {\n+        form.num.filter(at => at.operator).forEach(({operator, operands, conceptId}) => {\n+          const attr = {name: AttrName.NUM, operator, operands};\n+          if (subtype === CriteriaSubType.BP) {\n+            attr['conceptId'] = conceptId;\n+          }\n+          if (attr.operator === 'ANY' && subtype === CriteriaSubType.BP) {\n+            attr.name = AttrName.ANY;\n+            attr.operands = [];\n+            delete attr.operator;\n+            attrs.push(attr);\n+          } else if (attr.operator !== 'ANY') {\n+            attrs.push(attr);\n+          }\n+        });\n+        if (form.cat.some(at => at.checked)) {\n+          const catOperands = form.cat.reduce((checked, current) => {\n+            if (current.checked) {\n+              checked.push(current.valueAsConceptId.toString());\n+            }\n+            return checked;\n+          }, []);\n+          attrs.push({name: AttrName.CAT, operator: Operator.IN, operands: catOperands});\n+        }\n+        paramName = this.paramName;\n+      }\n+      return {...node, parameterId: this.paramId, name: paramName, attributes: attrs};\n+    }\n+\n+    get paramName() {\n+      const {node} = this.props;\n+      const {form} = this.state;\n+      const selectionDisplay = [];\n+      let name = '';\n+      form.num.filter(at => at.operator).forEach((attr, i) => {\n+        if (attr.operator === 'ANY') {\n+          if (i === 0) {\n+            name += optionUtil.ANY.display;\n+          }\n+        } else {\n+          if (i > 0) {\n+            name += ' / ';\n+          }\n+          if (node.subtype === CriteriaSubType.BP) {\n+            name += attr.name + ' ';\n+          }\n+          name += optionUtil[attr.operator].display + attr.operands.map(op => parseInt(op, 10).toLocaleString()).join('-');\n+        }\n+      });\n+      if (name !== '') {\n+        selectionDisplay.push(name);\n+      }\n+      form.cat.filter(ca => ca.checked).forEach(attr => selectionDisplay.push(attr.conceptName));\n+      const nodeName = this.isSurvey ? ppiQuestions.getValue()[node.parentId].name : node.name;\n+      return nodeName + ' (' + selectionDisplay.join(', ') +\n+        (this.isPhysicalMeasurement && form.num[0].operator !== AttrName.ANY ? PM_UNITS[node.subtype] : '') + ')';\n+    }\n+\n+    requestPreview() {\n+      this.setState({count: null, calculating: true, countError: false});\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Calculate');\n+      }\n+      const cdrVersionId = +(currentWorkspaceStore.getValue().cdrVersionId);\n+      const request = {\n+        excludes: [],\n+        includes: [{\n+          items: [{\n+            type: param.domainId,\n+            searchParameters: [mapParameter(param)],\n+            modifiers: []\n+          }],\n+          temporal: false\n+        }],\n+        dataFilters: []\n+      };\n+      cohortBuilderApi().countParticipants(cdrVersionId, request).then(response => {\n+        this.setState({count: response, calculating: false});\n+      }, () => {\n+        this.setState({calculating: false, countError: true});\n+      });\n+    }\n+\n+    addParameterToSearchItem() {\n+      const {close} = this.props;\n+      let {criteria} = this.props;\n+      const param = this.paramWithAttributes;\n+      // TODO remove condition to only track PM criteria for 'Phase 2' of CB Google Analytics\n+      if (this.isPhysicalMeasurement) {\n+        this.trackEvent(param.subtype, 'Add');\n+      }\n+      criteria = criteria.filter(crit => crit.parameterId !== param.parameterId);\n+      currentCohortCriteriaStore.next([...criteria, param]);\n+      close();\n+    }\n+\n+    trackEvent(subtype: string, eventType: string) {\n+      triggerEvent(\n+        'Cohort Builder Search',\n+        'Click',\n+        `Physical Measurements - ${subTypeToTitle(subtype)} - ${eventType}`\n+      );\n+    }\n+\n+    get hasUnits() {\n+      const {node: {subtype}} = this.props;\n+      return typeof PM_UNITS[subtype] !== 'undefined';\n+    }\n+\n+    get isMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.MEASUREMENT;\n+    }\n+\n+    get isPhysicalMeasurement() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.PHYSICALMEASUREMENT;\n+    }\n+\n+    get isSurvey() {\n+      const {node: {domainId}} = this.props;\n+      return domainId === DomainType.SURVEY;\n+    }\n+\n+    get isBloodPressure() {\n+      const {node: {subtype}} = this.props;\n+      return subtype === CriteriaSubType.BP;\n+    }\n+\n+    get hasRange() {\n+      return this.isMeasurement || this.isSurvey;\n+    }\n+\n+    render() {\n+      const {close, node: {domainId, name, parentId, subtype}} = this.props;\n+      const {calculating, count, countError, form, loading, options} = this.state;\n+      const {formErrors, formValid} = this.validateForm();\n+      const disableAdd = calculating || !formValid;\n+      const disableCalculate = disableAdd || form.exists || form.num.every(attr => attr.operator === 'ANY');\n+      return (loading ?\n+        <SpinnerOverlay/> :\n+        <div style={{marginTop: '0.5rem'}}>\n+          <h3 style={{fontWeight: 600, margin: '0 0 0.5rem', textTransform: 'capitalize'}}>\n+            {domainId === DomainType.PHYSICALMEASUREMENT.toString() ? name : domainId.toString().toLowerCase()} Detail\n+          </h3>\n+          {countError && <div style={styles.error}>\n+            <ClrIcon style={{margin: '0 0.5rem 0 0.25rem'}} className='is-solid'\n+              shape='exclamation-triangle' size='22'/>\n+            Sorry, the request cannot be completed.\n+          </div>}\n+          {!!formErrors.size && <div style={styles.errors}>\n+            {Array.from(formErrors).map((err, e) => <div key={e} style={styles.errorItem}>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5Nzk0OA=="}, "originalCommit": {"oid": "e597892259182af04699d6dcc7249138ec0faff4"}, "originalPosition": 525}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDQxNjY0OnYy", "diffSide": "RIGHT", "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODoxNjo1NVrOG8-_JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOTo1NzowNlrOG9CM4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5OTcxNw==", "bodyText": "Optional: Curious if we can use loadash here like:\neg. var object = { 'a': [{ 'b': { 'c': 3 } }] };\n_.set(object, 'a[0].b.c', 4);", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r466599717", "createdAt": "2020-08-06T18:16:55Z", "author": {"login": "NehaBroad"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,609 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const {form} = this.state;\n+      if (this.hasRange) {\n+        this.getAttributes();\n+      } else {\n+        form.num = subtype === CriteriaSubType[CriteriaSubType.BP]\n+          ? JSON.parse(JSON.stringify(PREDEFINED_ATTRIBUTES.BP_DETAIL))\n+          : [{name: subtype, operator: 'ANY', operands: []}];\n+        this.setState({form, count: this.nodeCount, loading: false});\n+      }\n+    }\n+\n+    getAttributes() {\n+      const {node: {conceptId}} = this.props;\n+      const{form} = this.state;\n+      const {cdrVersionId} = currentWorkspaceStore.getValue();\n+      cohortBuilderApi().findCriteriaAttributeByConceptId(+cdrVersionId, conceptId).then(resp => {\n+        resp.items.forEach(attr => {\n+          if (attr.type === AttrName[AttrName.NUM]) {\n+            // NUM attributes set the min and max range for the number inputs in the attributes form\n+            if (!form.num.length) {\n+              form.num.push({\n+                name: AttrName.NUM,\n+                operator: this.isSurvey ? 'ANY' : null,\n+                operands: [],\n+                conceptId: conceptId,\n+                [attr.conceptName]: parseInt(attr.estCount, 10)\n+              });\n+            } else {\n+              form.num[0][attr.conceptName] = parseInt(attr.estCount, 10);\n+            }\n+          } else {\n+            // CAT attributes are displayed as checkboxes in the attributes form\n+            if (parseInt(attr.estCount, 10) > 0) {\n+              attr['checked'] = false;\n+              form.cat.push(attr);\n+            }\n+          }\n+        });\n+        const count = this.isSurvey ? this.nodeCount : null;\n+        this.setState({count, form, loading: false});\n+      });\n+    }\n+\n+    toggleCheckbox(checked: boolean) {\n+      const {form} = this.state;\n+      let {node: {count}} = this.props;\n+      if (checked) {\n+        form.exists = true;\n+        form.num = form.num.map(attr =>\n+          ({...attr, operator: this.isPhysicalMeasurement ? 'ANY' : null, operands: []}));\n+        form.cat = form.cat.map(attr => ({...attr, checked: false}));\n+      } else {\n+        count = null;\n+        form.exists = false;\n+      }\n+      this.setState({form, count});\n+    }\n+\n+    selectChange(attributeIndex: number, value: string) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operator = value;\n+      if (this.isBloodPressure) {\n+        // for blood pressure, either both operators have to be 'ANY' OR neither can be 'ANY'\n+        const otherAttribute = attributeIndex === 0 ? 1 : 0;\n+        if (value === 'ANY') {\n+          form.num[otherAttribute].operator = 'ANY';\n+          form.num[otherAttribute].operands = form.num[attributeIndex].operands = [];\n+        } else if (form.num[otherAttribute].operator === 'ANY') {\n+          form.num[otherAttribute].operator = value;\n+        }\n+      } else if (value === 'ANY') {\n+        form.num[attributeIndex].operands = [];\n+      }\n+      if (value !== Operator[Operator.BETWEEN]) {\n+        // delete second operand if it exists\n+        form.num[attributeIndex].operands.splice(1);\n+      }\n+      const count = value === 'ANY' ? this.nodeCount : null;\n+      this.setState({form, count});\n+    }\n+\n+    inputChange(input: string, attributeIndex: number, operandIndex: number) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operands[operandIndex] = sanitizeNumericalInput(input);\n+      this.setState({form, count: null});\n+    }\n+\n+    checkboxChange(checked: boolean, index: number) {\n+      const {form} = this.state;\n+      form.cat[index].checked = checked;\n+      this.setState({form});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd98b4518f573de4ec67ff69c0cef7c9bfbe6652"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1MjM4Nw==", "bodyText": "Seems like it should work but I couldn't get it to actually update the form object. Tried like this:\nfp.set(`cat[${index}].checked`, checked, form);\n\n(fp syntax switches up the args: _.set(path, value, object))", "url": "https://github.com/all-of-us/workbench/pull/3836#discussion_r466652387", "createdAt": "2020-08-06T19:57:06Z", "author": {"login": "dolbeew"}, "path": "ui/src/app/cohort-search/attributes-page-v2/attributes-page-v2.component.tsx", "diffHunk": "@@ -0,0 +1,609 @@\n+import * as fp from 'lodash/fp';\n+import {Dropdown} from 'primereact/dropdown';\n+import * as React from 'react';\n+\n+import {PM_UNITS, PREDEFINED_ATTRIBUTES} from 'app/cohort-search/constant';\n+import {ppiQuestions} from 'app/cohort-search/search-state.service';\n+import {Selection} from 'app/cohort-search/selection-list/selection-list.component';\n+import {\n+  mapParameter,\n+  sanitizeNumericalInput,\n+  stripHtml,\n+  subTypeToTitle\n+} from 'app/cohort-search/utils';\n+import {Button} from 'app/components/buttons';\n+import {FlexRowWrap} from 'app/components/flex';\n+import {ClrIcon} from 'app/components/icons';\n+import {CheckBox, NumberInput} from 'app/components/inputs';\n+import {Spinner, SpinnerOverlay} from 'app/components/spinners';\n+import {cohortBuilderApi} from 'app/services/swagger-fetch-clients';\n+import colors, {colorWithWhiteness} from 'app/styles/colors';\n+import {reactStyles, withCurrentCohortCriteria, withCurrentWorkspace} from 'app/utils';\n+import {triggerEvent} from 'app/utils/analytics';\n+import {currentCohortCriteriaStore, currentWorkspaceStore} from 'app/utils/navigation';\n+import {WorkspaceData} from 'app/utils/workspace-data';\n+import {AttrName, CriteriaSubType, DomainType, Operator} from 'generated/fetch';\n+\n+const styles = reactStyles({\n+  countPreview: {\n+    borderTop: `1px solid ${colorWithWhiteness(colors.black, 0.59)}`,\n+    marginTop: '1rem',\n+    paddingTop: '1rem',\n+  },\n+  row: {\n+    display: 'flex',\n+    flexWrap: 'wrap'\n+  },\n+  label: {\n+    color: colors.primary,\n+    fontWeight: 600,\n+    display: 'flex',\n+  },\n+  orCircle: {\n+    backgroundColor: colors.primary,\n+    borderRadius: '50%',\n+    color: colors.white,\n+    width: '1.25rem',\n+    height: '1.25rem',\n+    margin: '0.75rem auto 0.25rem',\n+    lineHeight: '1.35rem',\n+    textAlign: 'center',\n+    fontSize: '0.45rem',\n+  },\n+  container: {\n+    display: 'flex',\n+    marginLeft: 'auto',\n+    marginRight: 'auto',\n+  },\n+  dropdown: {\n+    width: '12rem',\n+    marginRight: '1rem',\n+  },\n+  categorical: {\n+    width: '100%',\n+    marginBottom: '0.25rem'\n+  },\n+  badge: {\n+    background: colors.primary,\n+    color: colors.white,\n+    fontSize: '10px',\n+    height: '0.625rem',\n+    padding: '0 4px',\n+    marginRight: '0.5rem',\n+    borderRadius: '10px',\n+    display: 'inline-flex',\n+    verticalAlign: 'middle',\n+    alignItems: 'center',\n+  },\n+  addButtonContainer: {\n+    bottom: '1rem',\n+    position: 'absolute',\n+    right: '1rem'\n+  },\n+  addButton: {\n+    height: '2rem',\n+    borderRadius: '5px',\n+    fontWeight: 600,\n+    marginRight: '0.5rem'\n+  },\n+  calculateButton: {\n+    height: '1.75rem',\n+    border: `1px solid`,\n+    borderColor: colors.accent,\n+    borderRadius: '2px',\n+    fontWeight: 100\n+  },\n+  spinner: {\n+    marginRight: '0.25rem',\n+    marginLeft: '-0.25rem'\n+  },\n+  resultsContainer: {\n+    flex: '0 0 50%',\n+    maxWidth: '50%',\n+    color: colors.primary,\n+  },\n+  error: {\n+    background: colors.warning,\n+    color: colors.white,\n+    fontSize: '12px',\n+    fontWeight: 500,\n+    textAlign: 'left',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '5px',\n+    margin: '0.25rem 0',\n+  },\n+  errors: {\n+    background: colorWithWhiteness(colors.danger, .7),\n+    color: colorWithWhiteness(colors.dark, .1),\n+    fontSize: '11px',\n+    border: '1px solid #ebafa6',\n+    borderRadius: '3px',\n+    margin: '0.25rem 0',\n+    padding: '3px 5px'\n+  },\n+  errorItem: {\n+    lineHeight: '16px',\n+  },\n+});\n+\n+const optionUtil = {\n+  ANY: {display: 'Any value', code: 'Any'},\n+  EQUAL: {display: '= ', code: '01'},\n+  GREATER_THAN_OR_EQUAL_TO: {display: '>= ', code: '02'},\n+  LESS_THAN_OR_EQUAL_TO: {display: '<= ', code: '03'},\n+  BETWEEN: {display: '', code: '04'},\n+};\n+\n+interface AttributeForm {\n+  exists: boolean; // Check if attribute values exist (Measurements only)\n+  num: Array<any>; // Numerical attributes (Physical Measurements or Measurements)\n+  cat: Array<any>; // Categorical attributes (Measurements only)\n+}\n+\n+interface Props {\n+  close: Function;\n+  criteria: Array<Selection>;\n+  node: any;\n+  workspace: WorkspaceData;\n+}\n+\n+interface State {\n+  calculating: boolean;\n+  count: number;\n+  countError: boolean;\n+  form: AttributeForm;\n+  loading: boolean;\n+  options: any;\n+}\n+export const AttributesPageV2 = fp.flow(withCurrentWorkspace(), withCurrentCohortCriteria()) (\n+  class extends React.Component<Props, State> {\n+    constructor(props: Props) {\n+      super(props);\n+      this.state = {\n+        calculating: false,\n+        count: null,\n+        countError: false,\n+        form: {exists: false, num: [], cat: []},\n+        loading: true,\n+        options: [\n+          {label: 'Equals', value: Operator.EQUAL},\n+          {label: 'Greater Than or Equal To', value: Operator.GREATERTHANOREQUALTO},\n+          {label: 'Less Than or Equal To', value: Operator.LESSTHANOREQUALTO},\n+          {label: 'Between', value: Operator.BETWEEN},\n+        ],\n+      };\n+    }\n+\n+    componentDidMount() {\n+      const{options} = this.state;\n+      if (!this.isMeasurement) {\n+        options.unshift({label: optionUtil.ANY.display, value: AttrName[AttrName.ANY]});\n+        this.setState({options}, () => this.initAttributeForm());\n+      } else {\n+        this.initAttributeForm();\n+      }\n+    }\n+\n+    componentDidUpdate(prevProps: Readonly<Props>): void {\n+      if (this.props.node !== prevProps.node) {\n+        // A different node has been selected, so we reset the form and load the new attributes\n+        this.setState({\n+          form: {exists: false, num: [], cat: []},\n+          loading: true\n+        }, () => this.initAttributeForm());\n+      }\n+    }\n+\n+    initAttributeForm() {\n+      const {node: {subtype}} = this.props;\n+      const {form} = this.state;\n+      if (this.hasRange) {\n+        this.getAttributes();\n+      } else {\n+        form.num = subtype === CriteriaSubType[CriteriaSubType.BP]\n+          ? JSON.parse(JSON.stringify(PREDEFINED_ATTRIBUTES.BP_DETAIL))\n+          : [{name: subtype, operator: 'ANY', operands: []}];\n+        this.setState({form, count: this.nodeCount, loading: false});\n+      }\n+    }\n+\n+    getAttributes() {\n+      const {node: {conceptId}} = this.props;\n+      const{form} = this.state;\n+      const {cdrVersionId} = currentWorkspaceStore.getValue();\n+      cohortBuilderApi().findCriteriaAttributeByConceptId(+cdrVersionId, conceptId).then(resp => {\n+        resp.items.forEach(attr => {\n+          if (attr.type === AttrName[AttrName.NUM]) {\n+            // NUM attributes set the min and max range for the number inputs in the attributes form\n+            if (!form.num.length) {\n+              form.num.push({\n+                name: AttrName.NUM,\n+                operator: this.isSurvey ? 'ANY' : null,\n+                operands: [],\n+                conceptId: conceptId,\n+                [attr.conceptName]: parseInt(attr.estCount, 10)\n+              });\n+            } else {\n+              form.num[0][attr.conceptName] = parseInt(attr.estCount, 10);\n+            }\n+          } else {\n+            // CAT attributes are displayed as checkboxes in the attributes form\n+            if (parseInt(attr.estCount, 10) > 0) {\n+              attr['checked'] = false;\n+              form.cat.push(attr);\n+            }\n+          }\n+        });\n+        const count = this.isSurvey ? this.nodeCount : null;\n+        this.setState({count, form, loading: false});\n+      });\n+    }\n+\n+    toggleCheckbox(checked: boolean) {\n+      const {form} = this.state;\n+      let {node: {count}} = this.props;\n+      if (checked) {\n+        form.exists = true;\n+        form.num = form.num.map(attr =>\n+          ({...attr, operator: this.isPhysicalMeasurement ? 'ANY' : null, operands: []}));\n+        form.cat = form.cat.map(attr => ({...attr, checked: false}));\n+      } else {\n+        count = null;\n+        form.exists = false;\n+      }\n+      this.setState({form, count});\n+    }\n+\n+    selectChange(attributeIndex: number, value: string) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operator = value;\n+      if (this.isBloodPressure) {\n+        // for blood pressure, either both operators have to be 'ANY' OR neither can be 'ANY'\n+        const otherAttribute = attributeIndex === 0 ? 1 : 0;\n+        if (value === 'ANY') {\n+          form.num[otherAttribute].operator = 'ANY';\n+          form.num[otherAttribute].operands = form.num[attributeIndex].operands = [];\n+        } else if (form.num[otherAttribute].operator === 'ANY') {\n+          form.num[otherAttribute].operator = value;\n+        }\n+      } else if (value === 'ANY') {\n+        form.num[attributeIndex].operands = [];\n+      }\n+      if (value !== Operator[Operator.BETWEEN]) {\n+        // delete second operand if it exists\n+        form.num[attributeIndex].operands.splice(1);\n+      }\n+      const count = value === 'ANY' ? this.nodeCount : null;\n+      this.setState({form, count});\n+    }\n+\n+    inputChange(input: string, attributeIndex: number, operandIndex: number) {\n+      const {form} = this.state;\n+      form.num[attributeIndex].operands[operandIndex] = sanitizeNumericalInput(input);\n+      this.setState({form, count: null});\n+    }\n+\n+    checkboxChange(checked: boolean, index: number) {\n+      const {form} = this.state;\n+      form.cat[index].checked = checked;\n+      this.setState({form});", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5OTcxNw=="}, "originalCommit": {"oid": "bd98b4518f573de4ec67ff69c0cef7c9bfbe6652"}, "originalPosition": 289}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2477, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}