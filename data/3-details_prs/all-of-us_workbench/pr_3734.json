{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMzUwOTMw", "number": 3734, "title": "[RW-5139][risk=low] Switch profile validation to only validate changed fields", "bodyText": "Here is a proposed fix for RW-5139 (a bug where empty profile address fields are preventing admins from changing institutional affiliations due to always-on validation logic).\nTwo separate issues were involved here:\n(1) Users with a non-empty address entry, but invalid fields (e.g. city='')\n(2) Users with a null address entry.\nWe have many instances of each in prod.\nThe solution here is based on a few principles / requirements:\n\nWhen a profile is being updated, we only care about actively validating changed fields.\nWhen a new profile is being created, all fields should be validated.\nProfile validation code should be simple, flexible, and unified.\nThis is a P1 bug so we shouldn't boil the ocean (any more than necessary) in pursuit of a fix.\n\nI took a stab here at using a generic object differ (Javers seems to be standard for this) to make it more straightforward to detect field-by-field changes. I think the end result strikes a nice balance, but I'm not dead set in this direction and am open to feedback.\n\nPR checklist\n\n This PR meets the Acceptance Criteria in the JIRA story\n The JIRA story has been moved to Dev Review\n This PR includes appropriate unit tests\n I have run and tested this change locally\n I have run the E2E tests on ths change against my local UI + API server with yarn test-local", "createdAt": "2020-06-30T23:24:37Z", "url": "https://github.com/all-of-us/workbench/pull/3734", "merged": true, "mergeCommit": {"oid": "cdac0617227a7736e5ebb9a3d80817243b088c03"}, "closed": true, "closedAt": "2020-07-01T19:49:08Z", "author": {"login": "gjuggler"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwg8qSAFqTQ0MDUwMTczNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwvV5RAH2gAyNDQyMzUwOTMwOmRiMjE1NGQwZDllODgyMzFjOGRkZTE3M2FmNGE4NDc5ODJjMTRiMTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTAxNzM1", "url": "https://github.com/all-of-us/workbench/pull/3734#pullrequestreview-440501735", "createdAt": "2020-07-01T02:12:30Z", "commit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "state": "APPROVED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjoxMjozMFrOGrUc2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjozNjoxOVrOGrUztA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3NzAxNg==", "bodyText": "nit: I'd add a wrapper around this in the service so you could do profileService.validateProfile(profile);. Ideally, we should very rarely need to write out null.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448077016", "createdAt": "2020-07-01T02:12:30Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/api/ProfileController.java", "diffHunk": "@@ -270,12 +270,8 @@ private DbUser initializeUserIfNeeded() {\n \n     final Profile profile = request.getProfile();\n \n-    // We don't include this check in validateAndCleanProfile since some existing user profiles\n-    // may have empty addresses. So we only check this on user creation, not update.\n-    Optional.ofNullable(profile.getAddress())\n-        .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n-\n-    profileService.validateAndCleanProfile(profile);\n+    // Run all profile validation by passing in a null 'previous' object.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3Nzk0Ng==", "bodyText": "should we not just bail here if the username is missing? Either throw IllegalStateException or return a failure code.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448077946", "createdAt": "2020-07-01T02:16:15Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -227,23 +235,16 @@ public void updateProfileForUser(DbUser user, Profile updatedProfile, Profile pr\n     profileAuditor.fireUpdateAction(previousProfile, appliedUpdatedProfile);\n   }\n \n-  public void validateAndCleanProfile(Profile profile) throws BadRequestException {\n-    // Validation steps, which yield a BadRequestException if errors are found.\n-    String userName = profile.getUsername();\n-    if (userName == null || userName.length() < 3 || userName.length() > 64) {\n-      throw new BadRequestException(\n-          \"Username should be at least 3 characters and not more than 64 characters\");\n-    }\n-    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n-    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n-\n+  public void cleanProfile(Profile profile) throws BadRequestException {\n     // Cleaning steps, which provide non-null fields or apply some cleanup / transformation.\n     profile.setDemographicSurvey(\n         Optional.ofNullable(profile.getDemographicSurvey()).orElse(new DemographicSurvey()));\n     profile.setInstitutionalAffiliations(\n         Optional.ofNullable(profile.getInstitutionalAffiliations()).orElse(new ArrayList<>()));\n-    // We always store the username as all lowercase.\n-    profile.setUsername(profile.getUsername().toLowerCase());\n+    if (profile.getUsername() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3OTM2OA==", "bodyText": "Did you look at ModelBackedTargetProperty and the TargetPropertyExtractor? It works via one of the target property enums like ProprtyTargetProperty.\nI'd prefer not to have separate logic for essentially the same thing both here and in the audit code.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448079368", "createdAt": "2020-07-01T02:22:07Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {\n+            return ((PropertyChange) change).getPropertyNameWithPath().startsWith(pathPrefix);\n+          } else {\n+            return false;\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Validates a set of Profile changes by comparing the updated profile to the previous version.\n+   * Only fields that have changed are subject to validation.\n+   *\n+   * <p>If the previous version is null, the updated profile is presumed to be a new profile and all\n+   * validation rules are run. If both versions are non-null, only changed fields are validated.\n+   *\n+   * @param updatedProfile\n+   * @param prevProfile\n+   * @throws BadRequestException\n+   */\n+  public void validateProfile(Profile updatedProfile, Profile prevProfile)\n+      throws BadRequestException {\n+    cleanProfile(updatedProfile);\n+\n+    boolean isNewObject = prevProfile == null;\n+    Diff diff = javers.compare(prevProfile, updatedProfile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3OTk4Mg==", "bodyText": "If we could avoid nullable parameters, that would be better. Optional works, but even optional parameters are discouraged.\nI think the breakdown is also a bit confusing, because validateProfile() calls cleanProfile(), which makes changes. I generally expect validate methods to just check something and either return a boolean or throw something.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448079982", "createdAt": "2020-07-01T02:24:38Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {\n+            return ((PropertyChange) change).getPropertyNameWithPath().startsWith(pathPrefix);\n+          } else {\n+            return false;\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Validates a set of Profile changes by comparing the updated profile to the previous version.\n+   * Only fields that have changed are subject to validation.\n+   *\n+   * <p>If the previous version is null, the updated profile is presumed to be a new profile and all\n+   * validation rules are run. If both versions are non-null, only changed fields are validated.\n+   *\n+   * @param updatedProfile\n+   * @param prevProfile\n+   * @throws BadRequestException\n+   */\n+  public void validateProfile(Profile updatedProfile, Profile prevProfile)\n+      throws BadRequestException {\n+    cleanProfile(updatedProfile);\n+\n+    boolean isNewObject = prevProfile == null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MDYwOA==", "bodyText": "Can we just add validation methods to the ProfileTargetProperty enum and cycle through those instead of putting a bunch of if's here? That way we won't have to remember to update them all.\nWhere we have\nenum class ProfileTargetProperty\nconstructor(override val propertyName: String, override val extractor: (Profile) -> String?) : ModelBackedTargetProperty<Profile>\n\nwe can just add another parameter like String? -> boolean\nYou could also add another interface for this like ValidatingTargetProperty<Profile>.\nThe downside is we have to make everything into a string.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448080608", "createdAt": "2020-07-01T02:27:16Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTIwMg==", "bodyText": "Why not use && after the instanceof check?", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448081202", "createdAt": "2020-07-01T02:29:54Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTQ1Nw==", "bodyText": "Can you make a list of Strings and iterate over tit since it's the same condition really? Better yet, can you simply tell Javers not to look at these fields?", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448081457", "createdAt": "2020-07-01T02:30:49Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {\n+            return ((PropertyChange) change).getPropertyNameWithPath().startsWith(pathPrefix);\n+          } else {\n+            return false;\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Validates a set of Profile changes by comparing the updated profile to the previous version.\n+   * Only fields that have changed are subject to validation.\n+   *\n+   * <p>If the previous version is null, the updated profile is presumed to be a new profile and all\n+   * validation rules are run. If both versions are non-null, only changed fields are validated.\n+   *\n+   * @param updatedProfile\n+   * @param prevProfile\n+   * @throws BadRequestException\n+   */\n+  public void validateProfile(Profile updatedProfile, Profile prevProfile)\n+      throws BadRequestException {\n+    cleanProfile(updatedProfile);\n+\n+    boolean isNewObject = prevProfile == null;\n+    Diff diff = javers.compare(prevProfile, updatedProfile);\n+\n+    if (!getChangesWithPrefix(diff, \"username\").isEmpty() || isNewObject) {\n+      validateUsername(updatedProfile);\n     }\n-    if (field.length() > max) {\n-      throw new BadRequestException(\n-          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    if (!getChangesWithPrefix(diff, \"contactEmail\").isEmpty() || isNewObject) {\n+      validateContactEmail(updatedProfile);\n     }\n-    if (field.length() < min) {\n-      if (min == 1) {\n-        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n-      } else {\n-        throw new BadRequestException(\n-            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+    if (!getChangesWithPrefix(diff, \"givenName\").isEmpty() || isNewObject) {\n+      validateGivenName(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"familyName\").isEmpty() || isNewObject) {\n+      validateFamilyName(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"address\").isEmpty() || isNewObject) {\n+      validateAddress(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"areaOfResearch\").isEmpty() || isNewObject) {\n+      validateAreaOfResearch(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"verifiedInstitutionalAffiliation\").isEmpty() || isNewObject) {\n+      validateInstitutionalAffiliation(updatedProfile);\n+    }\n+\n+    if (!isNewObject) {\n+      // We disallow changes in certain fields.\n+      if (!getChangesWithPrefix(diff, \"username\").isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTgxNg==", "bodyText": "It's easier to interpret and maintain if the fields look more like real data. If they're all asdf, we won't catch errors that swap them.\nIt's also much easier to pick up how the class is supposed to be used if there's recognizable state in it.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448081816", "createdAt": "2020-07-01T02:32:25Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/profile/ProfileServiceTest.java", "diffHunk": "@@ -31,22 +35,52 @@\n import org.pmiops.workbench.institution.VerifiedInstitutionalAffiliationMapper;\n import org.pmiops.workbench.institution.VerifiedInstitutionalAffiliationMapperImpl;\n import org.pmiops.workbench.institution.deprecated.InstitutionalAffiliationMapperImpl;\n+import org.pmiops.workbench.model.Address;\n import org.pmiops.workbench.model.InstitutionalRole;\n import org.pmiops.workbench.model.Profile;\n import org.pmiops.workbench.model.VerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.test.FakeClock;\n import org.pmiops.workbench.utils.mappers.CommonMappers;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.boot.test.context.TestConfiguration;\n import org.springframework.boot.test.mock.mockito.MockBean;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Import;\n+import org.springframework.context.annotation.Scope;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n public class ProfileServiceTest {\n+  private static final FakeClock CLOCK = new FakeClock(Instant.parse(\"2000-01-01T00:00:00.00Z\"));\n+\n+  private static final DbInstitution BROAD_INSTITUTION =\n+      new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\");\n+\n+  private static final VerifiedInstitutionalAffiliation BROAD_AFFILIATION =\n+      new VerifiedInstitutionalAffiliation()\n+          .institutionShortName(\"Broad\")\n+          .institutionDisplayName(\"The Broad Institute\")\n+          .institutionalRoleEnum(InstitutionalRole.ADMIN);\n+\n+  private static final Profile VALID_PROFILE =\n+      new Profile()\n+          .username(\"jdoe123\")\n+          .contactEmail(\"jdoe123@gmail.com\")\n+          .address(\n+              new Address()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4Mjc5NA==", "bodyText": "Is there not a way to associate a schema with a Diff? It seems somewhat risky (in terms of unintended changes in behavior) to use reflection, though I can see the other argument.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448082794", "createdAt": "2020-07-01T02:36:06Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4Mjg2OA==", "bodyText": "I like the name change. It makes expect changes.\nI would prefer a more immutable style, though, where we take in a profile and return a new one, especially since these aren't ORM objects.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448082868", "createdAt": "2020-07-01T02:36:19Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -227,23 +235,16 @@ public void updateProfileForUser(DbUser user, Profile updatedProfile, Profile pr\n     profileAuditor.fireUpdateAction(previousProfile, appliedUpdatedProfile);\n   }\n \n-  public void validateAndCleanProfile(Profile profile) throws BadRequestException {\n-    // Validation steps, which yield a BadRequestException if errors are found.\n-    String userName = profile.getUsername();\n-    if (userName == null || userName.length() < 3 || userName.length() > 64) {\n-      throw new BadRequestException(\n-          \"Username should be at least 3 characters and not more than 64 characters\");\n-    }\n-    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n-    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n-\n+  public void cleanProfile(Profile profile) throws BadRequestException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNzUxMzYw", "url": "https://github.com/all-of-us/workbench/pull/3734#pullrequestreview-440751360", "createdAt": "2020-07-01T10:37:47Z", "commit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDozNzo0N1rOGrgfhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo1NToxNlrOGrhA4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NDMxMA==", "bodyText": "Done. Note that both methods need to be public though, so we can't get entirely away from having a nullable parameter.\nFor cross-reference, the Javers API used to have two separate methods (one to check \"new\" objects, and one to check diffs) but they've since deprecated the separate method. There's a tiny complexity tradeoff in either direction.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448274310", "createdAt": "2020-07-01T10:37:47Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/api/ProfileController.java", "diffHunk": "@@ -270,12 +270,8 @@ private DbUser initializeUserIfNeeded() {\n \n     final Profile profile = request.getProfile();\n \n-    // We don't include this check in validateAndCleanProfile since some existing user profiles\n-    // may have empty addresses. So we only check this on user creation, not update.\n-    Optional.ofNullable(profile.getAddress())\n-        .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n-\n-    profileService.validateAndCleanProfile(profile);\n+    // Run all profile validation by passing in a null 'previous' object.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3NzAxNg=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NDgwMg==", "bodyText": "If we had a Profile.clone method I'd probably have done that. Too much code without it (and too much risk of missing something when hand-rolling the clone). Maybe there's something Swagger-codegen can be improved to do (or already has added in more recent versions?)", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448274802", "createdAt": "2020-07-01T10:38:56Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -227,23 +235,16 @@ public void updateProfileForUser(DbUser user, Profile updatedProfile, Profile pr\n     profileAuditor.fireUpdateAction(previousProfile, appliedUpdatedProfile);\n   }\n \n-  public void validateAndCleanProfile(Profile profile) throws BadRequestException {\n-    // Validation steps, which yield a BadRequestException if errors are found.\n-    String userName = profile.getUsername();\n-    if (userName == null || userName.length() < 3 || userName.length() > 64) {\n-      throw new BadRequestException(\n-          \"Username should be at least 3 characters and not more than 64 characters\");\n-    }\n-    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n-    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n-\n+  public void cleanProfile(Profile profile) throws BadRequestException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4Mjg2OA=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NTY4Mw==", "bodyText": "We separately check for missing username in the 'validate' method. I was trying to make the clean-up code as permissive as possible; I think I specifically added this to support the minimal test cases, but I think it's not unreasonable behavior for cleanProfile to avoid throwing errors.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448275683", "createdAt": "2020-07-01T10:40:51Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -227,23 +235,16 @@ public void updateProfileForUser(DbUser user, Profile updatedProfile, Profile pr\n     profileAuditor.fireUpdateAction(previousProfile, appliedUpdatedProfile);\n   }\n \n-  public void validateAndCleanProfile(Profile profile) throws BadRequestException {\n-    // Validation steps, which yield a BadRequestException if errors are found.\n-    String userName = profile.getUsername();\n-    if (userName == null || userName.length() < 3 || userName.length() > 64) {\n-      throw new BadRequestException(\n-          \"Username should be at least 3 characters and not more than 64 characters\");\n-    }\n-    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n-    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n-\n+  public void cleanProfile(Profile profile) throws BadRequestException {\n     // Cleaning steps, which provide non-null fields or apply some cleanup / transformation.\n     profile.setDemographicSurvey(\n         Optional.ofNullable(profile.getDemographicSurvey()).orElse(new DemographicSurvey()));\n     profile.setInstitutionalAffiliations(\n         Optional.ofNullable(profile.getInstitutionalAffiliations()).orElse(new ArrayList<>()));\n-    // We always store the username as all lowercase.\n-    profile.setUsername(profile.getUsername().toLowerCase());\n+    if (profile.getUsername() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3Nzk0Ng=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NzEwNA==", "bodyText": "I did have an initial look, since they're definitely somewhat related use cases. But it felt like enough plumbing would be required that I checked to see what else was out there, and Javers ended up working well with surprisingly little adapter code required. Especially w.r.t. handling nested properties it seems pretty robust.\nAs a lesser point, one of the important things w.r.t. this validation is that we have meaningful error messages when validation fails. Having those error messages live within the service implementation felt appropriate.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448277104", "createdAt": "2020-07-01T10:43:35Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MDYwOA=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3ODg2OA==", "bodyText": "There's all sorts of configuration possible, but the non-configured flow worked well enough here. The use of strings to identify changed fields is the riskiest part, but (1) those fields are part of our API model and shouldn't change much, and (2) each validation flow is covered by unit tests.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448278868", "createdAt": "2020-07-01T10:47:16Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4Mjc5NA=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3OTAzNA==", "bodyText": "I'd been experimenting with some add'l logic and hadn't cleaned it up yet. Done.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448279034", "createdAt": "2020-07-01T10:47:34Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTIwMg=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MDA2NA==", "bodyText": "I bumped cleanProfile out and added a separate validateNewProfile method. I can't identify any room for simplification beyond that. Javers aligned on a nullable 'previous' object for diffing a new instance, and they've clearly put some thought into this.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448280064", "createdAt": "2020-07-01T10:49:33Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {\n+            return ((PropertyChange) change).getPropertyNameWithPath().startsWith(pathPrefix);\n+          } else {\n+            return false;\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Validates a set of Profile changes by comparing the updated profile to the previous version.\n+   * Only fields that have changed are subject to validation.\n+   *\n+   * <p>If the previous version is null, the updated profile is presumed to be a new profile and all\n+   * validation rules are run. If both versions are non-null, only changed fields are validated.\n+   *\n+   * @param updatedProfile\n+   * @param prevProfile\n+   * @throws BadRequestException\n+   */\n+  public void validateProfile(Profile updatedProfile, Profile prevProfile)\n+      throws BadRequestException {\n+    cleanProfile(updatedProfile);\n+\n+    boolean isNewObject = prevProfile == null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3OTk4Mg=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MTIwOQ==", "bodyText": "Responded to a similar comment above \u2013 I took a look. My initial assessment was that it would have required some deep retooling to adapt the TargetProperty stuff to cover these exact use cases, and Javers was too fit-for-purpose to not use here.\nEspecially with the \"not boil the ocean\" principle in mind for this PR, this felt like the reasonable path.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448281209", "createdAt": "2020-07-01T10:51:51Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {\n+            return ((PropertyChange) change).getPropertyNameWithPath().startsWith(pathPrefix);\n+          } else {\n+            return false;\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Validates a set of Profile changes by comparing the updated profile to the previous version.\n+   * Only fields that have changed are subject to validation.\n+   *\n+   * <p>If the previous version is null, the updated profile is presumed to be a new profile and all\n+   * validation rules are run. If both versions are non-null, only changed fields are validated.\n+   *\n+   * @param updatedProfile\n+   * @param prevProfile\n+   * @throws BadRequestException\n+   */\n+  public void validateProfile(Profile updatedProfile, Profile prevProfile)\n+      throws BadRequestException {\n+    cleanProfile(updatedProfile);\n+\n+    boolean isNewObject = prevProfile == null;\n+    Diff diff = javers.compare(prevProfile, updatedProfile);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3OTM2OA=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MTQ5MA==", "bodyText": "I'm not sure what you mean here. We definitely do want Javers to check these fields, so we can throw an error when they've changed.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448281490", "createdAt": "2020-07-01T10:52:29Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {\n+            return ((PropertyChange) change).getPropertyNameWithPath().startsWith(pathPrefix);\n+          } else {\n+            return false;\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Validates a set of Profile changes by comparing the updated profile to the previous version.\n+   * Only fields that have changed are subject to validation.\n+   *\n+   * <p>If the previous version is null, the updated profile is presumed to be a new profile and all\n+   * validation rules are run. If both versions are non-null, only changed fields are validated.\n+   *\n+   * @param updatedProfile\n+   * @param prevProfile\n+   * @throws BadRequestException\n+   */\n+  public void validateProfile(Profile updatedProfile, Profile prevProfile)\n+      throws BadRequestException {\n+    cleanProfile(updatedProfile);\n+\n+    boolean isNewObject = prevProfile == null;\n+    Diff diff = javers.compare(prevProfile, updatedProfile);\n+\n+    if (!getChangesWithPrefix(diff, \"username\").isEmpty() || isNewObject) {\n+      validateUsername(updatedProfile);\n     }\n-    if (field.length() > max) {\n-      throw new BadRequestException(\n-          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    if (!getChangesWithPrefix(diff, \"contactEmail\").isEmpty() || isNewObject) {\n+      validateContactEmail(updatedProfile);\n     }\n-    if (field.length() < min) {\n-      if (min == 1) {\n-        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n-      } else {\n-        throw new BadRequestException(\n-            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+    if (!getChangesWithPrefix(diff, \"givenName\").isEmpty() || isNewObject) {\n+      validateGivenName(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"familyName\").isEmpty() || isNewObject) {\n+      validateFamilyName(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"address\").isEmpty() || isNewObject) {\n+      validateAddress(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"areaOfResearch\").isEmpty() || isNewObject) {\n+      validateAreaOfResearch(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"verifiedInstitutionalAffiliation\").isEmpty() || isNewObject) {\n+      validateInstitutionalAffiliation(updatedProfile);\n+    }\n+\n+    if (!isNewObject) {\n+      // We disallow changes in certain fields.\n+      if (!getChangesWithPrefix(diff, \"username\").isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTQ1Nw=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4Mjg1MA==", "bodyText": "Done", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448282850", "createdAt": "2020-07-01T10:55:16Z", "author": {"login": "gjuggler"}, "path": "api/src/test/java/org/pmiops/workbench/profile/ProfileServiceTest.java", "diffHunk": "@@ -31,22 +35,52 @@\n import org.pmiops.workbench.institution.VerifiedInstitutionalAffiliationMapper;\n import org.pmiops.workbench.institution.VerifiedInstitutionalAffiliationMapperImpl;\n import org.pmiops.workbench.institution.deprecated.InstitutionalAffiliationMapperImpl;\n+import org.pmiops.workbench.model.Address;\n import org.pmiops.workbench.model.InstitutionalRole;\n import org.pmiops.workbench.model.Profile;\n import org.pmiops.workbench.model.VerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.test.FakeClock;\n import org.pmiops.workbench.utils.mappers.CommonMappers;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.boot.test.context.TestConfiguration;\n import org.springframework.boot.test.mock.mockito.MockBean;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Import;\n+import org.springframework.context.annotation.Scope;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n public class ProfileServiceTest {\n+  private static final FakeClock CLOCK = new FakeClock(Instant.parse(\"2000-01-01T00:00:00.00Z\"));\n+\n+  private static final DbInstitution BROAD_INSTITUTION =\n+      new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\");\n+\n+  private static final VerifiedInstitutionalAffiliation BROAD_AFFILIATION =\n+      new VerifiedInstitutionalAffiliation()\n+          .institutionShortName(\"Broad\")\n+          .institutionDisplayName(\"The Broad Institute\")\n+          .institutionalRoleEnum(InstitutionalRole.ADMIN);\n+\n+  private static final Profile VALID_PROFILE =\n+      new Profile()\n+          .username(\"jdoe123\")\n+          .contactEmail(\"jdoe123@gmail.com\")\n+          .address(\n+              new Address()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTgxNg=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwODU1NTMw", "url": "https://github.com/all-of-us/workbench/pull/3734#pullrequestreview-440855530", "createdAt": "2020-07-01T13:12:40Z", "commit": {"oid": "6d6a46315bdfdb433d81fa592378a5069583305d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f97ce62cbc24f7eb5a4b32d543443d50c9290531", "author": {"user": {"login": "gjuggler", "name": "Greg Jordan"}}, "url": "https://github.com/all-of-us/workbench/commit/f97ce62cbc24f7eb5a4b32d543443d50c9290531", "committedDate": "2020-07-01T18:01:39Z", "message": "First cut at more flexible profile validation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c621d459561cc944e90b34e022469606c15f5681", "author": {"user": {"login": "gjuggler", "name": "Greg Jordan"}}, "url": "https://github.com/all-of-us/workbench/commit/c621d459561cc944e90b34e022469606c15f5681", "committedDate": "2020-07-01T18:01:39Z", "message": "Gradle build fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4bc2b225f902ed8b369783fda22b05491c467dd", "author": {"user": {"login": "gjuggler", "name": "Greg Jordan"}}, "url": "https://github.com/all-of-us/workbench/commit/e4bc2b225f902ed8b369783fda22b05491c467dd", "committedDate": "2020-07-01T18:01:40Z", "message": "Tiny doc addition"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fbf4e32d12f61eee83d973d0b19facad8ab87650", "author": {"user": {"login": "gjuggler", "name": "Greg Jordan"}}, "url": "https://github.com/all-of-us/workbench/commit/fbf4e32d12f61eee83d973d0b19facad8ab87650", "committedDate": "2020-07-01T18:01:40Z", "message": "Fix controller tests with some diff improvements."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3a51b9e94df6b84bcc275676708f40f57a95cda", "author": {"user": {"login": "gjuggler", "name": "Greg Jordan"}}, "url": "https://github.com/all-of-us/workbench/commit/a3a51b9e94df6b84bcc275676708f40f57a95cda", "committedDate": "2020-07-01T18:01:40Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9284eee24093bd0bd2213e805719b2ec45cbfa41", "author": {"user": {"login": "gjuggler", "name": "Greg Jordan"}}, "url": "https://github.com/all-of-us/workbench/commit/9284eee24093bd0bd2213e805719b2ec45cbfa41", "committedDate": "2020-07-01T18:01:41Z", "message": "Test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4e5e87e13fa8536f60742af9faad0a6dfd50c31", "author": {"user": {"login": "gjuggler", "name": "Greg Jordan"}}, "url": "https://github.com/all-of-us/workbench/commit/d4e5e87e13fa8536f60742af9faad0a6dfd50c31", "committedDate": "2020-07-01T18:01:41Z", "message": "Populate an empty Address field in cleanProfile if null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ab9486d564678ab1a90bc3f47bc47e6197f2f06", "author": {"user": {"login": "gjuggler", "name": "Greg Jordan"}}, "url": "https://github.com/all-of-us/workbench/commit/6ab9486d564678ab1a90bc3f47bc47e6197f2f06", "committedDate": "2020-07-01T18:01:41Z", "message": "Add test for updateProfileForUser method."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e57e2cd3938cec4ad29a9a1c1f7df715751825c", "author": {"user": {"login": "gjuggler", "name": "Greg Jordan"}}, "url": "https://github.com/all-of-us/workbench/commit/6e57e2cd3938cec4ad29a9a1c1f7df715751825c", "committedDate": "2020-07-01T18:01:42Z", "message": "Handle null address."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2782c15121745dc90c691984cccc5623ed481415", "author": {"user": {"login": "gjuggler", "name": "Greg Jordan"}}, "url": "https://github.com/all-of-us/workbench/commit/2782c15121745dc90c691984cccc5623ed481415", "committedDate": "2020-07-01T17:14:06Z", "message": "Handle null address."}, "afterCommit": {"oid": "6e57e2cd3938cec4ad29a9a1c1f7df715751825c", "author": {"user": {"login": "gjuggler", "name": "Greg Jordan"}}, "url": "https://github.com/all-of-us/workbench/commit/6e57e2cd3938cec4ad29a9a1c1f7df715751825c", "committedDate": "2020-07-01T18:01:42Z", "message": "Handle null address."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f8d199c43589f819f40479d155de44cdb775c6d", "author": {"user": {"login": "gjuggler", "name": "Greg Jordan"}}, "url": "https://github.com/all-of-us/workbench/commit/1f8d199c43589f819f40479d155de44cdb775c6d", "committedDate": "2020-07-01T18:49:48Z", "message": "Remove extra println"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMTE4ODcy", "url": "https://github.com/all-of-us/workbench/pull/3734#pullrequestreview-441118872", "createdAt": "2020-07-01T18:52:04Z", "commit": {"oid": "1f8d199c43589f819f40479d155de44cdb775c6d"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODo1MjowNFrOGrxoJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxOTowMjoxMlrOGrx7Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1NTA0Ng==", "bodyText": "nit: we're alphabetizing these lists now (also 2 spots below)", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448555046", "createdAt": "2020-07-01T18:52:04Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -53,6 +60,7 @@\n   private final UserTermsOfServiceDao userTermsOfServiceDao;\n   private final VerifiedInstitutionalAffiliationDao verifiedInstitutionalAffiliationDao;\n   private final VerifiedInstitutionalAffiliationMapper verifiedInstitutionalAffiliationMapper;\n+  private final Javers javers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f8d199c43589f819f40479d155de44cdb775c6d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1NjQxNw==", "bodyText": "nit - ifPresent(DbAddress::setUser)", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448556417", "createdAt": "2020-07-01T18:54:48Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -185,31 +210,30 @@ public void updateProfileForUser(DbUser user, Profile updatedProfile, Profile pr\n     user.setAreaOfResearch(updatedProfile.getAreaOfResearch());\n     user.setProfessionalUrl(updatedProfile.getProfessionalUrl());\n     user.setAddress(addressMapper.addressToDbAddress(updatedProfile.getAddress()));\n-    user.getAddress().setUser(user);\n+    // Address may be null for users who were created before address validation was in place. See\n+    // RW-5139.\n+    Optional.ofNullable(user.getAddress()).ifPresent(address -> address.setUser(user));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f8d199c43589f819f40479d155de44cdb775c6d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1OTkyNw==", "bodyText": "I often trip up on @MockBean vs @Autowired vs @import ... do we have a doc?\nI have probably asked this before.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448559927", "createdAt": "2020-07-01T19:02:12Z", "author": {"login": "jmthibault79"}, "path": "api/src/test/java/org/pmiops/workbench/profile/ProfileServiceTest.java", "diffHunk": "@@ -55,12 +92,12 @@\n   @MockBean\n   private VerifiedInstitutionalAffiliationMapper mockVerifiedInstitutionalAffiliationMapper;\n \n-  private static final FakeClock CLOCK = new FakeClock(Instant.parse(\"2000-01-01T00:00:00.00Z\"));\n+  @MockBean private VerifiedInstitutionalAffiliationDao mockVerifiedInstitutionalAffiliationDao;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f8d199c43589f819f40479d155de44cdb775c6d"}, "originalPosition": 92}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db2154d0d9e88231c8dde173af4a847982c14b17", "author": {"user": {"login": "gjuggler", "name": "Greg Jordan"}}, "url": "https://github.com/all-of-us/workbench/commit/db2154d0d9e88231c8dde173af4a847982c14b17", "committedDate": "2020-07-01T19:23:54Z", "message": "Alphabetize"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4650, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}