{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMzUwOTMw", "number": 3734, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjoxMjozMFrOEKVmtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxOTowMjoxMlrOEKoKJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mjc1MTg5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/api/ProfileController.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjoxMjozMFrOGrUc2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDozNzo0N1rOGrgfhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3NzAxNg==", "bodyText": "nit: I'd add a wrapper around this in the service so you could do profileService.validateProfile(profile);. Ideally, we should very rarely need to write out null.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448077016", "createdAt": "2020-07-01T02:12:30Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/api/ProfileController.java", "diffHunk": "@@ -270,12 +270,8 @@ private DbUser initializeUserIfNeeded() {\n \n     final Profile profile = request.getProfile();\n \n-    // We don't include this check in validateAndCleanProfile since some existing user profiles\n-    // may have empty addresses. So we only check this on user creation, not update.\n-    Optional.ofNullable(profile.getAddress())\n-        .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n-\n-    profileService.validateAndCleanProfile(profile);\n+    // Run all profile validation by passing in a null 'previous' object.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NDMxMA==", "bodyText": "Done. Note that both methods need to be public though, so we can't get entirely away from having a nullable parameter.\nFor cross-reference, the Javers API used to have two separate methods (one to check \"new\" objects, and one to check diffs) but they've since deprecated the separate method. There's a tiny complexity tradeoff in either direction.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448274310", "createdAt": "2020-07-01T10:37:47Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/api/ProfileController.java", "diffHunk": "@@ -270,12 +270,8 @@ private DbUser initializeUserIfNeeded() {\n \n     final Profile profile = request.getProfile();\n \n-    // We don't include this check in validateAndCleanProfile since some existing user profiles\n-    // may have empty addresses. So we only check this on user creation, not update.\n-    Optional.ofNullable(profile.getAddress())\n-        .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n-\n-    profileService.validateAndCleanProfile(profile);\n+    // Run all profile validation by passing in a null 'previous' object.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3NzAxNg=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mjc1ODEzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjoxNjoxNVrOGrUgeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo0MDo1MVrOGrgk4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3Nzk0Ng==", "bodyText": "should we not just bail here if the username is missing? Either throw IllegalStateException or return a failure code.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448077946", "createdAt": "2020-07-01T02:16:15Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -227,23 +235,16 @@ public void updateProfileForUser(DbUser user, Profile updatedProfile, Profile pr\n     profileAuditor.fireUpdateAction(previousProfile, appliedUpdatedProfile);\n   }\n \n-  public void validateAndCleanProfile(Profile profile) throws BadRequestException {\n-    // Validation steps, which yield a BadRequestException if errors are found.\n-    String userName = profile.getUsername();\n-    if (userName == null || userName.length() < 3 || userName.length() > 64) {\n-      throw new BadRequestException(\n-          \"Username should be at least 3 characters and not more than 64 characters\");\n-    }\n-    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n-    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n-\n+  public void cleanProfile(Profile profile) throws BadRequestException {\n     // Cleaning steps, which provide non-null fields or apply some cleanup / transformation.\n     profile.setDemographicSurvey(\n         Optional.ofNullable(profile.getDemographicSurvey()).orElse(new DemographicSurvey()));\n     profile.setInstitutionalAffiliations(\n         Optional.ofNullable(profile.getInstitutionalAffiliations()).orElse(new ArrayList<>()));\n-    // We always store the username as all lowercase.\n-    profile.setUsername(profile.getUsername().toLowerCase());\n+    if (profile.getUsername() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NTY4Mw==", "bodyText": "We separately check for missing username in the 'validate' method. I was trying to make the clean-up code as permissive as possible; I think I specifically added this to support the minimal test cases, but I think it's not unreasonable behavior for cleanProfile to avoid throwing errors.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448275683", "createdAt": "2020-07-01T10:40:51Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -227,23 +235,16 @@ public void updateProfileForUser(DbUser user, Profile updatedProfile, Profile pr\n     profileAuditor.fireUpdateAction(previousProfile, appliedUpdatedProfile);\n   }\n \n-  public void validateAndCleanProfile(Profile profile) throws BadRequestException {\n-    // Validation steps, which yield a BadRequestException if errors are found.\n-    String userName = profile.getUsername();\n-    if (userName == null || userName.length() < 3 || userName.length() > 64) {\n-      throw new BadRequestException(\n-          \"Username should be at least 3 characters and not more than 64 characters\");\n-    }\n-    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n-    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n-\n+  public void cleanProfile(Profile profile) throws BadRequestException {\n     // Cleaning steps, which provide non-null fields or apply some cleanup / transformation.\n     profile.setDemographicSurvey(\n         Optional.ofNullable(profile.getDemographicSurvey()).orElse(new DemographicSurvey()));\n     profile.setInstitutionalAffiliations(\n         Optional.ofNullable(profile.getInstitutionalAffiliations()).orElse(new ArrayList<>()));\n-    // We always store the username as all lowercase.\n-    profile.setUsername(profile.getUsername().toLowerCase());\n+    if (profile.getUsername() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3Nzk0Ng=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mjc2Nzc5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjoyMjowN1rOGrUmCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo1MTo1MVrOGrg6eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3OTM2OA==", "bodyText": "Did you look at ModelBackedTargetProperty and the TargetPropertyExtractor? It works via one of the target property enums like ProprtyTargetProperty.\nI'd prefer not to have separate logic for essentially the same thing both here and in the audit code.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448079368", "createdAt": "2020-07-01T02:22:07Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {\n+            return ((PropertyChange) change).getPropertyNameWithPath().startsWith(pathPrefix);\n+          } else {\n+            return false;\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Validates a set of Profile changes by comparing the updated profile to the previous version.\n+   * Only fields that have changed are subject to validation.\n+   *\n+   * <p>If the previous version is null, the updated profile is presumed to be a new profile and all\n+   * validation rules are run. If both versions are non-null, only changed fields are validated.\n+   *\n+   * @param updatedProfile\n+   * @param prevProfile\n+   * @throws BadRequestException\n+   */\n+  public void validateProfile(Profile updatedProfile, Profile prevProfile)\n+      throws BadRequestException {\n+    cleanProfile(updatedProfile);\n+\n+    boolean isNewObject = prevProfile == null;\n+    Diff diff = javers.compare(prevProfile, updatedProfile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MTIwOQ==", "bodyText": "Responded to a similar comment above \u2013 I took a look. My initial assessment was that it would have required some deep retooling to adapt the TargetProperty stuff to cover these exact use cases, and Javers was too fit-for-purpose to not use here.\nEspecially with the \"not boil the ocean\" principle in mind for this PR, this felt like the reasonable path.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448281209", "createdAt": "2020-07-01T10:51:51Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {\n+            return ((PropertyChange) change).getPropertyNameWithPath().startsWith(pathPrefix);\n+          } else {\n+            return false;\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Validates a set of Profile changes by comparing the updated profile to the previous version.\n+   * Only fields that have changed are subject to validation.\n+   *\n+   * <p>If the previous version is null, the updated profile is presumed to be a new profile and all\n+   * validation rules are run. If both versions are non-null, only changed fields are validated.\n+   *\n+   * @param updatedProfile\n+   * @param prevProfile\n+   * @throws BadRequestException\n+   */\n+  public void validateProfile(Profile updatedProfile, Profile prevProfile)\n+      throws BadRequestException {\n+    cleanProfile(updatedProfile);\n+\n+    boolean isNewObject = prevProfile == null;\n+    Diff diff = javers.compare(prevProfile, updatedProfile);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3OTM2OA=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mjc3MjAwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjoyNDozOFrOGrUobg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo0OTozM1rOGrg2AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3OTk4Mg==", "bodyText": "If we could avoid nullable parameters, that would be better. Optional works, but even optional parameters are discouraged.\nI think the breakdown is also a bit confusing, because validateProfile() calls cleanProfile(), which makes changes. I generally expect validate methods to just check something and either return a boolean or throw something.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448079982", "createdAt": "2020-07-01T02:24:38Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {\n+            return ((PropertyChange) change).getPropertyNameWithPath().startsWith(pathPrefix);\n+          } else {\n+            return false;\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Validates a set of Profile changes by comparing the updated profile to the previous version.\n+   * Only fields that have changed are subject to validation.\n+   *\n+   * <p>If the previous version is null, the updated profile is presumed to be a new profile and all\n+   * validation rules are run. If both versions are non-null, only changed fields are validated.\n+   *\n+   * @param updatedProfile\n+   * @param prevProfile\n+   * @throws BadRequestException\n+   */\n+  public void validateProfile(Profile updatedProfile, Profile prevProfile)\n+      throws BadRequestException {\n+    cleanProfile(updatedProfile);\n+\n+    boolean isNewObject = prevProfile == null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MDA2NA==", "bodyText": "I bumped cleanProfile out and added a separate validateNewProfile method. I can't identify any room for simplification beyond that. Javers aligned on a nullable 'previous' object for diffing a new instance, and they've clearly put some thought into this.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448280064", "createdAt": "2020-07-01T10:49:33Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {\n+            return ((PropertyChange) change).getPropertyNameWithPath().startsWith(pathPrefix);\n+          } else {\n+            return false;\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Validates a set of Profile changes by comparing the updated profile to the previous version.\n+   * Only fields that have changed are subject to validation.\n+   *\n+   * <p>If the previous version is null, the updated profile is presumed to be a new profile and all\n+   * validation rules are run. If both versions are non-null, only changed fields are validated.\n+   *\n+   * @param updatedProfile\n+   * @param prevProfile\n+   * @throws BadRequestException\n+   */\n+  public void validateProfile(Profile updatedProfile, Profile prevProfile)\n+      throws BadRequestException {\n+    cleanProfile(updatedProfile);\n+\n+    boolean isNewObject = prevProfile == null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3OTk4Mg=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mjc3NjE3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjoyNzoxNlrOGrUq4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo0MzozNVrOGrgqcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MDYwOA==", "bodyText": "Can we just add validation methods to the ProfileTargetProperty enum and cycle through those instead of putting a bunch of if's here? That way we won't have to remember to update them all.\nWhere we have\nenum class ProfileTargetProperty\nconstructor(override val propertyName: String, override val extractor: (Profile) -> String?) : ModelBackedTargetProperty<Profile>\n\nwe can just add another parameter like String? -> boolean\nYou could also add another interface for this like ValidatingTargetProperty<Profile>.\nThe downside is we have to make everything into a string.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448080608", "createdAt": "2020-07-01T02:27:16Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NzEwNA==", "bodyText": "I did have an initial look, since they're definitely somewhat related use cases. But it felt like enough plumbing would be required that I checked to see what else was out there, and Javers ended up working well with surprisingly little adapter code required. Especially w.r.t. handling nested properties it seems pretty robust.\nAs a lesser point, one of the important things w.r.t. this validation is that we have meaningful error messages when validation fails. Having those error messages live within the service implementation felt appropriate.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448277104", "createdAt": "2020-07-01T10:43:35Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MDYwOA=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mjc4MDA3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjoyOTo1NFrOGrUtMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo0NzozNFrOGrgx-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTIwMg==", "bodyText": "Why not use && after the instanceof check?", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448081202", "createdAt": "2020-07-01T02:29:54Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3OTAzNA==", "bodyText": "I'd been experimenting with some add'l logic and hadn't cleaned it up yet. Done.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448279034", "createdAt": "2020-07-01T10:47:34Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTIwMg=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mjc4MTk3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjozMDo0OVrOGrUuMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODo0MzoyM1rOGrxXtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTQ1Nw==", "bodyText": "Can you make a list of Strings and iterate over tit since it's the same condition really? Better yet, can you simply tell Javers not to look at these fields?", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448081457", "createdAt": "2020-07-01T02:30:49Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {\n+            return ((PropertyChange) change).getPropertyNameWithPath().startsWith(pathPrefix);\n+          } else {\n+            return false;\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Validates a set of Profile changes by comparing the updated profile to the previous version.\n+   * Only fields that have changed are subject to validation.\n+   *\n+   * <p>If the previous version is null, the updated profile is presumed to be a new profile and all\n+   * validation rules are run. If both versions are non-null, only changed fields are validated.\n+   *\n+   * @param updatedProfile\n+   * @param prevProfile\n+   * @throws BadRequestException\n+   */\n+  public void validateProfile(Profile updatedProfile, Profile prevProfile)\n+      throws BadRequestException {\n+    cleanProfile(updatedProfile);\n+\n+    boolean isNewObject = prevProfile == null;\n+    Diff diff = javers.compare(prevProfile, updatedProfile);\n+\n+    if (!getChangesWithPrefix(diff, \"username\").isEmpty() || isNewObject) {\n+      validateUsername(updatedProfile);\n     }\n-    if (field.length() > max) {\n-      throw new BadRequestException(\n-          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    if (!getChangesWithPrefix(diff, \"contactEmail\").isEmpty() || isNewObject) {\n+      validateContactEmail(updatedProfile);\n     }\n-    if (field.length() < min) {\n-      if (min == 1) {\n-        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n-      } else {\n-        throw new BadRequestException(\n-            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+    if (!getChangesWithPrefix(diff, \"givenName\").isEmpty() || isNewObject) {\n+      validateGivenName(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"familyName\").isEmpty() || isNewObject) {\n+      validateFamilyName(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"address\").isEmpty() || isNewObject) {\n+      validateAddress(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"areaOfResearch\").isEmpty() || isNewObject) {\n+      validateAreaOfResearch(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"verifiedInstitutionalAffiliation\").isEmpty() || isNewObject) {\n+      validateInstitutionalAffiliation(updatedProfile);\n+    }\n+\n+    if (!isNewObject) {\n+      // We disallow changes in certain fields.\n+      if (!getChangesWithPrefix(diff, \"username\").isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MTQ5MA==", "bodyText": "I'm not sure what you mean here. We definitely do want Javers to check these fields, so we can throw an error when they've changed.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448281490", "createdAt": "2020-07-01T10:52:29Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {\n+            return ((PropertyChange) change).getPropertyNameWithPath().startsWith(pathPrefix);\n+          } else {\n+            return false;\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Validates a set of Profile changes by comparing the updated profile to the previous version.\n+   * Only fields that have changed are subject to validation.\n+   *\n+   * <p>If the previous version is null, the updated profile is presumed to be a new profile and all\n+   * validation rules are run. If both versions are non-null, only changed fields are validated.\n+   *\n+   * @param updatedProfile\n+   * @param prevProfile\n+   * @throws BadRequestException\n+   */\n+  public void validateProfile(Profile updatedProfile, Profile prevProfile)\n+      throws BadRequestException {\n+    cleanProfile(updatedProfile);\n+\n+    boolean isNewObject = prevProfile == null;\n+    Diff diff = javers.compare(prevProfile, updatedProfile);\n+\n+    if (!getChangesWithPrefix(diff, \"username\").isEmpty() || isNewObject) {\n+      validateUsername(updatedProfile);\n     }\n-    if (field.length() > max) {\n-      throw new BadRequestException(\n-          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    if (!getChangesWithPrefix(diff, \"contactEmail\").isEmpty() || isNewObject) {\n+      validateContactEmail(updatedProfile);\n     }\n-    if (field.length() < min) {\n-      if (min == 1) {\n-        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n-      } else {\n-        throw new BadRequestException(\n-            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+    if (!getChangesWithPrefix(diff, \"givenName\").isEmpty() || isNewObject) {\n+      validateGivenName(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"familyName\").isEmpty() || isNewObject) {\n+      validateFamilyName(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"address\").isEmpty() || isNewObject) {\n+      validateAddress(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"areaOfResearch\").isEmpty() || isNewObject) {\n+      validateAreaOfResearch(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"verifiedInstitutionalAffiliation\").isEmpty() || isNewObject) {\n+      validateInstitutionalAffiliation(updatedProfile);\n+    }\n+\n+    if (!isNewObject) {\n+      // We disallow changes in certain fields.\n+      if (!getChangesWithPrefix(diff, \"username\").isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTQ1Nw=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1MDgzOA==", "bodyText": "Oh, I was thinking we only wrote fields that changed. nvm.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448550838", "createdAt": "2020-07-01T18:43:23Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {\n+    return diff.getChanges(\n+        change -> {\n+          if (change instanceof PropertyChange) {\n+            return ((PropertyChange) change).getPropertyNameWithPath().startsWith(pathPrefix);\n+          } else {\n+            return false;\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Validates a set of Profile changes by comparing the updated profile to the previous version.\n+   * Only fields that have changed are subject to validation.\n+   *\n+   * <p>If the previous version is null, the updated profile is presumed to be a new profile and all\n+   * validation rules are run. If both versions are non-null, only changed fields are validated.\n+   *\n+   * @param updatedProfile\n+   * @param prevProfile\n+   * @throws BadRequestException\n+   */\n+  public void validateProfile(Profile updatedProfile, Profile prevProfile)\n+      throws BadRequestException {\n+    cleanProfile(updatedProfile);\n+\n+    boolean isNewObject = prevProfile == null;\n+    Diff diff = javers.compare(prevProfile, updatedProfile);\n+\n+    if (!getChangesWithPrefix(diff, \"username\").isEmpty() || isNewObject) {\n+      validateUsername(updatedProfile);\n     }\n-    if (field.length() > max) {\n-      throw new BadRequestException(\n-          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    if (!getChangesWithPrefix(diff, \"contactEmail\").isEmpty() || isNewObject) {\n+      validateContactEmail(updatedProfile);\n     }\n-    if (field.length() < min) {\n-      if (min == 1) {\n-        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n-      } else {\n-        throw new BadRequestException(\n-            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+    if (!getChangesWithPrefix(diff, \"givenName\").isEmpty() || isNewObject) {\n+      validateGivenName(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"familyName\").isEmpty() || isNewObject) {\n+      validateFamilyName(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"address\").isEmpty() || isNewObject) {\n+      validateAddress(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"areaOfResearch\").isEmpty() || isNewObject) {\n+      validateAreaOfResearch(updatedProfile);\n+    }\n+    if (!getChangesWithPrefix(diff, \"verifiedInstitutionalAffiliation\").isEmpty() || isNewObject) {\n+      validateInstitutionalAffiliation(updatedProfile);\n+    }\n+\n+    if (!isNewObject) {\n+      // We disallow changes in certain fields.\n+      if (!getChangesWithPrefix(diff, \"username\").isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTQ1Nw=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mjc4NDE5OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/pmiops/workbench/profile/ProfileServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjozMjoyNVrOGrUvmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo1NToxNlrOGrhA4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTgxNg==", "bodyText": "It's easier to interpret and maintain if the fields look more like real data. If they're all asdf, we won't catch errors that swap them.\nIt's also much easier to pick up how the class is supposed to be used if there's recognizable state in it.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448081816", "createdAt": "2020-07-01T02:32:25Z", "author": {"login": "jaycarlton"}, "path": "api/src/test/java/org/pmiops/workbench/profile/ProfileServiceTest.java", "diffHunk": "@@ -31,22 +35,52 @@\n import org.pmiops.workbench.institution.VerifiedInstitutionalAffiliationMapper;\n import org.pmiops.workbench.institution.VerifiedInstitutionalAffiliationMapperImpl;\n import org.pmiops.workbench.institution.deprecated.InstitutionalAffiliationMapperImpl;\n+import org.pmiops.workbench.model.Address;\n import org.pmiops.workbench.model.InstitutionalRole;\n import org.pmiops.workbench.model.Profile;\n import org.pmiops.workbench.model.VerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.test.FakeClock;\n import org.pmiops.workbench.utils.mappers.CommonMappers;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.boot.test.context.TestConfiguration;\n import org.springframework.boot.test.mock.mockito.MockBean;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Import;\n+import org.springframework.context.annotation.Scope;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n public class ProfileServiceTest {\n+  private static final FakeClock CLOCK = new FakeClock(Instant.parse(\"2000-01-01T00:00:00.00Z\"));\n+\n+  private static final DbInstitution BROAD_INSTITUTION =\n+      new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\");\n+\n+  private static final VerifiedInstitutionalAffiliation BROAD_AFFILIATION =\n+      new VerifiedInstitutionalAffiliation()\n+          .institutionShortName(\"Broad\")\n+          .institutionDisplayName(\"The Broad Institute\")\n+          .institutionalRoleEnum(InstitutionalRole.ADMIN);\n+\n+  private static final Profile VALID_PROFILE =\n+      new Profile()\n+          .username(\"jdoe123\")\n+          .contactEmail(\"jdoe123@gmail.com\")\n+          .address(\n+              new Address()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4Mjg1MA==", "bodyText": "Done", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448282850", "createdAt": "2020-07-01T10:55:16Z", "author": {"login": "gjuggler"}, "path": "api/src/test/java/org/pmiops/workbench/profile/ProfileServiceTest.java", "diffHunk": "@@ -31,22 +35,52 @@\n import org.pmiops.workbench.institution.VerifiedInstitutionalAffiliationMapper;\n import org.pmiops.workbench.institution.VerifiedInstitutionalAffiliationMapperImpl;\n import org.pmiops.workbench.institution.deprecated.InstitutionalAffiliationMapperImpl;\n+import org.pmiops.workbench.model.Address;\n import org.pmiops.workbench.model.InstitutionalRole;\n import org.pmiops.workbench.model.Profile;\n import org.pmiops.workbench.model.VerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.test.FakeClock;\n import org.pmiops.workbench.utils.mappers.CommonMappers;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.boot.test.context.TestConfiguration;\n import org.springframework.boot.test.mock.mockito.MockBean;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Import;\n+import org.springframework.context.annotation.Scope;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n public class ProfileServiceTest {\n+  private static final FakeClock CLOCK = new FakeClock(Instant.parse(\"2000-01-01T00:00:00.00Z\"));\n+\n+  private static final DbInstitution BROAD_INSTITUTION =\n+      new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\");\n+\n+  private static final VerifiedInstitutionalAffiliation BROAD_AFFILIATION =\n+      new VerifiedInstitutionalAffiliation()\n+          .institutionShortName(\"Broad\")\n+          .institutionDisplayName(\"The Broad Institute\")\n+          .institutionalRoleEnum(InstitutionalRole.ADMIN);\n+\n+  private static final Profile VALID_PROFILE =\n+      new Profile()\n+          .username(\"jdoe123\")\n+          .contactEmail(\"jdoe123@gmail.com\")\n+          .address(\n+              new Address()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTgxNg=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mjc5MDk0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjozNjowNlrOGrUzag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjoxMzoyOFrOGrjUNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4Mjc5NA==", "bodyText": "Is there not a way to associate a schema with a Diff? It seems somewhat risky (in terms of unintended changes in behavior) to use reflection, though I can see the other argument.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448082794", "createdAt": "2020-07-01T02:36:06Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3ODg2OA==", "bodyText": "There's all sorts of configuration possible, but the non-configured flow worked well enough here. The use of strings to identify changed fields is the riskiest part, but (1) those fields are part of our API model and shouldn't change much, and (2) each validation flow is covered by unit tests.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448278868", "createdAt": "2020-07-01T10:47:16Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4Mjc5NA=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMDU2Nw==", "bodyText": "I thought of a couple of things to be careful about would be any dynamic properties that return different results every time or properties derived from other properties, which would be double-evaluated. Neiither are an issue for a simple codegen'd model class I suppose.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448320567", "createdAt": "2020-07-01T12:13:28Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -286,50 +287,132 @@ private void updateInstitutionalAffiliations(Profile updatedProfile, DbUser user\n     }\n   }\n \n-  private void validateUpdatedProfile(Profile updatedProfile, Profile prevProfile)\n-      throws BadRequestException {\n-    validateAndCleanProfile(updatedProfile);\n-    if (StringUtils.isEmpty(updatedProfile.getAreaOfResearch())) {\n-      throw new BadRequestException(\"Research background cannot be empty\");\n+  private void validateStringLength(String field, String fieldName, int max, int min) {\n+    if (field == null) {\n+      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+    }\n+    if (field.length() > max) {\n+      throw new BadRequestException(\n+          String.format(\"%s length exceeds character limit. (%d)\", fieldName, max));\n+    }\n+    if (field.length() < min) {\n+      if (min == 1) {\n+        throw new BadRequestException(String.format(\"%s cannot be left blank.\", fieldName));\n+      } else {\n+        throw new BadRequestException(\n+            String.format(\"%s is under character minimum. (%d)\", fieldName, min));\n+      }\n+    }\n+  }\n+\n+  private void validateUsername(Profile profile) throws BadRequestException {\n+    String username = profile.getUsername();\n+    if (username == null || username.length() < 3 || username.length() > 64) {\n+      throw new BadRequestException(\n+          \"Username should be at least 3 characters and not more than 64 characters\");\n     }\n-    Optional.ofNullable(updatedProfile.getAddress())\n+  }\n+\n+  private void validateContactEmail(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getContactEmail())) {\n+      throw new BadRequestException(\"Contact email cannot be empty\");\n+    }\n+  }\n+\n+  private void validateGivenName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n+  }\n+\n+  private void validateFamilyName(Profile profile) throws BadRequestException {\n+    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n+  }\n+\n+  private void validateAddress(Profile profile) throws BadRequestException {\n+    Optional.ofNullable(profile.getAddress())\n         .orElseThrow(() -> new BadRequestException(\"Address must not be empty\"));\n \n-    Address updatedProfileAddress = updatedProfile.getAddress();\n+    Address updatedProfileAddress = profile.getAddress();\n     if (StringUtils.isEmpty(updatedProfileAddress.getStreetAddress1())\n         || StringUtils.isEmpty(updatedProfileAddress.getCity())\n         || StringUtils.isEmpty(updatedProfileAddress.getState())\n         || StringUtils.isEmpty(updatedProfileAddress.getCountry())\n         || StringUtils.isEmpty(updatedProfileAddress.getZipCode())) {\n       throw new BadRequestException(\n-          \"Address cannot have empty street Address 1/city/state/country or Zip Code\");\n+          \"Address cannot have empty street address, city, state, country or zip code\");\n     }\n-    if (updatedProfile.getContactEmail() != null\n-        && !updatedProfile.getContactEmail().equals(prevProfile.getContactEmail())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing email is not currently supported\");\n-    }\n-    if (updatedProfile.getUsername() != null\n-        && !updatedProfile.getUsername().equals(prevProfile.getUsername())) {\n-      // See RW-1488.\n-      throw new BadRequestException(\"Changing username is not supported\");\n+  }\n+\n+  private void validateAreaOfResearch(Profile profile) throws BadRequestException {\n+    if (StringUtils.isEmpty(profile.getAreaOfResearch())) {\n+      throw new BadRequestException(\"Research background cannot be empty\");\n     }\n   }\n \n-  private void validateStringLength(String field, String fieldName, int max, int min) {\n-    if (field == null) {\n-      throw new BadRequestException(String.format(\"%s cannot be left blank!\", fieldName));\n+  /**\n+   * Returns a list of PropertyChange entries from a diff that match either a field or any of its\n+   * subfields. For example, a pathPrefix of 'address' will match a field change for both 'address'\n+   * and for 'address.zipCode'.\n+   */\n+  private List<Change> getChangesWithPrefix(final Diff diff, final String pathPrefix) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4Mjc5NA=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mjc5MTQ3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjozNjoxOVrOGrUztA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODo0NDoyNlrOGrxZrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4Mjg2OA==", "bodyText": "I like the name change. It makes expect changes.\nI would prefer a more immutable style, though, where we take in a profile and return a new one, especially since these aren't ORM objects.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448082868", "createdAt": "2020-07-01T02:36:19Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -227,23 +235,16 @@ public void updateProfileForUser(DbUser user, Profile updatedProfile, Profile pr\n     profileAuditor.fireUpdateAction(previousProfile, appliedUpdatedProfile);\n   }\n \n-  public void validateAndCleanProfile(Profile profile) throws BadRequestException {\n-    // Validation steps, which yield a BadRequestException if errors are found.\n-    String userName = profile.getUsername();\n-    if (userName == null || userName.length() < 3 || userName.length() > 64) {\n-      throw new BadRequestException(\n-          \"Username should be at least 3 characters and not more than 64 characters\");\n-    }\n-    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n-    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n-\n+  public void cleanProfile(Profile profile) throws BadRequestException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NDgwMg==", "bodyText": "If we had a Profile.clone method I'd probably have done that. Too much code without it (and too much risk of missing something when hand-rolling the clone). Maybe there's something Swagger-codegen can be improved to do (or already has added in more recent versions?)", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448274802", "createdAt": "2020-07-01T10:38:56Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -227,23 +235,16 @@ public void updateProfileForUser(DbUser user, Profile updatedProfile, Profile pr\n     profileAuditor.fireUpdateAction(previousProfile, appliedUpdatedProfile);\n   }\n \n-  public void validateAndCleanProfile(Profile profile) throws BadRequestException {\n-    // Validation steps, which yield a BadRequestException if errors are found.\n-    String userName = profile.getUsername();\n-    if (userName == null || userName.length() < 3 || userName.length() > 64) {\n-      throw new BadRequestException(\n-          \"Username should be at least 3 characters and not more than 64 characters\");\n-    }\n-    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n-    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n-\n+  public void cleanProfile(Profile profile) throws BadRequestException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4Mjg2OA=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1MTM0Mw==", "bodyText": "We can  make a cloneProfile() easily with MapStruct. You just have a method that takes and returns a Profile.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448551343", "createdAt": "2020-07-01T18:44:26Z", "author": {"login": "jaycarlton"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -227,23 +235,16 @@ public void updateProfileForUser(DbUser user, Profile updatedProfile, Profile pr\n     profileAuditor.fireUpdateAction(previousProfile, appliedUpdatedProfile);\n   }\n \n-  public void validateAndCleanProfile(Profile profile) throws BadRequestException {\n-    // Validation steps, which yield a BadRequestException if errors are found.\n-    String userName = profile.getUsername();\n-    if (userName == null || userName.length() < 3 || userName.length() > 64) {\n-      throw new BadRequestException(\n-          \"Username should be at least 3 characters and not more than 64 characters\");\n-    }\n-    validateStringLength(profile.getGivenName(), \"Given Name\", 80, 1);\n-    validateStringLength(profile.getFamilyName(), \"Family Name\", 80, 1);\n-\n+  public void cleanProfile(Profile profile) throws BadRequestException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4Mjg2OA=="}, "originalCommit": {"oid": "c45e40cb5e11eae1756a48894c9a149f7e9d6b54"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTc2MTgyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODo1MjowNFrOGrxoJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxOToxMjo1OFrOGryO7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1NTA0Ng==", "bodyText": "nit: we're alphabetizing these lists now (also 2 spots below)", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448555046", "createdAt": "2020-07-01T18:52:04Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -53,6 +60,7 @@\n   private final UserTermsOfServiceDao userTermsOfServiceDao;\n   private final VerifiedInstitutionalAffiliationDao verifiedInstitutionalAffiliationDao;\n   private final VerifiedInstitutionalAffiliationMapper verifiedInstitutionalAffiliationMapper;\n+  private final Javers javers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f8d199c43589f819f40479d155de44cdb775c6d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2NDk3NQ==", "bodyText": "I lurve alphabetization \u2013\u00a0dunno why I didn't notice we're doing that here.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448564975", "createdAt": "2020-07-01T19:12:58Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -53,6 +60,7 @@\n   private final UserTermsOfServiceDao userTermsOfServiceDao;\n   private final VerifiedInstitutionalAffiliationDao verifiedInstitutionalAffiliationDao;\n   private final VerifiedInstitutionalAffiliationMapper verifiedInstitutionalAffiliationMapper;\n+  private final Javers javers;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1NTA0Ng=="}, "originalCommit": {"oid": "1f8d199c43589f819f40479d155de44cdb775c6d"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTc3MDQ2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODo1NDo0OFrOGrxtgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMDoyODoxOVrOGr0T1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1NjQxNw==", "bodyText": "nit - ifPresent(DbAddress::setUser)", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448556417", "createdAt": "2020-07-01T18:54:48Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -185,31 +210,30 @@ public void updateProfileForUser(DbUser user, Profile updatedProfile, Profile pr\n     user.setAreaOfResearch(updatedProfile.getAreaOfResearch());\n     user.setProfessionalUrl(updatedProfile.getProfessionalUrl());\n     user.setAddress(addressMapper.addressToDbAddress(updatedProfile.getAddress()));\n-    user.getAddress().setUser(user);\n+    // Address may be null for users who were created before address validation was in place. See\n+    // RW-5139.\n+    Optional.ofNullable(user.getAddress()).ifPresent(address -> address.setUser(user));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f8d199c43589f819f40479d155de44cdb775c6d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2NjUxNg==", "bodyText": "I don't think this quite works since the ifPresent subject is what we want to call the method on, not the argument.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448566516", "createdAt": "2020-07-01T19:16:21Z", "author": {"login": "gjuggler"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -185,31 +210,30 @@ public void updateProfileForUser(DbUser user, Profile updatedProfile, Profile pr\n     user.setAreaOfResearch(updatedProfile.getAreaOfResearch());\n     user.setProfessionalUrl(updatedProfile.getProfessionalUrl());\n     user.setAddress(addressMapper.addressToDbAddress(updatedProfile.getAddress()));\n-    user.getAddress().setUser(user);\n+    // Address may be null for users who were created before address validation was in place. See\n+    // RW-5139.\n+    Optional.ofNullable(user.getAddress()).ifPresent(address -> address.setUser(user));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1NjQxNw=="}, "originalCommit": {"oid": "1f8d199c43589f819f40479d155de44cdb775c6d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU5ODk5Ng==", "bodyText": "oops.  yes.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448598996", "createdAt": "2020-07-01T20:28:19Z", "author": {"login": "jmthibault79"}, "path": "api/src/main/java/org/pmiops/workbench/profile/ProfileService.java", "diffHunk": "@@ -185,31 +210,30 @@ public void updateProfileForUser(DbUser user, Profile updatedProfile, Profile pr\n     user.setAreaOfResearch(updatedProfile.getAreaOfResearch());\n     user.setProfessionalUrl(updatedProfile.getProfessionalUrl());\n     user.setAddress(addressMapper.addressToDbAddress(updatedProfile.getAddress()));\n-    user.getAddress().setUser(user);\n+    // Address may be null for users who were created before address validation was in place. See\n+    // RW-5139.\n+    Optional.ofNullable(user.getAddress()).ifPresent(address -> address.setUser(user));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1NjQxNw=="}, "originalCommit": {"oid": "1f8d199c43589f819f40479d155de44cdb775c6d"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTc5MTcyOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/org/pmiops/workbench/profile/ProfileServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxOTowMjoxMlrOGrx7Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxOToyMzozMFrOGryhjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1OTkyNw==", "bodyText": "I often trip up on @MockBean vs @Autowired vs @import ... do we have a doc?\nI have probably asked this before.", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448559927", "createdAt": "2020-07-01T19:02:12Z", "author": {"login": "jmthibault79"}, "path": "api/src/test/java/org/pmiops/workbench/profile/ProfileServiceTest.java", "diffHunk": "@@ -55,12 +92,12 @@\n   @MockBean\n   private VerifiedInstitutionalAffiliationMapper mockVerifiedInstitutionalAffiliationMapper;\n \n-  private static final FakeClock CLOCK = new FakeClock(Instant.parse(\"2000-01-01T00:00:00.00Z\"));\n+  @MockBean private VerifiedInstitutionalAffiliationDao mockVerifiedInstitutionalAffiliationDao;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f8d199c43589f819f40479d155de44cdb775c6d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2OTc0Mg==", "bodyText": "Eek, yeah it would be great to have some docs on this. I've definitely developed an aesthetic that seems to work reliably for most cases, it'll be good to capture that. Tracked in https://precisionmedicineinitiative.atlassian.net/browse/RW-5159", "url": "https://github.com/all-of-us/workbench/pull/3734#discussion_r448569742", "createdAt": "2020-07-01T19:23:30Z", "author": {"login": "gjuggler"}, "path": "api/src/test/java/org/pmiops/workbench/profile/ProfileServiceTest.java", "diffHunk": "@@ -55,12 +92,12 @@\n   @MockBean\n   private VerifiedInstitutionalAffiliationMapper mockVerifiedInstitutionalAffiliationMapper;\n \n-  private static final FakeClock CLOCK = new FakeClock(Instant.parse(\"2000-01-01T00:00:00.00Z\"));\n+  @MockBean private VerifiedInstitutionalAffiliationDao mockVerifiedInstitutionalAffiliationDao;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1OTkyNw=="}, "originalCommit": {"oid": "1f8d199c43589f819f40479d155de44cdb775c6d"}, "originalPosition": 92}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2604, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}