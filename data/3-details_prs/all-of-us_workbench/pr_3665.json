{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzNzcyNzgy", "number": 3665, "title": "[RISK=NO][RW-5065] Migrate additional route and add a guard", "bodyText": "Description:\nI migrated the data user code of conduct route over to react router.\n\nRemoved the existing route from the Angular router\nAdded a sign in guard - at the moment both sign in guards will get called, further work on teasing out the guards and stores will be needed\nAdded the concept of \"atoms\" to the code base - basically a subscribe-able container\n\nThis allows us to iteratively migrate away from the Angular services\nThis could be a pattern that replaces some of the current angular services / stores\n\n\nAdded an authStore and routeDataStore - a couple of barebones stores to be able to check the auth status and set the page title/pass data to the route respectively\n\n\nPR checklist\n\n This PR meets the Acceptance Criteria in the JIRA story\n The JIRA story has been moved to Dev Review\n This PR includes appropriate unit tests\n I have run and tested this change locally\n I have run the E2E tests on ths change against my local UI + API server with yarn test-local\n(Failing tests also failed on master)\n If this includes a UI change, I have taken screen recordings or screenshots of the new behavior and notified the PO and UX designer\n If this includes an API change, I have updated the appropriate Swagger definitions and notified API consumers\n If this includes a new feature flag, I have created and linked new JIRA tickets to (a) turn on the feature flag and (b) remove it later", "createdAt": "2020-06-12T16:14:08Z", "url": "https://github.com/all-of-us/workbench/pull/3665", "merged": true, "mergeCommit": {"oid": "4ff0e0f261b63109042b0ce7e38427d82a0db862"}, "closed": true, "closedAt": "2020-06-17T17:50:23Z", "author": {"login": "petesantos"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcprRTuAH2gAyNDMzNzcyNzgyOjg4ZDliMjY3ZTk0MDdlNGY4M2YyNTBjZTM3ODRlNTM1YTA2ZTNjOWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsLFWcgH2gAyNDMzNzcyNzgyOjAzNjg0NDkwZWI5YjY2N2YyODc5M2RjMTY1ODJkMDc4NGExYTgxNDg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "88d9b267e9407e4f83f250ce3784e535a06e3c9f", "author": {"user": {"login": "petesantos", "name": "Pete Santos"}}, "url": "https://github.com/all-of-us/workbench/commit/88d9b267e9407e4f83f250ce3784e535a06e3c9f", "committedDate": "2020-06-09T20:41:48Z", "message": "Working DUCC react router path"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ca607a598892bbce14be8c9192a063a93240f20", "author": {"user": {"login": "petesantos", "name": "Pete Santos"}}, "url": "https://github.com/all-of-us/workbench/commit/0ca607a598892bbce14be8c9192a063a93240f20", "committedDate": "2020-06-12T14:12:20Z", "message": "Functioning code with guard and redirect"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4589d5c02a075d714343d5dc4388ef16c5565bc3", "author": {"user": {"login": "petesantos", "name": "Pete Santos"}}, "url": "https://github.com/all-of-us/workbench/commit/4589d5c02a075d714343d5dc4388ef16c5565bc3", "committedDate": "2020-06-12T14:26:49Z", "message": "Code Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9846d1040b8fa17cda019144777da22cf9f19dd0", "author": {"user": {"login": "petesantos", "name": "Pete Santos"}}, "url": "https://github.com/all-of-us/workbench/commit/9846d1040b8fa17cda019144777da22cf9f19dd0", "committedDate": "2020-06-12T15:02:20Z", "message": "Cleanup and types to atoms"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a2799fe0c98f2576385f1bdf7c720edcf8fc14b", "author": {"user": {"login": "petesantos", "name": "Pete Santos"}}, "url": "https://github.com/all-of-us/workbench/commit/1a2799fe0c98f2576385f1bdf7c720edcf8fc14b", "committedDate": "2020-06-12T15:54:12Z", "message": "Add typing to atoms"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c", "author": {"user": {"login": "petesantos", "name": "Pete Santos"}}, "url": "https://github.com/all-of-us/workbench/commit/2bc531c26a401b920fa15fb212f393f422e1794c", "committedDate": "2020-06-12T15:59:41Z", "message": "Fix linting issue"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMDgzOTU1", "url": "https://github.com/all-of-us/workbench/pull/3665#pullrequestreview-430083955", "createdAt": "2020-06-12T23:34:48Z", "commit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzozNDo0OVrOGjT76g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDo1MDoxM1rOGjUtfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTk3OA==", "bodyText": "Hmm. Not new in this PR, but just checking around - it seems that our \"route not found\" behavior is pretty bad - just renders a blank page. I don't recall what the behavior was prior to the addition of this: I believe it was the same, worse, or it rerouted to the homepage. May want to track this in a ticket if you haven't already.", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439679978", "createdAt": "2020-06-12T23:34:49Z", "author": {"login": "calbach"}, "path": "ui/src/app/app-routing.module.ts", "diffHunk": "@@ -339,11 +334,18 @@ const routes: Routes = [\n         path: 'workspaces/build',\n         component: WorkspaceEditComponent,\n         data: {title: 'Create Workspace', mode: WorkspaceEditMode.Create}\n+      },\n+      {\n+        path: '**',\n+        component: AppRouting,\n+        data:  {}\n       }\n     ]\n-  }, {\n+  },\n+  {\n     path: '**',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MzE4Nw==", "bodyText": "Interesting, I was expecting the generic AuthStore to be inferred from the parameter type here, but it's possible the underlying React library is a bit lazy with its typing. Did you confirm that <AuthStore> is necessary here?", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439683187", "createdAt": "2020-06-12T23:54:23Z", "author": {"login": "calbach"}, "path": "ui/src/app/app-routing.tsx", "diffHunk": "@@ -1,15 +1,36 @@\n import {Component as AComponent} from '@angular/core';\n-import {AppRoute, AppRouter} from 'app/components/app-router';\n+import {AppRoute, AppRouter, Guard, ProtectedRoutes, withFullHeight, withTitle} from 'app/components/app-router';\n+import {DataUserCodeOfConduct} from 'app/pages/profile/data-user-code-of-conduct';\n import { ReactWrapperBase } from 'app/utils';\n+import {authStore, AuthStore, useStore} from 'app/utils/stores';\n+import * as fp from 'lodash/fp';\n import * as React from 'react';\n import {CookiePolicyComponent} from './pages/cookie-policy';\n \n-export const AppRoutingComponent: React.FunctionComponent = () => <AppRouter>\n+\n+const signInGuard: Guard = {\n+  allowed: (): boolean => authStore.get().isSignedIn,\n+  redirectPath: '/login'\n+};\n+\n+const DUCC = fp.flow(withTitle, withFullHeight)(DataUserCodeOfConduct);\n+\n+export const AppRoutingComponent: React.FunctionComponent = () => {\n+  const {authLoaded = false} = useStore<AuthStore>(authStore);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NDIyNQ==", "bodyText": "nit: rm space?", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439684225", "createdAt": "2020-06-13T00:01:10Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/stores.tsx", "diffHunk": "@@ -0,0 +1,23 @@\n+import {useEffect, useState} from 'react';\n+import {atom, Atom} from './subscribable';\n+\n+interface RouteDataStore {\n+  title?: string;\n+}\n+\n+export const routeDataStore = atom <RouteDataStore>({});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTU1Mw==", "bodyText": "I think it makes sense and I like the symmetry of useStore, but seeing useState in a helper function is hurting my brain a bit. We can discuss this offline if it's faster, but:\nDo you happen to know the mechanism by which React associates this global call to a component? Is it just tracking a stack of render calls - and binds any useState call to the current component in that stack? Or setting aside the implementation details, is that the right mental model?\nI would probably add a method doc to this one to explain the intended usage, i.e. that it should only be called from a react function component (I believe)", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439685553", "createdAt": "2020-06-13T00:09:38Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/stores.tsx", "diffHunk": "@@ -0,0 +1,23 @@\n+import {useEffect, useState} from 'react';\n+import {atom, Atom} from './subscribable';\n+\n+interface RouteDataStore {\n+  title?: string;\n+}\n+\n+export const routeDataStore = atom <RouteDataStore>({});\n+\n+export interface AuthStore {\n+  authLoaded: boolean;\n+  isSignedIn: boolean;\n+}\n+\n+export const authStore = atom<AuthStore>({authLoaded: false, isSignedIn: false});\n+\n+export function useStore<T>(theStore: Atom<T>) {\n+  const [value, setValue] = useState(theStore.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjMyNA==", "bodyText": "I looked at the useEffect docs. This line is still does not compute.\ntheStore is not a property or state, AFAICT. What does it mean to filter useEffect to only run when it \"changes\"? setValue might make some sense(?); my best guess is that it basically daisy-chains the above subscription setup to itself.\nCan you add a comment, or if there's a more general concept I'm missing - point me to the right docs?", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439686324", "createdAt": "2020-06-13T00:15:18Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/stores.tsx", "diffHunk": "@@ -0,0 +1,23 @@\n+import {useEffect, useState} from 'react';\n+import {atom, Atom} from './subscribable';\n+\n+interface RouteDataStore {\n+  title?: string;\n+}\n+\n+export const routeDataStore = atom <RouteDataStore>({});\n+\n+export interface AuthStore {\n+  authLoaded: boolean;\n+  isSignedIn: boolean;\n+}\n+\n+export const authStore = atom<AuthStore>({authLoaded: false, isSignedIn: false});\n+\n+export function useStore<T>(theStore: Atom<T>) {\n+  const [value, setValue] = useState(theStore.get());\n+  useEffect(() => {\n+    return theStore.subscribe(v => setValue(v)).unsubscribe;\n+  }, [theStore, setValue]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjUwNA==", "bodyText": "Could you add some basic docs to these interfaces? Method-level docs are probably not needed given the simplicity", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439686504", "createdAt": "2020-06-13T00:16:31Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,43 @@\n+import * as fp from 'lodash/fp';\n+\n+export interface Subscribable<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjgxNA==", "bodyText": "nit: Do you need the div? Does Fragment not work here?", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439686814", "createdAt": "2020-06-13T00:18:58Z", "author": {"login": "calbach"}, "path": "ui/src/app/components/app-router.tsx", "diffHunk": "@@ -1,26 +1,43 @@\n+import {navigate} from 'app/utils/navigation';\n+import {routeDataStore} from 'app/utils/stores';\n import * as fp from 'lodash/fp';\n import * as React from 'react';\n import { BrowserRouter, Link, Redirect, Route, Switch, useHistory, useLocation, useParams, useRouteMatch} from 'react-router-dom';\n \n const {Fragment} = React;\n \n-interface Guards {\n-  [index: number]: {\n-    checkGuard: () => boolean;\n-    redirectPath: string;\n-  };\n+export interface Guard {\n+  allowed: () => boolean;\n+  redirectPath: string;\n }\n \n export const usePath = () => {\n   const {path} = useRouteMatch();\n   return path;\n };\n \n+export const withTitle = WrappedComponent => ({title, ...props}) => {\n+  routeDataStore.set({title});\n+  return <WrappedComponent {...props}/>;\n+};\n+\n+export const withFullHeight = WrappedComponent => ({...props}) => {\n+  return <div style={{height: '100%'}}><WrappedComponent {...props} /></div>;\n+};\n+\n export const SubRoute = ({children}): React.ReactElement => <Switch>{children}</Switch>;\n export const AppRouter = ({children}): React.ReactElement => <BrowserRouter><SubRoute>{children}</SubRoute></BrowserRouter>;\n \n export const RouteLink = ({path, style = {}, children}): React.ReactElement => <Link style={{...style}} to={path}>{children}</Link>;\n \n+// To compensate for Angular, while keeping true to the declarative/compnentized nature of the router\n+// We will utilize a redirect component that uses the Angular navigation.\n+// Upon completing the migration this can be replaced with a react-router Redirect component\n+const NavRedirect = ({path}) => {\n+  navigate([path]);\n+  return <div/>;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Njk4OA==", "bodyText": "Not a real word anyways, but spelling: componentized", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439686988", "createdAt": "2020-06-13T00:20:20Z", "author": {"login": "calbach"}, "path": "ui/src/app/components/app-router.tsx", "diffHunk": "@@ -1,26 +1,43 @@\n+import {navigate} from 'app/utils/navigation';\n+import {routeDataStore} from 'app/utils/stores';\n import * as fp from 'lodash/fp';\n import * as React from 'react';\n import { BrowserRouter, Link, Redirect, Route, Switch, useHistory, useLocation, useParams, useRouteMatch} from 'react-router-dom';\n \n const {Fragment} = React;\n \n-interface Guards {\n-  [index: number]: {\n-    checkGuard: () => boolean;\n-    redirectPath: string;\n-  };\n+export interface Guard {\n+  allowed: () => boolean;\n+  redirectPath: string;\n }\n \n export const usePath = () => {\n   const {path} = useRouteMatch();\n   return path;\n };\n \n+export const withTitle = WrappedComponent => ({title, ...props}) => {\n+  routeDataStore.set({title});\n+  return <WrappedComponent {...props}/>;\n+};\n+\n+export const withFullHeight = WrappedComponent => ({...props}) => {\n+  return <div style={{height: '100%'}}><WrappedComponent {...props} /></div>;\n+};\n+\n export const SubRoute = ({children}): React.ReactElement => <Switch>{children}</Switch>;\n export const AppRouter = ({children}): React.ReactElement => <BrowserRouter><SubRoute>{children}</SubRoute></BrowserRouter>;\n \n export const RouteLink = ({path, style = {}, children}): React.ReactElement => <Link style={{...style}} to={path}>{children}</Link>;\n \n+// To compensate for Angular, while keeping true to the declarative/compnentized nature of the router", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Nzc4MA==", "bodyText": "This gets killed after migrating off Angular right? Maybe leave a comment here so we can remember what to rip out afterwards.", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439687780", "createdAt": "2020-06-13T00:25:38Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/stores.tsx", "diffHunk": "@@ -0,0 +1,23 @@\n+import {useEffect, useState} from 'react';\n+import {atom, Atom} from './subscribable';\n+\n+interface RouteDataStore {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4OTEzNQ==", "bodyText": "I'm surprised the type system is OK with this. Should this have the more constrained method signature found in the interface?", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439689135", "createdAt": "2020-06-13T00:34:14Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,43 @@\n+import * as fp from 'lodash/fp';\n+\n+export interface Subscribable<T> {\n+  subscribe: (Function) => { unsubscribe: () => void};\n+  next: (newValue: T, oldValue: T) => void;\n+}\n+\n+export interface Atom<T> {\n+  get: () => T;\n+  set: (value: T) => void;\n+  subscribe: Subscribable<T>['subscribe'];\n+  reset: () => void;\n+}\n+\n+export function subscribable<T>(): Subscribable<T> {\n+  let subscribers = [];\n+  return {\n+    subscribe: fn => {\n+      subscribers = fp.concat(subscribers, [fn]);\n+      return {\n+        unsubscribe: () => {\n+          subscribers = fp.without([fn], subscribers);\n+        }\n+      };\n+    },\n+    next: (...args) => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MTY0OA==", "bodyText": "Is this based on something else? There's some interesting design considerations here. Is this tailored for a particular constrained use case - or if not, do you have rationale on the following?\n\nWhether or not to immediately deliver the most recent element to new subscribers. For something like an event system, this wouldn't make sense - but for a store, it can make the initial connection boilerplate a bit more homogeneous (one subscribe() path, rather than a get + subscribe).\nSynchronous vs asynchronous handling on next(), i.e. current approach vs invoking subscribers in a setTimeout(, 0) to pop this out of the stack. This provides some encapsulation between the subscribers, and avoids dependency on synchronous next() behaviors.", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439691648", "createdAt": "2020-06-13T00:40:47Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,43 @@\n+import * as fp from 'lodash/fp';\n+\n+export interface Subscribable<T> {\n+  subscribe: (Function) => { unsubscribe: () => void};\n+  next: (newValue: T, oldValue: T) => void;\n+}\n+\n+export interface Atom<T> {\n+  get: () => T;\n+  set: (value: T) => void;\n+  subscribe: Subscribable<T>['subscribe'];\n+  reset: () => void;\n+}\n+\n+export function subscribable<T>(): Subscribable<T> {\n+  let subscribers = [];\n+  return {\n+    subscribe: fn => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MjI4OQ==", "bodyText": "This immediately throws if any of the subscribers throw. If you keep this synchronous per above, I would have some try/catch protection around each callback, since this is potentially a large list of mixed subscribers - an error in one should not be able to take down the whole subscribable.", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439692289", "createdAt": "2020-06-13T00:46:38Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,43 @@\n+import * as fp from 'lodash/fp';\n+\n+export interface Subscribable<T> {\n+  subscribe: (Function) => { unsubscribe: () => void};\n+  next: (newValue: T, oldValue: T) => void;\n+}\n+\n+export interface Atom<T> {\n+  get: () => T;\n+  set: (value: T) => void;\n+  subscribe: Subscribable<T>['subscribe'];\n+  reset: () => void;\n+}\n+\n+export function subscribable<T>(): Subscribable<T> {\n+  let subscribers = [];\n+  return {\n+    subscribe: fn => {\n+      subscribers = fp.concat(subscribers, [fn]);\n+      return {\n+        unsubscribe: () => {\n+          subscribers = fp.without([fn], subscribers);\n+        }\n+      };\n+    },\n+    next: (...args) => {\n+      fp.forEach(fn => fn(...args), subscribers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MjY3MA==", "bodyText": "Some simple unit tests around the Atom to codify some of its more nuanced behaviors could be nice: synchronous vs asynchronous behaviors, subscriptions, behavior on initial data seeding", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439692670", "createdAt": "2020-06-13T00:50:13Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,43 @@\n+import * as fp from 'lodash/fp';\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNjY5NTc3", "url": "https://github.com/all-of-us/workbench/pull/3665#pullrequestreview-430669577", "createdAt": "2020-06-15T13:58:05Z", "commit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMzo1ODowNlrOGjzZCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTowODowMlrOGj2csQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE5NTMzOA==", "bodyText": "<AuthStore> removed - thanks!", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440195338", "createdAt": "2020-06-15T13:58:06Z", "author": {"login": "petesantos"}, "path": "ui/src/app/app-routing.tsx", "diffHunk": "@@ -1,15 +1,36 @@\n import {Component as AComponent} from '@angular/core';\n-import {AppRoute, AppRouter} from 'app/components/app-router';\n+import {AppRoute, AppRouter, Guard, ProtectedRoutes, withFullHeight, withTitle} from 'app/components/app-router';\n+import {DataUserCodeOfConduct} from 'app/pages/profile/data-user-code-of-conduct';\n import { ReactWrapperBase } from 'app/utils';\n+import {authStore, AuthStore, useStore} from 'app/utils/stores';\n+import * as fp from 'lodash/fp';\n import * as React from 'react';\n import {CookiePolicyComponent} from './pages/cookie-policy';\n \n-export const AppRoutingComponent: React.FunctionComponent = () => <AppRouter>\n+\n+const signInGuard: Guard = {\n+  allowed: (): boolean => authStore.get().isSignedIn,\n+  redirectPath: '/login'\n+};\n+\n+const DUCC = fp.flow(withTitle, withFullHeight)(DataUserCodeOfConduct);\n+\n+export const AppRoutingComponent: React.FunctionComponent = () => {\n+  const {authLoaded = false} = useStore<AuthStore>(authStore);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MzE4Nw=="}, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE5ODUyNQ==", "bodyText": "replaced with return null", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440198525", "createdAt": "2020-06-15T14:02:47Z", "author": {"login": "petesantos"}, "path": "ui/src/app/components/app-router.tsx", "diffHunk": "@@ -1,26 +1,43 @@\n+import {navigate} from 'app/utils/navigation';\n+import {routeDataStore} from 'app/utils/stores';\n import * as fp from 'lodash/fp';\n import * as React from 'react';\n import { BrowserRouter, Link, Redirect, Route, Switch, useHistory, useLocation, useParams, useRouteMatch} from 'react-router-dom';\n \n const {Fragment} = React;\n \n-interface Guards {\n-  [index: number]: {\n-    checkGuard: () => boolean;\n-    redirectPath: string;\n-  };\n+export interface Guard {\n+  allowed: () => boolean;\n+  redirectPath: string;\n }\n \n export const usePath = () => {\n   const {path} = useRouteMatch();\n   return path;\n };\n \n+export const withTitle = WrappedComponent => ({title, ...props}) => {\n+  routeDataStore.set({title});\n+  return <WrappedComponent {...props}/>;\n+};\n+\n+export const withFullHeight = WrappedComponent => ({...props}) => {\n+  return <div style={{height: '100%'}}><WrappedComponent {...props} /></div>;\n+};\n+\n export const SubRoute = ({children}): React.ReactElement => <Switch>{children}</Switch>;\n export const AppRouter = ({children}): React.ReactElement => <BrowserRouter><SubRoute>{children}</SubRoute></BrowserRouter>;\n \n export const RouteLink = ({path, style = {}, children}): React.ReactElement => <Link style={{...style}} to={path}>{children}</Link>;\n \n+// To compensate for Angular, while keeping true to the declarative/compnentized nature of the router\n+// We will utilize a redirect component that uses the Angular navigation.\n+// Upon completing the migration this can be replaced with a react-router Redirect component\n+const NavRedirect = ({path}) => {\n+  navigate([path]);\n+  return <div/>;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjgxNA=="}, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIwMTE0Mg==", "bodyText": "I am not certain on this one. It depends on how we specify title's and other data in a route. RouteDataStore could be expanded to house additional data, or we could use a different mechanism", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440201142", "createdAt": "2020-06-15T14:06:35Z", "author": {"login": "petesantos"}, "path": "ui/src/app/utils/stores.tsx", "diffHunk": "@@ -0,0 +1,23 @@\n+import {useEffect, useState} from 'react';\n+import {atom, Atom} from './subscribable';\n+\n+interface RouteDataStore {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Nzc4MA=="}, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIyMDg4MA==", "bodyText": "If the store were to change (e.g. the store is passed into a child component as a prop from a parent component and the store changes) we would want the effect to run to:\n\nUnsubscribe from the previous store (cleanup) using the function returned in useEffect\nSubscribe to the new store\n\nOnce subscribed it will run setValue (setting the state) when the store changes, which will cause a re-render\nI removed setValue and will add some comments", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440220880", "createdAt": "2020-06-15T14:34:19Z", "author": {"login": "petesantos"}, "path": "ui/src/app/utils/stores.tsx", "diffHunk": "@@ -0,0 +1,23 @@\n+import {useEffect, useState} from 'react';\n+import {atom, Atom} from './subscribable';\n+\n+interface RouteDataStore {\n+  title?: string;\n+}\n+\n+export const routeDataStore = atom <RouteDataStore>({});\n+\n+export interface AuthStore {\n+  authLoaded: boolean;\n+  isSignedIn: boolean;\n+}\n+\n+export const authStore = atom<AuthStore>({authLoaded: false, isSignedIn: false});\n+\n+export function useStore<T>(theStore: Atom<T>) {\n+  const [value, setValue] = useState(theStore.get());\n+  useEffect(() => {\n+    return theStore.subscribe(v => setValue(v)).unsubscribe;\n+  }, [theStore, setValue]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjMyNA=="}, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIzNDc5Mg==", "bodyText": "Returning the unsubscribe functions allows for the use of anonymous functions / being able to unsubscribe from them. I could combine these all into the atom and return the value as well on subscribe.\nThis is taken from Terra code that we created to allow local storage changes to be synced up using hooks. But prior to that the atoms and subscribe code were all in one function.\nI like the idea on making this async! I will play around with that.", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440234792", "createdAt": "2020-06-15T14:53:14Z", "author": {"login": "petesantos"}, "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,43 @@\n+import * as fp from 'lodash/fp';\n+\n+export interface Subscribable<T> {\n+  subscribe: (Function) => { unsubscribe: () => void};\n+  next: (newValue: T, oldValue: T) => void;\n+}\n+\n+export interface Atom<T> {\n+  get: () => T;\n+  set: (value: T) => void;\n+  subscribe: Subscribable<T>['subscribe'];\n+  reset: () => void;\n+}\n+\n+export function subscribable<T>(): Subscribable<T> {\n+  let subscribers = [];\n+  return {\n+    subscribe: fn => {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MTY0OA=="}, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0NTQyNQ==", "bodyText": "added typing", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440245425", "createdAt": "2020-06-15T15:08:02Z", "author": {"login": "petesantos"}, "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,43 @@\n+import * as fp from 'lodash/fp';\n+\n+export interface Subscribable<T> {\n+  subscribe: (Function) => { unsubscribe: () => void};\n+  next: (newValue: T, oldValue: T) => void;\n+}\n+\n+export interface Atom<T> {\n+  get: () => T;\n+  set: (value: T) => void;\n+  subscribe: Subscribable<T>['subscribe'];\n+  reset: () => void;\n+}\n+\n+export function subscribable<T>(): Subscribable<T> {\n+  let subscribers = [];\n+  return {\n+    subscribe: fn => {\n+      subscribers = fp.concat(subscribers, [fn]);\n+      return {\n+        unsubscribe: () => {\n+          subscribers = fp.without([fn], subscribers);\n+        }\n+      };\n+    },\n+    next: (...args) => {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4OTEzNQ=="}, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b0e12427168bb9fdac8000b9505afc8ac44ee63", "author": {"user": {"login": "petesantos", "name": "Pete Santos"}}, "url": "https://github.com/all-of-us/workbench/commit/7b0e12427168bb9fdac8000b9505afc8ac44ee63", "committedDate": "2020-06-15T15:13:23Z", "message": "Addressed feedback from PR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce2d22b08991ee35378e71e3f25c13fe1aa2db10", "author": {"user": {"login": "petesantos", "name": "Pete Santos"}}, "url": "https://github.com/all-of-us/workbench/commit/ce2d22b08991ee35378e71e3f25c13fe1aa2db10", "committedDate": "2020-06-15T16:09:02Z", "message": "Add comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwODQ5MzM3", "url": "https://github.com/all-of-us/workbench/pull/3665#pullrequestreview-430849337", "createdAt": "2020-06-15T17:27:42Z", "commit": {"oid": "ce2d22b08991ee35378e71e3f25c13fe1aa2db10"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzoyNzo0MlrOGj7zLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODowMzoyMVrOGj8_OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzMzEwMA==", "bodyText": "Thanks, that doc link is very helpful. This all makes sense now.\nFWIW, I found some explanation of how it works - seems my guess is close enough: https://reactjs.org/docs/hooks-faq.html#how-does-react-associate-hook-calls-with-components", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440333100", "createdAt": "2020-06-15T17:27:42Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/stores.tsx", "diffHunk": "@@ -0,0 +1,23 @@\n+import {useEffect, useState} from 'react';\n+import {atom, Atom} from './subscribable';\n+\n+interface RouteDataStore {\n+  title?: string;\n+}\n+\n+export const routeDataStore = atom <RouteDataStore>({});\n+\n+export interface AuthStore {\n+  authLoaded: boolean;\n+  isSignedIn: boolean;\n+}\n+\n+export const authStore = atom<AuthStore>({authLoaded: false, isSignedIn: false});\n+\n+export function useStore<T>(theStore: Atom<T>) {\n+  const [value, setValue] = useState(theStore.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTU1Mw=="}, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNDcxMw==", "bodyText": "nice advanced typing", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440334713", "createdAt": "2020-06-15T17:30:33Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,58 @@\n+import * as fp from 'lodash/fp';\n+\n+/**\n+ * @name Subscribable\n+ * @description A container allowing components and functions to subscribe to changes in the container's contents\n+ * @function subscribe Add a subscription by passing a function\n+ * @function subscribe Send the new value to all subscribers\n+ **/\n+export interface Subscribable<T> {\n+  subscribe: (fn: (newValue?: T, oldValue?: T) => void) => { unsubscribe: () => void};\n+  next: (newValue: T, oldValue: T) => void;\n+}\n+\n+/** @name Atom\n+ * @description A container that can store a value to be accessed and subscribed to globally\n+ * @function get Returns the current value\n+ * @function set Sets the value and triggers all subscribed functions with the old/new values\n+ * @function subscribe Add a function to the subscribe list\n+ * @function reset Resets the value to the initial value\n+ */\n+export interface Atom<T> {\n+  get: () => T;\n+  set: (value: T) => void;\n+  subscribe: Subscribable<T>['subscribe'];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce2d22b08991ee35378e71e3f25c13fe1aa2db10"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MjU2OA==", "bodyText": "Thanks, this makes more sense after reading the React Hooks docs through.\nLet me check my understanding:\n\ntheStore in all current use cases is not a prop or state, but this function should treat all incoming parameters as if they might be props\nPresumably the useEffect filter works on non-prop/state values. I'm imagining in this specific case where theStore is not a prop, [theStore] is equivalent to [] ?\nAccordingly, we expect this useEffect() to run once on initial mount, then never run again", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440352568", "createdAt": "2020-06-15T18:03:21Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/stores.tsx", "diffHunk": "@@ -0,0 +1,23 @@\n+import {useEffect, useState} from 'react';\n+import {atom, Atom} from './subscribable';\n+\n+interface RouteDataStore {\n+  title?: string;\n+}\n+\n+export const routeDataStore = atom <RouteDataStore>({});\n+\n+export interface AuthStore {\n+  authLoaded: boolean;\n+  isSignedIn: boolean;\n+}\n+\n+export const authStore = atom<AuthStore>({authLoaded: false, isSignedIn: false});\n+\n+export function useStore<T>(theStore: Atom<T>) {\n+  const [value, setValue] = useState(theStore.get());\n+  useEffect(() => {\n+    return theStore.subscribe(v => setValue(v)).unsubscribe;\n+  }, [theStore, setValue]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjMyNA=="}, "originalCommit": {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwOTY2MjA0", "url": "https://github.com/all-of-us/workbench/pull/3665#pullrequestreview-430966204", "createdAt": "2020-06-15T20:23:56Z", "commit": {"oid": "ce2d22b08991ee35378e71e3f25c13fe1aa2db10"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDoyMzo1NlrOGkBcjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMTowNzozNFrOGkCyoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyNTYxMw==", "bodyText": "nit: make a ticket for this and call it out in this comment.\nhopefully it won't last 12+ months and get culled \ud83d\ude42", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440425613", "createdAt": "2020-06-15T20:23:56Z", "author": {"login": "als364"}, "path": "ui/src/app/components/app-router.tsx", "diffHunk": "@@ -1,26 +1,43 @@\n+import {navigate} from 'app/utils/navigation';\n+import {routeDataStore} from 'app/utils/stores';\n import * as fp from 'lodash/fp';\n import * as React from 'react';\n import { BrowserRouter, Link, Redirect, Route, Switch, useHistory, useLocation, useParams, useRouteMatch} from 'react-router-dom';\n \n const {Fragment} = React;\n \n-interface Guards {\n-  [index: number]: {\n-    checkGuard: () => boolean;\n-    redirectPath: string;\n-  };\n+export interface Guard {\n+  allowed: () => boolean;\n+  redirectPath: string;\n }\n \n export const usePath = () => {\n   const {path} = useRouteMatch();\n   return path;\n };\n \n+export const withTitle = WrappedComponent => ({title, ...props}) => {\n+  routeDataStore.set({title});\n+  return <WrappedComponent {...props}/>;\n+};\n+\n+export const withFullHeight = WrappedComponent => ({...props}) => {\n+  return <div style={{height: '100%'}}><WrappedComponent {...props} /></div>;\n+};\n+\n export const SubRoute = ({children}): React.ReactElement => <Switch>{children}</Switch>;\n export const AppRouter = ({children}): React.ReactElement => <BrowserRouter><SubRoute>{children}</SubRoute></BrowserRouter>;\n \n export const RouteLink = ({path, style = {}, children}): React.ReactElement => <Link style={{...style}} to={path}>{children}</Link>;\n \n+// To compensate for Angular, while keeping true to the declarative/componentized nature of the router\n+// We will utilize a redirect component that uses the Angular navigation.\n+// Upon completing the migration this can be replaced with a react-router Redirect component", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce2d22b08991ee35378e71e3f25c13fe1aa2db10"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0MzExNw==", "bodyText": "I believe this should be @function next", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440443117", "createdAt": "2020-06-15T20:58:34Z", "author": {"login": "als364"}, "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,58 @@\n+import * as fp from 'lodash/fp';\n+\n+/**\n+ * @name Subscribable\n+ * @description A container allowing components and functions to subscribe to changes in the container's contents\n+ * @function subscribe Add a subscription by passing a function\n+ * @function subscribe Send the new value to all subscribers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce2d22b08991ee35378e71e3f25c13fe1aa2db10"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0NzY0OQ==", "bodyText": "I googled this pattern cause I hadn't heard it called 'atom' before. It looks like this is a clojurescript pattern, and that someone ported it to react. Do you think this port is worth using, or can our needs be served by something as simple as what you've implemented here?", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440447649", "createdAt": "2020-06-15T21:07:34Z", "author": {"login": "als364"}, "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,58 @@\n+import * as fp from 'lodash/fp';\n+\n+/**\n+ * @name Subscribable\n+ * @description A container allowing components and functions to subscribe to changes in the container's contents\n+ * @function subscribe Add a subscription by passing a function\n+ * @function subscribe Send the new value to all subscribers\n+ **/\n+export interface Subscribable<T> {\n+  subscribe: (fn: (newValue?: T, oldValue?: T) => void) => { unsubscribe: () => void};\n+  next: (newValue: T, oldValue: T) => void;\n+}\n+\n+/** @name Atom\n+ * @description A container that can store a value to be accessed and subscribed to globally\n+ * @function get Returns the current value\n+ * @function set Sets the value and triggers all subscribed functions with the old/new values\n+ * @function subscribe Add a function to the subscribe list\n+ * @function reset Resets the value to the initial value\n+ */\n+export interface Atom<T> {\n+  get: () => T;\n+  set: (value: T) => void;\n+  subscribe: Subscribable<T>['subscribe'];\n+  reset: () => void;\n+}\n+\n+export function subscribable<T>(): Subscribable<T> {\n+  let subscribers = [];\n+  type subscriber = ((newValue?: T, oldValue?: T) => void);\n+\n+  return {\n+    subscribe: fn => {\n+      subscribers = fp.concat(subscribers, [fn]);\n+      return {\n+        unsubscribe: () => {\n+          subscribers = fp.without([fn], subscribers);\n+        }\n+      };\n+    },\n+    next: (newValue?: T, oldValue?: T) => {\n+      fp.forEach((fn: subscriber) => setTimeout(() => fn(newValue, oldValue), 0), subscribers);\n+    }\n+  };\n+}\n+\n+// A simple state container inspired by clojure atoms.\n+export function atom<T>(initialValue: T): Atom<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce2d22b08991ee35378e71e3f25c13fe1aa2db10"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b32cc98e5d5ca7a597b5fed1ce8daccddd412d34", "author": {"user": {"login": "petesantos", "name": "Pete Santos"}}, "url": "https://github.com/all-of-us/workbench/commit/b32cc98e5d5ca7a597b5fed1ce8daccddd412d34", "committedDate": "2020-06-16T14:04:46Z", "message": "Add subscribe test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8a7377fa351dc7e31a95986c1d225ed13e83313", "author": {"user": {"login": "petesantos", "name": "Pete Santos"}}, "url": "https://github.com/all-of-us/workbench/commit/a8a7377fa351dc7e31a95986c1d225ed13e83313", "committedDate": "2020-06-16T18:32:53Z", "message": "Add atom tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTEyNTUx", "url": "https://github.com/all-of-us/workbench/pull/3665#pullrequestreview-431912551", "createdAt": "2020-06-16T21:41:25Z", "commit": {"oid": "a8a7377fa351dc7e31a95986c1d225ed13e83313"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTo0MToyNVrOGkuLYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTo0MzoxNVrOGkuOkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1ODQ5OQ==", "bodyText": "nit: for the purposes of counting the invocations, I think starting with 0 would be more readable", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r441158499", "createdAt": "2020-06-16T21:41:25Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/subscribable.spec.tsx", "diffHunk": "@@ -0,0 +1,126 @@\n+import { atom } from './subscribable';\n+\n+export const delay = ms => {\n+  return new Promise(resolve => setTimeout(resolve, ms));\n+};\n+\n+const promiseComplete = () => {\n+  let resolveHandler;\n+  const promise = new Promise<void>((resolve) => {\n+    resolveHandler = value => value && resolve();\n+  });\n+  return {promise, resolveHandler};\n+};\n+\n+const makeSubscribeFn = (assertions): [() => Promise<void>, (newValue: any, oldValue: any) => Promise<{}>] => {\n+  const {promise, resolveHandler} = promiseComplete();\n+  const promiseHandler = (): Promise<void> => promise;\n+\n+  const subscribeFn = (newValue, oldValue) => new Promise((resolve) => {\n+    assertions.forEach(assertion => assertion(newValue, oldValue));\n+    resolveHandler(true);\n+    resolve();\n+  });\n+\n+  return [promiseHandler, subscribeFn];\n+};\n+\n+describe('atom', () => {\n+\n+  it('should initialize with a value', () => {\n+    const testAtom = atom({value: 1});\n+    expect(testAtom.get()).toEqual({value: 1});\n+  });\n+\n+  it('should set the value', () => {\n+    const testAtom = atom({value: 1});\n+    testAtom.set({value: 5});\n+    expect(testAtom.get()).toEqual({value: 5});\n+  });\n+\n+  it('should call a single subscribed function', async() => {\n+    const testAtom = atom({value: 1});\n+    const [complete, subscribeFn] = makeSubscribeFn([\n+      newValue => expect(newValue).toEqual({value: 10}),\n+      ({}, oldValue) => expect(oldValue).toEqual({value: 20})\n+    ]);\n+\n+    testAtom.set({value: 20});\n+    testAtom.subscribe(subscribeFn);\n+    testAtom.set({value: 10});\n+\n+    await complete();\n+  });\n+\n+  it('should call a multiple subscribed functions with new and old values', async() => {\n+    const testAtom = atom({value: 1});\n+    const assertions = [\n+      newValue => expect(newValue).toEqual({value: 10}),\n+      ({}, oldValue) => expect(oldValue).toEqual({value: 20})\n+    ];\n+\n+    const [complete1, subscribeFn1] = makeSubscribeFn(assertions);\n+    const [complete2, subscribeFn2] = makeSubscribeFn(assertions);\n+    const [complete3, subscribeFn3] = makeSubscribeFn(assertions);\n+\n+    testAtom.set({value: 20});\n+    testAtom.subscribe(subscribeFn1);\n+    testAtom.subscribe(subscribeFn2);\n+    testAtom.subscribe(subscribeFn3);\n+    testAtom.set({value: 10});\n+\n+    await complete1();\n+    await complete2();\n+    await complete3();\n+  });\n+\n+  it('should not call an unsubscribed function', async() => {\n+    const testAtom = atom({value: 1});\n+    let value = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8a7377fa351dc7e31a95986c1d225ed13e83313"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1OTMxMg==", "bodyText": "optional: one more test case which would be nice is to have one of the subscribers throw an error, and verify the others still succeed", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r441159312", "createdAt": "2020-06-16T21:43:15Z", "author": {"login": "calbach"}, "path": "ui/src/app/utils/subscribable.spec.tsx", "diffHunk": "@@ -0,0 +1,126 @@\n+import { atom } from './subscribable';\n+\n+export const delay = ms => {\n+  return new Promise(resolve => setTimeout(resolve, ms));\n+};\n+\n+const promiseComplete = () => {\n+  let resolveHandler;\n+  const promise = new Promise<void>((resolve) => {\n+    resolveHandler = value => value && resolve();\n+  });\n+  return {promise, resolveHandler};\n+};\n+\n+const makeSubscribeFn = (assertions): [() => Promise<void>, (newValue: any, oldValue: any) => Promise<{}>] => {\n+  const {promise, resolveHandler} = promiseComplete();\n+  const promiseHandler = (): Promise<void> => promise;\n+\n+  const subscribeFn = (newValue, oldValue) => new Promise((resolve) => {\n+    assertions.forEach(assertion => assertion(newValue, oldValue));\n+    resolveHandler(true);\n+    resolve();\n+  });\n+\n+  return [promiseHandler, subscribeFn];\n+};\n+\n+describe('atom', () => {\n+\n+  it('should initialize with a value', () => {\n+    const testAtom = atom({value: 1});\n+    expect(testAtom.get()).toEqual({value: 1});\n+  });\n+\n+  it('should set the value', () => {\n+    const testAtom = atom({value: 1});\n+    testAtom.set({value: 5});\n+    expect(testAtom.get()).toEqual({value: 5});\n+  });\n+\n+  it('should call a single subscribed function', async() => {\n+    const testAtom = atom({value: 1});\n+    const [complete, subscribeFn] = makeSubscribeFn([\n+      newValue => expect(newValue).toEqual({value: 10}),\n+      ({}, oldValue) => expect(oldValue).toEqual({value: 20})\n+    ]);\n+\n+    testAtom.set({value: 20});\n+    testAtom.subscribe(subscribeFn);\n+    testAtom.set({value: 10});\n+\n+    await complete();\n+  });\n+\n+  it('should call a multiple subscribed functions with new and old values', async() => {\n+    const testAtom = atom({value: 1});\n+    const assertions = [\n+      newValue => expect(newValue).toEqual({value: 10}),\n+      ({}, oldValue) => expect(oldValue).toEqual({value: 20})\n+    ];\n+\n+    const [complete1, subscribeFn1] = makeSubscribeFn(assertions);\n+    const [complete2, subscribeFn2] = makeSubscribeFn(assertions);\n+    const [complete3, subscribeFn3] = makeSubscribeFn(assertions);\n+\n+    testAtom.set({value: 20});\n+    testAtom.subscribe(subscribeFn1);\n+    testAtom.subscribe(subscribeFn2);\n+    testAtom.subscribe(subscribeFn3);\n+    testAtom.set({value: 10});\n+\n+    await complete1();\n+    await complete2();\n+    await complete3();\n+  });\n+\n+  it('should not call an unsubscribed function', async() => {\n+    const testAtom = atom({value: 1});\n+    let value = 1;\n+    const subscriber = [() => value += 1];\n+\n+    const [complete1, subscribeFn1] = makeSubscribeFn(subscriber);\n+    const [, subscribeFn2] = makeSubscribeFn(subscriber);\n+    const [complete3, subscribeFn3] = makeSubscribeFn(subscriber);\n+\n+    testAtom.set({value: 20});\n+    testAtom.subscribe(subscribeFn1);\n+\n+    const sub2 = testAtom.subscribe(subscribeFn2);\n+    sub2.unsubscribe();\n+\n+    testAtom.subscribe(subscribeFn3);\n+    testAtom.set({value: 10});\n+\n+    await complete1();\n+    await complete3();\n+    await delay(50);\n+\n+    expect(value).toBe(3);\n+  });\n+\n+  it('should not call any functions when all have unsubscribed', async() => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8a7377fa351dc7e31a95986c1d225ed13e83313"}, "originalPosition": 102}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03684490eb9b667f28793dc16582d0784a1a8148", "author": {"user": {"login": "petesantos", "name": "Pete Santos"}}, "url": "https://github.com/all-of-us/workbench/commit/03684490eb9b667f28793dc16582d0784a1a8148", "committedDate": "2020-06-17T14:53:33Z", "message": "Add error handling and associated test"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4867, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}