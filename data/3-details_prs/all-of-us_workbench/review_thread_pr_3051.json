{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4MjczODQx", "number": 3051, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzowMjowM1rODbZvIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNTozNToxNlrODb9YPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDU5ODExOnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzowMjowM1rOFi3opg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjozMzowN1rOFjPLLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNzQzMA==", "bodyText": "Please add an inbound link from the top level README (one directory above api). Actually, this could be merged with (or replace) some of the preamble material there.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372107430", "createdAt": "2020-01-28T23:02:03Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2MDY4Mw==", "bodyText": "I will add the inbound link but I'd rather not merge the documents. The top-level README is heavily focused on how to run the application and I don't want to make it about two things.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372460683", "createdAt": "2020-01-29T15:41:59Z", "author": {"login": "als364"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNzQzMA=="}, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5MzEwMw==", "bodyText": "That's fair. I might rename this new one to something like BACKEND_OVERVIEW.md or something. (There are structures everywhere.)\nThat one is a train wreck. I have a couple of tickets stashed away on reorganizing it and breaking it into useful sub-docs.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372493103", "createdAt": "2020-01-29T16:33:07Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNzQzMA=="}, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDYwMDg5OnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzowMzoxOFrOFi3qXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNTo0NDoyNVrOFjNScg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNzg2OA==", "bodyText": "You're getting into the weeds a bit here. Maybe breaking out a separate doc on spring data will help.\nLinks to usage in the code (though fragile) could help too. Might be better to put snippets of canonical usage here.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372107868", "createdAt": "2020-01-28T23:03:18Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2MjE5NA==", "bodyText": "Yeah, I'm now thing I will get rid of everything but the first sentence in the paragraph and provide links to both documentation of the annotations and examples of models that use said annotations.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372462194", "createdAt": "2020-01-29T15:44:25Z", "author": {"login": "als364"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNzg2OA=="}, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDYwMjUwOnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzowNDowMlrOFi3rTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNTo0Mzo0MFrOFjNQow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwODEwOQ==", "bodyText": "I'd probably say \"The primary application database is...\" so as not to hurt BigQuery's feelings.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372108109", "createdAt": "2020-01-28T23:04:02Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2MTczMQ==", "bodyText": "BigQuery isn't going to tattle to my teacher.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372461731", "createdAt": "2020-01-29T15:43:40Z", "author": {"login": "als364"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwODEwOQ=="}, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDYxNDQ1OnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzowOToyMVrOFi3yjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzowOToyMVrOFi3yjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwOTk2NA==", "bodyText": "It's 75% philosophy, 25% requirement. Basically, a Java class can implement any number of Spring beans for one or more services, and a given Spring bean can have any number of implementations.\nDeclaring a @Service directly on the implementation class is stepping on both of those degrees of freedom. A dependent service shouldn't need to know (or have any way to detect) the implementation class chosen.\nI actually got bit by this in the case of the UserService/UserServiceImpl pair. Before the latter was created, there was no (direct) way for implementation context to be reused to support \"sidecar services\" like the GaugeDataCollector bean.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372109964", "createdAt": "2020-01-28T23:09:21Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDYxODA5OnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzoxMDo1OVrOFi30uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzoxMDo1OVrOFi30uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMDUyMw==", "bodyText": "and should not contain any actual logic\n\ud83d\udcaf\n\n\nmunging data provided by the API or a Service\nI'd say \"packaging results into a ResponseEntity\" and possibly something about translating errors (occasionally).", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372110523", "createdAt": "2020-01-28T23:10:59Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDYxODYzOnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzoxMToxNlrOFi31Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzoxMToxNlrOFi31Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMDYxMA==", "bodyText": "I'd mention/link to MapStruct specifically.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372110610", "createdAt": "2020-01-28T23:11:16Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.\n+\n+### Mappers\n+\n+There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility classes that own methods that convert between these types of models.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDYxOTc0OnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzoxMTo0OFrOFi31uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjozNToyOVrOFjPROg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMDc3Ng==", "bodyText": "Might want to mention swagger-codegen, which is technically a separate project.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372110776", "createdAt": "2020-01-28T23:11:48Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.\n+\n+### Mappers\n+\n+There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility classes that own methods that convert between these types of models.\n+\n+## API\n+\n+The actual REST API is defined in a series of YAML files according to the [Swagger OpenAPI spec](https://swagger.io/specification/). Swagger takes these YAML files, merges them, and generates all the classes defined by the YAMLs. The command to do so is `./project.rb compile-generated-java`.\n+\n+One non-Swagger-standard thing about these YAML files is that the `tag` param is used to indicate which Controller / APIController an endpoint should be associated with.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4NTMxNQ==", "bodyText": "I don't actually have a good sense of what parts of our API generation are swagger and which are swagger-codegen.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372485315", "createdAt": "2020-01-29T16:21:07Z", "author": {"login": "als364"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.\n+\n+### Mappers\n+\n+There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility classes that own methods that convert between these types of models.\n+\n+## API\n+\n+The actual REST API is defined in a series of YAML files according to the [Swagger OpenAPI spec](https://swagger.io/specification/). Swagger takes these YAML files, merges them, and generates all the classes defined by the YAMLs. The command to do so is `./project.rb compile-generated-java`.\n+\n+One non-Swagger-standard thing about these YAML files is that the `tag` param is used to indicate which Controller / APIController an endpoint should be associated with.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMDc3Ng=="}, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5NDY1MA==", "bodyText": "Swagger (now OpenAPI) is the standard governing how we describe REST APIs in YAML or JSON. Swagger-codegen is a less-standard set of tools around building code from a specification in Swagger.\nThe bit where we use a tag to name the controller is a hack somewhere in Swagger-codegen. (There are many output languages and frameworks from what I understand; ours is specifically Java/Spring)", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372494650", "createdAt": "2020-01-29T16:35:29Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.\n+\n+### Mappers\n+\n+There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility classes that own methods that convert between these types of models.\n+\n+## API\n+\n+The actual REST API is defined in a series of YAML files according to the [Swagger OpenAPI spec](https://swagger.io/specification/). Swagger takes these YAML files, merges them, and generates all the classes defined by the YAMLs. The command to do so is `./project.rb compile-generated-java`.\n+\n+One non-Swagger-standard thing about these YAML files is that the `tag` param is used to indicate which Controller / APIController an endpoint should be associated with.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMDc3Ng=="}, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDYyNDY2OnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzoxNDowMFrOFi34ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjozNjo1MFrOFjPUcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMTUyMw==", "bodyText": "The major advantage of separating these is allowing a more layered architecture and stricter separation of business logic from database details. Granted, Spring is already giving us some abstraction.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372111523", "createdAt": "2020-01-28T23:14:00Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.\n+\n+### Mappers\n+\n+There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility classes that own methods that convert between these types of models.\n+\n+## API\n+\n+The actual REST API is defined in a series of YAML files according to the [Swagger OpenAPI spec](https://swagger.io/specification/). Swagger takes these YAML files, merges them, and generates all the classes defined by the YAMLs. The command to do so is `./project.rb compile-generated-java`.\n+\n+One non-Swagger-standard thing about these YAML files is that the `tag` param is used to indicate which Controller / APIController an endpoint should be associated with.\n+\n+Each REST endpoint is defined under `PATHS` in the YAML file.\n+\n+### API Models\n+\n+API models are defined under `DEFINITIONS` in the YAML file. Swagger autogenerates classes from these. Both API models and DB models are currently used in the Controller and Service layer. There is not currently consensus on whether the standard should switch to only using one or the other.\n+\n+TODO: is the latter sentence true?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4NjA3NA==", "bodyText": "I understand this. I'm just asking whether we as a team actually agree on what types of models we should be using where. We certainly haven't prioritized conforming to any particular standard.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372486074", "createdAt": "2020-01-29T16:22:09Z", "author": {"login": "als364"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.\n+\n+### Mappers\n+\n+There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility classes that own methods that convert between these types of models.\n+\n+## API\n+\n+The actual REST API is defined in a series of YAML files according to the [Swagger OpenAPI spec](https://swagger.io/specification/). Swagger takes these YAML files, merges them, and generates all the classes defined by the YAMLs. The command to do so is `./project.rb compile-generated-java`.\n+\n+One non-Swagger-standard thing about these YAML files is that the `tag` param is used to indicate which Controller / APIController an endpoint should be associated with.\n+\n+Each REST endpoint is defined under `PATHS` in the YAML file.\n+\n+### API Models\n+\n+API models are defined under `DEFINITIONS` in the YAML file. Swagger autogenerates classes from these. Both API models and DB models are currently used in the Controller and Service layer. There is not currently consensus on whether the standard should switch to only using one or the other.\n+\n+TODO: is the latter sentence true?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMTUyMw=="}, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5NTQ3Mw==", "bodyText": "There's a lot of value in what you're doing, i.e. to describe in some systematic way the general understanding of how things work today. It makes it possible to lay out a workable plan for improving things.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372495473", "createdAt": "2020-01-29T16:36:50Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.\n+\n+### Mappers\n+\n+There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility classes that own methods that convert between these types of models.\n+\n+## API\n+\n+The actual REST API is defined in a series of YAML files according to the [Swagger OpenAPI spec](https://swagger.io/specification/). Swagger takes these YAML files, merges them, and generates all the classes defined by the YAMLs. The command to do so is `./project.rb compile-generated-java`.\n+\n+One non-Swagger-standard thing about these YAML files is that the `tag` param is used to indicate which Controller / APIController an endpoint should be associated with.\n+\n+Each REST endpoint is defined under `PATHS` in the YAML file.\n+\n+### API Models\n+\n+API models are defined under `DEFINITIONS` in the YAML file. Swagger autogenerates classes from these. Both API models and DB models are currently used in the Controller and Service layer. There is not currently consensus on whether the standard should switch to only using one or the other.\n+\n+TODO: is the latter sentence true?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMTUyMw=="}, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDYyNzQ4OnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzoxNToyM1rOFi36aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjozNzozOVrOFjPWXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMTk3Nw==", "bodyText": "The missing bit here is a business-logic-level class. I think a major answer here will be Immutables.org objects, which let you define ad hoc value objects with builders that aren't subject to mutation.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372111977", "createdAt": "2020-01-28T23:15:23Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.\n+\n+### Mappers\n+\n+There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility classes that own methods that convert between these types of models.\n+\n+## API\n+\n+The actual REST API is defined in a series of YAML files according to the [Swagger OpenAPI spec](https://swagger.io/specification/). Swagger takes these YAML files, merges them, and generates all the classes defined by the YAMLs. The command to do so is `./project.rb compile-generated-java`.\n+\n+One non-Swagger-standard thing about these YAML files is that the `tag` param is used to indicate which Controller / APIController an endpoint should be associated with.\n+\n+Each REST endpoint is defined under `PATHS` in the YAML file.\n+\n+### API Models\n+\n+API models are defined under `DEFINITIONS` in the YAML file. Swagger autogenerates classes from these. Both API models and DB models are currently used in the Controller and Service layer. There is not currently consensus on whether the standard should switch to only using one or the other.\n+\n+TODO: is the latter sentence true?\n+\n+### Requests and Responses\n+\n+Swagger interprets the data sent to a given endpoint according to the Request model definition associated with that endpoint and throws an error if the data is improperly formatted. Likewise, Swagger validates that the data being returned from a given endpoint conforms to the Response model definition associated with that endpoint and throws an error if it does not.\n+\n+Technically, Requests and Responses are just more API model classes, similarly autogenerated by Swagger, but they are only used when communicating directly with the API layer. API models that represent business logic concepts are more freely used throughout the system.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4NjQzNA==", "bodyText": "This document is about the current state of the system.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372486434", "createdAt": "2020-01-29T16:22:49Z", "author": {"login": "als364"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.\n+\n+### Mappers\n+\n+There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility classes that own methods that convert between these types of models.\n+\n+## API\n+\n+The actual REST API is defined in a series of YAML files according to the [Swagger OpenAPI spec](https://swagger.io/specification/). Swagger takes these YAML files, merges them, and generates all the classes defined by the YAMLs. The command to do so is `./project.rb compile-generated-java`.\n+\n+One non-Swagger-standard thing about these YAML files is that the `tag` param is used to indicate which Controller / APIController an endpoint should be associated with.\n+\n+Each REST endpoint is defined under `PATHS` in the YAML file.\n+\n+### API Models\n+\n+API models are defined under `DEFINITIONS` in the YAML file. Swagger autogenerates classes from these. Both API models and DB models are currently used in the Controller and Service layer. There is not currently consensus on whether the standard should switch to only using one or the other.\n+\n+TODO: is the latter sentence true?\n+\n+### Requests and Responses\n+\n+Swagger interprets the data sent to a given endpoint according to the Request model definition associated with that endpoint and throws an error if the data is improperly formatted. Likewise, Swagger validates that the data being returned from a given endpoint conforms to the Response model definition associated with that endpoint and throws an error if it does not.\n+\n+Technically, Requests and Responses are just more API model classes, similarly autogenerated by Swagger, but they are only used when communicating directly with the API layer. API models that represent business logic concepts are more freely used throughout the system.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMTk3Nw=="}, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5NTk2Ng==", "bodyText": "\ud83e\udd37\u200d\u2642 I'm not sure I'd get into it then. It's kind of a detour.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372495966", "createdAt": "2020-01-29T16:37:39Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.\n+\n+### Mappers\n+\n+There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility classes that own methods that convert between these types of models.\n+\n+## API\n+\n+The actual REST API is defined in a series of YAML files according to the [Swagger OpenAPI spec](https://swagger.io/specification/). Swagger takes these YAML files, merges them, and generates all the classes defined by the YAMLs. The command to do so is `./project.rb compile-generated-java`.\n+\n+One non-Swagger-standard thing about these YAML files is that the `tag` param is used to indicate which Controller / APIController an endpoint should be associated with.\n+\n+Each REST endpoint is defined under `PATHS` in the YAML file.\n+\n+### API Models\n+\n+API models are defined under `DEFINITIONS` in the YAML file. Swagger autogenerates classes from these. Both API models and DB models are currently used in the Controller and Service layer. There is not currently consensus on whether the standard should switch to only using one or the other.\n+\n+TODO: is the latter sentence true?\n+\n+### Requests and Responses\n+\n+Swagger interprets the data sent to a given endpoint according to the Request model definition associated with that endpoint and throws an error if the data is improperly formatted. Likewise, Swagger validates that the data being returned from a given endpoint conforms to the Response model definition associated with that endpoint and throws an error if it does not.\n+\n+Technically, Requests and Responses are just more API model classes, similarly autogenerated by Swagger, but they are only used when communicating directly with the API layer. API models that represent business logic concepts are more freely used throughout the system.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMTk3Nw=="}, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDYyODg3OnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzoxNTo1N1rOFi37Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjozODozMFrOFjPYgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMjE4Ng==", "bodyText": "I don't know if i'd even go into this here. It's a bit of an implementation detail that you don't need to worry about. Worth discussing in a spring-speicfic document.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372112186", "createdAt": "2020-01-28T23:15:57Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.\n+\n+### Mappers\n+\n+There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility classes that own methods that convert between these types of models.\n+\n+## API\n+\n+The actual REST API is defined in a series of YAML files according to the [Swagger OpenAPI spec](https://swagger.io/specification/). Swagger takes these YAML files, merges them, and generates all the classes defined by the YAMLs. The command to do so is `./project.rb compile-generated-java`.\n+\n+One non-Swagger-standard thing about these YAML files is that the `tag` param is used to indicate which Controller / APIController an endpoint should be associated with.\n+\n+Each REST endpoint is defined under `PATHS` in the YAML file.\n+\n+### API Models\n+\n+API models are defined under `DEFINITIONS` in the YAML file. Swagger autogenerates classes from these. Both API models and DB models are currently used in the Controller and Service layer. There is not currently consensus on whether the standard should switch to only using one or the other.\n+\n+TODO: is the latter sentence true?\n+\n+### Requests and Responses\n+\n+Swagger interprets the data sent to a given endpoint according to the Request model definition associated with that endpoint and throws an error if the data is improperly formatted. Likewise, Swagger validates that the data being returned from a given endpoint conforms to the Response model definition associated with that endpoint and throws an error if it does not.\n+\n+Technically, Requests and Responses are just more API model classes, similarly autogenerated by Swagger, but they are only used when communicating directly with the API layer. API models that represent business logic concepts are more freely used throughout the system.\n+\n+### APIControllers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4NjkzMQ==", "bodyText": "This comment is here so that people understand what these random classes are that their Controllers talk to and inherit from. I should expand this section.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372486931", "createdAt": "2020-01-29T16:23:33Z", "author": {"login": "als364"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.\n+\n+### Mappers\n+\n+There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility classes that own methods that convert between these types of models.\n+\n+## API\n+\n+The actual REST API is defined in a series of YAML files according to the [Swagger OpenAPI spec](https://swagger.io/specification/). Swagger takes these YAML files, merges them, and generates all the classes defined by the YAMLs. The command to do so is `./project.rb compile-generated-java`.\n+\n+One non-Swagger-standard thing about these YAML files is that the `tag` param is used to indicate which Controller / APIController an endpoint should be associated with.\n+\n+Each REST endpoint is defined under `PATHS` in the YAML file.\n+\n+### API Models\n+\n+API models are defined under `DEFINITIONS` in the YAML file. Swagger autogenerates classes from these. Both API models and DB models are currently used in the Controller and Service layer. There is not currently consensus on whether the standard should switch to only using one or the other.\n+\n+TODO: is the latter sentence true?\n+\n+### Requests and Responses\n+\n+Swagger interprets the data sent to a given endpoint according to the Request model definition associated with that endpoint and throws an error if the data is improperly formatted. Likewise, Swagger validates that the data being returned from a given endpoint conforms to the Response model definition associated with that endpoint and throws an error if it does not.\n+\n+Technically, Requests and Responses are just more API model classes, similarly autogenerated by Swagger, but they are only used when communicating directly with the API layer. API models that represent business logic concepts are more freely used throughout the system.\n+\n+### APIControllers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMjE4Ng=="}, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5NjUxMg==", "bodyText": "I'd talk about BigQuery before getting into these details. It's just middleware really.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372496512", "createdAt": "2020-01-29T16:38:30Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,83 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` [annotations](https://www.baeldung.com/jpa-join-column). When using these annotations, be sure to carefully consider which table should 'own' the relationship. With a `@ManyToOne` relationship, the `@ManyToOne` side should generally own the relationship. For example. if we have an extender table containing a user's addresses, `DbAddress` should have a `@ManyToOne` `DbUser` member and `DbUser` should have a `@OneToMany` `DbAddress` member, with the annotation containing a `mappedBy` attribute pointing to `DbAddress`'s `DbUser` member as the member defining the relationship.\n+\n+TODO: wording on the above is Bad. pls help\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+TODO: Why do we do this this way?\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`\n+\n+ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.\n+\n+## Controllers\n+\n+Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).\n+\n+Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be munging data provided by the API or a Service.\n+\n+### Mappers\n+\n+There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility classes that own methods that convert between these types of models.\n+\n+## API\n+\n+The actual REST API is defined in a series of YAML files according to the [Swagger OpenAPI spec](https://swagger.io/specification/). Swagger takes these YAML files, merges them, and generates all the classes defined by the YAMLs. The command to do so is `./project.rb compile-generated-java`.\n+\n+One non-Swagger-standard thing about these YAML files is that the `tag` param is used to indicate which Controller / APIController an endpoint should be associated with.\n+\n+Each REST endpoint is defined under `PATHS` in the YAML file.\n+\n+### API Models\n+\n+API models are defined under `DEFINITIONS` in the YAML file. Swagger autogenerates classes from these. Both API models and DB models are currently used in the Controller and Service layer. There is not currently consensus on whether the standard should switch to only using one or the other.\n+\n+TODO: is the latter sentence true?\n+\n+### Requests and Responses\n+\n+Swagger interprets the data sent to a given endpoint according to the Request model definition associated with that endpoint and throws an error if the data is improperly formatted. Likewise, Swagger validates that the data being returned from a given endpoint conforms to the Response model definition associated with that endpoint and throws an error if it does not.\n+\n+Technically, Requests and Responses are just more API model classes, similarly autogenerated by Swagger, but they are only used when communicating directly with the API layer. API models that represent business logic concepts are more freely used throughout the system.\n+\n+### APIControllers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMjE4Ng=="}, "originalCommit": {"oid": "6b9e280ab41bf74579f54736d72d853c51de9e49"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNjEzNDQ1OnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNDoxODoyMFrOFjsfog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNTo1Mzo0MVrOFjwI5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk3MzQ3NA==", "bodyText": "A couple notes / thoughts on file naming. Feel free to ignore (though I think it does help a lot when we get these things right, since it makes it obvious where the next person who comes along should put content):\n\nWe have an existing directory, api/doc/, which contains some similar \"here's how parts of the system work\" Markdown files. It might be cleaner for this file to live over there, so there's one place where all of our backend-related team docs live.\nIn terms of file naming, I think all-caps should probably be reserved for truly standard filenames, e.g. README or INDEX. Structure as a name isn't bad, but I'm not sure it perfectly captures the intent. Spitballing a few other ideas in case any of them jump out to you as an improvement:\n\n\napi/doc/overview.md\napi/doc/index.md (this could eventually become a summary page of sorts, which links out to the more topic-specific docs we already have)\napi/doc/tech-stack.md\napi/doc/getting-started.md", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372973474", "createdAt": "2020-01-30T14:18:20Z", "author": {"login": "gjuggler"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,84 @@\n+# All of Us Workbench API Structure & Technologies", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b9ea275b211aeb14ca985d0500a66b280d8dcc"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAzMDI1MA==", "bodyText": "That directory was not on my radar at all. I agree that it makes sense to put this document there, but I'm a bit concerned that I'd just be round filing it. Maybe I'll point out this directory and this file in both the top level and API level READMEs.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r373030250", "createdAt": "2020-01-30T15:48:56Z", "author": {"login": "als364"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,84 @@\n+# All of Us Workbench API Structure & Technologies", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk3MzQ3NA=="}, "originalCommit": {"oid": "c6b9ea275b211aeb14ca985d0500a66b280d8dcc"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAzMzE5MQ==", "bodyText": "@gjuggler there's a ticket somewhere (or at least in my head) where we break down the main README into other sections and files. We need a navigation convention where everything there is linked from the top and/or intermediate sections, and link back in turn as a courtesy.\nOne annoyance that I think actually stops people from updating that file is that it's not in the api project. So maybe a top-of-the-backend readme makes sense.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r373033191", "createdAt": "2020-01-30T15:53:41Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,84 @@\n+# All of Us Workbench API Structure & Technologies", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk3MzQ3NA=="}, "originalCommit": {"oid": "c6b9ea275b211aeb14ca985d0500a66b280d8dcc"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNjE0NDY1OnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNDoyMTowNlrOFjsl7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNDoyMTowNlrOFjsl7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk3NTA4NQ==", "bodyText": "Not necessarily worth noting in here, but TIL that for our GAE environments, the Liquibase migrations are actually executed using the Liquibase Gradle plugin: \n  \n    \n      workbench/api/db/build.gradle\n    \n    \n         Line 16\n      in\n      331b122\n    \n    \n    \n    \n\n        \n          \n           liquibase {", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372975085", "createdAt": "2020-01-30T14:21:06Z", "author": {"login": "gjuggler"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,84 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The primary application database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b9ea275b211aeb14ca985d0500a66b280d8dcc"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNjE0OTM3OnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNDoyMjowOVrOFjsonw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNDoyMjowOVrOFjsonw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk3NTc3NQ==", "bodyText": "@ericsong  and I had a pretty good discussion about the various options here this week. I'd love if he could follow-up with some recommendations and/or pointers to models & DAOs where we use healthy patterns.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r372975775", "createdAt": "2020-01-30T14:22:09Z", "author": {"login": "gjuggler"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,84 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The primary application database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b9ea275b211aeb14ca985d0500a66b280d8dcc"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNjQzMjIyOnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNTozMzo0MlrOFjvXuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNTozMzo0MlrOFjvXuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAyMDYwMQ==", "bodyText": "These links are very helpful.  Thank you!", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r373020601", "createdAt": "2020-01-30T15:33:42Z", "author": {"login": "jmthibault79"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,84 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The primary application database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` annotations. Documentation and blogs on the usage of these annotations can be found in these links:\n+\n+- https://www.baeldung.com/jpa-join-column", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b9ea275b211aeb14ca985d0500a66b280d8dcc"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNjQzNzcyOnYy", "diffSide": "RIGHT", "path": "api/STRUCTURE.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNTozNToxNlrOFjvbVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNzozMDoxOFrOFjzkdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAyMTUyNg==", "bodyText": "The last sentence looks incomplete.  Also, is this intended as a positive example because it only talks to two DAOs or a negative one because we'd prefer it to talk to only one?", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r373021526", "createdAt": "2020-01-30T15:35:16Z", "author": {"login": "jmthibault79"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,84 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The primary application database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` annotations. Documentation and blogs on the usage of these annotations can be found in these links:\n+\n+- https://www.baeldung.com/jpa-join-column\n+- https://www.baeldung.com/hibernate-one-to-many\n+- https://www.baeldung.com/jpa-joincolumn-vs-mappedby\n+- https://docs.jboss.org/hibernate/jpa/2.1/api/javax/persistence/JoinColumn.html (contains See Also links to the rest of these annotations)\n+\n+Examples of the use of these annotations can be found in the following places:\n+\n+- [DbUser](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbUser.java)\n+- [DbAddress](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbAddress.java)\n+- [DbCohort](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbCohort.java)\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+Practically, this allows one ServiceImpl to implement multiple interfaces. This is used in several `UserServiceImpl` and others to mixin [GaugeDataCollector](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/monitoring/GaugeDataCollector.java), which needs a different implementation per-service.\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b9ea275b211aeb14ca985d0500a66b280d8dcc"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAzOTk2OQ==", "bodyText": "Positive example because everything it talks to is directly related to the purpose of the service. Something massive like WorkspaceServiceImpl should probably 1) get broken up and 2) stop talking to the UserDao directly.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r373039969", "createdAt": "2020-01-30T16:04:39Z", "author": {"login": "als364"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,84 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The primary application database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` annotations. Documentation and blogs on the usage of these annotations can be found in these links:\n+\n+- https://www.baeldung.com/jpa-join-column\n+- https://www.baeldung.com/hibernate-one-to-many\n+- https://www.baeldung.com/jpa-joincolumn-vs-mappedby\n+- https://docs.jboss.org/hibernate/jpa/2.1/api/javax/persistence/JoinColumn.html (contains See Also links to the rest of these annotations)\n+\n+Examples of the use of these annotations can be found in the following places:\n+\n+- [DbUser](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbUser.java)\n+- [DbAddress](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbAddress.java)\n+- [DbCohort](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbCohort.java)\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+Practically, this allows one ServiceImpl to implement multiple interfaces. This is used in several `UserServiceImpl` and others to mixin [GaugeDataCollector](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/monitoring/GaugeDataCollector.java), which needs a different implementation per-service.\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAyMTUyNg=="}, "originalCommit": {"oid": "c6b9ea275b211aeb14ca985d0500a66b280d8dcc"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA0MTYzNA==", "bodyText": "Ideally, each DAO would roll up to only one Service.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r373041634", "createdAt": "2020-01-30T16:07:32Z", "author": {"login": "als364"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,84 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The primary application database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` annotations. Documentation and blogs on the usage of these annotations can be found in these links:\n+\n+- https://www.baeldung.com/jpa-join-column\n+- https://www.baeldung.com/hibernate-one-to-many\n+- https://www.baeldung.com/jpa-joincolumn-vs-mappedby\n+- https://docs.jboss.org/hibernate/jpa/2.1/api/javax/persistence/JoinColumn.html (contains See Also links to the rest of these annotations)\n+\n+Examples of the use of these annotations can be found in the following places:\n+\n+- [DbUser](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbUser.java)\n+- [DbAddress](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbAddress.java)\n+- [DbCohort](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbCohort.java)\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+Practically, this allows one ServiceImpl to implement multiple interfaces. This is used in several `UserServiceImpl` and others to mixin [GaugeDataCollector](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/monitoring/GaugeDataCollector.java), which needs a different implementation per-service.\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAyMTUyNg=="}, "originalCommit": {"oid": "c6b9ea275b211aeb14ca985d0500a66b280d8dcc"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA4OTM5OQ==", "bodyText": "No, you could certainly imagine a service that needs more than one table (dao), or a table that's useful to more than one service. For example, the CohortDao is injected into a couple of services.\nBut yes, it makes lots of sense to break up some of these mega-services, even if they share DAOs.", "url": "https://github.com/all-of-us/workbench/pull/3051#discussion_r373089399", "createdAt": "2020-01-30T17:30:18Z", "author": {"login": "jaycarlton"}, "path": "api/STRUCTURE.md", "diffHunk": "@@ -0,0 +1,84 @@\n+# All of Us Workbench API Structure & Technologies\n+\n+The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.\n+\n+## Database\n+\n+The primary application database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).\n+\n+When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.\n+\n+We generally name database objects in lower_snake_case.\n+\n+Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:\n+\n+- dev-up (starts a local dev server)\n+- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)\n+- run-local-rw-migrations (runs migrations only on the `workbench` schema)\n+\n+## DAOs\n+\n+Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.\n+\n+CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.\n+\n+To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.\n+\n+TODO: do we have a preference of which of those to do?\n+\n+## DB Models\n+\n+DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.\n+\n+In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` annotations. Documentation and blogs on the usage of these annotations can be found in these links:\n+\n+- https://www.baeldung.com/jpa-join-column\n+- https://www.baeldung.com/hibernate-one-to-many\n+- https://www.baeldung.com/jpa-joincolumn-vs-mappedby\n+- https://docs.jboss.org/hibernate/jpa/2.1/api/javax/persistence/JoinColumn.html (contains See Also links to the rest of these annotations)\n+\n+Examples of the use of these annotations can be found in the following places:\n+\n+- [DbUser](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbUser.java)\n+- [DbAddress](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbAddress.java)\n+- [DbCohort](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbCohort.java)\n+\n+Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.\n+\n+## Services and ServiceImpls\n+\n+Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.\n+\n+Practically, this allows one ServiceImpl to implement multiple interfaces. This is used in several `UserServiceImpl` and others to mixin [GaugeDataCollector](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/monitoring/GaugeDataCollector.java), which needs a different implementation per-service.\n+\n+Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.\n+\n+ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAyMTUyNg=="}, "originalCommit": {"oid": "c6b9ea275b211aeb14ca985d0500a66b280d8dcc"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3520, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}