{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1NDM5MzEw", "number": 212, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxMDoyNFrOEu54kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTo1OTo0NFrOEu6fsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjE4MzIxOnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.common/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/common/RemoteFetchConfigurationConstants.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxMDoyNFrOHjkI6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxMDoyNFrOHjkI6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NDMxMw==", "bodyText": "Remove this line", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507054313", "createdAt": "2020-10-18T09:10:24Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.common/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/common/RemoteFetchConfigurationConstants.java", "diffHunk": "@@ -0,0 +1,123 @@\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1fb2dd934e5919e7461ee1a9845960ab21188a8"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjE4Mzc0OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.common/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/common/RemoteFetchConfigurationConstants.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxMDo0M1rOHjkJOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxMDo0M1rOHjkJOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NDM5NQ==", "bodyText": "Remove this line", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507054395", "createdAt": "2020-10-18T09:10:43Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.common/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/common/RemoteFetchConfigurationConstants.java", "diffHunk": "@@ -0,0 +1,123 @@\n+\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.identity.api.server.fetch.remote.common;\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1fb2dd934e5919e7461ee1a9845960ab21188a8"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjE4NDM5OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.common/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/common/RemoteFetchConfigurationConstants.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxMTowOVrOHjkJpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxMTowOVrOHjkJpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NDUwMw==", "bodyText": "Remove this line", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507054503", "createdAt": "2020-10-18T09:11:09Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.common/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/common/RemoteFetchConfigurationConstants.java", "diffHunk": "@@ -0,0 +1,123 @@\n+\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.identity.api.server.fetch.remote.common;\n+\n+\n+/**\n+ * Remote Fetch Configuration constant class.\n+ */\n+public class RemoteFetchConfigurationConstants {\n+\n+    public static final String REMOTE_FETCH_CONFIGURATION_MANAGEMENT_PREFIX = \"RFE-\";\n+    public static final String ERROR_CODE_DELIMITER = \"-\";\n+    public static final String FREQUENCY = \"frequency\";\n+    public static final String URI = \"uri\";\n+    public static final String BRANCH = \"branch\";\n+    public static final String DIRECTORY = \"directory\";\n+    public static final String ACCESS_TOKEN = \"accessToken\";\n+    public static final String USER_NAME = \"userName\";\n+    public static final String IS_ENABLED = \"isEnabled\";\n+    public static final String REMOTE_FETCH_NAME = \"remoteFetchName\";\n+    public static final String ACTION_LISTENER = \"actionListener\";\n+    public static final String ACTION_LISTENER_ATTRIBUTES = \"actionListenerAttributes\";\n+    public static final String REPOSITORY_MANAGER = \"repositoryManger\";\n+    public static final String REPOSITORY_MANAGER_ATTRIBUTES = \"repositoryMangerAttributes\";\n+    public static final String CONFIGURATION_DEPLOYER = \"configDeployer\";\n+    public static final String CONFIGURATION_DEPLOYER_ATTRIBUTES = \"configDeployerAttributes\";\n+    public static final String WEBHOOK_REQUEST = \"webHookRequest\";\n+\n+    public static final String SUCCESS = \"SUCCESS\";\n+    public static final String FAIL = \"FAIL\";\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1fb2dd934e5919e7461ee1a9845960ab21188a8"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjE4NDY2OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.common/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/common/RemoteFetchConfigurationConstants.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxMToxNVrOHjkJ2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxMToxNVrOHjkJ2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NDU1Mw==", "bodyText": "Remove this line", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507054553", "createdAt": "2020-10-18T09:11:15Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.common/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/common/RemoteFetchConfigurationConstants.java", "diffHunk": "@@ -0,0 +1,123 @@\n+\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.identity.api.server.fetch.remote.common;\n+\n+\n+/**\n+ * Remote Fetch Configuration constant class.\n+ */\n+public class RemoteFetchConfigurationConstants {\n+\n+    public static final String REMOTE_FETCH_CONFIGURATION_MANAGEMENT_PREFIX = \"RFE-\";\n+    public static final String ERROR_CODE_DELIMITER = \"-\";\n+    public static final String FREQUENCY = \"frequency\";\n+    public static final String URI = \"uri\";\n+    public static final String BRANCH = \"branch\";\n+    public static final String DIRECTORY = \"directory\";\n+    public static final String ACCESS_TOKEN = \"accessToken\";\n+    public static final String USER_NAME = \"userName\";\n+    public static final String IS_ENABLED = \"isEnabled\";\n+    public static final String REMOTE_FETCH_NAME = \"remoteFetchName\";\n+    public static final String ACTION_LISTENER = \"actionListener\";\n+    public static final String ACTION_LISTENER_ATTRIBUTES = \"actionListenerAttributes\";\n+    public static final String REPOSITORY_MANAGER = \"repositoryManger\";\n+    public static final String REPOSITORY_MANAGER_ATTRIBUTES = \"repositoryMangerAttributes\";\n+    public static final String CONFIGURATION_DEPLOYER = \"configDeployer\";\n+    public static final String CONFIGURATION_DEPLOYER_ATTRIBUTES = \"configDeployerAttributes\";\n+    public static final String WEBHOOK_REQUEST = \"webHookRequest\";\n+\n+    public static final String SUCCESS = \"SUCCESS\";\n+    public static final String FAIL = \"FAIL\";\n+\n+\n+    public static final String REMOTE_FETCH_CONFIGURATION_PATH_COMPONENT = \"/remote-fetch\";\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1fb2dd934e5919e7461ee1a9845960ab21188a8"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjE4OTYzOnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/gen/java/org/wso2/carbon/identity/api/server/fetch/remote/v1/factories/RemoteFetchApiServiceFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxMzo1OVrOHjkNQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTo1NjowOFrOHjlEtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NTQyNw==", "bodyText": "Incorrect formatting", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507055427", "createdAt": "2020-10-18T09:13:59Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/gen/java/org/wso2/carbon/identity/api/server/fetch/remote/v1/factories/RemoteFetchApiServiceFactory.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+* Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+*\n+* Licensed under the Apache License, Version 2.0 (the \"License\");\n+* you may not use this file except in compliance with the License.\n+* You may obtain a copy of the License at\n+*\n+* http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.wso2.carbon.identity.api.server.fetch.remote.v1.factories;\n+\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.RemoteFetchApiService;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.impl.RemoteFetchApiServiceImpl;\n+\n+public class RemoteFetchApiServiceFactory {\n+\n+   private final static RemoteFetchApiService service = new RemoteFetchApiServiceImpl();\n+\n+   public static RemoteFetchApiService getRemoteFetchApi()\n+   {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1fb2dd934e5919e7461ee1a9845960ab21188a8"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA2NzQwMQ==", "bodyText": "This shouldn't be changed as this is a generated class..", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507067401", "createdAt": "2020-10-18T09:51:03Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/gen/java/org/wso2/carbon/identity/api/server/fetch/remote/v1/factories/RemoteFetchApiServiceFactory.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+* Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+*\n+* Licensed under the Apache License, Version 2.0 (the \"License\");\n+* you may not use this file except in compliance with the License.\n+* You may obtain a copy of the License at\n+*\n+* http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.wso2.carbon.identity.api.server.fetch.remote.v1.factories;\n+\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.RemoteFetchApiService;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.impl.RemoteFetchApiServiceImpl;\n+\n+public class RemoteFetchApiServiceFactory {\n+\n+   private final static RemoteFetchApiService service = new RemoteFetchApiServiceImpl();\n+\n+   public static RemoteFetchApiService getRemoteFetchApi()\n+   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NTQyNw=="}, "originalCommit": {"oid": "c1fb2dd934e5919e7461ee1a9845960ab21188a8"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA2OTYyMw==", "bodyText": "Reverted", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507069623", "createdAt": "2020-10-18T09:56:08Z", "author": {"login": "Thumimku"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/gen/java/org/wso2/carbon/identity/api/server/fetch/remote/v1/factories/RemoteFetchApiServiceFactory.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+* Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+*\n+* Licensed under the Apache License, Version 2.0 (the \"License\");\n+* you may not use this file except in compliance with the License.\n+* You may obtain a copy of the License at\n+*\n+* http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.wso2.carbon.identity.api.server.fetch.remote.v1.factories;\n+\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.RemoteFetchApiService;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.impl.RemoteFetchApiServiceImpl;\n+\n+public class RemoteFetchApiServiceFactory {\n+\n+   private final static RemoteFetchApiService service = new RemoteFetchApiServiceImpl();\n+\n+   public static RemoteFetchApiService getRemoteFetchApi()\n+   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NTQyNw=="}, "originalCommit": {"oid": "c1fb2dd934e5919e7461ee1a9845960ab21188a8"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjE5MDAyOnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.common/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/common/factory/RemoteFetchConfigurationServiceFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxNDoxNFrOHjkNjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxNDoxNFrOHjkNjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NTUwMA==", "bodyText": "Remove this line.", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507055500", "createdAt": "2020-10-18T09:14:14Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.common/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/common/factory/RemoteFetchConfigurationServiceFactory.java", "diffHunk": "@@ -0,0 +1,56 @@\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1fb2dd934e5919e7461ee1a9845960ab21188a8"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjE5MDIzOnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.common/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/common/RemoteFetchServiceHolder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxNDoxOFrOHjkNrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxNDoxOFrOHjkNrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NTUzMw==", "bodyText": "Remove this line.", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507055533", "createdAt": "2020-10-18T09:14:18Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.common/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/common/RemoteFetchServiceHolder.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.identity.api.server.fetch.remote.common;\n+\n+import org.wso2.carbon.identity.remotefetch.common.RemoteFetchConfigurationService;\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1fb2dd934e5919e7461ee1a9845960ab21188a8"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjIwNDYzOnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/v1/core/ServerRemoteFetchConfigManagementService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToyMTo0N1rOHjkWyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTo1ODoxMFrOHjlIDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1Nzg2Ng==", "bodyText": "This can fit into one line.", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507057866", "createdAt": "2020-10-18T09:21:47Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/v1/core/ServerRemoteFetchConfigManagementService.java", "diffHunk": "@@ -0,0 +1,814 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.identity.api.server.fetch.remote.v1.core;\n+\n+import org.apache.commons.beanutils.BeanUtils;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.identity.api.server.common.ContextLoader;\n+import org.wso2.carbon.identity.api.server.common.error.APIError;\n+import org.wso2.carbon.identity.api.server.common.error.ErrorResponse;\n+import org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants;\n+import org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchServiceHolder;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.ActionListenerAttributes;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.PushEventWebHookPOSTRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.PushEventWebHookPOSTRequestCommits;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationGetResponse;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationListItem;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationListResponse;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationPOSTRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationPatchRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RepositoryManagerAttributes;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.StatusListItem;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.StatusListResponse;\n+import org.wso2.carbon.identity.core.util.IdentityTenantUtil;\n+import org.wso2.carbon.identity.remotefetch.common.BasicRemoteFetchConfiguration;\n+import org.wso2.carbon.identity.remotefetch.common.DeploymentRevision;\n+import org.wso2.carbon.identity.remotefetch.common.RemoteFetchConfiguration;\n+import org.wso2.carbon.identity.remotefetch.common.exceptions.RemoteFetchClientException;\n+import org.wso2.carbon.identity.remotefetch.common.exceptions.RemoteFetchCoreException;\n+import org.wso2.carbon.identity.remotefetch.common.exceptions.RemoteFetchServerException;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.OptionalInt;\n+\n+import javax.ws.rs.core.Response;\n+\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.ACTION_LISTENER;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.ACTION_LISTENER_ATTRIBUTES;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.BRANCH;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.CONFIGURATION_DEPLOYER;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.CONFIGURATION_DEPLOYER_ATTRIBUTES;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.DIRECTORY;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.FREQUENCY;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.IS_ENABLED;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.REMOTE_FETCH_NAME;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.REPOSITORY_MANAGER;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.REPOSITORY_MANAGER_ATTRIBUTES;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.URI;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.WEBHOOK_REQUEST;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.v1.core.RemoteFetchUtils.convertDateToStringIfNotNull;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.v1.core.RemoteFetchUtils.setIfNotNull;\n+\n+/**\n+ * Call internal osgi services to perform server remote fetch configuration related operations.\n+ */\n+public class ServerRemoteFetchConfigManagementService {\n+\n+    private static final Log log = LogFactory.getLog(ServerRemoteFetchConfigManagementService.class);\n+\n+    /**\n+     * Get list of remote fetch configurations.\n+     *\n+     * @return RemoteFetchConfigurationListResponse.\n+     */\n+    public RemoteFetchConfigurationListResponse getRemoteFetchConfigs() {\n+\n+        OptionalInt optionalIntLimit = OptionalInt.empty();\n+        OptionalInt optionalIntOffset = OptionalInt.empty();\n+\n+        try {\n+            return createRemoteFetchConfigurationListResponse(RemoteFetchServiceHolder.\n+                    getRemoteFetchConfigurationService()\n+                    .getBasicRemoteFetchConfigurationList(optionalIntLimit, optionalIntOffset));\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_ERROR_LISTING_RF_CONFIGS, null);\n+        }\n+    }\n+\n+    /**\n+     * Delete an Remote fetch configuration.\n+     *\n+     * @param remoteFetchConfigurationId Identity Provider resource ID.\n+     */\n+    public void deleteRemoteFetchConfig(String remoteFetchConfigurationId) {\n+\n+        try {\n+            RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                    .deleteRemoteFetchConfiguration(remoteFetchConfigurationId);\n+\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_ERROR_DELETING_RF_CONFIGS, remoteFetchConfigurationId);\n+        }\n+    }\n+\n+    /**\n+     * Get remote fetch configuration by resource Id.\n+     *\n+     * @param remoteFetchConfigurationId resource Id.\n+     * @return RemoteFetchConfigurationListResponse.\n+     */\n+    public RemoteFetchConfigurationGetResponse getRemoteFetchConfig(String remoteFetchConfigurationId) {\n+\n+        try {\n+            RemoteFetchConfiguration remoteFetchConfiguration =\n+                    RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                            .getRemoteFetchConfiguration(remoteFetchConfigurationId);\n+\n+            if (remoteFetchConfiguration == null) {\n+                throw handleException(Response.Status.NOT_FOUND, RemoteFetchConfigurationConstants.\n+                                ErrorMessage.ERROR_CODE_RE_CONFIG_NOT_FOUND,\n+                        remoteFetchConfigurationId);\n+            }\n+            return createRemoteFetchConfigurationResponse(remoteFetchConfiguration);\n+\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_ERROR_RETRIEVING_RF_CONFIG, null);\n+        }\n+    }\n+\n+    /**\n+     * Update remote fetch configuration by resource id.\n+     *\n+     * @param id                                   Id.\n+     * @param remoteFetchConfigurationPatchRequest RemoteFetchConfigurationPatchRequest.\n+     */\n+    public void updateRemoteFetchConfig(String id,\n+                                        RemoteFetchConfigurationPatchRequest remoteFetchConfigurationPatchRequest) {\n+\n+        try {\n+            RemoteFetchConfiguration remoteFetchConfiguration =\n+                    RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                            .getRemoteFetchConfiguration(id);\n+\n+            if (remoteFetchConfiguration == null) {\n+                throw handleException(Response.Status.NOT_FOUND, RemoteFetchConfigurationConstants.\n+                        ErrorMessage.ERROR_CODE_RE_CONFIG_NOT_FOUND, id);\n+            }\n+\n+            RemoteFetchConfiguration remoteFetchConfigurationToUpdate = deepCopyRemoteFetchConfiguration\n+                    (id, remoteFetchConfiguration);\n+\n+            setIfNotNull(remoteFetchConfigurationPatchRequest.getIsEnabled(),\n+                    remoteFetchConfigurationToUpdate::setEnabled);\n+\n+            setIfNotNull(remoteFetchConfigurationPatchRequest.getRemoteFetchName(),\n+                    remoteFetchConfigurationToUpdate::setRemoteFetchName);\n+\n+            RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                    .updateRemoteFetchConfiguration(remoteFetchConfigurationToUpdate);\n+\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.ErrorMessage.\n+                    ERROR_CODE_ERROR_UPDATING_RF_CONFIG, null);\n+        }\n+    }\n+\n+    /**\n+     * Trigger remote fetch.\n+     *\n+     * @param remoteFetchConfigurationId remoteFetchConfigurationId.\n+     */\n+    public void triggerRemoteFetch(String remoteFetchConfigurationId) {\n+\n+        try {\n+            RemoteFetchConfiguration remoteFetchConfiguration =\n+                    RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                            .getRemoteFetchConfiguration(remoteFetchConfigurationId);\n+\n+            if (remoteFetchConfiguration != null) {\n+                RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                        .triggerRemoteFetch(remoteFetchConfiguration);\n+            } else {\n+                throw handleException(Response.Status.NOT_FOUND, RemoteFetchConfigurationConstants.\n+                        ErrorMessage.ERROR_CODE_RE_CONFIG_NOT_FOUND, remoteFetchConfigurationId);\n+            }\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleException(Response.Status.INTERNAL_SERVER_ERROR, RemoteFetchConfigurationConstants.ErrorMessage\n+                    .ERROR_CODE_ERROR_TRIGGER_REMOTE_FETCH, remoteFetchConfigurationId);\n+        }\n+\n+    }\n+\n+    /**\n+     * Add remote fetch configuration.\n+     *\n+     * @param remoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest\n+     * @return resource id.\n+     */\n+    public String addRemoteFetchConfiguration(RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        try {\n+            validatePOSTRequest(remoteFetchConfigurationPOSTRequest);\n+            return RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                    .addRemoteFetchConfiguration(createRemoteFetchConfiguration(remoteFetchConfigurationPOSTRequest))\n+                    .getId();\n+\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.ErrorMessage.\n+                    ERROR_CODE_ERROR_ADDING_RF_CONFIG, null);\n+        }\n+    }\n+\n+    private void validatePOSTRequest(RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        if (remoteFetchConfigurationPOSTRequest.getIsEnabled() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, IS_ENABLED);\n+        }\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getRemoteFetchName())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, REMOTE_FETCH_NAME);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getActionListener() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, ACTION_LISTENER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getActionListener().getType() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, ACTION_LISTENER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getActionListener().getAttributes() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, ACTION_LISTENER_ATTRIBUTES);\n+        }\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getActionListener()\n+                .getAttributes().getFrequency())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, FREQUENCY);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getRepositoryManager() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, REPOSITORY_MANAGER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getRepositoryManager().getType() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, REPOSITORY_MANAGER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getRepositoryManager().getAttributes() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, REPOSITORY_MANAGER_ATTRIBUTES);\n+        }\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getRepositoryManager()\n+                .getAttributes().getUri())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, URI);\n+        }\n+\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getRepositoryManager()\n+                .getAttributes().getBranch())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, BRANCH);\n+        }\n+\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getRepositoryManager()\n+                .getAttributes().getDirectory())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, DIRECTORY);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getConfigurationDeployer() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, CONFIGURATION_DEPLOYER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getConfigurationDeployer().getType() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, CONFIGURATION_DEPLOYER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getConfigurationDeployer().getAttributes() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, CONFIGURATION_DEPLOYER_ATTRIBUTES);\n+        }\n+    }\n+\n+    /**\n+     * Get status of remote fetch.\n+     *\n+     * @param remoteFetchConfigurationId RemoteFetchConfigurationId.\n+     */\n+    public StatusListResponse getStatus(String remoteFetchConfigurationId) {\n+\n+        try {\n+            RemoteFetchConfiguration remoteFetchConfiguration =\n+                    RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                            .getRemoteFetchConfiguration(remoteFetchConfigurationId);\n+\n+            if (remoteFetchConfiguration != null) {\n+\n+                return createStatusListResponse(RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                        .getDeploymentRevisions(remoteFetchConfigurationId));\n+            } else {\n+                throw handleException(Response.Status.NOT_FOUND, RemoteFetchConfigurationConstants.\n+                        ErrorMessage.ERROR_CODE_RE_CONFIG_NOT_FOUND, remoteFetchConfigurationId);\n+            }\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleException(Response.Status.INTERNAL_SERVER_ERROR, RemoteFetchConfigurationConstants.ErrorMessage\n+                    .ERROR_CODE_ERROR_STATUS_REMOTE_FETCH, remoteFetchConfigurationId);\n+        }\n+\n+    }\n+\n+    /**\n+     * This method is used to create status list from list of deployment revisions.\n+     * This method uses java stream api to count successful deployments and failed deployments.\n+     *\n+     * @param deploymentRevisions List of deployment revisions.\n+     * @return StatusListResponse.\n+     */\n+    private StatusListResponse createStatusListResponse(List<DeploymentRevision> deploymentRevisions) {\n+\n+        StatusListResponse statusListResponse = new StatusListResponse();\n+        if (CollectionUtils.isNotEmpty(deploymentRevisions)) {\n+            List<StatusListItem> statusListItemList = new ArrayList<>();\n+            for (DeploymentRevision deploymentRevision : deploymentRevisions) {\n+                StatusListItem statusListItem = populateDeploymentRevision(deploymentRevision);\n+                statusListItemList.add(statusListItem);\n+            }\n+            statusListResponse.setRemoteFetchRevisionStatuses(statusListItemList);\n+            statusListResponse.setSuccessfulDeployments(\n+                    (int) deploymentRevisions.stream()\n+                            .filter(Objects::nonNull)\n+                            .filter(deploymentRevision ->\n+                                    deploymentRevision.getDeploymentStatus().name()\n+                                            .equals(RemoteFetchConfigurationConstants.SUCCESS)).count());\n+\n+            statusListResponse.setFailedDeployments(\n+                    (int) deploymentRevisions.stream()\n+                            .filter(Objects::nonNull)\n+                            .filter(deploymentRevision ->\n+                                    deploymentRevision.getDeploymentStatus().name()\n+                                            .equals(RemoteFetchConfigurationConstants.FAIL)).count());\n+\n+            Date date = deploymentRevisions.stream()\n+                    .map(DeploymentRevision::getLastSynchronizedDate)\n+                    .max(Date::compareTo)\n+                    .orElse(null);\n+\n+            convertDateToStringIfNotNull(date, statusListResponse::setLastSynchronizedTime);\n+            return statusListResponse;\n+        } else {\n+            statusListResponse.setCount(0);\n+        }\n+        return statusListResponse;\n+    }\n+\n+    /**\n+     * Populate deployment revision to get status list item.\n+     *\n+     * @param deploymentRevision DeploymentRevision.\n+     * @return StatusListItem.\n+     */\n+    private StatusListItem populateDeploymentRevision(DeploymentRevision deploymentRevision) {\n+\n+        StatusListItem statusListItem = new StatusListItem();\n+        statusListItem.setDeployedStatus(deploymentRevision.getDeploymentStatus().name());\n+        convertDateToStringIfNotNull(deploymentRevision.getDeployedDate(), statusListItem::setDeployedTime);\n+        statusListItem.setItemName(deploymentRevision.getItemName());\n+        statusListItem.setDeploymentErrorReport(deploymentRevision.getErrorMessage());\n+        return statusListItem;\n+    }\n+\n+    /**\n+     * This method is used to create remote fetch configuration object from POST request.\n+     * First it creates three hash map from post request.\n+     * Then it set primitive attributes from post request remote fetch configuration.\n+     *\n+     * @param remoteFetchConfigurationPOSTRequest POST request.\n+     * @return RemoteFetchConfiguration.\n+     */\n+    private RemoteFetchConfiguration createRemoteFetchConfiguration\n+    (RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        RemoteFetchConfiguration remoteFetchConfiguration = new RemoteFetchConfiguration();\n+        Map<String, String> repositoryManagerAttributes =\n+                createRepositoryManagerProperties(remoteFetchConfigurationPOSTRequest);\n+        Map<String, String> actionListenerAttributes =\n+                createActionListenerProperties(remoteFetchConfigurationPOSTRequest);\n+        Map<String, String> configurationDeployerAttributes = Collections.emptyMap();\n+\n+        setIfNotNull(remoteFetchConfigurationPOSTRequest.getIsEnabled(), remoteFetchConfiguration::setEnabled);\n+        setIfNotNull(remoteFetchConfigurationPOSTRequest.getRemoteFetchName(),\n+                remoteFetchConfiguration::setRemoteFetchName);\n+\n+        remoteFetchConfiguration.setTenantId(IdentityTenantUtil\n+                .getTenantId(ContextLoader.getTenantDomainFromContext()));\n+\n+        remoteFetchConfiguration.setConfigurationDeployerType(remoteFetchConfigurationPOSTRequest\n+                .getConfigurationDeployer().getType().name());\n+        remoteFetchConfiguration.setActionListenerType(remoteFetchConfigurationPOSTRequest\n+                .getActionListener().getType().name());\n+        remoteFetchConfiguration.setRepositoryManagerType(remoteFetchConfigurationPOSTRequest\n+                .getRepositoryManager().getType().name());\n+\n+        remoteFetchConfiguration.setActionListenerAttributes(actionListenerAttributes);\n+        remoteFetchConfiguration.setRepositoryManagerAttributes(repositoryManagerAttributes);\n+        remoteFetchConfiguration.setConfigurationDeployerAttributes(configurationDeployerAttributes);\n+        return remoteFetchConfiguration;\n+\n+    }\n+\n+    /**\n+     * This method is used to create action listener hash map from POST request.\n+     *\n+     * @param remoteFetchConfigurationPOSTRequest RemoteFetchConfigurationPOSTRequest/\n+     * @return Properties.\n+     */\n+    private Map<String, String> createActionListenerProperties\n+    (RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        Map<String, String> properties = new HashMap<>();\n+        if (remoteFetchConfigurationPOSTRequest.getActionListener() != null) {\n+            ActionListenerAttributes actionListenerAttributes =\n+                    remoteFetchConfigurationPOSTRequest.getActionListener().getAttributes();\n+            if (!StringUtils.isEmpty(actionListenerAttributes.getFrequency())) {\n+                properties.put(FREQUENCY, actionListenerAttributes.getFrequency());\n+            }\n+        }\n+        return properties;\n+\n+    }\n+\n+    /**\n+     * This method is used to create Repository manager hash map from post request.\n+     *\n+     * @param remoteFetchConfigurationPOSTRequest POST request.\n+     * @return Properties.\n+     */\n+    private Map<String, String> createRepositoryManagerProperties\n+    (RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        Map<String, String> properties = new HashMap<>();\n+\n+        if (remoteFetchConfigurationPOSTRequest.getRepositoryManager() != null) {\n+\n+            RepositoryManagerAttributes repositoryManagerAttributes =\n+                    remoteFetchConfigurationPOSTRequest.getRepositoryManager().getAttributes();\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getAccessToken())) {\n+                properties.put(RemoteFetchConfigurationConstants.ACCESS_TOKEN,\n+                        repositoryManagerAttributes.getAccessToken());\n+            }\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getBranch())) {\n+                properties.put(BRANCH, repositoryManagerAttributes.getBranch());\n+            }\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getDirectory())) {\n+                properties.put(RemoteFetchConfigurationConstants.DIRECTORY, repositoryManagerAttributes.getDirectory());\n+            }\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getUri())) {\n+                properties.put(URI, repositoryManagerAttributes.getUri());\n+            }\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getUsername())) {\n+                properties.put(RemoteFetchConfigurationConstants.USER_NAME, repositoryManagerAttributes.getUsername());\n+            }\n+        }\n+\n+        return properties;\n+    }\n+\n+    /**\n+     * This method is used to create GET response from remote fetch configuration id.\n+     *\n+     * @param remoteFetchConfiguration remote fetch configuration domain object.\n+     * @return RemoteFetchConfigurationGetResponse.\n+     * @throws RemoteFetchCoreException RemoteFetchCoreException\n+     */\n+    private RemoteFetchConfigurationGetResponse createRemoteFetchConfigurationResponse\n+    (RemoteFetchConfiguration remoteFetchConfiguration) throws RemoteFetchCoreException {\n+\n+        RemoteFetchConfigurationGetResponse remoteFetchConfigurationGetResponse\n+                = new RemoteFetchConfigurationGetResponse();\n+        ActionListenerAttributes actionListenerAttributes = createActionListenerAttributeProperties\n+                (remoteFetchConfiguration);\n+\n+        RepositoryManagerAttributes repositoryManagerAttributes = createRepositoryManagerAttributeProperties\n+                (remoteFetchConfiguration);\n+\n+        remoteFetchConfigurationGetResponse.setActionListenerAttributes(actionListenerAttributes);\n+        remoteFetchConfigurationGetResponse.setRepositoryManagerAttributes(repositoryManagerAttributes);\n+        remoteFetchConfigurationGetResponse.setConfigurationDeployerAttributes(null);\n+\n+        setIfNotNull(remoteFetchConfiguration.getRemoteFetchConfigurationId(),\n+                remoteFetchConfigurationGetResponse::setId);\n+        setIfNotNull(remoteFetchConfiguration.isEnabled(),\n+                remoteFetchConfigurationGetResponse::setIsEnabled);\n+        setIfNotNull(remoteFetchConfiguration.getRemoteFetchName(),\n+                remoteFetchConfigurationGetResponse::setRemoteFetchName);\n+        setIfNotNull(remoteFetchConfiguration.getRepositoryManagerType(),\n+                remoteFetchConfigurationGetResponse::setRepositoryManagerType);\n+        setIfNotNull(remoteFetchConfiguration.getConfigurationDeployerType(),\n+                remoteFetchConfigurationGetResponse::setConfigurationDeployerType);\n+        setIfNotNull(remoteFetchConfiguration.getRepositoryManagerType(),\n+                remoteFetchConfigurationGetResponse::setRepositoryManagerType);\n+\n+        StatusListResponse statusListResponse = this.createStatusListResponse(RemoteFetchServiceHolder\n+                .getRemoteFetchConfigurationService()\n+                .getDeploymentRevisions(remoteFetchConfiguration.getRemoteFetchConfigurationId()));\n+        remoteFetchConfigurationGetResponse.setStatus(statusListResponse);\n+\n+        return remoteFetchConfigurationGetResponse;\n+    }\n+\n+    /**\n+     * This method used to create Action Listener attributes from domain object.\n+     *\n+     * @param remoteFetchConfiguration RemoteFetchConfiguration.\n+     * @return ActionListenerAttributes.\n+     */\n+    private ActionListenerAttributes createActionListenerAttributeProperties\n+    (RemoteFetchConfiguration remoteFetchConfiguration) {\n+\n+        ActionListenerAttributes actionListenerAttributes = new ActionListenerAttributes();\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getActionListenerAttributes().get(FREQUENCY),\n+                actionListenerAttributes::setFrequency);\n+        return actionListenerAttributes;\n+\n+    }\n+\n+    /**\n+     * This method is used to create Repository Manager Attributes from domain object.\n+     *\n+     * @param remoteFetchConfiguration RemoteFetchConfiguration.\n+     * @return RepositoryManagerAttributes\n+     */\n+    private RepositoryManagerAttributes createRepositoryManagerAttributeProperties\n+    (RemoteFetchConfiguration remoteFetchConfiguration) {\n+\n+        RepositoryManagerAttributes repositoryManagerAttributes = new RepositoryManagerAttributes();\n+\n+        setIfNotNull((remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(RemoteFetchConfigurationConstants.ACCESS_TOKEN)),\n+                repositoryManagerAttributes::setAccessToken);\n+\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(BRANCH),\n+                repositoryManagerAttributes::setBranch);\n+\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(RemoteFetchConfigurationConstants.DIRECTORY),\n+                repositoryManagerAttributes::setDirectory);\n+\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(URI),\n+                repositoryManagerAttributes::setUri);\n+\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(RemoteFetchConfigurationConstants.USER_NAME),\n+                repositoryManagerAttributes::setUsername);\n+        return repositoryManagerAttributes;\n+\n+    }\n+\n+    /**\n+     * This method is used to create list response from basic remote fetch configuration.\n+     * This method is create list item from basic remote fetch configuration list items.\n+     *\n+     * @param basicRemoteFetchConfigurationList List response.\n+     * @return RemoteFetchConfigurationListResponse.\n+     */\n+    private RemoteFetchConfigurationListResponse createRemoteFetchConfigurationListResponse\n+    (List<BasicRemoteFetchConfiguration> basicRemoteFetchConfigurationList) {\n+\n+        RemoteFetchConfigurationListResponse remoteFetchConfigurationListResponse =\n+                new RemoteFetchConfigurationListResponse();\n+        if (CollectionUtils.isNotEmpty(basicRemoteFetchConfigurationList)) {\n+            List<RemoteFetchConfigurationListItem> remoteFetchConfigurations = new ArrayList<>();\n+            for (BasicRemoteFetchConfiguration basicRemoteFetchConfiguration : basicRemoteFetchConfigurationList) {\n+                RemoteFetchConfigurationListItem remoteFetchConfigurationListItem =\n+                        populateRemoteFetchConfigurationListResponse(basicRemoteFetchConfiguration);\n+                remoteFetchConfigurations.add(remoteFetchConfigurationListItem);\n+            }\n+            remoteFetchConfigurationListResponse.setRemotefetchConfigurations(remoteFetchConfigurations);\n+            remoteFetchConfigurationListResponse.setCount(remoteFetchConfigurations.size());\n+        } else {\n+            remoteFetchConfigurationListResponse.setCount(0);\n+        }\n+        return remoteFetchConfigurationListResponse;\n+    }\n+\n+    /**\n+     * This method is used to populate remote fetch configuration list item from basic remote fetch configuration.\n+     *\n+     * @param basicRemoteFetchConfiguration basic remote fetch configuration.\n+     * @return RemoteFetchConfigurationListItem.\n+     */\n+    private RemoteFetchConfigurationListItem populateRemoteFetchConfigurationListResponse\n+    (BasicRemoteFetchConfiguration basicRemoteFetchConfiguration) {\n+\n+        RemoteFetchConfigurationListItem remoteFetchConfigurationListItem = new RemoteFetchConfigurationListItem();\n+\n+        setIfNotNull(basicRemoteFetchConfiguration.getId(), remoteFetchConfigurationListItem::setId);\n+        setIfNotNull(basicRemoteFetchConfiguration.isEnabled(), remoteFetchConfigurationListItem::setIsEnabled);\n+        setIfNotNull(basicRemoteFetchConfiguration.getActionListenerType(),\n+                remoteFetchConfigurationListItem::setActionListenerType);\n+        setIfNotNull(basicRemoteFetchConfiguration.getConfigurationDeployerType(),\n+                remoteFetchConfigurationListItem::setConfigurationDeployerType);\n+        setIfNotNull(basicRemoteFetchConfiguration.getRepositoryManagerType(),\n+                remoteFetchConfigurationListItem::setRepositoryManagerType);\n+        setIfNotNull(basicRemoteFetchConfiguration.getRemoteFetchName(),\n+                remoteFetchConfigurationListItem::setName);\n+        if (basicRemoteFetchConfiguration.getLastDeployed() == null) {\n+            remoteFetchConfigurationListItem.setLastDeployed(null);\n+        } else {\n+            convertDateToStringIfNotNull(basicRemoteFetchConfiguration.getLastDeployed(),\n+                    remoteFetchConfigurationListItem::setLastDeployed);\n+        }\n+        remoteFetchConfigurationListItem.setFailedDeployments(basicRemoteFetchConfiguration.getFailedDeployments());\n+        remoteFetchConfigurationListItem.setSuccessfulDeployments(basicRemoteFetchConfiguration.\n+                getSuccessfulDeployments());\n+\n+        return remoteFetchConfigurationListItem;\n+    }\n+\n+    /**\n+     * This method is used to handle web hook.\n+     *\n+     * @param pushEventWebHookPOSTRequest WebHook Post request\n+     */\n+    public void handleWebHook(PushEventWebHookPOSTRequest pushEventWebHookPOSTRequest) {\n+\n+        try {\n+            validateWebHookRequest(pushEventWebHookPOSTRequest);\n+            String cloneURL = pushEventWebHookPOSTRequest.getRepository().getCloneUrl();\n+            String branch = populateBranch(pushEventWebHookPOSTRequest.getRef());\n+            List<String> modifiedFiles = extractAddedAndModifiedFiles(pushEventWebHookPOSTRequest.getCommits());\n+            RemoteFetchServiceHolder\n+                    .getRemoteFetchConfigurationService().handleWebHook(cloneURL, branch, modifiedFiles);\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleException(Response.Status.INTERNAL_SERVER_ERROR, RemoteFetchConfigurationConstants.ErrorMessage\n+                    .ERROR_CODE_ERROR_WEB_HOOK_REMOTE_FETCH, null);\n+        }\n+\n+    }\n+\n+    /**\n+     * Method used to validate GitHub Web hook request.\n+     *\n+     * @param pushEventWebHookPOSTRequest pushEventWebHookPOSTRequest.\n+     */\n+    private void validateWebHookRequest(PushEventWebHookPOSTRequest pushEventWebHookPOSTRequest) {\n+\n+        if ((pushEventWebHookPOSTRequest.getRef() == null) || (pushEventWebHookPOSTRequest.getRepository() == null) ||\n+                (pushEventWebHookPOSTRequest.getCommits() == null)) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, WEBHOOK_REQUEST);\n+        }\n+        if (StringUtils.isBlank(pushEventWebHookPOSTRequest.getRepository().getCloneUrl())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, WEBHOOK_REQUEST);\n+        }\n+    }\n+\n+    private String populateBranch(String ref) {\n+\n+        String[] splitCredentials = ref.split(\"/\", 3);\n+        return splitCredentials[2];\n+    }\n+\n+    /**\n+     * This method is used to extract added or modified file names from the commit objects.\n+     *\n+     * @param commits List of commits\n+     * @return List of FIle names\n+     */\n+    private List<String> extractAddedAndModifiedFiles(List<PushEventWebHookPOSTRequestCommits> commits) {\n+\n+        List<String> fileNames = new ArrayList<>();\n+        if (CollectionUtils.isNotEmpty(commits)) {\n+            for (PushEventWebHookPOSTRequestCommits commit : commits) {\n+                fileNames.addAll(commit.getAdded());\n+                fileNames.addAll(commit.getModified());\n+            }\n+            return fileNames;\n+        } else {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_COMMIT_NOT_FOUND, null);\n+        }\n+    }\n+\n+    /**\n+     * This method is used to handle remote fetch core exception and create API error wit suitable response code and\n+     * status by checking its instance type.\n+     *\n+     * @param e         RemoteFetchCoreException.\n+     * @param errorEnum RemoteFetchConfigurationConstants.ErrorMessage\n+     * @param data      data\n+     * @return APIError\n+     */\n+    private APIError handleRemoteFetchConfigurationException(RemoteFetchCoreException e,\n+                                                             RemoteFetchConfigurationConstants.ErrorMessage errorEnum,\n+                                                             String data) {\n+\n+        ErrorResponse errorResponse = getErrorBuilder(errorEnum, data).build(log, e, errorEnum.getDescription());\n+\n+        Response.Status status;\n+\n+        if (e instanceof RemoteFetchClientException) {\n+            if (e.getErrorCode() != null) {\n+                String errorCode = e.getErrorCode();\n+                errorCode =\n+                        errorCode.contains(RemoteFetchConfigurationConstants.ERROR_CODE_DELIMITER) ?\n+                                errorCode : RemoteFetchConfigurationConstants.\n+                                REMOTE_FETCH_CONFIGURATION_MANAGEMENT_PREFIX + errorCode;\n+                errorResponse.setCode(errorCode);\n+            }\n+            errorResponse.setDescription(e.getMessage());\n+            status = Response.Status.BAD_REQUEST;\n+        } else if (e instanceof RemoteFetchServerException) {\n+            if (e.getErrorCode() != null) {\n+                String errorCode = e.getErrorCode();\n+                errorCode =\n+                        errorCode.contains(RemoteFetchConfigurationConstants.ERROR_CODE_DELIMITER) ?\n+                                errorCode : RemoteFetchConfigurationConstants.\n+                                REMOTE_FETCH_CONFIGURATION_MANAGEMENT_PREFIX + errorCode;\n+                errorResponse.setCode(errorCode);\n+            }\n+            errorResponse.setDescription(e.getMessage());\n+            status = Response.Status.INTERNAL_SERVER_ERROR;\n+        } else {\n+            status = Response.Status.INTERNAL_SERVER_ERROR;\n+        }\n+        return new APIError(status, errorResponse);\n+    }\n+\n+    /**\n+     * From the error message and the data this method returns error builder.\n+     *\n+     * @param errorMsg error message.\n+     * @param data     data.\n+     * @return ErrorResponse.Builder\n+     */\n+    private ErrorResponse.Builder getErrorBuilder(RemoteFetchConfigurationConstants.ErrorMessage errorMsg,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1fb2dd934e5919e7461ee1a9845960ab21188a8"}, "originalPosition": 757}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA2MzY4Nw==", "bodyText": "Sorry. The line length will be 121 characters.", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507063687", "createdAt": "2020-10-18T09:39:45Z", "author": {"login": "Thumimku"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/v1/core/ServerRemoteFetchConfigManagementService.java", "diffHunk": "@@ -0,0 +1,814 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.identity.api.server.fetch.remote.v1.core;\n+\n+import org.apache.commons.beanutils.BeanUtils;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.identity.api.server.common.ContextLoader;\n+import org.wso2.carbon.identity.api.server.common.error.APIError;\n+import org.wso2.carbon.identity.api.server.common.error.ErrorResponse;\n+import org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants;\n+import org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchServiceHolder;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.ActionListenerAttributes;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.PushEventWebHookPOSTRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.PushEventWebHookPOSTRequestCommits;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationGetResponse;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationListItem;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationListResponse;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationPOSTRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationPatchRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RepositoryManagerAttributes;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.StatusListItem;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.StatusListResponse;\n+import org.wso2.carbon.identity.core.util.IdentityTenantUtil;\n+import org.wso2.carbon.identity.remotefetch.common.BasicRemoteFetchConfiguration;\n+import org.wso2.carbon.identity.remotefetch.common.DeploymentRevision;\n+import org.wso2.carbon.identity.remotefetch.common.RemoteFetchConfiguration;\n+import org.wso2.carbon.identity.remotefetch.common.exceptions.RemoteFetchClientException;\n+import org.wso2.carbon.identity.remotefetch.common.exceptions.RemoteFetchCoreException;\n+import org.wso2.carbon.identity.remotefetch.common.exceptions.RemoteFetchServerException;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.OptionalInt;\n+\n+import javax.ws.rs.core.Response;\n+\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.ACTION_LISTENER;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.ACTION_LISTENER_ATTRIBUTES;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.BRANCH;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.CONFIGURATION_DEPLOYER;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.CONFIGURATION_DEPLOYER_ATTRIBUTES;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.DIRECTORY;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.FREQUENCY;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.IS_ENABLED;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.REMOTE_FETCH_NAME;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.REPOSITORY_MANAGER;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.REPOSITORY_MANAGER_ATTRIBUTES;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.URI;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.WEBHOOK_REQUEST;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.v1.core.RemoteFetchUtils.convertDateToStringIfNotNull;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.v1.core.RemoteFetchUtils.setIfNotNull;\n+\n+/**\n+ * Call internal osgi services to perform server remote fetch configuration related operations.\n+ */\n+public class ServerRemoteFetchConfigManagementService {\n+\n+    private static final Log log = LogFactory.getLog(ServerRemoteFetchConfigManagementService.class);\n+\n+    /**\n+     * Get list of remote fetch configurations.\n+     *\n+     * @return RemoteFetchConfigurationListResponse.\n+     */\n+    public RemoteFetchConfigurationListResponse getRemoteFetchConfigs() {\n+\n+        OptionalInt optionalIntLimit = OptionalInt.empty();\n+        OptionalInt optionalIntOffset = OptionalInt.empty();\n+\n+        try {\n+            return createRemoteFetchConfigurationListResponse(RemoteFetchServiceHolder.\n+                    getRemoteFetchConfigurationService()\n+                    .getBasicRemoteFetchConfigurationList(optionalIntLimit, optionalIntOffset));\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_ERROR_LISTING_RF_CONFIGS, null);\n+        }\n+    }\n+\n+    /**\n+     * Delete an Remote fetch configuration.\n+     *\n+     * @param remoteFetchConfigurationId Identity Provider resource ID.\n+     */\n+    public void deleteRemoteFetchConfig(String remoteFetchConfigurationId) {\n+\n+        try {\n+            RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                    .deleteRemoteFetchConfiguration(remoteFetchConfigurationId);\n+\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_ERROR_DELETING_RF_CONFIGS, remoteFetchConfigurationId);\n+        }\n+    }\n+\n+    /**\n+     * Get remote fetch configuration by resource Id.\n+     *\n+     * @param remoteFetchConfigurationId resource Id.\n+     * @return RemoteFetchConfigurationListResponse.\n+     */\n+    public RemoteFetchConfigurationGetResponse getRemoteFetchConfig(String remoteFetchConfigurationId) {\n+\n+        try {\n+            RemoteFetchConfiguration remoteFetchConfiguration =\n+                    RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                            .getRemoteFetchConfiguration(remoteFetchConfigurationId);\n+\n+            if (remoteFetchConfiguration == null) {\n+                throw handleException(Response.Status.NOT_FOUND, RemoteFetchConfigurationConstants.\n+                                ErrorMessage.ERROR_CODE_RE_CONFIG_NOT_FOUND,\n+                        remoteFetchConfigurationId);\n+            }\n+            return createRemoteFetchConfigurationResponse(remoteFetchConfiguration);\n+\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_ERROR_RETRIEVING_RF_CONFIG, null);\n+        }\n+    }\n+\n+    /**\n+     * Update remote fetch configuration by resource id.\n+     *\n+     * @param id                                   Id.\n+     * @param remoteFetchConfigurationPatchRequest RemoteFetchConfigurationPatchRequest.\n+     */\n+    public void updateRemoteFetchConfig(String id,\n+                                        RemoteFetchConfigurationPatchRequest remoteFetchConfigurationPatchRequest) {\n+\n+        try {\n+            RemoteFetchConfiguration remoteFetchConfiguration =\n+                    RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                            .getRemoteFetchConfiguration(id);\n+\n+            if (remoteFetchConfiguration == null) {\n+                throw handleException(Response.Status.NOT_FOUND, RemoteFetchConfigurationConstants.\n+                        ErrorMessage.ERROR_CODE_RE_CONFIG_NOT_FOUND, id);\n+            }\n+\n+            RemoteFetchConfiguration remoteFetchConfigurationToUpdate = deepCopyRemoteFetchConfiguration\n+                    (id, remoteFetchConfiguration);\n+\n+            setIfNotNull(remoteFetchConfigurationPatchRequest.getIsEnabled(),\n+                    remoteFetchConfigurationToUpdate::setEnabled);\n+\n+            setIfNotNull(remoteFetchConfigurationPatchRequest.getRemoteFetchName(),\n+                    remoteFetchConfigurationToUpdate::setRemoteFetchName);\n+\n+            RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                    .updateRemoteFetchConfiguration(remoteFetchConfigurationToUpdate);\n+\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.ErrorMessage.\n+                    ERROR_CODE_ERROR_UPDATING_RF_CONFIG, null);\n+        }\n+    }\n+\n+    /**\n+     * Trigger remote fetch.\n+     *\n+     * @param remoteFetchConfigurationId remoteFetchConfigurationId.\n+     */\n+    public void triggerRemoteFetch(String remoteFetchConfigurationId) {\n+\n+        try {\n+            RemoteFetchConfiguration remoteFetchConfiguration =\n+                    RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                            .getRemoteFetchConfiguration(remoteFetchConfigurationId);\n+\n+            if (remoteFetchConfiguration != null) {\n+                RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                        .triggerRemoteFetch(remoteFetchConfiguration);\n+            } else {\n+                throw handleException(Response.Status.NOT_FOUND, RemoteFetchConfigurationConstants.\n+                        ErrorMessage.ERROR_CODE_RE_CONFIG_NOT_FOUND, remoteFetchConfigurationId);\n+            }\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleException(Response.Status.INTERNAL_SERVER_ERROR, RemoteFetchConfigurationConstants.ErrorMessage\n+                    .ERROR_CODE_ERROR_TRIGGER_REMOTE_FETCH, remoteFetchConfigurationId);\n+        }\n+\n+    }\n+\n+    /**\n+     * Add remote fetch configuration.\n+     *\n+     * @param remoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest\n+     * @return resource id.\n+     */\n+    public String addRemoteFetchConfiguration(RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        try {\n+            validatePOSTRequest(remoteFetchConfigurationPOSTRequest);\n+            return RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                    .addRemoteFetchConfiguration(createRemoteFetchConfiguration(remoteFetchConfigurationPOSTRequest))\n+                    .getId();\n+\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.ErrorMessage.\n+                    ERROR_CODE_ERROR_ADDING_RF_CONFIG, null);\n+        }\n+    }\n+\n+    private void validatePOSTRequest(RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        if (remoteFetchConfigurationPOSTRequest.getIsEnabled() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, IS_ENABLED);\n+        }\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getRemoteFetchName())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, REMOTE_FETCH_NAME);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getActionListener() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, ACTION_LISTENER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getActionListener().getType() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, ACTION_LISTENER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getActionListener().getAttributes() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, ACTION_LISTENER_ATTRIBUTES);\n+        }\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getActionListener()\n+                .getAttributes().getFrequency())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, FREQUENCY);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getRepositoryManager() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, REPOSITORY_MANAGER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getRepositoryManager().getType() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, REPOSITORY_MANAGER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getRepositoryManager().getAttributes() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, REPOSITORY_MANAGER_ATTRIBUTES);\n+        }\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getRepositoryManager()\n+                .getAttributes().getUri())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, URI);\n+        }\n+\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getRepositoryManager()\n+                .getAttributes().getBranch())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, BRANCH);\n+        }\n+\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getRepositoryManager()\n+                .getAttributes().getDirectory())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, DIRECTORY);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getConfigurationDeployer() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, CONFIGURATION_DEPLOYER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getConfigurationDeployer().getType() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, CONFIGURATION_DEPLOYER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getConfigurationDeployer().getAttributes() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, CONFIGURATION_DEPLOYER_ATTRIBUTES);\n+        }\n+    }\n+\n+    /**\n+     * Get status of remote fetch.\n+     *\n+     * @param remoteFetchConfigurationId RemoteFetchConfigurationId.\n+     */\n+    public StatusListResponse getStatus(String remoteFetchConfigurationId) {\n+\n+        try {\n+            RemoteFetchConfiguration remoteFetchConfiguration =\n+                    RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                            .getRemoteFetchConfiguration(remoteFetchConfigurationId);\n+\n+            if (remoteFetchConfiguration != null) {\n+\n+                return createStatusListResponse(RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                        .getDeploymentRevisions(remoteFetchConfigurationId));\n+            } else {\n+                throw handleException(Response.Status.NOT_FOUND, RemoteFetchConfigurationConstants.\n+                        ErrorMessage.ERROR_CODE_RE_CONFIG_NOT_FOUND, remoteFetchConfigurationId);\n+            }\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleException(Response.Status.INTERNAL_SERVER_ERROR, RemoteFetchConfigurationConstants.ErrorMessage\n+                    .ERROR_CODE_ERROR_STATUS_REMOTE_FETCH, remoteFetchConfigurationId);\n+        }\n+\n+    }\n+\n+    /**\n+     * This method is used to create status list from list of deployment revisions.\n+     * This method uses java stream api to count successful deployments and failed deployments.\n+     *\n+     * @param deploymentRevisions List of deployment revisions.\n+     * @return StatusListResponse.\n+     */\n+    private StatusListResponse createStatusListResponse(List<DeploymentRevision> deploymentRevisions) {\n+\n+        StatusListResponse statusListResponse = new StatusListResponse();\n+        if (CollectionUtils.isNotEmpty(deploymentRevisions)) {\n+            List<StatusListItem> statusListItemList = new ArrayList<>();\n+            for (DeploymentRevision deploymentRevision : deploymentRevisions) {\n+                StatusListItem statusListItem = populateDeploymentRevision(deploymentRevision);\n+                statusListItemList.add(statusListItem);\n+            }\n+            statusListResponse.setRemoteFetchRevisionStatuses(statusListItemList);\n+            statusListResponse.setSuccessfulDeployments(\n+                    (int) deploymentRevisions.stream()\n+                            .filter(Objects::nonNull)\n+                            .filter(deploymentRevision ->\n+                                    deploymentRevision.getDeploymentStatus().name()\n+                                            .equals(RemoteFetchConfigurationConstants.SUCCESS)).count());\n+\n+            statusListResponse.setFailedDeployments(\n+                    (int) deploymentRevisions.stream()\n+                            .filter(Objects::nonNull)\n+                            .filter(deploymentRevision ->\n+                                    deploymentRevision.getDeploymentStatus().name()\n+                                            .equals(RemoteFetchConfigurationConstants.FAIL)).count());\n+\n+            Date date = deploymentRevisions.stream()\n+                    .map(DeploymentRevision::getLastSynchronizedDate)\n+                    .max(Date::compareTo)\n+                    .orElse(null);\n+\n+            convertDateToStringIfNotNull(date, statusListResponse::setLastSynchronizedTime);\n+            return statusListResponse;\n+        } else {\n+            statusListResponse.setCount(0);\n+        }\n+        return statusListResponse;\n+    }\n+\n+    /**\n+     * Populate deployment revision to get status list item.\n+     *\n+     * @param deploymentRevision DeploymentRevision.\n+     * @return StatusListItem.\n+     */\n+    private StatusListItem populateDeploymentRevision(DeploymentRevision deploymentRevision) {\n+\n+        StatusListItem statusListItem = new StatusListItem();\n+        statusListItem.setDeployedStatus(deploymentRevision.getDeploymentStatus().name());\n+        convertDateToStringIfNotNull(deploymentRevision.getDeployedDate(), statusListItem::setDeployedTime);\n+        statusListItem.setItemName(deploymentRevision.getItemName());\n+        statusListItem.setDeploymentErrorReport(deploymentRevision.getErrorMessage());\n+        return statusListItem;\n+    }\n+\n+    /**\n+     * This method is used to create remote fetch configuration object from POST request.\n+     * First it creates three hash map from post request.\n+     * Then it set primitive attributes from post request remote fetch configuration.\n+     *\n+     * @param remoteFetchConfigurationPOSTRequest POST request.\n+     * @return RemoteFetchConfiguration.\n+     */\n+    private RemoteFetchConfiguration createRemoteFetchConfiguration\n+    (RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        RemoteFetchConfiguration remoteFetchConfiguration = new RemoteFetchConfiguration();\n+        Map<String, String> repositoryManagerAttributes =\n+                createRepositoryManagerProperties(remoteFetchConfigurationPOSTRequest);\n+        Map<String, String> actionListenerAttributes =\n+                createActionListenerProperties(remoteFetchConfigurationPOSTRequest);\n+        Map<String, String> configurationDeployerAttributes = Collections.emptyMap();\n+\n+        setIfNotNull(remoteFetchConfigurationPOSTRequest.getIsEnabled(), remoteFetchConfiguration::setEnabled);\n+        setIfNotNull(remoteFetchConfigurationPOSTRequest.getRemoteFetchName(),\n+                remoteFetchConfiguration::setRemoteFetchName);\n+\n+        remoteFetchConfiguration.setTenantId(IdentityTenantUtil\n+                .getTenantId(ContextLoader.getTenantDomainFromContext()));\n+\n+        remoteFetchConfiguration.setConfigurationDeployerType(remoteFetchConfigurationPOSTRequest\n+                .getConfigurationDeployer().getType().name());\n+        remoteFetchConfiguration.setActionListenerType(remoteFetchConfigurationPOSTRequest\n+                .getActionListener().getType().name());\n+        remoteFetchConfiguration.setRepositoryManagerType(remoteFetchConfigurationPOSTRequest\n+                .getRepositoryManager().getType().name());\n+\n+        remoteFetchConfiguration.setActionListenerAttributes(actionListenerAttributes);\n+        remoteFetchConfiguration.setRepositoryManagerAttributes(repositoryManagerAttributes);\n+        remoteFetchConfiguration.setConfigurationDeployerAttributes(configurationDeployerAttributes);\n+        return remoteFetchConfiguration;\n+\n+    }\n+\n+    /**\n+     * This method is used to create action listener hash map from POST request.\n+     *\n+     * @param remoteFetchConfigurationPOSTRequest RemoteFetchConfigurationPOSTRequest/\n+     * @return Properties.\n+     */\n+    private Map<String, String> createActionListenerProperties\n+    (RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        Map<String, String> properties = new HashMap<>();\n+        if (remoteFetchConfigurationPOSTRequest.getActionListener() != null) {\n+            ActionListenerAttributes actionListenerAttributes =\n+                    remoteFetchConfigurationPOSTRequest.getActionListener().getAttributes();\n+            if (!StringUtils.isEmpty(actionListenerAttributes.getFrequency())) {\n+                properties.put(FREQUENCY, actionListenerAttributes.getFrequency());\n+            }\n+        }\n+        return properties;\n+\n+    }\n+\n+    /**\n+     * This method is used to create Repository manager hash map from post request.\n+     *\n+     * @param remoteFetchConfigurationPOSTRequest POST request.\n+     * @return Properties.\n+     */\n+    private Map<String, String> createRepositoryManagerProperties\n+    (RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        Map<String, String> properties = new HashMap<>();\n+\n+        if (remoteFetchConfigurationPOSTRequest.getRepositoryManager() != null) {\n+\n+            RepositoryManagerAttributes repositoryManagerAttributes =\n+                    remoteFetchConfigurationPOSTRequest.getRepositoryManager().getAttributes();\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getAccessToken())) {\n+                properties.put(RemoteFetchConfigurationConstants.ACCESS_TOKEN,\n+                        repositoryManagerAttributes.getAccessToken());\n+            }\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getBranch())) {\n+                properties.put(BRANCH, repositoryManagerAttributes.getBranch());\n+            }\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getDirectory())) {\n+                properties.put(RemoteFetchConfigurationConstants.DIRECTORY, repositoryManagerAttributes.getDirectory());\n+            }\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getUri())) {\n+                properties.put(URI, repositoryManagerAttributes.getUri());\n+            }\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getUsername())) {\n+                properties.put(RemoteFetchConfigurationConstants.USER_NAME, repositoryManagerAttributes.getUsername());\n+            }\n+        }\n+\n+        return properties;\n+    }\n+\n+    /**\n+     * This method is used to create GET response from remote fetch configuration id.\n+     *\n+     * @param remoteFetchConfiguration remote fetch configuration domain object.\n+     * @return RemoteFetchConfigurationGetResponse.\n+     * @throws RemoteFetchCoreException RemoteFetchCoreException\n+     */\n+    private RemoteFetchConfigurationGetResponse createRemoteFetchConfigurationResponse\n+    (RemoteFetchConfiguration remoteFetchConfiguration) throws RemoteFetchCoreException {\n+\n+        RemoteFetchConfigurationGetResponse remoteFetchConfigurationGetResponse\n+                = new RemoteFetchConfigurationGetResponse();\n+        ActionListenerAttributes actionListenerAttributes = createActionListenerAttributeProperties\n+                (remoteFetchConfiguration);\n+\n+        RepositoryManagerAttributes repositoryManagerAttributes = createRepositoryManagerAttributeProperties\n+                (remoteFetchConfiguration);\n+\n+        remoteFetchConfigurationGetResponse.setActionListenerAttributes(actionListenerAttributes);\n+        remoteFetchConfigurationGetResponse.setRepositoryManagerAttributes(repositoryManagerAttributes);\n+        remoteFetchConfigurationGetResponse.setConfigurationDeployerAttributes(null);\n+\n+        setIfNotNull(remoteFetchConfiguration.getRemoteFetchConfigurationId(),\n+                remoteFetchConfigurationGetResponse::setId);\n+        setIfNotNull(remoteFetchConfiguration.isEnabled(),\n+                remoteFetchConfigurationGetResponse::setIsEnabled);\n+        setIfNotNull(remoteFetchConfiguration.getRemoteFetchName(),\n+                remoteFetchConfigurationGetResponse::setRemoteFetchName);\n+        setIfNotNull(remoteFetchConfiguration.getRepositoryManagerType(),\n+                remoteFetchConfigurationGetResponse::setRepositoryManagerType);\n+        setIfNotNull(remoteFetchConfiguration.getConfigurationDeployerType(),\n+                remoteFetchConfigurationGetResponse::setConfigurationDeployerType);\n+        setIfNotNull(remoteFetchConfiguration.getRepositoryManagerType(),\n+                remoteFetchConfigurationGetResponse::setRepositoryManagerType);\n+\n+        StatusListResponse statusListResponse = this.createStatusListResponse(RemoteFetchServiceHolder\n+                .getRemoteFetchConfigurationService()\n+                .getDeploymentRevisions(remoteFetchConfiguration.getRemoteFetchConfigurationId()));\n+        remoteFetchConfigurationGetResponse.setStatus(statusListResponse);\n+\n+        return remoteFetchConfigurationGetResponse;\n+    }\n+\n+    /**\n+     * This method used to create Action Listener attributes from domain object.\n+     *\n+     * @param remoteFetchConfiguration RemoteFetchConfiguration.\n+     * @return ActionListenerAttributes.\n+     */\n+    private ActionListenerAttributes createActionListenerAttributeProperties\n+    (RemoteFetchConfiguration remoteFetchConfiguration) {\n+\n+        ActionListenerAttributes actionListenerAttributes = new ActionListenerAttributes();\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getActionListenerAttributes().get(FREQUENCY),\n+                actionListenerAttributes::setFrequency);\n+        return actionListenerAttributes;\n+\n+    }\n+\n+    /**\n+     * This method is used to create Repository Manager Attributes from domain object.\n+     *\n+     * @param remoteFetchConfiguration RemoteFetchConfiguration.\n+     * @return RepositoryManagerAttributes\n+     */\n+    private RepositoryManagerAttributes createRepositoryManagerAttributeProperties\n+    (RemoteFetchConfiguration remoteFetchConfiguration) {\n+\n+        RepositoryManagerAttributes repositoryManagerAttributes = new RepositoryManagerAttributes();\n+\n+        setIfNotNull((remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(RemoteFetchConfigurationConstants.ACCESS_TOKEN)),\n+                repositoryManagerAttributes::setAccessToken);\n+\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(BRANCH),\n+                repositoryManagerAttributes::setBranch);\n+\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(RemoteFetchConfigurationConstants.DIRECTORY),\n+                repositoryManagerAttributes::setDirectory);\n+\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(URI),\n+                repositoryManagerAttributes::setUri);\n+\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(RemoteFetchConfigurationConstants.USER_NAME),\n+                repositoryManagerAttributes::setUsername);\n+        return repositoryManagerAttributes;\n+\n+    }\n+\n+    /**\n+     * This method is used to create list response from basic remote fetch configuration.\n+     * This method is create list item from basic remote fetch configuration list items.\n+     *\n+     * @param basicRemoteFetchConfigurationList List response.\n+     * @return RemoteFetchConfigurationListResponse.\n+     */\n+    private RemoteFetchConfigurationListResponse createRemoteFetchConfigurationListResponse\n+    (List<BasicRemoteFetchConfiguration> basicRemoteFetchConfigurationList) {\n+\n+        RemoteFetchConfigurationListResponse remoteFetchConfigurationListResponse =\n+                new RemoteFetchConfigurationListResponse();\n+        if (CollectionUtils.isNotEmpty(basicRemoteFetchConfigurationList)) {\n+            List<RemoteFetchConfigurationListItem> remoteFetchConfigurations = new ArrayList<>();\n+            for (BasicRemoteFetchConfiguration basicRemoteFetchConfiguration : basicRemoteFetchConfigurationList) {\n+                RemoteFetchConfigurationListItem remoteFetchConfigurationListItem =\n+                        populateRemoteFetchConfigurationListResponse(basicRemoteFetchConfiguration);\n+                remoteFetchConfigurations.add(remoteFetchConfigurationListItem);\n+            }\n+            remoteFetchConfigurationListResponse.setRemotefetchConfigurations(remoteFetchConfigurations);\n+            remoteFetchConfigurationListResponse.setCount(remoteFetchConfigurations.size());\n+        } else {\n+            remoteFetchConfigurationListResponse.setCount(0);\n+        }\n+        return remoteFetchConfigurationListResponse;\n+    }\n+\n+    /**\n+     * This method is used to populate remote fetch configuration list item from basic remote fetch configuration.\n+     *\n+     * @param basicRemoteFetchConfiguration basic remote fetch configuration.\n+     * @return RemoteFetchConfigurationListItem.\n+     */\n+    private RemoteFetchConfigurationListItem populateRemoteFetchConfigurationListResponse\n+    (BasicRemoteFetchConfiguration basicRemoteFetchConfiguration) {\n+\n+        RemoteFetchConfigurationListItem remoteFetchConfigurationListItem = new RemoteFetchConfigurationListItem();\n+\n+        setIfNotNull(basicRemoteFetchConfiguration.getId(), remoteFetchConfigurationListItem::setId);\n+        setIfNotNull(basicRemoteFetchConfiguration.isEnabled(), remoteFetchConfigurationListItem::setIsEnabled);\n+        setIfNotNull(basicRemoteFetchConfiguration.getActionListenerType(),\n+                remoteFetchConfigurationListItem::setActionListenerType);\n+        setIfNotNull(basicRemoteFetchConfiguration.getConfigurationDeployerType(),\n+                remoteFetchConfigurationListItem::setConfigurationDeployerType);\n+        setIfNotNull(basicRemoteFetchConfiguration.getRepositoryManagerType(),\n+                remoteFetchConfigurationListItem::setRepositoryManagerType);\n+        setIfNotNull(basicRemoteFetchConfiguration.getRemoteFetchName(),\n+                remoteFetchConfigurationListItem::setName);\n+        if (basicRemoteFetchConfiguration.getLastDeployed() == null) {\n+            remoteFetchConfigurationListItem.setLastDeployed(null);\n+        } else {\n+            convertDateToStringIfNotNull(basicRemoteFetchConfiguration.getLastDeployed(),\n+                    remoteFetchConfigurationListItem::setLastDeployed);\n+        }\n+        remoteFetchConfigurationListItem.setFailedDeployments(basicRemoteFetchConfiguration.getFailedDeployments());\n+        remoteFetchConfigurationListItem.setSuccessfulDeployments(basicRemoteFetchConfiguration.\n+                getSuccessfulDeployments());\n+\n+        return remoteFetchConfigurationListItem;\n+    }\n+\n+    /**\n+     * This method is used to handle web hook.\n+     *\n+     * @param pushEventWebHookPOSTRequest WebHook Post request\n+     */\n+    public void handleWebHook(PushEventWebHookPOSTRequest pushEventWebHookPOSTRequest) {\n+\n+        try {\n+            validateWebHookRequest(pushEventWebHookPOSTRequest);\n+            String cloneURL = pushEventWebHookPOSTRequest.getRepository().getCloneUrl();\n+            String branch = populateBranch(pushEventWebHookPOSTRequest.getRef());\n+            List<String> modifiedFiles = extractAddedAndModifiedFiles(pushEventWebHookPOSTRequest.getCommits());\n+            RemoteFetchServiceHolder\n+                    .getRemoteFetchConfigurationService().handleWebHook(cloneURL, branch, modifiedFiles);\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleException(Response.Status.INTERNAL_SERVER_ERROR, RemoteFetchConfigurationConstants.ErrorMessage\n+                    .ERROR_CODE_ERROR_WEB_HOOK_REMOTE_FETCH, null);\n+        }\n+\n+    }\n+\n+    /**\n+     * Method used to validate GitHub Web hook request.\n+     *\n+     * @param pushEventWebHookPOSTRequest pushEventWebHookPOSTRequest.\n+     */\n+    private void validateWebHookRequest(PushEventWebHookPOSTRequest pushEventWebHookPOSTRequest) {\n+\n+        if ((pushEventWebHookPOSTRequest.getRef() == null) || (pushEventWebHookPOSTRequest.getRepository() == null) ||\n+                (pushEventWebHookPOSTRequest.getCommits() == null)) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, WEBHOOK_REQUEST);\n+        }\n+        if (StringUtils.isBlank(pushEventWebHookPOSTRequest.getRepository().getCloneUrl())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, WEBHOOK_REQUEST);\n+        }\n+    }\n+\n+    private String populateBranch(String ref) {\n+\n+        String[] splitCredentials = ref.split(\"/\", 3);\n+        return splitCredentials[2];\n+    }\n+\n+    /**\n+     * This method is used to extract added or modified file names from the commit objects.\n+     *\n+     * @param commits List of commits\n+     * @return List of FIle names\n+     */\n+    private List<String> extractAddedAndModifiedFiles(List<PushEventWebHookPOSTRequestCommits> commits) {\n+\n+        List<String> fileNames = new ArrayList<>();\n+        if (CollectionUtils.isNotEmpty(commits)) {\n+            for (PushEventWebHookPOSTRequestCommits commit : commits) {\n+                fileNames.addAll(commit.getAdded());\n+                fileNames.addAll(commit.getModified());\n+            }\n+            return fileNames;\n+        } else {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_COMMIT_NOT_FOUND, null);\n+        }\n+    }\n+\n+    /**\n+     * This method is used to handle remote fetch core exception and create API error wit suitable response code and\n+     * status by checking its instance type.\n+     *\n+     * @param e         RemoteFetchCoreException.\n+     * @param errorEnum RemoteFetchConfigurationConstants.ErrorMessage\n+     * @param data      data\n+     * @return APIError\n+     */\n+    private APIError handleRemoteFetchConfigurationException(RemoteFetchCoreException e,\n+                                                             RemoteFetchConfigurationConstants.ErrorMessage errorEnum,\n+                                                             String data) {\n+\n+        ErrorResponse errorResponse = getErrorBuilder(errorEnum, data).build(log, e, errorEnum.getDescription());\n+\n+        Response.Status status;\n+\n+        if (e instanceof RemoteFetchClientException) {\n+            if (e.getErrorCode() != null) {\n+                String errorCode = e.getErrorCode();\n+                errorCode =\n+                        errorCode.contains(RemoteFetchConfigurationConstants.ERROR_CODE_DELIMITER) ?\n+                                errorCode : RemoteFetchConfigurationConstants.\n+                                REMOTE_FETCH_CONFIGURATION_MANAGEMENT_PREFIX + errorCode;\n+                errorResponse.setCode(errorCode);\n+            }\n+            errorResponse.setDescription(e.getMessage());\n+            status = Response.Status.BAD_REQUEST;\n+        } else if (e instanceof RemoteFetchServerException) {\n+            if (e.getErrorCode() != null) {\n+                String errorCode = e.getErrorCode();\n+                errorCode =\n+                        errorCode.contains(RemoteFetchConfigurationConstants.ERROR_CODE_DELIMITER) ?\n+                                errorCode : RemoteFetchConfigurationConstants.\n+                                REMOTE_FETCH_CONFIGURATION_MANAGEMENT_PREFIX + errorCode;\n+                errorResponse.setCode(errorCode);\n+            }\n+            errorResponse.setDescription(e.getMessage());\n+            status = Response.Status.INTERNAL_SERVER_ERROR;\n+        } else {\n+            status = Response.Status.INTERNAL_SERVER_ERROR;\n+        }\n+        return new APIError(status, errorResponse);\n+    }\n+\n+    /**\n+     * From the error message and the data this method returns error builder.\n+     *\n+     * @param errorMsg error message.\n+     * @param data     data.\n+     * @return ErrorResponse.Builder\n+     */\n+    private ErrorResponse.Builder getErrorBuilder(RemoteFetchConfigurationConstants.ErrorMessage errorMsg,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1Nzg2Ng=="}, "originalCommit": {"oid": "c1fb2dd934e5919e7461ee1a9845960ab21188a8"}, "originalPosition": 757}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA3MDQ3OA==", "bodyText": "Ack", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507070478", "createdAt": "2020-10-18T09:58:10Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/v1/core/ServerRemoteFetchConfigManagementService.java", "diffHunk": "@@ -0,0 +1,814 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.identity.api.server.fetch.remote.v1.core;\n+\n+import org.apache.commons.beanutils.BeanUtils;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.identity.api.server.common.ContextLoader;\n+import org.wso2.carbon.identity.api.server.common.error.APIError;\n+import org.wso2.carbon.identity.api.server.common.error.ErrorResponse;\n+import org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants;\n+import org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchServiceHolder;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.ActionListenerAttributes;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.PushEventWebHookPOSTRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.PushEventWebHookPOSTRequestCommits;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationGetResponse;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationListItem;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationListResponse;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationPOSTRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationPatchRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RepositoryManagerAttributes;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.StatusListItem;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.StatusListResponse;\n+import org.wso2.carbon.identity.core.util.IdentityTenantUtil;\n+import org.wso2.carbon.identity.remotefetch.common.BasicRemoteFetchConfiguration;\n+import org.wso2.carbon.identity.remotefetch.common.DeploymentRevision;\n+import org.wso2.carbon.identity.remotefetch.common.RemoteFetchConfiguration;\n+import org.wso2.carbon.identity.remotefetch.common.exceptions.RemoteFetchClientException;\n+import org.wso2.carbon.identity.remotefetch.common.exceptions.RemoteFetchCoreException;\n+import org.wso2.carbon.identity.remotefetch.common.exceptions.RemoteFetchServerException;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.OptionalInt;\n+\n+import javax.ws.rs.core.Response;\n+\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.ACTION_LISTENER;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.ACTION_LISTENER_ATTRIBUTES;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.BRANCH;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.CONFIGURATION_DEPLOYER;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.CONFIGURATION_DEPLOYER_ATTRIBUTES;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.DIRECTORY;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.FREQUENCY;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.IS_ENABLED;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.REMOTE_FETCH_NAME;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.REPOSITORY_MANAGER;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.REPOSITORY_MANAGER_ATTRIBUTES;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.URI;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants.WEBHOOK_REQUEST;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.v1.core.RemoteFetchUtils.convertDateToStringIfNotNull;\n+import static org.wso2.carbon.identity.api.server.fetch.remote.v1.core.RemoteFetchUtils.setIfNotNull;\n+\n+/**\n+ * Call internal osgi services to perform server remote fetch configuration related operations.\n+ */\n+public class ServerRemoteFetchConfigManagementService {\n+\n+    private static final Log log = LogFactory.getLog(ServerRemoteFetchConfigManagementService.class);\n+\n+    /**\n+     * Get list of remote fetch configurations.\n+     *\n+     * @return RemoteFetchConfigurationListResponse.\n+     */\n+    public RemoteFetchConfigurationListResponse getRemoteFetchConfigs() {\n+\n+        OptionalInt optionalIntLimit = OptionalInt.empty();\n+        OptionalInt optionalIntOffset = OptionalInt.empty();\n+\n+        try {\n+            return createRemoteFetchConfigurationListResponse(RemoteFetchServiceHolder.\n+                    getRemoteFetchConfigurationService()\n+                    .getBasicRemoteFetchConfigurationList(optionalIntLimit, optionalIntOffset));\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_ERROR_LISTING_RF_CONFIGS, null);\n+        }\n+    }\n+\n+    /**\n+     * Delete an Remote fetch configuration.\n+     *\n+     * @param remoteFetchConfigurationId Identity Provider resource ID.\n+     */\n+    public void deleteRemoteFetchConfig(String remoteFetchConfigurationId) {\n+\n+        try {\n+            RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                    .deleteRemoteFetchConfiguration(remoteFetchConfigurationId);\n+\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_ERROR_DELETING_RF_CONFIGS, remoteFetchConfigurationId);\n+        }\n+    }\n+\n+    /**\n+     * Get remote fetch configuration by resource Id.\n+     *\n+     * @param remoteFetchConfigurationId resource Id.\n+     * @return RemoteFetchConfigurationListResponse.\n+     */\n+    public RemoteFetchConfigurationGetResponse getRemoteFetchConfig(String remoteFetchConfigurationId) {\n+\n+        try {\n+            RemoteFetchConfiguration remoteFetchConfiguration =\n+                    RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                            .getRemoteFetchConfiguration(remoteFetchConfigurationId);\n+\n+            if (remoteFetchConfiguration == null) {\n+                throw handleException(Response.Status.NOT_FOUND, RemoteFetchConfigurationConstants.\n+                                ErrorMessage.ERROR_CODE_RE_CONFIG_NOT_FOUND,\n+                        remoteFetchConfigurationId);\n+            }\n+            return createRemoteFetchConfigurationResponse(remoteFetchConfiguration);\n+\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_ERROR_RETRIEVING_RF_CONFIG, null);\n+        }\n+    }\n+\n+    /**\n+     * Update remote fetch configuration by resource id.\n+     *\n+     * @param id                                   Id.\n+     * @param remoteFetchConfigurationPatchRequest RemoteFetchConfigurationPatchRequest.\n+     */\n+    public void updateRemoteFetchConfig(String id,\n+                                        RemoteFetchConfigurationPatchRequest remoteFetchConfigurationPatchRequest) {\n+\n+        try {\n+            RemoteFetchConfiguration remoteFetchConfiguration =\n+                    RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                            .getRemoteFetchConfiguration(id);\n+\n+            if (remoteFetchConfiguration == null) {\n+                throw handleException(Response.Status.NOT_FOUND, RemoteFetchConfigurationConstants.\n+                        ErrorMessage.ERROR_CODE_RE_CONFIG_NOT_FOUND, id);\n+            }\n+\n+            RemoteFetchConfiguration remoteFetchConfigurationToUpdate = deepCopyRemoteFetchConfiguration\n+                    (id, remoteFetchConfiguration);\n+\n+            setIfNotNull(remoteFetchConfigurationPatchRequest.getIsEnabled(),\n+                    remoteFetchConfigurationToUpdate::setEnabled);\n+\n+            setIfNotNull(remoteFetchConfigurationPatchRequest.getRemoteFetchName(),\n+                    remoteFetchConfigurationToUpdate::setRemoteFetchName);\n+\n+            RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                    .updateRemoteFetchConfiguration(remoteFetchConfigurationToUpdate);\n+\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.ErrorMessage.\n+                    ERROR_CODE_ERROR_UPDATING_RF_CONFIG, null);\n+        }\n+    }\n+\n+    /**\n+     * Trigger remote fetch.\n+     *\n+     * @param remoteFetchConfigurationId remoteFetchConfigurationId.\n+     */\n+    public void triggerRemoteFetch(String remoteFetchConfigurationId) {\n+\n+        try {\n+            RemoteFetchConfiguration remoteFetchConfiguration =\n+                    RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                            .getRemoteFetchConfiguration(remoteFetchConfigurationId);\n+\n+            if (remoteFetchConfiguration != null) {\n+                RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                        .triggerRemoteFetch(remoteFetchConfiguration);\n+            } else {\n+                throw handleException(Response.Status.NOT_FOUND, RemoteFetchConfigurationConstants.\n+                        ErrorMessage.ERROR_CODE_RE_CONFIG_NOT_FOUND, remoteFetchConfigurationId);\n+            }\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleException(Response.Status.INTERNAL_SERVER_ERROR, RemoteFetchConfigurationConstants.ErrorMessage\n+                    .ERROR_CODE_ERROR_TRIGGER_REMOTE_FETCH, remoteFetchConfigurationId);\n+        }\n+\n+    }\n+\n+    /**\n+     * Add remote fetch configuration.\n+     *\n+     * @param remoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest\n+     * @return resource id.\n+     */\n+    public String addRemoteFetchConfiguration(RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        try {\n+            validatePOSTRequest(remoteFetchConfigurationPOSTRequest);\n+            return RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                    .addRemoteFetchConfiguration(createRemoteFetchConfiguration(remoteFetchConfigurationPOSTRequest))\n+                    .getId();\n+\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleRemoteFetchConfigurationException(e, RemoteFetchConfigurationConstants.ErrorMessage.\n+                    ERROR_CODE_ERROR_ADDING_RF_CONFIG, null);\n+        }\n+    }\n+\n+    private void validatePOSTRequest(RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        if (remoteFetchConfigurationPOSTRequest.getIsEnabled() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, IS_ENABLED);\n+        }\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getRemoteFetchName())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, REMOTE_FETCH_NAME);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getActionListener() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, ACTION_LISTENER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getActionListener().getType() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, ACTION_LISTENER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getActionListener().getAttributes() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, ACTION_LISTENER_ATTRIBUTES);\n+        }\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getActionListener()\n+                .getAttributes().getFrequency())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, FREQUENCY);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getRepositoryManager() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, REPOSITORY_MANAGER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getRepositoryManager().getType() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, REPOSITORY_MANAGER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getRepositoryManager().getAttributes() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, REPOSITORY_MANAGER_ATTRIBUTES);\n+        }\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getRepositoryManager()\n+                .getAttributes().getUri())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, URI);\n+        }\n+\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getRepositoryManager()\n+                .getAttributes().getBranch())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, BRANCH);\n+        }\n+\n+        if (StringUtils.isBlank(remoteFetchConfigurationPOSTRequest.getRepositoryManager()\n+                .getAttributes().getDirectory())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, DIRECTORY);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getConfigurationDeployer() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, CONFIGURATION_DEPLOYER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getConfigurationDeployer().getType() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, CONFIGURATION_DEPLOYER);\n+        }\n+        if (remoteFetchConfigurationPOSTRequest.getConfigurationDeployer().getAttributes() == null) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, CONFIGURATION_DEPLOYER_ATTRIBUTES);\n+        }\n+    }\n+\n+    /**\n+     * Get status of remote fetch.\n+     *\n+     * @param remoteFetchConfigurationId RemoteFetchConfigurationId.\n+     */\n+    public StatusListResponse getStatus(String remoteFetchConfigurationId) {\n+\n+        try {\n+            RemoteFetchConfiguration remoteFetchConfiguration =\n+                    RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                            .getRemoteFetchConfiguration(remoteFetchConfigurationId);\n+\n+            if (remoteFetchConfiguration != null) {\n+\n+                return createStatusListResponse(RemoteFetchServiceHolder.getRemoteFetchConfigurationService()\n+                        .getDeploymentRevisions(remoteFetchConfigurationId));\n+            } else {\n+                throw handleException(Response.Status.NOT_FOUND, RemoteFetchConfigurationConstants.\n+                        ErrorMessage.ERROR_CODE_RE_CONFIG_NOT_FOUND, remoteFetchConfigurationId);\n+            }\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleException(Response.Status.INTERNAL_SERVER_ERROR, RemoteFetchConfigurationConstants.ErrorMessage\n+                    .ERROR_CODE_ERROR_STATUS_REMOTE_FETCH, remoteFetchConfigurationId);\n+        }\n+\n+    }\n+\n+    /**\n+     * This method is used to create status list from list of deployment revisions.\n+     * This method uses java stream api to count successful deployments and failed deployments.\n+     *\n+     * @param deploymentRevisions List of deployment revisions.\n+     * @return StatusListResponse.\n+     */\n+    private StatusListResponse createStatusListResponse(List<DeploymentRevision> deploymentRevisions) {\n+\n+        StatusListResponse statusListResponse = new StatusListResponse();\n+        if (CollectionUtils.isNotEmpty(deploymentRevisions)) {\n+            List<StatusListItem> statusListItemList = new ArrayList<>();\n+            for (DeploymentRevision deploymentRevision : deploymentRevisions) {\n+                StatusListItem statusListItem = populateDeploymentRevision(deploymentRevision);\n+                statusListItemList.add(statusListItem);\n+            }\n+            statusListResponse.setRemoteFetchRevisionStatuses(statusListItemList);\n+            statusListResponse.setSuccessfulDeployments(\n+                    (int) deploymentRevisions.stream()\n+                            .filter(Objects::nonNull)\n+                            .filter(deploymentRevision ->\n+                                    deploymentRevision.getDeploymentStatus().name()\n+                                            .equals(RemoteFetchConfigurationConstants.SUCCESS)).count());\n+\n+            statusListResponse.setFailedDeployments(\n+                    (int) deploymentRevisions.stream()\n+                            .filter(Objects::nonNull)\n+                            .filter(deploymentRevision ->\n+                                    deploymentRevision.getDeploymentStatus().name()\n+                                            .equals(RemoteFetchConfigurationConstants.FAIL)).count());\n+\n+            Date date = deploymentRevisions.stream()\n+                    .map(DeploymentRevision::getLastSynchronizedDate)\n+                    .max(Date::compareTo)\n+                    .orElse(null);\n+\n+            convertDateToStringIfNotNull(date, statusListResponse::setLastSynchronizedTime);\n+            return statusListResponse;\n+        } else {\n+            statusListResponse.setCount(0);\n+        }\n+        return statusListResponse;\n+    }\n+\n+    /**\n+     * Populate deployment revision to get status list item.\n+     *\n+     * @param deploymentRevision DeploymentRevision.\n+     * @return StatusListItem.\n+     */\n+    private StatusListItem populateDeploymentRevision(DeploymentRevision deploymentRevision) {\n+\n+        StatusListItem statusListItem = new StatusListItem();\n+        statusListItem.setDeployedStatus(deploymentRevision.getDeploymentStatus().name());\n+        convertDateToStringIfNotNull(deploymentRevision.getDeployedDate(), statusListItem::setDeployedTime);\n+        statusListItem.setItemName(deploymentRevision.getItemName());\n+        statusListItem.setDeploymentErrorReport(deploymentRevision.getErrorMessage());\n+        return statusListItem;\n+    }\n+\n+    /**\n+     * This method is used to create remote fetch configuration object from POST request.\n+     * First it creates three hash map from post request.\n+     * Then it set primitive attributes from post request remote fetch configuration.\n+     *\n+     * @param remoteFetchConfigurationPOSTRequest POST request.\n+     * @return RemoteFetchConfiguration.\n+     */\n+    private RemoteFetchConfiguration createRemoteFetchConfiguration\n+    (RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        RemoteFetchConfiguration remoteFetchConfiguration = new RemoteFetchConfiguration();\n+        Map<String, String> repositoryManagerAttributes =\n+                createRepositoryManagerProperties(remoteFetchConfigurationPOSTRequest);\n+        Map<String, String> actionListenerAttributes =\n+                createActionListenerProperties(remoteFetchConfigurationPOSTRequest);\n+        Map<String, String> configurationDeployerAttributes = Collections.emptyMap();\n+\n+        setIfNotNull(remoteFetchConfigurationPOSTRequest.getIsEnabled(), remoteFetchConfiguration::setEnabled);\n+        setIfNotNull(remoteFetchConfigurationPOSTRequest.getRemoteFetchName(),\n+                remoteFetchConfiguration::setRemoteFetchName);\n+\n+        remoteFetchConfiguration.setTenantId(IdentityTenantUtil\n+                .getTenantId(ContextLoader.getTenantDomainFromContext()));\n+\n+        remoteFetchConfiguration.setConfigurationDeployerType(remoteFetchConfigurationPOSTRequest\n+                .getConfigurationDeployer().getType().name());\n+        remoteFetchConfiguration.setActionListenerType(remoteFetchConfigurationPOSTRequest\n+                .getActionListener().getType().name());\n+        remoteFetchConfiguration.setRepositoryManagerType(remoteFetchConfigurationPOSTRequest\n+                .getRepositoryManager().getType().name());\n+\n+        remoteFetchConfiguration.setActionListenerAttributes(actionListenerAttributes);\n+        remoteFetchConfiguration.setRepositoryManagerAttributes(repositoryManagerAttributes);\n+        remoteFetchConfiguration.setConfigurationDeployerAttributes(configurationDeployerAttributes);\n+        return remoteFetchConfiguration;\n+\n+    }\n+\n+    /**\n+     * This method is used to create action listener hash map from POST request.\n+     *\n+     * @param remoteFetchConfigurationPOSTRequest RemoteFetchConfigurationPOSTRequest/\n+     * @return Properties.\n+     */\n+    private Map<String, String> createActionListenerProperties\n+    (RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        Map<String, String> properties = new HashMap<>();\n+        if (remoteFetchConfigurationPOSTRequest.getActionListener() != null) {\n+            ActionListenerAttributes actionListenerAttributes =\n+                    remoteFetchConfigurationPOSTRequest.getActionListener().getAttributes();\n+            if (!StringUtils.isEmpty(actionListenerAttributes.getFrequency())) {\n+                properties.put(FREQUENCY, actionListenerAttributes.getFrequency());\n+            }\n+        }\n+        return properties;\n+\n+    }\n+\n+    /**\n+     * This method is used to create Repository manager hash map from post request.\n+     *\n+     * @param remoteFetchConfigurationPOSTRequest POST request.\n+     * @return Properties.\n+     */\n+    private Map<String, String> createRepositoryManagerProperties\n+    (RemoteFetchConfigurationPOSTRequest remoteFetchConfigurationPOSTRequest) {\n+\n+        Map<String, String> properties = new HashMap<>();\n+\n+        if (remoteFetchConfigurationPOSTRequest.getRepositoryManager() != null) {\n+\n+            RepositoryManagerAttributes repositoryManagerAttributes =\n+                    remoteFetchConfigurationPOSTRequest.getRepositoryManager().getAttributes();\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getAccessToken())) {\n+                properties.put(RemoteFetchConfigurationConstants.ACCESS_TOKEN,\n+                        repositoryManagerAttributes.getAccessToken());\n+            }\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getBranch())) {\n+                properties.put(BRANCH, repositoryManagerAttributes.getBranch());\n+            }\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getDirectory())) {\n+                properties.put(RemoteFetchConfigurationConstants.DIRECTORY, repositoryManagerAttributes.getDirectory());\n+            }\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getUri())) {\n+                properties.put(URI, repositoryManagerAttributes.getUri());\n+            }\n+            if (!StringUtils.isEmpty(repositoryManagerAttributes.getUsername())) {\n+                properties.put(RemoteFetchConfigurationConstants.USER_NAME, repositoryManagerAttributes.getUsername());\n+            }\n+        }\n+\n+        return properties;\n+    }\n+\n+    /**\n+     * This method is used to create GET response from remote fetch configuration id.\n+     *\n+     * @param remoteFetchConfiguration remote fetch configuration domain object.\n+     * @return RemoteFetchConfigurationGetResponse.\n+     * @throws RemoteFetchCoreException RemoteFetchCoreException\n+     */\n+    private RemoteFetchConfigurationGetResponse createRemoteFetchConfigurationResponse\n+    (RemoteFetchConfiguration remoteFetchConfiguration) throws RemoteFetchCoreException {\n+\n+        RemoteFetchConfigurationGetResponse remoteFetchConfigurationGetResponse\n+                = new RemoteFetchConfigurationGetResponse();\n+        ActionListenerAttributes actionListenerAttributes = createActionListenerAttributeProperties\n+                (remoteFetchConfiguration);\n+\n+        RepositoryManagerAttributes repositoryManagerAttributes = createRepositoryManagerAttributeProperties\n+                (remoteFetchConfiguration);\n+\n+        remoteFetchConfigurationGetResponse.setActionListenerAttributes(actionListenerAttributes);\n+        remoteFetchConfigurationGetResponse.setRepositoryManagerAttributes(repositoryManagerAttributes);\n+        remoteFetchConfigurationGetResponse.setConfigurationDeployerAttributes(null);\n+\n+        setIfNotNull(remoteFetchConfiguration.getRemoteFetchConfigurationId(),\n+                remoteFetchConfigurationGetResponse::setId);\n+        setIfNotNull(remoteFetchConfiguration.isEnabled(),\n+                remoteFetchConfigurationGetResponse::setIsEnabled);\n+        setIfNotNull(remoteFetchConfiguration.getRemoteFetchName(),\n+                remoteFetchConfigurationGetResponse::setRemoteFetchName);\n+        setIfNotNull(remoteFetchConfiguration.getRepositoryManagerType(),\n+                remoteFetchConfigurationGetResponse::setRepositoryManagerType);\n+        setIfNotNull(remoteFetchConfiguration.getConfigurationDeployerType(),\n+                remoteFetchConfigurationGetResponse::setConfigurationDeployerType);\n+        setIfNotNull(remoteFetchConfiguration.getRepositoryManagerType(),\n+                remoteFetchConfigurationGetResponse::setRepositoryManagerType);\n+\n+        StatusListResponse statusListResponse = this.createStatusListResponse(RemoteFetchServiceHolder\n+                .getRemoteFetchConfigurationService()\n+                .getDeploymentRevisions(remoteFetchConfiguration.getRemoteFetchConfigurationId()));\n+        remoteFetchConfigurationGetResponse.setStatus(statusListResponse);\n+\n+        return remoteFetchConfigurationGetResponse;\n+    }\n+\n+    /**\n+     * This method used to create Action Listener attributes from domain object.\n+     *\n+     * @param remoteFetchConfiguration RemoteFetchConfiguration.\n+     * @return ActionListenerAttributes.\n+     */\n+    private ActionListenerAttributes createActionListenerAttributeProperties\n+    (RemoteFetchConfiguration remoteFetchConfiguration) {\n+\n+        ActionListenerAttributes actionListenerAttributes = new ActionListenerAttributes();\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getActionListenerAttributes().get(FREQUENCY),\n+                actionListenerAttributes::setFrequency);\n+        return actionListenerAttributes;\n+\n+    }\n+\n+    /**\n+     * This method is used to create Repository Manager Attributes from domain object.\n+     *\n+     * @param remoteFetchConfiguration RemoteFetchConfiguration.\n+     * @return RepositoryManagerAttributes\n+     */\n+    private RepositoryManagerAttributes createRepositoryManagerAttributeProperties\n+    (RemoteFetchConfiguration remoteFetchConfiguration) {\n+\n+        RepositoryManagerAttributes repositoryManagerAttributes = new RepositoryManagerAttributes();\n+\n+        setIfNotNull((remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(RemoteFetchConfigurationConstants.ACCESS_TOKEN)),\n+                repositoryManagerAttributes::setAccessToken);\n+\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(BRANCH),\n+                repositoryManagerAttributes::setBranch);\n+\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(RemoteFetchConfigurationConstants.DIRECTORY),\n+                repositoryManagerAttributes::setDirectory);\n+\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(URI),\n+                repositoryManagerAttributes::setUri);\n+\n+        setIfNotNull(remoteFetchConfiguration\n+                        .getRepositoryManagerAttributes().get(RemoteFetchConfigurationConstants.USER_NAME),\n+                repositoryManagerAttributes::setUsername);\n+        return repositoryManagerAttributes;\n+\n+    }\n+\n+    /**\n+     * This method is used to create list response from basic remote fetch configuration.\n+     * This method is create list item from basic remote fetch configuration list items.\n+     *\n+     * @param basicRemoteFetchConfigurationList List response.\n+     * @return RemoteFetchConfigurationListResponse.\n+     */\n+    private RemoteFetchConfigurationListResponse createRemoteFetchConfigurationListResponse\n+    (List<BasicRemoteFetchConfiguration> basicRemoteFetchConfigurationList) {\n+\n+        RemoteFetchConfigurationListResponse remoteFetchConfigurationListResponse =\n+                new RemoteFetchConfigurationListResponse();\n+        if (CollectionUtils.isNotEmpty(basicRemoteFetchConfigurationList)) {\n+            List<RemoteFetchConfigurationListItem> remoteFetchConfigurations = new ArrayList<>();\n+            for (BasicRemoteFetchConfiguration basicRemoteFetchConfiguration : basicRemoteFetchConfigurationList) {\n+                RemoteFetchConfigurationListItem remoteFetchConfigurationListItem =\n+                        populateRemoteFetchConfigurationListResponse(basicRemoteFetchConfiguration);\n+                remoteFetchConfigurations.add(remoteFetchConfigurationListItem);\n+            }\n+            remoteFetchConfigurationListResponse.setRemotefetchConfigurations(remoteFetchConfigurations);\n+            remoteFetchConfigurationListResponse.setCount(remoteFetchConfigurations.size());\n+        } else {\n+            remoteFetchConfigurationListResponse.setCount(0);\n+        }\n+        return remoteFetchConfigurationListResponse;\n+    }\n+\n+    /**\n+     * This method is used to populate remote fetch configuration list item from basic remote fetch configuration.\n+     *\n+     * @param basicRemoteFetchConfiguration basic remote fetch configuration.\n+     * @return RemoteFetchConfigurationListItem.\n+     */\n+    private RemoteFetchConfigurationListItem populateRemoteFetchConfigurationListResponse\n+    (BasicRemoteFetchConfiguration basicRemoteFetchConfiguration) {\n+\n+        RemoteFetchConfigurationListItem remoteFetchConfigurationListItem = new RemoteFetchConfigurationListItem();\n+\n+        setIfNotNull(basicRemoteFetchConfiguration.getId(), remoteFetchConfigurationListItem::setId);\n+        setIfNotNull(basicRemoteFetchConfiguration.isEnabled(), remoteFetchConfigurationListItem::setIsEnabled);\n+        setIfNotNull(basicRemoteFetchConfiguration.getActionListenerType(),\n+                remoteFetchConfigurationListItem::setActionListenerType);\n+        setIfNotNull(basicRemoteFetchConfiguration.getConfigurationDeployerType(),\n+                remoteFetchConfigurationListItem::setConfigurationDeployerType);\n+        setIfNotNull(basicRemoteFetchConfiguration.getRepositoryManagerType(),\n+                remoteFetchConfigurationListItem::setRepositoryManagerType);\n+        setIfNotNull(basicRemoteFetchConfiguration.getRemoteFetchName(),\n+                remoteFetchConfigurationListItem::setName);\n+        if (basicRemoteFetchConfiguration.getLastDeployed() == null) {\n+            remoteFetchConfigurationListItem.setLastDeployed(null);\n+        } else {\n+            convertDateToStringIfNotNull(basicRemoteFetchConfiguration.getLastDeployed(),\n+                    remoteFetchConfigurationListItem::setLastDeployed);\n+        }\n+        remoteFetchConfigurationListItem.setFailedDeployments(basicRemoteFetchConfiguration.getFailedDeployments());\n+        remoteFetchConfigurationListItem.setSuccessfulDeployments(basicRemoteFetchConfiguration.\n+                getSuccessfulDeployments());\n+\n+        return remoteFetchConfigurationListItem;\n+    }\n+\n+    /**\n+     * This method is used to handle web hook.\n+     *\n+     * @param pushEventWebHookPOSTRequest WebHook Post request\n+     */\n+    public void handleWebHook(PushEventWebHookPOSTRequest pushEventWebHookPOSTRequest) {\n+\n+        try {\n+            validateWebHookRequest(pushEventWebHookPOSTRequest);\n+            String cloneURL = pushEventWebHookPOSTRequest.getRepository().getCloneUrl();\n+            String branch = populateBranch(pushEventWebHookPOSTRequest.getRef());\n+            List<String> modifiedFiles = extractAddedAndModifiedFiles(pushEventWebHookPOSTRequest.getCommits());\n+            RemoteFetchServiceHolder\n+                    .getRemoteFetchConfigurationService().handleWebHook(cloneURL, branch, modifiedFiles);\n+        } catch (RemoteFetchCoreException e) {\n+            throw handleException(Response.Status.INTERNAL_SERVER_ERROR, RemoteFetchConfigurationConstants.ErrorMessage\n+                    .ERROR_CODE_ERROR_WEB_HOOK_REMOTE_FETCH, null);\n+        }\n+\n+    }\n+\n+    /**\n+     * Method used to validate GitHub Web hook request.\n+     *\n+     * @param pushEventWebHookPOSTRequest pushEventWebHookPOSTRequest.\n+     */\n+    private void validateWebHookRequest(PushEventWebHookPOSTRequest pushEventWebHookPOSTRequest) {\n+\n+        if ((pushEventWebHookPOSTRequest.getRef() == null) || (pushEventWebHookPOSTRequest.getRepository() == null) ||\n+                (pushEventWebHookPOSTRequest.getCommits() == null)) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, WEBHOOK_REQUEST);\n+        }\n+        if (StringUtils.isBlank(pushEventWebHookPOSTRequest.getRepository().getCloneUrl())) {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_INVALID_RE_CONFIG_INPUT, WEBHOOK_REQUEST);\n+        }\n+    }\n+\n+    private String populateBranch(String ref) {\n+\n+        String[] splitCredentials = ref.split(\"/\", 3);\n+        return splitCredentials[2];\n+    }\n+\n+    /**\n+     * This method is used to extract added or modified file names from the commit objects.\n+     *\n+     * @param commits List of commits\n+     * @return List of FIle names\n+     */\n+    private List<String> extractAddedAndModifiedFiles(List<PushEventWebHookPOSTRequestCommits> commits) {\n+\n+        List<String> fileNames = new ArrayList<>();\n+        if (CollectionUtils.isNotEmpty(commits)) {\n+            for (PushEventWebHookPOSTRequestCommits commit : commits) {\n+                fileNames.addAll(commit.getAdded());\n+                fileNames.addAll(commit.getModified());\n+            }\n+            return fileNames;\n+        } else {\n+            throw handleException(Response.Status.BAD_REQUEST, RemoteFetchConfigurationConstants.\n+                    ErrorMessage.ERROR_CODE_COMMIT_NOT_FOUND, null);\n+        }\n+    }\n+\n+    /**\n+     * This method is used to handle remote fetch core exception and create API error wit suitable response code and\n+     * status by checking its instance type.\n+     *\n+     * @param e         RemoteFetchCoreException.\n+     * @param errorEnum RemoteFetchConfigurationConstants.ErrorMessage\n+     * @param data      data\n+     * @return APIError\n+     */\n+    private APIError handleRemoteFetchConfigurationException(RemoteFetchCoreException e,\n+                                                             RemoteFetchConfigurationConstants.ErrorMessage errorEnum,\n+                                                             String data) {\n+\n+        ErrorResponse errorResponse = getErrorBuilder(errorEnum, data).build(log, e, errorEnum.getDescription());\n+\n+        Response.Status status;\n+\n+        if (e instanceof RemoteFetchClientException) {\n+            if (e.getErrorCode() != null) {\n+                String errorCode = e.getErrorCode();\n+                errorCode =\n+                        errorCode.contains(RemoteFetchConfigurationConstants.ERROR_CODE_DELIMITER) ?\n+                                errorCode : RemoteFetchConfigurationConstants.\n+                                REMOTE_FETCH_CONFIGURATION_MANAGEMENT_PREFIX + errorCode;\n+                errorResponse.setCode(errorCode);\n+            }\n+            errorResponse.setDescription(e.getMessage());\n+            status = Response.Status.BAD_REQUEST;\n+        } else if (e instanceof RemoteFetchServerException) {\n+            if (e.getErrorCode() != null) {\n+                String errorCode = e.getErrorCode();\n+                errorCode =\n+                        errorCode.contains(RemoteFetchConfigurationConstants.ERROR_CODE_DELIMITER) ?\n+                                errorCode : RemoteFetchConfigurationConstants.\n+                                REMOTE_FETCH_CONFIGURATION_MANAGEMENT_PREFIX + errorCode;\n+                errorResponse.setCode(errorCode);\n+            }\n+            errorResponse.setDescription(e.getMessage());\n+            status = Response.Status.INTERNAL_SERVER_ERROR;\n+        } else {\n+            status = Response.Status.INTERNAL_SERVER_ERROR;\n+        }\n+        return new APIError(status, errorResponse);\n+    }\n+\n+    /**\n+     * From the error message and the data this method returns error builder.\n+     *\n+     * @param errorMsg error message.\n+     * @param data     data.\n+     * @return ErrorResponse.Builder\n+     */\n+    private ErrorResponse.Builder getErrorBuilder(RemoteFetchConfigurationConstants.ErrorMessage errorMsg,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1Nzg2Ng=="}, "originalCommit": {"oid": "c1fb2dd934e5919e7461ee1a9845960ab21188a8"}, "originalPosition": 757}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjIyNzE1OnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTozMzo1MVrOHjklvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTozMzo1MVrOHjklvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA2MTY5NQ==", "bodyText": "Update to the v0.7.12", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507061695", "createdAt": "2020-10-18T09:33:51Z", "author": {"login": "darshanasbg"}, "path": "pom.xml", "diffHunk": "@@ -528,6 +546,7 @@\n         <mavan.findbugsplugin.exclude.file>findbugs-exclude-filter.xml</mavan.findbugsplugin.exclude.file>\n         <carbon.kernel.version>4.6.1-m5</carbon.kernel.version>\n         <carbon.multitenancy.version>4.8.6</carbon.multitenancy.version>\n+        <org.wso2.carbon.identity.remotefetch.version>0.7.11</org.wso2.carbon.identity.remotefetch.version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed36f59846ea90f74ef01dd6d690d6b4c3d73902"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjIyNzU0OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/main/resources/META-INF/cxf/rfc-server-v1-cxf.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTozNDoxOVrOHjkmFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTozNDoxOVrOHjkmFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA2MTc4MA==", "bodyText": "Add a new line.", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507061780", "createdAt": "2020-10-18T09:34:19Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/main/resources/META-INF/cxf/rfc-server-v1-cxf.xml", "diffHunk": "@@ -0,0 +1,29 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+  ~\n+  ~ WSO2 Inc. licenses this file to you under the Apache License,\n+  ~ Version 2.0 (the \"License\"); you may not use this file except\n+  ~ in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~ http://www.apache.org/licenses/LICENSE-2.0\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing,\n+  ~ software distributed under the License is distributed on an\n+  ~ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  ~ KIND, either express or implied.  See the License for the\n+  ~ specific language governing permissions and limitations\n+  ~ under the License.\n+  -->\n+\n+<beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jaxrs=\"http://cxf.apache.org/jaxrs\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd\">\n+    <bean class=\"org.wso2.carbon.identity.api.server.fetch.remote.v1.core.ServerRemoteFetchConfigManagementService\"/>\n+    <bean class=\"org.wso2.carbon.identity.api.server.fetch.remote.v1.impl.RemoteFetchApiServiceImpl\"/>\n+    <bean id=\"remoteFetchConfigurationServiceFactoryBean\"\n+          class=\"org.wso2.carbon.identity.api.server.fetch.remote.common.factory.RemoteFetchConfigurationServiceFactory\"/>\n+    <bean id=\"remoteFetchServiceHolderBean\"\n+          class=\"org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchServiceHolder\">\n+        <property name=\"remoteFetchConfigurationService\" ref=\"remoteFetchConfigurationServiceFactoryBean\"/>\n+    </bean>\n+</beans>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed36f59846ea90f74ef01dd6d690d6b4c3d73902"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjIyODE2OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/main/resources/fetch-remote.yaml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTozNDozOVrOHjkmfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTozNDozOVrOHjkmfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA2MTg4NA==", "bodyText": "Add a new line.", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507061884", "createdAt": "2020-10-18T09:34:39Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/main/resources/fetch-remote.yaml", "diffHunk": "@@ -0,0 +1,1073 @@\n+openapi: 3.0.0\n+info:\n+  description: >\n+    This document specifies an **Remote Fetch Configuration RESTful API** for\n+    **WSO2 Identity Server**. This supports Restful APIs for reomtefetch\n+    configuration management. The APIs provide the capability to\n+    add/update/delete/patch remotefetch configurations in the identity server.\n+    In addition, APIs are available to trigger revision deployement for given\n+    remote fetch configuration.\n+  version: \"v1\"\n+  title: WSO2 Identity Server - Remotedetch Configuration Management API definition\n+  termsOfService: 'http://swagger.io/terms/'\n+  contact:\n+    name: WSO2\n+    url: 'http://wso2.com/products/identity-server/'\n+    email: architecture@wso2.org\n+  license:\n+    name: Apache 2.0\n+    url: 'http://www.apache.org/licenses/LICENSE-2.0.html'\n+security:\n+  - OAuth2: []\n+  - BasicAuth: []\n+paths:\n+  /remote-fetch:\n+    get:\n+      tags:\n+        - Remote Fetch Configurations\n+      summary: |\n+        List remote fetch configurations\n+      description:\n+        This API provides the capability to retrieve the list of remotefetch\n+        configurations.<br> <b>Permission required:</b> <br>\n+        * None <br>\n+        <b>Scope required:</b> <br>\n+        * internal_login\n+      operationId: getRemoteFetchConfigs\n+      responses:\n+        '200':\n+          description: Successful Response\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/RemoteFetchConfigurationListResponse'\n+        '400':\n+          description: Bad Request\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '401':\n+          description: Unauthorized\n+        '403':\n+          description: Forbidden\n+        '404':\n+          description: Not Found\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '500':\n+          description: Server Error\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '501':\n+          description: Not Implemented\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+    post:\n+      tags:\n+        - Remote Fetch Configurations\n+      summary: |\n+        Add a new remotefetch configuration\n+      description: >\n+        This API provides the capability to create a new remotefetch\n+        configuration. <br>\n+\n+        <b>Permission required:</b> <br>\n+            * None <br>\n+        <b>Scope required:</b> <br>\n+            * internal_login\n+      operationId: addRemoteFetch\n+      responses:\n+        '201':\n+          description: Successfully created.\n+          headers:\n+            Location:\n+              description: Location of the newly created remotefetch configuration.\n+              schema:\n+                type: string\n+        '400':\n+          description: Bad Request\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+            application/xml:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '401':\n+          description: Unauthorized\n+        '403':\n+          description: Forbidden\n+        '409':\n+          description: Conflict\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+            application/xml:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '500':\n+          description: Server Error\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+            application/xml:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+      requestBody:\n+        content:\n+          application/json:\n+            schema:\n+              $ref: '#/components/schemas/RemoteFetchConfigurationPOSTRequest'\n+          application/xml:\n+            schema:\n+              $ref: '#/components/schemas/RemoteFetchConfigurationPOSTRequest'\n+        description: This represents the remotefetch configuration to be created.\n+        required: true\n+  '/remote-fetch/{id}':\n+    get:\n+      tags:\n+        - Remote Fetch Configurations\n+      summary: |\n+        Retrieve remotefetch Configuration by remotefetch Configuration's ID\n+      description: >\n+        This API provides the capability to retrieve the Remote Fetch\n+        Configuration details by using its ID.<br> <b>Permission required:</b>\n+        <br>\n+            * None <br>\n+        <b>Scope required:</b> <br>\n+            * internal_login\n+      operationId: getRemoteFetch\n+      parameters:\n+        - name: id\n+          in: path\n+          description: ID of the remotefetch Configuration.\n+          required: true\n+          schema:\n+            type: string\n+      responses:\n+        '200':\n+          description: Successful response\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/RemoteFetchConfigurationGetResponse'\n+            application/xml:\n+              schema:\n+                $ref: '#/components/schemas/RemoteFetchConfigurationGetResponse'\n+        '400':\n+          description: Bad Request\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+            application/xml:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '401':\n+          description: Unauthorized\n+        '403':\n+          description: Forbidden\n+        '404':\n+          description: Not Found\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+            application/xml:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '500':\n+          description: Server Error\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+            application/xml:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+    patch:\n+      tags:\n+        - Remote Fetch Configurations\n+      summary: |\n+        Patch a remotefetch Configuration property by ID.\n+      description: >\n+        This API provides the capability to update a remotefetch Configuration\n+        property using patch request. Patch is supported only for key-value\n+        pairs. <br> <b>Permission required:</b> <br>\n+            * None <br>\n+        <b>Scope required:</b> <br>\n+            * internal_login\n+      operationId: updateRemoteFetch\n+      parameters:\n+        - name: id\n+          in: path\n+          description: ID of the remotefetch Configuration.\n+          required: true\n+          schema:\n+            type: string\n+      responses:\n+        '200':\n+          description: Successfully Updated\n+        '400':\n+          description: Bad Request\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '401':\n+          description: Unauthorized\n+        '403':\n+          description: Forbidden\n+        '404':\n+          description: Not Found\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '500':\n+          description: Server Error\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+      requestBody:\n+        content:\n+          application/json:\n+            schema:\n+              $ref: '#/components/schemas/RemoteFetchConfigurationPatchRequest'\n+        required: true\n+    delete:\n+      tags:\n+        - Remote Fetch Configurations\n+      summary: >\n+        Delete a remotefetch Configuration by using the remotefetch\n+        Configuration's ID.\n+      description: >\n+        This API provides the capability to delete a remotefetch Configuration\n+        by giving its ID. <br> <b>Permission required:</b> <br>\n+            * None <br>\n+        <b>Scope required:</b> <br>\n+            * internal_login\n+      operationId: deleteRemoteFetch\n+      parameters:\n+        - name: id\n+          in: path\n+          description: ID of the remotefetch Configuration\n+          required: true\n+          schema:\n+            type: string\n+      responses:\n+        '204':\n+          description: Successfully Deleted\n+        '400':\n+          description: Bad Request\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '401':\n+          description: Unauthorized\n+        '403':\n+          description: Forbidden\n+        '404':\n+          description: Not Found\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '500':\n+          description: Server Error\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+  '/remote-fetch/{id}/trigger':\n+    post:\n+      tags:\n+        - Remote fetch Configuration Trigger\n+      summary: |\n+        Trigger a remote fetch configuration.\n+      description: >\n+        This API pprovides the capability to trigger given remotefetch\n+        configuration. <br> <b>Permission required:</b> <br>\n+            * None <br>\n+        <b>Scope required:</b> <br>\n+            * internal_login\n+      operationId: triggerRemoteFetch\n+      parameters:\n+        - name: id\n+          in: path\n+          description: ID of the remote fetch configuration.\n+          required: true\n+          schema:\n+            type: string\n+      responses:\n+        '202':\n+          description: Accepted.\n+          headers:\n+            Location:\n+              description: Location of the triggered remotefetch configuration.\n+              schema:\n+                type: string\n+        '400':\n+          description: Bad Request\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '401':\n+          description: Unauthorized\n+        '403':\n+          description: Forbidden\n+        '404':\n+          description: Not Found\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '500':\n+          description: Server Error\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+  '/remote-fetch/{id}/status':\n+    get:\n+      tags:\n+        - Remote fetch Configuration Status\n+      summary: |\n+        Retrieve latest Deployment status of remotefetch configuration.\n+      description: >\n+        This API provides the status of remote fetch configuration. The status\n+        hold deployment status and the deployment failure details . <br>\n+        <b>Permission required:</b> <br>\n+            * None <br>\n+        <b>Scope required:</b> <br>\n+            * internal_login\n+      operationId: getStatus\n+      parameters:\n+        - name: id\n+          in: path\n+          description: ID of the remote fetch configuration.\n+          required: true\n+          schema:\n+            type: string\n+      responses:\n+        '200':\n+          description: Successful Response\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/StatusListResponse'\n+        '400':\n+          description: Bad Request\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '401':\n+          description: Unauthorized\n+        '403':\n+          description: Forbidden\n+        '404':\n+          description: Not Found\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '500':\n+          description: Server Error\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+  '/remote-fetch/webhook/sp':\n+    post:\n+      tags:\n+        - Remote Fetch Webhook\n+      summary: |\n+        Web hook endpoint for remote fetch configuration.\n+      description: >\n+        This API provides the capability to handle web hook request from remote repository. <br>\n+      operationId: handleWebHook\n+      responses:\n+        '202':\n+          description: Successful Response\n+        '400':\n+          description: Bad Request\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '401':\n+          description: Unauthorized\n+        '403':\n+          description: Forbidden\n+        '404':\n+          description: Not Found\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+        '500':\n+          description: Server Error\n+          content:\n+            application/json:\n+              schema:\n+                $ref: '#/components/schemas/Error'\n+      requestBody:\n+        content:\n+          application/json:\n+            schema:\n+              $ref: '#/components/schemas/PushEventWebHookPOSTRequest'\n+          application/xml:\n+            schema:\n+              $ref: '#/components/schemas/PushEventWebHookPOSTRequest'\n+servers:\n+  # Added by API Auto Mocking Plugin\n+  - description: SwaggerHub API Auto Mocking\n+    url: https://virtserver.swaggerhub.com/Thumimku/Remotefetch/v1\n+  - description: SwaggerHub API Auto Mocking\n+    url: 'https://virtserver.swaggerhub.com/Thumimku/Remotedetch/v1'\n+  - url: 'https://localhost:9443/t/{tenant-domain}/api/server/v1'\n+    variables:\n+      tenant-domain:\n+        default: carbon.super\n+components:\n+  parameters:\n+    limitQueryParam:\n+      in: query\n+      name: limit\n+      required: false\n+      description: |\n+        Maximum number of records to return.\n+      schema:\n+        type: integer\n+        format: int32\n+    offsetQueryParam:\n+      in: query\n+      name: offset\n+      required: false\n+      description: |\n+        Number of records to skip for pagination.\n+      schema:\n+        type: integer\n+        format: int32\n+    filterQueryParam:\n+      in: query\n+      name: filter\n+      required: false\n+      description: >\n+        Condition to filter the retrieval of records. Supports 'sw', 'co', 'ew'\n+        and 'eq' operations and also complex queries with 'and' operations. E.g.\n+        /identity-providers?filter=name+sw+\"google\"+and+isEnabled+eq+\"true\"\n+      schema:\n+        type: string\n+    sortQueryParam:\n+      in: query\n+      name: sortOrder\n+      required: false\n+      description: |\n+        Defines the order in which the retrieved records should be sorted.\n+        _This parameter is not supported yet_\n+      schema:\n+        type: string\n+        enum:\n+          - ASC\n+          - DESC\n+    sortByQueryParam:\n+      in: query\n+      name: sortBy\n+      required: false\n+      description: |\n+        Attribute by which the retrieved records should be sorted.\n+        _This parameter is not supported yet_\n+      schema:\n+        type: string\n+    requiredAttributesQueryParam:\n+      in: query\n+      name: requiredAttributes\n+      required: false\n+      description: |\n+        Specifies the required parameters in the response.\n+        _This parameter is not supported yet_\n+      schema:\n+        type: string\n+  securitySchemes:\n+    BasicAuth:\n+      type: http\n+      scheme: basic\n+    OAuth2:\n+      type: oauth2\n+      flows:\n+        authorizationCode:\n+          authorizationUrl: 'https://localhost:9443/oauth/authorize'\n+          tokenUrl: 'https://localhost:9443/oauth/token'\n+          scopes: {}\n+  schemas:\n+    Error:\n+      type: object\n+      properties:\n+        code:\n+          type: string\n+          example: RFE-00000\n+        message:\n+          type: string\n+          example: Some Error Message\n+        description:\n+          type: string\n+          example: Some Error Description\n+        traceId:\n+          type: string\n+          example: e0fbcfeb-3617-43c4-8dd0-7b7d38e13047\n+    RemoteFetchConfigurationListResponse:\n+      type: object\n+      properties:\n+        count:\n+          type: integer\n+          example: 10\n+        remotefetchConfigurations:\n+          type: array\n+          items:\n+            $ref: '#/components/schemas/RemoteFetchConfigurationListItem'\n+    StatusListResponse:\n+      type: object\n+      properties:\n+        count:\n+          type: integer\n+          example: 10\n+        successfulDeployments:\n+          type: integer\n+          example: 1\n+        failedDeployments:\n+          type: integer\n+          example: 1\n+        lastSynchronizedTime:\n+          type: string\n+          example: '2020-03-29 07:36:08.0'\n+        remoteFetchRevisionStatuses:\n+          type: array\n+          items:\n+            $ref: '#/components/schemas/StatusListItem'\n+    RemoteFetchConfigurationListItem:\n+      type: object\n+      properties:\n+        id:\n+          type: string\n+          example: 00000000-13e9-4ed5-afaf-000000000000\n+        isEnabled:\n+          type: boolean\n+          default: true\n+          example: true\n+        name:\n+          type: string\n+          example: testSP\n+        repositoryManagerType:\n+          type: string\n+          example: GIT\n+        actionListenerType:\n+          type: string\n+          example: POOLING\n+        configurationDeployerType:\n+          type: string\n+          example: SP\n+        successfulDeployments:\n+          type: integer\n+          example: 1\n+        failedDeployments:\n+          type: integer\n+          example: 1\n+        lastDeployed:\n+          type: string\n+          example: 10-04-2020\n+    StatusListItem:\n+      type: object\n+      properties:\n+        itemName:\n+          type: string\n+          example: pickup\n+        deployedTime:\n+          type: string\n+          example: '2020-03-29 07:36:08.0'\n+        deployedStatus:\n+          type: string\n+          example: SUCCESS\n+        deploymentErrorReport:\n+          type: string\n+          example: \"Service Provider Deployment Error Occured\"\n+    RemoteFetchConfigurationPOSTRequest:\n+      type: object\n+      properties:\n+        remoteFetchName:\n+          type: string\n+          example: testSP\n+        isEnabled:\n+          type: boolean\n+          default: true\n+          example: true\n+        repositoryManager:\n+          $ref: '#/components/schemas/RepositoryManager'\n+        actionListener:\n+          $ref: '#/components/schemas/ActionListener'\n+        configurationDeployer:\n+          $ref: '#/components/schemas/ConfigurationDeployer'\n+    RemoteFetchConfigurationPatchRequest:\n+      type: object\n+      properties:\n+        remoteFetchName:\n+          type: string\n+          example: testSP\n+        isEnabled:\n+          type: boolean\n+          default: true\n+          example: true\n+    RepositoryManager:\n+      type: object\n+      properties:\n+        type:\n+          type: string\n+          description: The operation to be performed\n+          enum:\n+            - GIT\n+          example: GIT\n+        attributes:\n+          $ref: '#/components/schemas/RepositoryManagerAttributes'\n+    RepositoryManagerAttributes:\n+      type: object\n+      properties:\n+        accessToken:\n+          type: string\n+          example: sample access token\n+        username:\n+          type: string\n+          example: Jhon Doe\n+        uri:\n+          type: string\n+          example: 'https://github.com/TestUser/TestGit.git'\n+        branch:\n+          type: string\n+          example: master\n+        directory:\n+          type: string\n+          example: SP/\n+    ActionListener:\n+      type: object\n+      properties:\n+        type:\n+          type: string\n+          description: The operation to be performed\n+          enum:\n+            - POLLING\n+            - WEB HOOK\n+          example: WEB HOOK\n+        attributes:\n+          $ref: '#/components/schemas/ActionListenerAttributes'\n+    ActionListenerAttributes:\n+      type: object\n+      properties:\n+        frequency:\n+          type: string\n+          example: 60\n+    ConfigurationDeployer:\n+      type: object\n+      properties:\n+        type:\n+          type: string\n+          description: The operation to be performed\n+          enum:\n+            - SP\n+          example: SP\n+        attributes:\n+          $ref: '#/components/schemas/ConfigurationDeployerAttributes'\n+    ConfigurationDeployerAttributes:\n+      type: object\n+    RemoteFetchConfigurationGetResponse:\n+      type: object\n+      properties:\n+        id:\n+          type: string\n+          example: 00000000-13e9-4ed5-afaf-000000000000\n+        isEnabled:\n+          type: boolean\n+          default: true\n+          example: true\n+        remoteFetchName:\n+          type: string\n+          example: testSP\n+        repositoryManagerType:\n+          type: string\n+          example: GIT\n+        actionListenerType:\n+          type: string\n+          example: POOLING\n+        configurationDeployerType:\n+          type: string\n+          example: SP\n+        repositoryManagerAttributes:\n+          $ref: '#/components/schemas/RepositoryManagerAttributes'\n+        actionListenerAttributes:\n+          $ref: '#/components/schemas/ActionListenerAttributes'\n+        configurationDeployerAttributes:\n+          $ref: '#/components/schemas/ConfigurationDeployerAttributes'\n+        status:\n+          $ref: '#/components/schemas/StatusListResponse'\n+    PushEventWebHookPOSTRequest:\n+      type: object\n+      properties:\n+        ref:\n+          type: string\n+        before:\n+          type: string\n+        after:\n+          type: string\n+        created:\n+          type: boolean\n+        deleted:\n+          type: boolean\n+        forced:\n+          type: boolean\n+        base_ref:\n+          type: string\n+        compare:\n+          type: string\n+        pusher:\n+          type: object\n+          properties:\n+            name:\n+              type: string\n+            email:\n+              type: string\n+        sender:\n+          type: object\n+          properties:\n+            login:\n+              type: string\n+            id:\n+              type: integer\n+            node_id:\n+              type: string\n+            avatar_url:\n+              type: string\n+            gravatar_id:\n+              type: string\n+            url:\n+              type: string\n+            html_url:\n+              type: string\n+            followers_url:\n+              type: string\n+            following_url:\n+              type: string\n+            gists_url:\n+              type: string\n+            starred_url:\n+              type: string\n+            subscriptions_url:\n+              type: string\n+            organizations_url:\n+              type: string\n+            repos_url:\n+              type: string\n+            events_url:\n+              type: string\n+            received_events_url:\n+              type: string\n+            type:\n+              type: string\n+            site_admin:\n+              type: boolean\n+        commits:\n+          type: array\n+          items:\n+            type: object\n+            properties:\n+              id:\n+                type: string\n+              tree_id:\n+                type: string\n+              distinct:\n+                type: boolean\n+              message:\n+                type: string\n+              timestamp:\n+                type: string\n+              url:\n+                type: string\n+              author:\n+                type: object\n+                properties:\n+                  username:\n+                    type: string\n+                  name:\n+                    type: string\n+                  email:\n+                    type: string\n+              committer:\n+                type: object\n+                properties:\n+                  name:\n+                    type: string\n+                  email:\n+                    type: string\n+                  username:\n+                    type: string\n+              added:\n+                type: array\n+                items:\n+                  type: string\n+              removed:\n+                type: array\n+                items:\n+                  type: string\n+              modified:\n+                type: array\n+                items:\n+                  type: string\n+        head_commit:\n+          type: object\n+          properties:\n+            id:\n+              type: string\n+            tree_id:\n+              type: string\n+            distinct:\n+              type: boolean\n+            message:\n+              type: string\n+            timestamp:\n+              type: string\n+            url:\n+              type: string\n+            author:\n+              type: object\n+              properties:\n+                username:\n+                  type: string\n+                name:\n+                  type: string\n+                email:\n+                  type: string\n+            committer:\n+              type: object\n+              properties:\n+                name:\n+                  type: string\n+                email:\n+                  type: string\n+                username:\n+                  type: string\n+            added:\n+              type: array\n+              items:\n+                type: string\n+            removed:\n+              type: array\n+              items:\n+                type: string\n+            modified:\n+              type: array\n+              items:\n+                type: string\n+        repository:\n+          type: object\n+          properties:\n+            id:\n+              type: integer\n+            node_id:\n+              type: string\n+            name:\n+              type: string\n+            full_name:\n+              type: string\n+            private:\n+              type: boolean\n+            owner:\n+              type: object\n+              properties:\n+                name:\n+                  type: string\n+                email:\n+                  type: string\n+                login:\n+                  type: string\n+                id:\n+                  type: integer\n+                node_id:\n+                  type: string\n+                avatar_url:\n+                  type: string\n+                gravatar_id:\n+                  type: string\n+                url:\n+                  type: string\n+                html_url:\n+                  type: string\n+                followers_url:\n+                  type: string\n+                following_url:\n+                  type: string\n+                gists_url:\n+                  type: string\n+                starred_url:\n+                  type: string\n+                subscriptions_url:\n+                  type: string\n+                organizations_url:\n+                  type: string\n+                repos_url:\n+                  type: string\n+                events_url:\n+                  type: string\n+                received_events_url:\n+                  type: string\n+                type:\n+                  type: string\n+                site_admin:\n+                  type: boolean\n+            html_url:\n+              type: string\n+            description:\n+              type: string\n+            fork:\n+              type: boolean\n+            url:\n+              type: string\n+            forks_url:\n+              type: string\n+            keys_url:\n+              type: string\n+            collaborators_url:\n+              type: string\n+            teams_url:\n+              type: string\n+            hooks_url:\n+              type: string\n+            issue_events_url:\n+              type: string\n+            events_url:\n+              type: string\n+            assignees_url:\n+              type: string\n+            branches_url:\n+              type: string\n+            tags_url:\n+              type: string\n+            blobs_url:\n+              type: string\n+            git_tags_url:\n+              type: string\n+            git_refs_url:\n+              type: string\n+            trees_url:\n+              type: string\n+            statuses_url:\n+              type: string\n+            languages_url:\n+              type: string\n+            stargazers_url:\n+              type: string\n+            contributors_url:\n+              type: string\n+            subscribers_url:\n+              type: string\n+            subscription_url:\n+              type: string\n+            commits_url:\n+              type: string\n+            git_commits_url:\n+              type: string\n+            comments_url:\n+              type: string\n+            issue_comment_url:\n+              type: string\n+            contents_url:\n+              type: string\n+            compare_url:\n+              type: string\n+            merges_url:\n+              type: string\n+            archive_url:\n+              type: string\n+            downloads_url:\n+              type: string\n+            issues_url:\n+              type: string\n+            pulls_url:\n+              type: string\n+            milestones_url:\n+              type: string\n+            notifications_url:\n+              type: string\n+            labels_url:\n+              type: string\n+            releases_url:\n+              type: string\n+            deployments_url:\n+              type: string\n+            created_at:\n+              type: integer\n+            updated_at:\n+              type: string\n+            pushed_at:\n+              type: integer\n+            git_url:\n+              type: string\n+            ssh_url:\n+              type: string\n+            clone_url:\n+              type: string\n+            svn_url:\n+              type: string\n+            homepage:\n+              type: string\n+            size:\n+              type: integer\n+            stargazers_count:\n+              type: integer\n+            watchers_count:\n+              type: integer\n+            language:\n+              type: string\n+            has_issues:\n+              type: boolean\n+            has_projects:\n+              type: boolean\n+            has_downloads:\n+              type: boolean\n+            has_wiki:\n+              type: boolean\n+            has_pages:\n+              type: boolean\n+            forks_count:\n+              type: integer\n+            mirror_url:\n+              type: string\n+            archived:\n+              type: boolean\n+            disabled:\n+              type: boolean\n+            open_issues_count:\n+              type: integer\n+            license:\n+              type: string\n+            forks:\n+              type: integer\n+            open_issues:\n+              type: integer\n+            watchers:\n+              type: integer\n+            default_branch:\n+              type: string\n+            stargazers:\n+              type: integer\n+            master_branch:\n+              type: string", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed36f59846ea90f74ef01dd6d690d6b4c3d73902"}, "originalPosition": 1073}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjI4MDYxOnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/v1/impl/RemoteFetchApiServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTo1ODozNFrOHjlI2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTo1ODozNFrOHjlI2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA3MDY4MQ==", "bodyText": "Remove additional new line.", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507070681", "createdAt": "2020-10-18T09:58:34Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/v1/impl/RemoteFetchApiServiceImpl.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+* Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+*\n+* Licensed under the Apache License, Version 2.0 (the \"License\");\n+* you may not use this file except in compliance with the License.\n+* You may obtain a copy of the License at\n+*\n+* http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.wso2.carbon.identity.api.server.fetch.remote.v1.impl;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.wso2.carbon.identity.api.server.common.Constants;\n+import org.wso2.carbon.identity.api.server.common.ContextLoader;\n+import org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.RemoteFetchApiService;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.core.ServerRemoteFetchConfigManagementService;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.PushEventWebHookPOSTRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationListResponse;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationPOSTRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationPatchRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.StatusListResponse;\n+\n+import java.net.URI;\n+import javax.ws.rs.core.Response;\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46b821859ce0c9cfd57a1aed680fa623b7bd1f6d"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjI4MzM4OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/v1/impl/RemoteFetchApiServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTo1OTo0NFrOHjlKvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTo1OTo0NFrOHjlKvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA3MTE2Nw==", "bodyText": "Remove additional new line.", "url": "https://github.com/wso2/identity-api-server/pull/212#discussion_r507071167", "createdAt": "2020-10-18T09:59:44Z", "author": {"login": "darshanasbg"}, "path": "components/org.wso2.carbon.identity.api.server.fetch.remote/org.wso2.carbon.identity.api.server.fetch.remote.v1/src/main/java/org/wso2/carbon/identity/api/server/fetch/remote/v1/impl/RemoteFetchApiServiceImpl.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+* Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+*\n+* Licensed under the Apache License, Version 2.0 (the \"License\");\n+* you may not use this file except in compliance with the License.\n+* You may obtain a copy of the License at\n+*\n+* http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.wso2.carbon.identity.api.server.fetch.remote.v1.impl;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.wso2.carbon.identity.api.server.common.Constants;\n+import org.wso2.carbon.identity.api.server.common.ContextLoader;\n+import org.wso2.carbon.identity.api.server.fetch.remote.common.RemoteFetchConfigurationConstants;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.RemoteFetchApiService;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.core.ServerRemoteFetchConfigManagementService;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.PushEventWebHookPOSTRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationListResponse;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationPOSTRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.RemoteFetchConfigurationPatchRequest;\n+import org.wso2.carbon.identity.api.server.fetch.remote.v1.model.StatusListResponse;\n+\n+import java.net.URI;\n+import javax.ws.rs.core.Response;\n+\n+\n+/**\n+ * Implementation of the Remote Fetch Rest API.\n+ */\n+public class RemoteFetchApiServiceImpl implements RemoteFetchApiService {\n+\n+    @Autowired\n+    private ServerRemoteFetchConfigManagementService serverRemoteFetchConfigManagementService;\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46b821859ce0c9cfd57a1aed680fa623b7bd1f6d"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1508, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}