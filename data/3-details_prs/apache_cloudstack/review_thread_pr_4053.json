{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNzM2OTQ0", "number": 4053, "reviewThreads": {"totalCount": 51, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNzo1ODo0N1rOD6jdTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwODozMDo0M1rOEkbRng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzI0OTQzOnYy", "diffSide": "RIGHT", "path": "engine/storage/src/main/java/org/apache/cloudstack/storage/image/BaseImageStoreDriverImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNzo1ODo0N1rOGSdCxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTowOTozOVrOGSe-lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAwMzM5OQ==", "bodyText": "can you extract this bit like sendToLeastBusyEndPoint()?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422003399", "createdAt": "2020-05-08T07:58:47Z", "author": {"login": "DaanHoogland"}, "path": "engine/storage/src/main/java/org/apache/cloudstack/storage/image/BaseImageStoreDriverImpl.java", "diffHunk": "@@ -373,32 +375,26 @@ public void copyAsync(DataObject srcdata, DataObject destData, AsyncCompletionCa\n                 s_logger.error(errMsg);\n                 answer = new Answer(cmd, false, errMsg);\n             } else {\n-                boolean sent = false;\n-                // Find the first endpoint to which the command can be sent to\n-                for (EndPoint ep : eps) {\n-                    if (getCopyCmdsCountToSpecificSSVM(ep.getId()) >= maxConcurrentCopyOpsPerSSVM) {\n-                        continue;\n+                // select endpoint with least number of commands running on them\n+                EndPoint endPoint = null;\n+                Long epId = ssvmWithLeastMigrateJobs();\n+                if (epId == null) {\n+                    Collections.shuffle(eps);\n+                    endPoint = eps.get(0);\n+                } else {\n+                    List<EndPoint> remainingEps = eps.stream().filter(ep -> ep.getId() != epId ).collect(Collectors.toList());\n+                    if (!remainingEps.isEmpty()) {\n+                        Collections.shuffle(remainingEps);\n+                        endPoint = remainingEps.get(0);\n+                    } else {\n+                        endPoint = _defaultEpSelector.getEndPointFromHostId(epId);\n                     }\n-\n-                    CommandExecLogVO execLog = new CommandExecLogVO(ep.getId(), _secStorageVmDao.findByInstanceName(hostDao.findById(ep.getId()).getName()).getId(), cmd.getClass().getSimpleName(), 1);\n-                    Long cmdExecId = _cmdExecLogDao.persist(execLog).getId();\n-                    answer = ep.sendMessage(cmd);\n-                    answer.setContextParam(\"cmd\", cmdExecId.toString());\n-                    sent = true;\n-                    break;\n-                }\n-                // If both SSVMs are pre-occupied with tasks, choose the SSVM with least migrate jobs\n-                if (!sent) {\n-                    // Picking endpoint with least number of copy commands running on it\n-                    Long epId = ssvmWithLeastMigrateJobs();\n-                    EndPoint endPoint = _defaultEpSelector.getEndPointFromHostId(epId);\n-                    CommandExecLogVO execLog = new CommandExecLogVO(epId, _secStorageVmDao.findByInstanceName(hostDao.findById(epId).getName()).getId(), cmd.getClass().getSimpleName(), 1);\n-                    Long cmdExecId = _cmdExecLogDao.persist(execLog).getId();\n-                    answer = endPoint.sendMessage(cmd);\n-                    answer.setContextParam(\"cmd\", cmdExecId.toString());\n                 }\n+                CommandExecLogVO execLog = new CommandExecLogVO(endPoint.getId(), _secStorageVmDao.findByInstanceName(hostDao.findById(endPoint.getId()).getName()).getId(), cmd.getClass().getSimpleName(), 1);\n+                Long cmdExecId = _cmdExecLogDao.persist(execLog).getId();\n+                answer = endPoint.sendMessage(cmd);\n+                answer.setContextParam(\"cmd\", cmdExecId.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "082c7c73853b95ec40846aaf7b0f1229152740d5"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAzNTA5Mw==", "bodyText": "Done", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422035093", "createdAt": "2020-05-08T09:09:39Z", "author": {"login": "Pearl1594"}, "path": "engine/storage/src/main/java/org/apache/cloudstack/storage/image/BaseImageStoreDriverImpl.java", "diffHunk": "@@ -373,32 +375,26 @@ public void copyAsync(DataObject srcdata, DataObject destData, AsyncCompletionCa\n                 s_logger.error(errMsg);\n                 answer = new Answer(cmd, false, errMsg);\n             } else {\n-                boolean sent = false;\n-                // Find the first endpoint to which the command can be sent to\n-                for (EndPoint ep : eps) {\n-                    if (getCopyCmdsCountToSpecificSSVM(ep.getId()) >= maxConcurrentCopyOpsPerSSVM) {\n-                        continue;\n+                // select endpoint with least number of commands running on them\n+                EndPoint endPoint = null;\n+                Long epId = ssvmWithLeastMigrateJobs();\n+                if (epId == null) {\n+                    Collections.shuffle(eps);\n+                    endPoint = eps.get(0);\n+                } else {\n+                    List<EndPoint> remainingEps = eps.stream().filter(ep -> ep.getId() != epId ).collect(Collectors.toList());\n+                    if (!remainingEps.isEmpty()) {\n+                        Collections.shuffle(remainingEps);\n+                        endPoint = remainingEps.get(0);\n+                    } else {\n+                        endPoint = _defaultEpSelector.getEndPointFromHostId(epId);\n                     }\n-\n-                    CommandExecLogVO execLog = new CommandExecLogVO(ep.getId(), _secStorageVmDao.findByInstanceName(hostDao.findById(ep.getId()).getName()).getId(), cmd.getClass().getSimpleName(), 1);\n-                    Long cmdExecId = _cmdExecLogDao.persist(execLog).getId();\n-                    answer = ep.sendMessage(cmd);\n-                    answer.setContextParam(\"cmd\", cmdExecId.toString());\n-                    sent = true;\n-                    break;\n-                }\n-                // If both SSVMs are pre-occupied with tasks, choose the SSVM with least migrate jobs\n-                if (!sent) {\n-                    // Picking endpoint with least number of copy commands running on it\n-                    Long epId = ssvmWithLeastMigrateJobs();\n-                    EndPoint endPoint = _defaultEpSelector.getEndPointFromHostId(epId);\n-                    CommandExecLogVO execLog = new CommandExecLogVO(epId, _secStorageVmDao.findByInstanceName(hostDao.findById(epId).getName()).getId(), cmd.getClass().getSimpleName(), 1);\n-                    Long cmdExecId = _cmdExecLogDao.persist(execLog).getId();\n-                    answer = endPoint.sendMessage(cmd);\n-                    answer.setContextParam(\"cmd\", cmdExecId.toString());\n                 }\n+                CommandExecLogVO execLog = new CommandExecLogVO(endPoint.getId(), _secStorageVmDao.findByInstanceName(hostDao.findById(endPoint.getId()).getName()).getId(), cmd.getClass().getSimpleName(), 1);\n+                Long cmdExecId = _cmdExecLogDao.persist(execLog).getId();\n+                answer = endPoint.sendMessage(cmd);\n+                answer.setContextParam(\"cmd\", cmdExecId.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAwMzM5OQ=="}, "originalCommit": {"oid": "082c7c73853b95ec40846aaf7b0f1229152740d5"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzQ5MDE1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/ApiConstants.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOToyMzo0MFrOGSfWgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTozNzozNVrOGTYhCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MTIxOQ==", "bodyText": "how is this used in the API? I could imagine a name like srcStore or srcImage would be more appropriate.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422041219", "createdAt": "2020-05-08T09:23:40Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/org/apache/cloudstack/api/ApiConstants.java", "diffHunk": "@@ -777,6 +780,7 @@\n     public static final String EXITCODE = \"exitcode\";\n     public static final String TARGET_ID = \"targetid\";\n     public static final String FILES = \"files\";\n+    public static final String FROM = \"from\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA4MDAyMg==", "bodyText": "the API is more:\nmigrate secondarystoragedata from=<> migrateto=<> migrationtype=<> ..\nHowever, I could refactor that", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422080022", "createdAt": "2020-05-08T10:57:51Z", "author": {"login": "Pearl1594"}, "path": "api/src/main/java/org/apache/cloudstack/api/ApiConstants.java", "diffHunk": "@@ -777,6 +780,7 @@\n     public static final String EXITCODE = \"exitcode\";\n     public static final String TARGET_ID = \"targetid\";\n     public static final String FILES = \"files\";\n+    public static final String FROM = \"from\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MTIxOQ=="}, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3NzgwMQ==", "bodyText": "done", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422977801", "createdAt": "2020-05-11T11:37:35Z", "author": {"login": "Pearl1594"}, "path": "api/src/main/java/org/apache/cloudstack/api/ApiConstants.java", "diffHunk": "@@ -777,6 +780,7 @@\n     public static final String EXITCODE = \"exitcode\";\n     public static final String TARGET_ID = \"targetid\";\n     public static final String FILES = \"files\";\n+    public static final String FROM = \"from\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MTIxOQ=="}, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzQ5MzYxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/cloud/storage/ImageStoreService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOToyNDozNlrOGSfYeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTozNzo1MVrOGTYhlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MTcyMg==", "bodyText": "new classes should go into org.apache.cloudstack.*", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422041722", "createdAt": "2020-05-08T09:24:36Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/com/cloud/storage/ImageStoreService.java", "diffHunk": "@@ -0,0 +1,29 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package com.cloud.storage;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3Nzk0Mw==", "bodyText": "moved the file to appropriate pkg", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422977943", "createdAt": "2020-05-11T11:37:51Z", "author": {"login": "Pearl1594"}, "path": "api/src/main/java/com/cloud/storage/ImageStoreService.java", "diffHunk": "@@ -0,0 +1,29 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package com.cloud.storage;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MTcyMg=="}, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzUwMzk0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOToyODoyNFrOGSfe6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTozODoxN1rOGTYiXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MzM3MA==", "bodyText": "I think these should be called sourcePool and destinationPools. In light of conventions srcpool and destpools` are best, I think.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422043370", "createdAt": "2020-05-08T09:28:24Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",\n+        authorized = {RoleType.Admin})\n+public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n+\n+    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n+\n+    public static final String APINAME = \"migrateSecondaryStorageData\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    @Parameter(name = ApiConstants.FROM,\n+            type = CommandType.UUID,\n+            entityType = ImageStoreResponse.class,\n+            description = \"id of the image store from where the data is to be migrated\",\n+    required = true)\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.MIGRATE_TO,\n+    type = CommandType.LIST,\n+    collectionType = CommandType.UUID,\n+    entityType = ImageStoreResponse.class,\n+    description = \"id of the destination secondary storage pool to which the templates are to be migrated to\",\n+    required = true)\n+    private List<Long> migrateTo;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODE0Mg==", "bodyText": "done", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978142", "createdAt": "2020-05-11T11:38:17Z", "author": {"login": "Pearl1594"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",\n+        authorized = {RoleType.Admin})\n+public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n+\n+    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n+\n+    public static final String APINAME = \"migrateSecondaryStorageData\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    @Parameter(name = ApiConstants.FROM,\n+            type = CommandType.UUID,\n+            entityType = ImageStoreResponse.class,\n+            description = \"id of the image store from where the data is to be migrated\",\n+    required = true)\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.MIGRATE_TO,\n+    type = CommandType.LIST,\n+    collectionType = CommandType.UUID,\n+    entityType = ImageStoreResponse.class,\n+    description = \"id of the destination secondary storage pool to which the templates are to be migrated to\",\n+    required = true)\n+    private List<Long> migrateTo;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MzM3MA=="}, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzUxNTE2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTozMjoyOFrOGSflyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTozODoyMlrOGTYihA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0NTEzMA==", "bodyText": "id(s) of the destination storage pool(s) and remove the last to from the sentence", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422045130", "createdAt": "2020-05-08T09:32:28Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",\n+        authorized = {RoleType.Admin})\n+public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n+\n+    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n+\n+    public static final String APINAME = \"migrateSecondaryStorageData\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    @Parameter(name = ApiConstants.FROM,\n+            type = CommandType.UUID,\n+            entityType = ImageStoreResponse.class,\n+            description = \"id of the image store from where the data is to be migrated\",\n+    required = true)\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.MIGRATE_TO,\n+    type = CommandType.LIST,\n+    collectionType = CommandType.UUID,\n+    entityType = ImageStoreResponse.class,\n+    description = \"id of the destination secondary storage pool to which the templates are to be migrated to\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODE4MA==", "bodyText": "done", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978180", "createdAt": "2020-05-11T11:38:22Z", "author": {"login": "Pearl1594"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",\n+        authorized = {RoleType.Admin})\n+public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n+\n+    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n+\n+    public static final String APINAME = \"migrateSecondaryStorageData\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    @Parameter(name = ApiConstants.FROM,\n+            type = CommandType.UUID,\n+            entityType = ImageStoreResponse.class,\n+            description = \"id of the image store from where the data is to be migrated\",\n+    required = true)\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.MIGRATE_TO,\n+    type = CommandType.LIST,\n+    collectionType = CommandType.UUID,\n+    entityType = ImageStoreResponse.class,\n+    description = \"id of the destination secondary storage pool to which the templates are to be migrated to\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0NTEzMA=="}, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzUyMDI2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTozNDoxM1rOGSfo0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTozODozM1rOGTYi2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0NTkwNg==", "bodyText": "why is this required, isn't Complete a reasonable default? making this required lays unnecessary burdon on the user.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422045906", "createdAt": "2020-05-08T09:34:13Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",\n+        authorized = {RoleType.Admin})\n+public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n+\n+    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n+\n+    public static final String APINAME = \"migrateSecondaryStorageData\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    @Parameter(name = ApiConstants.FROM,\n+            type = CommandType.UUID,\n+            entityType = ImageStoreResponse.class,\n+            description = \"id of the image store from where the data is to be migrated\",\n+    required = true)\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.MIGRATE_TO,\n+    type = CommandType.LIST,\n+    collectionType = CommandType.UUID,\n+    entityType = ImageStoreResponse.class,\n+    description = \"id of the destination secondary storage pool to which the templates are to be migrated to\",\n+    required = true)\n+    private List<Long> migrateTo;\n+\n+    @Parameter(name = ApiConstants.MIGRATION_TYPE,\n+    type = CommandType.STRING,\n+    description = \"Balance: if you want data to be distributed evenly among the destination stores, \" +\n+            \"Complete: If you want to migrate the entire data from source image store to the destination store(s)\",\n+    required = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODI2NQ==", "bodyText": "Made complete migration as default action", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978265", "createdAt": "2020-05-11T11:38:33Z", "author": {"login": "Pearl1594"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",\n+        authorized = {RoleType.Admin})\n+public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n+\n+    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n+\n+    public static final String APINAME = \"migrateSecondaryStorageData\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    @Parameter(name = ApiConstants.FROM,\n+            type = CommandType.UUID,\n+            entityType = ImageStoreResponse.class,\n+            description = \"id of the image store from where the data is to be migrated\",\n+    required = true)\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.MIGRATE_TO,\n+    type = CommandType.LIST,\n+    collectionType = CommandType.UUID,\n+    entityType = ImageStoreResponse.class,\n+    description = \"id of the destination secondary storage pool to which the templates are to be migrated to\",\n+    required = true)\n+    private List<Long> migrateTo;\n+\n+    @Parameter(name = ApiConstants.MIGRATION_TYPE,\n+    type = CommandType.STRING,\n+    description = \"Balance: if you want data to be distributed evenly among the destination stores, \" +\n+            \"Complete: If you want to migrate the entire data from source image store to the destination store(s)\",\n+    required = true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0NTkwNg=="}, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzU1MjY5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo0NTo1M1rOGSf8MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo0NTo1M1rOGSf8MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1MDg2NQ==", "bodyText": "Why throw so many different exceptions? we can catch most of them and give nice consise error messages in a ServerApiException, right?\nMost of these are Runtime exception.\nMentioning them here is also redundant as they are declared in BaseCmd as well.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422050865", "createdAt": "2020-05-08T09:45:53Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",\n+        authorized = {RoleType.Admin})\n+public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n+\n+    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n+\n+    public static final String APINAME = \"migrateSecondaryStorageData\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    @Parameter(name = ApiConstants.FROM,\n+            type = CommandType.UUID,\n+            entityType = ImageStoreResponse.class,\n+            description = \"id of the image store from where the data is to be migrated\",\n+    required = true)\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.MIGRATE_TO,\n+    type = CommandType.LIST,\n+    collectionType = CommandType.UUID,\n+    entityType = ImageStoreResponse.class,\n+    description = \"id of the destination secondary storage pool to which the templates are to be migrated to\",\n+    required = true)\n+    private List<Long> migrateTo;\n+\n+    @Parameter(name = ApiConstants.MIGRATION_TYPE,\n+    type = CommandType.STRING,\n+    description = \"Balance: if you want data to be distributed evenly among the destination stores, \" +\n+            \"Complete: If you want to migrate the entire data from source image store to the destination store(s)\",\n+    required = true)\n+    private String migrationType;\n+\n+    /////////////////////////////////////////////////////\n+    /////////////////// Accessors ///////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public List<Long> getMigrateTo() {\n+        return migrateTo;\n+    }\n+\n+    public String getMigrationType() {\n+        return migrationType;\n+    }\n+\n+    @Override\n+    public String getEventType() {\n+        return EventTypes.EVENT_FILE_MIGRATE;\n+    }\n+\n+    @Override\n+    public String getEventDescription() {\n+        return \"Attempting to migrate files/data objects \" + \"from : \" + this.getId() + \" to: \" + StringUtils.join(getMigrateTo(), \",\");\n+    }\n+\n+    @Override\n+    public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzU1NzEyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo0NzoxN1rOGSf-xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo0NzoxN1rOGSf-xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1MTUyNw==", "bodyText": "same as above in MigrateSecondaryStorageDataCmd", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422051527", "createdAt": "2020-05-08T09:47:17Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java", "diffHunk": "@@ -0,0 +1,93 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.ApiErrorCode;\n+import org.apache.cloudstack.api.BaseCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+\n+@APICommand(name = UpdateImageStoreCmd.APINAME, description = \"Updates image store read-only status\", responseObject = ImageStoreResponse.class, entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false, responseHasSensitiveInfo = false)\n+public class UpdateImageStoreCmd extends BaseCmd {\n+    private static final Logger LOG = Logger.getLogger(UpdateImageStoreCmd.class.getName());\n+    public static final String APINAME = \"updateImageStore\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+    @Parameter(name = ApiConstants.ID, type = CommandType.UUID, entityType = ImageStoreResponse.class, required = true, description = \"Image Store UUID\")\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.READ_ONLY, type = CommandType.BOOLEAN, required = true, description = \"If set to true, it designates the corresponding image store to read-only\")\n+    private Boolean readonly;\n+\n+    /////////////////////////////////////////////////////\n+    /////////////////// Accessors ///////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public Boolean getReadonly() {\n+        return readonly;\n+    }\n+\n+    /////////////////////////////////////////////////////\n+    /////////////// API Implementation///////////////////\n+    /////////////////////////////////////////////////////\n+\n+    @Override\n+    public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzU2NDc5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo0OTo1NlrOGSgDVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo0OTo1NlrOGSgDVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1MjY5Mg==", "bodyText": "can you expand on the usefullness of a store being read-only in this - or the API description? I.E. something like (in better English): \"useful for deprecating image stores during storage migrations\"", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422052692", "createdAt": "2020-05-08T09:49:56Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java", "diffHunk": "@@ -0,0 +1,93 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.ApiErrorCode;\n+import org.apache.cloudstack.api.BaseCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+\n+@APICommand(name = UpdateImageStoreCmd.APINAME, description = \"Updates image store read-only status\", responseObject = ImageStoreResponse.class, entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false, responseHasSensitiveInfo = false)\n+public class UpdateImageStoreCmd extends BaseCmd {\n+    private static final Logger LOG = Logger.getLogger(UpdateImageStoreCmd.class.getName());\n+    public static final String APINAME = \"updateImageStore\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+    @Parameter(name = ApiConstants.ID, type = CommandType.UUID, entityType = ImageStoreResponse.class, required = true, description = \"Image Store UUID\")\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.READ_ONLY, type = CommandType.BOOLEAN, required = true, description = \"If set to true, it designates the corresponding image store to read-only\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228c70377490297afe68779d622bc8c7eff1fb86"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzU4MDk4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/response/MigrationResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo1NTo0MlrOGSgM_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo1NTo0MlrOGSgM_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1NTE2NA==", "bodyText": "A user might wonder what this means: \"Where does the messsage come from and what will it signify for me?\" Can you expand on that, please?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422055164", "createdAt": "2020-05-08T09:55:42Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/org/apache/cloudstack/api/response/MigrationResponse.java", "diffHunk": "@@ -0,0 +1,73 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.response;\n+\n+import org.apache.cloudstack.api.BaseResponse;\n+import org.apache.cloudstack.api.EntityReference;\n+\n+import com.cloud.serializer.Param;\n+import com.cloud.storage.ImageStore;\n+import com.google.gson.annotations.SerializedName;\n+\n+@EntityReference(value = ImageStore.class)\n+public class MigrationResponse extends BaseResponse {\n+    @SerializedName(\"message\")\n+    @Param(description = \"Response message\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzU4NzY5OnYy", "diffSide": "RIGHT", "path": "engine/api/src/main/java/org/apache/cloudstack/engine/subsystem/api/storage/ObjectInDataStoreStateMachine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo1ODowOFrOGSgRUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo1ODowOFrOGSgRUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1NjI3Mg==", "bodyText": "I don't understand this comment, should it still be here or was it only there as development aid?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422056272", "createdAt": "2020-05-08T09:58:08Z", "author": {"login": "DaanHoogland"}, "path": "engine/api/src/main/java/org/apache/cloudstack/engine/subsystem/api/storage/ObjectInDataStoreStateMachine.java", "diffHunk": "@@ -49,8 +50,12 @@ public String getDescription() {\n         DestroyRequested,\n         OperationSuccessed,\n         OperationFailed,\n+        // Added as volume converts migrationrequested to copyrequested - VolumeObject.java", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzU5MzYwOnYy", "diffSide": "LEFT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/VolumeOrchestrator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDowMDoxOVrOGSgVCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDowMDoxOVrOGSgVCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1NzIyNQ==", "bodyText": "makes sense but will lead possibly to unecessary conflicts during rebases, which are inevitable for this PR", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422057225", "createdAt": "2020-05-08T10:00:19Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/VolumeOrchestrator.java", "diffHunk": "@@ -141,7 +141,6 @@\n import com.cloud.vm.dao.UserVmDao;\n \n public class VolumeOrchestrator extends ManagerBase implements VolumeOrchestrationService, Configurable {\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzYwMDc2OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/secstorage/CommandExecLogDaoImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDowMjo1OVrOGSgZfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDowMjo1OVrOGSgZfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1ODM2Nw==", "bodyText": "?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422058367", "createdAt": "2020-05-08T10:02:59Z", "author": {"login": "DaanHoogland"}, "path": "engine/schema/src/main/java/com/cloud/secstorage/CommandExecLogDaoImpl.java", "diffHunk": "@@ -43,4 +48,15 @@ public void expungeExpiredRecords(Date cutTime) {\n         sc.setParameters(\"created\", cutTime);\n         expunge(sc);\n     }\n+\n+    @Override\n+    public Integer getCopyCmdCountForSSVM(Long id) {\n+        SearchCriteria<CommandExecLogVO> sc = CommandSearch.create();\n+        sc.setParameters(\"host_id\", id);\n+        sc.setParameters(\"command_name\", \"CopyCommand\");\n+        List<CommandExecLogVO> copyCmds = customSearch(sc, null);\n+        return copyCmds.size();\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzYwODkxOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDao.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDowNjoxN1rOGSgekQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDowNjoxN1rOGSgekQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1OTY2NQ==", "bodyText": "this method name is confusing: findByScope but than the scope is allready set to ZoneScope? Wouldn't findByZone be better?\nAlso the method above could probably just be extended with a flag for excludeReadOnly.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422059665", "createdAt": "2020-05-08T10:06:17Z", "author": {"login": "DaanHoogland"}, "path": "engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDao.java", "diffHunk": "@@ -31,6 +31,8 @@\n \n     List<ImageStoreVO> findByScope(ZoneScope scope);\n \n+    List<ImageStoreVO> findByScopeExcludingReadOnly(ZoneScope scope);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzYxMTU4OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDaoImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDowNzoyMVrOGSggPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDowNzoyMVrOGSggPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2MDA5Mw==", "bodyText": "so this line could be surrounded by if (readonlyExcludedFlag == true) {}", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422060093", "createdAt": "2020-05-08T10:07:21Z", "author": {"login": "DaanHoogland"}, "path": "engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDaoImpl.java", "diffHunk": "@@ -91,6 +91,20 @@ public ImageStoreVO findByName(String name) {\n         return listBy(sc);\n     }\n \n+    @Override\n+    public List<ImageStoreVO> findByScopeExcludingReadOnly(ZoneScope scope) {\n+        SearchCriteria<ImageStoreVO> sc = createSearchCriteria();\n+        sc.addAnd(\"role\", SearchCriteria.Op.EQ, DataStoreRole.Image);\n+        if (scope.getScopeId() != null) {\n+            SearchCriteria<ImageStoreVO> scc = createSearchCriteria();\n+            scc.addOr(\"scope\", SearchCriteria.Op.EQ, ScopeType.REGION);\n+            scc.addOr(\"dcId\", SearchCriteria.Op.EQ, scope.getScopeId());\n+            sc.addAnd(\"scope\", SearchCriteria.Op.SC, scc);\n+            sc.addAnd(\"readonly\", SearchCriteria.Op.EQ, Boolean.FALSE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzYxNzg2OnYy", "diffSide": "RIGHT", "path": "engine/storage/datamotion/src/main/java/org/apache/cloudstack/storage/motion/DataMotionServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDowOTo0M1rOGSgj9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDowOTo0M1rOGSgj9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2MTA0Nw==", "bodyText": "unecessary conlict potential", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422061047", "createdAt": "2020-05-08T10:09:43Z", "author": {"login": "DaanHoogland"}, "path": "engine/storage/datamotion/src/main/java/org/apache/cloudstack/storage/motion/DataMotionServiceImpl.java", "diffHunk": "@@ -39,9 +33,14 @@\n import org.apache.cloudstack.engine.subsystem.api.storage.StorageStrategyFactory;\n import org.apache.cloudstack.engine.subsystem.api.storage.VolumeInfo;\n import org.apache.cloudstack.framework.async.AsyncCompletionCallback;\n+import org.apache.log4j.Logger;\n+import org.springframework.stereotype.Component;\n \n import com.cloud.agent.api.to.VirtualMachineTO;\n import com.cloud.host.Host;\n+import com.cloud.storage.Volume;\n+import com.cloud.storage.VolumeVO;\n+import com.cloud.storage.dao.VolumeDao;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzYzOTMyOnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDoxODoxNFrOGSgxHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODowMDowOVrOGX_taA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NDQxNQ==", "bodyText": "this method is way too long. please modularise it into byte size chunks and factor it out to a worker - or utility class?\nI can not set a rule but in my opinion any method larger than 20 line or any class larger than 300 lines is probably not separating concerns.\nevery comment in this method should probably be converted to a good method name and extracted, and so should many top level blocks (if-, for- and while statements", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422064415", "createdAt": "2020-05-08T10:18:14Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODQ0Nw==", "bodyText": "Created a utility class", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978447", "createdAt": "2020-05-11T11:38:54Z", "author": {"login": "Pearl1594"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NDQxNQ=="}, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5OTc4NA==", "bodyText": "It is still 112 lines and there are a lot of comments in it that could serve as method names. This would help make the code more prozaic and thus easier to read. This method could do with some modularisation.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426699784", "createdAt": "2020-05-18T15:12:50Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NDQxNQ=="}, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxNDI0OA==", "bodyText": "75 lines, still big but i slowly get the picture ;)", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427814248", "createdAt": "2020-05-20T08:00:09Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NDQxNQ=="}, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzY0OTQ5OnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDoyMjoxOFrOGSg3QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTozOTowNFrOGTYj2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NTk4NQ==", "bodyText": "example extraction: above code could go in checkCompleteMigrationFor ReadyVolumesOnly(...)", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422065985", "createdAt": "2020-05-08T10:22:18Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {\n+        List<DataObject> files = new LinkedList<>();\n+        int successCount = 0;\n+        boolean success = true;\n+        String message = null;\n+\n+        if (migrationPolicy == MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODUyMw==", "bodyText": "done", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978523", "createdAt": "2020-05-11T11:39:04Z", "author": {"login": "Pearl1594"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {\n+        List<DataObject> files = new LinkedList<>();\n+        int successCount = 0;\n+        boolean success = true;\n+        String message = null;\n+\n+        if (migrationPolicy == MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NTk4NQ=="}, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzY1MDk1OnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDoyMzowMVrOGSg4MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTozOTowOVrOGTYkAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NjIyNQ==", "bodyText": "or: prepareSourcesList(...)", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422066225", "createdAt": "2020-05-08T10:23:01Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {\n+        List<DataObject> files = new LinkedList<>();\n+        int successCount = 0;\n+        boolean success = true;\n+        String message = null;\n+\n+        if (migrationPolicy == MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+\n+        DataStore srcDatastore = dataStoreManager.getDataStore(srcDataStoreId, DataStoreRole.Image);\n+        Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains = new HashMap<>();\n+        files.addAll(getAllValidTemplates(srcDatastore));\n+        files.addAll(getAllValidSnapshotChains(srcDatastore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDatastore));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODU2Mg==", "bodyText": "done", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978562", "createdAt": "2020-05-11T11:39:09Z", "author": {"login": "Pearl1594"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {\n+        List<DataObject> files = new LinkedList<>();\n+        int successCount = 0;\n+        boolean success = true;\n+        String message = null;\n+\n+        if (migrationPolicy == MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+\n+        DataStore srcDatastore = dataStoreManager.getDataStore(srcDataStoreId, DataStoreRole.Image);\n+        Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains = new HashMap<>();\n+        files.addAll(getAllValidTemplates(srcDatastore));\n+        files.addAll(getAllValidSnapshotChains(srcDatastore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDatastore));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NjIyNQ=="}, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzY1NjEzOnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDoyNDo1OFrOGSg7YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTozOToxNlrOGTYkRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NzA0MQ==", "bodyText": "sortSources(...), should probably be called from prepareSourcesList()`\netc.\netc.\nhope you get my drift. The code looks good but this is about maintainability. happy to discuss.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422067041", "createdAt": "2020-05-08T10:24:58Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {\n+        List<DataObject> files = new LinkedList<>();\n+        int successCount = 0;\n+        boolean success = true;\n+        String message = null;\n+\n+        if (migrationPolicy == MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+\n+        DataStore srcDatastore = dataStoreManager.getDataStore(srcDataStoreId, DataStoreRole.Image);\n+        Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains = new HashMap<>();\n+        files.addAll(getAllValidTemplates(srcDatastore));\n+        files.addAll(getAllValidSnapshotChains(srcDatastore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDatastore));\n+\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                //return o2.getSize() > o1.getSize() ? 1 : -1;\n+                return size2 > size1 ? 1 : -1;\n+            }\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODYyOQ==", "bodyText": "done", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978629", "createdAt": "2020-05-11T11:39:16Z", "author": {"login": "Pearl1594"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {\n+        List<DataObject> files = new LinkedList<>();\n+        int successCount = 0;\n+        boolean success = true;\n+        String message = null;\n+\n+        if (migrationPolicy == MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+\n+        DataStore srcDatastore = dataStoreManager.getDataStore(srcDataStoreId, DataStoreRole.Image);\n+        Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains = new HashMap<>();\n+        files.addAll(getAllValidTemplates(srcDatastore));\n+        files.addAll(getAllValidSnapshotChains(srcDatastore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDatastore));\n+\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                //return o2.getSize() > o1.getSize() ? 1 : -1;\n+                return size2 > size1 ? 1 : -1;\n+            }\n+        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NzA0MQ=="}, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzY3NTg2OnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDozMjowOVrOGShGxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTozOToyMVrOGTYkZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2OTk1OA==", "bodyText": "so never 0? Can we return size2 - size1?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422069958", "createdAt": "2020-05-08T10:32:09Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {\n+        List<DataObject> files = new LinkedList<>();\n+        int successCount = 0;\n+        boolean success = true;\n+        String message = null;\n+\n+        if (migrationPolicy == MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+\n+        DataStore srcDatastore = dataStoreManager.getDataStore(srcDataStoreId, DataStoreRole.Image);\n+        Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains = new HashMap<>();\n+        files.addAll(getAllValidTemplates(srcDatastore));\n+        files.addAll(getAllValidSnapshotChains(srcDatastore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDatastore));\n+\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                //return o2.getSize() > o1.getSize() ? 1 : -1;\n+                return size2 > size1 ? 1 : -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODY2Mg==", "bodyText": "done", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978662", "createdAt": "2020-05-11T11:39:21Z", "author": {"login": "Pearl1594"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {\n+        List<DataObject> files = new LinkedList<>();\n+        int successCount = 0;\n+        boolean success = true;\n+        String message = null;\n+\n+        if (migrationPolicy == MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+\n+        DataStore srcDatastore = dataStoreManager.getDataStore(srcDataStoreId, DataStoreRole.Image);\n+        Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains = new HashMap<>();\n+        files.addAll(getAllValidTemplates(srcDatastore));\n+        files.addAll(getAllValidSnapshotChains(srcDatastore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDatastore));\n+\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                //return o2.getSize() > o1.getSize() ? 1 : -1;\n+                return size2 > size1 ? 1 : -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2OTk1OA=="}, "originalCommit": {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzIwNzIwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDowOTo0NVrOGW46Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDowOTo0NVrOGW46Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1NDIzNA==", "bodyText": "we wont make \"4.14.0\" ;)", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426654234", "createdAt": "2020-05-18T14:09:45Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,115 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzIxMDMzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/ListImageStoresCmd.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDoxMDoyOVrOGW48GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDoxMDoyOVrOGW48GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1NDc0NQ==", "bodyText": "please add since = \"4.15\"", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426654745", "createdAt": "2020-05-18T14:10:29Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/ListImageStoresCmd.java", "diffHunk": "@@ -52,6 +51,9 @@\n     @Parameter(name = ApiConstants.ID, type = CommandType.UUID, entityType = ImageStoreResponse.class, description = \"the ID of the storage pool\")\n     private Long id;\n \n+    @Parameter(name = ApiConstants.READ_ONLY, type = CommandType.BOOLEAN, entityType = ImageStoreResponse.class, description = \"read-only status of the image store\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzIxNTkzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDoxMTo0MFrOGW4_hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDoxMTo0MFrOGW4_hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1NTYyMQ==", "bodyText": "this naming convention is not advices for static final fields rather use LOG or LOGGER", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426655621", "createdAt": "2020-05-18T14:11:40Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,115 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",\n+        authorized = {RoleType.Admin})\n+public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n+\n+    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzIyMzU4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDoxMzoxOFrOGW5EUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDoxMzoxOFrOGW5EUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1Njg1MQ==", "bodyText": "can you add since = \"4.15\"", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426656851", "createdAt": "2020-05-18T14:13:18Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java", "diffHunk": "@@ -0,0 +1,89 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.ApiErrorCode;\n+import org.apache.cloudstack.api.BaseCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.storage.ImageStore;\n+\n+@APICommand(name = UpdateImageStoreCmd.APINAME, description = \"Updates image store read-only status\", responseObject = ImageStoreResponse.class, entityType = {ImageStore.class},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzI2OTI2OnYy", "diffSide": "RIGHT", "path": "services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDoyMzoxNlrOGW5gQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDoyMzoxNlrOGW5gQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY2NDAwMw==", "bodyText": "some kind of indentation problem here. The method is a bit to long for a clear view on what happened. Can you modularise it a bit more, please? Also there is more than one return points, which makes the flow hard to follow.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426664003", "createdAt": "2020-05-18T14:23:16Z", "author": {"login": "DaanHoogland"}, "path": "services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java", "diffHunk": "@@ -1285,6 +1288,75 @@ protected File findFile(String path) {\n         return srcFile;\n     }\n \n+    protected Answer copyFromNfsToNfs(CopyCommand cmd) {\n+        final DataTO srcData = cmd.getSrcTO();\n+        final DataTO destData = cmd.getDestTO();\n+        DataStoreTO srcDataStore = srcData.getDataStore();\n+        NfsTO srcStore = (NfsTO)srcDataStore;\n+        DataStoreTO destDataStore = destData.getDataStore();\n+        final NfsTO destStore = (NfsTO) destDataStore;\n+        try {\n+            File srcFile = new File(getDir(srcStore.getUrl(), _nfsVersion), srcData.getPath());\n+            File destFile = new File(getDir(destStore.getUrl(), _nfsVersion), destData.getPath());\n+            ImageFormat format = getTemplateFormat(srcFile.getName());\n+\n+            if (srcFile == null) {\n+                return new CopyCmdAnswer(\"Can't find src file:\" + srcFile);\n+            }\n+\n+            if (srcData instanceof TemplateObjectTO || srcData instanceof VolumeObjectTO) {\n+                File srcDir = null;\n+                if (srcFile.isFile()) {\n+                    srcDir = new File(srcFile.getParent());\n+                }\n+                File destDir = null;\n+                if (destFile.isFile()) {\n+                    destDir = new File(destFile.getParent());\n+                }\n+\n+                try {\n+                    FileUtils.copyDirectory((srcDir == null ? srcFile : srcDir), (destDir == null? destFile : destDir));\n+                } catch (IOException e) {\n+                    String msg = \"Failed to copy file to destination\";\n+                    s_logger.info(msg);\n+                    return new CopyCmdAnswer(msg);\n+                }\n+            } else {\n+                destFile = new File(destFile, srcFile.getName());\n+                try {\n+                    FileUtils.copyFile(srcFile, destFile);\n+                } catch (IOException e) {\n+                    String msg = \"Failed to copy file to destination\";\n+                    s_logger.info(msg);\n+                    return new CopyCmdAnswer(msg);\n+                }\n+            }\n+\n+            DataTO retObj = null;\n+            if (destData.getObjectType() == DataObjectType.TEMPLATE) {\n+                TemplateObjectTO newTemplate = new TemplateObjectTO();\n+                newTemplate.setPath(destData.getPath() + File.separator + srcFile.getName());\n+                newTemplate.setSize(getVirtualSize(srcFile, format));\n+                newTemplate.setPhysicalSize(srcFile.length());\n+                newTemplate.setFormat(format);\n+                retObj = newTemplate;\n+            } else if (destData.getObjectType() == DataObjectType.VOLUME) {\n+                VolumeObjectTO newVol = new VolumeObjectTO();\n+                newVol.setPath(destData.getPath() + File.separator + srcFile.getName());\n+                newVol.setSize(srcFile.length());\n+                retObj = newVol;\n+            } else if (destData.getObjectType() == DataObjectType.SNAPSHOT) {\n+                SnapshotObjectTO newSnapshot = new SnapshotObjectTO();\n+                newSnapshot.setPath(destData.getPath() + File.separator + destFile.getName());\n+                retObj = newSnapshot;\n+            }\n+            return new CopyCmdAnswer(retObj);\n+            } catch (Exception e) {\n+            s_logger.error(\"failed to copy file\" + srcData.getPath(), e);\n+            return new CopyCmdAnswer(\"failed to copy file\" + srcData.getPath() + e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzI4MjQzOnYy", "diffSide": "RIGHT", "path": "services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDoyNjoxOFrOGW5ogQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDoyNjoxOFrOGW5ogQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY2NjExMw==", "bodyText": "please factor out in a suitably named method.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426666113", "createdAt": "2020-05-18T14:26:18Z", "author": {"login": "DaanHoogland"}, "path": "services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java", "diffHunk": "@@ -135,13 +152,43 @@ public boolean configure(String name, Map<String, Object> params) throws Configu\n             }\n \n             alreadyRunning = _secStorageVmDao.getSecStorageVmListInStates(null, dataCenterId, State.Running, State.Migrating, State.Starting);\n-\n             List<CommandExecLogVO> activeCmds = findActiveCommands(dataCenterId, cutTime);\n+            // Find running copy / migrate commands running arranged in ascending order of their creation time i.e., oldest first\n+            List<CommandExecLogVO> copyCmdsInPipeline = findAllActiveCopyCommands(dataCenterId, cutTime);\n+            // Count of total hosts\n+            Integer hostsCount = _hostDao.countAllByType(Host.Type.Routing);\n+            // Maximum number of allowed SSVMs for migration task\n+            Integer maxSsvms = (hostsCount < MaxNumberOfSsvmsForMigration.value()) ? hostsCount : MaxNumberOfSsvmsForMigration.value();\n+            int halfLimit = Math.round((float) (alreadyRunning.size() * migrateCapPerSSVM) / 2);\n+            currentTime = DateUtil.currentGMTTime().getTime();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzI4ODc5OnYy", "diffSide": "RIGHT", "path": "services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDoyNzozN1rOGW5sVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDoyNzozN1rOGW5sVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY2NzA5Mg==", "bodyText": "please factor this out in suitably called methods. This method was already too long to begin with, but let's not add to the lack of maintainability.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426667092", "createdAt": "2020-05-18T14:27:37Z", "author": {"login": "DaanHoogland"}, "path": "services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java", "diffHunk": "@@ -135,13 +152,43 @@ public boolean configure(String name, Map<String, Object> params) throws Configu\n             }\n \n             alreadyRunning = _secStorageVmDao.getSecStorageVmListInStates(null, dataCenterId, State.Running, State.Migrating, State.Starting);\n-\n             List<CommandExecLogVO> activeCmds = findActiveCommands(dataCenterId, cutTime);\n+            // Find running copy / migrate commands running arranged in ascending order of their creation time i.e., oldest first\n+            List<CommandExecLogVO> copyCmdsInPipeline = findAllActiveCopyCommands(dataCenterId, cutTime);\n+            // Count of total hosts\n+            Integer hostsCount = _hostDao.countAllByType(Host.Type.Routing);\n+            // Maximum number of allowed SSVMs for migration task\n+            Integer maxSsvms = (hostsCount < MaxNumberOfSsvmsForMigration.value()) ? hostsCount : MaxNumberOfSsvmsForMigration.value();\n+            int halfLimit = Math.round((float) (alreadyRunning.size() * migrateCapPerSSVM) / 2);\n+            currentTime = DateUtil.currentGMTTime().getTime();\n+\n             if (alreadyRunning.size() * _capacityPerSSVM - activeCmds.size() < _standbyCapacity) {\n                 s_logger.info(\"secondary storage command execution standby capactiy low (running VMs: \" + alreadyRunning.size() + \", active cmds: \" + activeCmds.size() +\n                         \"), starting a new one\");\n                 return new Pair<AfterScanAction, Object>(AfterScanAction.expand, SecondaryStorageVm.Role.commandExecutor);\n             }\n+            // Scale the number of SSVMs if the number of Copy operations is greater than the number of SSVMs running and the copy operation has been in pipeline for\n+            // more than half of the total time allocated for secondary storage operation\n+            else if (!copyCmdsInPipeline.isEmpty()  && copyCmdsInPipeline.size() >= halfLimit &&\n+                    (((currentTime - copyCmdsInPipeline.get(halfLimit - 1).getCreated().getTime()) > _maxExecutionTimeMs/2 )) &&\n+                            (currentTime > nextSpawnTime) &&  alreadyRunning.size() <=  maxSsvms) {\n+                    nextSpawnTime = currentTime + _maxExecutionTimeMs/2;\n+                    s_logger.debug(\"scaling SSVM to handle migration tasks\");\n+                    return new Pair<AfterScanAction, Object>(AfterScanAction.expand, SecondaryStorageVm.Role.templateProcessor);\n+                }\n+\n+            // Scale down the number of SSVMs if the load on them has reduced\n+            if ((copyCmdsInPipeline.size() < halfLimit && alreadyRunning.size() * _capacityPerSSVM - activeCmds.size() > _standbyCapacity) && alreadyRunning.size() > 1) {\n+                Collections.reverse(alreadyRunning);\n+                for(SecondaryStorageVmVO vm : alreadyRunning) {\n+                    long count = copyCmdsInPipeline.stream().map(cmd -> cmd.getInstanceId() == vm.getId()).count();\n+                    count += activeCmds.stream().map(cmd -> cmd.getInstanceId() == vm.getId()).count();\n+                    if (count == 0) {\n+                        destroySecStorageVm(vm.getId());\n+                        break;\n+                    }\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzMwNDc0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/storage/secondary/SecondaryStorageVmManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozMTowNlrOGW52Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTo1Mjo1MFrOGW9YUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY2OTY1MQ==", "bodyText": "is this being overridden by a global setting somewhere, or a hard-coded restiction", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426669651", "createdAt": "2020-05-18T14:31:06Z", "author": {"login": "DaanHoogland"}, "path": "server/src/main/java/com/cloud/storage/secondary/SecondaryStorageVmManager.java", "diffHunk": "@@ -31,6 +32,7 @@\n     public static final int DEFAULT_SS_VM_CPUMHZ = 500;             // 500 MHz\n     public static final int DEFAULT_SS_VM_MTUSIZE = 1500;\n     public static final int DEFAULT_SS_VM_CAPACITY = 50;            // max command execution session per SSVM\n+    public static final int DEFAULT_MIGRATE_SS_VM_CAPACITY = 2;     // number of concurrent migrate operations to happen per SSVM", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyNzUwNg==", "bodyText": "It is overridden elsewhere", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426727506", "createdAt": "2020-05-18T15:52:50Z", "author": {"login": "Pearl1594"}, "path": "server/src/main/java/com/cloud/storage/secondary/SecondaryStorageVmManager.java", "diffHunk": "@@ -31,6 +32,7 @@\n     public static final int DEFAULT_SS_VM_CPUMHZ = 500;             // 500 MHz\n     public static final int DEFAULT_SS_VM_MTUSIZE = 1500;\n     public static final int DEFAULT_SS_VM_CAPACITY = 50;            // max command execution session per SSVM\n+    public static final int DEFAULT_MIGRATE_SS_VM_CAPACITY = 2;     // number of concurrent migrate operations to happen per SSVM", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY2OTY1MQ=="}, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzMxNDUxOnYy", "diffSide": "LEFT", "path": "server/src/main/java/com/cloud/storage/ImageStoreDetailsUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozMzoyMFrOGW58ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozMzoyMFrOGW58ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3MTIyNw==", "bodyText": "I really like this style but in spite of it looking neater, the removal of the line is a potential conflict before we get a chance to merge. Better have those kind of changes is isolated contributions.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426671227", "createdAt": "2020-05-18T14:33:20Z", "author": {"login": "DaanHoogland"}, "path": "server/src/main/java/com/cloud/storage/ImageStoreDetailsUtil.java", "diffHunk": "@@ -30,7 +30,6 @@\n import com.google.common.base.Preconditions;\n \n public class ImageStoreDetailsUtil {\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzMyMjUwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/configuration/Config.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozNToxNVrOGW6Bfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozNToxNVrOGW6Bfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3MjUxMA==", "bodyText": "adding keys here is an obsoleted way of creating Configuration details. please use a Configkey<String>", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426672510", "createdAt": "2020-05-18T14:35:15Z", "author": {"login": "DaanHoogland"}, "path": "server/src/main/java/com/cloud/configuration/Config.java", "diffHunk": "@@ -904,6 +905,14 @@\n             \"random\",\n             \"'random', 'firstfit', 'userdispersing', 'userconcentratedpod_random', 'userconcentratedpod_firstfit', 'firstfitleastconsumed' : Order in which hosts within a cluster will be considered for VM/volume allocation.\",\n             null),\n+    ImageStoreAllocationAlgorithm(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzMyNTQ5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/configuration/Config.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozNTo1M1rOGW6DOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozNTo1M1rOGW6DOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3Mjk1NQ==", "bodyText": "please use ConfigKey<>s", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426672955", "createdAt": "2020-05-18T14:35:53Z", "author": {"login": "DaanHoogland"}, "path": "server/src/main/java/com/cloud/configuration/Config.java", "diffHunk": "@@ -1808,7 +1817,10 @@\n     // StatsCollector\n     StatsOutPutGraphiteHost(\"Advanced\", ManagementServer.class, String.class, \"stats.output.uri\", \"\", \"URI to additionally send StatsCollector statistics to\", null),\n \n-    SSVMPSK(\"Hidden\", ManagementServer.class, String.class, \"upload.post.secret.key\", \"\", \"PSK with SSVM\", null);\n+    SSVMPSK(\"Hidden\", ManagementServer.class, String.class, \"upload.post.secret.key\", \"\", \"PSK with SSVM\", null),\n+\n+    SecStorageMaxMigrateSessions(\n+            \"Advanced\", AgentManager.class, Integer.class, \"secstorage.max.migrate.sessions\",\"2\",\"The max number of concurrent copy command execution sessions that an SSVM can handle\",null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzMzNTM4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/api/query/ViewResponseHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozNzo1NlrOGW6JDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozNzo1NlrOGW6JDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3NDQ0NA==", "bodyText": "this file is not changed. better remove the diff from the PR", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426674444", "createdAt": "2020-05-18T14:37:56Z", "author": {"login": "DaanHoogland"}, "path": "server/src/main/java/com/cloud/api/query/ViewResponseHelper.java", "diffHunk": "@@ -84,8 +82,10 @@\n import com.cloud.api.query.vo.UserAccountJoinVO;\n import com.cloud.api.query.vo.UserVmJoinVO;\n import com.cloud.api.query.vo.VolumeJoinVO;\n-import com.cloud.storage.StoragePoolTagVO;\n+import com.cloud.configuration.Resource;\n+import com.cloud.domain.Domain;\n import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.StoragePoolTagVO;\n import com.cloud.storage.VolumeStats;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzM0MDYyOnYy", "diffSide": "RIGHT", "path": "server/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozOToxMFrOGW6MYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozOToxMFrOGW6MYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3NTI5Nw==", "bodyText": "version should go in the top level pom and not here.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426675297", "createdAt": "2020-05-18T14:39:10Z", "author": {"login": "DaanHoogland"}, "path": "server/pom.xml", "diffHunk": "@@ -89,6 +89,11 @@\n             <groupId>commons-codec</groupId>\n             <artifactId>commons-codec</artifactId>\n         </dependency>\n+        <dependency>\n+            <groupId>org.apache.commons</groupId>\n+            <artifactId>commons-math3</artifactId>\n+            <version>3.6.1</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzM0NzQzOnYy", "diffSide": "RIGHT", "path": "engine/storage/volume/src/main/java/org/apache/cloudstack/storage/volume/VolumeObject.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDo0MDo0MlrOGW6QeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDo0MDo0MlrOGW6QeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3NjM0NQ==", "bodyText": "please do not keep comment incode. We have an RCS for keeping save old code.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426676345", "createdAt": "2020-05-18T14:40:42Z", "author": {"login": "DaanHoogland"}, "path": "engine/storage/volume/src/main/java/org/apache/cloudstack/storage/volume/VolumeObject.java", "diffHunk": "@@ -392,7 +391,8 @@ public void processEvent(ObjectInDataStoreStateMachine.Event event) {\n                 if (event == ObjectInDataStoreStateMachine.Event.CreateOnlyRequested) {\n                     volEvent = Volume.Event.UploadRequested;\n                 } else if (event == ObjectInDataStoreStateMachine.Event.MigrationRequested) {\n-                    volEvent = Volume.Event.CopyRequested;\n+                    //volEvent = Volume.Event.CopyRequested;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzM1OTA2OnYy", "diffSide": "RIGHT", "path": "engine/storage/src/main/java/org/apache/cloudstack/storage/datastore/ObjectInDataStoreManagerImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDo0MzoyN1rOGW6X4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNzo0Mzo1MlrOGX_I5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3ODI0MQ==", "bodyText": "Event.OperationSuccessed? or should this be Event.OperationSucceeded?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426678241", "createdAt": "2020-05-18T14:43:27Z", "author": {"login": "DaanHoogland"}, "path": "engine/storage/src/main/java/org/apache/cloudstack/storage/datastore/ObjectInDataStoreManagerImpl.java", "diffHunk": "@@ -104,6 +104,14 @@ public ObjectInDataStoreManagerImpl() {\n         // TODO: further investigate why an extra event is sent when it is\n         // alreay Ready for DownloadListener\n         stateMachines.addTransition(State.Ready, Event.OperationSuccessed, State.Ready);\n+        // State transitions for data object migration\n+        stateMachines.addTransition(State.Ready, Event.MigrationRequested, State.Migrating);\n+        stateMachines.addTransition(State.Ready, Event.CopyRequested, State.Copying);\n+        stateMachines.addTransition(State.Allocated, Event.MigrationRequested, State.Migrating);\n+        stateMachines.addTransition(State.Migrating, Event.MigrationFailed, State.Failed);\n+        stateMachines.addTransition(State.Migrating, Event.MigrationSucceeded, State.Destroyed);\n+        stateMachines.addTransition(State.Migrating, Event.OperationSuccessed, State.Ready);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0NDA1Mg==", "bodyText": "I've reused what existed before", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426744052", "createdAt": "2020-05-18T16:16:56Z", "author": {"login": "Pearl1594"}, "path": "engine/storage/src/main/java/org/apache/cloudstack/storage/datastore/ObjectInDataStoreManagerImpl.java", "diffHunk": "@@ -104,6 +104,14 @@ public ObjectInDataStoreManagerImpl() {\n         // TODO: further investigate why an extra event is sent when it is\n         // alreay Ready for DownloadListener\n         stateMachines.addTransition(State.Ready, Event.OperationSuccessed, State.Ready);\n+        // State transitions for data object migration\n+        stateMachines.addTransition(State.Ready, Event.MigrationRequested, State.Migrating);\n+        stateMachines.addTransition(State.Ready, Event.CopyRequested, State.Copying);\n+        stateMachines.addTransition(State.Allocated, Event.MigrationRequested, State.Migrating);\n+        stateMachines.addTransition(State.Migrating, Event.MigrationFailed, State.Failed);\n+        stateMachines.addTransition(State.Migrating, Event.MigrationSucceeded, State.Destroyed);\n+        stateMachines.addTransition(State.Migrating, Event.OperationSuccessed, State.Ready);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3ODI0MQ=="}, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgwNDkwMg==", "bodyText": "yes I saw, maybe separate small issue, thanks", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427804902", "createdAt": "2020-05-20T07:43:52Z", "author": {"login": "DaanHoogland"}, "path": "engine/storage/src/main/java/org/apache/cloudstack/storage/datastore/ObjectInDataStoreManagerImpl.java", "diffHunk": "@@ -104,6 +104,14 @@ public ObjectInDataStoreManagerImpl() {\n         // TODO: further investigate why an extra event is sent when it is\n         // alreay Ready for DownloadListener\n         stateMachines.addTransition(State.Ready, Event.OperationSuccessed, State.Ready);\n+        // State transitions for data object migration\n+        stateMachines.addTransition(State.Ready, Event.MigrationRequested, State.Migrating);\n+        stateMachines.addTransition(State.Ready, Event.CopyRequested, State.Copying);\n+        stateMachines.addTransition(State.Allocated, Event.MigrationRequested, State.Migrating);\n+        stateMachines.addTransition(State.Migrating, Event.MigrationFailed, State.Failed);\n+        stateMachines.addTransition(State.Migrating, Event.MigrationSucceeded, State.Destroyed);\n+        stateMachines.addTransition(State.Migrating, Event.OperationSuccessed, State.Ready);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3ODI0MQ=="}, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzM2OTk1OnYy", "diffSide": "RIGHT", "path": "engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/TemplateServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDo0NTo1M1rOGW6eqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDo0NTo1M1rOGW6eqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3OTk3Nw==", "bodyText": "please remove commented code", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426679977", "createdAt": "2020-05-18T14:45:53Z", "author": {"login": "DaanHoogland"}, "path": "engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/TemplateServiceImpl.java", "diffHunk": "@@ -253,7 +253,8 @@ public void downloadBootstrapSysTemplate(DataStore store) {\n     @Override\n     public void handleSysTemplateDownload(HypervisorType hostHyper, Long dcId) {\n         Set<VMTemplateVO> toBeDownloaded = new HashSet<VMTemplateVO>();\n-        List<DataStore> stores = _storeMgr.getImageStoresByScope(new ZoneScope(dcId));\n+        //List<DataStore> stores = _storeMgr.getImageStoresByScope(new ZoneScope(dcId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzM4MTkyOnYy", "diffSide": "RIGHT", "path": "engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/StorageServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDo0ODozMFrOGW6mOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDo0ODozMFrOGW6mOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4MTkxNA==", "bodyText": "Are you sure this is the best naming convention here? a StorageService sounds like more basic than a SecondaryStorageService. Is it inteded to implement more Interfaces in the future?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426681914", "createdAt": "2020-05-18T14:48:30Z", "author": {"login": "DaanHoogland"}, "path": "engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/StorageServiceImpl.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.storage.image;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.CopyCommandResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataMotionService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateInfo;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.async.AsyncCallbackDispatcher;\n+import org.apache.cloudstack.framework.async.AsyncCompletionCallback;\n+import org.apache.cloudstack.framework.async.AsyncRpcContext;\n+import org.apache.cloudstack.storage.command.CopyCmdAnswer;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.secstorage.CommandExecLogDao;\n+import com.cloud.utils.Pair;\n+\n+public class StorageServiceImpl implements SecondaryStorageService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzM5ODIyOnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDo1MjowOFrOGW6weQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDo1MjowOFrOGW6weQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4NDUzNw==", "bodyText": "Can you call this static final something all-caps, please?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426684537", "createdAt": "2020-05-18T14:52:08Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzQwNjc3OnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDo1NDowM1rOGW619A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMjoxOTo0MFrOGXdszw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4NTk0MA==", "bodyText": "So, if there is any file in any other state, the migration is not ready, is it?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426685940", "createdAt": "2020-05-18T14:54:03Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwMDc3NQ==", "bodyText": "If files are in copying, migrating or creating states - complete migration will not happen", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427100775", "createdAt": "2020-05-19T07:54:28Z", "author": {"login": "Pearl1594"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4NTk0MA=="}, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI1NzAzOQ==", "bodyText": "worth mentioning that here as well. also validstates contains more : {\"Ready\", \"Allocated\", \"Destroying\", \"Destroyed\", \"Failed\"}. seems worth noting in the comment.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427257039", "createdAt": "2020-05-19T12:19:40Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4NTk0MA=="}, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzQxMTg3OnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDo1NTowN1rOGW65IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDo1NTowN1rOGW65IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4Njc1Mw==", "bodyText": "filesReady in this case means \"files ready to migrate\" does it? if so can we rename it that please?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426686753", "createdAt": "2020-05-18T14:55:07Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzQyNDQ5OnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDo1NzozNVrOGW7AuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzo1NToxNVrOGXUMIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4ODY5Ng==", "bodyText": "no 0 possible for equal?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426688696", "createdAt": "2020-05-18T14:57:35Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwMTIxOA==", "bodyText": "They get sorted properly even on ignoring the equality case", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427101218", "createdAt": "2020-05-19T07:55:15Z", "author": {"login": "Pearl1594"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4ODY5Ng=="}, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzQzODQ3OnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTowMDozN1rOGW7Jiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTowMDozN1rOGW7Jiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MDk1NQ==", "bodyText": "I know I asked for this (or such), but overflow is possible if the diff is huge.\nIn relation to the comment to the coomparable above, Is 0 useful? Might we want to reuse this in cases where it is?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426690955", "createdAt": "2020-05-18T15:00:37Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;\n+            }\n+        });\n+        HashMap<Long, Pair<Long, Long>> temp = new LinkedHashMap<>();\n+        for (Map.Entry<Long, Pair<Long, Long>> value : list) {\n+            temp.put(value.getKey(), value.getValue());\n+        }\n+\n+        return new ArrayList<>(temp.keySet());\n+    }\n+\n+    protected List<DataObject> getSortedValidSourcesList(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<DataObject> files = new ArrayList<>();\n+        files.addAll(getAllValidTemplates(srcDataStore));\n+        files.addAll(getAllValidSnapshotsAndChains(srcDataStore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDataStore));\n+\n+        files = sortFilesOnSize(files, snapshotChains);\n+\n+        return files;\n+    }\n+\n+    protected List<DataObject> sortFilesOnSize(List<DataObject> files, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                return (int) (size2 - size1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzQ0NzAwOnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTowMjozNVrOGW7PHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTowMjozNVrOGW7PHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MjM4Mw==", "bodyText": "not a useful comment given the clear method name. extend the method name to be even more clear? make this a javadoc? remove?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426692383", "createdAt": "2020-05-18T15:02:35Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;\n+            }\n+        });\n+        HashMap<Long, Pair<Long, Long>> temp = new LinkedHashMap<>();\n+        for (Map.Entry<Long, Pair<Long, Long>> value : list) {\n+            temp.put(value.getKey(), value.getValue());\n+        }\n+\n+        return new ArrayList<>(temp.keySet());\n+    }\n+\n+    protected List<DataObject> getSortedValidSourcesList(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<DataObject> files = new ArrayList<>();\n+        files.addAll(getAllValidTemplates(srcDataStore));\n+        files.addAll(getAllValidSnapshotsAndChains(srcDataStore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDataStore));\n+\n+        files = sortFilesOnSize(files, snapshotChains);\n+\n+        return files;\n+    }\n+\n+    protected List<DataObject> sortFilesOnSize(List<DataObject> files, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                return (int) (size2 - size1);\n+            }\n+        });\n+        return files;\n+    }\n+\n+    // Gets list of all valid templates, i.e, templates in \"Ready\" state for migration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzQ1MDY1OnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTowMzoyNlrOGW7RiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTowMzoyNlrOGW7RiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MzAwMQ==", "bodyText": "methodname says it all", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426693001", "createdAt": "2020-05-18T15:03:26Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;\n+            }\n+        });\n+        HashMap<Long, Pair<Long, Long>> temp = new LinkedHashMap<>();\n+        for (Map.Entry<Long, Pair<Long, Long>> value : list) {\n+            temp.put(value.getKey(), value.getValue());\n+        }\n+\n+        return new ArrayList<>(temp.keySet());\n+    }\n+\n+    protected List<DataObject> getSortedValidSourcesList(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<DataObject> files = new ArrayList<>();\n+        files.addAll(getAllValidTemplates(srcDataStore));\n+        files.addAll(getAllValidSnapshotsAndChains(srcDataStore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDataStore));\n+\n+        files = sortFilesOnSize(files, snapshotChains);\n+\n+        return files;\n+    }\n+\n+    protected List<DataObject> sortFilesOnSize(List<DataObject> files, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                return (int) (size2 - size1);\n+            }\n+        });\n+        return files;\n+    }\n+\n+    // Gets list of all valid templates, i.e, templates in \"Ready\" state for migration\n+    protected List<DataObject> getAllValidTemplates(DataStore srcDataStore) {\n+\n+        List<DataObject> files = new LinkedList<>();\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStore.getId());\n+        for (TemplateDataStoreVO template : templates) {\n+            VMTemplateVO templateVO = templateDao.findById(template.getTemplateId());\n+            if (template.getState() == ObjectInDataStoreStateMachine.State.Ready && !templateVO.isPublicTemplate()) {\n+                files.add(templateFactory.getTemplate(template.getTemplateId(), srcDataStore));\n+            }\n+        }\n+        return files;\n+    }\n+\n+    /** Returns parent snapshots and snapshots that do not have any children; snapshotChains comprises of the snapshot chain info\n+     * for each parent snapshot and the cumulative size of the chain - this is done to ensure that all the snapshots in a chain\n+     * are migrated to the same datastore\n+     */\n+    protected List<DataObject> getAllValidSnapshotsAndChains(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<SnapshotInfo> files = new LinkedList<>();\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStore.getId(), DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            SnapshotVO snapshotVO = snapshotDao.findById(snapshot.getSnapshotId());\n+            if (snapshot.getState() == ObjectInDataStoreStateMachine.State.Ready && snapshot.getParentSnapshotId() == 0 ) {\n+                SnapshotInfo snap = snapshotFactory.getSnapshot(snapshotVO.getSnapshotId(), DataStoreRole.Image);\n+                files.add(snap);\n+            }\n+        }\n+\n+        for (SnapshotInfo parent : files) {\n+            List<SnapshotInfo> chain = new ArrayList<>();\n+            chain.add(parent);\n+            for (int i =0; i< chain.size(); i++) {\n+                SnapshotInfo child = chain.get(i);\n+                List<SnapshotInfo> children = child.getChildren();\n+                if (children != null) {\n+                    chain.addAll(children);\n+                }\n+            }\n+            snapshotChains.put(parent, new Pair<List<SnapshotInfo>, Long>(chain, getSizeForChain(chain)));\n+        }\n+\n+        return (List<DataObject>) (List<?>) files;\n+    }\n+\n+    // Finds the cumulative file size for all data objects in the chain", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzQ1NDU1OnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTowNDoyN1rOGW7UOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzo1NzoxMFrOGXhq9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MzY5MQ==", "bodyText": "this triggers the thought: should chain be migrated at all or be coalesced first?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426693691", "createdAt": "2020-05-18T15:04:27Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;\n+            }\n+        });\n+        HashMap<Long, Pair<Long, Long>> temp = new LinkedHashMap<>();\n+        for (Map.Entry<Long, Pair<Long, Long>> value : list) {\n+            temp.put(value.getKey(), value.getValue());\n+        }\n+\n+        return new ArrayList<>(temp.keySet());\n+    }\n+\n+    protected List<DataObject> getSortedValidSourcesList(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<DataObject> files = new ArrayList<>();\n+        files.addAll(getAllValidTemplates(srcDataStore));\n+        files.addAll(getAllValidSnapshotsAndChains(srcDataStore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDataStore));\n+\n+        files = sortFilesOnSize(files, snapshotChains);\n+\n+        return files;\n+    }\n+\n+    protected List<DataObject> sortFilesOnSize(List<DataObject> files, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                return (int) (size2 - size1);\n+            }\n+        });\n+        return files;\n+    }\n+\n+    // Gets list of all valid templates, i.e, templates in \"Ready\" state for migration\n+    protected List<DataObject> getAllValidTemplates(DataStore srcDataStore) {\n+\n+        List<DataObject> files = new LinkedList<>();\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStore.getId());\n+        for (TemplateDataStoreVO template : templates) {\n+            VMTemplateVO templateVO = templateDao.findById(template.getTemplateId());\n+            if (template.getState() == ObjectInDataStoreStateMachine.State.Ready && !templateVO.isPublicTemplate()) {\n+                files.add(templateFactory.getTemplate(template.getTemplateId(), srcDataStore));\n+            }\n+        }\n+        return files;\n+    }\n+\n+    /** Returns parent snapshots and snapshots that do not have any children; snapshotChains comprises of the snapshot chain info\n+     * for each parent snapshot and the cumulative size of the chain - this is done to ensure that all the snapshots in a chain\n+     * are migrated to the same datastore\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NzQyMA==", "bodyText": "@DaanHoogland Could you please expand on this", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427057420", "createdAt": "2020-05-19T06:26:12Z", "author": {"login": "Pearl1594"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;\n+            }\n+        });\n+        HashMap<Long, Pair<Long, Long>> temp = new LinkedHashMap<>();\n+        for (Map.Entry<Long, Pair<Long, Long>> value : list) {\n+            temp.put(value.getKey(), value.getValue());\n+        }\n+\n+        return new ArrayList<>(temp.keySet());\n+    }\n+\n+    protected List<DataObject> getSortedValidSourcesList(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<DataObject> files = new ArrayList<>();\n+        files.addAll(getAllValidTemplates(srcDataStore));\n+        files.addAll(getAllValidSnapshotsAndChains(srcDataStore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDataStore));\n+\n+        files = sortFilesOnSize(files, snapshotChains);\n+\n+        return files;\n+    }\n+\n+    protected List<DataObject> sortFilesOnSize(List<DataObject> files, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                return (int) (size2 - size1);\n+            }\n+        });\n+        return files;\n+    }\n+\n+    // Gets list of all valid templates, i.e, templates in \"Ready\" state for migration\n+    protected List<DataObject> getAllValidTemplates(DataStore srcDataStore) {\n+\n+        List<DataObject> files = new LinkedList<>();\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStore.getId());\n+        for (TemplateDataStoreVO template : templates) {\n+            VMTemplateVO templateVO = templateDao.findById(template.getTemplateId());\n+            if (template.getState() == ObjectInDataStoreStateMachine.State.Ready && !templateVO.isPublicTemplate()) {\n+                files.add(templateFactory.getTemplate(template.getTemplateId(), srcDataStore));\n+            }\n+        }\n+        return files;\n+    }\n+\n+    /** Returns parent snapshots and snapshots that do not have any children; snapshotChains comprises of the snapshot chain info\n+     * for each parent snapshot and the cumulative size of the chain - this is done to ensure that all the snapshots in a chain\n+     * are migrated to the same datastore\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MzY5MQ=="}, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMyMjEwMw==", "bodyText": "basic idea is to follow the snapshot creation logic, if there is a chain they all go to the same datastore - otherwise snapshot is created in the datastore with max free capacity", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427322103", "createdAt": "2020-05-19T13:57:10Z", "author": {"login": "Pearl1594"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;\n+            }\n+        });\n+        HashMap<Long, Pair<Long, Long>> temp = new LinkedHashMap<>();\n+        for (Map.Entry<Long, Pair<Long, Long>> value : list) {\n+            temp.put(value.getKey(), value.getValue());\n+        }\n+\n+        return new ArrayList<>(temp.keySet());\n+    }\n+\n+    protected List<DataObject> getSortedValidSourcesList(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<DataObject> files = new ArrayList<>();\n+        files.addAll(getAllValidTemplates(srcDataStore));\n+        files.addAll(getAllValidSnapshotsAndChains(srcDataStore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDataStore));\n+\n+        files = sortFilesOnSize(files, snapshotChains);\n+\n+        return files;\n+    }\n+\n+    protected List<DataObject> sortFilesOnSize(List<DataObject> files, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                return (int) (size2 - size1);\n+            }\n+        });\n+        return files;\n+    }\n+\n+    // Gets list of all valid templates, i.e, templates in \"Ready\" state for migration\n+    protected List<DataObject> getAllValidTemplates(DataStore srcDataStore) {\n+\n+        List<DataObject> files = new LinkedList<>();\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStore.getId());\n+        for (TemplateDataStoreVO template : templates) {\n+            VMTemplateVO templateVO = templateDao.findById(template.getTemplateId());\n+            if (template.getState() == ObjectInDataStoreStateMachine.State.Ready && !templateVO.isPublicTemplate()) {\n+                files.add(templateFactory.getTemplate(template.getTemplateId(), srcDataStore));\n+            }\n+        }\n+        return files;\n+    }\n+\n+    /** Returns parent snapshots and snapshots that do not have any children; snapshotChains comprises of the snapshot chain info\n+     * for each parent snapshot and the cumulative size of the chain - this is done to ensure that all the snapshots in a chain\n+     * are migrated to the same datastore\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MzY5MQ=="}, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzQ1OTY4OnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTowNTo0NVrOGW7Xrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTowNTo0NVrOGW7Xrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NDU3NQ==", "bodyText": "rename to getAllReadyVolumes and delete comment?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426694575", "createdAt": "2020-05-18T15:05:45Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;\n+            }\n+        });\n+        HashMap<Long, Pair<Long, Long>> temp = new LinkedHashMap<>();\n+        for (Map.Entry<Long, Pair<Long, Long>> value : list) {\n+            temp.put(value.getKey(), value.getValue());\n+        }\n+\n+        return new ArrayList<>(temp.keySet());\n+    }\n+\n+    protected List<DataObject> getSortedValidSourcesList(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<DataObject> files = new ArrayList<>();\n+        files.addAll(getAllValidTemplates(srcDataStore));\n+        files.addAll(getAllValidSnapshotsAndChains(srcDataStore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDataStore));\n+\n+        files = sortFilesOnSize(files, snapshotChains);\n+\n+        return files;\n+    }\n+\n+    protected List<DataObject> sortFilesOnSize(List<DataObject> files, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                return (int) (size2 - size1);\n+            }\n+        });\n+        return files;\n+    }\n+\n+    // Gets list of all valid templates, i.e, templates in \"Ready\" state for migration\n+    protected List<DataObject> getAllValidTemplates(DataStore srcDataStore) {\n+\n+        List<DataObject> files = new LinkedList<>();\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStore.getId());\n+        for (TemplateDataStoreVO template : templates) {\n+            VMTemplateVO templateVO = templateDao.findById(template.getTemplateId());\n+            if (template.getState() == ObjectInDataStoreStateMachine.State.Ready && !templateVO.isPublicTemplate()) {\n+                files.add(templateFactory.getTemplate(template.getTemplateId(), srcDataStore));\n+            }\n+        }\n+        return files;\n+    }\n+\n+    /** Returns parent snapshots and snapshots that do not have any children; snapshotChains comprises of the snapshot chain info\n+     * for each parent snapshot and the cumulative size of the chain - this is done to ensure that all the snapshots in a chain\n+     * are migrated to the same datastore\n+     */\n+    protected List<DataObject> getAllValidSnapshotsAndChains(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<SnapshotInfo> files = new LinkedList<>();\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStore.getId(), DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            SnapshotVO snapshotVO = snapshotDao.findById(snapshot.getSnapshotId());\n+            if (snapshot.getState() == ObjectInDataStoreStateMachine.State.Ready && snapshot.getParentSnapshotId() == 0 ) {\n+                SnapshotInfo snap = snapshotFactory.getSnapshot(snapshotVO.getSnapshotId(), DataStoreRole.Image);\n+                files.add(snap);\n+            }\n+        }\n+\n+        for (SnapshotInfo parent : files) {\n+            List<SnapshotInfo> chain = new ArrayList<>();\n+            chain.add(parent);\n+            for (int i =0; i< chain.size(); i++) {\n+                SnapshotInfo child = chain.get(i);\n+                List<SnapshotInfo> children = child.getChildren();\n+                if (children != null) {\n+                    chain.addAll(children);\n+                }\n+            }\n+            snapshotChains.put(parent, new Pair<List<SnapshotInfo>, Long>(chain, getSizeForChain(chain)));\n+        }\n+\n+        return (List<DataObject>) (List<?>) files;\n+    }\n+\n+    // Finds the cumulative file size for all data objects in the chain\n+    protected Long getSizeForChain(List<SnapshotInfo> chain) {\n+        Long size = 0L;\n+        for (SnapshotInfo snapshot : chain) {\n+            size += snapshot.getSize();\n+        }\n+        return size;\n+    }\n+\n+    // Returns a list of volumes that are in \"Ready\" state", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDQwNzA2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/configuration/Config.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNzo0ODozNVrOGX_TSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNzo0ODozNVrOGX_TSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgwNzU2Mw==", "bodyText": "no significant changes in this file", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427807563", "createdAt": "2020-05-20T07:48:35Z", "author": {"login": "DaanHoogland"}, "path": "server/src/main/java/com/cloud/configuration/Config.java", "diffHunk": "@@ -16,6 +16,15 @@\n // under the License.\n package com.cloud.configuration;\n \n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+import org.apache.cloudstack.engine.orchestration.service.NetworkOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.StoragePoolAllocator;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a2208e5c0b0482b24a6e45557468e7fecde4782"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Mzg0MjI1OnYy", "diffSide": "RIGHT", "path": "services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTo1MjoxNVrOGZcCDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTo1MjoxNVrOGZcCDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMyNjg2Mg==", "bodyText": "so ./dir/file/file without extra .extension!", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r429326862", "createdAt": "2020-05-22T15:52:15Z", "author": {"login": "DaanHoogland"}, "path": "services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java", "diffHunk": "@@ -1347,7 +1351,11 @@ protected Answer copyFromNfsToNfs(CopyCommand cmd) {\n                 retObj = newVol;\n             } else if (destData.getObjectType() == DataObjectType.SNAPSHOT) {\n                 SnapshotObjectTO newSnapshot = new SnapshotObjectTO();\n-                newSnapshot.setPath(destData.getPath() + File.separator + destFile.getName());\n+                if (srcFile.isFile()) {\n+                    newSnapshot.setPath(destData.getPath() + File.separator + destFile.getName());\n+                } else {\n+                    newSnapshot.setPath(destData.getPath() + File.separator + destFile.getName() + File.separator + destFile.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f64e76f42a7540a1cb5d356d80d374cbfb5d8fb2"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA4NzgzOnYy", "diffSide": "RIGHT", "path": "test.sh", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozOTo0MlrOHSkHUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxNzowNFrOHSlezQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyODExNQ==", "bodyText": "@Pearl1594 can you remove this file?", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r489228115", "createdAt": "2020-09-16T07:39:42Z", "author": {"login": "rhtyd"}, "path": "test.sh", "diffHunk": "@@ -0,0 +1 @@\n+cks", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "716e77af138c8dd0bc5af4a334113f3dbb3a36cd"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDUwOQ==", "bodyText": "Done", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r489250509", "createdAt": "2020-09-16T08:17:04Z", "author": {"login": "Pearl1594"}, "path": "test.sh", "diffHunk": "@@ -0,0 +1 @@\n+cks", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyODExNQ=="}, "originalCommit": {"oid": "716e77af138c8dd0bc5af4a334113f3dbb3a36cd"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NjMxMDcwOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/resources/META-INF/db/schema-41310to41400.sql", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwODozMDo0M1rOHTXRnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwODozMDo0M1rOHTXRnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA2NjMzNQ==", "bodyText": "This schema change has to be moved to schema-41400to41500.sql.\n@Pearl1594  please raise a separate PR as this is already merged.", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r490066335", "createdAt": "2020-09-17T08:30:43Z", "author": {"login": "harikrishna-patnala"}, "path": "engine/schema/src/main/resources/META-INF/db/schema-41310to41400.sql", "diffHunk": "@@ -53,6 +53,33 @@ ALTER TABLE `cloud`.`vm_instance` ADD COLUMN `backup_offering_id` bigint unsigne\n ALTER TABLE `cloud`.`vm_instance` ADD COLUMN `backup_external_id` varchar(255) DEFAULT NULL COMMENT 'ID of external backup job or container if any';\n ALTER TABLE `cloud`.`vm_instance` ADD COLUMN `backup_volumes` text DEFAULT NULL COMMENT 'details of backedup volumes';\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8552428f02925013f7b2e35efb72ee95704487"}, "originalPosition": 3}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3883, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}