{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwMTQ0MjAw", "number": 4021, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODo1Mjo0NFrOD4KnfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTo0MToxOFrOEHiTFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjIwNzk2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/ApiConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODo1Mjo0NFrOGO2InQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODo1Mjo0NFrOGO2InQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyMDE4OQ==", "bodyText": "Minor style fix: missing space after the '='", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r418220189", "createdAt": "2020-04-30T18:52:44Z", "author": {"login": "nvazquez"}, "path": "api/src/main/java/org/apache/cloudstack/api/ApiConstants.java", "diffHunk": "@@ -806,6 +806,7 @@\n \n     public static final String BOOT_TYPE =\"boottype\";\n     public static final String BOOT_MODE =\"bootmode\";\n+    public static final String BOOT_INTO_SETUP =\"bootintosetup\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjIyMzIwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/org/apache/cloudstack/api/command/user/vm/DeployVMCmd.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODo1NzowMVrOGO2SRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNDoxODozNVrOGPK7yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyMjY2MA==", "bodyText": "The null check was removed, can you include it inside this if clause?", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r418222660", "createdAt": "2020-04-30T18:57:01Z", "author": {"login": "nvazquez"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/user/vm/DeployVMCmd.java", "diffHunk": "@@ -281,15 +284,14 @@ public Long getDomainId() {\n                 }\n             }\n         }\n-        if(getBootType() != null){ // export to get\n-            if(getBootType() == ApiConstants.BootType.UEFI) {\n-                customparameterMap.put(getBootType().toString(), getBootMode().toString());\n-            }\n+        if (ApiConstants.BootType.UEFI.equals(getBootType())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU2MDk3MQ==", "bodyText": "null won't be equal to ApiConstants.BootType.UEFI so it is implied.", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r418560971", "createdAt": "2020-05-01T14:18:35Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/org/apache/cloudstack/api/command/user/vm/DeployVMCmd.java", "diffHunk": "@@ -281,15 +284,14 @@ public Long getDomainId() {\n                 }\n             }\n         }\n-        if(getBootType() != null){ // export to get\n-            if(getBootType() == ApiConstants.BootType.UEFI) {\n-                customparameterMap.put(getBootType().toString(), getBootMode().toString());\n-            }\n+        if (ApiConstants.BootType.UEFI.equals(getBootType())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyMjY2MA=="}, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjI0OTk5OnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTowNToxN1rOGO2jrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNDozMzo1M1rOGPLWYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyNzExNw==", "bodyText": "Minor improvement request: what about removing the boolean variable and init the string buffer empty, so at this point instead of asking for the boolean flag you could check if the generated string is not empty, in that case log it", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r418227117", "createdAt": "2020-04-30T19:05:17Z", "author": {"login": "nvazquez"}, "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "diffHunk": "@@ -1315,6 +1324,30 @@ public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfil\n         }\n     }\n \n+    private void logBootModeParameters(Map<VirtualMachineProfile.Param, Object> params) {\n+        StringBuffer msgBuf = new StringBuffer(\"Uefi params \");\n+        boolean log = false;\n+        if (params.get(VirtualMachineProfile.Param.UefiFlag) != null) {\n+            msgBuf.append(String.format(\"UefiFlag: %s \", params.get(VirtualMachineProfile.Param.UefiFlag)));\n+            log = true;\n+        }\n+        if (params.get(VirtualMachineProfile.Param.BootType) != null) {\n+            msgBuf.append(String.format(\"Boot Type: %s \", params.get(VirtualMachineProfile.Param.BootType)));\n+            log = true;\n+        }\n+        if (params.get(VirtualMachineProfile.Param.BootMode) != null) {\n+            msgBuf.append(String.format(\"Boot Mode: %s \", params.get(VirtualMachineProfile.Param.BootMode)));\n+            log = true;\n+        }\n+        if (params.get(VirtualMachineProfile.Param.BootIntoSetup) != null) {\n+            msgBuf.append(String.format(\"Boot into Setup: %s \", params.get(VirtualMachineProfile.Param.BootIntoSetup)));\n+            log = true;\n+        }\n+        if (log) {\n+            s_logger.info(msgBuf.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU2Nzc3Ng==", "bodyText": "actually the initial text would have to be added so the logic would replace teh guard boolean with a string concatenation. I prefer this.", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r418567776", "createdAt": "2020-05-01T14:33:53Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "diffHunk": "@@ -1315,6 +1324,30 @@ public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfil\n         }\n     }\n \n+    private void logBootModeParameters(Map<VirtualMachineProfile.Param, Object> params) {\n+        StringBuffer msgBuf = new StringBuffer(\"Uefi params \");\n+        boolean log = false;\n+        if (params.get(VirtualMachineProfile.Param.UefiFlag) != null) {\n+            msgBuf.append(String.format(\"UefiFlag: %s \", params.get(VirtualMachineProfile.Param.UefiFlag)));\n+            log = true;\n+        }\n+        if (params.get(VirtualMachineProfile.Param.BootType) != null) {\n+            msgBuf.append(String.format(\"Boot Type: %s \", params.get(VirtualMachineProfile.Param.BootType)));\n+            log = true;\n+        }\n+        if (params.get(VirtualMachineProfile.Param.BootMode) != null) {\n+            msgBuf.append(String.format(\"Boot Mode: %s \", params.get(VirtualMachineProfile.Param.BootMode)));\n+            log = true;\n+        }\n+        if (params.get(VirtualMachineProfile.Param.BootIntoSetup) != null) {\n+            msgBuf.append(String.format(\"Boot into Setup: %s \", params.get(VirtualMachineProfile.Param.BootIntoSetup)));\n+            log = true;\n+        }\n+        if (log) {\n+            s_logger.info(msgBuf.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyNzExNw=="}, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjI4NTg0OnYy", "diffSide": "RIGHT", "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOToxNTo1OVrOGO26Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOToxNTo1OVrOGO26Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzMjg5NQ==", "bodyText": "Missing space", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r418232895", "createdAt": "2020-04-30T19:15:59Z", "author": {"login": "nvazquez"}, "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "diffHunk": "@@ -1723,10 +1723,13 @@ protected StartAnswer execute(StartCommand cmd) {\n         String dataDiskController = vmSpec.getDetails().get(VmDetailConstants.DATA_DISK_CONTROLLER);\n         String rootDiskController = vmSpec.getDetails().get(VmDetailConstants.ROOT_DISK_CONTROLLER);\n         DiskTO rootDiskTO = null;\n-        String bootMode = \"bios\";\n+        String bootMode = null;\n         if (vmSpec.getDetails().containsKey(VmDetailConstants.BOOT_MODE)) {\n             bootMode = vmSpec.getDetails().get(VmDetailConstants.BOOT_MODE);\n         }\n+        if(null == bootMode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjMwNDEzOnYy", "diffSide": "RIGHT", "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOToyMTozOFrOGO3Fvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMjozNToyOFrOGP-SbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzNTgzOA==", "bodyText": "We are swallowing the exception here, should we try to stop the process instead?", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r418235838", "createdAt": "2020-04-30T19:21:38Z", "author": {"login": "nvazquez"}, "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "diffHunk": "@@ -3950,6 +3970,25 @@ protected Answer execute(RebootCommand cmd) {\n         }\n     }\n \n+    private void checkAndSetEnableSetupConfig(VirtualMachineMO vmMo, VirtualMachineTO virtualMachine) {\n+        if (virtualMachine.isEnterHardwareSetup()) {\n+            VirtualMachineBootOptions bootOptions = new VirtualMachineBootOptions();\n+            VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();\n+            if (s_logger.isDebugEnabled()) {\n+                s_logger.debug(String.format(\"configuring VM '%s' to reboot into hardware setup menu.\",virtualMachine.getName()));\n+            }\n+            bootOptions.setEnterBIOSSetup(virtualMachine.isEnterHardwareSetup());\n+            vmConfigSpec.setBootOptions(bootOptions);\n+            try {\n+                if (!vmMo.configureVm(vmConfigSpec)) {\n+                    throw new Exception(\"Failed to configure VM to boot into hardware setup menu: \" + vmMo.getName());\n+                }\n+            } catch (Exception e) {\n+                s_logger.error(String.format(\"failed to reconfigure VM '%s' to boot into hardware setup menu\",virtualMachine.getName()),e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU2NDU4NQ==", "bodyText": "no, the rest of the reboot process can still proceed normally and it is an unlikely event that implies an error in Vsphere.", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r418564585", "createdAt": "2020-05-01T14:26:50Z", "author": {"login": "DaanHoogland"}, "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "diffHunk": "@@ -3950,6 +3970,25 @@ protected Answer execute(RebootCommand cmd) {\n         }\n     }\n \n+    private void checkAndSetEnableSetupConfig(VirtualMachineMO vmMo, VirtualMachineTO virtualMachine) {\n+        if (virtualMachine.isEnterHardwareSetup()) {\n+            VirtualMachineBootOptions bootOptions = new VirtualMachineBootOptions();\n+            VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();\n+            if (s_logger.isDebugEnabled()) {\n+                s_logger.debug(String.format(\"configuring VM '%s' to reboot into hardware setup menu.\",virtualMachine.getName()));\n+            }\n+            bootOptions.setEnterBIOSSetup(virtualMachine.isEnterHardwareSetup());\n+            vmConfigSpec.setBootOptions(bootOptions);\n+            try {\n+                if (!vmMo.configureVm(vmConfigSpec)) {\n+                    throw new Exception(\"Failed to configure VM to boot into hardware setup menu: \" + vmMo.getName());\n+                }\n+            } catch (Exception e) {\n+                s_logger.error(String.format(\"failed to reconfigure VM '%s' to boot into hardware setup menu\",virtualMachine.getName()),e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzNTgzOA=="}, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4NDE1NA==", "bodyText": "ok, revisited this and yes it is a valid concern in view of the hard reset that follows in the calling method. I'll have to refactor this to handle a failure to set the parameter on the VM.", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r419284154", "createdAt": "2020-05-04T08:32:34Z", "author": {"login": "DaanHoogland"}, "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "diffHunk": "@@ -3950,6 +3970,25 @@ protected Answer execute(RebootCommand cmd) {\n         }\n     }\n \n+    private void checkAndSetEnableSetupConfig(VirtualMachineMO vmMo, VirtualMachineTO virtualMachine) {\n+        if (virtualMachine.isEnterHardwareSetup()) {\n+            VirtualMachineBootOptions bootOptions = new VirtualMachineBootOptions();\n+            VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();\n+            if (s_logger.isDebugEnabled()) {\n+                s_logger.debug(String.format(\"configuring VM '%s' to reboot into hardware setup menu.\",virtualMachine.getName()));\n+            }\n+            bootOptions.setEnterBIOSSetup(virtualMachine.isEnterHardwareSetup());\n+            vmConfigSpec.setBootOptions(bootOptions);\n+            try {\n+                if (!vmMo.configureVm(vmConfigSpec)) {\n+                    throw new Exception(\"Failed to configure VM to boot into hardware setup menu: \" + vmMo.getName());\n+                }\n+            } catch (Exception e) {\n+                s_logger.error(String.format(\"failed to reconfigure VM '%s' to boot into hardware setup menu\",virtualMachine.getName()),e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzNTgzOA=="}, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1NDA3NA==", "bodyText": "I improved this flow @nvazquez can you have a look? I can not think of a way of testing this. Unless there is a way to disallow booting into setup from vsphere. (/me doing quick google now ;)", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r419354074", "createdAt": "2020-05-04T10:53:12Z", "author": {"login": "DaanHoogland"}, "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "diffHunk": "@@ -3950,6 +3970,25 @@ protected Answer execute(RebootCommand cmd) {\n         }\n     }\n \n+    private void checkAndSetEnableSetupConfig(VirtualMachineMO vmMo, VirtualMachineTO virtualMachine) {\n+        if (virtualMachine.isEnterHardwareSetup()) {\n+            VirtualMachineBootOptions bootOptions = new VirtualMachineBootOptions();\n+            VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();\n+            if (s_logger.isDebugEnabled()) {\n+                s_logger.debug(String.format(\"configuring VM '%s' to reboot into hardware setup menu.\",virtualMachine.getName()));\n+            }\n+            bootOptions.setEnterBIOSSetup(virtualMachine.isEnterHardwareSetup());\n+            vmConfigSpec.setBootOptions(bootOptions);\n+            try {\n+                if (!vmMo.configureVm(vmConfigSpec)) {\n+                    throw new Exception(\"Failed to configure VM to boot into hardware setup menu: \" + vmMo.getName());\n+                }\n+            } catch (Exception e) {\n+                s_logger.error(String.format(\"failed to reconfigure VM '%s' to boot into hardware setup menu\",virtualMachine.getName()),e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzNTgzOA=="}, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM4MzI1Ng==", "bodyText": "Looks good. I can think of a way to test this:\nWhat about adding a config key to control the delay as described here? (bootDelay param) https://vdc-download.vmware.com/vmwb-repository/dcr-public/b50dcbbf-051d-4204-a3e7-e1b618c1e384/538cf2ec-b34f-4bae-a332-3820ef9e7773/vim.vm.BootOptions.html\nWill need testing but as it expects a long value, sending a negative delay may cause VM config to throw an exception", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r419383256", "createdAt": "2020-05-04T11:57:55Z", "author": {"login": "nvazquez"}, "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "diffHunk": "@@ -3950,6 +3970,25 @@ protected Answer execute(RebootCommand cmd) {\n         }\n     }\n \n+    private void checkAndSetEnableSetupConfig(VirtualMachineMO vmMo, VirtualMachineTO virtualMachine) {\n+        if (virtualMachine.isEnterHardwareSetup()) {\n+            VirtualMachineBootOptions bootOptions = new VirtualMachineBootOptions();\n+            VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();\n+            if (s_logger.isDebugEnabled()) {\n+                s_logger.debug(String.format(\"configuring VM '%s' to reboot into hardware setup menu.\",virtualMachine.getName()));\n+            }\n+            bootOptions.setEnterBIOSSetup(virtualMachine.isEnterHardwareSetup());\n+            vmConfigSpec.setBootOptions(bootOptions);\n+            try {\n+                if (!vmMo.configureVm(vmConfigSpec)) {\n+                    throw new Exception(\"Failed to configure VM to boot into hardware setup menu: \" + vmMo.getName());\n+                }\n+            } catch (Exception e) {\n+                s_logger.error(String.format(\"failed to reconfigure VM '%s' to boot into hardware setup menu\",virtualMachine.getName()),e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzNTgzOA=="}, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQwMjM0OQ==", "bodyText": ":) next feature, but good to keep in mind!", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r419402349", "createdAt": "2020-05-04T12:35:28Z", "author": {"login": "DaanHoogland"}, "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "diffHunk": "@@ -3950,6 +3970,25 @@ protected Answer execute(RebootCommand cmd) {\n         }\n     }\n \n+    private void checkAndSetEnableSetupConfig(VirtualMachineMO vmMo, VirtualMachineTO virtualMachine) {\n+        if (virtualMachine.isEnterHardwareSetup()) {\n+            VirtualMachineBootOptions bootOptions = new VirtualMachineBootOptions();\n+            VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();\n+            if (s_logger.isDebugEnabled()) {\n+                s_logger.debug(String.format(\"configuring VM '%s' to reboot into hardware setup menu.\",virtualMachine.getName()));\n+            }\n+            bootOptions.setEnterBIOSSetup(virtualMachine.isEnterHardwareSetup());\n+            vmConfigSpec.setBootOptions(bootOptions);\n+            try {\n+                if (!vmMo.configureVm(vmConfigSpec)) {\n+                    throw new Exception(\"Failed to configure VM to boot into hardware setup menu: \" + vmMo.getName());\n+                }\n+            } catch (Exception e) {\n+                s_logger.error(String.format(\"failed to reconfigure VM '%s' to boot into hardware setup menu\",virtualMachine.getName()),e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzNTgzOA=="}, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjMwOTIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOToyMzoxOFrOGO3JBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOToyMzoxOFrOGO3JBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzNjY3OA==", "bodyText": "Space", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r418236678", "createdAt": "2020-04-30T19:23:18Z", "author": {"login": "nvazquez"}, "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "diffHunk": "@@ -969,8 +973,18 @@ private UserVm rebootVirtualMachine(long userId, long vmId) throws InsufficientC\n             } catch (Exception ex){\n                 throw new CloudRuntimeException(\"Router start failed due to\" + ex);\n             }finally {\n-                s_logger.info(\"Rebooting vm \" + vm.getInstanceName());\n-                _itMgr.reboot(vm.getUuid(), null);\n+                if (s_logger.isInfoEnabled()) {\n+                    s_logger.info(String.format(\"Rebooting vm %s%s.\", vm.getInstanceName(), enterSetup? \" entering hardware setup menu\" : \" as is\"));\n+                }\n+                Map<VirtualMachineProfile.Param,Object> params = null;\n+                if(enterSetup) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjMxNTgzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOToyNTowOVrOGO3M8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMTo0MTowNFrOGP8ptw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzNzY4MQ==", "bodyText": "For readability can you change it to: enterSetup != null && hypervisor != Vmware?", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r418237681", "createdAt": "2020-04-30T19:25:09Z", "author": {"login": "nvazquez"}, "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "diffHunk": "@@ -2866,7 +2892,11 @@ public UserVm rebootVirtualMachine(RebootVMCmd cmd) throws InsufficientCapacityE\n             throw new InvalidParameterValueException(\"Unable to find service offering: \" + serviceOfferingId + \" corresponding to the vm\");\n         }\n \n-        UserVm userVm = rebootVirtualMachine(CallContext.current().getCallingUserId(), vmId);\n+        Boolean enterSetup = cmd.getBootIntoSetup();\n+        if (! (enterSetup == null || HypervisorType.VMware.equals(vmInstance.getHypervisorType()))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU2NTQxMg==", "bodyText": "would enterSetup != null && !HypervisorType.VMware.equals(vmInstance.getHypervisorType()) be acceptable as well?", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r418565412", "createdAt": "2020-05-01T14:28:39Z", "author": {"login": "DaanHoogland"}, "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "diffHunk": "@@ -2866,7 +2892,11 @@ public UserVm rebootVirtualMachine(RebootVMCmd cmd) throws InsufficientCapacityE\n             throw new InvalidParameterValueException(\"Unable to find service offering: \" + serviceOfferingId + \" corresponding to the vm\");\n         }\n \n-        UserVm userVm = rebootVirtualMachine(CallContext.current().getCallingUserId(), vmId);\n+        Boolean enterSetup = cmd.getBootIntoSetup();\n+        if (! (enterSetup == null || HypervisorType.VMware.equals(vmInstance.getHypervisorType()))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzNzY4MQ=="}, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM3NTU0Mw==", "bodyText": "Sure", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r419375543", "createdAt": "2020-05-04T11:41:04Z", "author": {"login": "nvazquez"}, "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "diffHunk": "@@ -2866,7 +2892,11 @@ public UserVm rebootVirtualMachine(RebootVMCmd cmd) throws InsufficientCapacityE\n             throw new InvalidParameterValueException(\"Unable to find service offering: \" + serviceOfferingId + \" corresponding to the vm\");\n         }\n \n-        UserVm userVm = rebootVirtualMachine(CallContext.current().getCallingUserId(), vmId);\n+        Boolean enterSetup = cmd.getBootIntoSetup();\n+        if (! (enterSetup == null || HypervisorType.VMware.equals(vmInstance.getHypervisorType()))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzNzY4MQ=="}, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjMzNTA0OnYy", "diffSide": "RIGHT", "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/guru/VMwareGuru.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTozMToyOFrOGO3Zcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMjozODoyMVrOGP-YKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0MDg4Mg==", "bodyText": "Why not using the @Inject annotation?", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r418240882", "createdAt": "2020-04-30T19:31:28Z", "author": {"login": "nvazquez"}, "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/guru/VMwareGuru.java", "diffHunk": "@@ -172,326 +157,59 @@\n public class VMwareGuru extends HypervisorGuruBase implements HypervisorGuru, Configurable {\n     private static final Logger s_logger = Logger.getLogger(VMwareGuru.class);\n \n-    @Inject\n-    private NetworkDao _networkDao;\n-    @Inject\n-    private GuestOSDao _guestOsDao;\n-    @Inject\n-    private GuestOSHypervisorDao _guestOsHypervisorDao;\n-    @Inject\n-    private HostDao _hostDao;\n-    @Inject\n-    private HostDetailsDao _hostDetailsDao;\n-    @Inject\n-    private ClusterDetailsDao _clusterDetailsDao;\n-    @Inject\n-    private CommandExecLogDao _cmdExecLogDao;\n-    @Inject\n-    private VmwareManager _vmwareMgr;\n-    @Inject\n-    private SecondaryStorageVmManager _secStorageMgr;\n-    @Inject\n-    private NetworkModel _networkMgr;\n-    @Inject\n-    private NicDao _nicDao;\n-    @Inject\n-    private DomainRouterDao _domainRouterDao;\n-    @Inject\n-    private PhysicalNetworkTrafficTypeDao _physicalNetworkTrafficTypeDao;\n-    @Inject\n-    private VMInstanceDao _vmDao;\n-    @Inject\n-    private VirtualMachineManager vmManager;\n-    @Inject\n-    private ClusterManager _clusterMgr;\n-    @Inject\n-    VolumeDao _volumeDao;\n-    @Inject\n-    ResourceLimitService _resourceLimitService;\n-    @Inject\n-    PrimaryDataStoreDao _storagePoolDao;\n-    @Inject\n-    VolumeDataFactory _volFactory;\n-    @Inject\n-    private VmwareDatacenterDao vmwareDatacenterDao;\n-    @Inject\n-    private VmwareDatacenterZoneMapDao vmwareDatacenterZoneMapDao;\n-    @Inject\n-    private ServiceOfferingDao serviceOfferingDao;\n-    @Inject\n-    private VMTemplatePoolDao templateStoragePoolDao;\n-    @Inject\n-    private VMTemplateDao vmTemplateDao;\n-    @Inject\n-    private UserVmDao userVmDao;\n-    @Inject\n-    private DiskOfferingDao diskOfferingDao;\n-    @Inject\n-    private PhysicalNetworkDao physicalNetworkDao;\n-    @Inject\n-    private TemplateOVFPropertiesDao templateOVFPropertiesDao;\n+\n+    private VmwareVmImplementer vmwareVmImplementer;\n+\n+    @Inject NetworkDao _networkDao;\n+    @Inject GuestOSDao _guestOsDao;\n+    @Inject HostDao _hostDao;\n+    @Inject HostDetailsDao _hostDetailsDao;\n+    @Inject ClusterDetailsDao _clusterDetailsDao;\n+    @Inject CommandExecLogDao _cmdExecLogDao;\n+    @Inject VmwareManager _vmwareMgr;\n+    @Inject SecondaryStorageVmManager _secStorageMgr;\n+    @Inject NicDao _nicDao;\n+    @Inject PhysicalNetworkTrafficTypeDao _physicalNetworkTrafficTypeDao;\n+    @Inject VMInstanceDao _vmDao;\n+    @Inject VirtualMachineManager vmManager;\n+    @Inject ClusterManager _clusterMgr;\n+    @Inject VolumeDao _volumeDao;\n+    @Inject ResourceLimitService _resourceLimitService;\n+    @Inject PrimaryDataStoreDao _storagePoolDao;\n+    @Inject VolumeDataFactory _volFactory;\n+    @Inject VmwareDatacenterDao vmwareDatacenterDao;\n+    @Inject VmwareDatacenterZoneMapDao vmwareDatacenterZoneMapDao;\n+    @Inject ServiceOfferingDao serviceOfferingDao;\n+    @Inject VMTemplatePoolDao templateStoragePoolDao;\n+    @Inject VMTemplateDao vmTemplateDao;\n+    @Inject UserVmDao userVmDao;\n+    @Inject DiskOfferingDao diskOfferingDao;\n+    @Inject PhysicalNetworkDao physicalNetworkDao;\n \n     protected VMwareGuru() {\n         super();\n     }\n \n     public static final ConfigKey<Boolean> VmwareReserveCpu = new ConfigKey<Boolean>(Boolean.class, \"vmware.reserve.cpu\", \"Advanced\", \"false\",\n-        \"Specify whether or not to reserve CPU when deploying an instance.\", true, ConfigKey.Scope.Cluster,\n-        null);\n+            \"Specify whether or not to reserve CPU when deploying an instance.\", true, ConfigKey.Scope.Cluster, null);\n \n     public static final ConfigKey<Boolean> VmwareReserveMemory = new ConfigKey<Boolean>(Boolean.class, \"vmware.reserve.mem\", \"Advanced\", \"false\",\n-        \"Specify whether or not to reserve memory when deploying an instance.\", true,\n-        ConfigKey.Scope.Cluster, null);\n+            \"Specify whether or not to reserve memory when deploying an instance.\", true, ConfigKey.Scope.Cluster, null);\n \n     protected ConfigKey<Boolean> VmwareEnableNestedVirtualization = new ConfigKey<Boolean>(Boolean.class, \"vmware.nested.virtualization\", \"Advanced\", \"false\",\n             \"When set to true this will enable nested virtualization when this is supported by the hypervisor\", true, ConfigKey.Scope.Global, null);\n \n     protected ConfigKey<Boolean> VmwareEnableNestedVirtualizationPerVM = new ConfigKey<Boolean>(Boolean.class, \"vmware.nested.virtualization.perVM\", \"Advanced\", \"false\",\n             \"When set to true this will enable nested virtualization per vm\", true, ConfigKey.Scope.Global, null);\n \n-    @Override\n-    public HypervisorType getHypervisorType() {\n+    @Override public HypervisorType getHypervisorType() {\n         return HypervisorType.VMware;\n     }\n \n-    @Override\n-    public VirtualMachineTO implement(VirtualMachineProfile vm) {\n-        VirtualMachineTO to = toVirtualMachineTO(vm);\n-        to.setBootloader(BootloaderType.HVM);\n-\n-        Map<String, String> details = to.getDetails();\n-        if (details == null)\n-            details = new HashMap<String, String>();\n-\n-        Type vmType = vm.getType();\n-        boolean userVm = !(vmType.equals(VirtualMachine.Type.DomainRouter) || vmType.equals(VirtualMachine.Type.ConsoleProxy)\n-                || vmType.equals(VirtualMachine.Type.SecondaryStorageVm));\n-\n-        String nicDeviceType = details.get(VmDetailConstants.NIC_ADAPTER);\n-        if (!userVm) {\n-\n-            if (nicDeviceType == null) {\n-                details.put(VmDetailConstants.NIC_ADAPTER, _vmwareMgr.getSystemVMDefaultNicAdapterType());\n-            } else {\n-                try {\n-                    VirtualEthernetCardType.valueOf(nicDeviceType);\n-                } catch (Exception e) {\n-                    s_logger.warn(\"Invalid NIC device type \" + nicDeviceType + \" is specified in VM details, switch to default E1000\");\n-                    details.put(VmDetailConstants.NIC_ADAPTER, VirtualEthernetCardType.E1000.toString());\n-                }\n-            }\n-        } else {\n-            // for user-VM, use E1000 as default\n-            if (nicDeviceType == null) {\n-                details.put(VmDetailConstants.NIC_ADAPTER, VirtualEthernetCardType.E1000.toString());\n-            } else {\n-                try {\n-                    VirtualEthernetCardType.valueOf(nicDeviceType);\n-                } catch (Exception e) {\n-                    s_logger.warn(\"Invalid NIC device type \" + nicDeviceType + \" is specified in VM details, switch to default E1000\");\n-                    details.put(VmDetailConstants.NIC_ADAPTER, VirtualEthernetCardType.E1000.toString());\n-                }\n-            }\n-        }\n-\n-        details.put(VmDetailConstants.BOOT_MODE, to.getBootMode());\n-        String diskDeviceType = details.get(VmDetailConstants.ROOT_DISK_CONTROLLER);\n-        if (userVm) {\n-            if (diskDeviceType == null) {\n-                details.put(VmDetailConstants.ROOT_DISK_CONTROLLER, _vmwareMgr.getRootDiskController());\n-            }\n-        }\n-        String diskController = details.get(VmDetailConstants.DATA_DISK_CONTROLLER);\n-        if (userVm) {\n-            if (diskController == null) {\n-                details.put(VmDetailConstants.DATA_DISK_CONTROLLER, DiskControllerType.lsilogic.toString());\n-            }\n-        }\n-\n-        if (vm.getType() == VirtualMachine.Type.NetScalerVm) {\n-            details.put(VmDetailConstants.ROOT_DISK_CONTROLLER, \"scsi\");\n-        }\n-\n-        List<NicProfile> nicProfiles = vm.getNics();\n-\n-        for (NicProfile nicProfile : nicProfiles) {\n-            if (nicProfile.getTrafficType() == TrafficType.Guest) {\n-                if (_networkMgr.isProviderSupportServiceInNetwork(nicProfile.getNetworkId(), Service.Firewall, Provider.CiscoVnmc)) {\n-                    details.put(\"ConfigureVServiceInNexus\", Boolean.TRUE.toString());\n-                }\n-                break;\n-            }\n-        }\n-\n-        long clusterId = getClusterId(vm.getId());\n-        details.put(VmwareReserveCpu.key(), VmwareReserveCpu.valueIn(clusterId).toString());\n-        details.put(VmwareReserveMemory.key(), VmwareReserveMemory.valueIn(clusterId).toString());\n-        to.setDetails(details);\n-\n-        if (vmType.equals(VirtualMachine.Type.DomainRouter)) {\n-\n-            NicProfile publicNicProfile = null;\n-            for (NicProfile nicProfile : nicProfiles) {\n-                if (nicProfile.getTrafficType() == TrafficType.Public) {\n-                    publicNicProfile = nicProfile;\n-                    break;\n-                }\n-            }\n-\n-            if (publicNicProfile != null) {\n-                NicTO[] nics = to.getNics();\n-\n-                // reserve extra NICs\n-                NicTO[] expandedNics = new NicTO[nics.length + _vmwareMgr.getRouterExtraPublicNics()];\n-                int i = 0;\n-                int deviceId = -1;\n-                for (i = 0; i < nics.length; i++) {\n-                    expandedNics[i] = nics[i];\n-                    if (nics[i].getDeviceId() > deviceId)\n-                        deviceId = nics[i].getDeviceId();\n-                }\n-                deviceId++;\n-\n-                long networkId = publicNicProfile.getNetworkId();\n-                NetworkVO network = _networkDao.findById(networkId);\n-\n-                for (; i < nics.length + _vmwareMgr.getRouterExtraPublicNics(); i++) {\n-                    NicTO nicTo = new NicTO();\n-\n-                    nicTo.setDeviceId(deviceId++);\n-                    nicTo.setBroadcastType(publicNicProfile.getBroadcastType());\n-                    nicTo.setType(publicNicProfile.getTrafficType());\n-                    nicTo.setIp(\"0.0.0.0\");\n-                    nicTo.setNetmask(\"255.255.255.255\");\n-\n-                    try {\n-                        String mac = _networkMgr.getNextAvailableMacAddressInNetwork(networkId);\n-                        nicTo.setMac(mac);\n-                    } catch (InsufficientAddressCapacityException e) {\n-                        throw new CloudRuntimeException(\"unable to allocate mac address on network: \" + networkId);\n-                    }\n-                    nicTo.setDns1(publicNicProfile.getIPv4Dns1());\n-                    nicTo.setDns2(publicNicProfile.getIPv4Dns2());\n-                    if (publicNicProfile.getIPv4Gateway() != null) {\n-                        nicTo.setGateway(publicNicProfile.getIPv4Gateway());\n-                    } else {\n-                        nicTo.setGateway(network.getGateway());\n-                    }\n-                    nicTo.setDefaultNic(false);\n-                    nicTo.setBroadcastUri(publicNicProfile.getBroadCastUri());\n-                    nicTo.setIsolationuri(publicNicProfile.getIsolationUri());\n-\n-                    Integer networkRate = _networkMgr.getNetworkRate(network.getId(), null);\n-                    nicTo.setNetworkRateMbps(networkRate);\n-\n-                    expandedNics[i] = nicTo;\n-                }\n-\n-                to.setNics(expandedNics);\n-\n-                VirtualMachine router = vm.getVirtualMachine();\n-                DomainRouterVO routerVO = _domainRouterDao.findById(router.getId());\n-                if (routerVO != null && routerVO.getIsRedundantRouter()) {\n-                    Long peerRouterId = _nicDao.getPeerRouterId(publicNicProfile.getMacAddress(), router.getId());\n-                    DomainRouterVO peerRouterVO = null;\n-                    if (peerRouterId != null) {\n-                        peerRouterVO = _domainRouterDao.findById(peerRouterId);\n-                        if (peerRouterVO != null) {\n-                            details.put(\"PeerRouterInstanceName\", peerRouterVO.getInstanceName());\n-                        }\n-                    }\n-                }\n-            }\n-\n-            StringBuffer sbMacSequence = new StringBuffer();\n-            for (NicTO nicTo : sortNicsByDeviceId(to.getNics())) {\n-                sbMacSequence.append(nicTo.getMac()).append(\"|\");\n-            }\n-            if (!sbMacSequence.toString().isEmpty()) {\n-                sbMacSequence.deleteCharAt(sbMacSequence.length() - 1);\n-                String bootArgs = to.getBootArgs();\n-                to.setBootArgs(bootArgs + \" nic_macs=\" + sbMacSequence.toString());\n-            }\n-\n-        }\n-\n-        // Don't do this if the virtual machine is one of the special types\n-        // Should only be done on user machines\n-        if (userVm) {\n-            configureNestedVirtualization(details, to);\n-        }\n-        // Determine the VM's OS description\n-        GuestOSVO guestOS = _guestOsDao.findByIdIncludingRemoved(vm.getVirtualMachine().getGuestOSId());\n-        to.setOs(guestOS.getDisplayName());\n-        to.setHostName(vm.getHostName());\n-        HostVO host = _hostDao.findById(vm.getVirtualMachine().getHostId());\n-        GuestOSHypervisorVO guestOsMapping = null;\n-        if (host != null) {\n-            guestOsMapping = _guestOsHypervisorDao.findByOsIdAndHypervisor(guestOS.getId(), getHypervisorType().toString(), host.getHypervisorVersion());\n-        }\n-        if (guestOsMapping == null || host == null) {\n-            to.setPlatformEmulator(null);\n-        } else {\n-            to.setPlatformEmulator(guestOsMapping.getGuestOsName());\n-        }\n-\n-        List<OVFPropertyTO> ovfProperties = new ArrayList<>();\n-        for (String detailKey : details.keySet()) {\n-            if (detailKey.startsWith(ApiConstants.OVF_PROPERTIES)) {\n-                String ovfPropKey = detailKey.replace(ApiConstants.OVF_PROPERTIES + \"-\", \"\");\n-                TemplateOVFPropertyVO templateOVFPropertyVO = templateOVFPropertiesDao.findByTemplateAndKey(vm.getTemplateId(), ovfPropKey);\n-                if (templateOVFPropertyVO == null) {\n-                    s_logger.warn(String.format(\"OVF property %s not found on template, discarding\", ovfPropKey));\n-                    continue;\n-                }\n-                String ovfValue = details.get(detailKey);\n-                boolean isPassword = templateOVFPropertyVO.isPassword();\n-                OVFPropertyTO propertyTO = new OVFPropertyTO(ovfPropKey, ovfValue, isPassword);\n-                ovfProperties.add(propertyTO);\n-            }\n-        }\n-\n-        if (CollectionUtils.isNotEmpty(ovfProperties)) {\n-            removeOvfPropertiesFromDetails(ovfProperties, details);\n-            String templateInstallPath = null;\n-            List<DiskTO> rootDiskList = vm.getDisks().stream().filter(x -> x.getType() == Volume.Type.ROOT).collect(Collectors.toList());\n-            if (rootDiskList.size() != 1) {\n-                throw new CloudRuntimeException(\"Did not find only one root disk for VM \" + vm.getHostName());\n-            }\n-\n-            DiskTO rootDiskTO = rootDiskList.get(0);\n-            DataStoreTO dataStore = rootDiskTO.getData().getDataStore();\n-            StoragePoolVO storagePoolVO = _storagePoolDao.findByUuid(dataStore.getUuid());\n-            long dataCenterId = storagePoolVO.getDataCenterId();\n-            List<StoragePoolVO> pools = _storagePoolDao.listByDataCenterId(dataCenterId);\n-            for (StoragePoolVO pool : pools) {\n-                VMTemplateStoragePoolVO ref = templateStoragePoolDao.findByPoolTemplate(pool.getId(), vm.getTemplateId());\n-                if (ref != null && ref.getDownloadState() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n-                    templateInstallPath = ref.getInstallPath();\n-                    break;\n-                }\n-            }\n+    @Override public VirtualMachineTO implement(VirtualMachineProfile vm) {\n+        vmwareVmImplementer = ComponentContext.inject(new VmwareVmImplementer(this));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 425}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQwMzgxOQ==", "bodyText": "trying to clean it up enough to deal with the cyclic dependencies.", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r419403819", "createdAt": "2020-05-04T12:38:21Z", "author": {"login": "DaanHoogland"}, "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/guru/VMwareGuru.java", "diffHunk": "@@ -172,326 +157,59 @@\n public class VMwareGuru extends HypervisorGuruBase implements HypervisorGuru, Configurable {\n     private static final Logger s_logger = Logger.getLogger(VMwareGuru.class);\n \n-    @Inject\n-    private NetworkDao _networkDao;\n-    @Inject\n-    private GuestOSDao _guestOsDao;\n-    @Inject\n-    private GuestOSHypervisorDao _guestOsHypervisorDao;\n-    @Inject\n-    private HostDao _hostDao;\n-    @Inject\n-    private HostDetailsDao _hostDetailsDao;\n-    @Inject\n-    private ClusterDetailsDao _clusterDetailsDao;\n-    @Inject\n-    private CommandExecLogDao _cmdExecLogDao;\n-    @Inject\n-    private VmwareManager _vmwareMgr;\n-    @Inject\n-    private SecondaryStorageVmManager _secStorageMgr;\n-    @Inject\n-    private NetworkModel _networkMgr;\n-    @Inject\n-    private NicDao _nicDao;\n-    @Inject\n-    private DomainRouterDao _domainRouterDao;\n-    @Inject\n-    private PhysicalNetworkTrafficTypeDao _physicalNetworkTrafficTypeDao;\n-    @Inject\n-    private VMInstanceDao _vmDao;\n-    @Inject\n-    private VirtualMachineManager vmManager;\n-    @Inject\n-    private ClusterManager _clusterMgr;\n-    @Inject\n-    VolumeDao _volumeDao;\n-    @Inject\n-    ResourceLimitService _resourceLimitService;\n-    @Inject\n-    PrimaryDataStoreDao _storagePoolDao;\n-    @Inject\n-    VolumeDataFactory _volFactory;\n-    @Inject\n-    private VmwareDatacenterDao vmwareDatacenterDao;\n-    @Inject\n-    private VmwareDatacenterZoneMapDao vmwareDatacenterZoneMapDao;\n-    @Inject\n-    private ServiceOfferingDao serviceOfferingDao;\n-    @Inject\n-    private VMTemplatePoolDao templateStoragePoolDao;\n-    @Inject\n-    private VMTemplateDao vmTemplateDao;\n-    @Inject\n-    private UserVmDao userVmDao;\n-    @Inject\n-    private DiskOfferingDao diskOfferingDao;\n-    @Inject\n-    private PhysicalNetworkDao physicalNetworkDao;\n-    @Inject\n-    private TemplateOVFPropertiesDao templateOVFPropertiesDao;\n+\n+    private VmwareVmImplementer vmwareVmImplementer;\n+\n+    @Inject NetworkDao _networkDao;\n+    @Inject GuestOSDao _guestOsDao;\n+    @Inject HostDao _hostDao;\n+    @Inject HostDetailsDao _hostDetailsDao;\n+    @Inject ClusterDetailsDao _clusterDetailsDao;\n+    @Inject CommandExecLogDao _cmdExecLogDao;\n+    @Inject VmwareManager _vmwareMgr;\n+    @Inject SecondaryStorageVmManager _secStorageMgr;\n+    @Inject NicDao _nicDao;\n+    @Inject PhysicalNetworkTrafficTypeDao _physicalNetworkTrafficTypeDao;\n+    @Inject VMInstanceDao _vmDao;\n+    @Inject VirtualMachineManager vmManager;\n+    @Inject ClusterManager _clusterMgr;\n+    @Inject VolumeDao _volumeDao;\n+    @Inject ResourceLimitService _resourceLimitService;\n+    @Inject PrimaryDataStoreDao _storagePoolDao;\n+    @Inject VolumeDataFactory _volFactory;\n+    @Inject VmwareDatacenterDao vmwareDatacenterDao;\n+    @Inject VmwareDatacenterZoneMapDao vmwareDatacenterZoneMapDao;\n+    @Inject ServiceOfferingDao serviceOfferingDao;\n+    @Inject VMTemplatePoolDao templateStoragePoolDao;\n+    @Inject VMTemplateDao vmTemplateDao;\n+    @Inject UserVmDao userVmDao;\n+    @Inject DiskOfferingDao diskOfferingDao;\n+    @Inject PhysicalNetworkDao physicalNetworkDao;\n \n     protected VMwareGuru() {\n         super();\n     }\n \n     public static final ConfigKey<Boolean> VmwareReserveCpu = new ConfigKey<Boolean>(Boolean.class, \"vmware.reserve.cpu\", \"Advanced\", \"false\",\n-        \"Specify whether or not to reserve CPU when deploying an instance.\", true, ConfigKey.Scope.Cluster,\n-        null);\n+            \"Specify whether or not to reserve CPU when deploying an instance.\", true, ConfigKey.Scope.Cluster, null);\n \n     public static final ConfigKey<Boolean> VmwareReserveMemory = new ConfigKey<Boolean>(Boolean.class, \"vmware.reserve.mem\", \"Advanced\", \"false\",\n-        \"Specify whether or not to reserve memory when deploying an instance.\", true,\n-        ConfigKey.Scope.Cluster, null);\n+            \"Specify whether or not to reserve memory when deploying an instance.\", true, ConfigKey.Scope.Cluster, null);\n \n     protected ConfigKey<Boolean> VmwareEnableNestedVirtualization = new ConfigKey<Boolean>(Boolean.class, \"vmware.nested.virtualization\", \"Advanced\", \"false\",\n             \"When set to true this will enable nested virtualization when this is supported by the hypervisor\", true, ConfigKey.Scope.Global, null);\n \n     protected ConfigKey<Boolean> VmwareEnableNestedVirtualizationPerVM = new ConfigKey<Boolean>(Boolean.class, \"vmware.nested.virtualization.perVM\", \"Advanced\", \"false\",\n             \"When set to true this will enable nested virtualization per vm\", true, ConfigKey.Scope.Global, null);\n \n-    @Override\n-    public HypervisorType getHypervisorType() {\n+    @Override public HypervisorType getHypervisorType() {\n         return HypervisorType.VMware;\n     }\n \n-    @Override\n-    public VirtualMachineTO implement(VirtualMachineProfile vm) {\n-        VirtualMachineTO to = toVirtualMachineTO(vm);\n-        to.setBootloader(BootloaderType.HVM);\n-\n-        Map<String, String> details = to.getDetails();\n-        if (details == null)\n-            details = new HashMap<String, String>();\n-\n-        Type vmType = vm.getType();\n-        boolean userVm = !(vmType.equals(VirtualMachine.Type.DomainRouter) || vmType.equals(VirtualMachine.Type.ConsoleProxy)\n-                || vmType.equals(VirtualMachine.Type.SecondaryStorageVm));\n-\n-        String nicDeviceType = details.get(VmDetailConstants.NIC_ADAPTER);\n-        if (!userVm) {\n-\n-            if (nicDeviceType == null) {\n-                details.put(VmDetailConstants.NIC_ADAPTER, _vmwareMgr.getSystemVMDefaultNicAdapterType());\n-            } else {\n-                try {\n-                    VirtualEthernetCardType.valueOf(nicDeviceType);\n-                } catch (Exception e) {\n-                    s_logger.warn(\"Invalid NIC device type \" + nicDeviceType + \" is specified in VM details, switch to default E1000\");\n-                    details.put(VmDetailConstants.NIC_ADAPTER, VirtualEthernetCardType.E1000.toString());\n-                }\n-            }\n-        } else {\n-            // for user-VM, use E1000 as default\n-            if (nicDeviceType == null) {\n-                details.put(VmDetailConstants.NIC_ADAPTER, VirtualEthernetCardType.E1000.toString());\n-            } else {\n-                try {\n-                    VirtualEthernetCardType.valueOf(nicDeviceType);\n-                } catch (Exception e) {\n-                    s_logger.warn(\"Invalid NIC device type \" + nicDeviceType + \" is specified in VM details, switch to default E1000\");\n-                    details.put(VmDetailConstants.NIC_ADAPTER, VirtualEthernetCardType.E1000.toString());\n-                }\n-            }\n-        }\n-\n-        details.put(VmDetailConstants.BOOT_MODE, to.getBootMode());\n-        String diskDeviceType = details.get(VmDetailConstants.ROOT_DISK_CONTROLLER);\n-        if (userVm) {\n-            if (diskDeviceType == null) {\n-                details.put(VmDetailConstants.ROOT_DISK_CONTROLLER, _vmwareMgr.getRootDiskController());\n-            }\n-        }\n-        String diskController = details.get(VmDetailConstants.DATA_DISK_CONTROLLER);\n-        if (userVm) {\n-            if (diskController == null) {\n-                details.put(VmDetailConstants.DATA_DISK_CONTROLLER, DiskControllerType.lsilogic.toString());\n-            }\n-        }\n-\n-        if (vm.getType() == VirtualMachine.Type.NetScalerVm) {\n-            details.put(VmDetailConstants.ROOT_DISK_CONTROLLER, \"scsi\");\n-        }\n-\n-        List<NicProfile> nicProfiles = vm.getNics();\n-\n-        for (NicProfile nicProfile : nicProfiles) {\n-            if (nicProfile.getTrafficType() == TrafficType.Guest) {\n-                if (_networkMgr.isProviderSupportServiceInNetwork(nicProfile.getNetworkId(), Service.Firewall, Provider.CiscoVnmc)) {\n-                    details.put(\"ConfigureVServiceInNexus\", Boolean.TRUE.toString());\n-                }\n-                break;\n-            }\n-        }\n-\n-        long clusterId = getClusterId(vm.getId());\n-        details.put(VmwareReserveCpu.key(), VmwareReserveCpu.valueIn(clusterId).toString());\n-        details.put(VmwareReserveMemory.key(), VmwareReserveMemory.valueIn(clusterId).toString());\n-        to.setDetails(details);\n-\n-        if (vmType.equals(VirtualMachine.Type.DomainRouter)) {\n-\n-            NicProfile publicNicProfile = null;\n-            for (NicProfile nicProfile : nicProfiles) {\n-                if (nicProfile.getTrafficType() == TrafficType.Public) {\n-                    publicNicProfile = nicProfile;\n-                    break;\n-                }\n-            }\n-\n-            if (publicNicProfile != null) {\n-                NicTO[] nics = to.getNics();\n-\n-                // reserve extra NICs\n-                NicTO[] expandedNics = new NicTO[nics.length + _vmwareMgr.getRouterExtraPublicNics()];\n-                int i = 0;\n-                int deviceId = -1;\n-                for (i = 0; i < nics.length; i++) {\n-                    expandedNics[i] = nics[i];\n-                    if (nics[i].getDeviceId() > deviceId)\n-                        deviceId = nics[i].getDeviceId();\n-                }\n-                deviceId++;\n-\n-                long networkId = publicNicProfile.getNetworkId();\n-                NetworkVO network = _networkDao.findById(networkId);\n-\n-                for (; i < nics.length + _vmwareMgr.getRouterExtraPublicNics(); i++) {\n-                    NicTO nicTo = new NicTO();\n-\n-                    nicTo.setDeviceId(deviceId++);\n-                    nicTo.setBroadcastType(publicNicProfile.getBroadcastType());\n-                    nicTo.setType(publicNicProfile.getTrafficType());\n-                    nicTo.setIp(\"0.0.0.0\");\n-                    nicTo.setNetmask(\"255.255.255.255\");\n-\n-                    try {\n-                        String mac = _networkMgr.getNextAvailableMacAddressInNetwork(networkId);\n-                        nicTo.setMac(mac);\n-                    } catch (InsufficientAddressCapacityException e) {\n-                        throw new CloudRuntimeException(\"unable to allocate mac address on network: \" + networkId);\n-                    }\n-                    nicTo.setDns1(publicNicProfile.getIPv4Dns1());\n-                    nicTo.setDns2(publicNicProfile.getIPv4Dns2());\n-                    if (publicNicProfile.getIPv4Gateway() != null) {\n-                        nicTo.setGateway(publicNicProfile.getIPv4Gateway());\n-                    } else {\n-                        nicTo.setGateway(network.getGateway());\n-                    }\n-                    nicTo.setDefaultNic(false);\n-                    nicTo.setBroadcastUri(publicNicProfile.getBroadCastUri());\n-                    nicTo.setIsolationuri(publicNicProfile.getIsolationUri());\n-\n-                    Integer networkRate = _networkMgr.getNetworkRate(network.getId(), null);\n-                    nicTo.setNetworkRateMbps(networkRate);\n-\n-                    expandedNics[i] = nicTo;\n-                }\n-\n-                to.setNics(expandedNics);\n-\n-                VirtualMachine router = vm.getVirtualMachine();\n-                DomainRouterVO routerVO = _domainRouterDao.findById(router.getId());\n-                if (routerVO != null && routerVO.getIsRedundantRouter()) {\n-                    Long peerRouterId = _nicDao.getPeerRouterId(publicNicProfile.getMacAddress(), router.getId());\n-                    DomainRouterVO peerRouterVO = null;\n-                    if (peerRouterId != null) {\n-                        peerRouterVO = _domainRouterDao.findById(peerRouterId);\n-                        if (peerRouterVO != null) {\n-                            details.put(\"PeerRouterInstanceName\", peerRouterVO.getInstanceName());\n-                        }\n-                    }\n-                }\n-            }\n-\n-            StringBuffer sbMacSequence = new StringBuffer();\n-            for (NicTO nicTo : sortNicsByDeviceId(to.getNics())) {\n-                sbMacSequence.append(nicTo.getMac()).append(\"|\");\n-            }\n-            if (!sbMacSequence.toString().isEmpty()) {\n-                sbMacSequence.deleteCharAt(sbMacSequence.length() - 1);\n-                String bootArgs = to.getBootArgs();\n-                to.setBootArgs(bootArgs + \" nic_macs=\" + sbMacSequence.toString());\n-            }\n-\n-        }\n-\n-        // Don't do this if the virtual machine is one of the special types\n-        // Should only be done on user machines\n-        if (userVm) {\n-            configureNestedVirtualization(details, to);\n-        }\n-        // Determine the VM's OS description\n-        GuestOSVO guestOS = _guestOsDao.findByIdIncludingRemoved(vm.getVirtualMachine().getGuestOSId());\n-        to.setOs(guestOS.getDisplayName());\n-        to.setHostName(vm.getHostName());\n-        HostVO host = _hostDao.findById(vm.getVirtualMachine().getHostId());\n-        GuestOSHypervisorVO guestOsMapping = null;\n-        if (host != null) {\n-            guestOsMapping = _guestOsHypervisorDao.findByOsIdAndHypervisor(guestOS.getId(), getHypervisorType().toString(), host.getHypervisorVersion());\n-        }\n-        if (guestOsMapping == null || host == null) {\n-            to.setPlatformEmulator(null);\n-        } else {\n-            to.setPlatformEmulator(guestOsMapping.getGuestOsName());\n-        }\n-\n-        List<OVFPropertyTO> ovfProperties = new ArrayList<>();\n-        for (String detailKey : details.keySet()) {\n-            if (detailKey.startsWith(ApiConstants.OVF_PROPERTIES)) {\n-                String ovfPropKey = detailKey.replace(ApiConstants.OVF_PROPERTIES + \"-\", \"\");\n-                TemplateOVFPropertyVO templateOVFPropertyVO = templateOVFPropertiesDao.findByTemplateAndKey(vm.getTemplateId(), ovfPropKey);\n-                if (templateOVFPropertyVO == null) {\n-                    s_logger.warn(String.format(\"OVF property %s not found on template, discarding\", ovfPropKey));\n-                    continue;\n-                }\n-                String ovfValue = details.get(detailKey);\n-                boolean isPassword = templateOVFPropertyVO.isPassword();\n-                OVFPropertyTO propertyTO = new OVFPropertyTO(ovfPropKey, ovfValue, isPassword);\n-                ovfProperties.add(propertyTO);\n-            }\n-        }\n-\n-        if (CollectionUtils.isNotEmpty(ovfProperties)) {\n-            removeOvfPropertiesFromDetails(ovfProperties, details);\n-            String templateInstallPath = null;\n-            List<DiskTO> rootDiskList = vm.getDisks().stream().filter(x -> x.getType() == Volume.Type.ROOT).collect(Collectors.toList());\n-            if (rootDiskList.size() != 1) {\n-                throw new CloudRuntimeException(\"Did not find only one root disk for VM \" + vm.getHostName());\n-            }\n-\n-            DiskTO rootDiskTO = rootDiskList.get(0);\n-            DataStoreTO dataStore = rootDiskTO.getData().getDataStore();\n-            StoragePoolVO storagePoolVO = _storagePoolDao.findByUuid(dataStore.getUuid());\n-            long dataCenterId = storagePoolVO.getDataCenterId();\n-            List<StoragePoolVO> pools = _storagePoolDao.listByDataCenterId(dataCenterId);\n-            for (StoragePoolVO pool : pools) {\n-                VMTemplateStoragePoolVO ref = templateStoragePoolDao.findByPoolTemplate(pool.getId(), vm.getTemplateId());\n-                if (ref != null && ref.getDownloadState() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n-                    templateInstallPath = ref.getInstallPath();\n-                    break;\n-                }\n-            }\n+    @Override public VirtualMachineTO implement(VirtualMachineProfile vm) {\n+        vmwareVmImplementer = ComponentContext.inject(new VmwareVmImplementer(this));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0MDg4Mg=="}, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 425}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjM0NjUxOnYy", "diffSide": "RIGHT", "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/guru/VMwareGuru.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTozNToyMFrOGO3gog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTozNToyMFrOGO3gog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0MjcyMg==", "bodyText": "Just format stuff: these annotations have been moved to the same line as the method's firm all over the class", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r418242722", "createdAt": "2020-04-30T19:35:20Z", "author": {"login": "nvazquez"}, "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/guru/VMwareGuru.java", "diffHunk": "@@ -686,8 +400,7 @@ public int compare(NicTO arg0, NicTO arg1) {\n         return new Pair<Boolean, Long>(Boolean.FALSE, new Long(hostId));\n     }\n \n-    @Override\n-    public boolean trackVmHostChange() {\n+    @Override public boolean trackVmHostChange() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3041b0d891d3847786b523d9e7a9e26b9f083e79"}, "originalPosition": 551}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwOTMzOTU0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/cloud/agent/api/to/VirtualMachineTO.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMjoyNDowMFrOGezmWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNzo0MTowM1rOGe5leg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTg2NQ==", "bodyText": "@DaanHoogland Is hardware setup same as boot setup?", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r434955865", "createdAt": "2020-06-04T02:24:00Z", "author": {"login": "rhtyd"}, "path": "api/src/main/java/com/cloud/agent/api/to/VirtualMachineTO.java", "diffHunk": "@@ -65,6 +65,7 @@\n     String uuid;\n     String bootType;\n     String bootMode;\n+    boolean enterHardwareSetup;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734535c573dd3167a0bf8ec2f314b369a9a7a155"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1Mzk0Ng==", "bodyText": "in hindsite this name should have been something like \"bootIntoFirmware\". many names have passed the catwalk. on resource level it is called enterHardwareSetup on API it is bootIntoSetup.", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r435053946", "createdAt": "2020-06-04T07:41:03Z", "author": {"login": "DaanHoogland"}, "path": "api/src/main/java/com/cloud/agent/api/to/VirtualMachineTO.java", "diffHunk": "@@ -65,6 +65,7 @@\n     String uuid;\n     String bootType;\n     String bootMode;\n+    boolean enterHardwareSetup;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTg2NQ=="}, "originalCommit": {"oid": "734535c573dd3167a0bf8ec2f314b369a9a7a155"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzM3NDMxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTo0MToxOFrOGm9AYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTo1NDo0NVrOGm9aLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5ODU5NQ==", "bodyText": "I don't like this message, missing capital \"B\" and in general I don't like it... can we reword it to  \"...not supported for ....\" or similar?", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r443498595", "createdAt": "2020-06-22T11:41:18Z", "author": {"login": "andrijapanicsb"}, "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "diffHunk": "@@ -2866,7 +2892,11 @@ public UserVm rebootVirtualMachine(RebootVMCmd cmd) throws InsufficientCapacityE\n             throw new InvalidParameterValueException(\"Unable to find service offering: \" + serviceOfferingId + \" corresponding to the vm\");\n         }\n \n-        UserVm userVm = rebootVirtualMachine(CallContext.current().getCallingUserId(), vmId);\n+        Boolean enterSetup = cmd.getBootIntoSetup();\n+        if (enterSetup != null && !HypervisorType.VMware.equals(vmInstance.getHypervisorType())) {\n+            throw new InvalidParameterValueException(\"booting into a hardware setup menu does not make sense on \" + vmInstance.getHypervisorType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69db80a2f72e80214eae141d3d7b169b040dec94"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwNTE5OA==", "bodyText": "ah, yes we can but a new re-word PR is needed.", "url": "https://github.com/apache/cloudstack/pull/4021#discussion_r443505198", "createdAt": "2020-06-22T11:54:45Z", "author": {"login": "DaanHoogland"}, "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "diffHunk": "@@ -2866,7 +2892,11 @@ public UserVm rebootVirtualMachine(RebootVMCmd cmd) throws InsufficientCapacityE\n             throw new InvalidParameterValueException(\"Unable to find service offering: \" + serviceOfferingId + \" corresponding to the vm\");\n         }\n \n-        UserVm userVm = rebootVirtualMachine(CallContext.current().getCallingUserId(), vmId);\n+        Boolean enterSetup = cmd.getBootIntoSetup();\n+        if (enterSetup != null && !HypervisorType.VMware.equals(vmInstance.getHypervisorType())) {\n+            throw new InvalidParameterValueException(\"booting into a hardware setup menu does not make sense on \" + vmInstance.getHypervisorType());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5ODU5NQ=="}, "originalCommit": {"oid": "69db80a2f72e80214eae141d3d7b169b040dec94"}, "originalPosition": 82}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3854, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}