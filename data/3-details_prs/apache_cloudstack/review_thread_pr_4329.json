{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3NzUzMjg4", "number": 4329, "reviewThreads": {"totalCount": 115, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDo0MDoyNFrOGmpeag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0xN1QwOTowOToxN1rOGwMF9g==", "hasNextPage": false, "hasPreviousPage": true}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQzMTc4NjAyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/storage/VolumeApiServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDo0MDoyNFrOKXlmdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDo0MDoyNFrOKXlmdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgyMTk0Mw==", "bodyText": "... here. can you extract?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695821943", "createdAt": "2021-08-25T14:40:24Z", "author": {"login": "DaanHoogland"}, "path": "server/src/main/java/com/cloud/storage/VolumeApiServiceImpl.java", "diffHunk": "@@ -2863,7 +2868,12 @@ public Snapshot allocSnapshotForVm(Long vmId, Long volumeId, String snapshotName\n \n         if (volume.getTemplateId() != null) {\n             VMTemplateVO template = _templateDao.findById(volume.getTemplateId());\n-            if (template != null && template.getTemplateType() == Storage.TemplateType.SYSTEM) {\n+            Long instanceId = volume.getInstanceId();\n+            UserVmVO userVmVO = null;\n+            if (instanceId != null) {\n+                userVmVO = _userVmDao.findById(instanceId);\n+            }\n+            if (template != null && template.getTemplateType() == Storage.TemplateType.SYSTEM && (userVmVO == null || !UserVmManager.CKS_NODE.equals(userVmVO.getUserVmType()))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQzMTc5MjgzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/storage/snapshot/SnapshotManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDo0MToyOVrOKXlqdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDo0MToyOVrOKXlqdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgyMjk2NQ==", "bodyText": "this block seems to exist in VolumeApiServiceImpl as well (twice)", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695822965", "createdAt": "2021-08-25T14:41:29Z", "author": {"login": "DaanHoogland"}, "path": "server/src/main/java/com/cloud/storage/snapshot/SnapshotManagerImpl.java", "diffHunk": "@@ -834,7 +835,12 @@ public SnapshotPolicyVO createPolicy(CreateSnapshotPolicyCmd cmd, Account policy\n \n         if (volume.getTemplateId() != null) {\n             VMTemplateVO template = _templateDao.findById(volume.getTemplateId());\n-            if (template != null && template.getTemplateType() == Storage.TemplateType.SYSTEM) {\n+            Long instanceId = volume.getInstanceId();\n+            UserVmVO userVmVO = null;\n+            if (instanceId != null) {\n+                userVmVO = _vmDao.findById(instanceId);\n+            }\n+            if (template != null && template.getTemplateType() == Storage.TemplateType.SYSTEM && (userVmVO == null || !UserVmManager.CKS_NODE.equals(userVmVO.getUserVmType()))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQzMTg4Nzg3OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDo1Njo0MVrOKXmlZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDo1Njo0MVrOKXmlZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgzODA1Mg==", "bodyText": "PerformRegistration()", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695838052", "createdAt": "2021-08-25T14:56:41Z", "author": {"login": "DaanHoogland"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.naming.ConfigurationException;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String mountCommand = \"sudo mount -t nfs %s %s\";\n+    private static final String umountCommand = \"sudo umount %s\";\n+    private static final  String hashAlgorithm = \"MD5\";\n+    private static final String relativeTemplatePath = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String AbsolutetemplatesPath = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String templatesPath = fetchTemplatesPath();\n+    private static final String metadataFileName = \"metadata.ini\";\n+    private static final String metadataFile = templatesPath + metadataFileName;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = relativeTemplatePath + metadataFileName;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = relativeTemplatePath;\n+            }\n+            if (templatePath == null) {\n+                filePath = AbsolutetemplatesPath + metadataFileName;\n+                metaFile = new File(filePath);\n+                templatePath = AbsolutetemplatesPath;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(mountCommand, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(umountCommand, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName, Pair<String, Long> storeUrlAndId) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    newTemplateUrl.get(hypervisor), newTemplateChecksum.get(hypervisor), hypervisorImageFormat.get(hypervisor), hypervisorGuestOsMap.get(hypervisor), hypervisor, storeUrlAndId.second());\n+            templateId = createTemplateObjectInDB(conn, details);\n+            if (templateId == null) {\n+                throw new CloudRuntimeException(String.format(\"Failed to register template for hypervisor: %s\", hypervisor.name()));\n+            }\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            String storageScriptsDir = \"scripts/storage/secondary\";\n+            String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+            if (setupTmpltScript == null) {\n+                throw new ConfigurationException(\"Unable to find the createtmplt.sh\");\n+            }\n+            Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+            scr.add(\"-u\", templateName);\n+            scr.add(\"-f\", templatesPath + fileNames.get(hypervisorAndTemplateName.first()));\n+            scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+            scr.add(\"-d\", destTempFolder);\n+            String result = scr.execute();\n+            if (result != null) {\n+                String errMsg = String.format(\"failed to create template: %s \", result);\n+                LOGGER.error(errMsg);\n+                throw new CloudRuntimeException(errMsg);\n+            }\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details);\n+            Map<String, String> configParams = new HashMap<>();\n+            configParams.put(SystemVmTemplateRegistration.routerTemplateConfigurationNames.get(hypervisorAndTemplateName.first()), hypervisorAndTemplateName.second());\n+            configParams.put(\"minreq.sysvmtemplate.version\", CS_MAJOR_VERSION + \".\" + CS_TINY_VERSION);\n+            updateConfigurationParams(conn, configParams);\n+            updateSystemVMEntries(conn, templateId, hypervisorAndTemplateName);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void parseMetadataFile() {\n+        try {\n+            Ini ini = new Ini();\n+            ini.load(new FileReader(metadataFile));\n+            for (Hypervisor.HypervisorType hypervisorType : hypervisorList) {\n+                String hypervisor = hypervisorType.name().toLowerCase(Locale.ROOT);\n+                Ini.Section section = ini.get(hypervisor);\n+                NewTemplateNameList.put(hypervisorType, section.get(\"templatename\"));\n+                fileNames.put(hypervisorType, section.get(\"filename\"));\n+                newTemplateChecksum.put(hypervisorType, section.get(\"checksum\"));\n+                newTemplateUrl.put(hypervisorType, section.get(\"downloadurl\"));\n+            }\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to parse systemVM template metadata file: %s\", metadataFile);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void cleanupStore(Long templateId) {\n+        String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + String.valueOf(templateId);\n+        Script.runSimpleBashScript(\"rm -rf \" + destTempFolder);\n+    }\n+\n+    public static void registerTemplates(Connection conn, Set<Hypervisor.HypervisorType> hypervisorsInUse) {\n+        GlobalLock lock = GlobalLock.getInternLock(\"UpgradeDatabase-Lock\");\n+        try {\n+            LOGGER.info(\"Grabbing lock to register templates.\");\n+            if (!lock.lock(LOCK_WAIT_TIMEOUT)) {\n+                throw new CloudRuntimeException(\"Unable to acquire lock to register SystemVM template.\");\n+            }\n+            // Check if templates path exists\n+            try {\n+                Set<String> hypervisors = hypervisorsInUse.stream().map(Enum::name).\n+                        map(name -> name.toLowerCase(Locale.ROOT)).map(SystemVmTemplateRegistration::getHypervisorName).collect(Collectors.toSet());\n+                List<String> templates = new ArrayList<>();\n+                for (Hypervisor.HypervisorType hypervisorType : hypervisorsInUse) {\n+                    templates.add(fileNames.get(hypervisorType));\n+                }\n+\n+                boolean templatesFound = true;\n+                for (String hypervisor : hypervisors) {\n+                    String matchedTemplate = templates.stream().filter(x -> x.contains(hypervisor)).findAny().orElse(null);\n+                    if (matchedTemplate == null) {\n+                        templatesFound = false;\n+                        break;\n+                    }\n+                    MessageDigest mdigest = MessageDigest.getInstance(hashAlgorithm);\n+                    File tempFile = new File(templatesPath + matchedTemplate);\n+                    String templateChecksum = calculateChecksum(mdigest, tempFile);\n+                    if (!templateChecksum.equals(newTemplateChecksum.get(getHypervisorType(hypervisor)))) {\n+                        LOGGER.error(String.format(\"Checksum mismatch: %s != %s \", templateChecksum, newTemplateChecksum.get(getHypervisorType(hypervisor))));\n+                        templatesFound = false;\n+                        break;\n+                    }\n+                }\n+\n+                if (!templatesFound) {\n+                    String errMsg = \"SystemVm template not found. Cannot upgrade system Vms\";\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+\n+                // Perform Registration if templates not already registered", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 732}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQ0MTE2MjUzOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwODo0NDozM1rOKY9nmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwODo0NDozM1rOKY9nmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI2NDAyNQ==", "bodyText": "@Pearl1594 just check/revisit", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697264025", "createdAt": "2021-08-27T08:44:33Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,778 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.dc.dao.ClusterDao;\n+import com.cloud.dc.dao.ClusterDaoImpl;\n+import com.cloud.dc.dao.DataCenterDao;\n+import com.cloud.dc.dao.DataCenterDaoImpl;\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.Storage;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateStorageResourceAssoc;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.storage.dao.VMTemplateDaoImpl;\n+import com.cloud.template.VirtualMachineTemplate;\n+import com.cloud.upgrade.dao.BasicTemplateDataStoreDaoImpl;\n+import com.cloud.user.Account;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.db.Transaction;\n+import com.cloud.utils.db.TransactionCallbackNoReturn;\n+import com.cloud.utils.db.TransactionStatus;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import com.cloud.vm.dao.VMInstanceDao;\n+import com.cloud.vm.dao.VMInstanceDaoImpl;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/systemvm/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    public static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQ0MTE4NjUwOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwODo0OTo1NVrOKY91wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwODo0OTo1NVrOKY91wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI2NzY1MA==", "bodyText": "@Pearl1594 can we make it use dao/vo as well?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697267650", "createdAt": "2021-08-27T08:49:55Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,778 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.dc.dao.ClusterDao;\n+import com.cloud.dc.dao.ClusterDaoImpl;\n+import com.cloud.dc.dao.DataCenterDao;\n+import com.cloud.dc.dao.DataCenterDaoImpl;\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.Storage;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateStorageResourceAssoc;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.storage.dao.VMTemplateDaoImpl;\n+import com.cloud.template.VirtualMachineTemplate;\n+import com.cloud.upgrade.dao.BasicTemplateDataStoreDaoImpl;\n+import com.cloud.user.Account;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.db.Transaction;\n+import com.cloud.utils.db.TransactionCallbackNoReturn;\n+import com.cloud.utils.db.TransactionStatus;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import com.cloud.vm.dao.VMInstanceDao;\n+import com.cloud.vm.dao.VMInstanceDaoImpl;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/systemvm/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    public static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARTIAL_TEMPLATE_FOLDER = String.format(\"/template/tmpl/%d/\", Account.ACCOUNT_ID_SYSTEM);\n+    private static final String FETCH_REGISTERED_TEMPLATE_INSTALL_PATH = \"SELECT install_path FROM `cloud`.`template_store_ref` where template_id = ? LIMIT 1\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQ0MTE5MzQ3OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwODo1MToxOFrOKY95tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwODo1MToxOFrOKY95tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI2ODY2MA==", "bodyText": "Put a comment to explain the guest OS ID", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697268660", "createdAt": "2021-08-27T08:51:18Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,778 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.dc.dao.ClusterDao;\n+import com.cloud.dc.dao.ClusterDaoImpl;\n+import com.cloud.dc.dao.DataCenterDao;\n+import com.cloud.dc.dao.DataCenterDaoImpl;\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.Storage;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateStorageResourceAssoc;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.storage.dao.VMTemplateDaoImpl;\n+import com.cloud.template.VirtualMachineTemplate;\n+import com.cloud.upgrade.dao.BasicTemplateDataStoreDaoImpl;\n+import com.cloud.user.Account;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.db.Transaction;\n+import com.cloud.utils.db.TransactionCallbackNoReturn;\n+import com.cloud.utils.db.TransactionStatus;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import com.cloud.vm.dao.VMInstanceDao;\n+import com.cloud.vm.dao.VMInstanceDaoImpl;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/systemvm/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    public static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARTIAL_TEMPLATE_FOLDER = String.format(\"/template/tmpl/%d/\", Account.ACCOUNT_ID_SYSTEM);\n+    private static final String FETCH_REGISTERED_TEMPLATE_INSTALL_PATH = \"SELECT install_path FROM `cloud`.`template_store_ref` where template_id = ? LIMIT 1\";\n+    private static final String storageScriptsDir = \"scripts/storage/secondary\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    private static final Integer TOKEN_LENGTH = 10;\n+\n+    public static String CS_MAJOR_VERSION = null;\n+    public static String CS_TINY_VERSION = null;\n+\n+    @Inject\n+    DataCenterDao dataCenterDao;\n+    @Inject\n+    VMTemplateDao vmTemplateDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    VMInstanceDao vmInstanceDao;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    ClusterDao clusterDao;\n+    @Inject\n+    ConfigurationDao configurationDao;\n+\n+    public SystemVmTemplateRegistration() {\n+        dataCenterDao = new DataCenterDaoImpl();\n+        vmTemplateDao = new VMTemplateDaoImpl();\n+        templateDataStoreDao = new BasicTemplateDataStoreDaoImpl();\n+        vmInstanceDao = new VMInstanceDaoImpl();\n+        imageStoreDao = new ImageStoreDaoImpl();\n+        clusterDao = new ClusterDaoImpl();\n+        configurationDao = new ConfigurationDaoImpl();\n+    }\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> FileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183"}, "originalPosition": 278}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQ0MTIwNzQzOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwODo1NDowNFrOKY-BpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwODo1NDowNFrOKY-BpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI3MDY5Mw==", "bodyText": "Explore use of Files", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697270693", "createdAt": "2021-08-27T08:54:04Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,778 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.dc.dao.ClusterDao;\n+import com.cloud.dc.dao.ClusterDaoImpl;\n+import com.cloud.dc.dao.DataCenterDao;\n+import com.cloud.dc.dao.DataCenterDaoImpl;\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.Storage;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateStorageResourceAssoc;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.storage.dao.VMTemplateDaoImpl;\n+import com.cloud.template.VirtualMachineTemplate;\n+import com.cloud.upgrade.dao.BasicTemplateDataStoreDaoImpl;\n+import com.cloud.user.Account;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.db.Transaction;\n+import com.cloud.utils.db.TransactionCallbackNoReturn;\n+import com.cloud.utils.db.TransactionStatus;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import com.cloud.vm.dao.VMInstanceDao;\n+import com.cloud.vm.dao.VMInstanceDaoImpl;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/systemvm/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    public static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARTIAL_TEMPLATE_FOLDER = String.format(\"/template/tmpl/%d/\", Account.ACCOUNT_ID_SYSTEM);\n+    private static final String FETCH_REGISTERED_TEMPLATE_INSTALL_PATH = \"SELECT install_path FROM `cloud`.`template_store_ref` where template_id = ? LIMIT 1\";\n+    private static final String storageScriptsDir = \"scripts/storage/secondary\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    private static final Integer TOKEN_LENGTH = 10;\n+\n+    public static String CS_MAJOR_VERSION = null;\n+    public static String CS_TINY_VERSION = null;\n+\n+    @Inject\n+    DataCenterDao dataCenterDao;\n+    @Inject\n+    VMTemplateDao vmTemplateDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    VMInstanceDao vmInstanceDao;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    ClusterDao clusterDao;\n+    @Inject\n+    ConfigurationDao configurationDao;\n+\n+    public SystemVmTemplateRegistration() {\n+        dataCenterDao = new DataCenterDaoImpl();\n+        vmTemplateDao = new VMTemplateDaoImpl();\n+        templateDataStoreDao = new BasicTemplateDataStoreDaoImpl();\n+        vmInstanceDao = new VMInstanceDaoImpl();\n+        imageStoreDao = new ImageStoreDaoImpl();\n+        clusterDao = new ClusterDaoImpl();\n+        configurationDao = new ConfigurationDaoImpl();\n+    }\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> FileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static String generateToken(int length) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183"}, "originalPosition": 298}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQ0MTIxMzIyOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwODo1NToxM1rOKY-E_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwODo1NToxM1rOKY-E_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI3MTU0OA==", "bodyText": "Nit - Magic no. check can be avoided if primitive fields are not used", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697271548", "createdAt": "2021-08-27T08:55:13Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,778 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.dc.dao.ClusterDao;\n+import com.cloud.dc.dao.ClusterDaoImpl;\n+import com.cloud.dc.dao.DataCenterDao;\n+import com.cloud.dc.dao.DataCenterDaoImpl;\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.Storage;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateStorageResourceAssoc;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.storage.dao.VMTemplateDaoImpl;\n+import com.cloud.template.VirtualMachineTemplate;\n+import com.cloud.upgrade.dao.BasicTemplateDataStoreDaoImpl;\n+import com.cloud.user.Account;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.db.Transaction;\n+import com.cloud.utils.db.TransactionCallbackNoReturn;\n+import com.cloud.utils.db.TransactionStatus;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import com.cloud.vm.dao.VMInstanceDao;\n+import com.cloud.vm.dao.VMInstanceDaoImpl;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/systemvm/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    public static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARTIAL_TEMPLATE_FOLDER = String.format(\"/template/tmpl/%d/\", Account.ACCOUNT_ID_SYSTEM);\n+    private static final String FETCH_REGISTERED_TEMPLATE_INSTALL_PATH = \"SELECT install_path FROM `cloud`.`template_store_ref` where template_id = ? LIMIT 1\";\n+    private static final String storageScriptsDir = \"scripts/storage/secondary\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    private static final Integer TOKEN_LENGTH = 10;\n+\n+    public static String CS_MAJOR_VERSION = null;\n+    public static String CS_TINY_VERSION = null;\n+\n+    @Inject\n+    DataCenterDao dataCenterDao;\n+    @Inject\n+    VMTemplateDao vmTemplateDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    VMInstanceDao vmInstanceDao;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    ClusterDao clusterDao;\n+    @Inject\n+    ConfigurationDao configurationDao;\n+\n+    public SystemVmTemplateRegistration() {\n+        dataCenterDao = new DataCenterDaoImpl();\n+        vmTemplateDao = new VMTemplateDaoImpl();\n+        templateDataStoreDao = new BasicTemplateDataStoreDaoImpl();\n+        vmInstanceDao = new VMInstanceDaoImpl();\n+        imageStoreDao = new ImageStoreDaoImpl();\n+        clusterDao = new ClusterDaoImpl();\n+        configurationDao = new ConfigurationDaoImpl();\n+    }\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> FileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static String generateToken(int length) {\n+        String charset = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+        Random rand = new Random(System.currentTimeMillis());\n+        StringBuffer sb = new StringBuffer();\n+        for (int i = 0; i < length; i++) {\n+            int pos = rand.nextInt(charset.length());\n+            sb.append(charset.charAt(pos));\n+        }\n+        return sb.toString();\n+    }\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        String filePath = TEMPORARY_SECONDARY_STORE + generateToken(TOKEN_LENGTH);\n+        try {\n+            mountStore(url, filePath);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = filePath + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            LOGGER.error(\"Failed to verify if the template is seeded\", e);\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore(filePath);\n+        }\n+    }\n+\n+    private String calculateChecksum(File file) {\n+        try (InputStream is = Files.newInputStream(Paths.get(file.getPath()))) {\n+            return DigestUtils.md5Hex(is);\n+        } catch (IOException e) {\n+            String errMsg = \"Failed to calculate template checksum\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public long getRegisteredTemplateId(Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        VMTemplateVO vmTemplate = vmTemplateDao.findLatestTemplateByName(hypervisorAndTemplateName.second());\n+        long templateId = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183"}, "originalPosition": 343}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQ0MTI1MjcxOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41510to41600.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwOTowMzo1M1rOKY-ckQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwOTowMzo1M1rOKY-ckQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI3NzU4NQ==", "bodyText": "Can we refactor and move this to the systemvmtemplate check/register service/class...", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697277585", "createdAt": "2021-08-27T09:03:53Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41510to41600.java", "diffHunk": "@@ -66,10 +71,15 @@ public boolean supportsRollingUpgrade() {\n     public void performDataMigration(Connection conn) {\n     }\n \n+    private void initSystemVmTemplateRegistration() {\n+        systemVmTemplateRegistration = new SystemVmTemplateRegistration();\n+    }\n+\n     @Override\n     @SuppressWarnings(\"serial\")\n     public void updateSystemVmTemplates(final Connection conn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQ0MTMzNzAxOnYy", "diffSide": "RIGHT", "path": "tools/marvin/marvin/config/test_data.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwOToyMzo1M1rOKY_PtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwOToyMzo1M1rOKY_PtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI5MDY3Nw==", "bodyText": "Maybe a typo?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697290677", "createdAt": "2021-08-27T09:23:53Z", "author": {"login": "rhtyd"}, "path": "tools/marvin/marvin/config/test_data.py", "diffHunk": "@@ -2058,46 +2052,11 @@\n         },\n         \"1.16.3\": {\n             \"semanticversion\": \"1.16.3\",\n-            \"url\": \"http://download.cloudstack.org/cks/setup-1.16.3.iso\",\n+            \"url\": \"http://download.cloudstack.org/cks/as-1.16.3.iso\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183"}, "originalPosition": 18}]}}, {"id": "PRRT_kwDOAJTq2M4a-IK-", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/dc/dao/ClusterDao.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0xNlQwNzoxMjo0NVrOKk9PfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0xNlQwNzoxMjo0NVrOKk9PfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "PRRC_kwDOAJTq2M4qT098", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Set<HypervisorType> getDistictAvailableHypervisorsAcrossClusters();\n          \n          \n            \n                Set<HypervisorType> getDistinctAvailableHypervisorsAcrossClusters();\n          \n      \n    \n    \n  \n\ntypo ^^^", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r709840764", "createdAt": "2021-09-16T07:12:45Z", "author": {"login": "sureshanaparti"}, "path": "engine/schema/src/main/java/com/cloud/dc/dao/ClusterDao.java", "diffHunk": "@@ -34,6 +35,8 @@\n \n     List<HypervisorType> getAvailableHypervisorInZone(Long zoneId);\n \n+    Set<HypervisorType> getDistictAvailableHypervisorsAcrossClusters();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a03b25ab4556211efa3d80854b557952a38d15"}, "originalPosition": 12}]}}, {"id": "PRRT_kwDOAJTq2M4a-IY9", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/dc/dao/ClusterDaoImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0xNlQwNzoxMzo1MFrOKk9UIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0xNlQwNzoxMzo1MFrOKk9UIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "PRRC_kwDOAJTq2M4qT1Qg", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Set<HypervisorType> hypers = new HashSet<>();\n          \n          \n            \n                    Set<HypervisorType> hypervisorTypes = new HashSet<>();", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r709841952", "createdAt": "2021-09-16T07:13:50Z", "author": {"login": "sureshanaparti"}, "path": "engine/schema/src/main/java/com/cloud/dc/dao/ClusterDaoImpl.java", "diffHunk": "@@ -154,6 +161,17 @@ public ClusterVO findBy(String name, long podId) {\n         return hypers;\n     }\n \n+    @Override\n+    public Set<HypervisorType> getDistictAvailableHypervisorsAcrossClusters() {\n+        SearchCriteria<ClusterVO> sc = ClusterSearch.create();\n+        List<ClusterVO> clusters = listBy(sc);\n+        Set<HypervisorType> hypers = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a03b25ab4556211efa3d80854b557952a38d15"}, "originalPosition": 38}]}}, {"id": "PRRT_kwDOAJTq2M4a-Jli", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0xNlQwNzoyMDoxNlrOKk9wug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0xNlQwNzoyMDoxNlrOKk9wug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "PRRC_kwDOAJTq2M4qT3C6", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class SystemVmTemplateRegistration {\n          \n          \n            \n            public class SystemVmTemplate {", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r709849274", "createdAt": "2021-09-16T07:20:16Z", "author": {"login": "sureshanaparti"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,849 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.dc.dao.ClusterDao;\n+import com.cloud.dc.dao.ClusterDaoImpl;\n+import com.cloud.dc.dao.DataCenterDao;\n+import com.cloud.dc.dao.DataCenterDaoImpl;\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.Storage;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateStorageResourceAssoc;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.storage.dao.VMTemplateDaoImpl;\n+import com.cloud.template.VirtualMachineTemplate;\n+import com.cloud.upgrade.dao.BasicTemplateDataStoreDaoImpl;\n+import com.cloud.user.Account;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.db.Transaction;\n+import com.cloud.utils.db.TransactionCallbackNoReturn;\n+import com.cloud.utils.db.TransactionStatus;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import com.cloud.vm.dao.VMInstanceDao;\n+import com.cloud.vm.dao.VMInstanceDaoImpl;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a03b25ab4556211efa3d80854b557952a38d15"}, "originalPosition": 80}]}}, {"id": "PRRT_kwDOAJTq2M4bAwLj", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41520to41600.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0xN1QwOTowNzo0NlrOKl9HTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0xN1QwOToxOTo1M1rOKl9pwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "PRRC_kwDOAJTq2M4qX0dN", "bodyText": "shouldn't this now become a standard check and no longer part of a specific upgrade step?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r710887245", "createdAt": "2021-09-17T09:07:46Z", "author": {"login": "DaanHoogland"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41520to41600.java", "diffHunk": "@@ -92,173 +92,20 @@ private void generateUuidForExistingSshKeyPairs(Connection conn) {\n         }\n     }\n \n+    private void initSystemVmTemplateRegistration() {\n+        systemVmTemplateRegistration = new SystemVmTemplateRegistration();\n+    }\n+\n     @Override\n     @SuppressWarnings(\"serial\")\n     public void updateSystemVmTemplates(final Connection conn) {\n         LOG.debug(\"Updating System Vm template IDs\");\n-        final Set<Hypervisor.HypervisorType> hypervisorsListInUse = new HashSet<Hypervisor.HypervisorType>();\n-        try (PreparedStatement pstmt = conn.prepareStatement(\"select distinct(hypervisor_type) from `cloud`.`cluster` where removed is null\"); ResultSet rs = pstmt.executeQuery()) {\n-            while (rs.next()) {\n-                switch (Hypervisor.HypervisorType.getType(rs.getString(1))) {\n-                    case XenServer:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.XenServer);\n-                        break;\n-                    case KVM:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.KVM);\n-                        break;\n-                    case VMware:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.VMware);\n-                        break;\n-                    case Hyperv:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.Hyperv);\n-                        break;\n-                    case LXC:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.LXC);\n-                        break;\n-                    case Ovm3:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.Ovm3);\n-                        break;\n-                    default:\n-                        break;\n-                }\n-            }\n-        } catch (final SQLException e) {\n-            LOG.error(\"updateSystemVmTemplates: Exception caught while getting hypervisor types from clusters: \" + e.getMessage());\n-            throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while getting hypervisor types from clusters\", e);\n-        }\n-\n-        final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>() {\n-            {\n-                put(Hypervisor.HypervisorType.KVM, \"systemvm-kvm-4.16.0\");\n-                put(Hypervisor.HypervisorType.VMware, \"systemvm-vmware-4.16.0\");\n-                put(Hypervisor.HypervisorType.XenServer, \"systemvm-xenserver-4.16.0\");\n-                put(Hypervisor.HypervisorType.Hyperv, \"systemvm-hyperv-4.16.0\");\n-                put(Hypervisor.HypervisorType.LXC, \"systemvm-lxc-4.16.0\");\n-                put(Hypervisor.HypervisorType.Ovm3, \"systemvm-ovm3-4.16.0\");\n-            }\n-        };\n-\n-        final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n-            {\n-                put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n-                put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n-                put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n-                put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n-                put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n-                put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n-            }\n-        };\n-\n-        final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>() {\n-            {\n-                put(Hypervisor.HypervisorType.KVM, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-kvm.qcow2.bz2\");\n-                put(Hypervisor.HypervisorType.VMware, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-vmware.ova\");\n-                put(Hypervisor.HypervisorType.XenServer, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-xen.vhd.bz2\");\n-                put(Hypervisor.HypervisorType.Hyperv, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-hyperv.vhd.zip\");\n-                put(Hypervisor.HypervisorType.LXC, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-kvm.qcow2.bz2\");\n-                put(Hypervisor.HypervisorType.Ovm3, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-ovm.raw.bz2\");\n-            }\n-        };\n-\n-        final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>() {\n-            {\n-                put(Hypervisor.HypervisorType.KVM, \"81b3e48bb934784a13555a43c5ef5ffb\");\n-                put(Hypervisor.HypervisorType.XenServer, \"1b178a5dbdbe090555515340144c6017\");\n-                put(Hypervisor.HypervisorType.VMware, \"e6a88e518c57d6f36c096c4204c3417f\");\n-                put(Hypervisor.HypervisorType.Hyperv, \"5c94da45337cf3e1910dcbe084d4b9ad\");\n-                put(Hypervisor.HypervisorType.LXC, \"81b3e48bb934784a13555a43c5ef5ffb\");\n-                put(Hypervisor.HypervisorType.Ovm3, \"875c5c65455fc06c4a012394410db375\");\n-            }\n-        };\n-\n-        for (final Map.Entry<Hypervisor.HypervisorType, String> hypervisorAndTemplateName : NewTemplateNameList.entrySet()) {\n-            LOG.debug(\"Updating \" + hypervisorAndTemplateName.getKey() + \" System Vms\");\n-            try (PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\")) {\n-                // Get systemvm template id for corresponding hypervisor\n-                long templateId = -1;\n-                pstmt.setString(1, hypervisorAndTemplateName.getValue());\n-                try (ResultSet rs = pstmt.executeQuery()) {\n-                    if (rs.next()) {\n-                        templateId = rs.getLong(1);\n-                    }\n-                } catch (final SQLException e) {\n-                    LOG.error(\"updateSystemVmTemplates: Exception caught while getting ids of templates: \" + e.getMessage());\n-                    throw new CloudRuntimeException(\"updateSystemVmTemplates: Exception caught while getting ids of templates\", e);\n-                }\n-\n-                // change template type to SYSTEM\n-                if (templateId != -1) {\n-                    try (PreparedStatement templ_type_pstmt = conn.prepareStatement(\"update `cloud`.`vm_template` set type='SYSTEM' where id = ?\");) {\n-                        templ_type_pstmt.setLong(1, templateId);\n-                        templ_type_pstmt.executeUpdate();\n-                    } catch (final SQLException e) {\n-                        LOG.error(\"updateSystemVmTemplates:Exception while updating template with id \" + templateId + \" to be marked as 'system': \" + e.getMessage());\n-                        throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while updating template with id \" + templateId + \" to be marked as 'system'\", e);\n-                    }\n-                    // update template ID of system Vms\n-                    try (PreparedStatement update_templ_id_pstmt = conn\n-                            .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");) {\n-                        update_templ_id_pstmt.setLong(1, templateId);\n-                        update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.getKey().toString());\n-                        update_templ_id_pstmt.executeUpdate();\n-                    } catch (final Exception e) {\n-                        LOG.error(\"updateSystemVmTemplates:Exception while setting template for \" + hypervisorAndTemplateName.getKey().toString() + \" to \" + templateId\n-                                + \": \" + e.getMessage());\n-                        throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while setting template for \" + hypervisorAndTemplateName.getKey().toString() + \" to \"\n-                                + templateId, e);\n-                    }\n-\n-                    // Change value of global configuration parameter\n-                    // router.template.* for the corresponding hypervisor\n-                    try (PreparedStatement update_pstmt = conn.prepareStatement(\"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\");) {\n-                        update_pstmt.setString(1, hypervisorAndTemplateName.getValue());\n-                        update_pstmt.setString(2, routerTemplateConfigurationNames.get(hypervisorAndTemplateName.getKey()));\n-                        update_pstmt.executeUpdate();\n-                    } catch (final SQLException e) {\n-                        LOG.error(\"updateSystemVmTemplates:Exception while setting \" + routerTemplateConfigurationNames.get(hypervisorAndTemplateName.getKey()) + \" to \"\n-                                + hypervisorAndTemplateName.getValue() + \": \" + e.getMessage());\n-                        throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while setting \"\n-                                + routerTemplateConfigurationNames.get(hypervisorAndTemplateName.getKey()) + \" to \" + hypervisorAndTemplateName.getValue(), e);\n-                    }\n-\n-                    // Change value of global configuration parameter\n-                    // minreq.sysvmtemplate.version for the ACS version\n-                    try (PreparedStatement update_pstmt = conn.prepareStatement(\"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\");) {\n-                        update_pstmt.setString(1, \"4.16.0\");\n-                        update_pstmt.setString(2, \"minreq.sysvmtemplate.version\");\n-                        update_pstmt.executeUpdate();\n-                    } catch (final SQLException e) {\n-                        LOG.error(\"updateSystemVmTemplates:Exception while setting 'minreq.sysvmtemplate.version' to 4.16.0: \" + e.getMessage());\n-                        throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while setting 'minreq.sysvmtemplate.version' to 4.16.0\", e);\n-                    }\n-                } else {\n-                    if (hypervisorsListInUse.contains(hypervisorAndTemplateName.getKey())) {\n-                        throw new CloudRuntimeException(getUpgradedVersion() + hypervisorAndTemplateName.getKey() + \" SystemVm template not found. Cannot upgrade system Vms\");\n-                    } else {\n-                        LOG.warn(getUpgradedVersion() + hypervisorAndTemplateName.getKey() + \" SystemVm template not found. \" + hypervisorAndTemplateName.getKey()\n-                                + \" hypervisor is not used, so not failing upgrade\");\n-                        // Update the latest template URLs for corresponding\n-                        // hypervisor\n-                        try (PreparedStatement update_templ_url_pstmt = conn\n-                                .prepareStatement(\"UPDATE `cloud`.`vm_template` SET url = ? , checksum = ? WHERE hypervisor_type = ? AND type = 'SYSTEM' AND removed is null order by id desc limit 1\");) {\n-                            update_templ_url_pstmt.setString(1, newTemplateUrl.get(hypervisorAndTemplateName.getKey()));\n-                            update_templ_url_pstmt.setString(2, newTemplateChecksum.get(hypervisorAndTemplateName.getKey()));\n-                            update_templ_url_pstmt.setString(3, hypervisorAndTemplateName.getKey().toString());\n-                            update_templ_url_pstmt.executeUpdate();\n-                        } catch (final SQLException e) {\n-                            LOG.error(\"updateSystemVmTemplates:Exception while updating 'url' and 'checksum' for hypervisor type \"\n-                                    + hypervisorAndTemplateName.getKey().toString() + \": \" + e.getMessage());\n-                            throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while updating 'url' and 'checksum' for hypervisor type \"\n-                                    + hypervisorAndTemplateName.getKey().toString(), e);\n-                        }\n-                    }\n-                }\n-            } catch (final SQLException e) {\n-                LOG.error(\"updateSystemVmTemplates:Exception while getting ids of templates: \" + e.getMessage());\n-                throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while getting ids of templates\", e);\n-            }\n+        initSystemVmTemplateRegistration();\n+        try {\n+            systemVmTemplateRegistration.updateSystemVmTemplates(conn);\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to find / register SystemVM template(s)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a03b25ab4556211efa3d80854b557952a38d15"}, "originalPosition": 202}, {"id": "PRRC_kwDOAJTq2M4qX2nC", "bodyText": "At this point I haven't changed the structuring. Could probably be done as part of Phase2", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r710896066", "createdAt": "2021-09-17T09:19:53Z", "author": {"login": "Pearl1594"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41520to41600.java", "diffHunk": "@@ -92,173 +92,20 @@ private void generateUuidForExistingSshKeyPairs(Connection conn) {\n         }\n     }\n \n+    private void initSystemVmTemplateRegistration() {\n+        systemVmTemplateRegistration = new SystemVmTemplateRegistration();\n+    }\n+\n     @Override\n     @SuppressWarnings(\"serial\")\n     public void updateSystemVmTemplates(final Connection conn) {\n         LOG.debug(\"Updating System Vm template IDs\");\n-        final Set<Hypervisor.HypervisorType> hypervisorsListInUse = new HashSet<Hypervisor.HypervisorType>();\n-        try (PreparedStatement pstmt = conn.prepareStatement(\"select distinct(hypervisor_type) from `cloud`.`cluster` where removed is null\"); ResultSet rs = pstmt.executeQuery()) {\n-            while (rs.next()) {\n-                switch (Hypervisor.HypervisorType.getType(rs.getString(1))) {\n-                    case XenServer:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.XenServer);\n-                        break;\n-                    case KVM:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.KVM);\n-                        break;\n-                    case VMware:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.VMware);\n-                        break;\n-                    case Hyperv:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.Hyperv);\n-                        break;\n-                    case LXC:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.LXC);\n-                        break;\n-                    case Ovm3:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.Ovm3);\n-                        break;\n-                    default:\n-                        break;\n-                }\n-            }\n-        } catch (final SQLException e) {\n-            LOG.error(\"updateSystemVmTemplates: Exception caught while getting hypervisor types from clusters: \" + e.getMessage());\n-            throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while getting hypervisor types from clusters\", e);\n-        }\n-\n-        final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>() {\n-            {\n-                put(Hypervisor.HypervisorType.KVM, \"systemvm-kvm-4.16.0\");\n-                put(Hypervisor.HypervisorType.VMware, \"systemvm-vmware-4.16.0\");\n-                put(Hypervisor.HypervisorType.XenServer, \"systemvm-xenserver-4.16.0\");\n-                put(Hypervisor.HypervisorType.Hyperv, \"systemvm-hyperv-4.16.0\");\n-                put(Hypervisor.HypervisorType.LXC, \"systemvm-lxc-4.16.0\");\n-                put(Hypervisor.HypervisorType.Ovm3, \"systemvm-ovm3-4.16.0\");\n-            }\n-        };\n-\n-        final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n-            {\n-                put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n-                put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n-                put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n-                put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n-                put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n-                put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n-            }\n-        };\n-\n-        final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>() {\n-            {\n-                put(Hypervisor.HypervisorType.KVM, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-kvm.qcow2.bz2\");\n-                put(Hypervisor.HypervisorType.VMware, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-vmware.ova\");\n-                put(Hypervisor.HypervisorType.XenServer, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-xen.vhd.bz2\");\n-                put(Hypervisor.HypervisorType.Hyperv, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-hyperv.vhd.zip\");\n-                put(Hypervisor.HypervisorType.LXC, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-kvm.qcow2.bz2\");\n-                put(Hypervisor.HypervisorType.Ovm3, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-ovm.raw.bz2\");\n-            }\n-        };\n-\n-        final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>() {\n-            {\n-                put(Hypervisor.HypervisorType.KVM, \"81b3e48bb934784a13555a43c5ef5ffb\");\n-                put(Hypervisor.HypervisorType.XenServer, \"1b178a5dbdbe090555515340144c6017\");\n-                put(Hypervisor.HypervisorType.VMware, \"e6a88e518c57d6f36c096c4204c3417f\");\n-                put(Hypervisor.HypervisorType.Hyperv, \"5c94da45337cf3e1910dcbe084d4b9ad\");\n-                put(Hypervisor.HypervisorType.LXC, \"81b3e48bb934784a13555a43c5ef5ffb\");\n-                put(Hypervisor.HypervisorType.Ovm3, \"875c5c65455fc06c4a012394410db375\");\n-            }\n-        };\n-\n-        for (final Map.Entry<Hypervisor.HypervisorType, String> hypervisorAndTemplateName : NewTemplateNameList.entrySet()) {\n-            LOG.debug(\"Updating \" + hypervisorAndTemplateName.getKey() + \" System Vms\");\n-            try (PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\")) {\n-                // Get systemvm template id for corresponding hypervisor\n-                long templateId = -1;\n-                pstmt.setString(1, hypervisorAndTemplateName.getValue());\n-                try (ResultSet rs = pstmt.executeQuery()) {\n-                    if (rs.next()) {\n-                        templateId = rs.getLong(1);\n-                    }\n-                } catch (final SQLException e) {\n-                    LOG.error(\"updateSystemVmTemplates: Exception caught while getting ids of templates: \" + e.getMessage());\n-                    throw new CloudRuntimeException(\"updateSystemVmTemplates: Exception caught while getting ids of templates\", e);\n-                }\n-\n-                // change template type to SYSTEM\n-                if (templateId != -1) {\n-                    try (PreparedStatement templ_type_pstmt = conn.prepareStatement(\"update `cloud`.`vm_template` set type='SYSTEM' where id = ?\");) {\n-                        templ_type_pstmt.setLong(1, templateId);\n-                        templ_type_pstmt.executeUpdate();\n-                    } catch (final SQLException e) {\n-                        LOG.error(\"updateSystemVmTemplates:Exception while updating template with id \" + templateId + \" to be marked as 'system': \" + e.getMessage());\n-                        throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while updating template with id \" + templateId + \" to be marked as 'system'\", e);\n-                    }\n-                    // update template ID of system Vms\n-                    try (PreparedStatement update_templ_id_pstmt = conn\n-                            .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");) {\n-                        update_templ_id_pstmt.setLong(1, templateId);\n-                        update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.getKey().toString());\n-                        update_templ_id_pstmt.executeUpdate();\n-                    } catch (final Exception e) {\n-                        LOG.error(\"updateSystemVmTemplates:Exception while setting template for \" + hypervisorAndTemplateName.getKey().toString() + \" to \" + templateId\n-                                + \": \" + e.getMessage());\n-                        throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while setting template for \" + hypervisorAndTemplateName.getKey().toString() + \" to \"\n-                                + templateId, e);\n-                    }\n-\n-                    // Change value of global configuration parameter\n-                    // router.template.* for the corresponding hypervisor\n-                    try (PreparedStatement update_pstmt = conn.prepareStatement(\"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\");) {\n-                        update_pstmt.setString(1, hypervisorAndTemplateName.getValue());\n-                        update_pstmt.setString(2, routerTemplateConfigurationNames.get(hypervisorAndTemplateName.getKey()));\n-                        update_pstmt.executeUpdate();\n-                    } catch (final SQLException e) {\n-                        LOG.error(\"updateSystemVmTemplates:Exception while setting \" + routerTemplateConfigurationNames.get(hypervisorAndTemplateName.getKey()) + \" to \"\n-                                + hypervisorAndTemplateName.getValue() + \": \" + e.getMessage());\n-                        throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while setting \"\n-                                + routerTemplateConfigurationNames.get(hypervisorAndTemplateName.getKey()) + \" to \" + hypervisorAndTemplateName.getValue(), e);\n-                    }\n-\n-                    // Change value of global configuration parameter\n-                    // minreq.sysvmtemplate.version for the ACS version\n-                    try (PreparedStatement update_pstmt = conn.prepareStatement(\"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\");) {\n-                        update_pstmt.setString(1, \"4.16.0\");\n-                        update_pstmt.setString(2, \"minreq.sysvmtemplate.version\");\n-                        update_pstmt.executeUpdate();\n-                    } catch (final SQLException e) {\n-                        LOG.error(\"updateSystemVmTemplates:Exception while setting 'minreq.sysvmtemplate.version' to 4.16.0: \" + e.getMessage());\n-                        throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while setting 'minreq.sysvmtemplate.version' to 4.16.0\", e);\n-                    }\n-                } else {\n-                    if (hypervisorsListInUse.contains(hypervisorAndTemplateName.getKey())) {\n-                        throw new CloudRuntimeException(getUpgradedVersion() + hypervisorAndTemplateName.getKey() + \" SystemVm template not found. Cannot upgrade system Vms\");\n-                    } else {\n-                        LOG.warn(getUpgradedVersion() + hypervisorAndTemplateName.getKey() + \" SystemVm template not found. \" + hypervisorAndTemplateName.getKey()\n-                                + \" hypervisor is not used, so not failing upgrade\");\n-                        // Update the latest template URLs for corresponding\n-                        // hypervisor\n-                        try (PreparedStatement update_templ_url_pstmt = conn\n-                                .prepareStatement(\"UPDATE `cloud`.`vm_template` SET url = ? , checksum = ? WHERE hypervisor_type = ? AND type = 'SYSTEM' AND removed is null order by id desc limit 1\");) {\n-                            update_templ_url_pstmt.setString(1, newTemplateUrl.get(hypervisorAndTemplateName.getKey()));\n-                            update_templ_url_pstmt.setString(2, newTemplateChecksum.get(hypervisorAndTemplateName.getKey()));\n-                            update_templ_url_pstmt.setString(3, hypervisorAndTemplateName.getKey().toString());\n-                            update_templ_url_pstmt.executeUpdate();\n-                        } catch (final SQLException e) {\n-                            LOG.error(\"updateSystemVmTemplates:Exception while updating 'url' and 'checksum' for hypervisor type \"\n-                                    + hypervisorAndTemplateName.getKey().toString() + \": \" + e.getMessage());\n-                            throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while updating 'url' and 'checksum' for hypervisor type \"\n-                                    + hypervisorAndTemplateName.getKey().toString(), e);\n-                        }\n-                    }\n-                }\n-            } catch (final SQLException e) {\n-                LOG.error(\"updateSystemVmTemplates:Exception while getting ids of templates: \" + e.getMessage());\n-                throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while getting ids of templates\", e);\n-            }\n+        initSystemVmTemplateRegistration();\n+        try {\n+            systemVmTemplateRegistration.updateSystemVmTemplates(conn);\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to find / register SystemVM template(s)\");", "state": "SUBMITTED", "replyTo": {"id": "PRRC_kwDOAJTq2M4qX0dN"}, "originalCommit": {"oid": "28a03b25ab4556211efa3d80854b557952a38d15"}, "originalPosition": 202}]}}, {"id": "PRRT_kwDOAJTq2M4bAwX2", "diffSide": "RIGHT", "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0xN1QwOTowOToxN1rOKl9L4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0xN1QwOToyMTo1NlrOKl9vmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "PRRC_kwDOAJTq2M4qX0vh", "bodyText": "is this change on purpose?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r710888417", "createdAt": "2021-09-17T09:09:17Z", "author": {"login": "DaanHoogland"}, "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "diffHunk": "@@ -48,6 +48,7 @@\n import javax.naming.ConfigurationException;\n import javax.xml.datatype.XMLGregorianCalendar;\n \n+import com.cloud.utils.script.Script;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a03b25ab4556211efa3d80854b557952a38d15"}, "originalPosition": 4}, {"id": "PRRC_kwDOAJTq2M4qX2-Z", "bodyText": "I had initially done some refactor to the logic of fetching id_rsa file and then reverted it - this is probably a consequence of that action", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r710897561", "createdAt": "2021-09-17T09:21:56Z", "author": {"login": "Pearl1594"}, "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "diffHunk": "@@ -48,6 +48,7 @@\n import javax.naming.ConfigurationException;\n import javax.xml.datatype.XMLGregorianCalendar;\n \n+import com.cloud.utils.script.Script;", "state": "SUBMITTED", "replyTo": {"id": "PRRC_kwDOAJTq2M4qX0vh"}, "originalCommit": {"oid": "28a03b25ab4556211efa3d80854b557952a38d15"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMTkxMTc3OnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMjowMDozM1rOHqYjCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMjowMDozM1rOHqYjCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIwNDQyNA==", "bodyText": "this comment could be a method name and the bit below factored out", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514204424", "createdAt": "2020-10-29T12:00:33Z", "author": {"login": "DaanHoogland"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "diffHunk": "@@ -378,17 +376,18 @@ private void setupKubernetesClusterNetworkRules(Network network, List<UserVm> cl\n             throw new ManagementServerException(String.format(\"No source NAT IP addresses found for network : %s, Kubernetes cluster : %s\",\n                 network.getName(), kubernetesCluster.getName()));\n         }\n-\n+        // Firewall rule fo API access for master node VMs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMTkxMzY5OnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMjowMTowNVrOHqYkKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMjowMTowNVrOHqYkKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIwNDcxMw==", "bodyText": "idem; this comment could be a method name and the bit below factored out", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514204713", "createdAt": "2020-10-29T12:01:05Z", "author": {"login": "DaanHoogland"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "diffHunk": "@@ -378,17 +376,18 @@ private void setupKubernetesClusterNetworkRules(Network network, List<UserVm> cl\n             throw new ManagementServerException(String.format(\"No source NAT IP addresses found for network : %s, Kubernetes cluster : %s\",\n                 network.getName(), kubernetesCluster.getName()));\n         }\n-\n+        // Firewall rule fo API access for master node VMs\n         try {\n             provisionFirewallRules(publicIp, owner, CLUSTER_API_PORT, CLUSTER_API_PORT);\n             if (LOGGER.isInfoEnabled()) {\n-                LOGGER.info(String.format(\"Provisioned firewall rule to open up port %d on %s for Kubernetes cluster ID: %s\",\n-                        CLUSTER_API_PORT, publicIp.getAddress().addr(), kubernetesCluster.getUuid()));\n+                LOGGER.info(String.format(\"Provisioned firewall rule to open up port %d on %s for Kubernetes cluster %s\",\n+                        CLUSTER_API_PORT, publicIp.getAddress().addr(), kubernetesCluster.getName()));\n             }\n         } catch (NoSuchFieldException | IllegalAccessException | ResourceUnavailableException | NetworkRuleConflictException e) {\n             throw new ManagementServerException(String.format(\"Failed to provision firewall rules for API access for the Kubernetes cluster : %s\", kubernetesCluster.getName()), e);\n         }\n \n+        // Firewall rule fo SSH access on each node VM", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMTkxODY5OnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMjowMjozN1rOHqYnWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMjowMjozN1rOHqYnWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIwNTUyOA==", "bodyText": "one or two extra methods", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514205528", "createdAt": "2020-10-29T12:02:37Z", "author": {"login": "DaanHoogland"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "diffHunk": "@@ -565,6 +564,18 @@ public boolean startKubernetesClusterOnCreate() {\n         if (!isKubernetesClusterDashboardServiceRunning(true, startTimeoutTime)) {\n             logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n         }\n+        retrieveScriptFiles();\n+        for (int i = 0; i < clusterVMs.size(); ++i) {\n+            try {\n+                copyAutoscalerScripts(publicIpAddress, CLUSTER_NODES_DEFAULT_START_SSH_PORT + i);\n+            } catch (Exception e) {\n+                throw new CloudRuntimeException(e);\n+            }\n+        }\n+        if (!createCloudStackSecret(keys)) {\n+            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup keys for Kubernetes cluster %s\",\n+                kubernetesCluster.getName()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjU1ODkzOnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOToxODoyOFrOHrG1hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOToxODoyOFrOHrG1hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2MjgyMg==", "bodyText": "Minor nit, inconsistency in exception messages. At some places it is bit detailed while at some places it is single phrase starting with lowercase", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514962822", "createdAt": "2020-10-30T09:18:28Z", "author": {"login": "shwstppr"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "diffHunk": "@@ -845,30 +865,87 @@ private void validateKubernetesClusterScaleParameters(ScaleKubernetesClusterCmd\n         final Long kubernetesClusterId = cmd.getId();\n         final Long serviceOfferingId = cmd.getServiceOfferingId();\n         final Long clusterSize = cmd.getClusterSize();\n+        final List<Long> nodeIds = cmd.getNodeIds();\n+        final Boolean isAutoscalingEnabled = cmd.isAutoscalingEnabled();\n+        final Long minSize = cmd.getMinSize();\n+        final Long maxSize = cmd.getMaxSize();\n+\n         if (kubernetesClusterId == null || kubernetesClusterId < 1L) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         KubernetesClusterVO kubernetesCluster = kubernetesClusterDao.findById(kubernetesClusterId);\n         if (kubernetesCluster == null || kubernetesCluster.getRemoved() != null) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         final DataCenter zone = dataCenterDao.findById(kubernetesCluster.getZoneId());\n         if (zone == null) {\n             logAndThrow(Level.WARN, String.format(\"Unable to find zone for Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (serviceOfferingId == null && clusterSize == null && nodeIds == null && isAutoscalingEnabled == null) {\n+            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster %s cannot be scaled, either service offering or cluster size or nodeids to be removed or autoscaling must be passed\", kubernetesCluster.getName()));\n+        }\n+\n         Account caller = CallContext.current().getCallingAccount();\n         accountManager.checkAccess(caller, SecurityChecker.AccessType.OperateEntry, false, kubernetesCluster);\n \n-        if (serviceOfferingId == null && clusterSize == null) {\n-            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster : %s cannot be scaled, either a new service offering or a new cluster size must be passed\", kubernetesCluster.getName()));\n-        }\n-\n         final KubernetesSupportedVersion clusterVersion = kubernetesSupportedVersionDao.findById(kubernetesCluster.getKubernetesVersionId());\n         if (clusterVersion == null) {\n             throw new CloudRuntimeException(String.format(\"Invalid Kubernetes version associated with Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (!(kubernetesCluster.getState().equals(KubernetesCluster.State.Created) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Running) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Stopped))) {\n+            throw new PermissionDeniedException(String.format(\"Kubernetes cluster %s is in %s state and can not be scaled\", kubernetesCluster.getName(), kubernetesCluster.getState().toString()));\n+        }\n+\n+        if (isAutoscalingEnabled != null && isAutoscalingEnabled) {\n+            if (clusterSize != null || serviceOfferingId != null || nodeIds != null) {\n+                throw new InvalidParameterValueException(\"autoscaling can not be passed along with nodeids or clustersize or service offering\");\n+            }\n+\n+            if (!KubernetesVersionManagerImpl.versionSupportsAutoscaling(clusterVersion)) {\n+                throw new InvalidParameterValueException(String.format(\"Autoscaling requires Kubernetes Version %s or above\",\n+                    KubernetesVersionManagerImpl.MINIMUN_AUTOSCALER_SUPPORTED_VERSION ));\n+            }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjU2MTI2OnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOToxOTowOFrOHrG22A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMTowMDowNVrOHrKIdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2MzE2MA==", "bodyText": "Are we allowing scaling for master nodes?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514963160", "createdAt": "2020-10-30T09:19:08Z", "author": {"login": "shwstppr"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "diffHunk": "@@ -845,30 +865,87 @@ private void validateKubernetesClusterScaleParameters(ScaleKubernetesClusterCmd\n         final Long kubernetesClusterId = cmd.getId();\n         final Long serviceOfferingId = cmd.getServiceOfferingId();\n         final Long clusterSize = cmd.getClusterSize();\n+        final List<Long> nodeIds = cmd.getNodeIds();\n+        final Boolean isAutoscalingEnabled = cmd.isAutoscalingEnabled();\n+        final Long minSize = cmd.getMinSize();\n+        final Long maxSize = cmd.getMaxSize();\n+\n         if (kubernetesClusterId == null || kubernetesClusterId < 1L) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         KubernetesClusterVO kubernetesCluster = kubernetesClusterDao.findById(kubernetesClusterId);\n         if (kubernetesCluster == null || kubernetesCluster.getRemoved() != null) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         final DataCenter zone = dataCenterDao.findById(kubernetesCluster.getZoneId());\n         if (zone == null) {\n             logAndThrow(Level.WARN, String.format(\"Unable to find zone for Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (serviceOfferingId == null && clusterSize == null && nodeIds == null && isAutoscalingEnabled == null) {\n+            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster %s cannot be scaled, either service offering or cluster size or nodeids to be removed or autoscaling must be passed\", kubernetesCluster.getName()));\n+        }\n+\n         Account caller = CallContext.current().getCallingAccount();\n         accountManager.checkAccess(caller, SecurityChecker.AccessType.OperateEntry, false, kubernetesCluster);\n \n-        if (serviceOfferingId == null && clusterSize == null) {\n-            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster : %s cannot be scaled, either a new service offering or a new cluster size must be passed\", kubernetesCluster.getName()));\n-        }\n-\n         final KubernetesSupportedVersion clusterVersion = kubernetesSupportedVersionDao.findById(kubernetesCluster.getKubernetesVersionId());\n         if (clusterVersion == null) {\n             throw new CloudRuntimeException(String.format(\"Invalid Kubernetes version associated with Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (!(kubernetesCluster.getState().equals(KubernetesCluster.State.Created) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Running) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Stopped))) {\n+            throw new PermissionDeniedException(String.format(\"Kubernetes cluster %s is in %s state and can not be scaled\", kubernetesCluster.getName(), kubernetesCluster.getState().toString()));\n+        }\n+\n+        if (isAutoscalingEnabled != null && isAutoscalingEnabled) {\n+            if (clusterSize != null || serviceOfferingId != null || nodeIds != null) {\n+                throw new InvalidParameterValueException(\"autoscaling can not be passed along with nodeids or clustersize or service offering\");\n+            }\n+\n+            if (!KubernetesVersionManagerImpl.versionSupportsAutoscaling(clusterVersion)) {\n+                throw new InvalidParameterValueException(String.format(\"Autoscaling requires Kubernetes Version %s or above\",\n+                    KubernetesVersionManagerImpl.MINIMUN_AUTOSCALER_SUPPORTED_VERSION ));\n+            }\n+\n+            validateEndpointUrl();\n+\n+            if (minSize == null || maxSize == null) {\n+                throw new InvalidParameterValueException(\"autoscaling requires minsize and maxsize to be passed\");\n+            }\n+            if (minSize < 1) {\n+                throw new InvalidParameterValueException(\"minsize must be at least than 1\");\n+            }\n+            if (maxSize <= minSize) {\n+                throw new InvalidParameterValueException(\"maxsize must be greater than or equal to minsize\");\n+            }\n+        }\n+\n+        if (nodeIds != null) {\n+            if (clusterSize != null || serviceOfferingId != null) {\n+                throw new InvalidParameterValueException(\"nodeids can not be passed along with clustersize or service offering\");\n+            }\n+            List<KubernetesClusterVmMapVO> nodes = kubernetesClusterVmMapDao.listByClusterIdAndVmIdsIn(kubernetesCluster.getId(), nodeIds);\n+            // Do all the nodes exist ?\n+            if (nodes == null || nodes.size() != nodeIds.size()) {\n+                throw new InvalidParameterValueException(\"Invalid node ids\");\n+            }\n+            // Ensure there's always a master\n+            long mastersToRemove = nodes.stream().filter(x -> x.isMaster()).count();\n+            if (mastersToRemove >= kubernetesCluster.getMasterNodeCount()) {\n+                throw new InvalidParameterValueException(\"Can not remove all masters from a cluster\");\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjgyMQ==", "bodyText": "The autoscaler will not remove master nodes, however, nodeids can be passed, ensuring that users do not accidentally delete master nodes", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r515016821", "createdAt": "2020-10-30T11:00:05Z", "author": {"login": "davidjumani"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "diffHunk": "@@ -845,30 +865,87 @@ private void validateKubernetesClusterScaleParameters(ScaleKubernetesClusterCmd\n         final Long kubernetesClusterId = cmd.getId();\n         final Long serviceOfferingId = cmd.getServiceOfferingId();\n         final Long clusterSize = cmd.getClusterSize();\n+        final List<Long> nodeIds = cmd.getNodeIds();\n+        final Boolean isAutoscalingEnabled = cmd.isAutoscalingEnabled();\n+        final Long minSize = cmd.getMinSize();\n+        final Long maxSize = cmd.getMaxSize();\n+\n         if (kubernetesClusterId == null || kubernetesClusterId < 1L) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         KubernetesClusterVO kubernetesCluster = kubernetesClusterDao.findById(kubernetesClusterId);\n         if (kubernetesCluster == null || kubernetesCluster.getRemoved() != null) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         final DataCenter zone = dataCenterDao.findById(kubernetesCluster.getZoneId());\n         if (zone == null) {\n             logAndThrow(Level.WARN, String.format(\"Unable to find zone for Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (serviceOfferingId == null && clusterSize == null && nodeIds == null && isAutoscalingEnabled == null) {\n+            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster %s cannot be scaled, either service offering or cluster size or nodeids to be removed or autoscaling must be passed\", kubernetesCluster.getName()));\n+        }\n+\n         Account caller = CallContext.current().getCallingAccount();\n         accountManager.checkAccess(caller, SecurityChecker.AccessType.OperateEntry, false, kubernetesCluster);\n \n-        if (serviceOfferingId == null && clusterSize == null) {\n-            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster : %s cannot be scaled, either a new service offering or a new cluster size must be passed\", kubernetesCluster.getName()));\n-        }\n-\n         final KubernetesSupportedVersion clusterVersion = kubernetesSupportedVersionDao.findById(kubernetesCluster.getKubernetesVersionId());\n         if (clusterVersion == null) {\n             throw new CloudRuntimeException(String.format(\"Invalid Kubernetes version associated with Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (!(kubernetesCluster.getState().equals(KubernetesCluster.State.Created) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Running) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Stopped))) {\n+            throw new PermissionDeniedException(String.format(\"Kubernetes cluster %s is in %s state and can not be scaled\", kubernetesCluster.getName(), kubernetesCluster.getState().toString()));\n+        }\n+\n+        if (isAutoscalingEnabled != null && isAutoscalingEnabled) {\n+            if (clusterSize != null || serviceOfferingId != null || nodeIds != null) {\n+                throw new InvalidParameterValueException(\"autoscaling can not be passed along with nodeids or clustersize or service offering\");\n+            }\n+\n+            if (!KubernetesVersionManagerImpl.versionSupportsAutoscaling(clusterVersion)) {\n+                throw new InvalidParameterValueException(String.format(\"Autoscaling requires Kubernetes Version %s or above\",\n+                    KubernetesVersionManagerImpl.MINIMUN_AUTOSCALER_SUPPORTED_VERSION ));\n+            }\n+\n+            validateEndpointUrl();\n+\n+            if (minSize == null || maxSize == null) {\n+                throw new InvalidParameterValueException(\"autoscaling requires minsize and maxsize to be passed\");\n+            }\n+            if (minSize < 1) {\n+                throw new InvalidParameterValueException(\"minsize must be at least than 1\");\n+            }\n+            if (maxSize <= minSize) {\n+                throw new InvalidParameterValueException(\"maxsize must be greater than or equal to minsize\");\n+            }\n+        }\n+\n+        if (nodeIds != null) {\n+            if (clusterSize != null || serviceOfferingId != null) {\n+                throw new InvalidParameterValueException(\"nodeids can not be passed along with clustersize or service offering\");\n+            }\n+            List<KubernetesClusterVmMapVO> nodes = kubernetesClusterVmMapDao.listByClusterIdAndVmIdsIn(kubernetesCluster.getId(), nodeIds);\n+            // Do all the nodes exist ?\n+            if (nodes == null || nodes.size() != nodeIds.size()) {\n+                throw new InvalidParameterValueException(\"Invalid node ids\");\n+            }\n+            // Ensure there's always a master\n+            long mastersToRemove = nodes.stream().filter(x -> x.isMaster()).count();\n+            if (mastersToRemove >= kubernetesCluster.getMasterNodeCount()) {\n+                throw new InvalidParameterValueException(\"Can not remove all masters from a cluster\");\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2MzE2MA=="}, "originalCommit": {"oid": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjU4MTk2OnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/version/KubernetesVersionManagerImpl.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOToyNToxMlrOHrHDLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzowMzowNFrOHr4NWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2NjMxNw==", "bodyText": "For UI, do we need to return this in KubernetesSupportedVersionResponse? Or can we deprecate older k8s version?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514966317", "createdAt": "2020-10-30T09:25:12Z", "author": {"login": "shwstppr"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/version/KubernetesVersionManagerImpl.java", "diffHunk": "@@ -202,6 +204,10 @@ public static int compareSemanticVersions(String v1, String v2) throws IllegalAr\n         return 0;\n     }\n \n+    public static boolean versionSupportsAutoscaling(KubernetesSupportedVersion clusterVersion) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNzIwOQ==", "bodyText": "@shwstppr Do you mean as a flag ?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r515017209", "createdAt": "2020-10-30T11:00:52Z", "author": {"login": "davidjumani"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/version/KubernetesVersionManagerImpl.java", "diffHunk": "@@ -202,6 +204,10 @@ public static int compareSemanticVersions(String v1, String v2) throws IllegalAr\n         return 0;\n     }\n \n+    public static boolean versionSupportsAutoscaling(KubernetesSupportedVersion clusterVersion) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2NjMxNw=="}, "originalCommit": {"oid": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyMzczOQ==", "bodyText": "@davidjumani something like this https://github.com/shapeblue/cloudstack/blob/41a7eac5f55acfe85f7f32443f1b8ef8574392f5/plugins/integrations/kubernetes-service/src/main/java/org/apache/cloudstack/api/response/KubernetesSupportedVersionResponse.java#L63?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r515023739", "createdAt": "2020-10-30T11:14:08Z", "author": {"login": "shwstppr"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/version/KubernetesVersionManagerImpl.java", "diffHunk": "@@ -202,6 +204,10 @@ public static int compareSemanticVersions(String v1, String v2) throws IllegalAr\n         return 0;\n     }\n \n+    public static boolean versionSupportsAutoscaling(KubernetesSupportedVersion clusterVersion) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2NjMxNw=="}, "originalCommit": {"oid": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3MTczNg==", "bodyText": "Makes sense to deprecate it. Can also add a flag in case users are running older versions. Thanks @shwstppr", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r515771736", "createdAt": "2020-11-02T07:03:04Z", "author": {"login": "davidjumani"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/version/KubernetesVersionManagerImpl.java", "diffHunk": "@@ -202,6 +204,10 @@ public static int compareSemanticVersions(String v1, String v2) throws IllegalAr\n         return 0;\n     }\n \n+    public static boolean versionSupportsAutoscaling(KubernetesSupportedVersion clusterVersion) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2NjMxNw=="}, "originalCommit": {"oid": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjU5MDk1OnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/org/apache/cloudstack/api/command/user/kubernetes/cluster/ScaleKubernetesClusterCmd.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOToyODowMFrOHrHI1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMTowMTo0OFrOHrKLvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2Nzc2Ng==", "bodyText": "We don't support allowing autoscaling while deployment itself and it can be enabled only after the cluster is deployed?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514967766", "createdAt": "2020-10-30T09:28:00Z", "author": {"login": "shwstppr"}, "path": "plugins/integrations/kubernetes-service/src/main/java/org/apache/cloudstack/api/command/user/kubernetes/cluster/ScaleKubernetesClusterCmd.java", "diffHunk": "@@ -58,19 +61,38 @@\n     //////////////// API parameters /////////////////////\n     /////////////////////////////////////////////////////\n     @Parameter(name = ApiConstants.ID, type = CommandType.UUID, required = true,\n-            entityType = KubernetesClusterResponse.class,\n-            description = \"the ID of the Kubernetes cluster\")\n+        entityType = KubernetesClusterResponse.class,\n+        description = \"the ID of the Kubernetes cluster\")\n     private Long id;\n \n     @ACL(accessType = SecurityChecker.AccessType.UseEntry)\n     @Parameter(name = ApiConstants.SERVICE_OFFERING_ID, type = CommandType.UUID, entityType = ServiceOfferingResponse.class,\n-            description = \"the ID of the service offering for the virtual machines in the cluster.\")\n+        description = \"the ID of the service offering for the virtual machines in the cluster.\")\n     private Long serviceOfferingId;\n \n     @Parameter(name=ApiConstants.SIZE, type = CommandType.LONG,\n-            description = \"number of Kubernetes cluster nodes\")\n+        description = \"number of Kubernetes cluster nodes\")\n     private Long clusterSize;\n \n+    @Parameter(name = ApiConstants.NODE_IDS,\n+        type = CommandType.LIST,\n+        collectionType = CommandType.UUID,\n+        entityType = UserVmResponse.class,\n+        description = \"the IDs of the nodes to be removed\")\n+    private List<Long> nodeIds;\n+\n+    @Parameter(name=ApiConstants.AUTOSCALING_ENABLED, type = CommandType.BOOLEAN,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNzY2Mw==", "bodyText": "Yes, for now only after deployment, however, I do plan to add that in the future", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r515017663", "createdAt": "2020-10-30T11:01:48Z", "author": {"login": "davidjumani"}, "path": "plugins/integrations/kubernetes-service/src/main/java/org/apache/cloudstack/api/command/user/kubernetes/cluster/ScaleKubernetesClusterCmd.java", "diffHunk": "@@ -58,19 +61,38 @@\n     //////////////// API parameters /////////////////////\n     /////////////////////////////////////////////////////\n     @Parameter(name = ApiConstants.ID, type = CommandType.UUID, required = true,\n-            entityType = KubernetesClusterResponse.class,\n-            description = \"the ID of the Kubernetes cluster\")\n+        entityType = KubernetesClusterResponse.class,\n+        description = \"the ID of the Kubernetes cluster\")\n     private Long id;\n \n     @ACL(accessType = SecurityChecker.AccessType.UseEntry)\n     @Parameter(name = ApiConstants.SERVICE_OFFERING_ID, type = CommandType.UUID, entityType = ServiceOfferingResponse.class,\n-            description = \"the ID of the service offering for the virtual machines in the cluster.\")\n+        description = \"the ID of the service offering for the virtual machines in the cluster.\")\n     private Long serviceOfferingId;\n \n     @Parameter(name=ApiConstants.SIZE, type = CommandType.LONG,\n-            description = \"number of Kubernetes cluster nodes\")\n+        description = \"number of Kubernetes cluster nodes\")\n     private Long clusterSize;\n \n+    @Parameter(name = ApiConstants.NODE_IDS,\n+        type = CommandType.LIST,\n+        collectionType = CommandType.UUID,\n+        entityType = UserVmResponse.class,\n+        description = \"the IDs of the nodes to be removed\")\n+    private List<Long> nodeIds;\n+\n+    @Parameter(name=ApiConstants.AUTOSCALING_ENABLED, type = CommandType.BOOLEAN,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2Nzc2Ng=="}, "originalCommit": {"oid": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTI3MzQxOnYy", "diffSide": "LEFT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODoxMDoxNVrOHtM9DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMToyNTowOVrOKVvccA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2MDIwNQ==", "bodyText": "@Pearl1594 have we put any check or something for people who will upgrade to 4.16 and have existing k8s cluster? They try to scale their cluster cc @davidjumani", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517160205", "createdAt": "2020-11-04T08:10:15Z", "author": {"login": "shwstppr"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "diffHunk": "@@ -261,60 +269,6 @@ private void logAndThrow(final Level logLevel, final String message, final Excep\n         logTransitStateAndThrow(logLevel, message, null, null, ex);\n     }\n \n-    private boolean isKubernetesServiceTemplateConfigured(DataCenter zone) {\n-        // Check Kubernetes VM template for zone\n-        boolean isHyperVAvailable = false;\n-        boolean isKVMAvailable = false;\n-        boolean isVMwareAvailable = false;\n-        boolean isXenserverAvailable = false;\n-        List<ClusterVO> clusters = clusterDao.listByZoneId(zone.getId());\n-        for (ClusterVO clusterVO : clusters) {\n-            if (Hypervisor.HypervisorType.Hyperv.equals(clusterVO.getHypervisorType())) {\n-                isHyperVAvailable = true;\n-            }\n-            if (Hypervisor.HypervisorType.KVM.equals(clusterVO.getHypervisorType())) {\n-                isKVMAvailable = true;\n-            }\n-            if (Hypervisor.HypervisorType.VMware.equals(clusterVO.getHypervisorType())) {\n-                isVMwareAvailable = true;\n-            }\n-            if (Hypervisor.HypervisorType.XenServer.equals(clusterVO.getHypervisorType())) {\n-                isXenserverAvailable = true;\n-            }\n-        }\n-        List<Pair<String, String>> templatePairs = new ArrayList<>();\n-        if (isHyperVAvailable) {\n-            templatePairs.add(new Pair<>(KubernetesClusterHyperVTemplateName.key(), KubernetesClusterHyperVTemplateName.value()));\n-        }\n-        if (isKVMAvailable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYzMjgyMA==", "bodyText": "@shwstppr On an upgraded env, the existing cluster will continue to operate  as is, and scaling will result in creation of a new debian-based worker node", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r519632820", "createdAt": "2020-11-09T08:36:39Z", "author": {"login": "Pearl1594"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "diffHunk": "@@ -261,60 +269,6 @@ private void logAndThrow(final Level logLevel, final String message, final Excep\n         logTransitStateAndThrow(logLevel, message, null, null, ex);\n     }\n \n-    private boolean isKubernetesServiceTemplateConfigured(DataCenter zone) {\n-        // Check Kubernetes VM template for zone\n-        boolean isHyperVAvailable = false;\n-        boolean isKVMAvailable = false;\n-        boolean isVMwareAvailable = false;\n-        boolean isXenserverAvailable = false;\n-        List<ClusterVO> clusters = clusterDao.listByZoneId(zone.getId());\n-        for (ClusterVO clusterVO : clusters) {\n-            if (Hypervisor.HypervisorType.Hyperv.equals(clusterVO.getHypervisorType())) {\n-                isHyperVAvailable = true;\n-            }\n-            if (Hypervisor.HypervisorType.KVM.equals(clusterVO.getHypervisorType())) {\n-                isKVMAvailable = true;\n-            }\n-            if (Hypervisor.HypervisorType.VMware.equals(clusterVO.getHypervisorType())) {\n-                isVMwareAvailable = true;\n-            }\n-            if (Hypervisor.HypervisorType.XenServer.equals(clusterVO.getHypervisorType())) {\n-                isXenserverAvailable = true;\n-            }\n-        }\n-        List<Pair<String, String>> templatePairs = new ArrayList<>();\n-        if (isHyperVAvailable) {\n-            templatePairs.add(new Pair<>(KubernetesClusterHyperVTemplateName.key(), KubernetesClusterHyperVTemplateName.value()));\n-        }\n-        if (isKVMAvailable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2MDIwNQ=="}, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg4NjA2NA==", "bodyText": "@Pearl1594 a follow up question on this - I've a running k8s cluster. I upgrade ACS to 4.16. I scale-up my k8s cluster. Now there will be mixed node VMs (with coreos and systemvm templates). Now when I try to upgrade k8s version on my k8s cluster will there be an issue? As user on these VMs may be different core and root.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693886064", "createdAt": "2021-08-23T11:25:09Z", "author": {"login": "shwstppr"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "diffHunk": "@@ -261,60 +269,6 @@ private void logAndThrow(final Level logLevel, final String message, final Excep\n         logTransitStateAndThrow(logLevel, message, null, null, ex);\n     }\n \n-    private boolean isKubernetesServiceTemplateConfigured(DataCenter zone) {\n-        // Check Kubernetes VM template for zone\n-        boolean isHyperVAvailable = false;\n-        boolean isKVMAvailable = false;\n-        boolean isVMwareAvailable = false;\n-        boolean isXenserverAvailable = false;\n-        List<ClusterVO> clusters = clusterDao.listByZoneId(zone.getId());\n-        for (ClusterVO clusterVO : clusters) {\n-            if (Hypervisor.HypervisorType.Hyperv.equals(clusterVO.getHypervisorType())) {\n-                isHyperVAvailable = true;\n-            }\n-            if (Hypervisor.HypervisorType.KVM.equals(clusterVO.getHypervisorType())) {\n-                isKVMAvailable = true;\n-            }\n-            if (Hypervisor.HypervisorType.VMware.equals(clusterVO.getHypervisorType())) {\n-                isVMwareAvailable = true;\n-            }\n-            if (Hypervisor.HypervisorType.XenServer.equals(clusterVO.getHypervisorType())) {\n-                isXenserverAvailable = true;\n-            }\n-        }\n-        List<Pair<String, String>> templatePairs = new ArrayList<>();\n-        if (isHyperVAvailable) {\n-            templatePairs.add(new Pair<>(KubernetesClusterHyperVTemplateName.key(), KubernetesClusterHyperVTemplateName.value()));\n-        }\n-        if (isKVMAvailable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2MDIwNQ=="}, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTI4MDg4OnYy", "diffSide": "RIGHT", "path": "tools/marvin/marvin/config/test_data.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODoxMjoxOFrOHtNBaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODoxMjoxOFrOHtNBaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2MTMyMw==", "bodyText": "@Pearl1594 @davidjumani you don't need to to put this link here. It can be set in Trillian override code.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517161323", "createdAt": "2020-11-04T08:12:18Z", "author": {"login": "shwstppr"}, "path": "tools/marvin/marvin/config/test_data.py", "diffHunk": "@@ -2036,46 +2030,11 @@\n         },\n         \"1.16.3\": {\n             \"semanticversion\": \"1.16.3\",\n-            \"url\": \"http://download.cloudstack.org/cks/setup-1.16.3.iso\",\n+            \"url\": \"http://sbjenkins-stagingrepo.jenkins.lon/cks/binaries-iso/as-1.16.3.iso\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTI4MzAxOnYy", "diffSide": "RIGHT", "path": "tools/appliance/systemvmtemplate/template.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODoxMzowMlrOHtNCwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODoxMzowMlrOHtNCwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2MTY2NA==", "bodyText": "@Pearl1594 @davidjumani you don't need to to put this link here. It can be set in Trillian override code.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517161664", "createdAt": "2020-11-04T08:13:02Z", "author": {"login": "shwstppr"}, "path": "tools/appliance/systemvmtemplate/template.json", "diffHunk": "@@ -33,11 +33,11 @@\n         [ \"-smp\", \"1\" ]\n       ],\n       \"format\": \"qcow2\",\n-      \"disk_size\": 2500,\n+      \"disk_size\": 10000,\n       \"disk_interface\": \"virtio\",\n       \"net_device\": \"virtio-net\",\n-      \"iso_url\": \"https://download.cloudstack.org/systemvm/debian/debian-10.5.0-amd64-netinst.iso\",\n-      \"iso_checksum\": \"0a6aee1d9aafc1ed095105c052f9fdd65ed00ea9274188c9cd0072c8e6838ab40e246d45a1e6956d74ef1b04a1fc042151762f25412e9ff0cbf49418eef7992e\",\n+      \"iso_url\": \"http://sbjenkins-stagingrepo.jenkins.lon/flatcar/debian-10.6.0-amd64-netinst.iso\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTI5MDk1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/vm/UserVmManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODoxNTozMlrOHtNHiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODoxNTozMlrOHtNHiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2Mjg4OA==", "bodyText": "Don't we need to have some default type?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517162888", "createdAt": "2020-11-04T08:15:32Z", "author": {"login": "shwstppr"}, "path": "server/src/main/java/com/cloud/vm/UserVmManager.java", "diffHunk": "@@ -55,6 +55,10 @@\n \n     static final int MAX_USER_DATA_LENGTH_BYTES = 2048;\n \n+    public static enum UserVmType {\n+        CKSNode\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTU2MTg4OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41400to41500.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOToyNzoyM1rOHtPr6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOToyNzoyM1rOHtPr6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwNDk3MA==", "bodyText": "Note: after 4.15 is cut; we need to create a new upgrade path from 4.15->4.16 and move these there. cc @Pearl1594", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517204970", "createdAt": "2020-11-04T09:27:23Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41400to41500.java", "diffHunk": "@@ -140,9 +140,9 @@ private void updateSystemVmTemplates(final Connection conn) {\n \n         final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>() {\n             {\n-                put(Hypervisor.HypervisorType.KVM, \"81b3e48bb934784a13555a43c5ef5ffb\");\n-                put(Hypervisor.HypervisorType.XenServer, \"1b178a5dbdbe090555515340144c6017\");\n-                put(Hypervisor.HypervisorType.VMware, \"e6a88e518c57d6f36c096c4204c3417f\");\n+                put(Hypervisor.HypervisorType.KVM, \"0d95bb3d9385097dec8b485e46eae34b\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTU2NjI0OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/resources/META-INF/db/schema-41400to41500.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOToyODozOVrOHtPuyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOToyODozOVrOHtPuyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwNTcwNw==", "bodyText": "Note - we need to move it to a 4.15->4.16 path in future.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517205707", "createdAt": "2020-11-04T09:28:39Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/resources/META-INF/db/schema-41400to41500.sql", "diffHunk": "@@ -833,3 +833,17 @@ INSERT INTO `cloud`.`guest_os_hypervisor` (uuid,hypervisor_type, hypervisor_vers\n \n -- Fix OS category for Guest OS 'Other PV Virtio-SCSI (64-bit)'\n UPDATE `cloud`.`guest_os` SET category_id = 7 WHERE id = 275 AND display_name = 'Other PV Virtio-SCSI (64-bit)';\n+\n+-- TODO : Move to 4.16", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTU3MzA0OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/resources/META-INF/db/schema-41400to41500.sql", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTozMDoxOFrOHtPzFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTozMjo1MlrOHtP5fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwNjgwNA==", "bodyText": "Add a comment to explain why this is done.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517206804", "createdAt": "2020-11-04T09:30:18Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/resources/META-INF/db/schema-41400to41500.sql", "diffHunk": "@@ -833,3 +833,17 @@ INSERT INTO `cloud`.`guest_os_hypervisor` (uuid,hypervisor_type, hypervisor_vers\n \n -- Fix OS category for Guest OS 'Other PV Virtio-SCSI (64-bit)'\n UPDATE `cloud`.`guest_os` SET category_id = 7 WHERE id = 275 AND display_name = 'Other PV Virtio-SCSI (64-bit)';\n+\n+-- TODO : Move to 4.16\n+ALTER TABLE `cloud`.`user_vm` ADD COLUMN `user_vm_type` varchar(255) DEFAULT \"UserVM\" COMMENT 'Defines the type of UserVM';\n+\n+UPDATE `cloud`.`vm_template` set deploy_as_is = 1 where id = 8;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwODQ0NQ==", "bodyText": "Explore - For existing env which has gone through an upgrade, we want to handle it in the java upgrade path by checking the registered template and setting the deploy_as_is to true.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517208445", "createdAt": "2020-11-04T09:32:52Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/resources/META-INF/db/schema-41400to41500.sql", "diffHunk": "@@ -833,3 +833,17 @@ INSERT INTO `cloud`.`guest_os_hypervisor` (uuid,hypervisor_type, hypervisor_vers\n \n -- Fix OS category for Guest OS 'Other PV Virtio-SCSI (64-bit)'\n UPDATE `cloud`.`guest_os` SET category_id = 7 WHERE id = 275 AND display_name = 'Other PV Virtio-SCSI (64-bit)';\n+\n+-- TODO : Move to 4.16\n+ALTER TABLE `cloud`.`user_vm` ADD COLUMN `user_vm_type` varchar(255) DEFAULT \"UserVM\" COMMENT 'Defines the type of UserVM';\n+\n+UPDATE `cloud`.`vm_template` set deploy_as_is = 1 where id = 8;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwNjgwNA=="}, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTYxMzQ3OnYy", "diffSide": "RIGHT", "path": "systemvm/debian/opt/cloud/bin/setup/CKSNode.sh", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo0MDoxNFrOHtQL0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo0MTo1OVrOHtQQFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxMzEzNg==", "bodyText": "sudo systemctl disable dhcpcd.service ?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517213136", "createdAt": "2020-11-04T09:40:14Z", "author": {"login": "rhtyd"}, "path": "systemvm/debian/opt/cloud/bin/setup/CKSNode.sh", "diffHunk": "@@ -0,0 +1,61 @@\n+#!/bin/bash\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+. /opt/cloud/bin/setup/common.sh\n+\n+setup_k8s_node() {\n+    log_it \"Setting up k8s node\"\n+\n+    # set default ssh port and restart sshd service\n+    sed -i 's/3922/22/g' /etc/ssh/sshd_config\n+\n+    swapoff -a\n+    sudo sed -i '/ swap / s/^/#/' /etc/fstab\n+    log_it \"Swap disabled\"\n+\n+    log_it \"Setting up interfaces\"\n+    setup_common eth0\n+    setup_system_rfc1918_internal\n+\n+    log_it \"Setting up entry in hosts\"\n+    sed -i  /$NAME/d /etc/hosts\n+    echo \"$ETH0_IP $NAME\" >> /etc/hosts\n+\n+    public_ip=`getPublicIp`\n+    echo \"$public_ip $NAME\" >> /etc/hosts\n+\n+    echo \"export PATH='$PATH:/opt/bin/'\">> ~/.bashrc\n+\n+    disable_rpfilter\n+    enable_fwding 1\n+    enable_irqbalance 0\n+    setup_ntp\n+    dhclient", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNDIyOQ==", "bodyText": "note - should we call dhclient with some guarding parameters (timeouts, no. of retries...)", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517214229", "createdAt": "2020-11-04T09:41:59Z", "author": {"login": "rhtyd"}, "path": "systemvm/debian/opt/cloud/bin/setup/CKSNode.sh", "diffHunk": "@@ -0,0 +1,61 @@\n+#!/bin/bash\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+. /opt/cloud/bin/setup/common.sh\n+\n+setup_k8s_node() {\n+    log_it \"Setting up k8s node\"\n+\n+    # set default ssh port and restart sshd service\n+    sed -i 's/3922/22/g' /etc/ssh/sshd_config\n+\n+    swapoff -a\n+    sudo sed -i '/ swap / s/^/#/' /etc/fstab\n+    log_it \"Swap disabled\"\n+\n+    log_it \"Setting up interfaces\"\n+    setup_common eth0\n+    setup_system_rfc1918_internal\n+\n+    log_it \"Setting up entry in hosts\"\n+    sed -i  /$NAME/d /etc/hosts\n+    echo \"$ETH0_IP $NAME\" >> /etc/hosts\n+\n+    public_ip=`getPublicIp`\n+    echo \"$public_ip $NAME\" >> /etc/hosts\n+\n+    echo \"export PATH='$PATH:/opt/bin/'\">> ~/.bashrc\n+\n+    disable_rpfilter\n+    enable_fwding 1\n+    enable_irqbalance 0\n+    setup_ntp\n+    dhclient", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxMzEzNg=="}, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTYyNDIyOnYy", "diffSide": "RIGHT", "path": "systemvm/debian/opt/cloud/bin/setup/postinit.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo0MzowNFrOHtQSpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo0MzowNFrOHtQSpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNDg4NQ==", "bodyText": "Note - if we've guarded how to call/run the dhclient, we may not need to do this.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517214885", "createdAt": "2020-11-04T09:43:04Z", "author": {"login": "rhtyd"}, "path": "systemvm/debian/opt/cloud/bin/setup/postinit.sh", "diffHunk": "@@ -33,6 +42,10 @@ then\n   fi\n fi\n \n+if [ \"$TYPE\" == \"CKSNode\" ]; then\n+  pkill -9 dhclient", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTY0Mjg4OnYy", "diffSide": "RIGHT", "path": "tools/appliance/systemvmtemplate/scripts/cleanup.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo0NzozMVrOHtQdqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo0NzozMVrOHtQdqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNzcwNA==", "bodyText": "@Pearl1594 - can you check if there are anything else that could be purged ? (due to docker etc dependencies)", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517217704", "createdAt": "2020-11-04T09:47:31Z", "author": {"login": "rhtyd"}, "path": "tools/appliance/systemvmtemplate/scripts/cleanup.sh", "diffHunk": "@@ -17,11 +17,10 @@\n # under the License.\n \n set -e\n-set -x\n \n function cleanup_apt() {\n   export DEBIAN_FRONTEND=noninteractive\n-  apt-get -y remove --purge dictionaries-common busybox isc-dhcp-client isc-dhcp-common \\\n+  apt-get -y remove --purge dictionaries-common busybox \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTY0Mzg2OnYy", "diffSide": "RIGHT", "path": "tools/appliance/systemvmtemplate/http/preseed.cfg", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo0Nzo0OFrOHtQeSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo0Nzo0OFrOHtQeSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNzg2NA==", "bodyText": "Note - find the min. disk size and reconfigure this.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517217864", "createdAt": "2020-11-04T09:47:48Z", "author": {"login": "rhtyd"}, "path": "tools/appliance/systemvmtemplate/http/preseed.cfg", "diffHunk": "@@ -56,13 +56,13 @@ d-i partman-auto/disk string /dev/vda\n d-i partman-auto/method string regular\n d-i partman-auto/expert_recipe string                         \\\n       boot-root ::                                            \\\n-              100 60 100 ext2                                 \\\n+              512 60 512 ext2                                 \\\n                       $primary{ } $bootable{ }                \\\n                       method{ format } format{ }              \\\n                       use_filesystem{ } filesystem{ ext2 }    \\\n                       mountpoint{ /boot }                     \\\n               .                                               \\\n-              2240 40 2500 ext4                               \\\n+              5000 40 10000 ext4                               \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTY1NTI0OnYy", "diffSide": "RIGHT", "path": "tools/appliance/systemvmtemplate/template.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo1MDoyOVrOHtQlNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo1MDoyOVrOHtQlNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxOTYzNg==", "bodyText": "@Pearl1594 check and match with the preseed partition sizes", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517219636", "createdAt": "2020-11-04T09:50:29Z", "author": {"login": "rhtyd"}, "path": "tools/appliance/systemvmtemplate/template.json", "diffHunk": "@@ -33,11 +33,11 @@\n         [ \"-smp\", \"1\" ]\n       ],\n       \"format\": \"qcow2\",\n-      \"disk_size\": 2500,\n+      \"disk_size\": 10000,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTY2ODE1OnYy", "diffSide": "RIGHT", "path": "tools/appliance/systemvmtemplate/template.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo1MzozMFrOHtQsyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo1MzozMFrOHtQsyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIyMTU3Ng==", "bodyText": "Can you fix the url to download.cloudstack.org for 10.6 iso?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517221576", "createdAt": "2020-11-04T09:53:30Z", "author": {"login": "rhtyd"}, "path": "tools/appliance/systemvmtemplate/template.json", "diffHunk": "@@ -33,11 +33,11 @@\n         [ \"-smp\", \"1\" ]\n       ],\n       \"format\": \"qcow2\",\n-      \"disk_size\": 2500,\n+      \"disk_size\": 10000,\n       \"disk_interface\": \"virtio\",\n       \"net_device\": \"virtio-net\",\n-      \"iso_url\": \"https://download.cloudstack.org/systemvm/debian/debian-10.5.0-amd64-netinst.iso\",\n-      \"iso_checksum\": \"0a6aee1d9aafc1ed095105c052f9fdd65ed00ea9274188c9cd0072c8e6838ab40e246d45a1e6956d74ef1b04a1fc042151762f25412e9ff0cbf49418eef7992e\",\n+      \"iso_url\": \"http://sbjenkins-stagingrepo.jenkins.lon/flatcar/debian-10.6.0-amd64-netinst.iso\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTg0NDc2OnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterActionWorker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDozNzoxOFrOHtSXyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDozNzoxOFrOHtSXyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI0ODk3MQ==", "bodyText": "@davidjumani - our systemvmtemplate patching also uses /opt/bin --> data iso patching doesn't overwrite any scripts or folders?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517248971", "createdAt": "2020-11-04T10:37:18Z", "author": {"login": "rhtyd"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterActionWorker.java", "diffHunk": "@@ -380,4 +411,59 @@ protected boolean stateTransitTo(long kubernetesClusterId, KubernetesCluster.Eve\n             return false;\n         }\n     }\n+\n+    protected boolean createCloudStackSecret(String[] keys) {\n+        File pkFile = getManagementServerSshPublicKeyFile();\n+        Pair<String, Integer> publicIpSshPort = getKubernetesClusterServerIpSshPort(null);\n+        publicIpAddress = publicIpSshPort.first();\n+        sshPort = publicIpSshPort.second();\n+\n+        try {\n+            Pair<Boolean, String> result = SshHelper.sshExecute(publicIpAddress, sshPort, CLUSTER_NODE_VM_USER,\n+                pkFile, null, String.format(\"/opt/bin/deploy-cloudstack-secret -u '%s' -k '%s' -s '%s'\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0OTQ1NjkzOnYy", "diffSide": "RIGHT", "path": "tools/appliance/systemvmtemplate/scripts/install_systemvm_packages.sh", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQwOTowMjowOVrOIZcxfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQwODowMjo1NVrOIbrB4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU1NjczMg==", "bodyText": "@davidjumani\nwe do not need docker installed in systemvm template.\nit would be better to create separated folder in tools/appliance/", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r563556732", "createdAt": "2021-01-25T09:02:09Z", "author": {"login": "weizhouapache"}, "path": "tools/appliance/systemvmtemplate/scripts/install_systemvm_packages.sh", "diffHunk": "@@ -70,20 +76,33 @@ function install_packages() {\n     radvd \\\n     sharutils genisoimage aria2 \\\n     strongswan libcharon-extra-plugins libstrongswan-extra-plugins strongswan-charon strongswan-starter \\\n-    virt-what open-vm-tools qemu-guest-agent hyperv-daemons\n+    virt-what open-vm-tools qemu-guest-agent hyperv-daemons cloud-guest-utils \\\n+    apt-transport-https ca-certificates curl gnupg  gnupg-agent software-properties-common cloud-init\n \n   apt-get -y autoremove --purge\n   apt-get clean\n   apt-get autoclean\n \n+  apt_clean\n   ${apt_get} install links\n \n+   curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n+   apt-key fingerprint 0EBFCD88\n+\n   #32 bit architecture support for vhd-util: not required for 32 bit template\n   if [ \"${arch}\" != \"i386\" ]; then\n     dpkg --add-architecture i386\n     apt-get update\n     ${apt_get} install libuuid1:i386 libc6:i386\n+\n+    add-apt-repository \\\n+    \"deb [arch=amd64] https://download.docker.com/linux/debian \\\n+    $(lsb_release -cs) \\\n+    stable\"\n+    apt-get update\n+    ${apt_get} install docker-ce docker-ce-cli containerd.io", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ae34dfebe6945a2c6d07032fc78c246db1c694"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY1NzYxMg==", "bodyText": "@weizhouapache With coreOS having reached EOL, we've enabled the systemVM template to be consumed by CKS for deploying K8s clusters. Hence docker is installed in the template. However, the service is only run on the cks nodes", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r563657612", "createdAt": "2021-01-25T11:37:59Z", "author": {"login": "Pearl1594"}, "path": "tools/appliance/systemvmtemplate/scripts/install_systemvm_packages.sh", "diffHunk": "@@ -70,20 +76,33 @@ function install_packages() {\n     radvd \\\n     sharutils genisoimage aria2 \\\n     strongswan libcharon-extra-plugins libstrongswan-extra-plugins strongswan-charon strongswan-starter \\\n-    virt-what open-vm-tools qemu-guest-agent hyperv-daemons\n+    virt-what open-vm-tools qemu-guest-agent hyperv-daemons cloud-guest-utils \\\n+    apt-transport-https ca-certificates curl gnupg  gnupg-agent software-properties-common cloud-init\n \n   apt-get -y autoremove --purge\n   apt-get clean\n   apt-get autoclean\n \n+  apt_clean\n   ${apt_get} install links\n \n+   curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n+   apt-key fingerprint 0EBFCD88\n+\n   #32 bit architecture support for vhd-util: not required for 32 bit template\n   if [ \"${arch}\" != \"i386\" ]; then\n     dpkg --add-architecture i386\n     apt-get update\n     ${apt_get} install libuuid1:i386 libc6:i386\n+\n+    add-apt-repository \\\n+    \"deb [arch=amd64] https://download.docker.com/linux/debian \\\n+    $(lsb_release -cs) \\\n+    stable\"\n+    apt-get update\n+    ${apt_get} install docker-ce docker-ce-cli containerd.io", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU1NjczMg=="}, "originalCommit": {"oid": "15ae34dfebe6945a2c6d07032fc78c246db1c694"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzcxOTYyNA==", "bodyText": "@Pearl1594\nwe could have different template for cks. debian9 is one of an options for cks template. if cloudstack users want to have centos8 or ubuntu 2004 as cks template,we could build them as well.\nwe can create separated folder in tools/appliance/, like cks-template-debian10, cks-template-centos8, etc\nif we use same template on VR and cks, and we need to make more changes in the template, it will impact the systemvm and vrs as well. cloudstack systemvm template is quite stable now. do not touch it if possible.\nin addition, some packages in systemvm template are not needed for cks.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r563719624", "createdAt": "2021-01-25T13:24:36Z", "author": {"login": "weizhouapache"}, "path": "tools/appliance/systemvmtemplate/scripts/install_systemvm_packages.sh", "diffHunk": "@@ -70,20 +76,33 @@ function install_packages() {\n     radvd \\\n     sharutils genisoimage aria2 \\\n     strongswan libcharon-extra-plugins libstrongswan-extra-plugins strongswan-charon strongswan-starter \\\n-    virt-what open-vm-tools qemu-guest-agent hyperv-daemons\n+    virt-what open-vm-tools qemu-guest-agent hyperv-daemons cloud-guest-utils \\\n+    apt-transport-https ca-certificates curl gnupg  gnupg-agent software-properties-common cloud-init\n \n   apt-get -y autoremove --purge\n   apt-get clean\n   apt-get autoclean\n \n+  apt_clean\n   ${apt_get} install links\n \n+   curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n+   apt-key fingerprint 0EBFCD88\n+\n   #32 bit architecture support for vhd-util: not required for 32 bit template\n   if [ \"${arch}\" != \"i386\" ]; then\n     dpkg --add-architecture i386\n     apt-get update\n     ${apt_get} install libuuid1:i386 libc6:i386\n+\n+    add-apt-repository \\\n+    \"deb [arch=amd64] https://download.docker.com/linux/debian \\\n+    $(lsb_release -cs) \\\n+    stable\"\n+    apt-get update\n+    ${apt_get} install docker-ce docker-ce-cli containerd.io", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU1NjczMg=="}, "originalCommit": {"oid": "15ae34dfebe6945a2c6d07032fc78c246db1c694"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTgyNDI2OA==", "bodyText": "@weizhouapache I completely understand your concerns. However, the basic intent of moving to systemVM template was that we could leverage the already registered template, thus removing the need to register a new template for CKS. We've ensured that VRs and systemVMs will not be affected by these new packages installed. In case the concern is about the template size, it's increased by 500MB and have incorporated your PR #3900 for growing / resizing the root disk partition during boot up to a predefined / provided disk size. We could also probably discuss this on the mailing list to get a feedback from a wider audience and incorporate and test all cases to ensure that there aren't any adverse effects of these changes.. Thanks @weizhouapache", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r565824268", "createdAt": "2021-01-28T05:09:25Z", "author": {"login": "Pearl1594"}, "path": "tools/appliance/systemvmtemplate/scripts/install_systemvm_packages.sh", "diffHunk": "@@ -70,20 +76,33 @@ function install_packages() {\n     radvd \\\n     sharutils genisoimage aria2 \\\n     strongswan libcharon-extra-plugins libstrongswan-extra-plugins strongswan-charon strongswan-starter \\\n-    virt-what open-vm-tools qemu-guest-agent hyperv-daemons\n+    virt-what open-vm-tools qemu-guest-agent hyperv-daemons cloud-guest-utils \\\n+    apt-transport-https ca-certificates curl gnupg  gnupg-agent software-properties-common cloud-init\n \n   apt-get -y autoremove --purge\n   apt-get clean\n   apt-get autoclean\n \n+  apt_clean\n   ${apt_get} install links\n \n+   curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n+   apt-key fingerprint 0EBFCD88\n+\n   #32 bit architecture support for vhd-util: not required for 32 bit template\n   if [ \"${arch}\" != \"i386\" ]; then\n     dpkg --add-architecture i386\n     apt-get update\n     ${apt_get} install libuuid1:i386 libc6:i386\n+\n+    add-apt-repository \\\n+    \"deb [arch=amd64] https://download.docker.com/linux/debian \\\n+    $(lsb_release -cs) \\\n+    stable\"\n+    apt-get update\n+    ${apt_get} install docker-ce docker-ce-cli containerd.io", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU1NjczMg=="}, "originalCommit": {"oid": "15ae34dfebe6945a2c6d07032fc78c246db1c694"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg4NzQ1OQ==", "bodyText": "@Pearl1594 thanks !\nIt would be better to discuss it on mailing list.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r565887459", "createdAt": "2021-01-28T08:02:55Z", "author": {"login": "weizhouapache"}, "path": "tools/appliance/systemvmtemplate/scripts/install_systemvm_packages.sh", "diffHunk": "@@ -70,20 +76,33 @@ function install_packages() {\n     radvd \\\n     sharutils genisoimage aria2 \\\n     strongswan libcharon-extra-plugins libstrongswan-extra-plugins strongswan-charon strongswan-starter \\\n-    virt-what open-vm-tools qemu-guest-agent hyperv-daemons\n+    virt-what open-vm-tools qemu-guest-agent hyperv-daemons cloud-guest-utils \\\n+    apt-transport-https ca-certificates curl gnupg  gnupg-agent software-properties-common cloud-init\n \n   apt-get -y autoremove --purge\n   apt-get clean\n   apt-get autoclean\n \n+  apt_clean\n   ${apt_get} install links\n \n+   curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n+   apt-key fingerprint 0EBFCD88\n+\n   #32 bit architecture support for vhd-util: not required for 32 bit template\n   if [ \"${arch}\" != \"i386\" ]; then\n     dpkg --add-architecture i386\n     apt-get update\n     ${apt_get} install libuuid1:i386 libc6:i386\n+\n+    add-apt-repository \\\n+    \"deb [arch=amd64] https://download.docker.com/linux/debian \\\n+    $(lsb_release -cs) \\\n+    stable\"\n+    apt-get update\n+    ${apt_get} install docker-ce docker-ce-cli containerd.io", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU1NjczMg=="}, "originalCommit": {"oid": "15ae34dfebe6945a2c6d07032fc78c246db1c694"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxODkwMTI3OnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMDozMDozMVrOKVtc0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMDozMDozMVrOKVtc0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg1MzM5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"root size (in GB) of systemvm and virtual routers\", true);\n          \n          \n            \n                        \"Size of root volume (in GB) of system VMs and virtual routers\", true);", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693853392", "createdAt": "2021-08-23T10:30:31Z", "author": {"login": "shwstppr"}, "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "diffHunk": "@@ -405,6 +405,10 @@\n     static final ConfigKey<Boolean> HaVmRestartHostUp = new ConfigKey<Boolean>(\"Advanced\", Boolean.class, \"ha.vm.restart.hostup\", \"true\",\n             \"If an out-of-band stop of a VM is detected and its host is up, then power on the VM\", true);\n \n+    static final ConfigKey<Long> SystemVmRootDiskSize = new ConfigKey<Long>(\"Advanced\",\n+            Long.class, \"systemvm.root.disk.size\", \"-1\",\n+            \"root size (in GB) of systemvm and virtual routers\", true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxODkxODAxOnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMDozNDo0OFrOKVtm7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwNzo1MDoxN1rOKWaeFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg1NTk4Mg==", "bodyText": "I think SystemVmRootDiskSize.value() will always give a non-null", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693855982", "createdAt": "2021-08-23T10:34:48Z", "author": {"login": "shwstppr"}, "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "diffHunk": "@@ -453,6 +457,12 @@ public void allocate(final String vmInstanceName, final VirtualMachineTemplate t\n \n         final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vmFinal, template, serviceOffering, null, null);\n \n+        Long rootDiskSize = rootDiskOfferingInfo.getSize();\n+        if (vm.getType().isUsedBySystem() && SystemVmRootDiskSize.value() != null && SystemVmRootDiskSize.value() > 0L) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDU5MDk5OA==", "bodyText": "question - is isUsedBySystem() returning true for systemvms and VRs?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694590998", "createdAt": "2021-08-24T07:50:17Z", "author": {"login": "rhtyd"}, "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "diffHunk": "@@ -453,6 +457,12 @@ public void allocate(final String vmInstanceName, final VirtualMachineTemplate t\n \n         final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vmFinal, template, serviceOffering, null, null);\n \n+        Long rootDiskSize = rootDiskOfferingInfo.getSize();\n+        if (vm.getType().isUsedBySystem() && SystemVmRootDiskSize.value() != null && SystemVmRootDiskSize.value() > 0L) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg1NTk4Mg=="}, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxODkyNTkzOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMDozNjo0OFrOKVtrtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMDozNjo0OFrOKVtrtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg1NzIwNw==", "bodyText": "Why different naming scheme for different variables with same access?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693857207", "createdAt": "2021-08-23T10:36:48Z", "author": {"login": "shwstppr"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.naming.ConfigurationException;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String mountCommand = \"sudo mount -t nfs %s %s\";\n+    private static final String umountCommand = \"sudo umount %s\";\n+    private static final  String hashAlgorithm = \"MD5\";\n+    private static final String relativeTemplatePath = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String AbsolutetemplatesPath = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String templatesPath = fetchTemplatesPath();\n+    private static final String metadataFileName = \"metadata.ini\";\n+    private static final String metadataFile = templatesPath + metadataFileName;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxODk0NzI4OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreVO.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMDo0MjowMlrOKVt4Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMzo0NTozOFrOKV1jMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2MDQ0Mg==", "bodyText": "Using getDataCenterId won't work?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693860442", "createdAt": "2021-08-23T10:42:02Z", "author": {"login": "shwstppr"}, "path": "engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreVO.java", "diffHunk": "@@ -135,6 +135,10 @@ public Long getDataCenterId() {\n         return this.dcId;\n     }\n \n+    public Long getDcId() {\n+        return this.dcId;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzk4NjA5Nw==", "bodyText": "This was done because of this https://github.com/shapeblue/hackerbook/blob/main/hack/db.md#note-", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693986097", "createdAt": "2021-08-23T13:45:38Z", "author": {"login": "Pearl1594"}, "path": "engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreVO.java", "diffHunk": "@@ -135,6 +135,10 @@ public Long getDataCenterId() {\n         return this.dcId;\n     }\n \n+    public Long getDcId() {\n+        return this.dcId;\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2MDQ0Mg=="}, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxODk3MDA1OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMDo0NzoxOVrOKVuFmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDo0Nzo0N1rOKXmCJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2MzgzNA==", "bodyText": "Not good for people with OCD :-D\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final  String hashAlgorithm = \"MD5\";\n          \n          \n            \n                private static final String hashAlgorithm = \"MD5\";", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693863834", "createdAt": "2021-08-23T10:47:19Z", "author": {"login": "shwstppr"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.naming.ConfigurationException;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String mountCommand = \"sudo mount -t nfs %s %s\";\n+    private static final String umountCommand = \"sudo umount %s\";\n+    private static final  String hashAlgorithm = \"MD5\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgyOTAyOQ==", "bodyText": "let's apply this", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695829029", "createdAt": "2021-08-25T14:47:47Z", "author": {"login": "DaanHoogland"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.naming.ConfigurationException;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String mountCommand = \"sudo mount -t nfs %s %s\";\n+    private static final String umountCommand = \"sudo umount %s\";\n+    private static final  String hashAlgorithm = \"MD5\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2MzgzNA=="}, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxODk3ODk4OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMDo0OToyOVrOKVuK8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowOTowOFrOKWbWhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2NTIwMw==", "bodyText": "We will update this default value for every version in future?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693865203", "createdAt": "2021-08-23T10:49:29Z", "author": {"login": "shwstppr"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.naming.ConfigurationException;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String mountCommand = \"sudo mount -t nfs %s %s\";\n+    private static final String umountCommand = \"sudo umount %s\";\n+    private static final  String hashAlgorithm = \"MD5\";\n+    private static final String relativeTemplatePath = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String AbsolutetemplatesPath = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String templatesPath = fetchTemplatesPath();\n+    private static final String metadataFileName = \"metadata.ini\";\n+    private static final String metadataFile = templatesPath + metadataFileName;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkxMDkzNw==", "bodyText": "it's only a placeholder - this will automatically be updated during MS restart - if the code version has changed", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693910937", "createdAt": "2021-08-23T12:05:25Z", "author": {"login": "Pearl1594"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.naming.ConfigurationException;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String mountCommand = \"sudo mount -t nfs %s %s\";\n+    private static final String umountCommand = \"sudo umount %s\";\n+    private static final  String hashAlgorithm = \"MD5\";\n+    private static final String relativeTemplatePath = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String AbsolutetemplatesPath = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String templatesPath = fetchTemplatesPath();\n+    private static final String metadataFileName = \"metadata.ini\";\n+    private static final String metadataFile = templatesPath + metadataFileName;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2NTIwMw=="}, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNTQ0NQ==", "bodyText": "suggestion - in that case set them as null or something invalid? If the field does not update, but is used elsewhere it will throw NPE and possible fail than do something wrong", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694605445", "createdAt": "2021-08-24T08:09:08Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.naming.ConfigurationException;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String mountCommand = \"sudo mount -t nfs %s %s\";\n+    private static final String umountCommand = \"sudo umount %s\";\n+    private static final  String hashAlgorithm = \"MD5\";\n+    private static final String relativeTemplatePath = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String AbsolutetemplatesPath = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String templatesPath = fetchTemplatesPath();\n+    private static final String metadataFileName = \"metadata.ini\";\n+    private static final String metadataFile = templatesPath + metadataFileName;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2NTIwMw=="}, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxOTAyODA2OnYy", "diffSide": "RIGHT", "path": "plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/resource/LibvirtComputingResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMTowMjoyNlrOKVuobQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMTowMjoyNlrOKVuobQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg3Mjc0OQ==", "bodyText": "probably not needed", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693872749", "createdAt": "2021-08-23T11:02:26Z", "author": {"login": "shwstppr"}, "path": "plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/resource/LibvirtComputingResource.java", "diffHunk": "@@ -1667,6 +1667,7 @@ public boolean passCmdLine(final String vmName, final String cmdLine) throws Int\n         command.add(\"-n\", vmName);\n         command.add(\"-c\", cmdLine);\n         result = command.execute();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxOTA1ODQ0OnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterActionWorker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMToxMDozOVrOKVu63g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMToxMDozOVrOKVu63g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg3NzQ3MA==", "bodyText": "needed?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693877470", "createdAt": "2021-08-23T11:10:39Z", "author": {"login": "shwstppr"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterActionWorker.java", "diffHunk": "@@ -310,6 +333,7 @@ protected String getControlVmPrivateIp() {\n     }\n \n     protected void attachIsoKubernetesVMs(List<UserVm> clusterVMs, final KubernetesSupportedVersion kubernetesSupportedVersion) throws CloudRuntimeException {\n+        //final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxOTA5MjUzOnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterActionWorker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMToxOTozN1rOKVvP4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMToxOTozN1rOKVvP4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg4Mjg1MA==", "bodyText": "Is it possible to call it only when needed? Not sure but as I can understand this might be called everytime there is an issue the k8s cluster such as upgrade/start (from stopped state) as well. Revoking permission log can be confusing in those cases. Though not a major issue", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693882850", "createdAt": "2021-08-23T11:19:37Z", "author": {"login": "shwstppr"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterActionWorker.java", "diffHunk": "@@ -203,11 +218,19 @@ protected void logTransitStateDetachIsoAndThrow(final Level logLevel, final Stri\n         throw new CloudRuntimeException(message, e);\n     }\n \n+    protected void deleteTemplateLaunchPermission() {\n+        if (clusterTemplate != null && owner != null) {\n+            LOGGER.info(\"Revoking launch permission for systemVM template\");\n+            launchPermissionDao.removePermissions(clusterTemplate.getId(), Collections.singletonList(owner.getId()));\n+        }\n+    }\n+\n     protected void logTransitStateAndThrow(final Level logLevel, final String message, final Long kubernetesClusterId, final KubernetesCluster.Event event, final Exception e) throws CloudRuntimeException {\n         logMessage(logLevel, message, e);\n         if (kubernetesClusterId != null && event != null) {\n             stateTransitTo(kubernetesClusterId, event);\n         }\n+        deleteTemplateLaunchPermission();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxOTE1MDEwOnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMTozNDowM1rOKVvxqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowOTo0OFrOKWbYfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg5MTQ5Nw==", "bodyText": "Use list 'contains?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693891497", "createdAt": "2021-08-23T11:34:03Z", "author": {"login": "shwstppr"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "diffHunk": "@@ -864,30 +807,92 @@ private void validateKubernetesClusterScaleParameters(ScaleKubernetesClusterCmd\n         final Long kubernetesClusterId = cmd.getId();\n         final Long serviceOfferingId = cmd.getServiceOfferingId();\n         final Long clusterSize = cmd.getClusterSize();\n+        final List<Long> nodeIds = cmd.getNodeIds();\n+        final Boolean isAutoscalingEnabled = cmd.isAutoscalingEnabled();\n+        final Long minSize = cmd.getMinSize();\n+        final Long maxSize = cmd.getMaxSize();\n+\n         if (kubernetesClusterId == null || kubernetesClusterId < 1L) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         KubernetesClusterVO kubernetesCluster = kubernetesClusterDao.findById(kubernetesClusterId);\n         if (kubernetesCluster == null || kubernetesCluster.getRemoved() != null) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         final DataCenter zone = dataCenterDao.findById(kubernetesCluster.getZoneId());\n         if (zone == null) {\n             logAndThrow(Level.WARN, String.format(\"Unable to find zone for Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (serviceOfferingId == null && clusterSize == null && nodeIds == null && isAutoscalingEnabled == null) {\n+            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster %s cannot be scaled, either service offering or cluster size or nodeids to be removed or autoscaling must be passed\", kubernetesCluster.getName()));\n+        }\n+\n         Account caller = CallContext.current().getCallingAccount();\n         accountManager.checkAccess(caller, SecurityChecker.AccessType.OperateEntry, false, kubernetesCluster);\n \n-        if (serviceOfferingId == null && clusterSize == null) {\n-            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster : %s cannot be scaled, either a new service offering or a new cluster size must be passed\", kubernetesCluster.getName()));\n-        }\n-\n         final KubernetesSupportedVersion clusterVersion = kubernetesSupportedVersionDao.findById(kubernetesCluster.getKubernetesVersionId());\n         if (clusterVersion == null) {\n             throw new CloudRuntimeException(String.format(\"Invalid Kubernetes version associated with Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (!(kubernetesCluster.getState().equals(KubernetesCluster.State.Created) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Running) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Stopped))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNTk1MA==", "bodyText": "and extract in a separate method", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694605950", "createdAt": "2021-08-24T08:09:48Z", "author": {"login": "DaanHoogland"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "diffHunk": "@@ -864,30 +807,92 @@ private void validateKubernetesClusterScaleParameters(ScaleKubernetesClusterCmd\n         final Long kubernetesClusterId = cmd.getId();\n         final Long serviceOfferingId = cmd.getServiceOfferingId();\n         final Long clusterSize = cmd.getClusterSize();\n+        final List<Long> nodeIds = cmd.getNodeIds();\n+        final Boolean isAutoscalingEnabled = cmd.isAutoscalingEnabled();\n+        final Long minSize = cmd.getMinSize();\n+        final Long maxSize = cmd.getMaxSize();\n+\n         if (kubernetesClusterId == null || kubernetesClusterId < 1L) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         KubernetesClusterVO kubernetesCluster = kubernetesClusterDao.findById(kubernetesClusterId);\n         if (kubernetesCluster == null || kubernetesCluster.getRemoved() != null) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         final DataCenter zone = dataCenterDao.findById(kubernetesCluster.getZoneId());\n         if (zone == null) {\n             logAndThrow(Level.WARN, String.format(\"Unable to find zone for Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (serviceOfferingId == null && clusterSize == null && nodeIds == null && isAutoscalingEnabled == null) {\n+            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster %s cannot be scaled, either service offering or cluster size or nodeids to be removed or autoscaling must be passed\", kubernetesCluster.getName()));\n+        }\n+\n         Account caller = CallContext.current().getCallingAccount();\n         accountManager.checkAccess(caller, SecurityChecker.AccessType.OperateEntry, false, kubernetesCluster);\n \n-        if (serviceOfferingId == null && clusterSize == null) {\n-            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster : %s cannot be scaled, either a new service offering or a new cluster size must be passed\", kubernetesCluster.getName()));\n-        }\n-\n         final KubernetesSupportedVersion clusterVersion = kubernetesSupportedVersionDao.findById(kubernetesCluster.getKubernetesVersionId());\n         if (clusterVersion == null) {\n             throw new CloudRuntimeException(String.format(\"Invalid Kubernetes version associated with Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (!(kubernetesCluster.getState().equals(KubernetesCluster.State.Created) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Running) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Stopped))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg5MTQ5Nw=="}, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxOTE4NTA5OnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterVO.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMTo0MjowNlrOKVwFlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMjowMzozOVrOKVw5eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg5NjU5OA==", "bodyText": "Is this used anywhere? Can't find its usage in my IDE", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693896598", "createdAt": "2021-08-23T11:42:06Z", "author": {"login": "shwstppr"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterVO.java", "diffHunk": "@@ -333,6 +369,16 @@ public KubernetesClusterVO(String name, String description, long zoneId, long ku\n         this.checkForGc = false;\n     }\n \n+    public KubernetesClusterVO(String name, String description, long zoneId, long kubernetesVersionId, long serviceOfferingId, long templateId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkwOTg4MQ==", "bodyText": "I'm not sure of it's usage probably @davidjumani can advice", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693909881", "createdAt": "2021-08-23T12:03:39Z", "author": {"login": "Pearl1594"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterVO.java", "diffHunk": "@@ -333,6 +369,16 @@ public KubernetesClusterVO(String name, String description, long zoneId, long ku\n         this.checkForGc = false;\n     }\n \n+    public KubernetesClusterVO(String name, String description, long zoneId, long kubernetesVersionId, long serviceOfferingId, long templateId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg5NjU5OA=="}, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxOTIyNzIwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/cloud/vm/UserVmService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMTo1MjoyMVrOKVweOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMTo1MjoyMVrOKVweOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkwMjkwNA==", "bodyText": "Can type be an enum value?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693902904", "createdAt": "2021-08-23T11:52:21Z", "author": {"login": "shwstppr"}, "path": "api/src/main/java/com/cloud/vm/UserVmService.java", "diffHunk": "@@ -379,7 +379,7 @@ UserVm createAdvancedVirtualMachine(DataCenter zone, ServiceOffering serviceOffe\n         String hostName, String displayName, Long diskOfferingId, Long diskSize, String group, HypervisorType hypervisor, HTTPMethod httpmethod, String userData,\n         String sshKeyPair, Map<Long, IpAddresses> requestedIps, IpAddresses defaultIps, Boolean displayVm, String keyboard, List<Long> affinityGroupIdList,\n         Map<String, String> customParameters, String customId, Map<String, Map<Integer, String>> dhcpOptionMap, Map<Long, DiskOffering> dataDiskTemplateToDiskOfferingMap,\n-        Map<String, String> templateOvfPropertiesMap, boolean dynamicScalingEnabled)\n+        Map<String, String> templateOvfPropertiesMap, boolean dynamicScalingEnabled, String type)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxOTI1NDYxOnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/org/apache/cloudstack/api/command/user/kubernetes/cluster/CreateKubernetesClusterCmd.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMTo1ODo1OFrOKVwuUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1MjoxN1rOKWeQMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkwNzAyNg==", "bodyText": "Is this some tested value?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693907026", "createdAt": "2021-08-23T11:58:58Z", "author": {"login": "shwstppr"}, "path": "plugins/integrations/kubernetes-service/src/main/java/org/apache/cloudstack/api/command/user/kubernetes/cluster/CreateKubernetesClusterCmd.java", "diffHunk": "@@ -55,6 +57,7 @@\n public class CreateKubernetesClusterCmd extends BaseAsyncCreateCmd {\n     public static final Logger LOGGER = Logger.getLogger(CreateKubernetesClusterCmd.class.getName());\n     public static final String APINAME = \"createKubernetesCluster\";\n+    private static final Long DEFAULT_NODE_ROOT_DISK_SIZE = 8L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkwOTI5Mg==", "bodyText": "We've set it as 8GB as this was the disk size for core os as well", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693909292", "createdAt": "2021-08-23T12:02:41Z", "author": {"login": "Pearl1594"}, "path": "plugins/integrations/kubernetes-service/src/main/java/org/apache/cloudstack/api/command/user/kubernetes/cluster/CreateKubernetesClusterCmd.java", "diffHunk": "@@ -55,6 +57,7 @@\n public class CreateKubernetesClusterCmd extends BaseAsyncCreateCmd {\n     public static final Logger LOGGER = Logger.getLogger(CreateKubernetesClusterCmd.class.getName());\n     public static final String APINAME = \"createKubernetesCluster\";\n+    private static final Long DEFAULT_NODE_ROOT_DISK_SIZE = 8L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkwNzAyNg=="}, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1Mjk3Ng==", "bodyText": "I read somewhere in k8s docs, this is probably recommended in best practices?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694652976", "createdAt": "2021-08-24T08:52:17Z", "author": {"login": "rhtyd"}, "path": "plugins/integrations/kubernetes-service/src/main/java/org/apache/cloudstack/api/command/user/kubernetes/cluster/CreateKubernetesClusterCmd.java", "diffHunk": "@@ -55,6 +57,7 @@\n public class CreateKubernetesClusterCmd extends BaseAsyncCreateCmd {\n     public static final Logger LOGGER = Logger.getLogger(CreateKubernetesClusterCmd.class.getName());\n     public static final String APINAME = \"createKubernetesCluster\";\n+    private static final Long DEFAULT_NODE_ROOT_DISK_SIZE = 8L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkwNzAyNg=="}, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQxOTI4MjUwOnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMjowNTo1MlrOKVw-nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yM1QxMjowNTo1MlrOKVw-nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkxMTE5OQ==", "bodyText": "nice little utility method getIntendedRootDiskSize(DiskOffering rootDiskOfferingInfo, VirtualMachine vm) is in order here.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693911199", "createdAt": "2021-08-23T12:05:52Z", "author": {"login": "DaanHoogland"}, "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "diffHunk": "@@ -453,6 +457,12 @@ public void allocate(final String vmInstanceName, final VirtualMachineTemplate t\n \n         final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vmFinal, template, serviceOffering, null, null);\n \n+        Long rootDiskSize = rootDiskOfferingInfo.getSize();\n+        if (vm.getType().isUsedBySystem() && SystemVmRootDiskSize.value() != null && SystemVmRootDiskSize.value() > 0L) {\n+            rootDiskSize = SystemVmRootDiskSize.value();\n+        }\n+        final Long rootDiskSizeFinal = rootDiskSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzc1Mjc3OnYy", "diffSide": "RIGHT", "path": "debian/rules", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwNzo0ODozMVrOKWaZUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwNzo0ODozMVrOKWaZUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDU4OTc3OQ==", "bodyText": "minor nit - should we say systemvm?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694589779", "createdAt": "2021-08-24T07:48:31Z", "author": {"login": "rhtyd"}, "path": "debian/rules", "diffHunk": "@@ -66,17 +66,21 @@ override_dh_auto_install:\n \tmkdir -p $(DESTDIR)/usr/share/$(PACKAGE)-management\n \tmkdir -p $(DESTDIR)/usr/share/$(PACKAGE)-management/lib\n \tmkdir -p $(DESTDIR)/usr/share/$(PACKAGE)-management/setup\n+\tmkdir -p $(DESTDIR)/usr/share/$(PACKAGE)-management/templates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzc1NTc1OnYy", "diffSide": "RIGHT", "path": "debian/rules", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwNzo0OTowN1rOKWabGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoxMDo1NFrOKXj08g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDU5MDIzNQ==", "bodyText": "question - when removing the checksum, are we ensuring some equivalent checksum/ini file is at least added?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694590235", "createdAt": "2021-08-24T07:49:07Z", "author": {"login": "rhtyd"}, "path": "debian/rules", "diffHunk": "@@ -66,17 +66,21 @@ override_dh_auto_install:\n \tmkdir -p $(DESTDIR)/usr/share/$(PACKAGE)-management\n \tmkdir -p $(DESTDIR)/usr/share/$(PACKAGE)-management/lib\n \tmkdir -p $(DESTDIR)/usr/share/$(PACKAGE)-management/setup\n+\tmkdir -p $(DESTDIR)/usr/share/$(PACKAGE)-management/templates\n \tmkdir $(DESTDIR)/var/log/$(PACKAGE)/management\n \tmkdir $(DESTDIR)/var/cache/$(PACKAGE)/management\n \tmkdir $(DESTDIR)/var/log/$(PACKAGE)/ipallocator\n \tmkdir $(DESTDIR)/var/lib/$(PACKAGE)/management\n \tmkdir $(DESTDIR)/var/lib/$(PACKAGE)/mnt\n+\n \tcp -r client/target/utilities/scripts/db/* $(DESTDIR)/usr/share/$(PACKAGE)-management/setup/\n \tcp -r client/target/classes/META-INF/webapp $(DESTDIR)/usr/share/$(PACKAGE)-management/webapp\n \tcp server/target/conf/* $(DESTDIR)/$(SYSCONFDIR)/$(PACKAGE)/server/\n \tcp client/target/conf/* $(DESTDIR)/$(SYSCONFDIR)/$(PACKAGE)/management/\n \tcp client/target/cloud-client-ui-$(VERSION).jar $(DESTDIR)/usr/share/$(PACKAGE)-management/lib/cloudstack-$(VERSION).jar\n \tcp client/target/lib/*jar $(DESTDIR)/usr/share/$(PACKAGE)-management/lib/\n+\tcp -r engine/schema/dist/systemvm-templates/* $(DESTDIR)/usr/share/$(PACKAGE)-management/templates/\n+\trm -rf $(DESTDIR)/usr/share/$(PACKAGE)-management/templates/md5sum.txt", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTc5Mjg4Mg==", "bodyText": "yes - the metatdata.ini file will be present", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695792882", "createdAt": "2021-08-25T14:10:54Z", "author": {"login": "Pearl1594"}, "path": "debian/rules", "diffHunk": "@@ -66,17 +66,21 @@ override_dh_auto_install:\n \tmkdir -p $(DESTDIR)/usr/share/$(PACKAGE)-management\n \tmkdir -p $(DESTDIR)/usr/share/$(PACKAGE)-management/lib\n \tmkdir -p $(DESTDIR)/usr/share/$(PACKAGE)-management/setup\n+\tmkdir -p $(DESTDIR)/usr/share/$(PACKAGE)-management/templates\n \tmkdir $(DESTDIR)/var/log/$(PACKAGE)/management\n \tmkdir $(DESTDIR)/var/cache/$(PACKAGE)/management\n \tmkdir $(DESTDIR)/var/log/$(PACKAGE)/ipallocator\n \tmkdir $(DESTDIR)/var/lib/$(PACKAGE)/management\n \tmkdir $(DESTDIR)/var/lib/$(PACKAGE)/mnt\n+\n \tcp -r client/target/utilities/scripts/db/* $(DESTDIR)/usr/share/$(PACKAGE)-management/setup/\n \tcp -r client/target/classes/META-INF/webapp $(DESTDIR)/usr/share/$(PACKAGE)-management/webapp\n \tcp server/target/conf/* $(DESTDIR)/$(SYSCONFDIR)/$(PACKAGE)/server/\n \tcp client/target/conf/* $(DESTDIR)/$(SYSCONFDIR)/$(PACKAGE)/management/\n \tcp client/target/cloud-client-ui-$(VERSION).jar $(DESTDIR)/usr/share/$(PACKAGE)-management/lib/cloudstack-$(VERSION).jar\n \tcp client/target/lib/*jar $(DESTDIR)/usr/share/$(PACKAGE)-management/lib/\n+\tcp -r engine/schema/dist/systemvm-templates/* $(DESTDIR)/usr/share/$(PACKAGE)-management/templates/\n+\trm -rf $(DESTDIR)/usr/share/$(PACKAGE)-management/templates/md5sum.txt", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDU5MDIzNQ=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzc1Nzc5OnYy", "diffSide": "RIGHT", "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwNzo0OTozNVrOKWacXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoxMToxNVrOKXj2aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDU5MDU1Nw==", "bodyText": "suggestion - is this global default - can this be zone specific?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694590557", "createdAt": "2021-08-24T07:49:35Z", "author": {"login": "rhtyd"}, "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "diffHunk": "@@ -405,6 +405,10 @@\n     static final ConfigKey<Boolean> HaVmRestartHostUp = new ConfigKey<Boolean>(\"Advanced\", Boolean.class, \"ha.vm.restart.hostup\", \"true\",\n             \"If an out-of-band stop of a VM is detected and its host is up, then power on the VM\", true);\n \n+    static final ConfigKey<Long> SystemVmRootDiskSize = new ConfigKey<Long>(\"Advanced\",\n+            Long.class, \"systemvm.root.disk.size\", \"-1\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTc5MzI1Nw==", "bodyText": "Can be done as part of another phase?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695793257", "createdAt": "2021-08-25T14:11:15Z", "author": {"login": "Pearl1594"}, "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "diffHunk": "@@ -405,6 +405,10 @@\n     static final ConfigKey<Boolean> HaVmRestartHostUp = new ConfigKey<Boolean>(\"Advanced\", Boolean.class, \"ha.vm.restart.hostup\", \"true\",\n             \"If an out-of-band stop of a VM is detected and its host is up, then power on the VM\", true);\n \n+    static final ConfigKey<Long> SystemVmRootDiskSize = new ConfigKey<Long>(\"Advanced\",\n+            Long.class, \"systemvm.root.disk.size\", \"-1\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDU5MDU1Nw=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzgzNzk2OnYy", "diffSide": "RIGHT", "path": "engine/schema/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowNTo1MFrOKWbMIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoxMTo1MFrOKXj4sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwMjc4NA==", "bodyText": "+1 does this solve your caching issue @Pearl1594 ?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694602784", "createdAt": "2021-08-24T08:05:50Z", "author": {"login": "rhtyd"}, "path": "engine/schema/pom.xml", "diffHunk": "@@ -52,5 +52,158 @@\n             <groupId>mysql</groupId>\n             <artifactId>mysql-connector-java</artifactId>\n         </dependency>\n+        <dependency>\n+            <groupId>org.ini4j</groupId>\n+            <artifactId>ini4j</artifactId>\n+            <version>${cs.ini.version}</version>\n+        </dependency>\n     </dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.codehaus.gmavenplus</groupId>\n+                <artifactId>gmavenplus-plugin</artifactId>\n+                <version>${cs.gmaven.version}</version>\n+                <executions>\n+                    <execution>\n+                        <phase>generate-sources</phase>\n+                        <goals>\n+                            <goal>execute</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+                <configuration>\n+                    <bindPropertiesToSeparateVariables> true </bindPropertiesToSeparateVariables>\n+                    <scripts>\n+                        log.info \"$project.version\"\n+                        def projectVersion = project.version\n+                        String[] versionParts =  projectVersion.split(\"\\\\.\")\n+                        project.properties['cs.version'] = versionParts[0] + \".\" + versionParts[1]\n+                        project.properties['patch.version'] = versionParts[2]\n+                    </scripts>\n+                </configuration>\n+                <dependencies>\n+                    <dependency>\n+                        <groupId>org.codehaus.groovy</groupId>\n+                        <artifactId>groovy-all</artifactId>\n+                        <version>${cs.groovy.version}</version>\n+                        <scope>runtime</scope>\n+                    </dependency>\n+                </dependencies>\n+            </plugin>\n+            <plugin>\n+                <groupId>com.googlecode.maven-download-plugin</groupId>\n+                <artifactId>download-maven-plugin</artifactId>\n+                <version>1.6.3</version>\n+                <executions>\n+                    <execution>\n+                        <id>download-checksums</id>\n+                        <phase>generate-resources</phase>\n+                        <goals>\n+                            <goal>wget</goal>\n+                        </goals>\n+                        <configuration>\n+                            <url>https://download.cloudstack.org/systemvm/${cs.version}/md5sum.txt</url>\n+                            <outputDirectory>${basedir}/dist/systemvm-templates/</outputDirectory>\n+                            <skipCache>true</skipCache>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTc5Mzg0Mw==", "bodyText": "skipCache wouldn't be ideal for large sized files", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695793843", "createdAt": "2021-08-25T14:11:50Z", "author": {"login": "Pearl1594"}, "path": "engine/schema/pom.xml", "diffHunk": "@@ -52,5 +52,158 @@\n             <groupId>mysql</groupId>\n             <artifactId>mysql-connector-java</artifactId>\n         </dependency>\n+        <dependency>\n+            <groupId>org.ini4j</groupId>\n+            <artifactId>ini4j</artifactId>\n+            <version>${cs.ini.version}</version>\n+        </dependency>\n     </dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.codehaus.gmavenplus</groupId>\n+                <artifactId>gmavenplus-plugin</artifactId>\n+                <version>${cs.gmaven.version}</version>\n+                <executions>\n+                    <execution>\n+                        <phase>generate-sources</phase>\n+                        <goals>\n+                            <goal>execute</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+                <configuration>\n+                    <bindPropertiesToSeparateVariables> true </bindPropertiesToSeparateVariables>\n+                    <scripts>\n+                        log.info \"$project.version\"\n+                        def projectVersion = project.version\n+                        String[] versionParts =  projectVersion.split(\"\\\\.\")\n+                        project.properties['cs.version'] = versionParts[0] + \".\" + versionParts[1]\n+                        project.properties['patch.version'] = versionParts[2]\n+                    </scripts>\n+                </configuration>\n+                <dependencies>\n+                    <dependency>\n+                        <groupId>org.codehaus.groovy</groupId>\n+                        <artifactId>groovy-all</artifactId>\n+                        <version>${cs.groovy.version}</version>\n+                        <scope>runtime</scope>\n+                    </dependency>\n+                </dependencies>\n+            </plugin>\n+            <plugin>\n+                <groupId>com.googlecode.maven-download-plugin</groupId>\n+                <artifactId>download-maven-plugin</artifactId>\n+                <version>1.6.3</version>\n+                <executions>\n+                    <execution>\n+                        <id>download-checksums</id>\n+                        <phase>generate-resources</phase>\n+                        <goals>\n+                            <goal>wget</goal>\n+                        </goals>\n+                        <configuration>\n+                            <url>https://download.cloudstack.org/systemvm/${cs.version}/md5sum.txt</url>\n+                            <outputDirectory>${basedir}/dist/systemvm-templates/</outputDirectory>\n+                            <skipCache>true</skipCache>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwMjc4NA=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzg0MjA3OnYy", "diffSide": "RIGHT", "path": "engine/schema/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowNjo0M1rOKWbOtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowNjo0M1rOKWbOtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwMzQ0NA==", "bodyText": "@Pearl1594 add the skip cache option here too?\n    <skipCache>true</skipCache>", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694603444", "createdAt": "2021-08-24T08:06:43Z", "author": {"login": "rhtyd"}, "path": "engine/schema/pom.xml", "diffHunk": "@@ -52,5 +52,158 @@\n             <groupId>mysql</groupId>\n             <artifactId>mysql-connector-java</artifactId>\n         </dependency>\n+        <dependency>\n+            <groupId>org.ini4j</groupId>\n+            <artifactId>ini4j</artifactId>\n+            <version>${cs.ini.version}</version>\n+        </dependency>\n     </dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.codehaus.gmavenplus</groupId>\n+                <artifactId>gmavenplus-plugin</artifactId>\n+                <version>${cs.gmaven.version}</version>\n+                <executions>\n+                    <execution>\n+                        <phase>generate-sources</phase>\n+                        <goals>\n+                            <goal>execute</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+                <configuration>\n+                    <bindPropertiesToSeparateVariables> true </bindPropertiesToSeparateVariables>\n+                    <scripts>\n+                        log.info \"$project.version\"\n+                        def projectVersion = project.version\n+                        String[] versionParts =  projectVersion.split(\"\\\\.\")\n+                        project.properties['cs.version'] = versionParts[0] + \".\" + versionParts[1]\n+                        project.properties['patch.version'] = versionParts[2]\n+                    </scripts>\n+                </configuration>\n+                <dependencies>\n+                    <dependency>\n+                        <groupId>org.codehaus.groovy</groupId>\n+                        <artifactId>groovy-all</artifactId>\n+                        <version>${cs.groovy.version}</version>\n+                        <scope>runtime</scope>\n+                    </dependency>\n+                </dependencies>\n+            </plugin>\n+            <plugin>\n+                <groupId>com.googlecode.maven-download-plugin</groupId>\n+                <artifactId>download-maven-plugin</artifactId>\n+                <version>1.6.3</version>\n+                <executions>\n+                    <execution>\n+                        <id>download-checksums</id>\n+                        <phase>generate-resources</phase>\n+                        <goals>\n+                            <goal>wget</goal>\n+                        </goals>\n+                        <configuration>\n+                            <url>https://download.cloudstack.org/systemvm/${cs.version}/md5sum.txt</url>\n+                            <outputDirectory>${basedir}/dist/systemvm-templates/</outputDirectory>\n+                            <skipCache>true</skipCache>\n+                            <overwrite>true</overwrite>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.codehaus.mojo</groupId>\n+                <artifactId>exec-maven-plugin</artifactId>\n+                <version>1.2.1</version>\n+                <executions>\n+                    <execution>\n+                        <id>validate-checksums</id>\n+                        <phase>generate-resources</phase>\n+                        <goals>\n+                            <goal>exec</goal>\n+                        </goals>\n+                        <configuration>\n+                            <executable>bash</executable>\n+                            <arguments>\n+                                <argument>validate-checksum</argument>\n+                            </arguments>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.codehaus.mojo</groupId>\n+                <artifactId>exec-maven-plugin</artifactId>\n+                <version>1.2.1</version>\n+                <executions>\n+                    <execution>\n+                        <id>systemvm-template-metadata</id>\n+                        <phase>package</phase>\n+                        <goals>\n+                            <goal>exec</goal>\n+                        </goals>\n+                        <configuration>\n+                            <workingDirectory>${basedir}/</workingDirectory>\n+                            <executable>bash</executable>\n+                            <arguments>\n+                                <argument>templateConfig.sh</argument>\n+                                <armument>${project.version}</armument>\n+                            </arguments>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+        </plugins>\n+    </build>\n+    <profiles>\n+        <profile>\n+            <id>template-create</id>\n+            <activation>\n+                <property>\n+                    <name>noredist</name>\n+                </property>\n+            </activation>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>com.googlecode.maven-download-plugin</groupId>\n+                        <artifactId>download-maven-plugin</artifactId>\n+                        <version>1.6.3</version>\n+                        <executions>\n+                            <execution>\n+                                <id>download-kvm-template</id>\n+                                <goals>\n+                                    <goal>wget</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <url>https://download.cloudstack.org/systemvm/${cs.version}/systemvmtemplate-${cs.version}.${patch.version}-kvm.qcow2.bz2</url>\n+                                    <outputDirectory>${basedir}/dist/systemvm-templates/</outputDirectory>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzg0MzczOnYy", "diffSide": "RIGHT", "path": "engine/schema/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowNzowNlrOKWbPxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowNzowNlrOKWbPxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwMzcxOQ==", "bodyText": "Add the skipCache option here?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694603719", "createdAt": "2021-08-24T08:07:06Z", "author": {"login": "rhtyd"}, "path": "engine/schema/pom.xml", "diffHunk": "@@ -52,5 +52,158 @@\n             <groupId>mysql</groupId>\n             <artifactId>mysql-connector-java</artifactId>\n         </dependency>\n+        <dependency>\n+            <groupId>org.ini4j</groupId>\n+            <artifactId>ini4j</artifactId>\n+            <version>${cs.ini.version}</version>\n+        </dependency>\n     </dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.codehaus.gmavenplus</groupId>\n+                <artifactId>gmavenplus-plugin</artifactId>\n+                <version>${cs.gmaven.version}</version>\n+                <executions>\n+                    <execution>\n+                        <phase>generate-sources</phase>\n+                        <goals>\n+                            <goal>execute</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+                <configuration>\n+                    <bindPropertiesToSeparateVariables> true </bindPropertiesToSeparateVariables>\n+                    <scripts>\n+                        log.info \"$project.version\"\n+                        def projectVersion = project.version\n+                        String[] versionParts =  projectVersion.split(\"\\\\.\")\n+                        project.properties['cs.version'] = versionParts[0] + \".\" + versionParts[1]\n+                        project.properties['patch.version'] = versionParts[2]\n+                    </scripts>\n+                </configuration>\n+                <dependencies>\n+                    <dependency>\n+                        <groupId>org.codehaus.groovy</groupId>\n+                        <artifactId>groovy-all</artifactId>\n+                        <version>${cs.groovy.version}</version>\n+                        <scope>runtime</scope>\n+                    </dependency>\n+                </dependencies>\n+            </plugin>\n+            <plugin>\n+                <groupId>com.googlecode.maven-download-plugin</groupId>\n+                <artifactId>download-maven-plugin</artifactId>\n+                <version>1.6.3</version>\n+                <executions>\n+                    <execution>\n+                        <id>download-checksums</id>\n+                        <phase>generate-resources</phase>\n+                        <goals>\n+                            <goal>wget</goal>\n+                        </goals>\n+                        <configuration>\n+                            <url>https://download.cloudstack.org/systemvm/${cs.version}/md5sum.txt</url>\n+                            <outputDirectory>${basedir}/dist/systemvm-templates/</outputDirectory>\n+                            <skipCache>true</skipCache>\n+                            <overwrite>true</overwrite>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.codehaus.mojo</groupId>\n+                <artifactId>exec-maven-plugin</artifactId>\n+                <version>1.2.1</version>\n+                <executions>\n+                    <execution>\n+                        <id>validate-checksums</id>\n+                        <phase>generate-resources</phase>\n+                        <goals>\n+                            <goal>exec</goal>\n+                        </goals>\n+                        <configuration>\n+                            <executable>bash</executable>\n+                            <arguments>\n+                                <argument>validate-checksum</argument>\n+                            </arguments>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.codehaus.mojo</groupId>\n+                <artifactId>exec-maven-plugin</artifactId>\n+                <version>1.2.1</version>\n+                <executions>\n+                    <execution>\n+                        <id>systemvm-template-metadata</id>\n+                        <phase>package</phase>\n+                        <goals>\n+                            <goal>exec</goal>\n+                        </goals>\n+                        <configuration>\n+                            <workingDirectory>${basedir}/</workingDirectory>\n+                            <executable>bash</executable>\n+                            <arguments>\n+                                <argument>templateConfig.sh</argument>\n+                                <armument>${project.version}</armument>\n+                            </arguments>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+        </plugins>\n+    </build>\n+    <profiles>\n+        <profile>\n+            <id>template-create</id>\n+            <activation>\n+                <property>\n+                    <name>noredist</name>\n+                </property>\n+            </activation>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>com.googlecode.maven-download-plugin</groupId>\n+                        <artifactId>download-maven-plugin</artifactId>\n+                        <version>1.6.3</version>\n+                        <executions>\n+                            <execution>\n+                                <id>download-kvm-template</id>\n+                                <goals>\n+                                    <goal>wget</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <url>https://download.cloudstack.org/systemvm/${cs.version}/systemvmtemplate-${cs.version}.${patch.version}-kvm.qcow2.bz2</url>\n+                                    <outputDirectory>${basedir}/dist/systemvm-templates/</outputDirectory>\n+                                </configuration>\n+                            </execution>\n+                            <execution>\n+                                <id>download-vmware-template</id>\n+                                <goals>\n+                                    <goal>wget</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <url>https://download.cloudstack.org/systemvm/${cs.version}/systemvmtemplate-${cs.version}.${patch.version}-vmware.ova</url>\n+                                    <outputDirectory>${basedir}/dist/systemvm-templates/</outputDirectory>\n+                                </configuration>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzg0NDExOnYy", "diffSide": "RIGHT", "path": "engine/schema/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowNzoxMVrOKWbQAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowNzoxMVrOKWbQAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwMzc3OQ==", "bodyText": "Add the skipCache option here?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694603779", "createdAt": "2021-08-24T08:07:11Z", "author": {"login": "rhtyd"}, "path": "engine/schema/pom.xml", "diffHunk": "@@ -52,5 +52,158 @@\n             <groupId>mysql</groupId>\n             <artifactId>mysql-connector-java</artifactId>\n         </dependency>\n+        <dependency>\n+            <groupId>org.ini4j</groupId>\n+            <artifactId>ini4j</artifactId>\n+            <version>${cs.ini.version}</version>\n+        </dependency>\n     </dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.codehaus.gmavenplus</groupId>\n+                <artifactId>gmavenplus-plugin</artifactId>\n+                <version>${cs.gmaven.version}</version>\n+                <executions>\n+                    <execution>\n+                        <phase>generate-sources</phase>\n+                        <goals>\n+                            <goal>execute</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+                <configuration>\n+                    <bindPropertiesToSeparateVariables> true </bindPropertiesToSeparateVariables>\n+                    <scripts>\n+                        log.info \"$project.version\"\n+                        def projectVersion = project.version\n+                        String[] versionParts =  projectVersion.split(\"\\\\.\")\n+                        project.properties['cs.version'] = versionParts[0] + \".\" + versionParts[1]\n+                        project.properties['patch.version'] = versionParts[2]\n+                    </scripts>\n+                </configuration>\n+                <dependencies>\n+                    <dependency>\n+                        <groupId>org.codehaus.groovy</groupId>\n+                        <artifactId>groovy-all</artifactId>\n+                        <version>${cs.groovy.version}</version>\n+                        <scope>runtime</scope>\n+                    </dependency>\n+                </dependencies>\n+            </plugin>\n+            <plugin>\n+                <groupId>com.googlecode.maven-download-plugin</groupId>\n+                <artifactId>download-maven-plugin</artifactId>\n+                <version>1.6.3</version>\n+                <executions>\n+                    <execution>\n+                        <id>download-checksums</id>\n+                        <phase>generate-resources</phase>\n+                        <goals>\n+                            <goal>wget</goal>\n+                        </goals>\n+                        <configuration>\n+                            <url>https://download.cloudstack.org/systemvm/${cs.version}/md5sum.txt</url>\n+                            <outputDirectory>${basedir}/dist/systemvm-templates/</outputDirectory>\n+                            <skipCache>true</skipCache>\n+                            <overwrite>true</overwrite>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.codehaus.mojo</groupId>\n+                <artifactId>exec-maven-plugin</artifactId>\n+                <version>1.2.1</version>\n+                <executions>\n+                    <execution>\n+                        <id>validate-checksums</id>\n+                        <phase>generate-resources</phase>\n+                        <goals>\n+                            <goal>exec</goal>\n+                        </goals>\n+                        <configuration>\n+                            <executable>bash</executable>\n+                            <arguments>\n+                                <argument>validate-checksum</argument>\n+                            </arguments>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.codehaus.mojo</groupId>\n+                <artifactId>exec-maven-plugin</artifactId>\n+                <version>1.2.1</version>\n+                <executions>\n+                    <execution>\n+                        <id>systemvm-template-metadata</id>\n+                        <phase>package</phase>\n+                        <goals>\n+                            <goal>exec</goal>\n+                        </goals>\n+                        <configuration>\n+                            <workingDirectory>${basedir}/</workingDirectory>\n+                            <executable>bash</executable>\n+                            <arguments>\n+                                <argument>templateConfig.sh</argument>\n+                                <armument>${project.version}</armument>\n+                            </arguments>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+        </plugins>\n+    </build>\n+    <profiles>\n+        <profile>\n+            <id>template-create</id>\n+            <activation>\n+                <property>\n+                    <name>noredist</name>\n+                </property>\n+            </activation>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>com.googlecode.maven-download-plugin</groupId>\n+                        <artifactId>download-maven-plugin</artifactId>\n+                        <version>1.6.3</version>\n+                        <executions>\n+                            <execution>\n+                                <id>download-kvm-template</id>\n+                                <goals>\n+                                    <goal>wget</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <url>https://download.cloudstack.org/systemvm/${cs.version}/systemvmtemplate-${cs.version}.${patch.version}-kvm.qcow2.bz2</url>\n+                                    <outputDirectory>${basedir}/dist/systemvm-templates/</outputDirectory>\n+                                </configuration>\n+                            </execution>\n+                            <execution>\n+                                <id>download-vmware-template</id>\n+                                <goals>\n+                                    <goal>wget</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <url>https://download.cloudstack.org/systemvm/${cs.version}/systemvmtemplate-${cs.version}.${patch.version}-vmware.ova</url>\n+                                    <outputDirectory>${basedir}/dist/systemvm-templates/</outputDirectory>\n+                                </configuration>\n+                            </execution>\n+                            <execution>\n+                                <id>download-xenserver-template</id>\n+                                <goals>\n+                                    <goal>wget</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <url>https://download.cloudstack.org/systemvm/${cs.version}/systemvmtemplate-${cs.version}.${patch.version}-xen.vhd.bz2</url>\n+                                    <outputDirectory>${basedir}/dist/systemvm-templates/</outputDirectory>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzg0NzQ2OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/DatabaseUpgradeChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowNzo0NlrOKWbR-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowNzo0NlrOKWbR-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNDI4MQ==", "bodyText": "minor nit - the standard practice is to introduce getters and setters for internal or static fields", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694604281", "createdAt": "2021-08-24T08:07:46Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/DatabaseUpgradeChecker.java", "diffHunk": "@@ -364,7 +364,11 @@ public void check() {\n                     return;\n                 }\n \n+                SystemVmTemplateRegistration.parseMetadataFile();\n                 final CloudStackVersion currentVersion = CloudStackVersion.parse(currentVersionValue);\n+                SystemVmTemplateRegistration.CS_MAJOR_VERSION  = String.valueOf(currentVersion.getMajorRelease()) + \".\" + String.valueOf(currentVersion.getMinorRelease());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzg0ODUwOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/DatabaseUpgradeChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowNzo1NVrOKWbSkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowNzo1NVrOKWbSkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNDQzNQ==", "bodyText": "minor nit - same as above ^^", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694604435", "createdAt": "2021-08-24T08:07:55Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/DatabaseUpgradeChecker.java", "diffHunk": "@@ -364,7 +364,11 @@ public void check() {\n                     return;\n                 }\n \n+                SystemVmTemplateRegistration.parseMetadataFile();\n                 final CloudStackVersion currentVersion = CloudStackVersion.parse(currentVersionValue);\n+                SystemVmTemplateRegistration.CS_MAJOR_VERSION  = String.valueOf(currentVersion.getMajorRelease()) + \".\" + String.valueOf(currentVersion.getMinorRelease());\n+                SystemVmTemplateRegistration.CS_TINY_VERSION = String.valueOf(currentVersion.getPatchRelease());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzg1NzEyOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowOToyNlrOKWbXdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODowOToyNlrOKWbXdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNTY4NQ==", "bodyText": "Remove unnecessary constructor", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694605685", "createdAt": "2021-08-24T08:09:26Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzg2NDA4OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxMDo0OFrOKWbboA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxMDo0OFrOKWbboA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNjc1Mg==", "bodyText": "Security issue - you may want to randomly create a directory in java tmp space for example:\nPath tempDirWithPrefix = Files.createTempDirectory(prefix);\n\nAnd in the finally block remove the temp directory after unmounting it. Using the tmp directory may also guard against multiple-threads trying to execute this method.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694606752", "createdAt": "2021-08-24T08:10:48Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 263}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzg2ODMxOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxMTo0MVrOKWbeJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxMTo0MVrOKWbeJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNzM5Ng==", "bodyText": "same as last time - what is this magic number?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694607396", "createdAt": "2021-08-24T08:11:41Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzg3MDk5OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxMjoxNVrOKWbfzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxMjoxNVrOKWbfzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNzgyMg==", "bodyText": "Can we use any off-the-shelf utility/method to do checksums? Otherwise, pl add unit tests to cover this method.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694607822", "createdAt": "2021-08-24T08:12:15Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 278}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzg4MjAwOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxNDoxMVrOKWbmQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNlQwNDo0MToyNVrOKYBzWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwOTQ3NQ==", "bodyText": "Minor nit - refactor/rename the method which is returning template ID? Maybe return Long than long (the idea that return object is null means object not found, otherwise template ID is found and returned - this also allows you to not compare against magic no. -1)?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694609475", "createdAt": "2021-08-24T08:14:11Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 305}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgzMzgxNw==", "bodyText": "rather throw an exception than return null imnsho", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695833817", "createdAt": "2021-08-25T14:52:32Z", "author": {"login": "DaanHoogland"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwOTQ3NQ=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 305}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjI4Mzk5NA==", "bodyText": "this has been refactored and handled - thanks", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r696283994", "createdAt": "2021-08-26T04:41:25Z", "author": {"login": "Pearl1594"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwOTQ3NQ=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 305}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzkwMTY3OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxNjoyMlrOKWbx8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoxNTozMlrOKXkG4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxMjQ2NQ==", "bodyText": "Check - These strings are hardcoded, could the cause an issue:\n    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n\nIn different distros, as some of these paths are overridden by build.properties. The relative path is that relative wrt the jar, or is that a file/dir path we use? Or is that to support developer's workflow?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694612465", "createdAt": "2021-08-24T08:16:22Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 329}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTc5NzQ3Mw==", "bodyText": "The check for ./engine/schema/dist/systemvm-templates/\" path is for developer workflow - similar to this: https://github.com/apache/cloudstack/blob/main/plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java#L7053", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695797473", "createdAt": "2021-08-25T14:15:32Z", "author": {"login": "Pearl1594"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxMjQ2NQ=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 329}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzkwNzQyOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxNzowMFrOKWb1QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxNzowMFrOKWb1QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxMzMxMg==", "bodyText": "Refactor move this to an already existing Enum?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694613312", "createdAt": "2021-08-24T08:17:00Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 350}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzkxMjM0OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxNzozMlrOKWb4Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoxNjozN1rOKXkK8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxNDAyMg==", "bodyText": "Refactor move this to an already existing Enum?\nThe logic would be you ask the Enum or Utility to get the Enum by string; than you can convert the Enum to string or just use Enum.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694614022", "createdAt": "2021-08-24T08:17:32Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 366}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTc5ODUxMw==", "bodyText": "the reason for doing this is that templates names don't have \"xenserver\" / \"ovm3\" but rather \"xen\"/\"ovm\" - hence using this to fetch the template names while parsing the metadata file", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695798513", "createdAt": "2021-08-25T14:16:37Z", "author": {"login": "Pearl1594"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxNDAyMg=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 366}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzkyMTU5OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxODozMVrOKWb9Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxODozMVrOKWb9Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxNTM2Mg==", "bodyText": "Use Files to create tmp directory than use static - and add a finally block to remove/unmount/cleanup dir.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694615362", "createdAt": "2021-08-24T08:18:31Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 416}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzkyOTk2OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxOToyOVrOKWcCkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxOToyOVrOKWcCkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxNjcyMw==", "bodyText": "This would break/cause maintenance issue/if/when the table changes - see if there's a way to use/initialise GenericDaoBase if possible? If it's not possible then keep as is.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694616723", "createdAt": "2021-08-24T08:19:29Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 450}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzkzMDE4OnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterResourceModifierActionWorker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxOTozMVrOKWcCvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoxOTozMVrOKWcCvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxNjc2Ng==", "bodyText": "could this be disected a bit more? at least the if(enable) and its else block in extra methods?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694616766", "createdAt": "2021-08-24T08:19:31Z", "author": {"login": "DaanHoogland"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterResourceModifierActionWorker.java", "diffHunk": "@@ -548,13 +565,96 @@ protected String getKubernetesClusterNodeNamePrefix() {\n         return prefix;\n     }\n \n-    protected String getKubernetesClusterNodeAvailableName(final String hostName) {\n-        String name = hostName;\n-        int suffix = 1;\n-        while (vmInstanceDao.findVMByHostName(name) != null) {\n-            name = String.format(\"%s-%d\", hostName, suffix);\n-            suffix++;\n+    protected KubernetesClusterVO updateKubernetesClusterEntry(final Long cores, final Long memory,\n+        final Long size, final Long serviceOfferingId, final Boolean autoscaleEnabled, final Long minSize, final Long maxSize) {\n+        return Transaction.execute(new TransactionCallback<KubernetesClusterVO>() {\n+                @Override\n+                public KubernetesClusterVO doInTransaction(TransactionStatus status) {\n+                KubernetesClusterVO updatedCluster = kubernetesClusterDao.createForUpdate(kubernetesCluster.getId());\n+                if (cores != null) {\n+                    updatedCluster.setCores(cores);\n+                }\n+                if (memory != null) {\n+                    updatedCluster.setMemory(memory);\n+                }\n+                if (size != null) {\n+                    updatedCluster.setNodeCount(size);\n+                }\n+                if (serviceOfferingId != null) {\n+                    updatedCluster.setServiceOfferingId(serviceOfferingId);\n+                }\n+                if (autoscaleEnabled != null) {\n+                    updatedCluster.setAutoscalingEnabled(autoscaleEnabled.booleanValue());\n+                }\n+                updatedCluster.setMinSize(minSize);\n+                updatedCluster.setMaxSize(maxSize);\n+                return kubernetesClusterDao.persist(updatedCluster);\n+            }\n+        });\n+    }\n+\n+    private KubernetesClusterVO updateKubernetesClusterEntry(final Boolean autoscaleEnabled, final Long minSize, final Long maxSize) throws CloudRuntimeException {\n+        KubernetesClusterVO kubernetesClusterVO = updateKubernetesClusterEntry(null, null, null, null, autoscaleEnabled, minSize, maxSize);\n+        if (kubernetesClusterVO == null) {\n+            logTransitStateAndThrow(Level.ERROR, String.format(\"Scaling Kubernetes cluster %s failed, unable to update Kubernetes cluster\",\n+                    kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n+        }\n+        return kubernetesClusterVO;\n+    }\n+\n+    protected boolean autoscaleCluster(boolean enable, Long minSize, Long maxSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzkzNDg5OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyMDowMFrOKWcFeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyMDowMFrOKWcFeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxNzQ2Ng==", "bodyText": "Minor nit - update name to make more sense (updateSystemVmTemplateDetails?)", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694617466", "createdAt": "2021-08-24T08:20:00Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 501}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzk1ODI2OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyMjoyNlrOKWcTDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyMjoyNlrOKWcTDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyMDk0MQ==", "bodyText": "Can we somehow explore transactions? General comment - in this class we're doing many SQL transactions manually instead of using generic dao base, how should the system recover in case of failure; consider this method where you update something, but what if the delete fails afterwards? Similar other cases throughout this class where some statements work but others fail.\nOne way is to wrap each try-catch for each sql query that is not just read-only (select query) and handle on case-by-case basis.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694620941", "createdAt": "2021-08-24T08:22:26Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 589}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzk2NzA2OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyMzoyMFrOKWcYEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoxNzo1N1rOKXkQWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyMjIyNA==", "bodyText": "Check and see if we should run using sudo (there's usually some API param you can pass so commands run as sudo) as mgmt server process runs as cloud user.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694622224", "createdAt": "2021-08-24T08:23:20Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 612}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTc5OTg5Nw==", "bodyText": "I haven't faced any permission issue during mount/umount - so adding sudo may not be required", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695799897", "createdAt": "2021-08-25T14:17:57Z", "author": {"login": "Pearl1594"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyMjIyNA=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 612}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzk3MDQwOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyMzo0MlrOKWcaAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyMzo0MlrOKWcaAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyMjcyMA==", "bodyText": "if this is static move this to private static String field?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694622720", "createdAt": "2021-08-24T08:23:42Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 622}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzk3MzU5OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyNDowM1rOKWcb_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoxOTo0M1rOKXkXSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyMzIyOQ==", "bodyText": "Minor nit - should we run this as root user? that is run as sudo/sudoer?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694623229", "createdAt": "2021-08-24T08:24:03Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 627}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwMTY3Mg==", "bodyText": "It isn't required that the script be run by root user - the necessary command - \"touch\" has been added to the  /etc/sudoers.d/cloudstack-management file", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695801672", "createdAt": "2021-08-25T14:19:43Z", "author": {"login": "Pearl1594"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyMzIyOQ=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 627}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyMzk5MzUwOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyNjoxOFrOKWcn7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyNjoxOFrOKWcn7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyNjI4Nw==", "bodyText": "General comment:\n\nBreak failure-cases in individual try-catch and apply recovery/finally logic\nFor path creation use a standard utility from Files or other utility/dependency (this code highly assumes Linux and specific paths than tmp folders)\ncan we introduce transactional query? (fail together or pass together)\nUse tmp files and folders and cleanup/unmount/gc in finally", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694626287", "createdAt": "2021-08-24T08:26:18Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+        scr.add(\"-u\", templateName);\n+        scr.add(\"-f\", TEMPLATES_PATH + fileNames.get(hypervisorAndTemplateName.first()));\n+        scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+        scr.add(\"-d\", destTempFolder);\n+        String result = scr.execute();\n+        if (result != null) {\n+            String errMsg = String.format(\"failed to create template: %s \", result);\n+            LOGGER.error(errMsg);\n+            throw new CloudRuntimeException(errMsg);\n+        }\n+\n+    }\n+\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+                                        Pair<String, Long> storeUrlAndId, VMTemplateVO templateVO) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    templateVO.getUrl(), templateVO.getChecksum(), templateVO.getFormat(), (int) templateVO.getGuestOSId(), templateVO.getHypervisorType(),\n+                    storeUrlAndId.second());\n+            templateId = templateVO.getId();\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 660}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDAwMTc4OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyNzoxM1rOKWcs-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyNzoxM1rOKWcs-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyNzU3OA==", "bodyText": "See above method and review comments - seems redundant code, could be refactored together?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694627578", "createdAt": "2021-08-24T08:27:13Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+        scr.add(\"-u\", templateName);\n+        scr.add(\"-f\", TEMPLATES_PATH + fileNames.get(hypervisorAndTemplateName.first()));\n+        scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+        scr.add(\"-d\", destTempFolder);\n+        String result = scr.execute();\n+        if (result != null) {\n+            String errMsg = String.format(\"failed to create template: %s \", result);\n+            LOGGER.error(errMsg);\n+            throw new CloudRuntimeException(errMsg);\n+        }\n+\n+    }\n+\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+                                        Pair<String, Long> storeUrlAndId, VMTemplateVO templateVO) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    templateVO.getUrl(), templateVO.getChecksum(), templateVO.getFormat(), (int) templateVO.getGuestOSId(), templateVO.getHypervisorType(),\n+                    storeUrlAndId.second());\n+            templateId = templateVO.getId();\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, false);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+\n+    }\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName, Pair<String, Long> storeUrlAndId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 673}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDAxODU3OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyODo1MlrOKWc2ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODoyOTo0OFrOKWc79g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzMDA0Ng==", "bodyText": "Minor nit - use consistent naming style for public static fields (if not necessary you want to convert them into private static ... fields, or use getters/setters - also makes it easier to write unit tests).", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694630046", "createdAt": "2021-08-24T08:28:52Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzMTQxNA==", "bodyText": "Suggestion - instead of four different fields you want a Map of HypervisorType to an object that returns all metadata of the template (name, filename, url and checksum).", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694631414", "createdAt": "2021-08-24T08:29:48Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzMDA0Ng=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDAzNjExOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODozMDo0MVrOKWdA6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODozMDo0MVrOKWdA6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzMjY4Mw==", "bodyText": "Instead of four fields, you want a map object that maps hypervisor type to a template object that holds all four properties - filename, checksum, url and name", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694632683", "createdAt": "2021-08-24T08:30:41Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+        scr.add(\"-u\", templateName);\n+        scr.add(\"-f\", TEMPLATES_PATH + fileNames.get(hypervisorAndTemplateName.first()));\n+        scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+        scr.add(\"-d\", destTempFolder);\n+        String result = scr.execute();\n+        if (result != null) {\n+            String errMsg = String.format(\"failed to create template: %s \", result);\n+            LOGGER.error(errMsg);\n+            throw new CloudRuntimeException(errMsg);\n+        }\n+\n+    }\n+\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+                                        Pair<String, Long> storeUrlAndId, VMTemplateVO templateVO) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    templateVO.getUrl(), templateVO.getChecksum(), templateVO.getFormat(), (int) templateVO.getGuestOSId(), templateVO.getHypervisorType(),\n+                    storeUrlAndId.second());\n+            templateId = templateVO.getId();\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, false);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+\n+    }\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName, Pair<String, Long> storeUrlAndId) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    newTemplateUrl.get(hypervisor), newTemplateChecksum.get(hypervisor), hypervisorImageFormat.get(hypervisor), hypervisorGuestOsMap.get(hypervisor), hypervisor, storeUrlAndId.second());\n+            templateId = createTemplateObjectInDB(conn, details);\n+            if (templateId == null) {\n+                throw new CloudRuntimeException(String.format(\"Failed to register template for hypervisor: %s\", hypervisor.name()));\n+            }\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, true);\n+            Map<String, String> configParams = new HashMap<>();\n+            configParams.put(SystemVmTemplateRegistration.routerTemplateConfigurationNames.get(hypervisorAndTemplateName.first()), hypervisorAndTemplateName.second());\n+            configParams.put(\"minreq.sysvmtemplate.version\", CS_MAJOR_VERSION + \".\" + CS_TINY_VERSION);\n+            updateConfigurationParams(conn, configParams);\n+            updateSystemVMEntries(conn, templateId, hypervisorAndTemplateName);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void parseMetadataFile() {\n+        try {\n+            Ini ini = new Ini();\n+            ini.load(new FileReader(METADATA_FILE));\n+            for (Hypervisor.HypervisorType hypervisorType : hypervisorList) {\n+                String hypervisor = hypervisorType.name().toLowerCase(Locale.ROOT);\n+                Ini.Section section = ini.get(hypervisor);\n+                NewTemplateNameList.put(hypervisorType, section.get(\"templatename\"));\n+                fileNames.put(hypervisorType, section.get(\"filename\"));\n+                newTemplateChecksum.put(hypervisorType, section.get(\"checksum\"));\n+                newTemplateUrl.put(hypervisorType, section.get(\"downloadurl\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 721}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDA0NzcxOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODozMTo1NFrOKWdHjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODozMTo1NFrOKWdHjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzNDM4Mw==", "bodyText": "HOL UP: Oh dear (/me bites lip) - you want to be very very very cautious with this sort of code; try and use Java Files or similar to do deletion and cleanup :)", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694634383", "createdAt": "2021-08-24T08:31:54Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+        scr.add(\"-u\", templateName);\n+        scr.add(\"-f\", TEMPLATES_PATH + fileNames.get(hypervisorAndTemplateName.first()));\n+        scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+        scr.add(\"-d\", destTempFolder);\n+        String result = scr.execute();\n+        if (result != null) {\n+            String errMsg = String.format(\"failed to create template: %s \", result);\n+            LOGGER.error(errMsg);\n+            throw new CloudRuntimeException(errMsg);\n+        }\n+\n+    }\n+\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+                                        Pair<String, Long> storeUrlAndId, VMTemplateVO templateVO) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    templateVO.getUrl(), templateVO.getChecksum(), templateVO.getFormat(), (int) templateVO.getGuestOSId(), templateVO.getHypervisorType(),\n+                    storeUrlAndId.second());\n+            templateId = templateVO.getId();\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, false);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+\n+    }\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName, Pair<String, Long> storeUrlAndId) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    newTemplateUrl.get(hypervisor), newTemplateChecksum.get(hypervisor), hypervisorImageFormat.get(hypervisor), hypervisorGuestOsMap.get(hypervisor), hypervisor, storeUrlAndId.second());\n+            templateId = createTemplateObjectInDB(conn, details);\n+            if (templateId == null) {\n+                throw new CloudRuntimeException(String.format(\"Failed to register template for hypervisor: %s\", hypervisor.name()));\n+            }\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, true);\n+            Map<String, String> configParams = new HashMap<>();\n+            configParams.put(SystemVmTemplateRegistration.routerTemplateConfigurationNames.get(hypervisorAndTemplateName.first()), hypervisorAndTemplateName.second());\n+            configParams.put(\"minreq.sysvmtemplate.version\", CS_MAJOR_VERSION + \".\" + CS_TINY_VERSION);\n+            updateConfigurationParams(conn, configParams);\n+            updateSystemVMEntries(conn, templateId, hypervisorAndTemplateName);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void parseMetadataFile() {\n+        try {\n+            Ini ini = new Ini();\n+            ini.load(new FileReader(METADATA_FILE));\n+            for (Hypervisor.HypervisorType hypervisorType : hypervisorList) {\n+                String hypervisor = hypervisorType.name().toLowerCase(Locale.ROOT);\n+                Ini.Section section = ini.get(hypervisor);\n+                NewTemplateNameList.put(hypervisorType, section.get(\"templatename\"));\n+                fileNames.put(hypervisorType, section.get(\"filename\"));\n+                newTemplateChecksum.put(hypervisorType, section.get(\"checksum\"));\n+                newTemplateUrl.put(hypervisorType, section.get(\"downloadurl\"));\n+            }\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to parse systemVM template metadata file: %s\", METADATA_FILE);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void cleanupStore(Long templateId) {\n+        String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + String.valueOf(templateId);\n+        Script.runSimpleBashScript(\"rm -rf \" + destTempFolder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 732}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDA2MDIwOnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODozMzoxMlrOKWdOww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODozMzoxMlrOKWdOww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzNjIyNw==", "bodyText": "You may want to explore non-static way and use tmp directory created by Files, to create folder, mount secondary storage, do all sorts of things.\nhttps://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.nio.file.Path-java.lang.String-java.nio.file.attribute.FileAttribute...-", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694636227", "createdAt": "2021-08-24T08:33:12Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+        scr.add(\"-u\", templateName);\n+        scr.add(\"-f\", TEMPLATES_PATH + fileNames.get(hypervisorAndTemplateName.first()));\n+        scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+        scr.add(\"-d\", destTempFolder);\n+        String result = scr.execute();\n+        if (result != null) {\n+            String errMsg = String.format(\"failed to create template: %s \", result);\n+            LOGGER.error(errMsg);\n+            throw new CloudRuntimeException(errMsg);\n+        }\n+\n+    }\n+\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+                                        Pair<String, Long> storeUrlAndId, VMTemplateVO templateVO) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    templateVO.getUrl(), templateVO.getChecksum(), templateVO.getFormat(), (int) templateVO.getGuestOSId(), templateVO.getHypervisorType(),\n+                    storeUrlAndId.second());\n+            templateId = templateVO.getId();\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, false);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+\n+    }\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName, Pair<String, Long> storeUrlAndId) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    newTemplateUrl.get(hypervisor), newTemplateChecksum.get(hypervisor), hypervisorImageFormat.get(hypervisor), hypervisorGuestOsMap.get(hypervisor), hypervisor, storeUrlAndId.second());\n+            templateId = createTemplateObjectInDB(conn, details);\n+            if (templateId == null) {\n+                throw new CloudRuntimeException(String.format(\"Failed to register template for hypervisor: %s\", hypervisor.name()));\n+            }\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, true);\n+            Map<String, String> configParams = new HashMap<>();\n+            configParams.put(SystemVmTemplateRegistration.routerTemplateConfigurationNames.get(hypervisorAndTemplateName.first()), hypervisorAndTemplateName.second());\n+            configParams.put(\"minreq.sysvmtemplate.version\", CS_MAJOR_VERSION + \".\" + CS_TINY_VERSION);\n+            updateConfigurationParams(conn, configParams);\n+            updateSystemVMEntries(conn, templateId, hypervisorAndTemplateName);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void parseMetadataFile() {\n+        try {\n+            Ini ini = new Ini();\n+            ini.load(new FileReader(METADATA_FILE));\n+            for (Hypervisor.HypervisorType hypervisorType : hypervisorList) {\n+                String hypervisor = hypervisorType.name().toLowerCase(Locale.ROOT);\n+                Ini.Section section = ini.get(hypervisor);\n+                NewTemplateNameList.put(hypervisorType, section.get(\"templatename\"));\n+                fileNames.put(hypervisorType, section.get(\"filename\"));\n+                newTemplateChecksum.put(hypervisorType, section.get(\"checksum\"));\n+                newTemplateUrl.put(hypervisorType, section.get(\"downloadurl\"));\n+            }\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to parse systemVM template metadata file: %s\", METADATA_FILE);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void cleanupStore(Long templateId) {\n+        String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + String.valueOf(templateId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 731}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDA3MDg4OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODozNDo1M1rOKWdVaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODozNDo1M1rOKWdVaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzNzkzMQ==", "bodyText": "Can you explain/simplify logic - break in smaller methods?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694637931", "createdAt": "2021-08-24T08:34:53Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+        scr.add(\"-u\", templateName);\n+        scr.add(\"-f\", TEMPLATES_PATH + fileNames.get(hypervisorAndTemplateName.first()));\n+        scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+        scr.add(\"-d\", destTempFolder);\n+        String result = scr.execute();\n+        if (result != null) {\n+            String errMsg = String.format(\"failed to create template: %s \", result);\n+            LOGGER.error(errMsg);\n+            throw new CloudRuntimeException(errMsg);\n+        }\n+\n+    }\n+\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+                                        Pair<String, Long> storeUrlAndId, VMTemplateVO templateVO) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    templateVO.getUrl(), templateVO.getChecksum(), templateVO.getFormat(), (int) templateVO.getGuestOSId(), templateVO.getHypervisorType(),\n+                    storeUrlAndId.second());\n+            templateId = templateVO.getId();\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, false);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+\n+    }\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName, Pair<String, Long> storeUrlAndId) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    newTemplateUrl.get(hypervisor), newTemplateChecksum.get(hypervisor), hypervisorImageFormat.get(hypervisor), hypervisorGuestOsMap.get(hypervisor), hypervisor, storeUrlAndId.second());\n+            templateId = createTemplateObjectInDB(conn, details);\n+            if (templateId == null) {\n+                throw new CloudRuntimeException(String.format(\"Failed to register template for hypervisor: %s\", hypervisor.name()));\n+            }\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, true);\n+            Map<String, String> configParams = new HashMap<>();\n+            configParams.put(SystemVmTemplateRegistration.routerTemplateConfigurationNames.get(hypervisorAndTemplateName.first()), hypervisorAndTemplateName.second());\n+            configParams.put(\"minreq.sysvmtemplate.version\", CS_MAJOR_VERSION + \".\" + CS_TINY_VERSION);\n+            updateConfigurationParams(conn, configParams);\n+            updateSystemVMEntries(conn, templateId, hypervisorAndTemplateName);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void parseMetadataFile() {\n+        try {\n+            Ini ini = new Ini();\n+            ini.load(new FileReader(METADATA_FILE));\n+            for (Hypervisor.HypervisorType hypervisorType : hypervisorList) {\n+                String hypervisor = hypervisorType.name().toLowerCase(Locale.ROOT);\n+                Ini.Section section = ini.get(hypervisor);\n+                NewTemplateNameList.put(hypervisorType, section.get(\"templatename\"));\n+                fileNames.put(hypervisorType, section.get(\"filename\"));\n+                newTemplateChecksum.put(hypervisorType, section.get(\"checksum\"));\n+                newTemplateUrl.put(hypervisorType, section.get(\"downloadurl\"));\n+            }\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to parse systemVM template metadata file: %s\", METADATA_FILE);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void cleanupStore(Long templateId) {\n+        String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + String.valueOf(templateId);\n+        Script.runSimpleBashScript(\"rm -rf \" + destTempFolder);\n+    }\n+\n+    public static void registerTemplates(Connection conn, Set<Hypervisor.HypervisorType> hypervisorsInUse) {\n+        GlobalLock lock = GlobalLock.getInternLock(\"UpgradeDatabase-Lock\");\n+        try {\n+            LOGGER.info(\"Grabbing lock to register templates.\");\n+            if (!lock.lock(LOCK_WAIT_TIMEOUT)) {\n+                throw new CloudRuntimeException(\"Unable to acquire lock to register SystemVM template.\");\n+            }\n+            // Check if templates path exists\n+            try {\n+                Set<String> hypervisors = hypervisorsInUse.stream().map(Enum::name).\n+                        map(name -> name.toLowerCase(Locale.ROOT)).map(SystemVmTemplateRegistration::getHypervisorName).collect(Collectors.toSet());\n+                List<String> templates = new ArrayList<>();\n+                for (Hypervisor.HypervisorType hypervisorType : hypervisorsInUse) {\n+                    templates.add(fileNames.get(hypervisorType));\n+                }\n+\n+                boolean templatesFound = true;\n+                for (String hypervisor : hypervisors) {\n+                    String matchedTemplate = templates.stream().filter(x -> x.contains(hypervisor)).findAny().orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 753}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDA3NjQ4OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41510to41600.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODozNjowMFrOKWdY0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoyMToyNFrOKXkdpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzODgwMg==", "bodyText": "Why specific code for VMware? Can we add some generic utility in this new class (or create a new/different class/manager) and let it handle/do any systemvmtemplate upgrade logic?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694638802", "createdAt": "2021-08-24T08:36:00Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41510to41600.java", "diffHunk": "@@ -64,6 +66,7 @@ public boolean supportsRollingUpgrade() {\n \n     @Override\n     public void performDataMigration(Connection conn) {\n+        updateVMwareSystemvVMTemplateField(conn, SystemVmTemplateRegistration.NewTemplateNameList.get(Hypervisor.HypervisorType.VMware));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwMzMwMQ==", "bodyText": "This was done as there was a change in  upgrade workflow made in 4.15 - I've now reverted it, as we have gone back to the old w/f of first updating the schema and then registering the template(s)", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695803301", "createdAt": "2021-08-25T14:21:24Z", "author": {"login": "Pearl1594"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41510to41600.java", "diffHunk": "@@ -64,6 +66,7 @@ public boolean supportsRollingUpgrade() {\n \n     @Override\n     public void performDataMigration(Connection conn) {\n+        updateVMwareSystemvVMTemplateField(conn, SystemVmTemplateRegistration.NewTemplateNameList.get(Hypervisor.HypervisorType.VMware));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzODgwMg=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDA4MDE3OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41510to41600.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODozNjo0N1rOKWdbIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODozNjo0N1rOKWdbIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzOTM5NA==", "bodyText": "Suggestion - move all systemvmtemplate changes to a service/manager/utility class? (as we keep repeating this logic between upgrade classes)", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694639394", "createdAt": "2021-08-24T08:36:47Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41510to41600.java", "diffHunk": "@@ -235,6 +175,16 @@ public void updateSystemVmTemplates(final Connection conn) {\n         LOG.debug(\"Updating System Vm Template IDs Complete\");\n     }\n \n+    private void updateVMwareSystemvVMTemplateField(final Connection conn, String templateName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDA4NDc2OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/java/com/cloud/vm/UserVmVO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODozNzozN1rOKWdd3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODozNzozN1rOKWdd3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0MDA5Mw==", "bodyText": "Minor nit - is this guarded for user account/roles (they shouldn't be able to change template type)", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694640093", "createdAt": "2021-08-24T08:37:37Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/java/com/cloud/vm/UserVmVO.java", "diffHunk": "@@ -48,6 +48,9 @@\n     @Column(name = \"update_parameters\", updatable = true)\n     protected boolean updateParameters = true;\n \n+    @Column(name = \"user_vm_type\", updatable = true)\n+    private String userVmType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDEwNTU0OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/resources/META-INF/db/schema-41510to41600.sql", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo0MTo1MVrOKWdqgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoyMjowNlrOKXkgqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0MzMyOA==", "bodyText": "@Pearl1594 this may not be necessary, we do have a routing field and type field. (type SYSTEM/USER?)", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694643328", "createdAt": "2021-08-24T08:41:51Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/resources/META-INF/db/schema-41510to41600.sql", "diffHunk": "@@ -19,6 +19,19 @@\n -- Schema upgrade from 4.15.1.0 to 4.16.0.0\n --;\n \n+ALTER TABLE `cloud`.`user_vm` ADD COLUMN `user_vm_type` varchar(255) DEFAULT \"UserVM\" COMMENT 'Defines the type of UserVM';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwNDA3Mg==", "bodyText": "The type field is to state if it's a User / System or any other type of VM - CKS Node is a type of user vm", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695804072", "createdAt": "2021-08-25T14:22:06Z", "author": {"login": "Pearl1594"}, "path": "engine/schema/src/main/resources/META-INF/db/schema-41510to41600.sql", "diffHunk": "@@ -19,6 +19,19 @@\n -- Schema upgrade from 4.15.1.0 to 4.16.0.0\n --;\n \n+ALTER TABLE `cloud`.`user_vm` ADD COLUMN `user_vm_type` varchar(255) DEFAULT \"UserVM\" COMMENT 'Defines the type of UserVM';", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0MzMyOA=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDEwNzI0OnYy", "diffSide": "RIGHT", "path": "engine/schema/src/main/resources/META-INF/db/schema-41510to41600.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo0MjoxMFrOKWdrjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo0MjoxMFrOKWdrjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0MzU5OA==", "bodyText": "@Pearl1594 does this actually work now?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694643598", "createdAt": "2021-08-24T08:42:10Z", "author": {"login": "rhtyd"}, "path": "engine/schema/src/main/resources/META-INF/db/schema-41510to41600.sql", "diffHunk": "@@ -19,6 +19,19 @@\n -- Schema upgrade from 4.15.1.0 to 4.16.0.0\n --;\n \n+ALTER TABLE `cloud`.`user_vm` ADD COLUMN `user_vm_type` varchar(255) DEFAULT \"UserVM\" COMMENT 'Defines the type of UserVM';\n+\n+-- This is set, so as to ensure that the controller details from the ovf template are adhered to\n+UPDATE `cloud`.`vm_template` set deploy_as_is = 1 where id = 8;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDExNjUzOnYy", "diffSide": "RIGHT", "path": "engine/schema/templateConfig.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo0NDowNlrOKWdxIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo0NDowNlrOKWdxIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0NTAyNQ==", "bodyText": "remove extra newline", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694645025", "createdAt": "2021-08-24T08:44:06Z", "author": {"login": "rhtyd"}, "path": "engine/schema/templateConfig.sh", "diffHunk": "@@ -0,0 +1,84 @@\n+#!/bin/bash\n+\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+function getTemplateVersion() {\n+  projVersion=$1\n+  version=\"$(cut -d'-' -f1 <<<\"$projVersion\")\"\n+  subversion1=\"$(cut -d'.' -f1 <<<\"$version\")\"\n+  subversion2=\"$(cut -d'.' -f2 <<<\"$version\")\"\n+  minorversion=\"$(cut -d'.' -f3 <<<\"$version\")\"\n+  export CS_VERSION=\"${subversion1}\".\"${subversion2}\"\n+  export CS_MINOR_VERSION=\"${minorversion}\"\n+}\n+\n+function getGenericName() {\n+  hypervisor=$(echo \"$1\" | tr \"[:upper:]\" \"[:lower:]\")\n+  if [[ \"$hypervisor\" == \"ovm3\" ]]; then\n+    echo \"ovm\"\n+  elif [[ \"$hypervisor\" == \"lxc\" ]]; then\n+    echo \"kvm\"\n+  elif [[ \"$hypervisor\" == \"xenserver\" ]]; then\n+    echo \"xen\"\n+  else\n+    echo \"$hypervisor\"\n+  fi\n+}\n+\n+function getChecksum() {\n+  local fileData=\"$1\"\n+  local hvName=$2\n+  while IFS= read -r line; do\n+    if [[ $line == *\"$hvName\"* ]]; then\n+      echo \"$(cut -d' ' -f1 <<<\"$line\")\"\n+    fi\n+  done <<< \"$fileData\"\n+}\n+\n+function createMetadataFile() {\n+  local fileData=$(cat $SOURCEFILE)\n+  for i in \"${!templates[@]}\"\n+  do\n+    section=\"$i\"\n+    hvName=$(getGenericName $i)\n+    templatename=\"systemvm-${i}-${CS_VERSION}\"\n+    checksum=$(getChecksum \"$fileData\" $hvName)\n+    downloadurl=\"${templates[$i]}\"\n+    filename=$(echo ${downloadurl##*'/'})\n+    echo -e \"[\"$section\"]\\ntemplatename = $templatename\\nchecksum = $checksum\\ndownloadurl = $downloadurl\\nfilename = $filename\\n\" >> $METADATAFILE\n+  done\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDEyMDI4OnYy", "diffSide": "RIGHT", "path": "engine/schema/validate-checksum", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo0NDo1NlrOKWdzfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo0NDo1NlrOKWdzfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0NTYyOA==", "bodyText": "Use something like md5sum --check; or diff -Naur <file1> <file2>?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694645628", "createdAt": "2021-08-24T08:44:56Z", "author": {"login": "rhtyd"}, "path": "engine/schema/validate-checksum", "diffHunk": "@@ -0,0 +1,33 @@\n+#!/bin/bash\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+# \n+#   http://www.apache.org/licenses/LICENSE-2.0\n+# \n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+set -x\n+old_checksum_path=\"$HOME/.m2/repository/.cache/download-maven-plugin/\"\n+new_checksum_path=\"./dist/systemvm-templates/\"\n+file_name=\"md5sum.txt\"\n+\n+count=$(ls -d ${old_checksum_path}${file_name}* | wc -l)\n+if [ \"$count\" -gt 1 ]; then\n+  rm -rf $old_checksum_path*\n+else\n+  echo $PWD\n+  old_checksum=$(md5sum ${old_checksum_path}${file_name}* | awk '{print $1}')\n+  new_checksum=$(md5sum ${new_checksum_path}${file_name} | awk '{print $1}')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDEyMTM2OnYy", "diffSide": "RIGHT", "path": "packaging/centos7/cloud.spec", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo0NTowNVrOKWd0QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo0NTowNVrOKWd0QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0NTgyNA==", "bodyText": "Remove extra newline", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694645824", "createdAt": "2021-08-24T08:45:05Z", "author": {"login": "rhtyd"}, "path": "packaging/centos7/cloud.spec", "diffHunk": "@@ -298,6 +298,12 @@ install -D server/target/conf/cloudstack-sudoers ${RPM_BUILD_ROOT}%{_sysconfdir}\n touch ${RPM_BUILD_ROOT}%{_localstatedir}/run/%{name}-management.pid\n #install -D server/target/conf/cloudstack-catalina.logrotate ${RPM_BUILD_ROOT}%{_sysconfdir}/logrotate.d/%{name}-catalina\n \n+# SystemVM template\n+mkdir -p ${RPM_BUILD_ROOT}%{_datadir}/%{name}-management/templates/\n+cp -r engine/schema/dist/systemvm-templates/* ${RPM_BUILD_ROOT}%{_datadir}/%{name}-management/templates/\n+rm -rf ${RPM_BUILD_ROOT}%{_datadir}/%{name}-management/templates/md5sum.txt\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDE0MDgyOnYy", "diffSide": "RIGHT", "path": "plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/resource/wrapper/LibvirtStartCommandWrapper.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo0NzowM1rOKWd-_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNlQwNDozNToxN1rOKYBrig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0ODU3NQ==", "bodyText": "Question - are we using cmdline to pass params/args to CKS node? Why not have some logic in systemvmtemplate to fire-up dhcp services, and get params consumed from VR's user-data or config drive?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694648575", "createdAt": "2021-08-24T08:47:03Z", "author": {"login": "rhtyd"}, "path": "plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/resource/wrapper/LibvirtStartCommandWrapper.java", "diffHunk": "@@ -88,14 +89,7 @@ public Answer execute(final StartCommand command, final LibvirtComputingResource\n             libvirtComputingResource.applyDefaultNetworkRules(conn, vmSpec, false);\n \n             // pass cmdline info to system vms\n-            if (vmSpec.getType() != VirtualMachine.Type.User) {\n-                String controlIp = null;\n-                for (final NicTO nic : vmSpec.getNics()) {\n-                    if (nic.getType() == TrafficType.Control) {\n-                        controlIp = nic.getIp();\n-                        break;\n-                    }\n-                }\n+            if (vmSpec.getType() != VirtualMachine.Type.User || (vmSpec.getBootArgs() != null && vmSpec.getBootArgs().contains(UserVmManager.CKS_NODE))) {\n                 // try to patch and SSH into the systemvm for up to 5 minutes\n                 for (int count = 0; count < 10; count++) {\n                     // wait and try passCmdLine for 30 seconds at most for CLOUDSTACK-2823", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0OTY5Mw==", "bodyText": "I think the user-consumed templates shouldn't be allowed to use the systemvm's patching (cmdline specifically). Btw, if we're going with the tradeoff of using same patching mechanism as systemvms, then do we now allow users to ssh to CKS nodes?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694649693", "createdAt": "2021-08-24T08:48:04Z", "author": {"login": "rhtyd"}, "path": "plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/resource/wrapper/LibvirtStartCommandWrapper.java", "diffHunk": "@@ -88,14 +89,7 @@ public Answer execute(final StartCommand command, final LibvirtComputingResource\n             libvirtComputingResource.applyDefaultNetworkRules(conn, vmSpec, false);\n \n             // pass cmdline info to system vms\n-            if (vmSpec.getType() != VirtualMachine.Type.User) {\n-                String controlIp = null;\n-                for (final NicTO nic : vmSpec.getNics()) {\n-                    if (nic.getType() == TrafficType.Control) {\n-                        controlIp = nic.getIp();\n-                        break;\n-                    }\n-                }\n+            if (vmSpec.getType() != VirtualMachine.Type.User || (vmSpec.getBootArgs() != null && vmSpec.getBootArgs().contains(UserVmManager.CKS_NODE))) {\n                 // try to patch and SSH into the systemvm for up to 5 minutes\n                 for (int count = 0; count < 10; count++) {\n                     // wait and try passCmdLine for 30 seconds at most for CLOUDSTACK-2823", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0ODU3NQ=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjI4MTk5NA==", "bodyText": "Currently, yes, we pass the cmdline args to CKS nodes as we do with systemVMs - and this has been restricted to other userVMs", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r696281994", "createdAt": "2021-08-26T04:35:17Z", "author": {"login": "Pearl1594"}, "path": "plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/resource/wrapper/LibvirtStartCommandWrapper.java", "diffHunk": "@@ -88,14 +89,7 @@ public Answer execute(final StartCommand command, final LibvirtComputingResource\n             libvirtComputingResource.applyDefaultNetworkRules(conn, vmSpec, false);\n \n             // pass cmdline info to system vms\n-            if (vmSpec.getType() != VirtualMachine.Type.User) {\n-                String controlIp = null;\n-                for (final NicTO nic : vmSpec.getNics()) {\n-                    if (nic.getType() == TrafficType.Control) {\n-                        controlIp = nic.getIp();\n-                        break;\n-                    }\n-                }\n+            if (vmSpec.getType() != VirtualMachine.Type.User || (vmSpec.getBootArgs() != null && vmSpec.getBootArgs().contains(UserVmManager.CKS_NODE))) {\n                 // try to patch and SSH into the systemvm for up to 5 minutes\n                 for (int count = 0; count < 10; count++) {\n                     // wait and try passCmdLine for 30 seconds at most for CLOUDSTACK-2823", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0ODU3NQ=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDE1MjE3OnYy", "diffSide": "RIGHT", "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo0ODo1MlrOKWeFpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo0ODo1MlrOKWeFpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1MDI3Nw==", "bodyText": "Nit - Use Files.separator to create the path? Could user.home be not available or defined?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694650277", "createdAt": "2021-08-24T08:48:52Z", "author": {"login": "rhtyd"}, "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "diffHunk": "@@ -425,8 +423,8 @@\n \n     protected static File s_systemVmKeyFile = null;\n     private static final Object s_syncLockObjectFetchKeyFile = new Object();\n-    protected static final String s_relativePathSystemVmKeyFileInstallDir = \"scripts/vm/systemvm/id_rsa.cloud\";\n-    protected static final String s_defaultPathSystemVmKeyFile = \"/usr/share/cloudstack-common/scripts/vm/systemvm/id_rsa.cloud\";\n+    private static final String homeDir = System.getProperty(\"user.home\");\n+    protected static final String s_defaultPathSystemVmKeyFile =  homeDir + \"/.ssh/id_rsa\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDE1OTA4OnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1MDoxMlrOKWeJ5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1MDoxMlrOKWeJ5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1MTM2NQ==", "bodyText": "good method name; LoadBalancerRuleForAPIAccessForControlNodeVMs", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694651365", "createdAt": "2021-08-24T08:50:12Z", "author": {"login": "DaanHoogland"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "diffHunk": "@@ -385,39 +385,45 @@ private void setupKubernetesClusterNetworkRules(Network network, List<UserVm> cl\n                 network.getName(), kubernetesCluster.getName()));\n         }\n \n+        createFirewallRules(publicIp, clusterVMIds);\n+\n+        // Load balancer rule fo API access for control node VMs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDE2MjIwOnYy", "diffSide": "LEFT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1MDo0OFrOKWeLwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1MDo0OFrOKWeLwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1MTg0Mg==", "bodyText": "Suggestion - maybe we want to revisit this? We may want to by default require CKS to use systemvmtemplates, but do we want to allow admin/operator/user to bring their own templates? If yes than in future phases, we want to revisit these settings or similar. (for example the create CKS cluster can allow selection of template?) cc @shwstppr @davidjumani", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694651842", "createdAt": "2021-08-24T08:50:48Z", "author": {"login": "rhtyd"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterService.java", "diffHunk": "@@ -41,26 +41,6 @@\n             \"false\",\n             \"Indicates whether Kubernetes Service plugin is enabled or not. Management server restart needed on change\",\n             false);\n-    static final ConfigKey<String> KubernetesClusterHyperVTemplateName = new ConfigKey<String>(\"Advanced\", String.class,\n-            \"cloud.kubernetes.cluster.template.name.hyperv\",\n-            \"Kubernetes-Service-Template-HyperV\",\n-            \"Name of the template to be used for creating Kubernetes cluster nodes on HyperV\",\n-            true);\n-    static final ConfigKey<String> KubernetesClusterKVMTemplateName = new ConfigKey<String>(\"Advanced\", String.class,\n-            \"cloud.kubernetes.cluster.template.name.kvm\",\n-            \"Kubernetes-Service-Template-KVM\",\n-            \"Name of the template to be used for creating Kubernetes cluster nodes on KVM\",\n-            true);\n-    static final ConfigKey<String> KubernetesClusterVMwareTemplateName = new ConfigKey<String>(\"Advanced\", String.class,\n-            \"cloud.kubernetes.cluster.template.name.vmware\",\n-            \"Kubernetes-Service-Template-VMware\",\n-            \"Name of the template to be used for creating Kubernetes cluster nodes on VMware\",\n-            true);\n-    static final ConfigKey<String> KubernetesClusterXenserverTemplateName = new ConfigKey<String>(\"Advanced\", String.class,\n-            \"cloud.kubernetes.cluster.template.name.xenserver\",\n-            \"Kubernetes-Service-Template-Xenserver\",\n-            \"Name of the template to be used for creating Kubernetes cluster nodes on Xenserver\",\n-            true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDE2NDMzOnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1MToxNVrOKWeNBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1MToxNVrOKWeNBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1MjE2Ng==", "bodyText": "love this one as well: PortForwardingRuleForSSHAccessOnEachNodeVM", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694652166", "createdAt": "2021-08-24T08:51:15Z", "author": {"login": "DaanHoogland"}, "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "diffHunk": "@@ -385,39 +385,45 @@ private void setupKubernetesClusterNetworkRules(Network network, List<UserVm> cl\n                 network.getName(), kubernetesCluster.getName()));\n         }\n \n+        createFirewallRules(publicIp, clusterVMIds);\n+\n+        // Load balancer rule fo API access for control node VMs\n+        try {\n+            provisionLoadBalancerRule(publicIp, network, owner, clusterVMIds, CLUSTER_API_PORT);\n+        } catch (NetworkRuleConflictException | InsufficientAddressCapacityException e) {\n+            throw new ManagementServerException(String.format(\"Failed to provision load balancer rule for API access for the Kubernetes cluster : %s\", kubernetesCluster.getName()), e);\n+        }\n+\n+        // Port forwarding rule fo SSH access on each node VM", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDE3MjU2OnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/resources/conf/k8s-control-node-add.yml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1Mjo1MVrOKWeR4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwOToxNToyOVrOKY-6GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1MzQwOQ==", "bodyText": "@Pearl1594 username is something else? (or it won't matter?)", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694653409", "createdAt": "2021-08-24T08:52:51Z", "author": {"login": "rhtyd"}, "path": "plugins/integrations/kubernetes-service/src/main/resources/conf/k8s-control-node-add.yml", "diffHunk": "@@ -17,12 +17,16 @@\n # under the License.\n \n ---\n-ssh_authorized_keys:\n-  {{ k8s.ssh.pub.key }}\n-\n-write-files:\n+users:\n+  - name: core", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwNTk1Ng==", "bodyText": "core is the username used in coreOS templates, hence the same user is created for backward compatibility", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695805956", "createdAt": "2021-08-25T14:24:05Z", "author": {"login": "Pearl1594"}, "path": "plugins/integrations/kubernetes-service/src/main/resources/conf/k8s-control-node-add.yml", "diffHunk": "@@ -17,12 +17,16 @@\n # under the License.\n \n ---\n-ssh_authorized_keys:\n-  {{ k8s.ssh.pub.key }}\n-\n-write-files:\n+users:\n+  - name: core", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1MzQwOQ=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI4NTE0NA==", "bodyText": "Suggestion - let's do a clean break, CoreOS isn't supported; we can mention in docs how users should upgrade.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697285144", "createdAt": "2021-08-27T09:15:29Z", "author": {"login": "rhtyd"}, "path": "plugins/integrations/kubernetes-service/src/main/resources/conf/k8s-control-node-add.yml", "diffHunk": "@@ -17,12 +17,16 @@\n # under the License.\n \n ---\n-ssh_authorized_keys:\n-  {{ k8s.ssh.pub.key }}\n-\n-write-files:\n+users:\n+  - name: core", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1MzQwOQ=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDE3NDgzOnYy", "diffSide": "RIGHT", "path": "plugins/integrations/kubernetes-service/src/main/resources/conf/k8s-control-node.yml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1MzoxOFrOKWeTQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoyNDoyNVrOKXkpOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1Mzc2MA==", "bodyText": "Nit - user name is cloud in systemvmtemplate?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694653760", "createdAt": "2021-08-24T08:53:18Z", "author": {"login": "rhtyd"}, "path": "plugins/integrations/kubernetes-service/src/main/resources/conf/k8s-control-node.yml", "diffHunk": "@@ -17,10 +17,14 @@\n # under the License.\n \n ---\n-ssh_authorized_keys:\n-  {{ k8s.ssh.pub.key }}\n-\n-write-files:\n+users:\n+  - name: core", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwNjI2Nw==", "bodyText": "as mentioned above", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695806267", "createdAt": "2021-08-25T14:24:25Z", "author": {"login": "Pearl1594"}, "path": "plugins/integrations/kubernetes-service/src/main/resources/conf/k8s-control-node.yml", "diffHunk": "@@ -17,10 +17,14 @@\n # under the License.\n \n ---\n-ssh_authorized_keys:\n-  {{ k8s.ssh.pub.key }}\n-\n-write-files:\n+users:\n+  - name: core", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1Mzc2MA=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDE4MDQ2OnYy", "diffSide": "LEFT", "path": "scripts/vm/hypervisor/kvm/patch.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1NDoyNFrOKWeWww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1NDoyNFrOKWeWww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1NDY1OQ==", "bodyText": "+1 I wish we can get rid of this whole patching script one day too!", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694654659", "createdAt": "2021-08-24T08:54:24Z", "author": {"login": "rhtyd"}, "path": "scripts/vm/hypervisor/kvm/patch.sh", "diffHunk": "@@ -70,11 +71,5 @@ do\n     sleep 0.1\n done\n \n-# Write ssh public key\n-send_file $name \"/root/.ssh/authorized_keys\" $sshkey", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDE4NjI4OnYy", "diffSide": "RIGHT", "path": "scripts/vm/systemvm/injectkeys.sh", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1NTozNFrOKWeaiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoyNDo1OFrOKXkrTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1NTYyNA==", "bodyText": "@Pearl1594 you may want to check and remove some code specific to VMware that requires/calls this in a global lock (didn't check code, unless it's already fixed down somewhere).", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694655624", "createdAt": "2021-08-24T08:55:34Z", "author": {"login": "rhtyd"}, "path": "scripts/vm/systemvm/injectkeys.sh", "diffHunk": "@@ -18,8 +18,7 @@\n \n \n # Copies keys that enable SSH communication with system vms\n-# $1 = new public key\n-# $2 = new private key\n+# $1 = new private key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwNjc5Ng==", "bodyText": "I didn't get what you meant @rhtyd", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695806796", "createdAt": "2021-08-25T14:24:58Z", "author": {"login": "Pearl1594"}, "path": "scripts/vm/systemvm/injectkeys.sh", "diffHunk": "@@ -18,8 +18,7 @@\n \n \n # Copies keys that enable SSH communication with system vms\n-# $1 = new public key\n-# $2 = new private key\n+# $1 = new private key", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1NTYyNA=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDE5MTgzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/network/router/VirtualNetworkApplianceManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1Njo0NFrOKWed2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1Njo0NFrOKWed2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1NjQ3NA==", "bodyText": "Does it make sense to move this logic/code as a utility? I see at least 4-5 usage already across systemvms?\n(or better save the base64 encoded string somewhere and simply call use the DB/VO/ConfigKey?)", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694656474", "createdAt": "2021-08-24T08:56:44Z", "author": {"login": "rhtyd"}, "path": "server/src/main/java/com/cloud/network/router/VirtualNetworkApplianceManagerImpl.java", "diffHunk": "@@ -1939,6 +1941,13 @@ public boolean finalizeVirtualMachineProfile(final VirtualMachineProfile profile\n         if (Boolean.valueOf(_configDao.getValue(\"system.vm.random.password\"))) {\n             buf.append(\" vmpassword=\").append(_configDao.getValue(\"system.vm.password\"));\n         }\n+        String MsPublicKey = _configDao.getValue(\"ssh.publickey\");\n+        String base64EncodedPublicKey = null;\n+        if (MsPublicKey != null) {\n+            base64EncodedPublicKey = Base64.getEncoder().encodeToString(MsPublicKey.getBytes(StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDE5NjI3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/storage/StorageManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1NzozM1rOKWegWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoyNTo0N1rOKXkudg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1NzExNA==", "bodyText": "Isn't LXC same as KVM or there is a different global setting?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694657114", "createdAt": "2021-08-24T08:57:33Z", "author": {"login": "rhtyd"}, "path": "server/src/main/java/com/cloud/storage/StorageManagerImpl.java", "diffHunk": "@@ -2638,6 +2643,29 @@ public String getName() {\n         return null;\n     }\n \n+    private String getValidTemplateName(Long zoneId, HypervisorType hType) {\n+        String templateName = null;\n+        switch (hType) {\n+            case XenServer:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateXen.valueIn(zoneId);\n+                break;\n+            case KVM:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateKvm.valueIn(zoneId);\n+                break;\n+            case VMware:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateVmware.valueIn(zoneId);\n+                break;\n+            case Hyperv:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateHyperV.valueIn(zoneId);\n+                break;\n+            case LXC:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateLxc.valueIn(zoneId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwNzYwNg==", "bodyText": "There is different global setting for LXC's template name", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695807606", "createdAt": "2021-08-25T14:25:47Z", "author": {"login": "Pearl1594"}, "path": "server/src/main/java/com/cloud/storage/StorageManagerImpl.java", "diffHunk": "@@ -2638,6 +2643,29 @@ public String getName() {\n         return null;\n     }\n \n+    private String getValidTemplateName(Long zoneId, HypervisorType hType) {\n+        String templateName = null;\n+        switch (hType) {\n+            case XenServer:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateXen.valueIn(zoneId);\n+                break;\n+            case KVM:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateKvm.valueIn(zoneId);\n+                break;\n+            case VMware:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateVmware.valueIn(zoneId);\n+                break;\n+            case Hyperv:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateHyperV.valueIn(zoneId);\n+                break;\n+            case LXC:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateLxc.valueIn(zoneId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1NzExNA=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDIwMDMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/storage/StorageManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1ODoyN1rOKWei9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1ODoyN1rOKWei9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1Nzc4MQ==", "bodyText": "Do it like: NFS_IMAGE.equals(providerName) - this style of comparing is more defensive in case providerName is null.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694657781", "createdAt": "2021-08-24T08:58:27Z", "author": {"login": "rhtyd"}, "path": "server/src/main/java/com/cloud/storage/StorageManagerImpl.java", "diffHunk": "@@ -2722,6 +2750,52 @@ public ImageStore discoverImageStore(String name, String url, String providerNam\n             // populate template_store_ref table\n             _imageSrv.addSystemVMTemplatesToSecondary(store);\n             _imageSrv.handleTemplateSync(store);\n+            if (providerName.equals(DataStoreProvider.NFS_IMAGE) && zoneId != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDIwNDczOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwODo1OToyN1rOKWel0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoyNzowNlrOKXkzVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1ODUxMg==", "bodyText": "See comment in upgrade path, this is not necessary a  type param already exists.", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694658512", "createdAt": "2021-08-24T08:59:27Z", "author": {"login": "rhtyd"}, "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "diffHunk": "@@ -4179,6 +4179,7 @@ public UserVmVO doInTransaction(TransactionStatus status) throws InsufficientCap\n                     }\n                 }\n \n+                vm.setUserVmType(type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwODg1Mw==", "bodyText": "cks nodes are at the end of the day UserVMs - hence, CKSNode userVM type is to further categorize the user vm", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695808853", "createdAt": "2021-08-25T14:27:06Z", "author": {"login": "Pearl1594"}, "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "diffHunk": "@@ -4179,6 +4179,7 @@ public UserVmVO doInTransaction(TransactionStatus status) throws InsufficientCap\n                     }\n                 }\n \n+                vm.setUserVmType(type);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1ODUxMg=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDIxMDA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwOTowMDozMFrOKWepEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoyNzoxNFrOKXkz0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1OTM0Nw==", "bodyText": "Suggestion - we should revisit the initialisation/setup code, otherwise we hardcode/tie exclusively with systemvmtemplate (if not now then in phase2/future)", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694659347", "createdAt": "2021-08-24T09:00:30Z", "author": {"login": "rhtyd"}, "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "diffHunk": "@@ -4603,12 +4604,54 @@ private UserVm startVirtualMachine(long vmId, Long podId, Long clusterId, Long h\n         return vm;\n     }\n \n+    private void addUserVMCmdlineArgs(Long vmId, VirtualMachineProfile profile, DeployDestination dest, StringBuilder buf) {\n+        UserVmVO k8sVM = _vmDao.findById(vmId);\n+        buf.append(\" template=domP\");\n+        buf.append(\" name=\").append(profile.getHostName());\n+        buf.append(\" type=\").append(k8sVM.getUserVmType());\n+        for (NicProfile nic : profile.getNics()) {\n+            int deviceId = nic.getDeviceId();\n+            if (nic.getIPv4Address() == null) {\n+                buf.append(\" eth\").append(deviceId).append(\"ip=\").append(\"0.0.0.0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwODk3Nw==", "bodyText": "+1", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695808977", "createdAt": "2021-08-25T14:27:14Z", "author": {"login": "Pearl1594"}, "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "diffHunk": "@@ -4603,12 +4604,54 @@ private UserVm startVirtualMachine(long vmId, Long podId, Long clusterId, Long h\n         return vm;\n     }\n \n+    private void addUserVMCmdlineArgs(Long vmId, VirtualMachineProfile profile, DeployDestination dest, StringBuilder buf) {\n+        UserVmVO k8sVM = _vmDao.findById(vmId);\n+        buf.append(\" template=domP\");\n+        buf.append(\" name=\").append(profile.getHostName());\n+        buf.append(\" type=\").append(k8sVM.getUserVmType());\n+        for (NicProfile nic : profile.getNics()) {\n+            int deviceId = nic.getDeviceId();\n+            if (nic.getIPv4Address() == null) {\n+                buf.append(\" eth\").append(deviceId).append(\"ip=\").append(\"0.0.0.0\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1OTM0Nw=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDIxMTYxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/cloudstack/diagnostics/DiagnosticsServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwOTowMDo1MFrOKWeqGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwOToxNzozMVrOKY-_Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1OTYwOA==", "bodyText": "Use Files to create path?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694659608", "createdAt": "2021-08-24T09:00:50Z", "author": {"login": "rhtyd"}, "path": "server/src/main/java/org/apache/cloudstack/diagnostics/DiagnosticsServiceImpl.java", "diffHunk": "@@ -341,7 +341,8 @@ private Answer deleteDiagnosticsZipFileInsystemVm(VMInstanceVO vmInstance, Strin\n             boolean existsInSecondaryStore = dataDirectory.exists() || dataDirectory.mkdir();\n             if (existsInSecondaryStore) {\n                 // scp from system VM to mounted sec storage directory\n-                File permKey = new File(\"/var/cloudstack/management/.ssh/id_rsa\");\n+                String homeDir = System.getProperty(\"user.home\");\n+                File permKey = new File(homeDir + \"/.ssh/id_rsa\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI4NjQ0Ng==", "bodyText": "Tests advised - run diagnostic tests across all supported distros", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697286446", "createdAt": "2021-08-27T09:17:31Z", "author": {"login": "rhtyd"}, "path": "server/src/main/java/org/apache/cloudstack/diagnostics/DiagnosticsServiceImpl.java", "diffHunk": "@@ -341,7 +341,8 @@ private Answer deleteDiagnosticsZipFileInsystemVm(VMInstanceVO vmInstance, Strin\n             boolean existsInSecondaryStore = dataDirectory.exists() || dataDirectory.mkdir();\n             if (existsInSecondaryStore) {\n                 // scp from system VM to mounted sec storage directory\n-                File permKey = new File(\"/var/cloudstack/management/.ssh/id_rsa\");\n+                String homeDir = System.getProperty(\"user.home\");\n+                File permKey = new File(homeDir + \"/.ssh/id_rsa\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1OTYwOA=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDM0ODc2OnYy", "diffSide": "RIGHT", "path": "systemvm/debian/opt/cloud/bin/setup/cksnode.sh", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwOToyOTowMlrOKWf9Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoyODowNVrOKXk3TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY4MDg3OQ==", "bodyText": "Suggestion - if we were to explore default option (i.e. cks nodes not patched like systemvms), then cloud.init should start, CKS nodes should get IP etc from VR, get the user-data which runs these commands (via cloud-init)", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694680879", "createdAt": "2021-08-24T09:29:02Z", "author": {"login": "rhtyd"}, "path": "systemvm/debian/opt/cloud/bin/setup/cksnode.sh", "diffHunk": "@@ -0,0 +1,76 @@\n+#!/bin/bash\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+. /opt/cloud/bin/setup/common.sh\n+\n+setup_k8s_node() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwOTg2OA==", "bodyText": "something to work-out as part of the next phase", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695809868", "createdAt": "2021-08-25T14:28:05Z", "author": {"login": "Pearl1594"}, "path": "systemvm/debian/opt/cloud/bin/setup/cksnode.sh", "diffHunk": "@@ -0,0 +1,76 @@\n+#!/bin/bash\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+. /opt/cloud/bin/setup/common.sh\n+\n+setup_k8s_node() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY4MDg3OQ=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDM1MTM3OnYy", "diffSide": "RIGHT", "path": "systemvm/debian/opt/cloud/bin/setup/cloud-early-config", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwOToyOTozNFrOKWf-uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwOToyOTozNFrOKWf-uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY4MTI3NQ==", "bodyText": "Use the $(cmd here) format, more easy to read than the `", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694681275", "createdAt": "2021-08-24T09:29:34Z", "author": {"login": "rhtyd"}, "path": "systemvm/debian/opt/cloud/bin/setup/cloud-early-config", "diffHunk": "@@ -89,6 +88,14 @@ start() {\n   rm -f /root/.rnd\n   echo \"\" > /root/.ssh/known_hosts\n \n+  if which growpart > /dev/null; then\n+    ROOT_MOUNT_POINT=`df -h / | tail -n 1  | cut -d' ' -f1`\n+    ROOT_DISK=`echo $ROOT_MOUNT_POINT | sed 's/[0-9]*$//g'`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDM1Nzc1OnYy", "diffSide": "RIGHT", "path": "tools/appliance/systemvmtemplate/http/preseed.cfg", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwOTozMDo1MFrOKWgCdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwOTozMDo1MFrOKWgCdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY4MjIyOA==", "bodyText": "Check the resultant size of swap space - if it's more than 256MB?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694682228", "createdAt": "2021-08-24T09:30:50Z", "author": {"login": "rhtyd"}, "path": "tools/appliance/systemvmtemplate/http/preseed.cfg", "diffHunk": "@@ -66,13 +66,13 @@ d-i partman-auto/expert_recipe string                         \\\n                       use_filesystem{ } filesystem{ ext2 }    \\\n                       mountpoint{ /boot }                     \\\n               .                                               \\\n+              256 1000 256 linux-swap                         \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDM1ODk4OnYy", "diffSide": "LEFT", "path": "tools/appliance/systemvmtemplate/scripts/configure_conntrack.sh", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwOTozMTowNFrOKWgDMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoyODoyMFrOKXk4Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY4MjQxNg==", "bodyText": "@Pearl1594 any reason to remove these?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694682416", "createdAt": "2021-08-24T09:31:04Z", "author": {"login": "rhtyd"}, "path": "tools/appliance/systemvmtemplate/scripts/configure_conntrack.sh", "diffHunk": "@@ -34,8 +34,6 @@ function load_conntrack_modules() {\n   grep nf_conntrack_ipv4 /etc/modules && return\n \n   cat >> /etc/modules << EOF\n-nf_conntrack_ipv4\n-nf_conntrack_ipv6", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgxMDEzOQ==", "bodyText": "there is only an nf_conntrack module, it is because of these unknown modules that we see an error during systemvm bootup", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695810139", "createdAt": "2021-08-25T14:28:20Z", "author": {"login": "Pearl1594"}, "path": "tools/appliance/systemvmtemplate/scripts/configure_conntrack.sh", "diffHunk": "@@ -34,8 +34,6 @@ function load_conntrack_modules() {\n   grep nf_conntrack_ipv4 /etc/modules && return\n \n   cat >> /etc/modules << EOF\n-nf_conntrack_ipv4\n-nf_conntrack_ipv6", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY4MjQxNg=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDM2MjIyOnYy", "diffSide": "RIGHT", "path": "tools/appliance/systemvmtemplate/scripts/install_systemvm_packages.sh", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwOTozMTo0MlrOKWgFAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDoyODoyM1rOKXk4iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY4Mjg4MQ==", "bodyText": "maybe we don't need CLI? Or both docker-ce, we use ctrctl to import images? If not now - in future phase?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694682881", "createdAt": "2021-08-24T09:31:42Z", "author": {"login": "rhtyd"}, "path": "tools/appliance/systemvmtemplate/scripts/install_systemvm_packages.sh", "diffHunk": "@@ -69,23 +75,33 @@ function install_packages() {\n     radvd \\\n     sharutils genisoimage \\\n     strongswan libcharon-extra-plugins libstrongswan-extra-plugins strongswan-charon strongswan-starter \\\n-    virt-what open-vm-tools qemu-guest-agent hyperv-daemons\n+    virt-what open-vm-tools qemu-guest-agent hyperv-daemons cloud-guest-utils \\\n+    conntrack apt-transport-https ca-certificates curl gnupg  gnupg-agent software-properties-common\n+\n+  apt-get install -y python3-json-pointer python3-jsonschema cloud-init\n \n   # python2-netaddr workaround\n   wget https://github.com/shapeblue/cloudstack-nonoss/raw/main/python-netaddr_0.7.19-1_all.deb\n   dpkg -i python-netaddr_0.7.19-1_all.deb\n \n-  apt-get -y autoremove --purge\n-  apt-get clean\n-  apt-get autoclean\n+  apt_clean\n \n-  #32 bit architecture support for vhd-util: not required for 32 bit template\n+  # 32 bit architecture support for vhd-util\n   if [ \"${arch}\" != \"i386\" ]; then\n     dpkg --add-architecture i386\n     apt-get update\n     ${apt_get} install libuuid1:i386 libc6:i386\n   fi\n \n+  # Install docker and containerd for CKS\n+  curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n+  apt-key fingerprint 0EBFCD88\n+  add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable\"\n+  apt-get update\n+  ${apt_get} install docker-ce docker-ce-cli containerd.io", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgxMDE4NA==", "bodyText": "+1 - will work on it in the next phase", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695810184", "createdAt": "2021-08-25T14:28:23Z", "author": {"login": "Pearl1594"}, "path": "tools/appliance/systemvmtemplate/scripts/install_systemvm_packages.sh", "diffHunk": "@@ -69,23 +75,33 @@ function install_packages() {\n     radvd \\\n     sharutils genisoimage \\\n     strongswan libcharon-extra-plugins libstrongswan-extra-plugins strongswan-charon strongswan-starter \\\n-    virt-what open-vm-tools qemu-guest-agent hyperv-daemons\n+    virt-what open-vm-tools qemu-guest-agent hyperv-daemons cloud-guest-utils \\\n+    conntrack apt-transport-https ca-certificates curl gnupg  gnupg-agent software-properties-common\n+\n+  apt-get install -y python3-json-pointer python3-jsonschema cloud-init\n \n   # python2-netaddr workaround\n   wget https://github.com/shapeblue/cloudstack-nonoss/raw/main/python-netaddr_0.7.19-1_all.deb\n   dpkg -i python-netaddr_0.7.19-1_all.deb\n \n-  apt-get -y autoremove --purge\n-  apt-get clean\n-  apt-get autoclean\n+  apt_clean\n \n-  #32 bit architecture support for vhd-util: not required for 32 bit template\n+  # 32 bit architecture support for vhd-util\n   if [ \"${arch}\" != \"i386\" ]; then\n     dpkg --add-architecture i386\n     apt-get update\n     ${apt_get} install libuuid1:i386 libc6:i386\n   fi\n \n+  # Install docker and containerd for CKS\n+  curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n+  apt-key fingerprint 0EBFCD88\n+  add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable\"\n+  apt-get update\n+  ${apt_get} install docker-ce docker-ce-cli containerd.io", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY4Mjg4MQ=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDM2NTE5OnYy", "diffSide": "RIGHT", "path": "ui/src/components/view/ResourceView.vue", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwOTozMjoyNlrOKWgG5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yN1QwOToyNDo1MFrOKY_R4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY4MzM2Ng==", "bodyText": "Question - are these checks moved to tab?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694683366", "createdAt": "2021-08-24T09:32:26Z", "author": {"login": "rhtyd"}, "path": "ui/src/components/view/ResourceView.vue", "diffHunk": "@@ -135,27 +135,8 @@ export default {\n       this.$emit('onTabChange', key)\n     },\n     showTab (tab) {\n-      if ('networkServiceFilter' in tab) {\n-        if (this.resource && this.resource.virtualmachineid && !this.resource.vpcid && tab.name !== 'firewall') {\n-          return false\n-        }\n-        if (this.resource && this.resource.virtualmachineid && this.resource.vpcid) {\n-          return false\n-        }\n-        // dont display any option for source NAT IP of VPC\n-        if (this.resource && this.resource.vpcid && !this.resource.issourcenat && tab.name !== 'firewall') {\n-          return true\n-        }\n-        // display LB and PF options for isolated networks if static nat is disabled\n-        if (this.resource && !this.resource.vpcid) {\n-          if (!this.resource.isstaticnat) {\n-            return true\n-          } else if (tab.name === 'firewall') {\n-            return true\n-          }\n-        }\n-        return this.networkService && this.networkService.service &&\n-          tab.networkServiceFilter(this.networkService.service)\n+      if (this.networkService && this.networkService.service && tab.networkServiceFilter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI5MTIzMw==", "bodyText": "@davidjumani can you check?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697291233", "createdAt": "2021-08-27T09:24:50Z", "author": {"login": "rhtyd"}, "path": "ui/src/components/view/ResourceView.vue", "diffHunk": "@@ -135,27 +135,8 @@ export default {\n       this.$emit('onTabChange', key)\n     },\n     showTab (tab) {\n-      if ('networkServiceFilter' in tab) {\n-        if (this.resource && this.resource.virtualmachineid && !this.resource.vpcid && tab.name !== 'firewall') {\n-          return false\n-        }\n-        if (this.resource && this.resource.virtualmachineid && this.resource.vpcid) {\n-          return false\n-        }\n-        // dont display any option for source NAT IP of VPC\n-        if (this.resource && this.resource.vpcid && !this.resource.issourcenat && tab.name !== 'firewall') {\n-          return true\n-        }\n-        // display LB and PF options for isolated networks if static nat is disabled\n-        if (this.resource && !this.resource.vpcid) {\n-          if (!this.resource.isstaticnat) {\n-            return true\n-          } else if (tab.name === 'firewall') {\n-            return true\n-          }\n-        }\n-        return this.networkService && this.networkService.service &&\n-          tab.networkServiceFilter(this.networkService.service)\n+      if (this.networkService && this.networkService.service && tab.networkServiceFilter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY4MzM2Ng=="}, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQyNDM2OTg5OnYy", "diffSide": "RIGHT", "path": "ui/src/config/section/compute.js", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwOTozMzoyNlrOKWgJtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNFQwOTozMzoyNlrOKWgJtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY4NDA4Nw==", "bodyText": "nit - there is a global import on store, if we move to this format - should we remove that or refactor all usage per this new pattern?", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694684087", "createdAt": "2021-08-24T09:33:26Z", "author": {"login": "rhtyd"}, "path": "ui/src/config/section/compute.js", "diffHunk": "@@ -425,15 +425,18 @@ export default {\n       icon: kubernetes,\n       docHelp: 'plugins/cloudstack-kubernetes-service.html',\n       permission: ['listKubernetesClusters'],\n-      columns: () => {\n+      columns: (store) => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQzMTc3MzcyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/storage/StorageManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDozODoyMFrOKXle5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDozODoyMFrOKXle5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgyMDAwNQ==", "bodyText": "Can you extract this block", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695820005", "createdAt": "2021-08-25T14:38:20Z", "author": {"login": "DaanHoogland"}, "path": "server/src/main/java/com/cloud/storage/StorageManagerImpl.java", "diffHunk": "@@ -2722,6 +2750,46 @@ public ImageStore discoverImageStore(String name, String url, String providerNam\n             // populate template_store_ref table\n             _imageSrv.addSystemVMTemplatesToSecondary(store);\n             _imageSrv.handleTemplateSync(store);\n+            if (providerName.equals(DataStoreProvider.NFS_IMAGE) && zoneId != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDQzMTc4MjcyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/cloud/storage/VolumeApiServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDozOTo1MlrOKXlkhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0yNVQxNDozOTo1MlrOKXlkhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgyMTQ0Ng==", "bodyText": "this block is repeated ...", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695821446", "createdAt": "2021-08-25T14:39:52Z", "author": {"login": "DaanHoogland"}, "path": "server/src/main/java/com/cloud/storage/VolumeApiServiceImpl.java", "diffHunk": "@@ -2806,7 +2806,12 @@ public Snapshot allocSnapshot(Long volumeId, Long policyId, String snapshotName,\n \n         if (volume.getTemplateId() != null) {\n             VMTemplateVO template = _templateDao.findById(volume.getTemplateId());\n-            if (template != null && template.getTemplateType() == Storage.TemplateType.SYSTEM) {\n+            Long instanceId = volume.getInstanceId();\n+            UserVmVO userVmVO = null;\n+            if (instanceId != null) {\n+                userVmVO = _userVmDao.findById(instanceId);\n+            }\n+            if (template != null && template.getTemplateType() == Storage.TemplateType.SYSTEM && (userVmVO == null || !UserVmManager.CKS_NODE.equals(userVmVO.getUserVmType()))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac54a79faf191878fd30133c90609a699fc84874"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4175, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}