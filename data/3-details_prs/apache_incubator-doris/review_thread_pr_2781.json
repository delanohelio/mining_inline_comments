{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNjEyNjgw", "number": 2781, "reviewThreads": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMzo0NzoyOVrODYgfhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMzo1NjowOFrODeOGAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MDI0NzcyOnYy", "diffSide": "RIGHT", "path": "fe/src/main/cup/sql_parser.cup", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMzo0NzoyOVrOFeZ2Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzozODoyM1rOFe5L5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQyNTEwNg==", "bodyText": "How about cancel rollup with rollup name? not job id?", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367425106", "createdAt": "2020-01-16T13:47:29Z", "author": {"login": "morningman"}, "path": "fe/src/main/cup/sql_parser.cup", "diffHunk": "@@ -2276,14 +2328,24 @@ cancel_stmt ::=\n     :}\n     ;\n \n+cancel_rollup_job_id_list ::=", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3f01aae2aaf50f14f46b9ea2f675d314f4f2315"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg1MzAzMA==", "bodyText": "When user want to cancel job,he must first to execute \"show alter table rollup\" to get job info and find the job to be cancel,then use job info(jobid or rollup name) to cancel a job;\nIn my opinion,use rollup name isn't better than using jobid;In contrast, rollup name may be too long to cause alter sql too long.\nDo you have some good reason to use rollup name?", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367853030", "createdAt": "2020-01-17T09:56:29Z", "author": {"login": "wangbo"}, "path": "fe/src/main/cup/sql_parser.cup", "diffHunk": "@@ -2276,14 +2328,24 @@ cancel_stmt ::=\n     :}\n     ;\n \n+cancel_rollup_job_id_list ::=", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQyNTEwNg=="}, "originalCommit": {"oid": "f3f01aae2aaf50f14f46b9ea2f675d314f4f2315"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzODUzNQ==", "bodyText": "name is for people to read, id is for system to understand.\nSo we cancel the load job by where label=\"xxx\", not by\nid = 123;", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367938535", "createdAt": "2020-01-17T13:38:23Z", "author": {"login": "morningman"}, "path": "fe/src/main/cup/sql_parser.cup", "diffHunk": "@@ -2276,14 +2328,24 @@ cancel_stmt ::=\n     :}\n     ;\n \n+cancel_rollup_job_id_list ::=", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQyNTEwNg=="}, "originalCommit": {"oid": "f3f01aae2aaf50f14f46b9ea2f675d314f4f2315"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzQyMTIzOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/common/Config.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzowMjoxNlrOFe4UVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMjoxNjozOVrOFfKmqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyNDMxMQ==", "bodyText": "max_running_rollup_job_num_per_table ?", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367924311", "createdAt": "2020-01-17T13:02:16Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/common/Config.java", "diffHunk": "@@ -984,5 +984,11 @@\n      */\n     @ConfField(mutable = true, masterOnly = true)\n     public static boolean dynamic_partition_enable = false;\n+\n+    /*\n+     * control rollup job concurrent limit\n+     */\n+    @ConfField\n+    public static int max_running_rollup_job_num = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyMzkxNA==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r368223914", "createdAt": "2020-01-18T12:16:39Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/common/Config.java", "diffHunk": "@@ -984,5 +984,11 @@\n      */\n     @ConfField(mutable = true, masterOnly = true)\n     public static boolean dynamic_partition_enable = false;\n+\n+    /*\n+     * control rollup job concurrent limit\n+     */\n+    @ConfField\n+    public static int max_running_rollup_job_num = 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyNDMxMQ=="}, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzU1NjEwOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/analysis/CreateTableStmt.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzo1MzozMVrOFe5l7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMjoxNzoxOVrOFfKmxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NTE5OQ==", "bodyText": "What's meaning of ops?", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367945199", "createdAt": "2020-01-17T13:53:31Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/analysis/CreateTableStmt.java", "diffHunk": "@@ -74,6 +75,7 @@\n     private Map<String, String> extProperties;\n     private String engineName;\n     private String comment;\n+    private List<AlterClause> ops;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyMzk0Mw==", "bodyText": "or may be rollupOpts is better", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r368223943", "createdAt": "2020-01-18T12:17:19Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/analysis/CreateTableStmt.java", "diffHunk": "@@ -74,6 +75,7 @@\n     private Map<String, String> extProperties;\n     private String engineName;\n     private String comment;\n+    private List<AlterClause> ops;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NTE5OQ=="}, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzU2NTY3OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/analysis/CreateTableStmt.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzo1Njo0OFrOFe5rnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzo1Njo0OFrOFe5rnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NjY1Mg==", "bodyText": "After java8. prefer to Optional", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367946652", "createdAt": "2020-01-17T13:56:48Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/analysis/CreateTableStmt.java", "diffHunk": "@@ -150,6 +184,7 @@ public CreateTableStmt(boolean ifNotExists,\n         this.comment = Strings.nullToEmpty(comment);\n \n         this.tableSignature = -1;\n+        this.ops = ops == null ? new ArrayList<>() : ops;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzU3NTU3OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/analysis/CancelAlterTableStmt.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzo1OTo0NVrOFe5xQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMjoxNzozMFrOFfKmzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0ODA5Nw==", "bodyText": "could replace by CollectionUtils.isNotEmpty", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367948097", "createdAt": "2020-01-17T13:59:45Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/analysis/CancelAlterTableStmt.java", "diffHunk": "@@ -71,6 +85,11 @@ public String toSql() {\n         StringBuilder stringBuilder = new StringBuilder();\n         stringBuilder.append(\"CANCEL ALTER \" + this.alterType);\n         stringBuilder.append(\" FROM \" + dbTableName.toSql());\n+        if (alterJobIdList != null && alterJobIdList.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyMzk0OQ==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r368223949", "createdAt": "2020-01-18T12:17:30Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/analysis/CancelAlterTableStmt.java", "diffHunk": "@@ -71,6 +85,11 @@ public String toSql() {\n         StringBuilder stringBuilder = new StringBuilder();\n         stringBuilder.append(\"CANCEL ALTER \" + this.alterType);\n         stringBuilder.append(\" FROM \" + dbTableName.toSql());\n+        if (alterJobIdList != null && alterJobIdList.size() > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0ODA5Nw=="}, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzU4OTA2OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDowNDoyMFrOFe55XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMjoyMzo0NlrOFfKnww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1MDE3Mg==", "bodyText": "This comment confuse me.\nsort rollup index -> successfully create rollup index ?", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367950172", "createdAt": "2020-01-17T14:04:20Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -858,4 +1160,57 @@ public void cancel(CancelStmt stmt) throws DdlException {\n             jobDone(rollupJob);\n         }\n     }\n+\n+    // There may be dependency relation between user batch input rollup index\n+    // e.g, user input rollup index: r1 from r2,r2 from r3 ;the input order must be r3,r2,r1\n+    // sort rollup index for two reasons:\n+    // 1. successfully create rollup index", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 740}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyNDE5NQ==", "bodyText": "Actually, rollup index can't be created in catalog before its parent rollup created,so does rollup job runs;so we must first sort rollup index,then  create index work and run rollup job;\nI'll change the comment for better understand", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r368224195", "createdAt": "2020-01-18T12:23:46Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -858,4 +1160,57 @@ public void cancel(CancelStmt stmt) throws DdlException {\n             jobDone(rollupJob);\n         }\n     }\n+\n+    // There may be dependency relation between user batch input rollup index\n+    // e.g, user input rollup index: r1 from r2,r2 from r3 ;the input order must be r3,r2,r1\n+    // sort rollup index for two reasons:\n+    // 1. successfully create rollup index", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1MDE3Mg=="}, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 740}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzYwNzI1OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoxMDoyNlrOFe6Edw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwODo1Mjo0N1rOFfW_Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1MzAxNQ==", "bodyText": "For simple. I think we needn't introduce the Dependency concept. We could check the\nalter statement and require the from index must exist firstly, and then, we needn't consider the rollup job dependency.", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367953015", "createdAt": "2020-01-17T14:10:26Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -85,6 +90,71 @@ public MaterializedViewHandler() {\n         super(\"materialized view\");\n     }\n \n+\n+    // for batch submit rollup job, tableId -> jobId\n+    // keep table's not final state job size. The job size determine's table's state, = 0 means table is normal,otherwrise is rollup\n+    private Map<Long, Set<Long>> tableNotFinalStateJobMap = new ConcurrentHashMap<>();\n+    // keep table's running job,used for concurrency limit\n+    private Map<Long, Set<Long>> tableRunningJobMap = new ConcurrentHashMap<>();\n+    // make sure that job's dependency just init once\n+    private volatile boolean hasBuildJobDependency = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQyNjc3MA==", "bodyText": "No,Dependency is necessary;\nBecause int both parent job is cancel or parent is not final case, we all can't find parent index in catalog.Only 'parent index can be seen in catalog' can't decide whether current rollup job is  ready to run", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r368426770", "createdAt": "2020-01-20T08:52:47Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -85,6 +90,71 @@ public MaterializedViewHandler() {\n         super(\"materialized view\");\n     }\n \n+\n+    // for batch submit rollup job, tableId -> jobId\n+    // keep table's not final state job size. The job size determine's table's state, = 0 means table is normal,otherwrise is rollup\n+    private Map<Long, Set<Long>> tableNotFinalStateJobMap = new ConcurrentHashMap<>();\n+    // keep table's running job,used for concurrency limit\n+    private Map<Long, Set<Long>> tableRunningJobMap = new ConcurrentHashMap<>();\n+    // make sure that job's dependency just init once\n+    private volatile boolean hasBuildJobDependency = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1MzAxNQ=="}, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzYxMDI3OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoxMToyNFrOFe6GRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQwNToyNjoxOVrOFnTYGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1MzQ3Ng==", "bodyText": "It is weird to use a iterator here, maybe just  alterClauses.get(0) is enough? Or Iterables.getOnlyElement()?", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367953476", "createdAt": "2020-01-17T14:11:24Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -787,11 +1079,15 @@ private void getOldAlterJobInfos(Database db, List<List<Comparable>> rollupJobIn\n     @Override\n     public void process(List<AlterClause> alterClauses, String clusterName, Database db, OlapTable olapTable)\n             throws DdlException, AnalysisException {\n-        for (AlterClause alterClause : alterClauses) {\n+        alterClauses = sortRollupIndex(alterClauses);\n+\n+        Iterator<AlterClause> alterClauseIterator = alterClauses.iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 681}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NjI0OA==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376756248", "createdAt": "2020-02-09T05:26:19Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -787,11 +1079,15 @@ private void getOldAlterJobInfos(Database db, List<List<Comparable>> rollupJobIn\n     @Override\n     public void process(List<AlterClause> alterClauses, String clusterName, Database db, OlapTable olapTable)\n             throws DdlException, AnalysisException {\n-        for (AlterClause alterClause : alterClauses) {\n+        alterClauses = sortRollupIndex(alterClauses);\n+\n+        Iterator<AlterClause> alterClauseIterator = alterClauses.iterator();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1MzQ3Ng=="}, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 681}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzYxMzQxOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoxMjoxMVrOFe6ICw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMjozMDoxN1rOFfKo3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1MzkzMQ==", "bodyText": "only use one write lock is enough.", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367953931", "createdAt": "2020-01-17T14:12:11Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -590,15 +767,130 @@ protected void runAfterCatalogReady() {\n         runAlterJobV2();\n     }\n \n+    private synchronized Map<Long, AlterJobV2> getAlterJobsCopy () {\n+        return new HashMap<>(alterJobsV2);\n+    }\n+\n+    private void removeJobFromRunningQueue(RollupJobV2 rollupJobV2) {\n+        Set<Long> runningJobIdSet = tableRunningJobMap.get(rollupJobV2.getTableId());\n+        if (runningJobIdSet != null) {\n+            runningJobIdSet.remove(rollupJobV2.getJobId());\n+            if (runningJobIdSet.size() == 0) {\n+                tableRunningJobMap.remove(rollupJobV2.getTableId());\n+            }\n+        }\n+    }\n+\n+    private void changeTableStatus(long dbId, long tableId, OlapTableState olapTableState) {\n+        Database db = Catalog.getCurrentCatalog().getDb(dbId);\n+        db.readLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 531}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyNDQ3Ng==", "bodyText": "Write lock means lower concurrency than read lock;", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r368224476", "createdAt": "2020-01-18T12:30:17Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -590,15 +767,130 @@ protected void runAfterCatalogReady() {\n         runAlterJobV2();\n     }\n \n+    private synchronized Map<Long, AlterJobV2> getAlterJobsCopy () {\n+        return new HashMap<>(alterJobsV2);\n+    }\n+\n+    private void removeJobFromRunningQueue(RollupJobV2 rollupJobV2) {\n+        Set<Long> runningJobIdSet = tableRunningJobMap.get(rollupJobV2.getTableId());\n+        if (runningJobIdSet != null) {\n+            runningJobIdSet.remove(rollupJobV2.getJobId());\n+            if (runningJobIdSet.size() == 0) {\n+                tableRunningJobMap.remove(rollupJobV2.getTableId());\n+            }\n+        }\n+    }\n+\n+    private void changeTableStatus(long dbId, long tableId, OlapTableState olapTableState) {\n+        Database db = Catalog.getCurrentCatalog().getDb(dbId);\n+        db.readLock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1MzkzMQ=="}, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 531}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzYxODI3OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoxMzo0M1rOFe6LCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOTozODoyMVrOFkrMkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NDY5Ng==", "bodyText": "Would better add a comment to explain why concurrent rollup job for one table could work.", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367954696", "createdAt": "2020-01-17T14:13:43Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -590,15 +767,130 @@ protected void runAfterCatalogReady() {\n         runAlterJobV2();\n     }\n \n+    private synchronized Map<Long, AlterJobV2> getAlterJobsCopy () {\n+        return new HashMap<>(alterJobsV2);\n+    }\n+\n+    private void removeJobFromRunningQueue(RollupJobV2 rollupJobV2) {\n+        Set<Long> runningJobIdSet = tableRunningJobMap.get(rollupJobV2.getTableId());\n+        if (runningJobIdSet != null) {\n+            runningJobIdSet.remove(rollupJobV2.getJobId());\n+            if (runningJobIdSet.size() == 0) {\n+                tableRunningJobMap.remove(rollupJobV2.getTableId());\n+            }\n+        }\n+    }\n+\n+    private void changeTableStatus(long dbId, long tableId, OlapTableState olapTableState) {\n+        Database db = Catalog.getCurrentCatalog().getDb(dbId);\n+        db.readLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            if (tbl == null || tbl.getState() == olapTableState) {\n+                return;\n+            }\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        db.writeLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            tbl.setState(olapTableState);\n+        } finally {\n+            db.writeUnlock();\n+        }\n+    }\n+\n+    // replay the alter job v2\n+    public void replayAlterJobV2(AlterJobV2 alterJob) {\n+        super.replayAlterJobV2(alterJob);\n+        if (!alterJob.isDone()) {\n+            addAlterJobV2ToTableNotFinalStateJobMap(alterJob);\n+            changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.ROLLUP);\n+        } else {\n+            int ret = removeAlterJobV2FromTableNotFinalStateJobMap(alterJob);\n+            if (ret == 0) {\n+                changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.NORMAL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param rollupJobV2\n+     * @return\n+     *  true,parent job is finish or current job don't have parent job;\n+     *  false, parent job is cancelled or current job hasn't finished\n+     */\n+    private boolean checkRollupJobDependency(RollupJobV2 rollupJobV2) {\n+        RollupJobV2 parentJobV2 = (RollupJobV2) alterJobsV2.get(rollupJobV2.getParentRollupJobId());\n+        if (parentJobV2 != null) {\n+            // check whether current rollup job's parent rollup job is finished\n+            if (parentJobV2.getJobState() == AlterJobV2.JobState.CANCELLED) {\n+                rollupJobV2.cancel(String.format(\"rollup %s 's base rollup %s is cancelled\", rollupJobV2.getRollupIndexId(), rollupJobV2.getBaseIndexId()));\n+                return false;\n+            }\n+            if (parentJobV2.getJobState() != AlterJobV2.JobState.FINISHED) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void runAlterJobWithConcurrencyLimit(RollupJobV2 rollupJobV2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 586}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyNDUwNA==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r368224504", "createdAt": "2020-01-18T12:30:45Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -590,15 +767,130 @@ protected void runAfterCatalogReady() {\n         runAlterJobV2();\n     }\n \n+    private synchronized Map<Long, AlterJobV2> getAlterJobsCopy () {\n+        return new HashMap<>(alterJobsV2);\n+    }\n+\n+    private void removeJobFromRunningQueue(RollupJobV2 rollupJobV2) {\n+        Set<Long> runningJobIdSet = tableRunningJobMap.get(rollupJobV2.getTableId());\n+        if (runningJobIdSet != null) {\n+            runningJobIdSet.remove(rollupJobV2.getJobId());\n+            if (runningJobIdSet.size() == 0) {\n+                tableRunningJobMap.remove(rollupJobV2.getTableId());\n+            }\n+        }\n+    }\n+\n+    private void changeTableStatus(long dbId, long tableId, OlapTableState olapTableState) {\n+        Database db = Catalog.getCurrentCatalog().getDb(dbId);\n+        db.readLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            if (tbl == null || tbl.getState() == olapTableState) {\n+                return;\n+            }\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        db.writeLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            tbl.setState(olapTableState);\n+        } finally {\n+            db.writeUnlock();\n+        }\n+    }\n+\n+    // replay the alter job v2\n+    public void replayAlterJobV2(AlterJobV2 alterJob) {\n+        super.replayAlterJobV2(alterJob);\n+        if (!alterJob.isDone()) {\n+            addAlterJobV2ToTableNotFinalStateJobMap(alterJob);\n+            changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.ROLLUP);\n+        } else {\n+            int ret = removeAlterJobV2FromTableNotFinalStateJobMap(alterJob);\n+            if (ret == 0) {\n+                changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.NORMAL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param rollupJobV2\n+     * @return\n+     *  true,parent job is finish or current job don't have parent job;\n+     *  false, parent job is cancelled or current job hasn't finished\n+     */\n+    private boolean checkRollupJobDependency(RollupJobV2 rollupJobV2) {\n+        RollupJobV2 parentJobV2 = (RollupJobV2) alterJobsV2.get(rollupJobV2.getParentRollupJobId());\n+        if (parentJobV2 != null) {\n+            // check whether current rollup job's parent rollup job is finished\n+            if (parentJobV2.getJobState() == AlterJobV2.JobState.CANCELLED) {\n+                rollupJobV2.cancel(String.format(\"rollup %s 's base rollup %s is cancelled\", rollupJobV2.getRollupIndexId(), rollupJobV2.getBaseIndexId()));\n+                return false;\n+            }\n+            if (parentJobV2.getJobState() != AlterJobV2.JobState.FINISHED) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void runAlterJobWithConcurrencyLimit(RollupJobV2 rollupJobV2) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NDY5Ng=="}, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 586}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDAwMDc4Ng==", "bodyText": "Not update", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374000786", "createdAt": "2020-02-03T09:38:21Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -590,15 +767,130 @@ protected void runAfterCatalogReady() {\n         runAlterJobV2();\n     }\n \n+    private synchronized Map<Long, AlterJobV2> getAlterJobsCopy () {\n+        return new HashMap<>(alterJobsV2);\n+    }\n+\n+    private void removeJobFromRunningQueue(RollupJobV2 rollupJobV2) {\n+        Set<Long> runningJobIdSet = tableRunningJobMap.get(rollupJobV2.getTableId());\n+        if (runningJobIdSet != null) {\n+            runningJobIdSet.remove(rollupJobV2.getJobId());\n+            if (runningJobIdSet.size() == 0) {\n+                tableRunningJobMap.remove(rollupJobV2.getTableId());\n+            }\n+        }\n+    }\n+\n+    private void changeTableStatus(long dbId, long tableId, OlapTableState olapTableState) {\n+        Database db = Catalog.getCurrentCatalog().getDb(dbId);\n+        db.readLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            if (tbl == null || tbl.getState() == olapTableState) {\n+                return;\n+            }\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        db.writeLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            tbl.setState(olapTableState);\n+        } finally {\n+            db.writeUnlock();\n+        }\n+    }\n+\n+    // replay the alter job v2\n+    public void replayAlterJobV2(AlterJobV2 alterJob) {\n+        super.replayAlterJobV2(alterJob);\n+        if (!alterJob.isDone()) {\n+            addAlterJobV2ToTableNotFinalStateJobMap(alterJob);\n+            changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.ROLLUP);\n+        } else {\n+            int ret = removeAlterJobV2FromTableNotFinalStateJobMap(alterJob);\n+            if (ret == 0) {\n+                changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.NORMAL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param rollupJobV2\n+     * @return\n+     *  true,parent job is finish or current job don't have parent job;\n+     *  false, parent job is cancelled or current job hasn't finished\n+     */\n+    private boolean checkRollupJobDependency(RollupJobV2 rollupJobV2) {\n+        RollupJobV2 parentJobV2 = (RollupJobV2) alterJobsV2.get(rollupJobV2.getParentRollupJobId());\n+        if (parentJobV2 != null) {\n+            // check whether current rollup job's parent rollup job is finished\n+            if (parentJobV2.getJobState() == AlterJobV2.JobState.CANCELLED) {\n+                rollupJobV2.cancel(String.format(\"rollup %s 's base rollup %s is cancelled\", rollupJobV2.getRollupIndexId(), rollupJobV2.getBaseIndexId()));\n+                return false;\n+            }\n+            if (parentJobV2.getJobState() != AlterJobV2.JobState.FINISHED) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void runAlterJobWithConcurrencyLimit(RollupJobV2 rollupJobV2) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NDY5Ng=="}, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 586}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzYyMTIyOnYy", "diffSide": "RIGHT", "path": "fe/src/main/cup/sql_parser.cup", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoxNDozOVrOFe6MxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMjozMDoyOVrOFfKo4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NTE0MQ==", "bodyText": "Please update the user doc firstly.", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367955141", "createdAt": "2020-01-17T14:14:39Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/cup/sql_parser.cup", "diffHunk": "@@ -663,8 +665,54 @@ opt_user ::=\n     :}\n     ;\n \n+add_rollup_clause ::=", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyNDQ4MQ==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r368224481", "createdAt": "2020-01-18T12:30:29Z", "author": {"login": "wangbo"}, "path": "fe/src/main/cup/sql_parser.cup", "diffHunk": "@@ -663,8 +665,54 @@ opt_user ::=\n     :}\n     ;\n \n+add_rollup_clause ::=", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NTE0MQ=="}, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzY2MTMwOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoyNzoyMFrOFe6ljA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwODoyMjo1MVrOFfNt4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2MTQ4NA==", "bodyText": "I think there is no concurrent issue. you could directly use alterJobsV2.", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367961484", "createdAt": "2020-01-17T14:27:20Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -590,15 +767,130 @@ protected void runAfterCatalogReady() {\n         runAlterJobV2();\n     }\n \n+    private synchronized Map<Long, AlterJobV2> getAlterJobsCopy () {\n+        return new HashMap<>(alterJobsV2);\n+    }\n+\n+    private void removeJobFromRunningQueue(RollupJobV2 rollupJobV2) {\n+        Set<Long> runningJobIdSet = tableRunningJobMap.get(rollupJobV2.getTableId());\n+        if (runningJobIdSet != null) {\n+            runningJobIdSet.remove(rollupJobV2.getJobId());\n+            if (runningJobIdSet.size() == 0) {\n+                tableRunningJobMap.remove(rollupJobV2.getTableId());\n+            }\n+        }\n+    }\n+\n+    private void changeTableStatus(long dbId, long tableId, OlapTableState olapTableState) {\n+        Database db = Catalog.getCurrentCatalog().getDb(dbId);\n+        db.readLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            if (tbl == null || tbl.getState() == olapTableState) {\n+                return;\n+            }\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        db.writeLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            tbl.setState(olapTableState);\n+        } finally {\n+            db.writeUnlock();\n+        }\n+    }\n+\n+    // replay the alter job v2\n+    public void replayAlterJobV2(AlterJobV2 alterJob) {\n+        super.replayAlterJobV2(alterJob);\n+        if (!alterJob.isDone()) {\n+            addAlterJobV2ToTableNotFinalStateJobMap(alterJob);\n+            changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.ROLLUP);\n+        } else {\n+            int ret = removeAlterJobV2FromTableNotFinalStateJobMap(alterJob);\n+            if (ret == 0) {\n+                changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.NORMAL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param rollupJobV2\n+     * @return\n+     *  true,parent job is finish or current job don't have parent job;\n+     *  false, parent job is cancelled or current job hasn't finished\n+     */\n+    private boolean checkRollupJobDependency(RollupJobV2 rollupJobV2) {\n+        RollupJobV2 parentJobV2 = (RollupJobV2) alterJobsV2.get(rollupJobV2.getParentRollupJobId());\n+        if (parentJobV2 != null) {\n+            // check whether current rollup job's parent rollup job is finished\n+            if (parentJobV2.getJobState() == AlterJobV2.JobState.CANCELLED) {\n+                rollupJobV2.cancel(String.format(\"rollup %s 's base rollup %s is cancelled\", rollupJobV2.getRollupIndexId(), rollupJobV2.getBaseIndexId()));\n+                return false;\n+            }\n+            if (parentJobV2.getJobState() != AlterJobV2.JobState.FINISHED) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void runAlterJobWithConcurrencyLimit(RollupJobV2 rollupJobV2) {\n+        Set<Long> tableRunningJobSet = tableRunningJobMap.get(rollupJobV2.getTableId());\n+        if (tableRunningJobSet == null) {\n+            tableRunningJobSet = new HashSet<>();\n+            tableRunningJobMap.put(rollupJobV2.getTableId(), tableRunningJobSet);\n+        }\n+\n+        // current job is already in running\n+        if (tableRunningJobSet.contains(rollupJobV2.getJobId())) {\n+            rollupJobV2.run();\n+        } else if (tableRunningJobSet.size() < Config.max_running_rollup_job_num) {\n+            // create rollup index for job in case 1,see processBatchAddRollup\n+            if (rollupJobV2.getPartitionIdToRollupIndex().size() == 0) {\n+                Catalog catalog = Catalog.getCurrentCatalog();\n+                Database db = Catalog.getInstance().getDb(rollupJobV2.dbId);\n+                OlapTable olapTable = (OlapTable) db.getTable(rollupJobV2.getTableId());\n+                if (!createMaterializedIndexForRollupJobV2(olapTable, db, catalog, rollupJobV2)) {\n+                    rollupJobV2.cancel(String.format(\"rollup %s 's base rollup %s is cancelled due to create mv index failed, jobId = %s\",\n+                            rollupJobV2.getRollupIndexId(), rollupJobV2.getBaseIndexId(), rollupJobV2.getJobId()));\n+                }\n+                // for job in case 2 in log replay,they are in pending but not create index, can't transfer to WAITING_TXN,so first need transfer to pending\n+                rollupJobV2.setJobState(AlterJobV2.JobState.PENDING);\n+                catalog.getEditLog().logAlterJob(rollupJobV2);\n+            }\n+            // add current job to running queue\n+            tableRunningJobSet.add(rollupJobV2.getJobId());\n+            rollupJobV2.run();\n+        }\n+    }\n+\n     private void runAlterJobV2() {\n-        Iterator<Map.Entry<Long, AlterJobV2>> iter = alterJobsV2.entrySet().iterator();\n-        while (iter.hasNext()) {\n-            Map.Entry<Long, AlterJobV2> entry = iter.next();\n-            AlterJobV2 alterJob = entry.getValue();\n+        replayJobDependencyAfterCatalogReady();\n+        Iterator<Map.Entry<Long, AlterJobV2>> iterator = getAlterJobsCopy().entrySet().iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 622}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3NDkxMg==", "bodyText": "Alter Stmt write job to alterJobsV2\uff0cMaterializedViewHandler read the alterJobsV2;\nSo this is concurrent access;\nTo avoid unnecessary concurrent issue,I think better to read a alter job snapshot;", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r368274912", "createdAt": "2020-01-19T08:22:51Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -590,15 +767,130 @@ protected void runAfterCatalogReady() {\n         runAlterJobV2();\n     }\n \n+    private synchronized Map<Long, AlterJobV2> getAlterJobsCopy () {\n+        return new HashMap<>(alterJobsV2);\n+    }\n+\n+    private void removeJobFromRunningQueue(RollupJobV2 rollupJobV2) {\n+        Set<Long> runningJobIdSet = tableRunningJobMap.get(rollupJobV2.getTableId());\n+        if (runningJobIdSet != null) {\n+            runningJobIdSet.remove(rollupJobV2.getJobId());\n+            if (runningJobIdSet.size() == 0) {\n+                tableRunningJobMap.remove(rollupJobV2.getTableId());\n+            }\n+        }\n+    }\n+\n+    private void changeTableStatus(long dbId, long tableId, OlapTableState olapTableState) {\n+        Database db = Catalog.getCurrentCatalog().getDb(dbId);\n+        db.readLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            if (tbl == null || tbl.getState() == olapTableState) {\n+                return;\n+            }\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        db.writeLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            tbl.setState(olapTableState);\n+        } finally {\n+            db.writeUnlock();\n+        }\n+    }\n+\n+    // replay the alter job v2\n+    public void replayAlterJobV2(AlterJobV2 alterJob) {\n+        super.replayAlterJobV2(alterJob);\n+        if (!alterJob.isDone()) {\n+            addAlterJobV2ToTableNotFinalStateJobMap(alterJob);\n+            changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.ROLLUP);\n+        } else {\n+            int ret = removeAlterJobV2FromTableNotFinalStateJobMap(alterJob);\n+            if (ret == 0) {\n+                changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.NORMAL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param rollupJobV2\n+     * @return\n+     *  true,parent job is finish or current job don't have parent job;\n+     *  false, parent job is cancelled or current job hasn't finished\n+     */\n+    private boolean checkRollupJobDependency(RollupJobV2 rollupJobV2) {\n+        RollupJobV2 parentJobV2 = (RollupJobV2) alterJobsV2.get(rollupJobV2.getParentRollupJobId());\n+        if (parentJobV2 != null) {\n+            // check whether current rollup job's parent rollup job is finished\n+            if (parentJobV2.getJobState() == AlterJobV2.JobState.CANCELLED) {\n+                rollupJobV2.cancel(String.format(\"rollup %s 's base rollup %s is cancelled\", rollupJobV2.getRollupIndexId(), rollupJobV2.getBaseIndexId()));\n+                return false;\n+            }\n+            if (parentJobV2.getJobState() != AlterJobV2.JobState.FINISHED) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void runAlterJobWithConcurrencyLimit(RollupJobV2 rollupJobV2) {\n+        Set<Long> tableRunningJobSet = tableRunningJobMap.get(rollupJobV2.getTableId());\n+        if (tableRunningJobSet == null) {\n+            tableRunningJobSet = new HashSet<>();\n+            tableRunningJobMap.put(rollupJobV2.getTableId(), tableRunningJobSet);\n+        }\n+\n+        // current job is already in running\n+        if (tableRunningJobSet.contains(rollupJobV2.getJobId())) {\n+            rollupJobV2.run();\n+        } else if (tableRunningJobSet.size() < Config.max_running_rollup_job_num) {\n+            // create rollup index for job in case 1,see processBatchAddRollup\n+            if (rollupJobV2.getPartitionIdToRollupIndex().size() == 0) {\n+                Catalog catalog = Catalog.getCurrentCatalog();\n+                Database db = Catalog.getInstance().getDb(rollupJobV2.dbId);\n+                OlapTable olapTable = (OlapTable) db.getTable(rollupJobV2.getTableId());\n+                if (!createMaterializedIndexForRollupJobV2(olapTable, db, catalog, rollupJobV2)) {\n+                    rollupJobV2.cancel(String.format(\"rollup %s 's base rollup %s is cancelled due to create mv index failed, jobId = %s\",\n+                            rollupJobV2.getRollupIndexId(), rollupJobV2.getBaseIndexId(), rollupJobV2.getJobId()));\n+                }\n+                // for job in case 2 in log replay,they are in pending but not create index, can't transfer to WAITING_TXN,so first need transfer to pending\n+                rollupJobV2.setJobState(AlterJobV2.JobState.PENDING);\n+                catalog.getEditLog().logAlterJob(rollupJobV2);\n+            }\n+            // add current job to running queue\n+            tableRunningJobSet.add(rollupJobV2.getJobId());\n+            rollupJobV2.run();\n+        }\n+    }\n+\n     private void runAlterJobV2() {\n-        Iterator<Map.Entry<Long, AlterJobV2>> iter = alterJobsV2.entrySet().iterator();\n-        while (iter.hasNext()) {\n-            Map.Entry<Long, AlterJobV2> entry = iter.next();\n-            AlterJobV2 alterJob = entry.getValue();\n+        replayJobDependencyAfterCatalogReady();\n+        Iterator<Map.Entry<Long, AlterJobV2>> iterator = getAlterJobsCopy().entrySet().iterator();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2MTQ4NA=="}, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 622}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzY2NzU1OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoyOToxNFrOFe6pOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMjo0MjowNlrOFfKq6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2MjQyNw==", "bodyText": "why replay here\uff1f", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367962427", "createdAt": "2020-01-17T14:29:14Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -590,15 +767,130 @@ protected void runAfterCatalogReady() {\n         runAlterJobV2();\n     }\n \n+    private synchronized Map<Long, AlterJobV2> getAlterJobsCopy () {\n+        return new HashMap<>(alterJobsV2);\n+    }\n+\n+    private void removeJobFromRunningQueue(RollupJobV2 rollupJobV2) {\n+        Set<Long> runningJobIdSet = tableRunningJobMap.get(rollupJobV2.getTableId());\n+        if (runningJobIdSet != null) {\n+            runningJobIdSet.remove(rollupJobV2.getJobId());\n+            if (runningJobIdSet.size() == 0) {\n+                tableRunningJobMap.remove(rollupJobV2.getTableId());\n+            }\n+        }\n+    }\n+\n+    private void changeTableStatus(long dbId, long tableId, OlapTableState olapTableState) {\n+        Database db = Catalog.getCurrentCatalog().getDb(dbId);\n+        db.readLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            if (tbl == null || tbl.getState() == olapTableState) {\n+                return;\n+            }\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        db.writeLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            tbl.setState(olapTableState);\n+        } finally {\n+            db.writeUnlock();\n+        }\n+    }\n+\n+    // replay the alter job v2\n+    public void replayAlterJobV2(AlterJobV2 alterJob) {\n+        super.replayAlterJobV2(alterJob);\n+        if (!alterJob.isDone()) {\n+            addAlterJobV2ToTableNotFinalStateJobMap(alterJob);\n+            changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.ROLLUP);\n+        } else {\n+            int ret = removeAlterJobV2FromTableNotFinalStateJobMap(alterJob);\n+            if (ret == 0) {\n+                changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.NORMAL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param rollupJobV2\n+     * @return\n+     *  true,parent job is finish or current job don't have parent job;\n+     *  false, parent job is cancelled or current job hasn't finished\n+     */\n+    private boolean checkRollupJobDependency(RollupJobV2 rollupJobV2) {\n+        RollupJobV2 parentJobV2 = (RollupJobV2) alterJobsV2.get(rollupJobV2.getParentRollupJobId());\n+        if (parentJobV2 != null) {\n+            // check whether current rollup job's parent rollup job is finished\n+            if (parentJobV2.getJobState() == AlterJobV2.JobState.CANCELLED) {\n+                rollupJobV2.cancel(String.format(\"rollup %s 's base rollup %s is cancelled\", rollupJobV2.getRollupIndexId(), rollupJobV2.getBaseIndexId()));\n+                return false;\n+            }\n+            if (parentJobV2.getJobState() != AlterJobV2.JobState.FINISHED) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void runAlterJobWithConcurrencyLimit(RollupJobV2 rollupJobV2) {\n+        Set<Long> tableRunningJobSet = tableRunningJobMap.get(rollupJobV2.getTableId());\n+        if (tableRunningJobSet == null) {\n+            tableRunningJobSet = new HashSet<>();\n+            tableRunningJobMap.put(rollupJobV2.getTableId(), tableRunningJobSet);\n+        }\n+\n+        // current job is already in running\n+        if (tableRunningJobSet.contains(rollupJobV2.getJobId())) {\n+            rollupJobV2.run();\n+        } else if (tableRunningJobSet.size() < Config.max_running_rollup_job_num) {\n+            // create rollup index for job in case 1,see processBatchAddRollup\n+            if (rollupJobV2.getPartitionIdToRollupIndex().size() == 0) {\n+                Catalog catalog = Catalog.getCurrentCatalog();\n+                Database db = Catalog.getInstance().getDb(rollupJobV2.dbId);\n+                OlapTable olapTable = (OlapTable) db.getTable(rollupJobV2.getTableId());\n+                if (!createMaterializedIndexForRollupJobV2(olapTable, db, catalog, rollupJobV2)) {\n+                    rollupJobV2.cancel(String.format(\"rollup %s 's base rollup %s is cancelled due to create mv index failed, jobId = %s\",\n+                            rollupJobV2.getRollupIndexId(), rollupJobV2.getBaseIndexId(), rollupJobV2.getJobId()));\n+                }\n+                // for job in case 2 in log replay,they are in pending but not create index, can't transfer to WAITING_TXN,so first need transfer to pending\n+                rollupJobV2.setJobState(AlterJobV2.JobState.PENDING);\n+                catalog.getEditLog().logAlterJob(rollupJobV2);\n+            }\n+            // add current job to running queue\n+            tableRunningJobSet.add(rollupJobV2.getJobId());\n+            rollupJobV2.run();\n+        }\n+    }\n+\n     private void runAlterJobV2() {\n-        Iterator<Map.Entry<Long, AlterJobV2>> iter = alterJobsV2.entrySet().iterator();\n-        while (iter.hasNext()) {\n-            Map.Entry<Long, AlterJobV2> entry = iter.next();\n-            AlterJobV2 alterJob = entry.getValue();\n+        replayJobDependencyAfterCatalogReady();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 621}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyNTAwMg==", "bodyText": "In this implementation,when fe restart,the job dependncy is lost,need to rebuild before running, set every job's parent job;\nBut if use \"whether base rollup can be found in catalog\" to judge whether parent rollup is ready is ok,so this method can be removed.", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r368225002", "createdAt": "2020-01-18T12:42:06Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -590,15 +767,130 @@ protected void runAfterCatalogReady() {\n         runAlterJobV2();\n     }\n \n+    private synchronized Map<Long, AlterJobV2> getAlterJobsCopy () {\n+        return new HashMap<>(alterJobsV2);\n+    }\n+\n+    private void removeJobFromRunningQueue(RollupJobV2 rollupJobV2) {\n+        Set<Long> runningJobIdSet = tableRunningJobMap.get(rollupJobV2.getTableId());\n+        if (runningJobIdSet != null) {\n+            runningJobIdSet.remove(rollupJobV2.getJobId());\n+            if (runningJobIdSet.size() == 0) {\n+                tableRunningJobMap.remove(rollupJobV2.getTableId());\n+            }\n+        }\n+    }\n+\n+    private void changeTableStatus(long dbId, long tableId, OlapTableState olapTableState) {\n+        Database db = Catalog.getCurrentCatalog().getDb(dbId);\n+        db.readLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            if (tbl == null || tbl.getState() == olapTableState) {\n+                return;\n+            }\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        db.writeLock();\n+        try {\n+            OlapTable tbl = (OlapTable) db.getTable(tableId);\n+            tbl.setState(olapTableState);\n+        } finally {\n+            db.writeUnlock();\n+        }\n+    }\n+\n+    // replay the alter job v2\n+    public void replayAlterJobV2(AlterJobV2 alterJob) {\n+        super.replayAlterJobV2(alterJob);\n+        if (!alterJob.isDone()) {\n+            addAlterJobV2ToTableNotFinalStateJobMap(alterJob);\n+            changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.ROLLUP);\n+        } else {\n+            int ret = removeAlterJobV2FromTableNotFinalStateJobMap(alterJob);\n+            if (ret == 0) {\n+                changeTableStatus(alterJob.getDbId(), alterJob.getTableId(), OlapTableState.NORMAL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param rollupJobV2\n+     * @return\n+     *  true,parent job is finish or current job don't have parent job;\n+     *  false, parent job is cancelled or current job hasn't finished\n+     */\n+    private boolean checkRollupJobDependency(RollupJobV2 rollupJobV2) {\n+        RollupJobV2 parentJobV2 = (RollupJobV2) alterJobsV2.get(rollupJobV2.getParentRollupJobId());\n+        if (parentJobV2 != null) {\n+            // check whether current rollup job's parent rollup job is finished\n+            if (parentJobV2.getJobState() == AlterJobV2.JobState.CANCELLED) {\n+                rollupJobV2.cancel(String.format(\"rollup %s 's base rollup %s is cancelled\", rollupJobV2.getRollupIndexId(), rollupJobV2.getBaseIndexId()));\n+                return false;\n+            }\n+            if (parentJobV2.getJobState() != AlterJobV2.JobState.FINISHED) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void runAlterJobWithConcurrencyLimit(RollupJobV2 rollupJobV2) {\n+        Set<Long> tableRunningJobSet = tableRunningJobMap.get(rollupJobV2.getTableId());\n+        if (tableRunningJobSet == null) {\n+            tableRunningJobSet = new HashSet<>();\n+            tableRunningJobMap.put(rollupJobV2.getTableId(), tableRunningJobSet);\n+        }\n+\n+        // current job is already in running\n+        if (tableRunningJobSet.contains(rollupJobV2.getJobId())) {\n+            rollupJobV2.run();\n+        } else if (tableRunningJobSet.size() < Config.max_running_rollup_job_num) {\n+            // create rollup index for job in case 1,see processBatchAddRollup\n+            if (rollupJobV2.getPartitionIdToRollupIndex().size() == 0) {\n+                Catalog catalog = Catalog.getCurrentCatalog();\n+                Database db = Catalog.getInstance().getDb(rollupJobV2.dbId);\n+                OlapTable olapTable = (OlapTable) db.getTable(rollupJobV2.getTableId());\n+                if (!createMaterializedIndexForRollupJobV2(olapTable, db, catalog, rollupJobV2)) {\n+                    rollupJobV2.cancel(String.format(\"rollup %s 's base rollup %s is cancelled due to create mv index failed, jobId = %s\",\n+                            rollupJobV2.getRollupIndexId(), rollupJobV2.getBaseIndexId(), rollupJobV2.getJobId()));\n+                }\n+                // for job in case 2 in log replay,they are in pending but not create index, can't transfer to WAITING_TXN,so first need transfer to pending\n+                rollupJobV2.setJobState(AlterJobV2.JobState.PENDING);\n+                catalog.getEditLog().logAlterJob(rollupJobV2);\n+            }\n+            // add current job to running queue\n+            tableRunningJobSet.add(rollupJobV2.getJobId());\n+            rollupJobV2.run();\n+        }\n+    }\n+\n     private void runAlterJobV2() {\n-        Iterator<Map.Entry<Long, AlterJobV2>> iter = alterJobsV2.entrySet().iterator();\n-        while (iter.hasNext()) {\n-            Map.Entry<Long, AlterJobV2> entry = iter.next();\n-            AlterJobV2 alterJob = entry.getValue();\n+        replayJobDependencyAfterCatalogReady();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2MjQyNw=="}, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 621}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzY3MDk2OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDozMDoyMlrOFe6rWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMjo0MjoxM1rOFfKq7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2Mjk2OQ==", "bodyText": "change return type to bool?", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r367962969", "createdAt": "2020-01-17T14:30:22Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -85,6 +90,71 @@ public MaterializedViewHandler() {\n         super(\"materialized view\");\n     }\n \n+\n+    // for batch submit rollup job, tableId -> jobId\n+    // keep table's not final state job size. The job size determine's table's state, = 0 means table is normal,otherwrise is rollup\n+    private Map<Long, Set<Long>> tableNotFinalStateJobMap = new ConcurrentHashMap<>();\n+    // keep table's running job,used for concurrency limit\n+    private Map<Long, Set<Long>> tableRunningJobMap = new ConcurrentHashMap<>();\n+    // make sure that job's dependency just init once\n+    private volatile boolean hasBuildJobDependency = false;\n+\n+    // set job' parent job after CatalogReady\n+    private void replayJobDependencyAfterCatalogReady() {\n+        if (!hasBuildJobDependency) {\n+            Map<Long, Long> rollupIndexIdJobIdMap = new HashMap<>();\n+            Iterator<Map.Entry<Long, AlterJobV2>> first  =alterJobsV2.entrySet().iterator();\n+            while (first.hasNext()) {\n+                Map.Entry<Long, AlterJobV2> entry = first.next();\n+                rollupIndexIdJobIdMap.put(((RollupJobV2)entry.getValue()).getRollupIndexId(), entry.getValue().getJobId());\n+            }\n+\n+            Iterator<Map.Entry<Long, AlterJobV2>> second = alterJobsV2.entrySet().iterator();\n+            while (second.hasNext()) {\n+                Map.Entry<Long, AlterJobV2> entry = second.next();\n+                RollupJobV2 rollupJobV2 = (RollupJobV2) entry.getValue();\n+                Long baseJobId = rollupIndexIdJobIdMap.get(rollupJobV2.getBaseIndexId());\n+                ((RollupJobV2)entry.getValue()).setParentRollupJobId(baseJobId == null ? 0 : baseJobId);\n+            }\n+            hasBuildJobDependency = true;\n+        }\n+    }\n+\n+    protected synchronized void addAlterJobV2(AlterJobV2 alterJob) {\n+        super.addAlterJobV2(alterJob);\n+        addAlterJobV2ToTableNotFinalStateJobMap(alterJob);\n+    }\n+\n+    private void addAlterJobV2ToTableNotFinalStateJobMap(AlterJobV2 alterJobV2) {\n+        if (alterJobV2.isDone()) {\n+            LOG.warn(\"try to add a final job({}) to a unfinal set\", alterJobV2.getJobId());\n+            return;\n+        }\n+        Long tableId = alterJobV2.getTableId();\n+        Long jobId = alterJobV2.getJobId();\n+        Set<Long> tableNotFinalStateJobIdSet = tableNotFinalStateJobMap.get(tableId);\n+        if (tableNotFinalStateJobIdSet == null) {\n+            tableNotFinalStateJobIdSet = new HashSet<>();\n+            tableNotFinalStateJobMap.put(tableId, tableNotFinalStateJobIdSet);\n+        }\n+        tableNotFinalStateJobIdSet.add(jobId);\n+    }\n+\n+    private int removeAlterJobV2FromTableNotFinalStateJobMap(AlterJobV2 alterJobV2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyNTAwNw==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r368225007", "createdAt": "2020-01-18T12:42:13Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -85,6 +90,71 @@ public MaterializedViewHandler() {\n         super(\"materialized view\");\n     }\n \n+\n+    // for batch submit rollup job, tableId -> jobId\n+    // keep table's not final state job size. The job size determine's table's state, = 0 means table is normal,otherwrise is rollup\n+    private Map<Long, Set<Long>> tableNotFinalStateJobMap = new ConcurrentHashMap<>();\n+    // keep table's running job,used for concurrency limit\n+    private Map<Long, Set<Long>> tableRunningJobMap = new ConcurrentHashMap<>();\n+    // make sure that job's dependency just init once\n+    private volatile boolean hasBuildJobDependency = false;\n+\n+    // set job' parent job after CatalogReady\n+    private void replayJobDependencyAfterCatalogReady() {\n+        if (!hasBuildJobDependency) {\n+            Map<Long, Long> rollupIndexIdJobIdMap = new HashMap<>();\n+            Iterator<Map.Entry<Long, AlterJobV2>> first  =alterJobsV2.entrySet().iterator();\n+            while (first.hasNext()) {\n+                Map.Entry<Long, AlterJobV2> entry = first.next();\n+                rollupIndexIdJobIdMap.put(((RollupJobV2)entry.getValue()).getRollupIndexId(), entry.getValue().getJobId());\n+            }\n+\n+            Iterator<Map.Entry<Long, AlterJobV2>> second = alterJobsV2.entrySet().iterator();\n+            while (second.hasNext()) {\n+                Map.Entry<Long, AlterJobV2> entry = second.next();\n+                RollupJobV2 rollupJobV2 = (RollupJobV2) entry.getValue();\n+                Long baseJobId = rollupIndexIdJobIdMap.get(rollupJobV2.getBaseIndexId());\n+                ((RollupJobV2)entry.getValue()).setParentRollupJobId(baseJobId == null ? 0 : baseJobId);\n+            }\n+            hasBuildJobDependency = true;\n+        }\n+    }\n+\n+    protected synchronized void addAlterJobV2(AlterJobV2 alterJob) {\n+        super.addAlterJobV2(alterJob);\n+        addAlterJobV2ToTableNotFinalStateJobMap(alterJob);\n+    }\n+\n+    private void addAlterJobV2ToTableNotFinalStateJobMap(AlterJobV2 alterJobV2) {\n+        if (alterJobV2.isDone()) {\n+            LOG.warn(\"try to add a final job({}) to a unfinal set\", alterJobV2.getJobId());\n+            return;\n+        }\n+        Long tableId = alterJobV2.getTableId();\n+        Long jobId = alterJobV2.getJobId();\n+        Set<Long> tableNotFinalStateJobIdSet = tableNotFinalStateJobMap.get(tableId);\n+        if (tableNotFinalStateJobIdSet == null) {\n+            tableNotFinalStateJobIdSet = new HashSet<>();\n+            tableNotFinalStateJobMap.put(tableId, tableNotFinalStateJobIdSet);\n+        }\n+        tableNotFinalStateJobIdSet.add(jobId);\n+    }\n+\n+    private int removeAlterJobV2FromTableNotFinalStateJobMap(AlterJobV2 alterJobV2) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2Mjk2OQ=="}, "originalCommit": {"oid": "92e45053b0cecaf6d34ed274b551b123c7033483"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjc4MTMzOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/AlterJobV2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOToyMTozNFrOFkquHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwODoyNzo0N1rOFlLgvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5Mjk5MQ==", "bodyText": "Why add a INIT state? which is necessary\uff1f what's the difference from PENDING state?", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r373992991", "createdAt": "2020-02-03T09:21:34Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/alter/AlterJobV2.java", "diffHunk": "@@ -38,7 +38,8 @@\n     private static final Logger LOG = LogManager.getLogger(AlterJobV2.class);\n \n     public enum JobState {\n-        PENDING, // Job is created\n+        INIT, // Job is created", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2716f02fd64d4a99bc3b242b0b3295de44771bdc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUzMDIzOQ==", "bodyText": "not necessary now", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374530239", "createdAt": "2020-02-04T08:27:47Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/AlterJobV2.java", "diffHunk": "@@ -38,7 +38,8 @@\n     private static final Logger LOG = LogManager.getLogger(AlterJobV2.class);\n \n     public enum JobState {\n-        PENDING, // Job is created\n+        INIT, // Job is created", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5Mjk5MQ=="}, "originalCommit": {"oid": "2716f02fd64d4a99bc3b242b0b3295de44771bdc"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjc4NDE4OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/BatchAlterJobV2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOToyMjoyOFrOFkqv1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozOTozNlrOFkukjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5MzQyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class BatchAlterJobV2 implements Writable {\n          \n          \n            \n            public class `BatchAlterJobPersistInfo` implements Writable {", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r373993428", "createdAt": "2020-02-03T09:22:28Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/alter/BatchAlterJobV2.java", "diffHunk": "@@ -0,0 +1,60 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package org.apache.doris.alter;\n+\n+import org.apache.doris.common.io.Writable;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ *\n+ * used for batch log AlterJob to editLog in one atomic operation\n+ *\n+ */\n+public class BatchAlterJobV2 implements Writable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2716f02fd64d4a99bc3b242b0b3295de44771bdc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NjA3OA==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374056078", "createdAt": "2020-02-03T11:39:36Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/BatchAlterJobV2.java", "diffHunk": "@@ -0,0 +1,60 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package org.apache.doris.alter;\n+\n+import org.apache.doris.common.io.Writable;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ *\n+ * used for batch log AlterJob to editLog in one atomic operation\n+ *\n+ */\n+public class BatchAlterJobV2 implements Writable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5MzQyOA=="}, "originalCommit": {"oid": "2716f02fd64d4a99bc3b242b0b3295de44771bdc"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjc5MDY1OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/BatchAlterJobV2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOToyNDo0NFrOFkqztQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwODoyOTo1NlrOFlLkOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5NDQyMQ==", "bodyText": "New metadata class should Serde by JSON. You could refer to Tag class", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r373994421", "createdAt": "2020-02-03T09:24:44Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/alter/BatchAlterJobV2.java", "diffHunk": "@@ -0,0 +1,60 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package org.apache.doris.alter;\n+\n+import org.apache.doris.common.io.Writable;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ *\n+ * used for batch log AlterJob to editLog in one atomic operation\n+ *\n+ */\n+public class BatchAlterJobV2 implements Writable {\n+\n+    private List<AlterJobV2> alterJobV2List;\n+\n+    public BatchAlterJobV2(List<AlterJobV2> alterJobV2List) {\n+        this.alterJobV2List = alterJobV2List;\n+    }\n+\n+    @Override\n+    public void write(DataOutput out) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2716f02fd64d4a99bc3b242b0b3295de44771bdc"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUzMTEzMQ==", "bodyText": "RollupJobV2 not support json serde,so BatchAlterJobV2 can't Serde by JSON", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374531131", "createdAt": "2020-02-04T08:29:56Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/BatchAlterJobV2.java", "diffHunk": "@@ -0,0 +1,60 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package org.apache.doris.alter;\n+\n+import org.apache.doris.common.io.Writable;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ *\n+ * used for batch log AlterJob to editLog in one atomic operation\n+ *\n+ */\n+public class BatchAlterJobV2 implements Writable {\n+\n+    private List<AlterJobV2> alterJobV2List;\n+\n+    public BatchAlterJobV2(List<AlterJobV2> alterJobV2List) {\n+        this.alterJobV2List = alterJobV2List;\n+    }\n+\n+    @Override\n+    public void write(DataOutput out) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5NDQyMQ=="}, "originalCommit": {"oid": "2716f02fd64d4a99bc3b242b0b3295de44771bdc"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjgxNzc5OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOTozMzoyOFrOFkrDyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMToyNTo1OVrOFkuPmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5ODUzOQ==", "bodyText": "Why change the log level?", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r373998539", "createdAt": "2020-02-03T09:33:28Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java", "diffHunk": "@@ -441,10 +441,10 @@ public void addTablet(long tabletId, TabletMeta tabletMeta) {\n             tabletMetaMap.put(tabletId, tabletMeta);\n             if (!tabletMetaTable.contains(tabletMeta.getPartitionId(), tabletMeta.getIndexId())) {\n                 tabletMetaTable.put(tabletMeta.getPartitionId(), tabletMeta.getIndexId(), tabletMeta);\n-                LOG.debug(\"add tablet meta: {}\", tabletId);\n+                LOG.info(\"add tablet meta: {}\", tabletId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2716f02fd64d4a99bc3b242b0b3295de44771bdc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MDcxNA==", "bodyText": "just for debug,it's useless", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374050714", "createdAt": "2020-02-03T11:25:59Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java", "diffHunk": "@@ -441,10 +441,10 @@ public void addTablet(long tabletId, TabletMeta tabletMeta) {\n             tabletMetaMap.put(tabletId, tabletMeta);\n             if (!tabletMetaTable.contains(tabletMeta.getPartitionId(), tabletMeta.getIndexId())) {\n                 tabletMetaTable.put(tabletMeta.getPartitionId(), tabletMeta.getIndexId(), tabletMeta);\n-                LOG.debug(\"add tablet meta: {}\", tabletId);\n+                LOG.info(\"add tablet meta: {}\", tabletId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5ODUzOQ=="}, "originalCommit": {"oid": "2716f02fd64d4a99bc3b242b0b3295de44771bdc"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjkzNjM2OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMDowOToyMFrOFksJcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozOTo0NlrOFkukzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDAxNjM3MQ==", "bodyText": "This is unnecessary. We could check the\nalter statement and require the from index must exist firstly, and then, we needn't do this work", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374016371", "createdAt": "2020-02-03T10:09:20Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -858,4 +1084,56 @@ public void cancel(CancelStmt stmt) throws DdlException {\n             jobDone(rollupJob);\n         }\n     }\n+\n+    // There may be dependency relation between user batch input rollup index\n+    // e.g, user input rollup index: r1 from r2,r2 from r3 ;the input order must be r3,r2,r1\n+    // the reason for sort rollup index:\n+    //   son rollup must be dealed after parent rollup, because they need parent rollup's info,such as baseRollupIndex\n+    public static List<AlterClause> sortRollupIndex(List<AlterClause> alterClauseList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2716f02fd64d4a99bc3b242b0b3295de44771bdc"}, "originalPosition": 680}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NjE0MA==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374056140", "createdAt": "2020-02-03T11:39:46Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -858,4 +1084,56 @@ public void cancel(CancelStmt stmt) throws DdlException {\n             jobDone(rollupJob);\n         }\n     }\n+\n+    // There may be dependency relation between user batch input rollup index\n+    // e.g, user input rollup index: r1 from r2,r2 from r3 ;the input order must be r3,r2,r1\n+    // the reason for sort rollup index:\n+    //   son rollup must be dealed after parent rollup, because they need parent rollup's info,such as baseRollupIndex\n+    public static List<AlterClause> sortRollupIndex(List<AlterClause> alterClauseList) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDAxNjM3MQ=="}, "originalCommit": {"oid": "2716f02fd64d4a99bc3b242b0b3295de44771bdc"}, "originalPosition": 680}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTk5MzgzOnYy", "diffSide": "RIGHT", "path": "docs/documentation/cn/sql-reference/sql-statements/Data Definition/ALTER TABLE.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNjozNjoyOVrOFlJYuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTozMzowM1rOFlNW5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5NTQxNw==", "bodyText": "\u5355\u72ec\u521b\u5efa\u548c\u6279\u91cf\u521b\u5efa\u5206\u5f00\u90fd\u7ed9\u4e2a\u4f8b\u5b50\u3002\n\u6279\u91cf\u521b\u5efa\u7ed9\u4e2a\u4e24\u4e2arollUp\u7684\u4f8b\u5b50\uff0c...\u662f\u5565\u542b\u4e49\u662f\u4e0d\u6e05\u695a\u7684\u3002", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374495417", "createdAt": "2020-02-04T06:36:29Z", "author": {"login": "kangkaisen"}, "path": "docs/documentation/cn/sql-reference/sql-statements/Data Definition/ALTER TABLE.md", "diffHunk": "@@ -63,20 +63,19 @@ under the License.\n             2) \u5bf9\u4e8e\u5355\u5206\u533a\u8868\uff0cpartition_name \u540c\u8868\u540d\u3002\n         \n     rollup \u652f\u6301\u5982\u4e0b\u51e0\u79cd\u521b\u5efa\u65b9\u5f0f\uff1a\n-    1. \u521b\u5efa rollup index\n+    1. \u6279\u91cf\u521b\u5efa rollup index", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4eb83654d0c9682c0b91111e00af9496fb270381"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2MDQ4NQ==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374560485", "createdAt": "2020-02-04T09:33:03Z", "author": {"login": "wangbo"}, "path": "docs/documentation/cn/sql-reference/sql-statements/Data Definition/ALTER TABLE.md", "diffHunk": "@@ -63,20 +63,19 @@ under the License.\n             2) \u5bf9\u4e8e\u5355\u5206\u533a\u8868\uff0cpartition_name \u540c\u8868\u540d\u3002\n         \n     rollup \u652f\u6301\u5982\u4e0b\u51e0\u79cd\u521b\u5efa\u65b9\u5f0f\uff1a\n-    1. \u521b\u5efa rollup index\n+    1. \u6279\u91cf\u521b\u5efa rollup index", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5NTQxNw=="}, "originalCommit": {"oid": "4eb83654d0c9682c0b91111e00af9496fb270381"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNjA0MDY4OnYy", "diffSide": "RIGHT", "path": "docs/documentation/cn/sql-reference/sql-statements/Data Definition/CANCEL ALTER.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNzowMzoxMFrOFlJzug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTo1NzozMFrOFlOIyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMjMzMA==", "bodyText": "\u82f1\u6587\u7248?", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374502330", "createdAt": "2020-02-04T07:03:10Z", "author": {"login": "kangkaisen"}, "path": "docs/documentation/cn/sql-reference/sql-statements/Data Definition/CANCEL ALTER.md", "diffHunk": "@@ -29,7 +29,11 @@ under the License.\n     \u8bed\u6cd5\uff1a\n         CANCEL ALTER TABLE ROLLUP\n         FROM db_name.table_name\n-        \n+\n+    3. \u6839\u636ejob id\u6279\u91cf\u64a4\u9500rollup\u64cd\u4f5c", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4eb83654d0c9682c0b91111e00af9496fb270381"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUzMTQ1NA==", "bodyText": "\u8fd9\u4e2a\u662fdocumentation/cn\u554a\uff0c\u5e94\u8be5\u5c31\u662f\u4e2d\u6587", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374531454", "createdAt": "2020-02-04T08:30:44Z", "author": {"login": "wangbo"}, "path": "docs/documentation/cn/sql-reference/sql-statements/Data Definition/CANCEL ALTER.md", "diffHunk": "@@ -29,7 +29,11 @@ under the License.\n     \u8bed\u6cd5\uff1a\n         CANCEL ALTER TABLE ROLLUP\n         FROM db_name.table_name\n-        \n+\n+    3. \u6839\u636ejob id\u6279\u91cf\u64a4\u9500rollup\u64cd\u4f5c", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMjMzMA=="}, "originalCommit": {"oid": "4eb83654d0c9682c0b91111e00af9496fb270381"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU3MzI1OA==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374573258", "createdAt": "2020-02-04T09:57:30Z", "author": {"login": "wangbo"}, "path": "docs/documentation/cn/sql-reference/sql-statements/Data Definition/CANCEL ALTER.md", "diffHunk": "@@ -29,7 +29,11 @@ under the License.\n     \u8bed\u6cd5\uff1a\n         CANCEL ALTER TABLE ROLLUP\n         FROM db_name.table_name\n-        \n+\n+    3. \u6839\u636ejob id\u6279\u91cf\u64a4\u9500rollup\u64cd\u4f5c", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMjMzMA=="}, "originalCommit": {"oid": "4eb83654d0c9682c0b91111e00af9496fb270381"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNjA5MzIyOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/catalog/Catalog.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNzozMToxMlrOFlKTDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwODozMTo1N1rOFlLnYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxMDM1MA==", "bodyText": "Remove this comment.  One Olap table always has one base index.", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374510350", "createdAt": "2020-02-04T07:31:12Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/catalog/Catalog.java", "diffHunk": "@@ -3543,6 +3548,32 @@ private void createOlapTable(Database db, CreateTableStmt stmt) throws DdlExcept\n         olapTable.setIndexSchemaInfo(baseIndexId, tableName, baseSchema, schemaVersion, schemaHash,\n                 shortKeyColumnCount);\n \n+\n+        for (AlterClause alterClause : stmt.getRollupAlterClauseList()) {\n+            AddRollupClause addRollupClause = (AddRollupClause)alterClause;\n+\n+            // TODO(wangbo): 2020/2/3 doris auto select base rollup", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4eb83654d0c9682c0b91111e00af9496fb270381"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUzMTkzOQ==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374531939", "createdAt": "2020-02-04T08:31:57Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/catalog/Catalog.java", "diffHunk": "@@ -3543,6 +3548,32 @@ private void createOlapTable(Database db, CreateTableStmt stmt) throws DdlExcept\n         olapTable.setIndexSchemaInfo(baseIndexId, tableName, baseSchema, schemaVersion, schemaHash,\n                 shortKeyColumnCount);\n \n+\n+        for (AlterClause alterClause : stmt.getRollupAlterClauseList()) {\n+            AddRollupClause addRollupClause = (AddRollupClause)alterClause;\n+\n+            // TODO(wangbo): 2020/2/3 doris auto select base rollup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxMDM1MA=="}, "originalCommit": {"oid": "4eb83654d0c9682c0b91111e00af9496fb270381"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNjEyNjYwOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/RollupJobV2.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNzo0Njo0NVrOFlKmwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMzowNTowMVrOFnQfog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxNTM5NA==", "bodyText": "what's the meaning of this comment?\nBefore checkpoint, we must replay the journal less than checkPointVersion", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374515394", "createdAt": "2020-02-04T07:46:45Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/alter/RollupJobV2.java", "diffHunk": "@@ -305,7 +305,9 @@ protected void runWaitingTxnJob() throws AlterCancelException {\n         if (db == null) {\n             throw new AlterCancelException(\"Databasee \" + dbId + \" does not exist\");\n         }\n-        \n+\n+        // TODO(wangbo): 2020/2/4 in the case that the [WaitingTxnJob|PendingJob] is checkpointed and replayMethod won't be called, make sure the tablet meta exists in olapTable and TabletInvertedIndex before doris run", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4eb83654d0c9682c0b91111e00af9496fb270381"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUzNDc5NA==", "bodyText": "TabletInvertedIndex and MaterializedIndex in olaptable can't be persisted until job is final,they\ndepend on replay to load data to memory", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r374534794", "createdAt": "2020-02-04T08:38:49Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/RollupJobV2.java", "diffHunk": "@@ -305,7 +305,9 @@ protected void runWaitingTxnJob() throws AlterCancelException {\n         if (db == null) {\n             throw new AlterCancelException(\"Databasee \" + dbId + \" does not exist\");\n         }\n-        \n+\n+        // TODO(wangbo): 2020/2/4 in the case that the [WaitingTxnJob|PendingJob] is checkpointed and replayMethod won't be called, make sure the tablet meta exists in olapTable and TabletInvertedIndex before doris run", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxNTM5NA=="}, "originalCommit": {"oid": "4eb83654d0c9682c0b91111e00af9496fb270381"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwOTAyNg==", "bodyText": "I think this comment can be removed when you keep the job's state\nin PENDING after calling replayPending(). Am I right?", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376709026", "createdAt": "2020-02-08T13:05:01Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/alter/RollupJobV2.java", "diffHunk": "@@ -305,7 +305,9 @@ protected void runWaitingTxnJob() throws AlterCancelException {\n         if (db == null) {\n             throw new AlterCancelException(\"Databasee \" + dbId + \" does not exist\");\n         }\n-        \n+\n+        // TODO(wangbo): 2020/2/4 in the case that the [WaitingTxnJob|PendingJob] is checkpointed and replayMethod won't be called, make sure the tablet meta exists in olapTable and TabletInvertedIndex before doris run", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxNTM5NA=="}, "originalCommit": {"oid": "4eb83654d0c9682c0b91111e00af9496fb270381"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDA1OTYyOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/analysis/CreateTableStmt.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwOTo1MjoyMFrOFnP9dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQwNToyNzowNlrOFnTYPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMDI3OQ==", "bodyText": "remove unused setRollupAlterClauseList() method", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376700279", "createdAt": "2020-02-08T09:52:20Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/analysis/CreateTableStmt.java", "diffHunk": "@@ -218,6 +236,14 @@ public String getComment() {\n         return comment;\n     }\n \n+    public void setRollupAlterClauseList(List<AlterClause> rollupAlterClauseList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NjI4NA==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376756284", "createdAt": "2020-02-09T05:27:06Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/analysis/CreateTableStmt.java", "diffHunk": "@@ -218,6 +236,14 @@ public String getComment() {\n         return comment;\n     }\n \n+    public void setRollupAlterClauseList(List<AlterClause> rollupAlterClauseList) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMDI3OQ=="}, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDA2MDM0OnYy", "diffSide": "RIGHT", "path": "docs/documentation/cn/sql-reference/sql-statements/Data Definition/CREATE TABLE.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwOTo1NTowNVrOFnP91Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQwNToyNzo0MFrOFnTYTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMDM3Mw==", "bodyText": "I saw that you agreed with @kangkaisen that user can not create rollup from non-exist rollup? So this example should be changed, right?\nr3(event_day) from r1", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376700373", "createdAt": "2020-02-08T09:55:05Z", "author": {"login": "morningman"}, "path": "docs/documentation/cn/sql-reference/sql-statements/Data Definition/CREATE TABLE.md", "diffHunk": "@@ -550,6 +559,26 @@ under the License.\n      );\n ```\n \n+12. Create a table with rollup index\n+```\n+    CREATE TABLE example_db.rolup_index_table\n+    (\n+        event_day DATE,\n+        siteid INT DEFAULT '10',\n+        citycode SMALLINT,\n+        username VARCHAR(32) DEFAULT '',\n+        pv BIGINT SUM DEFAULT '0'\n+    )\n+    AGGREGATE KEY(event_day, siteid, citycode, username)\n+    DISTRIBUTED BY HASH(siteid) BUCKETS 10\n+    rollup (\n+    r1(event_day,siteid),\n+    r2(event_day,citycode),\n+    r3(event_day) from r1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NjMwMQ==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376756301", "createdAt": "2020-02-09T05:27:40Z", "author": {"login": "wangbo"}, "path": "docs/documentation/cn/sql-reference/sql-statements/Data Definition/CREATE TABLE.md", "diffHunk": "@@ -550,6 +559,26 @@ under the License.\n      );\n ```\n \n+12. Create a table with rollup index\n+```\n+    CREATE TABLE example_db.rolup_index_table\n+    (\n+        event_day DATE,\n+        siteid INT DEFAULT '10',\n+        citycode SMALLINT,\n+        username VARCHAR(32) DEFAULT '',\n+        pv BIGINT SUM DEFAULT '0'\n+    )\n+    AGGREGATE KEY(event_day, siteid, citycode, username)\n+    DISTRIBUTED BY HASH(siteid) BUCKETS 10\n+    rollup (\n+    r1(event_day,siteid),\n+    r2(event_day,citycode),\n+    r3(event_day) from r1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMDM3Mw=="}, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDA2MzU2OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/catalog/Catalog.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMDowNDoxOFrOFnP_cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQwNTozMjo1NVrOFnTZIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMDc4NQ==", "bodyText": "So.. Seem that this is a serious bug exist before?\nIf yes, please add\nalterJobsV2 = this.getRollupHandler().getAlterJobsV2(); before.\nSo here can be remain unchanged.", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376700785", "createdAt": "2020-02-08T10:04:18Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/catalog/Catalog.java", "diffHunk": "@@ -1682,7 +1683,11 @@ public long loadAlterJob(DataInputStream dis, long checksum, JobType type) throw\n             newChecksum ^= size;\n             for (int i = 0; i < size; i++) {\n                 AlterJobV2 alterJobV2 = AlterJobV2.read(dis);\n-                alterJobsV2.put(alterJobV2.getJobId(), alterJobV2);\n+                if (type == JobType.ROLLUP) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NjUxNQ==", "bodyText": "No bug before; Before,SchemaChangeHandler has the addJob logic with MaterializedViewHandler;But now,they are different;", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376756515", "createdAt": "2020-02-09T05:32:55Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/catalog/Catalog.java", "diffHunk": "@@ -1682,7 +1683,11 @@ public long loadAlterJob(DataInputStream dis, long checksum, JobType type) throw\n             newChecksum ^= size;\n             for (int i = 0; i < size; i++) {\n                 AlterJobV2 alterJobV2 = AlterJobV2.read(dis);\n-                alterJobsV2.put(alterJobV2.getJobId(), alterJobV2);\n+                if (type == JobType.ROLLUP) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMDc4NQ=="}, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDA2NjMyOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/common/Config.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMDoxMTo1MFrOFnQAxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQwNTozMzowM1rOFnTZKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMTEyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @ConfField\n          \n          \n            \n                @ConfField(mutable = true, masterOnly = true)", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376701127", "createdAt": "2020-02-08T10:11:50Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/common/Config.java", "diffHunk": "@@ -984,5 +984,11 @@\n      */\n     @ConfField(mutable = true, masterOnly = true)\n     public static boolean dynamic_partition_enable = false;\n+\n+    /*\n+     * control rollup job concurrent limit\n+     */\n+    @ConfField", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NjUyMQ==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376756521", "createdAt": "2020-02-09T05:33:03Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/common/Config.java", "diffHunk": "@@ -984,5 +984,11 @@\n      */\n     @ConfField(mutable = true, masterOnly = true)\n     public static boolean dynamic_partition_enable = false;\n+\n+    /*\n+     * control rollup job concurrent limit\n+     */\n+    @ConfField", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMTEyNw=="}, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDA2NzA4OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/persist/OperationType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMDoxMzo0MVrOFnQBHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQwNTozNDo1MlrOFnTZfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMTIxNA==", "bodyText": "put the after the OP_MODIFY_DISTRIBUTION_TYPE to make the opCode ordered, even if OP_BATCH_ALTER_JOB_V2 is the same catalog of ALTER JOB. Otherwise, the following developer may use wrong code.", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376701214", "createdAt": "2020-02-08T10:13:41Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/persist/OperationType.java", "diffHunk": "@@ -56,6 +56,7 @@\n     public static final short OP_FINISH_CONSISTENCY_CHECK = 29;\n     public static final short OP_RENAME_ROLLUP = 120;\n     public static final short OP_ALTER_JOB_V2 = 121;\n+    public static final short OP_BATCH_ALTER_JOB_V2 = 123;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NjYwNA==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376756604", "createdAt": "2020-02-09T05:34:52Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/persist/OperationType.java", "diffHunk": "@@ -56,6 +56,7 @@\n     public static final short OP_FINISH_CONSISTENCY_CHECK = 29;\n     public static final short OP_RENAME_ROLLUP = 120;\n     public static final short OP_ALTER_JOB_V2 = 121;\n+    public static final short OP_BATCH_ALTER_JOB_V2 = 123;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMTIxNA=="}, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDA2NzY1OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/SchemaChangeHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMDoxNTowOVrOFnQBYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQwNTozNTo1MFrOFnTZpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMTI4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        schemaChangeJobV2 = schemaChangeJobV2List.size() == 0 ? schemaChangeJobV2 : Iterables.getOnlyElement(schemaChangeJobV2List);\n          \n          \n            \n                        schemaChangeJobV2 = schemaChangeJobV2List.size() == 0 ? null : Iterables.getOnlyElement(schemaChangeJobV2List);", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376701280", "createdAt": "2020-02-08T10:15:09Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/alter/SchemaChangeHandler.java", "diffHunk": "@@ -1436,7 +1437,8 @@ public void cancel(CancelStmt stmt) throws DdlException {\n             }\n \n             // find from new alter jobs first\n-            schemaChangeJobV2 = getUnfinishedAlterJobV2(olapTable.getId());\n+            List<AlterJobV2> schemaChangeJobV2List = getUnfinishedAlterJobV2ByTableId(olapTable.getId());\n+            schemaChangeJobV2 = schemaChangeJobV2List.size() == 0 ? schemaChangeJobV2 : Iterables.getOnlyElement(schemaChangeJobV2List);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMTMwOQ==", "bodyText": "And add comment to explain why there should be only one job in the schemaChangeJobV2List", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376701309", "createdAt": "2020-02-08T10:15:48Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/alter/SchemaChangeHandler.java", "diffHunk": "@@ -1436,7 +1437,8 @@ public void cancel(CancelStmt stmt) throws DdlException {\n             }\n \n             // find from new alter jobs first\n-            schemaChangeJobV2 = getUnfinishedAlterJobV2(olapTable.getId());\n+            List<AlterJobV2> schemaChangeJobV2List = getUnfinishedAlterJobV2ByTableId(olapTable.getId());\n+            schemaChangeJobV2 = schemaChangeJobV2List.size() == 0 ? schemaChangeJobV2 : Iterables.getOnlyElement(schemaChangeJobV2List);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMTI4MA=="}, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NjY0NQ==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376756645", "createdAt": "2020-02-09T05:35:50Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/SchemaChangeHandler.java", "diffHunk": "@@ -1436,7 +1437,8 @@ public void cancel(CancelStmt stmt) throws DdlException {\n             }\n \n             // find from new alter jobs first\n-            schemaChangeJobV2 = getUnfinishedAlterJobV2(olapTable.getId());\n+            List<AlterJobV2> schemaChangeJobV2List = getUnfinishedAlterJobV2ByTableId(olapTable.getId());\n+            schemaChangeJobV2 = schemaChangeJobV2List.size() == 0 ? schemaChangeJobV2 : Iterables.getOnlyElement(schemaChangeJobV2List);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwMTI4MA=="}, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDEyNjg0OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/RollupJobV2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMjo1OTo1NVrOFnQeuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQwNTozNjoxMlrOFnTZtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwODc5Mg==", "bodyText": "wrap the comment, its too long in one line", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376708792", "createdAt": "2020-02-08T12:59:55Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/alter/RollupJobV2.java", "diffHunk": "@@ -305,7 +305,9 @@ protected void runWaitingTxnJob() throws AlterCancelException {\n         if (db == null) {\n             throw new AlterCancelException(\"Databasee \" + dbId + \" does not exist\");\n         }\n-        \n+\n+        // TODO(wangbo): 2020/2/4 in the case that the [WaitingTxnJob|PendingJob] is checkpointed and replayMethod won't be called, make sure the tablet meta exists in olapTable and TabletInvertedIndex before doris run", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NjY2MA==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376756660", "createdAt": "2020-02-09T05:36:12Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/RollupJobV2.java", "diffHunk": "@@ -305,7 +305,9 @@ protected void runWaitingTxnJob() throws AlterCancelException {\n         if (db == null) {\n             throw new AlterCancelException(\"Databasee \" + dbId + \" does not exist\");\n         }\n-        \n+\n+        // TODO(wangbo): 2020/2/4 in the case that the [WaitingTxnJob|PendingJob] is checkpointed and replayMethod won't be called, make sure the tablet meta exists in olapTable and TabletInvertedIndex before doris run", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwODc5Mg=="}, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDEyNzgzOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/RollupJobV2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMzowMjo1MlrOFnQfRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQwNTozNjoyNVrOFnTZuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwODkzMw==", "bodyText": "Add a comment here to explain why after replaying the pending job,\nthe state is still PENDING:\nto make sure that this job will run runPendingJob() again to create the rollup replicas", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376708933", "createdAt": "2020-02-08T13:02:52Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/alter/RollupJobV2.java", "diffHunk": "@@ -614,33 +614,35 @@ private void replayPending(RollupJobV2 replayedJob) {\n                 // table may be dropped before replaying this log. just return\n                 return;\n             }\n-\n-            // add all rollup replicas to tablet inverted index\n-            TabletInvertedIndex invertedIndex = Catalog.getCurrentInvertedIndex();\n-            for (Long partitionId : partitionIdToRollupIndex.keySet()) {\n-                MaterializedIndex rollupIndex = partitionIdToRollupIndex.get(partitionId);\n-                TStorageMedium medium = tbl.getPartitionInfo().getDataProperty(partitionId).getStorageMedium();\n-                TabletMeta rollupTabletMeta = new TabletMeta(dbId, tableId, partitionId, rollupIndexId,\n-                        rollupSchemaHash, medium);\n-\n-                for (Tablet rollupTablet : rollupIndex.getTablets()) {\n-                    invertedIndex.addTablet(rollupTablet.getId(), rollupTabletMeta);\n-                    for (Replica rollupReplica : rollupTablet.getReplicas()) {\n-                        invertedIndex.addReplica(rollupTablet.getId(), rollupReplica);\n-                    }\n-                }\n-            }\n-            tbl.setState(OlapTableState.ROLLUP);\n+            addTabletToInvertedIndex(tbl);\n         } finally {\n             db.writeUnlock();\n         }\n \n-        this.jobState = JobState.WAITING_TXN;\n+        this.jobState = JobState.PENDING;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NjY2Nw==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376756667", "createdAt": "2020-02-09T05:36:25Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/RollupJobV2.java", "diffHunk": "@@ -614,33 +614,35 @@ private void replayPending(RollupJobV2 replayedJob) {\n                 // table may be dropped before replaying this log. just return\n                 return;\n             }\n-\n-            // add all rollup replicas to tablet inverted index\n-            TabletInvertedIndex invertedIndex = Catalog.getCurrentInvertedIndex();\n-            for (Long partitionId : partitionIdToRollupIndex.keySet()) {\n-                MaterializedIndex rollupIndex = partitionIdToRollupIndex.get(partitionId);\n-                TStorageMedium medium = tbl.getPartitionInfo().getDataProperty(partitionId).getStorageMedium();\n-                TabletMeta rollupTabletMeta = new TabletMeta(dbId, tableId, partitionId, rollupIndexId,\n-                        rollupSchemaHash, medium);\n-\n-                for (Tablet rollupTablet : rollupIndex.getTablets()) {\n-                    invertedIndex.addTablet(rollupTablet.getId(), rollupTabletMeta);\n-                    for (Replica rollupReplica : rollupTablet.getReplicas()) {\n-                        invertedIndex.addReplica(rollupTablet.getId(), rollupReplica);\n-                    }\n-                }\n-            }\n-            tbl.setState(OlapTableState.ROLLUP);\n+            addTabletToInvertedIndex(tbl);\n         } finally {\n             db.writeUnlock();\n         }\n \n-        this.jobState = JobState.WAITING_TXN;\n+        this.jobState = JobState.PENDING;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwODkzMw=="}, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDEzMjI2OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMzoxNTowM1rOFnQhhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMzoxNTowM1rOFnQhhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwOTUwOA==", "bodyText": "\"batch drop rollup\" operation should still be atomic when writing meta log.\nSo you need to modify the processDropRollup():\n\n\nFirst, traverse all drop clauses to validate them, such as whether to drop the base index, does the rollup index need to be dropped exist.\n\n\nDo the real drop operation. And all-or-non rollups should be dropped.\n\n\nWrite a edit log named BatchDropRollupOperationLog to persist the meta.", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376709508", "createdAt": "2020-02-08T13:15:03Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -507,6 +608,12 @@ private long checkAndGetBaseIndex(String baseIndexName, OlapTable olapTable) thr\n         return baseIndexId;\n     }\n \n+    public void processBatchDropRollup (List<AlterClause> dropRollupClauses, Database db, OlapTable olapTable) throws DdlException {\n+        for (AlterClause dropRollupClause : dropRollupClauses) {\n+            processDropRollup((DropRollupClause)dropRollupClause, db, olapTable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 308}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDEzNDQxOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMzoyMDo0NFrOFnQiiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQwNTozNjo1M1rOFnTZ3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwOTc3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // keep table's not final state job size. The job size determine's table's state, = 0 means table is normal,otherwrise is rollup\n          \n          \n            \n                // keep table's not final state job size. The job size determine's table's state, = 0 means table is normal, otherwise is rollup", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376709771", "createdAt": "2020-02-08T13:20:44Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -85,6 +88,54 @@ public MaterializedViewHandler() {\n         super(\"materialized view\");\n     }\n \n+\n+    // for batch submit rollup job, tableId -> jobId\n+    // keep table's not final state job size. The job size determine's table's state, = 0 means table is normal,otherwrise is rollup", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NjcwMA==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376756700", "createdAt": "2020-02-09T05:36:53Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -85,6 +88,54 @@ public MaterializedViewHandler() {\n         super(\"materialized view\");\n     }\n \n+\n+    // for batch submit rollup job, tableId -> jobId\n+    // keep table's not final state job size. The job size determine's table's state, = 0 means table is normal,otherwrise is rollup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwOTc3MQ=="}, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDEzNTY3OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMzoyNDoxNVrOFnQjJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQxNDozMDoxN1rOFnVVZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwOTkyNA==", "bodyText": "Can it be an assertion? I found there is no way to add an already-done job here.", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376709924", "createdAt": "2020-02-08T13:24:15Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -85,6 +88,54 @@ public MaterializedViewHandler() {\n         super(\"materialized view\");\n     }\n \n+\n+    // for batch submit rollup job, tableId -> jobId\n+    // keep table's not final state job size. The job size determine's table's state, = 0 means table is normal,otherwrise is rollup\n+    private Map<Long, Set<Long>> tableNotFinalStateJobMap = new ConcurrentHashMap<>();\n+    // keep table's running job,used for concurrency limit\n+    private Map<Long, Set<Long>> tableRunningJobMap = new ConcurrentHashMap<>();\n+\n+    public synchronized void addAlterJobV2(AlterJobV2 alterJob) {\n+        super.addAlterJobV2(alterJob);\n+        addAlterJobV2ToTableNotFinalStateJobMap(alterJob);\n+    }\n+\n+    protected synchronized void batchAddAlterJobV2(List<AlterJobV2> alterJobV2List) {\n+        for (AlterJobV2 alterJobV2 : alterJobV2List) {\n+            addAlterJobV2(alterJobV2);\n+        }\n+    }\n+\n+    private void addAlterJobV2ToTableNotFinalStateJobMap(AlterJobV2 alterJobV2) {\n+        if (alterJobV2.isDone()) {\n+            LOG.warn(\"try to add a final job({}) to a unfinal set\", alterJobV2.getJobId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc4ODMyNQ==", "bodyText": "job replay will add a done job", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376788325", "createdAt": "2020-02-09T14:30:17Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -85,6 +88,54 @@ public MaterializedViewHandler() {\n         super(\"materialized view\");\n     }\n \n+\n+    // for batch submit rollup job, tableId -> jobId\n+    // keep table's not final state job size. The job size determine's table's state, = 0 means table is normal,otherwrise is rollup\n+    private Map<Long, Set<Long>> tableNotFinalStateJobMap = new ConcurrentHashMap<>();\n+    // keep table's running job,used for concurrency limit\n+    private Map<Long, Set<Long>> tableRunningJobMap = new ConcurrentHashMap<>();\n+\n+    public synchronized void addAlterJobV2(AlterJobV2 alterJob) {\n+        super.addAlterJobV2(alterJob);\n+        addAlterJobV2ToTableNotFinalStateJobMap(alterJob);\n+    }\n+\n+    protected synchronized void batchAddAlterJobV2(List<AlterJobV2> alterJobV2List) {\n+        for (AlterJobV2 alterJobV2 : alterJobV2List) {\n+            addAlterJobV2(alterJobV2);\n+        }\n+    }\n+\n+    private void addAlterJobV2ToTableNotFinalStateJobMap(AlterJobV2 alterJobV2) {\n+        if (alterJobV2.isDone()) {\n+            LOG.warn(\"try to add a final job({}) to a unfinal set\", alterJobV2.getJobId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcwOTkyNA=="}, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDEzNjQyOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMzoyNjoyNlrOFnQjgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQwNTozOToyN1rOFnTaUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcxMDAxNg==", "bodyText": "Add comment to explain return value's meaning.", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376710016", "createdAt": "2020-02-08T13:26:26Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -85,6 +88,54 @@ public MaterializedViewHandler() {\n         super(\"materialized view\");\n     }\n \n+\n+    // for batch submit rollup job, tableId -> jobId\n+    // keep table's not final state job size. The job size determine's table's state, = 0 means table is normal,otherwrise is rollup\n+    private Map<Long, Set<Long>> tableNotFinalStateJobMap = new ConcurrentHashMap<>();\n+    // keep table's running job,used for concurrency limit\n+    private Map<Long, Set<Long>> tableRunningJobMap = new ConcurrentHashMap<>();\n+\n+    public synchronized void addAlterJobV2(AlterJobV2 alterJob) {\n+        super.addAlterJobV2(alterJob);\n+        addAlterJobV2ToTableNotFinalStateJobMap(alterJob);\n+    }\n+\n+    protected synchronized void batchAddAlterJobV2(List<AlterJobV2> alterJobV2List) {\n+        for (AlterJobV2 alterJobV2 : alterJobV2List) {\n+            addAlterJobV2(alterJobV2);\n+        }\n+    }\n+\n+    private void addAlterJobV2ToTableNotFinalStateJobMap(AlterJobV2 alterJobV2) {\n+        if (alterJobV2.isDone()) {\n+            LOG.warn(\"try to add a final job({}) to a unfinal set\", alterJobV2.getJobId());\n+            return;\n+        }\n+        Long tableId = alterJobV2.getTableId();\n+        Long jobId = alterJobV2.getJobId();\n+        Set<Long> tableNotFinalStateJobIdSet = tableNotFinalStateJobMap.get(tableId);\n+        if (tableNotFinalStateJobIdSet == null) {\n+            tableNotFinalStateJobIdSet = new HashSet<>();\n+            tableNotFinalStateJobMap.put(tableId, tableNotFinalStateJobIdSet);\n+        }\n+        tableNotFinalStateJobIdSet.add(jobId);\n+    }\n+\n+    private boolean removeAlterJobV2FromTableNotFinalStateJobMap(AlterJobV2 alterJobV2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NjgxOA==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376756818", "createdAt": "2020-02-09T05:39:27Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -85,6 +88,54 @@ public MaterializedViewHandler() {\n         super(\"materialized view\");\n     }\n \n+\n+    // for batch submit rollup job, tableId -> jobId\n+    // keep table's not final state job size. The job size determine's table's state, = 0 means table is normal,otherwrise is rollup\n+    private Map<Long, Set<Long>> tableNotFinalStateJobMap = new ConcurrentHashMap<>();\n+    // keep table's running job,used for concurrency limit\n+    private Map<Long, Set<Long>> tableRunningJobMap = new ConcurrentHashMap<>();\n+\n+    public synchronized void addAlterJobV2(AlterJobV2 alterJob) {\n+        super.addAlterJobV2(alterJob);\n+        addAlterJobV2ToTableNotFinalStateJobMap(alterJob);\n+    }\n+\n+    protected synchronized void batchAddAlterJobV2(List<AlterJobV2> alterJobV2List) {\n+        for (AlterJobV2 alterJobV2 : alterJobV2List) {\n+            addAlterJobV2(alterJobV2);\n+        }\n+    }\n+\n+    private void addAlterJobV2ToTableNotFinalStateJobMap(AlterJobV2 alterJobV2) {\n+        if (alterJobV2.isDone()) {\n+            LOG.warn(\"try to add a final job({}) to a unfinal set\", alterJobV2.getJobId());\n+            return;\n+        }\n+        Long tableId = alterJobV2.getTableId();\n+        Long jobId = alterJobV2.getJobId();\n+        Set<Long> tableNotFinalStateJobIdSet = tableNotFinalStateJobMap.get(tableId);\n+        if (tableNotFinalStateJobIdSet == null) {\n+            tableNotFinalStateJobIdSet = new HashSet<>();\n+            tableNotFinalStateJobMap.put(tableId, tableNotFinalStateJobIdSet);\n+        }\n+        tableNotFinalStateJobIdSet.add(jobId);\n+    }\n+\n+    private boolean removeAlterJobV2FromTableNotFinalStateJobMap(AlterJobV2 alterJobV2) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcxMDAxNg=="}, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDE0Nzg0OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxMzo1NjowOFrOFnQpJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQxNDozNjoyMVrOFnVXGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcxMTQ2Mw==", "bodyText": "getUnfinishedAlterJobV2ByJobId() may return null if job does not exist, so rollupJobV2List may contains null. You didn't check it when using it after.\nAnother problem is, batch cancel operation can be partial success in your implementation.\nAlthough I advocate all operations to avoid partial success. But for cancel operation, this change may be slightly more complicated. A two-phase protocal may be needed to achieve this.\nSo if you keep the current implementation. The first requirement is to allow the user to specify a non-existing job id to cancel. Second, the document needs to indicate that there may be partial success here, and the user needs to retry multiple times until a successful message is returned.", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376711463", "createdAt": "2020-02-08T13:56:08Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -830,8 +1008,14 @@ public void cancel(CancelStmt stmt) throws DdlException {\n             }\n \n             // find from new alter jobs first\n-            rollupJobV2 = getUnfinishedAlterJobV2(olapTable.getId());\n-            if (rollupJobV2 == null) {\n+            if (cancelAlterTableStmt.getAlterJobIdList() != null) {\n+                for (Long jobId : cancelAlterTableStmt.getAlterJobIdList()) {\n+                    rollupJobV2List.add(getUnfinishedAlterJobV2ByJobId(jobId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 475}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc4ODc2MQ==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/2781#discussion_r376788761", "createdAt": "2020-02-09T14:36:21Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/alter/MaterializedViewHandler.java", "diffHunk": "@@ -830,8 +1008,14 @@ public void cancel(CancelStmt stmt) throws DdlException {\n             }\n \n             // find from new alter jobs first\n-            rollupJobV2 = getUnfinishedAlterJobV2(olapTable.getId());\n-            if (rollupJobV2 == null) {\n+            if (cancelAlterTableStmt.getAlterJobIdList() != null) {\n+                for (Long jobId : cancelAlterTableStmt.getAlterJobIdList()) {\n+                    rollupJobV2List.add(getUnfinishedAlterJobV2ByJobId(jobId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcxMTQ2Mw=="}, "originalCommit": {"oid": "e6e99b7e757762f44cfd0ca67f4026a08bd0859e"}, "originalPosition": 475}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2133, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}