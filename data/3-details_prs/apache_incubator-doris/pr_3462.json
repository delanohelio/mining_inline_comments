{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNzcyMDI4", "number": 3462, "title": "[Memory Engine] Add hash index implementation", "bodyText": "This commit adds a hash index implementation for memory engine, it maps uint64_t hashcode(key) to uint32_t rowid(value). This hash index is different from the classical hash table in many ways:\n\nTo save memory usage, it does store value (only rowid), user need to follow the rowid and get the actual rowkey and check rowkey equality.\nOnly support insertion, no delete support\nOne writer/multi-reader concurrency support\n\nIt's specially designed for the memory storage engine.", "createdAt": "2020-05-04T07:01:17Z", "url": "https://github.com/apache/incubator-doris/pull/3462", "merged": true, "mergeCommit": {"oid": "73999974332362a3874bedb7d64cbd3f177718ec"}, "closed": true, "closedAt": "2020-05-06T15:37:26Z", "author": {"login": "decster"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcd5vCRgH2gAyNDEyNzcyMDI4OjYxNDQxMWMyNTQ5NGUyODQ5ZDI3M2E3ZDQ0ZTJlYzFiNGU4MGZiNTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcen24PgFqTQwNjU2MjkxNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "614411c25494e2849d273a7d44e2ec1b4e80fb55", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/614411c25494e2849d273a7d44e2ec1b4e80fb55", "committedDate": "2020-05-04T06:45:51Z", "message": "[Memory Engine] Add hash index implementation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NzY1Njg2", "url": "https://github.com/apache/incubator-doris/pull/3462#pullrequestreview-404765686", "createdAt": "2020-05-04T07:43:05Z", "commit": {"oid": "614411c25494e2849d273a7d44e2ec1b4e80fb55"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzo0MzowNVrOGP1nXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzo0MzowNVrOGP1nXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI2MDI1NQ==", "bodyText": "better using pointer to indicate that this is a output arguments:\nstd::vector<uint32_t>* entries\nAnd either & and * is better to attach to the left element.", "url": "https://github.com/apache/incubator-doris/pull/3462#discussion_r419260255", "createdAt": "2020-05-04T07:43:05Z", "author": {"login": "morningman"}, "path": "be/src/olap/memory/hash_index.h", "diffHunk": "@@ -0,0 +1,91 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_MEMORY_HASH_INDEX_H_\n+#define DORIS_BE_SRC_OLAP_MEMORY_HASH_INDEX_H_\n+\n+#include <stdint.h>\n+#include <atomic>\n+#include <string>\n+#include \"gutil/ref_counted.h\"\n+\n+namespace doris {\n+\n+struct HashChunk;\n+\n+// A hash index, which maps uint64_t hashcode(key) to uint32_t rowid(value).\n+//\n+// From the user's perspective, it doesn't store row-key values, so when user\n+// lookup a row-key, user need to first calculate row-key's hashcode, then\n+// query the hash index to get a list of candidate rowids, then check all\n+// the candidates rowids for equality.\n+//\n+// Note: this hash index do not support delete.\n+//\n+// Note: This hash index is thread-safe, but it only support\n+// single-writer/multi-reader style concurrency. When hash index reaches it's\n+// capacity, a writer need to expand&rebuild, this is not thread-safe, so the\n+// writer need to do a copy-on-write, and make it's owner to link to the new\n+// reference, while readers still reading the old reference.\n+//\n+// Note: for more info, please refer to:\n+// https://engineering.fb.com/developer-tools/f14/\n+class HashIndex : public RefCountedThreadSafe<HashIndex> {\n+public:\n+    static const uint64_t npos = (uint64_t)-1;\n+\n+    // Create hash index with capacity\n+    HashIndex(size_t capacity);\n+    ~HashIndex();\n+\n+    // Return number of elements\n+    size_t size() const { return _size; }\n+\n+    // Return max number of elements this hash index can hold\n+    // If size >= max_size, this hash index needs to expand and rebuild\n+    size_t max_size() const { return _max_size; }\n+\n+    // Find by key hash, put all candidate values into entries,\n+    // and return a entry position, so later user can use this position to\n+    // add a value with the same key hash directly into this hash index.\n+    uint64_t find(uint64_t key_hash, std::vector<uint32_t> &entries) const;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "614411c25494e2849d273a7d44e2ec1b4e80fb55"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MDg0MDE3", "url": "https://github.com/apache/incubator-doris/pull/3462#pullrequestreview-405084017", "createdAt": "2020-05-04T15:13:55Z", "commit": {"oid": "614411c25494e2849d273a7d44e2ec1b4e80fb55"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNToxMzo1NlrOGQE-9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNToyODo1M1rOGQFoqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxMjA1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        uint64_t step =  tag*2+1; // 1;\n          \n          \n            \n                        uint64_t step =  tag * 2 + 1; // 1;\n          \n      \n    \n    \n  \n\nAnd what is the comment 1 for?", "url": "https://github.com/apache/incubator-doris/pull/3462#discussion_r419512052", "createdAt": "2020-05-04T15:13:56Z", "author": {"login": "morningman"}, "path": "be/src/olap/memory/hash_index.cpp", "diffHunk": "@@ -0,0 +1,161 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <emmintrin.h>\n+#include <stdio.h>\n+#include <algorithm>\n+#include \"gutil/stringprintf.h\"\n+#include \"olap/memory/hash_index.h\"\n+\n+namespace doris {\n+\n+using TagVector = __m128i;\n+\n+struct alignas(64) HashChunk {\n+    static const uint32_t CAPACITY = 12;\n+    uint8_t tags[12];\n+    std::atomic<uint32_t> size;\n+    uint32_t values[12];\n+\n+    TagVector* tagVector() {\n+        return (TagVector*)tags;\n+    }\n+\n+    const std::string dump() const {\n+        std::string ret;\n+        StringPrintf(\"[\");\n+        for (uint32_t i=0;i<std::min((uint32_t)size, (uint32_t)12);i++) {\n+            printf(\"%6u(%02x)\", values[i], (uint32_t)tags[i]);\n+        }\n+        printf(\"]\\n\");\n+        return ret;\n+    }\n+};\n+\n+const uint64_t HashIndex::npos;\n+\n+HashIndex::HashIndex(size_t capacity) :\n+        _size(0), _max_size(0), _num_chunks(0), _chunk_mask(0),\n+        _chunks(NULL) {\n+    size_t min_chunk = (capacity * 14 / 12 + HashChunk::CAPACITY - 1) / HashChunk::CAPACITY;\n+    if (min_chunk == 0) {\n+        return;\n+    }\n+    size_t nc = 1;\n+    while (nc < min_chunk) {\n+        nc *= 2;\n+    }\n+    _chunks = (HashChunk*)aligned_malloc(nc*64, 64);\n+    if (_chunks) {\n+        _num_chunks = nc;\n+        _chunk_mask = nc - 1;\n+        memset(_chunks, 0, _num_chunks*64);\n+        _max_size = _num_chunks * HashChunk::CAPACITY * 12 / 14;\n+    }\n+}\n+\n+HashIndex::~HashIndex() {\n+    if (_chunks) {\n+        free(_chunks);\n+        _chunks = 0;\n+        _size = 0;\n+        _max_size = 0;\n+        _num_chunks = 0;\n+        _chunk_mask = 0;\n+    }\n+}\n+\n+uint64_t HashIndex::find(uint64_t key_hash, std::vector<uint32_t> &entries) const {\n+    uint64_t tag = key_hash & 0xff;\n+    if (tag == 0) {\n+        tag = 1;\n+    }\n+    uint64_t pos = (key_hash >> 8) & _chunk_mask;\n+    uint64_t orig_pos = pos;\n+    auto tests = _mm_set1_epi8(static_cast<uint8_t>(tag));\n+    while (true) {\n+        HashChunk& chunk = _chunks[pos];\n+        uint32_t sz = chunk.size.load(std::memory_order_acquire);\n+        auto tags = _mm_load_si128(chunk.tagVector());\n+        auto eqs = _mm_cmpeq_epi8(tags, tests);\n+        uint32_t mask = _mm_movemask_epi8(eqs) & 0xfff;\n+        while (mask != 0) {\n+            uint32_t i = __builtin_ctz(mask);\n+            mask &= (mask -1);\n+            entries.emplace_back(chunk.values[i]);\n+        }\n+        if (sz == HashChunk::CAPACITY) {\n+            uint64_t step =  tag*2+1; // 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "614411c25494e2849d273a7d44e2ec1b4e80fb55"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxMzQ0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        uint64_t step =  tag*2+1; // 1;\n          \n          \n            \n                        uint64_t step =  tag * 2 + 1; // 1;", "url": "https://github.com/apache/incubator-doris/pull/3462#discussion_r419513440", "createdAt": "2020-05-04T15:15:52Z", "author": {"login": "morningman"}, "path": "be/src/olap/memory/hash_index.cpp", "diffHunk": "@@ -0,0 +1,161 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <emmintrin.h>\n+#include <stdio.h>\n+#include <algorithm>\n+#include \"gutil/stringprintf.h\"\n+#include \"olap/memory/hash_index.h\"\n+\n+namespace doris {\n+\n+using TagVector = __m128i;\n+\n+struct alignas(64) HashChunk {\n+    static const uint32_t CAPACITY = 12;\n+    uint8_t tags[12];\n+    std::atomic<uint32_t> size;\n+    uint32_t values[12];\n+\n+    TagVector* tagVector() {\n+        return (TagVector*)tags;\n+    }\n+\n+    const std::string dump() const {\n+        std::string ret;\n+        StringPrintf(\"[\");\n+        for (uint32_t i=0;i<std::min((uint32_t)size, (uint32_t)12);i++) {\n+            printf(\"%6u(%02x)\", values[i], (uint32_t)tags[i]);\n+        }\n+        printf(\"]\\n\");\n+        return ret;\n+    }\n+};\n+\n+const uint64_t HashIndex::npos;\n+\n+HashIndex::HashIndex(size_t capacity) :\n+        _size(0), _max_size(0), _num_chunks(0), _chunk_mask(0),\n+        _chunks(NULL) {\n+    size_t min_chunk = (capacity * 14 / 12 + HashChunk::CAPACITY - 1) / HashChunk::CAPACITY;\n+    if (min_chunk == 0) {\n+        return;\n+    }\n+    size_t nc = 1;\n+    while (nc < min_chunk) {\n+        nc *= 2;\n+    }\n+    _chunks = (HashChunk*)aligned_malloc(nc*64, 64);\n+    if (_chunks) {\n+        _num_chunks = nc;\n+        _chunk_mask = nc - 1;\n+        memset(_chunks, 0, _num_chunks*64);\n+        _max_size = _num_chunks * HashChunk::CAPACITY * 12 / 14;\n+    }\n+}\n+\n+HashIndex::~HashIndex() {\n+    if (_chunks) {\n+        free(_chunks);\n+        _chunks = 0;\n+        _size = 0;\n+        _max_size = 0;\n+        _num_chunks = 0;\n+        _chunk_mask = 0;\n+    }\n+}\n+\n+uint64_t HashIndex::find(uint64_t key_hash, std::vector<uint32_t> &entries) const {\n+    uint64_t tag = key_hash & 0xff;\n+    if (tag == 0) {\n+        tag = 1;\n+    }\n+    uint64_t pos = (key_hash >> 8) & _chunk_mask;\n+    uint64_t orig_pos = pos;\n+    auto tests = _mm_set1_epi8(static_cast<uint8_t>(tag));\n+    while (true) {\n+        HashChunk& chunk = _chunks[pos];\n+        uint32_t sz = chunk.size.load(std::memory_order_acquire);\n+        auto tags = _mm_load_si128(chunk.tagVector());\n+        auto eqs = _mm_cmpeq_epi8(tags, tests);\n+        uint32_t mask = _mm_movemask_epi8(eqs) & 0xfff;\n+        while (mask != 0) {\n+            uint32_t i = __builtin_ctz(mask);\n+            mask &= (mask -1);\n+            entries.emplace_back(chunk.values[i]);\n+        }\n+        if (sz == HashChunk::CAPACITY) {\n+            uint64_t step =  tag*2+1; // 1;\n+            pos = (pos + step) & _chunk_mask;\n+            if (pos == orig_pos) {\n+                return npos;\n+            }\n+        } else {\n+            return (pos << 4) | sz;\n+        }\n+    }\n+}\n+\n+void HashIndex::set(uint64_t slot, uint64_t key_hash, uint32_t value) {\n+    uint64_t pos = slot >> 4;\n+    uint64_t tpos = slot & 0xf;\n+    HashChunk& chunk = _chunks[pos];\n+    uint64_t tag = key_hash & 0xff;\n+    if (tag == 0) {\n+        tag = 1;\n+    }\n+    chunk.tags[tpos] = tag;\n+    chunk.values[tpos] = value;\n+    if (tpos == chunk.size) {\n+        chunk.size.store(tpos+1, std::memory_order_release);\n+        _size++;\n+    }\n+}\n+\n+bool HashIndex::add(uint64_t key_hash, uint32_t value) {\n+    uint64_t tag = key_hash & 0xff;\n+    if (tag == 0) {\n+        tag = 1;\n+    }\n+    uint64_t pos = (key_hash >> 8) & _chunk_mask;\n+    uint64_t orig_pos = pos;\n+    while (true) {\n+        HashChunk& chunk = _chunks[pos];\n+        if (chunk.size == HashChunk::CAPACITY) {\n+            uint64_t step =  tag*2+1; // 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "614411c25494e2849d273a7d44e2ec1b4e80fb55"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUyMTgxNA==", "bodyText": "Why here we use store() method, but in HashIndex::add, it simply use chunk.size++?", "url": "https://github.com/apache/incubator-doris/pull/3462#discussion_r419521814", "createdAt": "2020-05-04T15:27:39Z", "author": {"login": "morningman"}, "path": "be/src/olap/memory/hash_index.cpp", "diffHunk": "@@ -0,0 +1,161 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <emmintrin.h>\n+#include <stdio.h>\n+#include <algorithm>\n+#include \"gutil/stringprintf.h\"\n+#include \"olap/memory/hash_index.h\"\n+\n+namespace doris {\n+\n+using TagVector = __m128i;\n+\n+struct alignas(64) HashChunk {\n+    static const uint32_t CAPACITY = 12;\n+    uint8_t tags[12];\n+    std::atomic<uint32_t> size;\n+    uint32_t values[12];\n+\n+    TagVector* tagVector() {\n+        return (TagVector*)tags;\n+    }\n+\n+    const std::string dump() const {\n+        std::string ret;\n+        StringPrintf(\"[\");\n+        for (uint32_t i=0;i<std::min((uint32_t)size, (uint32_t)12);i++) {\n+            printf(\"%6u(%02x)\", values[i], (uint32_t)tags[i]);\n+        }\n+        printf(\"]\\n\");\n+        return ret;\n+    }\n+};\n+\n+const uint64_t HashIndex::npos;\n+\n+HashIndex::HashIndex(size_t capacity) :\n+        _size(0), _max_size(0), _num_chunks(0), _chunk_mask(0),\n+        _chunks(NULL) {\n+    size_t min_chunk = (capacity * 14 / 12 + HashChunk::CAPACITY - 1) / HashChunk::CAPACITY;\n+    if (min_chunk == 0) {\n+        return;\n+    }\n+    size_t nc = 1;\n+    while (nc < min_chunk) {\n+        nc *= 2;\n+    }\n+    _chunks = (HashChunk*)aligned_malloc(nc*64, 64);\n+    if (_chunks) {\n+        _num_chunks = nc;\n+        _chunk_mask = nc - 1;\n+        memset(_chunks, 0, _num_chunks*64);\n+        _max_size = _num_chunks * HashChunk::CAPACITY * 12 / 14;\n+    }\n+}\n+\n+HashIndex::~HashIndex() {\n+    if (_chunks) {\n+        free(_chunks);\n+        _chunks = 0;\n+        _size = 0;\n+        _max_size = 0;\n+        _num_chunks = 0;\n+        _chunk_mask = 0;\n+    }\n+}\n+\n+uint64_t HashIndex::find(uint64_t key_hash, std::vector<uint32_t> &entries) const {\n+    uint64_t tag = key_hash & 0xff;\n+    if (tag == 0) {\n+        tag = 1;\n+    }\n+    uint64_t pos = (key_hash >> 8) & _chunk_mask;\n+    uint64_t orig_pos = pos;\n+    auto tests = _mm_set1_epi8(static_cast<uint8_t>(tag));\n+    while (true) {\n+        HashChunk& chunk = _chunks[pos];\n+        uint32_t sz = chunk.size.load(std::memory_order_acquire);\n+        auto tags = _mm_load_si128(chunk.tagVector());\n+        auto eqs = _mm_cmpeq_epi8(tags, tests);\n+        uint32_t mask = _mm_movemask_epi8(eqs) & 0xfff;\n+        while (mask != 0) {\n+            uint32_t i = __builtin_ctz(mask);\n+            mask &= (mask -1);\n+            entries.emplace_back(chunk.values[i]);\n+        }\n+        if (sz == HashChunk::CAPACITY) {\n+            uint64_t step =  tag*2+1; // 1;\n+            pos = (pos + step) & _chunk_mask;\n+            if (pos == orig_pos) {\n+                return npos;\n+            }\n+        } else {\n+            return (pos << 4) | sz;\n+        }\n+    }\n+}\n+\n+void HashIndex::set(uint64_t slot, uint64_t key_hash, uint32_t value) {\n+    uint64_t pos = slot >> 4;\n+    uint64_t tpos = slot & 0xf;\n+    HashChunk& chunk = _chunks[pos];\n+    uint64_t tag = key_hash & 0xff;\n+    if (tag == 0) {\n+        tag = 1;\n+    }\n+    chunk.tags[tpos] = tag;\n+    chunk.values[tpos] = value;\n+    if (tpos == chunk.size) {\n+        chunk.size.store(tpos+1, std::memory_order_release);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "614411c25494e2849d273a7d44e2ec1b4e80fb55"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUyMjcyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        mask &= (mask -1);\n          \n          \n            \n                        mask &= (mask - 1);", "url": "https://github.com/apache/incubator-doris/pull/3462#discussion_r419522729", "createdAt": "2020-05-04T15:28:53Z", "author": {"login": "morningman"}, "path": "be/src/olap/memory/hash_index.cpp", "diffHunk": "@@ -0,0 +1,161 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <emmintrin.h>\n+#include <stdio.h>\n+#include <algorithm>\n+#include \"gutil/stringprintf.h\"\n+#include \"olap/memory/hash_index.h\"\n+\n+namespace doris {\n+\n+using TagVector = __m128i;\n+\n+struct alignas(64) HashChunk {\n+    static const uint32_t CAPACITY = 12;\n+    uint8_t tags[12];\n+    std::atomic<uint32_t> size;\n+    uint32_t values[12];\n+\n+    TagVector* tagVector() {\n+        return (TagVector*)tags;\n+    }\n+\n+    const std::string dump() const {\n+        std::string ret;\n+        StringPrintf(\"[\");\n+        for (uint32_t i=0;i<std::min((uint32_t)size, (uint32_t)12);i++) {\n+            printf(\"%6u(%02x)\", values[i], (uint32_t)tags[i]);\n+        }\n+        printf(\"]\\n\");\n+        return ret;\n+    }\n+};\n+\n+const uint64_t HashIndex::npos;\n+\n+HashIndex::HashIndex(size_t capacity) :\n+        _size(0), _max_size(0), _num_chunks(0), _chunk_mask(0),\n+        _chunks(NULL) {\n+    size_t min_chunk = (capacity * 14 / 12 + HashChunk::CAPACITY - 1) / HashChunk::CAPACITY;\n+    if (min_chunk == 0) {\n+        return;\n+    }\n+    size_t nc = 1;\n+    while (nc < min_chunk) {\n+        nc *= 2;\n+    }\n+    _chunks = (HashChunk*)aligned_malloc(nc*64, 64);\n+    if (_chunks) {\n+        _num_chunks = nc;\n+        _chunk_mask = nc - 1;\n+        memset(_chunks, 0, _num_chunks*64);\n+        _max_size = _num_chunks * HashChunk::CAPACITY * 12 / 14;\n+    }\n+}\n+\n+HashIndex::~HashIndex() {\n+    if (_chunks) {\n+        free(_chunks);\n+        _chunks = 0;\n+        _size = 0;\n+        _max_size = 0;\n+        _num_chunks = 0;\n+        _chunk_mask = 0;\n+    }\n+}\n+\n+uint64_t HashIndex::find(uint64_t key_hash, std::vector<uint32_t> &entries) const {\n+    uint64_t tag = key_hash & 0xff;\n+    if (tag == 0) {\n+        tag = 1;\n+    }\n+    uint64_t pos = (key_hash >> 8) & _chunk_mask;\n+    uint64_t orig_pos = pos;\n+    auto tests = _mm_set1_epi8(static_cast<uint8_t>(tag));\n+    while (true) {\n+        HashChunk& chunk = _chunks[pos];\n+        uint32_t sz = chunk.size.load(std::memory_order_acquire);\n+        auto tags = _mm_load_si128(chunk.tagVector());\n+        auto eqs = _mm_cmpeq_epi8(tags, tests);\n+        uint32_t mask = _mm_movemask_epi8(eqs) & 0xfff;\n+        while (mask != 0) {\n+            uint32_t i = __builtin_ctz(mask);\n+            mask &= (mask -1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "614411c25494e2849d273a7d44e2ec1b4e80fb55"}, "originalPosition": 98}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d014c5cfbc0518ce97fbf1d369f81481e90c932", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/0d014c5cfbc0518ce97fbf1d369f81481e90c932", "committedDate": "2020-05-05T02:36:22Z", "message": "[Memory Engine] Add hash index implementation: use clang-format & address review issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a43e8a1c7eca4b1f595961e6181392e1d6df185a", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/a43e8a1c7eca4b1f595961e6181392e1d6df185a", "committedDate": "2020-05-05T03:15:04Z", "message": "[Memory Engine] Add hash index implementation: add non-SSE2 implementation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NjcyMTg5", "url": "https://github.com/apache/incubator-doris/pull/3462#pullrequestreview-405672189", "createdAt": "2020-05-05T10:40:33Z", "commit": {"oid": "a43e8a1c7eca4b1f595961e6181392e1d6df185a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDo0MDozM1rOGQjtwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDo0MDozM1rOGQjtwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxNTU1Mg==", "bodyText": "if __SSE2__  is undefined, the __m128i is also undefined.", "url": "https://github.com/apache/incubator-doris/pull/3462#discussion_r420015552", "createdAt": "2020-05-05T10:40:33Z", "author": {"login": "morningman"}, "path": "be/src/olap/memory/hash_index.cpp", "diffHunk": "@@ -0,0 +1,175 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/hash_index.h\"\n+\n+#include <stdio.h>\n+#ifdef __SSE2__\n+#include <emmintrin.h>\n+#endif\n+\n+#include <algorithm>\n+#include <vector>\n+\n+#include \"gutil/stringprintf.h\"\n+\n+namespace doris {\n+\n+using TagVector = __m128i;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a43e8a1c7eca4b1f595961e6181392e1d6df185a"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NjgxNzE0", "url": "https://github.com/apache/incubator-doris/pull/3462#pullrequestreview-405681714", "createdAt": "2020-05-05T10:56:37Z", "commit": {"oid": "a43e8a1c7eca4b1f595961e6181392e1d6df185a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDo1NjozN1rOGQkOIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDo1NjozN1rOGQkOIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyMzg0MQ==", "bodyText": "I think you should add some comment to elaborate the hash algorithm.\nFrom the principle and the specific addd/set/find function. SIMD also can be introduced with some description.", "url": "https://github.com/apache/incubator-doris/pull/3462#discussion_r420023841", "createdAt": "2020-05-05T10:56:37Z", "author": {"login": "chaoyli"}, "path": "be/src/olap/memory/hash_index.h", "diffHunk": "@@ -0,0 +1,92 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_MEMORY_HASH_INDEX_H_\n+#define DORIS_BE_SRC_OLAP_MEMORY_HASH_INDEX_H_\n+\n+#include <stdint.h>\n+\n+#include <atomic>\n+#include <string>\n+#include <vector>\n+\n+#include \"gutil/ref_counted.h\"\n+\n+namespace doris {\n+\n+struct HashChunk;\n+\n+// A hash index, which maps uint64_t hashcode(key) to uint32_t rowid(value).\n+//\n+// From the user's perspective, it doesn't store row-key values, so when user\n+// lookup a row-key, user need to first calculate row-key's hashcode, then\n+// query the hash index to get a list of candidate rowids, then check all\n+// the candidates rowids for equality.\n+//\n+// Note: this hash index do not support delete.\n+//\n+// Note: This hash index is thread-safe, but it only support\n+// single-writer/multi-reader style concurrency. When hash index reaches it's\n+// capacity, a writer need to expand&rebuild, this is not thread-safe, so the\n+// writer need to do a copy-on-write, and make it's owner to link to the new\n+// reference, while readers still reading the old reference.\n+//\n+// Note: for more info, please refer to:\n+// https://engineering.fb.com/developer-tools/f14/\n+class HashIndex : public RefCountedThreadSafe<HashIndex> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a43e8a1c7eca4b1f595961e6181392e1d6df185a"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70c7d34f9de5bd61f1e8f012d52b58c5ff064bbd", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/70c7d34f9de5bd61f1e8f012d52b58c5ff064bbd", "committedDate": "2020-05-05T11:00:01Z", "message": "[Memory Engine] Add hash index implementation: move __m128i in SSE2 def section"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1OTAyOTY1", "url": "https://github.com/apache/incubator-doris/pull/3462#pullrequestreview-405902965", "createdAt": "2020-05-05T15:29:28Z", "commit": {"oid": "70c7d34f9de5bd61f1e8f012d52b58c5ff064bbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNToyOToyOFrOGQu9hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNToyOToyOFrOGQu9hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE5OTgxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                uint64_t tag = key_hash & 0xff;\n          \n          \n            \n                uint64_t tag = std::max(1, key_hash & 0xff);", "url": "https://github.com/apache/incubator-doris/pull/3462#discussion_r420199814", "createdAt": "2020-05-05T15:29:28Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/memory/hash_index.cpp", "diffHunk": "@@ -0,0 +1,171 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/hash_index.h\"\n+\n+#include <stdio.h>\n+#ifdef __SSE2__\n+#include <emmintrin.h>\n+#endif\n+\n+#include <algorithm>\n+#include <vector>\n+\n+#include \"gutil/stringprintf.h\"\n+\n+namespace doris {\n+\n+struct alignas(64) HashChunk {\n+    static const uint32_t CAPACITY = 12;\n+    uint8_t tags[12];\n+    std::atomic<uint32_t> size;\n+    uint32_t values[12];\n+\n+    const std::string debug_string() const {\n+        std::string ret;\n+        StringPrintf(\"[\");\n+        for (uint32_t i = 0; i < std::min((uint32_t)size, (uint32_t)12); i++) {\n+            printf(\"%6u(%02x)\", values[i], (uint32_t)tags[i]);\n+        }\n+        printf(\"]\\n\");\n+        return ret;\n+    }\n+};\n+\n+const uint64_t HashIndex::npos;\n+\n+HashIndex::HashIndex(size_t capacity)\n+        : _size(0), _max_size(0), _num_chunks(0), _chunk_mask(0), _chunks(NULL) {\n+    size_t min_chunk = (capacity * 14 / 12 + HashChunk::CAPACITY - 1) / HashChunk::CAPACITY;\n+    if (min_chunk == 0) {\n+        return;\n+    }\n+    size_t nc = 1;\n+    while (nc < min_chunk) {\n+        nc *= 2;\n+    }\n+    _chunks = reinterpret_cast<HashChunk*>(aligned_malloc(nc * 64, 64));\n+    if (_chunks) {\n+        _num_chunks = nc;\n+        _chunk_mask = nc - 1;\n+        memset(_chunks, 0, _num_chunks * 64);\n+        _max_size = _num_chunks * HashChunk::CAPACITY * 12 / 14;\n+    }\n+}\n+\n+HashIndex::~HashIndex() {\n+    if (_chunks) {\n+        free(_chunks);\n+        _chunks = 0;\n+        _size = 0;\n+        _max_size = 0;\n+        _num_chunks = 0;\n+        _chunk_mask = 0;\n+    }\n+}\n+\n+uint64_t HashIndex::find(uint64_t key_hash, std::vector<uint32_t>* entries) const {\n+    uint64_t tag = key_hash & 0xff;\n+    if (tag == 0) {\n+        tag = 1;\n+    }\n+    uint64_t pos = (key_hash >> 8) & _chunk_mask;\n+    uint64_t orig_pos = pos;\n+#ifdef __SSE2__\n+    auto tests = _mm_set1_epi8(static_cast<uint8_t>(tag));\n+    while (true) {\n+        HashChunk& chunk = _chunks[pos];\n+        uint32_t sz = chunk.size;\n+        auto tags = _mm_load_si128(reinterpret_cast<__m128i*>(chunk.tags));\n+        auto eqs = _mm_cmpeq_epi8(tags, tests);\n+        uint32_t mask = _mm_movemask_epi8(eqs) & 0xfff;\n+        while (mask != 0) {\n+            uint32_t i = __builtin_ctz(mask);\n+            mask &= (mask - 1);\n+            entries->emplace_back(chunk.values[i]);\n+        }\n+#else\n+    // TODO: use NEON on arm platform\n+    while (true) {\n+        HashChunk& chunk = _chunks[pos];\n+        uint32_t sz = chunk.size;\n+        for (uint32_t i = 0; i < sz; i++) {\n+            if (chunk.tags[i] == (uint8_t)tag) {\n+                entries->emplace_back(chunk.values[i]);\n+            }\n+        }\n+#endif\n+        if (sz == HashChunk::CAPACITY) {\n+            uint64_t step = tag * 2 + 1;\n+            pos = (pos + step) & _chunk_mask;\n+            if (pos == orig_pos) {\n+                return npos;\n+            }\n+        } else {\n+            return (pos << 4) | sz;\n+        }\n+    }\n+}\n+\n+void HashIndex::set(uint64_t slot, uint64_t key_hash, uint32_t value) {\n+    uint64_t pos = slot >> 4;\n+    uint64_t tpos = slot & 0xf;\n+    HashChunk& chunk = _chunks[pos];\n+    uint64_t tag = key_hash & 0xff;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70c7d34f9de5bd61f1e8f012d52b58c5ff064bbd"}, "originalPosition": 128}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1747ab1acc8d6fde5f4bd29ba227cc93668ef0fd", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/1747ab1acc8d6fde5f4bd29ba227cc93668ef0fd", "committedDate": "2020-05-06T02:47:27Z", "message": "[Memory Engine] Add hash index implementation: add more comments; use std::max instead of if"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04c07d821325a5039ea3de582282e3a81b858be1", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/04c07d821325a5039ea3de582282e3a81b858be1", "committedDate": "2020-05-06T02:52:55Z", "message": "[Memory Engine] Add hash index implementation: fix comment space"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NTYyOTE3", "url": "https://github.com/apache/incubator-doris/pull/3462#pullrequestreview-406562917", "createdAt": "2020-05-06T12:30:03Z", "commit": {"oid": "04c07d821325a5039ea3de582282e3a81b858be1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2946, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}