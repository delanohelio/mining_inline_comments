{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0Mzc0NjYx", "number": 4020, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMjowNToxM1rOELhLzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMjo1MTo1M1rOELhihw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTEzNDg0OnYy", "diffSide": "RIGHT", "path": "be/src/exec/json_scanner.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMjowNToxM1rOGtG1vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMjowNToxM1rOGtG1vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MTE2NQ==", "bodyText": "I think that this code can be deleted", "url": "https://github.com/apache/incubator-doris/pull/4020#discussion_r449951165", "createdAt": "2020-07-06T02:05:13Z", "author": {"login": "worker24h"}, "path": "be/src/exec/json_scanner.cpp", "diffHunk": "@@ -360,26 +408,31 @@ Status JsonReader::set_tuple_value(rapidjson::Value& objectValue, Tuple* tuple,\n     }\n \n     if (nullcount == slot_descs.size()) {\n-        _state->append_error_msg_to_file(\"\", \"The all fields is null, this is a invalid row.\");\n+        _state->append_error_msg_to_file(_print_json_value(objectValue), \"All fields is null, this is a invalid row.\");\n         _counter->num_rows_filtered++;\n         *valid = false;\n-        return Status::OK();\n+        return;\n     }\n     *valid = true;\n-    return Status::OK();\n+    return;\n }\n \n /**\n- * handle input a simple json\n+ * handle input a simple json.\n+ * A json is a simple json only when user not specifying the json path.\n  * For example:\n  *  case 1. [{\"colunm1\":\"value1\", \"colunm2\":10}, {\"colunm1\":\"value2\", \"colunm2\":30}]\n  *  case 2. {\"colunm1\":\"value1\", \"colunm2\":10}\n  */\n-Status JsonReader::handle_simple_json(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool* eof) {\n+Status JsonReader::_handle_simple_json(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool* eof) {\n     do {\n         bool valid = false;\n         if (_next_line >= _total_lines) {//parse json and generic document\n-            RETURN_IF_ERROR(parse_json_doc(eof));\n+            Status st = _parse_json_doc(eof);\n+            if (st.is_data_quality_error()) {\n+                continue; // continue to read next\n+            }\n+            RETURN_IF_ERROR(st); // terminate if encounter other errors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7e1ce4daf7357fbee067badee7e152222fa3f7d"}, "originalPosition": 343}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTE1OTU5OnYy", "diffSide": "RIGHT", "path": "be/src/exec/json_scanner.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMjoyNjoxNFrOGtHEFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMjo1MToxM1rOGttY7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NDgzOA==", "bodyText": "I think that this code can be deleted", "url": "https://github.com/apache/incubator-doris/pull/4020#discussion_r449954838", "createdAt": "2020-07-06T02:26:14Z", "author": {"login": "worker24h"}, "path": "be/src/exec/json_scanner.cpp", "diffHunk": "@@ -406,54 +459,60 @@ Status JsonReader::handle_simple_json(Tuple* tuple, const std::vector<SlotDescri\n     return Status::OK();\n }\n \n-Status JsonReader::set_tuple_value_from_map(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool *valid) {\n+// for complex format json with strip_outer_array = false\n+Status JsonReader::_set_tuple_value_from_jmap(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool *valid) {\n     std::unordered_map<std::string, JsonDataInternal>::iterator it_map;\n     for (auto v : slot_descs) {\n         it_map = _jmap.find(v->col_name());\n         if (it_map == _jmap.end()) {\n-            return Status::RuntimeError(\"The column name of table is not foud in jsonpath.\");\n+            return Status::RuntimeError(\"The column name of table is not foud in jsonpath: \" + v->col_name());\n         }\n-        rapidjson::Value::ConstValueIterator value = it_map->second.get_next();\n+        rapidjson::Value* value = it_map->second.get_value();\n         if (value == nullptr) {\n             if (v->is_nullable()) {\n                 tuple->set_null(v->null_indicator_offset());\n             } else  {\n                 std::stringstream str_error;\n                 str_error << \"The column `\" << it_map->first << \"` is not nullable, but it's not found in jsondata.\";\n-                _state->append_error_msg_to_file(\"\", str_error.str());\n+                _state->append_error_msg_to_file(_print_json_value(*value), str_error.str());\n                 _counter->num_rows_filtered++;\n                 *valid = false; // current row is invalid\n                 break;\n             }\n         } else {\n-            RETURN_IF_ERROR(write_data_to_tuple(value, v, tuple, tuple_pool));\n+            _write_data_to_tuple(value, v, tuple, tuple_pool, valid);\n+            if (!(*valid)) {\n+                return Status::OK();\n+            }\n         }\n     }\n     *valid = true;\n     return Status::OK();\n }\n \n-Status JsonReader::handle_nest_complex_json(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool* eof) {\n+// _json_doc should be an object\n+Status JsonReader::_handle_nested_complex_json(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool* eof) {\n     do {\n         bool valid = false;\n         if (_next_line >= _total_lines) {\n-            RETURN_IF_ERROR(parse_json_doc(eof));\n-            if (*eof) {\n-                return Status::OK();\n+            Status st = _parse_json_doc(eof);\n+            if (st.is_data_quality_error()) {\n+                continue; // continue to read next\n             }\n-            _total_lines = get_data_by_jsonpath(slot_descs);\n-            if (_total_lines == -1) {\n-                return Status::InternalError(\"Parse json data is failed.\");\n-            } else if (_total_lines == 0) {\n-                *eof = true;\n+            RETURN_IF_ERROR(st); // terminate if encounter other errors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7e1ce4daf7357fbee067badee7e152222fa3f7d"}, "originalPosition": 421}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4Mjc2Nw==", "bodyText": "file reader may return other error", "url": "https://github.com/apache/incubator-doris/pull/4020#discussion_r450582767", "createdAt": "2020-07-07T02:51:13Z", "author": {"login": "morningman"}, "path": "be/src/exec/json_scanner.cpp", "diffHunk": "@@ -406,54 +459,60 @@ Status JsonReader::handle_simple_json(Tuple* tuple, const std::vector<SlotDescri\n     return Status::OK();\n }\n \n-Status JsonReader::set_tuple_value_from_map(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool *valid) {\n+// for complex format json with strip_outer_array = false\n+Status JsonReader::_set_tuple_value_from_jmap(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool *valid) {\n     std::unordered_map<std::string, JsonDataInternal>::iterator it_map;\n     for (auto v : slot_descs) {\n         it_map = _jmap.find(v->col_name());\n         if (it_map == _jmap.end()) {\n-            return Status::RuntimeError(\"The column name of table is not foud in jsonpath.\");\n+            return Status::RuntimeError(\"The column name of table is not foud in jsonpath: \" + v->col_name());\n         }\n-        rapidjson::Value::ConstValueIterator value = it_map->second.get_next();\n+        rapidjson::Value* value = it_map->second.get_value();\n         if (value == nullptr) {\n             if (v->is_nullable()) {\n                 tuple->set_null(v->null_indicator_offset());\n             } else  {\n                 std::stringstream str_error;\n                 str_error << \"The column `\" << it_map->first << \"` is not nullable, but it's not found in jsondata.\";\n-                _state->append_error_msg_to_file(\"\", str_error.str());\n+                _state->append_error_msg_to_file(_print_json_value(*value), str_error.str());\n                 _counter->num_rows_filtered++;\n                 *valid = false; // current row is invalid\n                 break;\n             }\n         } else {\n-            RETURN_IF_ERROR(write_data_to_tuple(value, v, tuple, tuple_pool));\n+            _write_data_to_tuple(value, v, tuple, tuple_pool, valid);\n+            if (!(*valid)) {\n+                return Status::OK();\n+            }\n         }\n     }\n     *valid = true;\n     return Status::OK();\n }\n \n-Status JsonReader::handle_nest_complex_json(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool* eof) {\n+// _json_doc should be an object\n+Status JsonReader::_handle_nested_complex_json(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool* eof) {\n     do {\n         bool valid = false;\n         if (_next_line >= _total_lines) {\n-            RETURN_IF_ERROR(parse_json_doc(eof));\n-            if (*eof) {\n-                return Status::OK();\n+            Status st = _parse_json_doc(eof);\n+            if (st.is_data_quality_error()) {\n+                continue; // continue to read next\n             }\n-            _total_lines = get_data_by_jsonpath(slot_descs);\n-            if (_total_lines == -1) {\n-                return Status::InternalError(\"Parse json data is failed.\");\n-            } else if (_total_lines == 0) {\n-                *eof = true;\n+            RETURN_IF_ERROR(st); // terminate if encounter other errors", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NDgzOA=="}, "originalCommit": {"oid": "e7e1ce4daf7357fbee067badee7e152222fa3f7d"}, "originalPosition": 421}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTE1OTY4OnYy", "diffSide": "RIGHT", "path": "be/src/exec/json_scanner.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMjoyNjoyMVrOGtHEJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMjoyNjoyMVrOGtHEJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NDg1Mg==", "bodyText": "I think that this code can be deleted", "url": "https://github.com/apache/incubator-doris/pull/4020#discussion_r449954852", "createdAt": "2020-07-06T02:26:21Z", "author": {"login": "worker24h"}, "path": "be/src/exec/json_scanner.cpp", "diffHunk": "@@ -471,10 +530,14 @@ Status JsonReader::handle_nest_complex_json(Tuple* tuple, const std::vector<Slot\n  *      value1     10\n  *      value2     30\n  */\n-Status JsonReader::handle_flat_array_complex_json(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool* eof) {\n+Status JsonReader::_handle_flat_array_complex_json(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool* eof) {\n     do {\n-        if (_next_line >= _total_lines) {//parse json and generic document\n-            RETURN_IF_ERROR(parse_json_doc(eof));\n+        if (_next_line >= _total_lines) {\n+            Status st = _parse_json_doc(eof);\n+            if (st.is_data_quality_error()) {\n+                continue; // continue to read next\n+            }\n+            RETURN_IF_ERROR(st); // terminate if encounter other errors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7e1ce4daf7357fbee067badee7e152222fa3f7d"}, "originalPosition": 463}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTE5MzAzOnYy", "diffSide": "RIGHT", "path": "be/src/exec/json_scanner.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMjo1MTo1M1rOGtHXrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMjo1MTo1M1rOGtHXrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1OTg1Mg==", "bodyText": "Delete it", "url": "https://github.com/apache/incubator-doris/pull/4020#discussion_r449959852", "createdAt": "2020-07-06T02:51:53Z", "author": {"login": "worker24h"}, "path": "be/src/exec/json_scanner.cpp", "diffHunk": "@@ -524,21 +593,21 @@ Status JsonReader::handle_flat_array_complex_json(Tuple* tuple, const std::vecto\n     return Status::OK();\n }\n \n-Status JsonReader::handle_complex_json(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool* eof) {\n+// handle json with specified json path\n+Status JsonReader::_handle_complex_json(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool* eof) {\n     if (_strip_outer_array) {\n-        return handle_flat_array_complex_json(tuple, slot_descs, tuple_pool, eof);\n+        return _handle_flat_array_complex_json(tuple, slot_descs, tuple_pool, eof);\n     } else {\n-        return handle_nest_complex_json(tuple, slot_descs, tuple_pool, eof);\n+        return _handle_nested_complex_json(tuple, slot_descs, tuple_pool, eof);\n     }\n }\n \n+// ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7e1ce4daf7357fbee067badee7e152222fa3f7d"}, "originalPosition": 542}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1365, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}