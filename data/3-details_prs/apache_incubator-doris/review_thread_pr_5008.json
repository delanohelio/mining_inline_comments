{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwOTEyOTQ4", "number": 5008, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTozNTowMlrOFCIhhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzo0MDo0NlrOFE_NPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NzgxMTI3OnYy", "diffSide": "RIGHT", "path": "be/src/common/config.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTozNTowMlrOIBH3HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTozNTowMlrOIBH3HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA0ODI4NA==", "bodyText": "I think it's better to give more description, such as what does the left size used for?", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538048284", "createdAt": "2020-12-08T05:35:02Z", "author": {"login": "acelyc111"}, "path": "be/src/common/config.h", "diffHunk": "@@ -260,6 +260,8 @@ CONF_Int64(index_stream_cache_capacity, \"10737418240\");\n \n // Cache for storage page size\n CONF_String(storage_page_cache_limit, \"20G\");\n+// Ratio for index page cache", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NzgxNzU0OnYy", "diffSide": "RIGHT", "path": "be/src/olap/page_cache.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTozNzoyM1rOIBH6cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTozNzoyM1rOIBH6cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA0OTEzNw==", "bodyText": "Better to define it as a static function", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538049137", "createdAt": "2020-12-08T05:37:23Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.h", "diffHunk": "@@ -53,36 +54,44 @@ class StoragePageCache {\n     };\n \n     // Create global instance of this class\n-    static void create_global_cache(size_t capacity);\n+    static void create_global_cache(size_t capacity, double index_cache_ratio);\n \n     // Return global instance.\n     // Client should call create_global_cache before.\n     static StoragePageCache* instance() { return _s_instance; }\n \n-    StoragePageCache(size_t capacity);\n+    StoragePageCache(size_t capacity, double index_cache_ratio);\n \n     // Lookup the given page in the cache.\n     //\n     // If the page is found, the cache entry will be written into handle.\n     // PageCacheHandle will release cache entry to cache when it\n     // destructs.\n     //\n+    // Cache type selection is determined by page_type argument\n+    //\n     // Return true if entry is found, otherwise return false.\n-    bool lookup(const CacheKey& key, PageCacheHandle* handle);\n+    bool lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type);\n \n     // Insert a page with key into this cache.\n     // Given handle will be set to valid reference.\n     // This function is thread-safe, and when two clients insert two same key\n     // concurrently, this function can assure that only one page is cached.\n     // The in_memory page will have higher priority.\n     void insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                bool in_memory = false);\n+                segment_v2::PageTypePB page_type, bool in_memory = false);\n+\n+    // Page cache available check.\n+    // When ratio is set to 0 or 1, the index or data cache will not be allocated.\n+    bool is_cache_available(segment_v2::PageTypePB page_type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NzgzNzQxOnYy", "diffSide": "RIGHT", "path": "be/src/olap/page_cache.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTo0NToyMFrOIBIFcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjowMDo0OFrOIB-tww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1MTk1NA==", "bodyText": "For double type values, better to use expression like std::abs(index_cache_ratio) < 1e-6 to judge whether they are equaled. If you think it's too ugly, you can use percentagle int value instead.", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538051954", "createdAt": "2020-12-08T05:45:20Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0NzAxMQ==", "bodyText": "I think it is a good idea to use the percentage as index cache ratio because of the safety problem as you mentioned and could also avoid using the type cast. I will change the definition. Thank you very much!", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538947011", "createdAt": "2020-12-09T02:00:48Z", "author": {"login": "Skysheepwang"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1MTk1NA=="}, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Nzg0NjQyOnYy", "diffSide": "RIGHT", "path": "be/src/olap/page_cache.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTo0ODo1OFrOIBIKaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTo0ODo1OFrOIBIKaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1MzIyNA==", "bodyText": "What if the other values passed, how about add CHECK(false) << \"xxx\" in else scope?", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538053224", "createdAt": "2020-12-08T05:48:58Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio == 1) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio > 0 && index_cache_ratio < 1) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", static_cast<size_t>(capacity * (1 - index_cache_ratio))));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", static_cast<size_t>(capacity * index_cache_ratio)));\n+    }   ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Nzg1MzUwOnYy", "diffSide": "RIGHT", "path": "be/src/olap/page_cache.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTo1MTo0OVrOIBIOQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjo1MDozMVrOIB_zXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NDIwOQ==", "bodyText": "There are some duplicate code, how about define a function like Cache::Handle* get_cache(segment_v2::PageTypePB page_type) to get lru_handle  at first, then do the same thing as before?", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538054209", "createdAt": "2020-12-08T05:51:49Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio == 1) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio > 0 && index_cache_ratio < 1) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", static_cast<size_t>(capacity * (1 - index_cache_ratio))));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", static_cast<size_t>(capacity * index_cache_ratio)));\n+    }   \n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n-    if (lru_handle == nullptr) {\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NDgzMA==", "bodyText": "Sorry, it should be Cache* get_cache(segment_v2::PageTypePB page_type) to get Cache at first", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538964830", "createdAt": "2020-12-09T02:50:31Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio == 1) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio > 0 && index_cache_ratio < 1) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", static_cast<size_t>(capacity * (1 - index_cache_ratio))));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", static_cast<size_t>(capacity * index_cache_ratio)));\n+    }   \n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n-    if (lru_handle == nullptr) {\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NDIwOQ=="}, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Nzg1NDU2OnYy", "diffSide": "RIGHT", "path": "be/src/olap/page_cache.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTo1MjoxMVrOIBIO0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTo1MjoxMVrOIBIO0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NDM1Mg==", "bodyText": "Same", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538054352", "createdAt": "2020-12-08T05:52:11Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio == 1) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio > 0 && index_cache_ratio < 1) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", static_cast<size_t>(capacity * (1 - index_cache_ratio))));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", static_cast<size_t>(capacity * index_cache_ratio)));\n+    }   \n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n-    if (lru_handle == nullptr) {\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;\n+    default:\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->insert(key.encode(), data.data, data.size, deleter, priority);\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->insert(key.encode(), data.data, data.size, deleter, priority);\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Nzg1OTI0OnYy", "diffSide": "RIGHT", "path": "be/src/olap/page_cache.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTo1NDowM1rOIBIRTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTo1NDowM1rOIBIRTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NDk4OQ==", "bodyText": "If you do the refactor as mentioned above, you can simply judge whether the return Cache*  is nullptr or not", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538054989", "createdAt": "2020-12-08T05:54:03Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio == 1) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio > 0 && index_cache_ratio < 1) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", static_cast<size_t>(capacity * (1 - index_cache_ratio))));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", static_cast<size_t>(capacity * index_cache_ratio)));\n+    }   \n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n-    if (lru_handle == nullptr) {\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;\n+    default:\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->insert(key.encode(), data.data, data.size, deleter, priority);\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->insert(key.encode(), data.data, data.size, deleter, priority);\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;\n+    default:\n+        break;\n+    }\n+}\n+\n+bool StoragePageCache::is_cache_available(segment_v2::PageTypePB page_type) {\n+    if (page_type == segment_v2::DATA_PAGE && _index_cache_ratio == 1) {\n+        return false;\n+    }\n+    else if (page_type == segment_v2::INDEX_PAGE && _index_cache_ratio == 0) {\n+        return false;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Nzg2OTU3OnYy", "diffSide": "RIGHT", "path": "docs/en/administrator-guide/config/be_config.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTo1Nzo1MlrOIBIW8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTo1Nzo1MlrOIBIW8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NjQzNA==", "bodyText": "Add descriptions.", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538056434", "createdAt": "2020-12-08T05:57:52Z", "author": {"login": "acelyc111"}, "path": "docs/en/administrator-guide/config/be_config.md", "diffHunk": "@@ -695,6 +695,8 @@ Indicates how many tablets in this data directory failed to load. At the same ti\n \n ### `storage_page_cache_limit`\n \n+### `index_page_cache_ratio`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Nzg2OTg2OnYy", "diffSide": "RIGHT", "path": "docs/zh-CN/administrator-guide/config/be_config.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTo1ODowMVrOIBIXIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTo1ODowMVrOIBIXIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NjQ4Mg==", "bodyText": "Add descriptions.", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538056482", "createdAt": "2020-12-08T05:58:01Z", "author": {"login": "acelyc111"}, "path": "docs/zh-CN/administrator-guide/config/be_config.md", "diffHunk": "@@ -693,6 +693,8 @@ load tablets from header failed, failed tablets size: xxx, path=xxx\n \n ### `storage_page_cache_limit`\n \n+### `index_page_cache_ratio`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjM3OTc3OnYy", "diffSide": "RIGHT", "path": "be/src/olap/page_cache.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDoyMzoxMlrOICXIxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDoyMzoxMlrOICXIxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0NzE0Mg==", "bodyText": "How about\nauto cache = _get_page_cache(page_type);\nauto lru_handle = cache->lookup(key.encode());\nif (lru_handle == nullptr) {\n    return false;\n}\n*handle = PageCacheHandle(cache, lru_handle);\nreturn true;", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539347142", "createdAt": "2020-12-09T14:23:12Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,70 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    }\n+    else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n     return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0086e4efcdff1ebeb77ff4843bc18b2e087ef041"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjM4NTI5OnYy", "diffSide": "RIGHT", "path": "be/src/olap/page_cache.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDoyNDoyNFrOICXMOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxNToyNlrOICw4vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0ODAyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (_get_page_cache(page_type) == nullptr) {\n          \n          \n            \n                    return false;\n          \n          \n            \n                }\n          \n          \n            \n                return true;\n          \n          \n            \n                return _get_page_cache(page_type) != nullptr;", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539348025", "createdAt": "2020-12-09T14:24:24Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,70 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    }\n+    else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->insert(key.encode(), data.data, data.size, deleter, priority);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n+}\n+\n+bool StoragePageCache::is_cache_available(segment_v2::PageTypePB page_type) {\n+    if (_get_page_cache(page_type) == nullptr) {\n+        return false;\n+    }\n+    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0086e4efcdff1ebeb77ff4843bc18b2e087ef041"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2OTAyMA==", "bodyText": "Thank you! I think it is a really good change. I will take it and change the method to an inline member method.", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539769020", "createdAt": "2020-12-10T01:15:26Z", "author": {"login": "Skysheepwang"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,70 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    }\n+    else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->insert(key.encode(), data.data, data.size, deleter, priority);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n+}\n+\n+bool StoragePageCache::is_cache_available(segment_v2::PageTypePB page_type) {\n+    if (_get_page_cache(page_type) == nullptr) {\n+        return false;\n+    }\n+    return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0ODAyNQ=="}, "originalCommit": {"oid": "0086e4efcdff1ebeb77ff4843bc18b2e087ef041"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjM5MjYxOnYy", "diffSide": "RIGHT", "path": "be/src/olap/page_cache.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDoyNTo0NFrOICXQjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDoyNTo0NFrOICXQjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0OTEzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Cache::Handle* lru_handle = nullptr;\n          \n          \n            \n                lru_handle = _get_page_cache(page_type)->insert(key.encode(), data.data, data.size, deleter, priority);\n          \n          \n            \n                *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n          \n          \n            \n                auto cache = _get_page_cache(page_type);\n          \n          \n            \n                Cache::Handle* lru_handle = cache->insert(key.encode(), data.data, data.size, deleter, priority);\n          \n          \n            \n                *handle = PageCacheHandle(cache, lru_handle);", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539349132", "createdAt": "2020-12-09T14:25:44Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,70 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    }\n+    else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->insert(key.encode(), data.data, data.size, deleter, priority);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0086e4efcdff1ebeb77ff4843bc18b2e087ef041"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDc3MTk0OnYy", "diffSide": "RIGHT", "path": "be/src/olap/page_cache.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOToxNToxMFrOIC-9bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOToxNToxMFrOIC-9bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5OTU5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                }\n          \n          \n            \n                else if (index_cache_percentage == 100) {\n          \n          \n            \n                    _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n          \n          \n            \n                }\n          \n          \n            \n                else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n          \n          \n            \n                    _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n          \n          \n            \n                    _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n          \n          \n            \n                }\n          \n          \n            \n                else {\n          \n          \n            \n                } else if (index_cache_percentage == 100) {\n          \n          \n            \n                    _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n          \n          \n            \n                } else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n          \n          \n            \n                    _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n          \n          \n            \n                    _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n          \n          \n            \n                } else {", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539999599", "createdAt": "2020-12-10T09:15:10Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,51 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    }\n+    else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c02b4de626bb5658dcedec67dee0be713a001aed"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzcyMjE3OnYy", "diffSide": "RIGHT", "path": "be/src/olap/page_cache.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzozNjoyM1rOIFQufA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOTozMTo0NlrOIG7-CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4NzgzNg==", "bodyText": "the cache maybe null if the index_page_cache_percentage is 0 or 100", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542387836", "createdAt": "2020-12-14T13:36:23Z", "author": {"login": "morningman"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,48 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    } else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    } else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    } else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    auto cache = _get_page_cache(page_type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5MzYzMg==", "bodyText": "Actually not because the is_cache_available() check will be called before using the lookup() method.", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542993632", "createdAt": "2020-12-15T02:17:52Z", "author": {"login": "Skysheepwang"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,48 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    } else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    } else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    } else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    auto cache = _get_page_cache(page_type);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4NzgzNg=="}, "originalCommit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE0NDkwNQ==", "bodyText": "Ok", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r544144905", "createdAt": "2020-12-16T09:31:46Z", "author": {"login": "morningman"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,48 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    } else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    } else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    } else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    auto cache = _get_page_cache(page_type);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4NzgzNg=="}, "originalCommit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzcyOTEzOnYy", "diffSide": "RIGHT", "path": "be/src/olap/page_cache.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzozNzo1M1rOIFQysg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMjoxODowM1rOIF1tMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4ODkxNA==", "bodyText": "cache may be null", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542388914", "createdAt": "2020-12-14T13:37:53Z", "author": {"login": "morningman"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,48 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    } else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    } else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    } else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    auto cache = _get_page_cache(page_type);\n+    auto lru_handle = cache->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(cache, lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    auto cache = _get_page_cache(page_type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5MzcxMw==", "bodyText": "Same as above.", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542993713", "createdAt": "2020-12-15T02:18:03Z", "author": {"login": "Skysheepwang"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,48 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    } else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    } else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    } else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    auto cache = _get_page_cache(page_type);\n+    auto lru_handle = cache->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(cache, lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    auto cache = _get_page_cache(page_type);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4ODkxNA=="}, "originalCommit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzc0MjA3OnYy", "diffSide": "RIGHT", "path": "be/src/olap/rowset/segment_v2/page_io.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzo0MDo0NlrOIFQ6gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMjoxNjo0MFrOIF1rGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM5MDkxMw==", "bodyText": "I think the check of is_cache_available() can be put into lookup() method for easy to use?\nAs well as the following insert logic", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542390913", "createdAt": "2020-12-14T13:40:46Z", "author": {"login": "morningman"}, "path": "be/src/olap/rowset/segment_v2/page_io.cpp", "diffHunk": "@@ -112,7 +112,7 @@ Status PageIO::read_and_decompress_page(const PageReadOptions& opts, PageHandle*\n     auto cache = StoragePageCache::instance();\n     PageCacheHandle cache_handle;\n     StoragePageCache::CacheKey cache_key(opts.rblock->path(), opts.page_pointer.offset);\n-    if (opts.use_page_cache && cache->lookup(cache_key, &cache_handle)) {\n+    if (opts.use_page_cache && cache->is_cache_available(opts.type) && cache->lookup(cache_key, &cache_handle, opts.type)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5MzE3Ng==", "bodyText": "I choose to make the is_cache_available() check as an interface basically for two reasons:\n\nIf the check is failed (which means that the percentage is set to 0 or 100), the lookup() and insert() method will not be called, which could save some of the cost of parameter passing.\nIt will do minimal changes to the original read_and_decompress_page() method in page_io.cpp and remain its design on whether call the lookup() and insert() methods.", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542993176", "createdAt": "2020-12-15T02:16:40Z", "author": {"login": "Skysheepwang"}, "path": "be/src/olap/rowset/segment_v2/page_io.cpp", "diffHunk": "@@ -112,7 +112,7 @@ Status PageIO::read_and_decompress_page(const PageReadOptions& opts, PageHandle*\n     auto cache = StoragePageCache::instance();\n     PageCacheHandle cache_handle;\n     StoragePageCache::CacheKey cache_key(opts.rblock->path(), opts.page_pointer.offset);\n-    if (opts.use_page_cache && cache->lookup(cache_key, &cache_handle)) {\n+    if (opts.use_page_cache && cache->is_cache_available(opts.type) && cache->lookup(cache_key, &cache_handle, opts.type)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM5MDkxMw=="}, "originalCommit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 929, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}