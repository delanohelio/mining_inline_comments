{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1OTMwMjg3", "number": 3742, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozMjowMVrOEBaA9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNDoyNzoyOVrOEHIppg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTEwMjYyOnYy", "diffSide": "RIGHT", "path": "be/src/olap/push_handler.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozMjowMVrOGdO-sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNzo0MDoxOVrOGe5kDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMwNzMxNA==", "bodyText": "I think for reader, close maybe better than finalize.", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r433307314", "createdAt": "2020-06-01T15:32:01Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/push_handler.h", "diffHunk": "@@ -209,6 +216,44 @@ class LzoBinaryReader: public IBinaryReader {\n     size_t _next_row_start;\n };\n \n+class PushBrokerReader {\n+public:\n+    PushBrokerReader() \n+        : _ready(false),\n+          _eof(false) {}\n+    ~PushBrokerReader() {}\n+\n+    OLAPStatus init(const Schema* schema,\n+                    const TBrokerScanRange& t_scan_range,\n+                    const TDescriptorTable& t_desc_tbl);\n+    OLAPStatus next(ContiguousRow* row);\n+    void print_profile();\n+\n+    OLAPStatus finalize() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MzU4Mw==", "bodyText": "ok", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r435053583", "createdAt": "2020-06-04T07:40:19Z", "author": {"login": "xy720"}, "path": "be/src/olap/push_handler.h", "diffHunk": "@@ -209,6 +216,44 @@ class LzoBinaryReader: public IBinaryReader {\n     size_t _next_row_start;\n };\n \n+class PushBrokerReader {\n+public:\n+    PushBrokerReader() \n+        : _ready(false),\n+          _eof(false) {}\n+    ~PushBrokerReader() {}\n+\n+    OLAPStatus init(const Schema* schema,\n+                    const TBrokerScanRange& t_scan_range,\n+                    const TDescriptorTable& t_desc_tbl);\n+    OLAPStatus next(ContiguousRow* row);\n+    void print_profile();\n+\n+    OLAPStatus finalize() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMwNzMxNA=="}, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTEzMTI4OnYy", "diffSide": "RIGHT", "path": "be/src/olap/push_handler.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozNjoxOVrOGdPPJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODowMDowM1rOGe6PMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxMTUyNQ==", "bodyText": "Why don't set a memory limit?", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r433311525", "createdAt": "2020-06-01T15:36:19Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -761,6 +915,126 @@ OLAPStatus LzoBinaryReader::_next_block() {\n   return res;\n }\n \n+OLAPStatus PushBrokerReader::init(const Schema* schema,\n+                                  const TBrokerScanRange& t_scan_range,\n+                                  const TDescriptorTable& t_desc_tbl) {\n+    // init schema\n+    _schema = schema;\n+\n+    // init runtime state, runtime profile, counter\n+    TUniqueId dummy_id;\n+    dummy_id.hi = 0;\n+    dummy_id.lo = 0;\n+    TPlanFragmentExecParams params;\n+    params.fragment_instance_id = dummy_id;\n+    params.query_id = dummy_id;\n+    TExecPlanFragmentParams fragment_params;\n+    fragment_params.params = params;\n+    fragment_params.protocol_version = PaloInternalServiceVersion::V1;\n+    TQueryOptions query_options;\n+    TQueryGlobals query_globals;\n+    _runtime_state.reset(new RuntimeState(fragment_params, query_options, query_globals,\n+                                          ExecEnv::GetInstance()));\n+    DescriptorTbl* desc_tbl = NULL;\n+    Status status = DescriptorTbl::create(_runtime_state->obj_pool(), t_desc_tbl, &desc_tbl);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to create descriptor table, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_state->set_desc_tbl(desc_tbl);\n+    status = _runtime_state->init_mem_trackers(dummy_id);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to init mem trackers, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_profile.reset(new RuntimeProfile(_runtime_state->obj_pool(), \"PushBrokerReader\"));\n+    _mem_tracker.reset(new MemTracker(-1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA2NDYyNw==", "bodyText": "Better keep it same as BrokerScanNode and OlapScanNode, they set memory limit to -1.", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r435064627", "createdAt": "2020-06-04T08:00:03Z", "author": {"login": "xy720"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -761,6 +915,126 @@ OLAPStatus LzoBinaryReader::_next_block() {\n   return res;\n }\n \n+OLAPStatus PushBrokerReader::init(const Schema* schema,\n+                                  const TBrokerScanRange& t_scan_range,\n+                                  const TDescriptorTable& t_desc_tbl) {\n+    // init schema\n+    _schema = schema;\n+\n+    // init runtime state, runtime profile, counter\n+    TUniqueId dummy_id;\n+    dummy_id.hi = 0;\n+    dummy_id.lo = 0;\n+    TPlanFragmentExecParams params;\n+    params.fragment_instance_id = dummy_id;\n+    params.query_id = dummy_id;\n+    TExecPlanFragmentParams fragment_params;\n+    fragment_params.params = params;\n+    fragment_params.protocol_version = PaloInternalServiceVersion::V1;\n+    TQueryOptions query_options;\n+    TQueryGlobals query_globals;\n+    _runtime_state.reset(new RuntimeState(fragment_params, query_options, query_globals,\n+                                          ExecEnv::GetInstance()));\n+    DescriptorTbl* desc_tbl = NULL;\n+    Status status = DescriptorTbl::create(_runtime_state->obj_pool(), t_desc_tbl, &desc_tbl);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to create descriptor table, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_state->set_desc_tbl(desc_tbl);\n+    status = _runtime_state->init_mem_trackers(dummy_id);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to init mem trackers, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_profile.reset(new RuntimeProfile(_runtime_state->obj_pool(), \"PushBrokerReader\"));\n+    _mem_tracker.reset(new MemTracker(-1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxMTUyNQ=="}, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTEzNjMxOnYy", "diffSide": "RIGHT", "path": "be/src/olap/push_handler.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozNzowNlrOGdPR0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNzozNDo0MFrOGe5Yxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxMjIwOQ==", "bodyText": "You should do a code format by clang-format.", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r433312209", "createdAt": "2020-06-01T15:37:06Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -761,6 +915,126 @@ OLAPStatus LzoBinaryReader::_next_block() {\n   return res;\n }\n \n+OLAPStatus PushBrokerReader::init(const Schema* schema,\n+                                  const TBrokerScanRange& t_scan_range,\n+                                  const TDescriptorTable& t_desc_tbl) {\n+    // init schema\n+    _schema = schema;\n+\n+    // init runtime state, runtime profile, counter\n+    TUniqueId dummy_id;\n+    dummy_id.hi = 0;\n+    dummy_id.lo = 0;\n+    TPlanFragmentExecParams params;\n+    params.fragment_instance_id = dummy_id;\n+    params.query_id = dummy_id;\n+    TExecPlanFragmentParams fragment_params;\n+    fragment_params.params = params;\n+    fragment_params.protocol_version = PaloInternalServiceVersion::V1;\n+    TQueryOptions query_options;\n+    TQueryGlobals query_globals;\n+    _runtime_state.reset(new RuntimeState(fragment_params, query_options, query_globals,\n+                                          ExecEnv::GetInstance()));\n+    DescriptorTbl* desc_tbl = NULL;\n+    Status status = DescriptorTbl::create(_runtime_state->obj_pool(), t_desc_tbl, &desc_tbl);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to create descriptor table, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_state->set_desc_tbl(desc_tbl);\n+    status = _runtime_state->init_mem_trackers(dummy_id);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to init mem trackers, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_profile.reset(new RuntimeProfile(_runtime_state->obj_pool(), \"PushBrokerReader\"));\n+    _mem_tracker.reset(new MemTracker(-1));\n+    _mem_pool.reset(new MemPool(_mem_tracker.get()));\n+    _counter.reset(new ScannerCounter());\n+\n+    // init scanner\n+    BaseScanner *scanner = nullptr;\n+    switch (t_scan_range.ranges[0].format_type) {\n+    case TFileFormatType::FORMAT_PARQUET:\n+        scanner = new ParquetScanner(_runtime_state.get(),\n+                                  _runtime_profile.get(),\n+                                  t_scan_range.params,\n+                                  t_scan_range.ranges,\n+                                  t_scan_range.broker_addresses,\n+                                  _counter.get());\n+        break;\n+    default:\n+        LOG(WARNING) << \"Unsupported file format type: \" << t_scan_range.ranges[0].format_type;\n+\t\treturn OLAP_ERR_PUSH_INIT_ERROR;\n+\t}\n+    _scanner.reset(scanner); \n+    status = _scanner->open();\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to open scanner, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    // init tuple\n+    auto tuple_id = t_scan_range.params.dest_tuple_id;\n+    _tuple_desc = _runtime_state->desc_tbl().get_tuple_descriptor(tuple_id);\n+    if (_tuple_desc == nullptr) {\n+        std::stringstream ss;\n+        LOG(WARNING) << \"Failed to get tuple descriptor, tuple_id: \" << tuple_id;\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    int tuple_buffer_size = _tuple_desc->byte_size();\n+    void* tuple_buffer = _mem_pool->allocate(tuple_buffer_size);\n+    if (tuple_buffer == nullptr) {\n+        LOG(WARNING) << \"Allocate memory for tuple failed\";\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _tuple = reinterpret_cast<Tuple*>(tuple_buffer);\n+\n+    _ready = true;\n+\treturn OLAP_SUCCESS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MDY5NA==", "bodyText": "if I use format this file, it will add many unrelated changes to this commit. May be I will format the code in another pr.", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r435050694", "createdAt": "2020-06-04T07:34:40Z", "author": {"login": "xy720"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -761,6 +915,126 @@ OLAPStatus LzoBinaryReader::_next_block() {\n   return res;\n }\n \n+OLAPStatus PushBrokerReader::init(const Schema* schema,\n+                                  const TBrokerScanRange& t_scan_range,\n+                                  const TDescriptorTable& t_desc_tbl) {\n+    // init schema\n+    _schema = schema;\n+\n+    // init runtime state, runtime profile, counter\n+    TUniqueId dummy_id;\n+    dummy_id.hi = 0;\n+    dummy_id.lo = 0;\n+    TPlanFragmentExecParams params;\n+    params.fragment_instance_id = dummy_id;\n+    params.query_id = dummy_id;\n+    TExecPlanFragmentParams fragment_params;\n+    fragment_params.params = params;\n+    fragment_params.protocol_version = PaloInternalServiceVersion::V1;\n+    TQueryOptions query_options;\n+    TQueryGlobals query_globals;\n+    _runtime_state.reset(new RuntimeState(fragment_params, query_options, query_globals,\n+                                          ExecEnv::GetInstance()));\n+    DescriptorTbl* desc_tbl = NULL;\n+    Status status = DescriptorTbl::create(_runtime_state->obj_pool(), t_desc_tbl, &desc_tbl);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to create descriptor table, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_state->set_desc_tbl(desc_tbl);\n+    status = _runtime_state->init_mem_trackers(dummy_id);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to init mem trackers, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_profile.reset(new RuntimeProfile(_runtime_state->obj_pool(), \"PushBrokerReader\"));\n+    _mem_tracker.reset(new MemTracker(-1));\n+    _mem_pool.reset(new MemPool(_mem_tracker.get()));\n+    _counter.reset(new ScannerCounter());\n+\n+    // init scanner\n+    BaseScanner *scanner = nullptr;\n+    switch (t_scan_range.ranges[0].format_type) {\n+    case TFileFormatType::FORMAT_PARQUET:\n+        scanner = new ParquetScanner(_runtime_state.get(),\n+                                  _runtime_profile.get(),\n+                                  t_scan_range.params,\n+                                  t_scan_range.ranges,\n+                                  t_scan_range.broker_addresses,\n+                                  _counter.get());\n+        break;\n+    default:\n+        LOG(WARNING) << \"Unsupported file format type: \" << t_scan_range.ranges[0].format_type;\n+\t\treturn OLAP_ERR_PUSH_INIT_ERROR;\n+\t}\n+    _scanner.reset(scanner); \n+    status = _scanner->open();\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to open scanner, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    // init tuple\n+    auto tuple_id = t_scan_range.params.dest_tuple_id;\n+    _tuple_desc = _runtime_state->desc_tbl().get_tuple_descriptor(tuple_id);\n+    if (_tuple_desc == nullptr) {\n+        std::stringstream ss;\n+        LOG(WARNING) << \"Failed to get tuple descriptor, tuple_id: \" << tuple_id;\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    int tuple_buffer_size = _tuple_desc->byte_size();\n+    void* tuple_buffer = _mem_pool->allocate(tuple_buffer_size);\n+    if (tuple_buffer == nullptr) {\n+        LOG(WARNING) << \"Allocate memory for tuple failed\";\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _tuple = reinterpret_cast<Tuple*>(tuple_buffer);\n+\n+    _ready = true;\n+\treturn OLAP_SUCCESS;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxMjIwOQ=="}, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 268}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTEzOTAzOnYy", "diffSide": "RIGHT", "path": "be/src/olap/push_handler.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozNzoyOFrOGdPTQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozNzoyOFrOGdPTQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxMjU3Nw==", "bodyText": "Remove", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r433312577", "createdAt": "2020-06-01T15:37:28Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -761,6 +915,126 @@ OLAPStatus LzoBinaryReader::_next_block() {\n   return res;\n }\n \n+OLAPStatus PushBrokerReader::init(const Schema* schema,\n+                                  const TBrokerScanRange& t_scan_range,\n+                                  const TDescriptorTable& t_desc_tbl) {\n+    // init schema\n+    _schema = schema;\n+\n+    // init runtime state, runtime profile, counter\n+    TUniqueId dummy_id;\n+    dummy_id.hi = 0;\n+    dummy_id.lo = 0;\n+    TPlanFragmentExecParams params;\n+    params.fragment_instance_id = dummy_id;\n+    params.query_id = dummy_id;\n+    TExecPlanFragmentParams fragment_params;\n+    fragment_params.params = params;\n+    fragment_params.protocol_version = PaloInternalServiceVersion::V1;\n+    TQueryOptions query_options;\n+    TQueryGlobals query_globals;\n+    _runtime_state.reset(new RuntimeState(fragment_params, query_options, query_globals,\n+                                          ExecEnv::GetInstance()));\n+    DescriptorTbl* desc_tbl = NULL;\n+    Status status = DescriptorTbl::create(_runtime_state->obj_pool(), t_desc_tbl, &desc_tbl);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to create descriptor table, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_state->set_desc_tbl(desc_tbl);\n+    status = _runtime_state->init_mem_trackers(dummy_id);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to init mem trackers, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_profile.reset(new RuntimeProfile(_runtime_state->obj_pool(), \"PushBrokerReader\"));\n+    _mem_tracker.reset(new MemTracker(-1));\n+    _mem_pool.reset(new MemPool(_mem_tracker.get()));\n+    _counter.reset(new ScannerCounter());\n+\n+    // init scanner\n+    BaseScanner *scanner = nullptr;\n+    switch (t_scan_range.ranges[0].format_type) {\n+    case TFileFormatType::FORMAT_PARQUET:\n+        scanner = new ParquetScanner(_runtime_state.get(),\n+                                  _runtime_profile.get(),\n+                                  t_scan_range.params,\n+                                  t_scan_range.ranges,\n+                                  t_scan_range.broker_addresses,\n+                                  _counter.get());\n+        break;\n+    default:\n+        LOG(WARNING) << \"Unsupported file format type: \" << t_scan_range.ranges[0].format_type;\n+\t\treturn OLAP_ERR_PUSH_INIT_ERROR;\n+\t}\n+    _scanner.reset(scanner); \n+    status = _scanner->open();\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to open scanner, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    // init tuple\n+    auto tuple_id = t_scan_range.params.dest_tuple_id;\n+    _tuple_desc = _runtime_state->desc_tbl().get_tuple_descriptor(tuple_id);\n+    if (_tuple_desc == nullptr) {\n+        std::stringstream ss;\n+        LOG(WARNING) << \"Failed to get tuple descriptor, tuple_id: \" << tuple_id;\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    int tuple_buffer_size = _tuple_desc->byte_size();\n+    void* tuple_buffer = _mem_pool->allocate(tuple_buffer_size);\n+    if (tuple_buffer == nullptr) {\n+        LOG(WARNING) << \"Allocate memory for tuple failed\";\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _tuple = reinterpret_cast<Tuple*>(tuple_buffer);\n+\n+    _ready = true;\n+\treturn OLAP_SUCCESS;\n+}\n+\n+OLAPStatus PushBrokerReader::next(ContiguousRow* row) {\n+    if (!_ready || row == nullptr) {\n+        return OLAP_ERR_INPUT_PARAMETER_ERROR;\n+    }\n+\n+    memset(_tuple, 0, _tuple_desc->num_null_bytes());\n+    // Get from scanner\n+    Status status = _scanner->get_next(_tuple, _mem_pool.get(), &_eof);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Scanner get next tuple failed\";\n+        return OLAP_ERR_PUSH_INPUT_DATA_ERROR;\n+    }\n+    if (_eof) {\n+        return OLAP_SUCCESS;\n+    }\n+    //LOG(INFO) << \"row data: \" << _tuple->to_string(*_tuple_desc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTE2NTg3OnYy", "diffSide": "RIGHT", "path": "be/src/olap/push_handler.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTo0MjoxMVrOGdPkGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjoyNTowM1rOGfDQBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxNjg4OA==", "bodyText": "Add a comment for these lines code.", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r433316888", "createdAt": "2020-06-01T15:42:11Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -761,6 +915,126 @@ OLAPStatus LzoBinaryReader::_next_block() {\n   return res;\n }\n \n+OLAPStatus PushBrokerReader::init(const Schema* schema,\n+                                  const TBrokerScanRange& t_scan_range,\n+                                  const TDescriptorTable& t_desc_tbl) {\n+    // init schema\n+    _schema = schema;\n+\n+    // init runtime state, runtime profile, counter\n+    TUniqueId dummy_id;\n+    dummy_id.hi = 0;\n+    dummy_id.lo = 0;\n+    TPlanFragmentExecParams params;\n+    params.fragment_instance_id = dummy_id;\n+    params.query_id = dummy_id;\n+    TExecPlanFragmentParams fragment_params;\n+    fragment_params.params = params;\n+    fragment_params.protocol_version = PaloInternalServiceVersion::V1;\n+    TQueryOptions query_options;\n+    TQueryGlobals query_globals;\n+    _runtime_state.reset(new RuntimeState(fragment_params, query_options, query_globals,\n+                                          ExecEnv::GetInstance()));\n+    DescriptorTbl* desc_tbl = NULL;\n+    Status status = DescriptorTbl::create(_runtime_state->obj_pool(), t_desc_tbl, &desc_tbl);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to create descriptor table, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_state->set_desc_tbl(desc_tbl);\n+    status = _runtime_state->init_mem_trackers(dummy_id);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to init mem trackers, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_profile.reset(new RuntimeProfile(_runtime_state->obj_pool(), \"PushBrokerReader\"));\n+    _mem_tracker.reset(new MemTracker(-1));\n+    _mem_pool.reset(new MemPool(_mem_tracker.get()));\n+    _counter.reset(new ScannerCounter());\n+\n+    // init scanner\n+    BaseScanner *scanner = nullptr;\n+    switch (t_scan_range.ranges[0].format_type) {\n+    case TFileFormatType::FORMAT_PARQUET:\n+        scanner = new ParquetScanner(_runtime_state.get(),\n+                                  _runtime_profile.get(),\n+                                  t_scan_range.params,\n+                                  t_scan_range.ranges,\n+                                  t_scan_range.broker_addresses,\n+                                  _counter.get());\n+        break;\n+    default:\n+        LOG(WARNING) << \"Unsupported file format type: \" << t_scan_range.ranges[0].format_type;\n+\t\treturn OLAP_ERR_PUSH_INIT_ERROR;\n+\t}\n+    _scanner.reset(scanner); \n+    status = _scanner->open();\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to open scanner, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    // init tuple\n+    auto tuple_id = t_scan_range.params.dest_tuple_id;\n+    _tuple_desc = _runtime_state->desc_tbl().get_tuple_descriptor(tuple_id);\n+    if (_tuple_desc == nullptr) {\n+        std::stringstream ss;\n+        LOG(WARNING) << \"Failed to get tuple descriptor, tuple_id: \" << tuple_id;\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    int tuple_buffer_size = _tuple_desc->byte_size();\n+    void* tuple_buffer = _mem_pool->allocate(tuple_buffer_size);\n+    if (tuple_buffer == nullptr) {\n+        LOG(WARNING) << \"Allocate memory for tuple failed\";\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _tuple = reinterpret_cast<Tuple*>(tuple_buffer);\n+\n+    _ready = true;\n+\treturn OLAP_SUCCESS;\n+}\n+\n+OLAPStatus PushBrokerReader::next(ContiguousRow* row) {\n+    if (!_ready || row == nullptr) {\n+        return OLAP_ERR_INPUT_PARAMETER_ERROR;\n+    }\n+\n+    memset(_tuple, 0, _tuple_desc->num_null_bytes());\n+    // Get from scanner\n+    Status status = _scanner->get_next(_tuple, _mem_pool.get(), &_eof);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Scanner get next tuple failed\";\n+        return OLAP_ERR_PUSH_INPUT_DATA_ERROR;\n+    }\n+    if (_eof) {\n+        return OLAP_SUCCESS;\n+    }\n+    //LOG(INFO) << \"row data: \" << _tuple->to_string(*_tuple_desc);\n+\n+    auto slot_descs = _tuple_desc->slots();\n+    size_t num_key_columns = _schema->num_key_columns();\n+    for (size_t i = 0; i < slot_descs.size(); ++i) {\n+        auto cell = row->cell(i);\n+        const SlotDescriptor* slot = slot_descs[i];\n+        bool is_null = _tuple->is_null(slot->null_indicator_offset());\n+        const void* value = _tuple->get_slot(slot->tuple_offset());\n+        _schema->column(i)->consume(&cell, (const char*)value, is_null, \n+                                    _mem_pool.get(), _runtime_state->obj_pool());\n+        if (i >= num_key_columns) {\n+            _schema->column(i)->agg_finalize(&cell, _mem_pool.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA0ODg4MA==", "bodyText": "ok", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r435048880", "createdAt": "2020-06-04T07:31:04Z", "author": {"login": "xy720"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -761,6 +915,126 @@ OLAPStatus LzoBinaryReader::_next_block() {\n   return res;\n }\n \n+OLAPStatus PushBrokerReader::init(const Schema* schema,\n+                                  const TBrokerScanRange& t_scan_range,\n+                                  const TDescriptorTable& t_desc_tbl) {\n+    // init schema\n+    _schema = schema;\n+\n+    // init runtime state, runtime profile, counter\n+    TUniqueId dummy_id;\n+    dummy_id.hi = 0;\n+    dummy_id.lo = 0;\n+    TPlanFragmentExecParams params;\n+    params.fragment_instance_id = dummy_id;\n+    params.query_id = dummy_id;\n+    TExecPlanFragmentParams fragment_params;\n+    fragment_params.params = params;\n+    fragment_params.protocol_version = PaloInternalServiceVersion::V1;\n+    TQueryOptions query_options;\n+    TQueryGlobals query_globals;\n+    _runtime_state.reset(new RuntimeState(fragment_params, query_options, query_globals,\n+                                          ExecEnv::GetInstance()));\n+    DescriptorTbl* desc_tbl = NULL;\n+    Status status = DescriptorTbl::create(_runtime_state->obj_pool(), t_desc_tbl, &desc_tbl);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to create descriptor table, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_state->set_desc_tbl(desc_tbl);\n+    status = _runtime_state->init_mem_trackers(dummy_id);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to init mem trackers, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_profile.reset(new RuntimeProfile(_runtime_state->obj_pool(), \"PushBrokerReader\"));\n+    _mem_tracker.reset(new MemTracker(-1));\n+    _mem_pool.reset(new MemPool(_mem_tracker.get()));\n+    _counter.reset(new ScannerCounter());\n+\n+    // init scanner\n+    BaseScanner *scanner = nullptr;\n+    switch (t_scan_range.ranges[0].format_type) {\n+    case TFileFormatType::FORMAT_PARQUET:\n+        scanner = new ParquetScanner(_runtime_state.get(),\n+                                  _runtime_profile.get(),\n+                                  t_scan_range.params,\n+                                  t_scan_range.ranges,\n+                                  t_scan_range.broker_addresses,\n+                                  _counter.get());\n+        break;\n+    default:\n+        LOG(WARNING) << \"Unsupported file format type: \" << t_scan_range.ranges[0].format_type;\n+\t\treturn OLAP_ERR_PUSH_INIT_ERROR;\n+\t}\n+    _scanner.reset(scanner); \n+    status = _scanner->open();\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to open scanner, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    // init tuple\n+    auto tuple_id = t_scan_range.params.dest_tuple_id;\n+    _tuple_desc = _runtime_state->desc_tbl().get_tuple_descriptor(tuple_id);\n+    if (_tuple_desc == nullptr) {\n+        std::stringstream ss;\n+        LOG(WARNING) << \"Failed to get tuple descriptor, tuple_id: \" << tuple_id;\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    int tuple_buffer_size = _tuple_desc->byte_size();\n+    void* tuple_buffer = _mem_pool->allocate(tuple_buffer_size);\n+    if (tuple_buffer == nullptr) {\n+        LOG(WARNING) << \"Allocate memory for tuple failed\";\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _tuple = reinterpret_cast<Tuple*>(tuple_buffer);\n+\n+    _ready = true;\n+\treturn OLAP_SUCCESS;\n+}\n+\n+OLAPStatus PushBrokerReader::next(ContiguousRow* row) {\n+    if (!_ready || row == nullptr) {\n+        return OLAP_ERR_INPUT_PARAMETER_ERROR;\n+    }\n+\n+    memset(_tuple, 0, _tuple_desc->num_null_bytes());\n+    // Get from scanner\n+    Status status = _scanner->get_next(_tuple, _mem_pool.get(), &_eof);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Scanner get next tuple failed\";\n+        return OLAP_ERR_PUSH_INPUT_DATA_ERROR;\n+    }\n+    if (_eof) {\n+        return OLAP_SUCCESS;\n+    }\n+    //LOG(INFO) << \"row data: \" << _tuple->to_string(*_tuple_desc);\n+\n+    auto slot_descs = _tuple_desc->slots();\n+    size_t num_key_columns = _schema->num_key_columns();\n+    for (size_t i = 0; i < slot_descs.size(); ++i) {\n+        auto cell = row->cell(i);\n+        const SlotDescriptor* slot = slot_descs[i];\n+        bool is_null = _tuple->is_null(slot->null_indicator_offset());\n+        const void* value = _tuple->get_slot(slot->tuple_offset());\n+        _schema->column(i)->consume(&cell, (const char*)value, is_null, \n+                                    _mem_pool.get(), _runtime_state->obj_pool());\n+        if (i >= num_key_columns) {\n+            _schema->column(i)->agg_finalize(&cell, _mem_pool.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxNjg4OA=="}, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxMjI5NQ==", "bodyText": "Later you can improve this by copying the buffer directly", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r435212295", "createdAt": "2020-06-04T12:25:03Z", "author": {"login": "wyb"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -761,6 +915,126 @@ OLAPStatus LzoBinaryReader::_next_block() {\n   return res;\n }\n \n+OLAPStatus PushBrokerReader::init(const Schema* schema,\n+                                  const TBrokerScanRange& t_scan_range,\n+                                  const TDescriptorTable& t_desc_tbl) {\n+    // init schema\n+    _schema = schema;\n+\n+    // init runtime state, runtime profile, counter\n+    TUniqueId dummy_id;\n+    dummy_id.hi = 0;\n+    dummy_id.lo = 0;\n+    TPlanFragmentExecParams params;\n+    params.fragment_instance_id = dummy_id;\n+    params.query_id = dummy_id;\n+    TExecPlanFragmentParams fragment_params;\n+    fragment_params.params = params;\n+    fragment_params.protocol_version = PaloInternalServiceVersion::V1;\n+    TQueryOptions query_options;\n+    TQueryGlobals query_globals;\n+    _runtime_state.reset(new RuntimeState(fragment_params, query_options, query_globals,\n+                                          ExecEnv::GetInstance()));\n+    DescriptorTbl* desc_tbl = NULL;\n+    Status status = DescriptorTbl::create(_runtime_state->obj_pool(), t_desc_tbl, &desc_tbl);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to create descriptor table, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_state->set_desc_tbl(desc_tbl);\n+    status = _runtime_state->init_mem_trackers(dummy_id);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to init mem trackers, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_profile.reset(new RuntimeProfile(_runtime_state->obj_pool(), \"PushBrokerReader\"));\n+    _mem_tracker.reset(new MemTracker(-1));\n+    _mem_pool.reset(new MemPool(_mem_tracker.get()));\n+    _counter.reset(new ScannerCounter());\n+\n+    // init scanner\n+    BaseScanner *scanner = nullptr;\n+    switch (t_scan_range.ranges[0].format_type) {\n+    case TFileFormatType::FORMAT_PARQUET:\n+        scanner = new ParquetScanner(_runtime_state.get(),\n+                                  _runtime_profile.get(),\n+                                  t_scan_range.params,\n+                                  t_scan_range.ranges,\n+                                  t_scan_range.broker_addresses,\n+                                  _counter.get());\n+        break;\n+    default:\n+        LOG(WARNING) << \"Unsupported file format type: \" << t_scan_range.ranges[0].format_type;\n+\t\treturn OLAP_ERR_PUSH_INIT_ERROR;\n+\t}\n+    _scanner.reset(scanner); \n+    status = _scanner->open();\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to open scanner, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    // init tuple\n+    auto tuple_id = t_scan_range.params.dest_tuple_id;\n+    _tuple_desc = _runtime_state->desc_tbl().get_tuple_descriptor(tuple_id);\n+    if (_tuple_desc == nullptr) {\n+        std::stringstream ss;\n+        LOG(WARNING) << \"Failed to get tuple descriptor, tuple_id: \" << tuple_id;\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    int tuple_buffer_size = _tuple_desc->byte_size();\n+    void* tuple_buffer = _mem_pool->allocate(tuple_buffer_size);\n+    if (tuple_buffer == nullptr) {\n+        LOG(WARNING) << \"Allocate memory for tuple failed\";\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _tuple = reinterpret_cast<Tuple*>(tuple_buffer);\n+\n+    _ready = true;\n+\treturn OLAP_SUCCESS;\n+}\n+\n+OLAPStatus PushBrokerReader::next(ContiguousRow* row) {\n+    if (!_ready || row == nullptr) {\n+        return OLAP_ERR_INPUT_PARAMETER_ERROR;\n+    }\n+\n+    memset(_tuple, 0, _tuple_desc->num_null_bytes());\n+    // Get from scanner\n+    Status status = _scanner->get_next(_tuple, _mem_pool.get(), &_eof);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Scanner get next tuple failed\";\n+        return OLAP_ERR_PUSH_INPUT_DATA_ERROR;\n+    }\n+    if (_eof) {\n+        return OLAP_SUCCESS;\n+    }\n+    //LOG(INFO) << \"row data: \" << _tuple->to_string(*_tuple_desc);\n+\n+    auto slot_descs = _tuple_desc->slots();\n+    size_t num_key_columns = _schema->num_key_columns();\n+    for (size_t i = 0; i < slot_descs.size(); ++i) {\n+        auto cell = row->cell(i);\n+        const SlotDescriptor* slot = slot_descs[i];\n+        bool is_null = _tuple->is_null(slot->null_indicator_offset());\n+        const void* value = _tuple->get_slot(slot->tuple_offset());\n+        _schema->column(i)->consume(&cell, (const char*)value, is_null, \n+                                    _mem_pool.get(), _runtime_state->obj_pool());\n+        if (i >= num_key_columns) {\n+            _schema->column(i)->agg_finalize(&cell, _mem_pool.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxNjg4OA=="}, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 298}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDg5ODkwOnYy", "diffSide": "RIGHT", "path": "be/src/olap/push_handler.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjoxMjowOVrOGfC0qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjoxMjowOVrOGfC0qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwNTI4OA==", "bodyText": "reader->close()", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r435205288", "createdAt": "2020-06-04T12:12:09Z", "author": {"login": "wyb"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -248,6 +259,149 @@ void PushHandler::_get_tablet_infos(const vector<TabletVars>& tablet_vars,\n   }\n }\n \n+OLAPStatus PushHandler::_convert_v2(TabletSharedPtr cur_tablet,\n+                                    TabletSharedPtr new_tablet,\n+                                    RowsetSharedPtr* cur_rowset,\n+                                    RowsetSharedPtr* new_rowset) {\n+    OLAPStatus res = OLAP_SUCCESS;\n+    PushBrokerReader* reader = nullptr;\n+    Schema* schema = nullptr;\n+    uint32_t num_rows = 0;\n+    PUniqueId load_id;\n+    load_id.set_hi(0);\n+    load_id.set_lo(0);\n+\n+    do {\n+        VLOG(3) << \"start to convert delta file.\";\n+\n+        // 1. init RowsetBuilder of cur_tablet for current push\n+        VLOG(3) << \"init rowset builder. tablet=\" << cur_tablet->full_name()\n+            << \", block_row_size=\" << cur_tablet->num_rows_per_row_block();\n+        RowsetWriterContext context;\n+        context.rowset_id = StorageEngine::instance()->next_rowset_id();\n+        context.tablet_uid = cur_tablet->tablet_uid();\n+        context.tablet_id = cur_tablet->tablet_id();\n+        context.partition_id = _request.partition_id;\n+        context.tablet_schema_hash = cur_tablet->schema_hash();\n+        context.rowset_type = StorageEngine::instance()->default_rowset_type();\n+        context.rowset_path_prefix = cur_tablet->tablet_path();\n+        context.tablet_schema = &(cur_tablet->tablet_schema());\n+        context.rowset_state = PREPARED;\n+        context.txn_id = _request.transaction_id;\n+        context.load_id = load_id;\n+        // although the spark load output files are fully sorted,\n+        // but it depends on thirparty implementation, so we conservatively\n+        // set this value to OVERLAP_UNKNOWN\n+        context.segments_overlap = OVERLAP_UNKNOWN;\n+\n+        std::unique_ptr<RowsetWriter> rowset_writer;\n+        res = RowsetFactory::create_rowset_writer(context, &rowset_writer);\n+        if (OLAP_SUCCESS != res) {\n+            LOG(WARNING) << \"failed to init rowset writer, tablet=\" << cur_tablet->full_name()\n+                         << \", txn_id=\" << _request.transaction_id\n+                         << \", res=\" << res;\n+            break;\n+        }\n+\n+        // 2. Init PushBrokerReader to read broker file if exist,\n+        //    in case of empty push this will be skipped.\n+        std::string path = _request.broker_scan_range.ranges[0].path;\n+        LOG(INFO) << \"tablet=\" << cur_tablet->full_name() << \", file path=\" << path\n+                  << \", file size=\" << _request.broker_scan_range.ranges[0].file_size;\n+        if (!path.empty()) {\n+            reader = new(std::nothrow) PushBrokerReader();\n+            if (reader == nullptr) {\n+                LOG(WARNING) << \"fail to create reader. tablet=\" << cur_tablet->full_name();\n+                res = OLAP_ERR_MALLOC_ERROR;\n+                break;\n+            }\n+\n+            // init schema\n+            schema = new(std::nothrow) Schema(cur_tablet->tablet_schema());\n+            if (schema == nullptr) {\n+                LOG(WARNING) << \"fail to create schema. tablet=\" << cur_tablet->full_name();\n+                res = OLAP_ERR_MALLOC_ERROR;\n+                break;\n+            }\n+\n+            // init Reader\n+            if (OLAP_SUCCESS != (res = reader->init(schema, \n+                                                    _request.broker_scan_range,\n+                                                    _request.desc_tbl))) {\n+                LOG(WARNING) << \"fail to init reader. res=\" << res\n+                             << \", tablet=\" << cur_tablet->full_name();\n+                res = OLAP_ERR_PUSH_INIT_ERROR;\n+                break;\n+            }\n+\n+            // 3. Init Row\n+            uint8_t* tuple_buf = reader->mem_pool()->allocate(schema->schema_size());\n+            ContiguousRow row(schema, tuple_buf);\n+\n+            // 4. Read data from broker and write into SegmentGroup of cur_tablet\n+            // Convert from raw to delta\n+            VLOG(3) << \"start to convert etl file to delta.\";\n+            while (!reader->eof()) {\n+                res = reader->next(&row);\n+                if (OLAP_SUCCESS != res) {\n+                    LOG(WARNING) << \"read next row failed.\"\n+                        << \" res=\" << res << \" read_rows=\" << num_rows;\n+                    break;\n+                } else {\n+                    if (reader->eof()) {\n+                        break;\n+                    }\n+                    if (OLAP_SUCCESS != (res = rowset_writer->add_row(row))) {\n+                        LOG(WARNING) << \"fail to attach row to rowset_writer. \"\n+                            << \"res=\" << res\n+                            << \", tablet=\" << cur_tablet->full_name()\n+                            << \", read_rows=\" << num_rows;\n+                        break;\n+                    }\n+                    num_rows++;\n+                }\n+            }\n+\n+            reader->print_profile();\n+            reader->finalize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0cbadd4e2ba4dd9d9254d345fc083df735412e4"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDkwMzI4OnYy", "diffSide": "RIGHT", "path": "be/src/olap/push_handler.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjoxMzoyNlrOGfC3Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjoxMzoyNlrOGfC3Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwNTk3OQ==", "bodyText": "IBinaryReader should use finalize", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r435205979", "createdAt": "2020-06-04T12:13:26Z", "author": {"login": "wyb"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -368,7 +522,7 @@ OLAPStatus PushHandler::_convert(TabletSharedPtr cur_tablet,\n                 }\n             }\n \n-            reader->finalize();\n+            reader->close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0cbadd4e2ba4dd9d9254d345fc083df735412e4"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1OTE1NjkyOnYy", "diffSide": "RIGHT", "path": "be/src/olap/push_handler.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNDoyMzowOFrOGmWoEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzoyNjo1NVrOGm00mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2OTc3OA==", "bodyText": "Could use std::unique_ptr?", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r442869778", "createdAt": "2020-06-19T14:23:08Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -248,6 +259,149 @@ void PushHandler::_get_tablet_infos(const vector<TabletVars>& tablet_vars,\n   }\n }\n \n+OLAPStatus PushHandler::_convert_v2(TabletSharedPtr cur_tablet,\n+                                    TabletSharedPtr new_tablet,\n+                                    RowsetSharedPtr* cur_rowset,\n+                                    RowsetSharedPtr* new_rowset) {\n+    OLAPStatus res = OLAP_SUCCESS;\n+    PushBrokerReader* reader = nullptr;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9500dd7a20bfa112093346acb1cd1341dad0fd8a"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM2NDUwNA==", "bodyText": "ok", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r443364504", "createdAt": "2020-06-22T07:26:55Z", "author": {"login": "xy720"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -248,6 +259,149 @@ void PushHandler::_get_tablet_infos(const vector<TabletVars>& tablet_vars,\n   }\n }\n \n+OLAPStatus PushHandler::_convert_v2(TabletSharedPtr cur_tablet,\n+                                    TabletSharedPtr new_tablet,\n+                                    RowsetSharedPtr* cur_rowset,\n+                                    RowsetSharedPtr* new_rowset) {\n+    OLAPStatus res = OLAP_SUCCESS;\n+    PushBrokerReader* reader = nullptr;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2OTc3OA=="}, "originalCommit": {"oid": "9500dd7a20bfa112093346acb1cd1341dad0fd8a"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1OTE3MjIyOnYy", "diffSide": "RIGHT", "path": "be/src/olap/olap_common.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNDoyNzoyOVrOGmWxug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzoyNzoxMlrOGm01Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3MjI1MA==", "bodyText": "Would better add a comment for these four push types.", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r442872250", "createdAt": "2020-06-19T14:27:29Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/olap_common.h", "diffHunk": "@@ -169,6 +169,7 @@ enum PushType {\n     PUSH_NORMAL = 1,\n     PUSH_FOR_DELETE = 2,\n     PUSH_FOR_LOAD_DELETE = 3,\n+    PUSH_NORMAL_V2 = 4,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9500dd7a20bfa112093346acb1cd1341dad0fd8a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM2NDYzNQ==", "bodyText": "done", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r443364635", "createdAt": "2020-06-22T07:27:12Z", "author": {"login": "xy720"}, "path": "be/src/olap/olap_common.h", "diffHunk": "@@ -169,6 +169,7 @@ enum PushType {\n     PUSH_NORMAL = 1,\n     PUSH_FOR_DELETE = 2,\n     PUSH_FOR_LOAD_DELETE = 3,\n+    PUSH_NORMAL_V2 = 4,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3MjI1MA=="}, "originalCommit": {"oid": "9500dd7a20bfa112093346acb1cd1341dad0fd8a"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1429, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}