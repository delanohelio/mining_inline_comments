{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNjU2NzEz", "number": 3278, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwODo1MjoxNVrODv5XKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1MzoxM1rODwB53g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTQ5NDgyOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwODo1MjoxNVrOGClYgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMDoxMDoyNlrOGCoZcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM2MjgxNw==", "bodyText": "Could we move this improve to ExprRewriteRule ?", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405362817", "createdAt": "2020-04-08T08:52:15Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQxMjIxMA==", "bodyText": "ExprRewriteRule will apply to expr bottom-up, this will make cannot get the longest or predicates, this rewrite needed  top-down", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405412210", "createdAt": "2020-04-08T10:10:26Z", "author": {"login": "yangzhg"}, "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM2MjgxNw=="}, "originalCommit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjg3MTQwOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo0ODoxM1rOGCyyZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo0ODoxM1rOGCyyZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MjQzOQ==", "bodyText": "Only exprs.size() < 2 is enough.\nexprs will not be NULL here.", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405582439", "createdAt": "2020-04-08T14:48:13Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {\n+        if (CollectionUtils.isEmpty(exprs) || exprs.size() < 2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjg3Njc0OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo0OToyNFrOGCy1sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo0OToyNFrOGCy1sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MzI4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // 1. remove duplcated elemnents [[a,a], [a, b], [a,b]] => [[a], [a,b]]\n          \n          \n            \n                    // 1. remove duplicated elements [[a,a], [a, b], [a,b]] => [[a], [a,b]]", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405583281", "createdAt": "2020-04-08T14:49:24Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {\n+        if (CollectionUtils.isEmpty(exprs) || exprs.size() < 2) {\n+            return null;\n+        }\n+        // 1. remove duplcated elemnents [[a,a], [a, b], [a,b]] => [[a], [a,b]]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjg4MTUzOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1MDoyN1rOGCy4wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1MDoyN1rOGCy4wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NDA2NQ==", "bodyText": "Better NOT to modify the parameter. It will make the method error-prone", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405584065", "createdAt": "2020-04-08T14:50:27Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {\n+        if (CollectionUtils.isEmpty(exprs) || exprs.size() < 2) {\n+            return null;\n+        }\n+        // 1. remove duplcated elemnents [[a,a], [a, b], [a,b]] => [[a], [a,b]]\n+        Set<Set<Expr>> set = new LinkedHashSet<>();\n+        for (List<Expr> ex : exprs) {\n+            Set<Expr> es = new LinkedHashSet<>();\n+            es.addAll(ex);\n+            set.add(es);\n+        }\n+        exprs.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjg5NDM4OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1MzoxM1rOGCzBEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1MzoxM1rOGCzBEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NjE5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.info(\"rewrite ors: \" + result.toSql());\n          \n          \n            \n                    LOG.debug(\"rewrite ors: \" + result.toSql());", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405586193", "createdAt": "2020-04-08T14:53:13Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {\n+        if (CollectionUtils.isEmpty(exprs) || exprs.size() < 2) {\n+            return null;\n+        }\n+        // 1. remove duplcated elemnents [[a,a], [a, b], [a,b]] => [[a], [a,b]]\n+        Set<Set<Expr>> set = new LinkedHashSet<>();\n+        for (List<Expr> ex : exprs) {\n+            Set<Expr> es = new LinkedHashSet<>();\n+            es.addAll(ex);\n+            set.add(es);\n+        }\n+        exprs.clear();\n+        for (Set<Expr> es : set) {\n+            List<Expr> el = new ArrayList<>();\n+            el.addAll(es);\n+            exprs.add(el);\n+        }\n+        if (exprs.size() == 1) {\n+            return makeCompound(exprs.get(0), CompoundPredicate.Operator.AND);\n+        }\n+        // 2. find duplcate cross the clause\n+        List<Expr> cloneExprs = new ArrayList<>(exprs.get(0));\n+        for (int i = 1; i < exprs.size(); ++i) {\n+            cloneExprs.retainAll(exprs.get(i));\n+        }\n+        List<Expr> temp = new ArrayList<>();\n+        if (CollectionUtils.isNotEmpty(cloneExprs)) {\n+            temp.add(makeCompound(cloneExprs, CompoundPredicate.Operator.AND));\n+        }\n+\n+        for (List<Expr> exprList : exprs) {\n+            exprList.removeAll(cloneExprs);\n+            temp.add(makeCompound(exprList, CompoundPredicate.Operator.AND));\n+        }\n+\n+        // rebuild CompoundPredicate if found duplicate predicate will build \uff08predcate) and (.. or ..)  predicate in\n+        // step 1: will build (.. or ..)\n+        Expr result = CollectionUtils.isNotEmpty(cloneExprs) ? new CompoundPredicate(CompoundPredicate.Operator.AND,\n+                temp.get(0), makeCompound(temp.subList(1, temp.size()), CompoundPredicate.Operator.OR))\n+                : makeCompound(temp, CompoundPredicate.Operator.OR);\n+        LOG.info(\"rewrite ors: \" + result.toSql());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba"}, "originalPosition": 128}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1882, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}