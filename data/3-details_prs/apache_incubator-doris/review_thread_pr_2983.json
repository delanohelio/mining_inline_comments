{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4OTU5Mzky", "number": 2983, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0MjoyNlrODkBp5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0MjoyNlrODkBp5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MTAyNDM4OnYy", "diffSide": "RIGHT", "path": "be/src/olap/fs/file_block_manager.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0MjoyNlrOFwJjgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0MjoyNlrOFwJjgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjUxMg==", "bodyText": "Why there is a private env() method?", "url": "https://github.com/apache/incubator-doris/pull/2983#discussion_r386032512", "createdAt": "2020-02-29T14:42:26Z", "author": {"login": "morningman"}, "path": "be/src/olap/fs/file_block_manager.h", "diffHunk": "@@ -0,0 +1,119 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"common/status.h\"\n+#include \"olap/fs/block_manager.h\"\n+\n+namespace doris {\n+\n+class BlockId;\n+class Env;\n+class MemTracker;\n+class RandomAccessFile;\n+\n+namespace fs {\n+namespace internal {\n+\n+class FileReadableBlock;\n+class FileWritableBlock;\n+struct BlockManagerMetrics;\n+\n+} // namespace internal\n+\n+// TODO(lingbin): When we create a batch of blocks(blocks are created one by one),\n+// eg, when we do a compaction,  multiple files will be generated in sequence.\n+// For this scenario, we should have a mechanism that can give the Operating System\n+// more opportunities to perform IO merge.\n+\n+// A file-backed block storage implementation.\n+//\n+// This is a naive block implementation which maps each block to its own\n+// file on disk.\n+//\n+// The block manager can take advantage of multiple filesystem paths.\n+//\n+// When creating blocks, the block manager will place blocks based on the\n+// provided CreateBlockOptions.\n+\n+// The file-backed block manager.\n+class FileBlockManager : public BlockManager {\n+public:\n+    // Note: all objects passed as pointers should remain alive for the lifetime\n+    // of the block manager.\n+    FileBlockManager(Env* env, BlockManagerOptions opts);\n+    virtual ~FileBlockManager();\n+\n+    Status open() override;\n+\n+    Status create_block(const CreateBlockOptions& opts,\n+                        std::unique_ptr<WritableBlock>* block) override;\n+    Status open_block(const std::string& path, std::unique_ptr<ReadableBlock>* block) override;\n+\n+    Status get_all_block_ids(std::vector<BlockId>* block_ids) override {\n+        // TODO(lingbin): to be implemented after we assign each block an id\n+        return Status::OK();\n+    };\n+\n+private:\n+    friend class internal::FileReadableBlock;\n+    friend class internal::FileWritableBlock;\n+\n+    // Deletes an existing block, allowing its space to be reclaimed by the\n+    // filesystem. The change is immediately made durable.\n+    //\n+    // Blocks may be deleted while they are open for reading or writing;\n+    // the actual deletion will take place after the last open reader or\n+    // writer is closed.\n+    Status _delete_block(const std::string& path);\n+\n+    // Synchronizes the metadata for a block with the given location.\n+    Status _sync_metadata(const std::string& path);\n+\n+    Env* env() const { return _env; }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fbe345a4d0fdd2f9cc420a5d5429f6fee982f42"}, "originalPosition": 94}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2041, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}