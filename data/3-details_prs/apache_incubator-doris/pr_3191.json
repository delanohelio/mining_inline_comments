{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzMzY2NDIy", "number": 3191, "title": "[Optimize][Delete] Simplify the delete process to make it fast", "bodyText": "#3190\nOur current DELETE strategy reuses the LoadChecker framework. Loadchecker runs jobs in different stages by polling them in every 5 seconds.\nThere are four stages of a load job, Pending/ETL/Loading/Quorum_finish, each of them is allocated to a LoadChecker. Four example, if a load job is submitted, it will be initialized to the pending state, then wait for running by the Pending LoadChecker. After the pending job is runned, its stage will change to ETL stage, and then wait for running by the next LoadChecker(ETL). Because interval time of the LoadChecker is 5s, in worst case, a pending job need to wait for 20s during its life cycle.\nIn particular, the DELETE jobs do not need to wait for polling, they can run the pushTask() function directly to delete. In this commit, I add a delete handler to concurrently processing delete tasks. All delete tasks will push to BE immediately, not required to wait for LoadCheker, without waiting for 2 LoadChecker(delete job started in LOADING state), at most 10s will be save(5s per LoadCheker). The delete process now is synchronized and users get response only after the delete finished or be canceled. If a delete is running over a certain period of time, it will be cancelled with a timeout exception.\n\u5f53\u524dDoris\u7684\u5220\u9664\u7b56\u7565\u662f\u8d70\u7684LoadChecker\u8def\u7ebf\uff0cDelete Job \u88ab\u89c6\u4e3a\u4e00\u822c\u7684Load Job\uff0c\u800c\u4e00\u822c\u7684Load Job\u9700\u8981\u7ecf\u8fc7\u4e00\u6b21LoadChecker\u7684\u8f6e\u8be2\u624d\u80fd\u6539\u53d8\u81ea\u5df1\u7684\u72b6\u6001\u3002\nLoad Job\u7684\u72b6\u6001\u53d8\u5316\u987a\u5e8f\u4e3aPENDING->ETL->LOADING->QUORUM_FINISHED\uff0c\u56e0\u4e3aLoadCheker\u7684\u8f6e\u8be2\u95f4\u9694\u4e3a5\u79d2\uff0c\u56e0\u6b64\u6700\u574f\u60c5\u51b5\u4e0bLoad Job\u9700\u8981\u7b49\u5f8520s\u65f6\u95f4\u3002\n\u4f46\u662fDelete Job\u4e00\u521d\u59cb\u5316\u5373\u4e3aLOADING\u72b6\u6001\uff0c\u751a\u81f3\u5b83\u6839\u672c\u4e0d\u9700\u8981\u72b6\u6001\uff0c\u76f4\u63a5\u63d0\u4ea4Push Task\u540e\u7b49\u5f85\u5c31\u53ef\u4ee5\u4e86\uff0c\u56e0\u6b64\u8fd9\u6b21\u63d0\u4ea4\u65e8\u5728\u5c06Delete Job\u4eceLoadChecker\u7684\u7cfb\u7edf\u4e2d\u5206\u79bb\u51fa\u6765\uff0c\u8282\u7701\u4e0d\u9700\u8981\u6d6a\u8d39\u7684\u65f6\u95f4\u3002\n\u6700\u597d\u60c5\u51b5\u4e0b\uff0c\u8ba9Delete Job\u76f4\u63a5push task\uff0c\u53ef\u4ee5\u8282\u77015\uff5e10s\u65f6\u95f4\uff0c\u5728\u63d0\u4ea4\u4efb\u52a1\u540e\uff0c\u6839\u636e\u6b64\u6b21\u63d0\u4ea4\u6d89\u53ca\u7684tablet\u6570\u91cf\u6307\u5b9a\u7b49\u5f85\u8d85\u65f6\u65f6\u95f4\uff0c\u8fd9\u6837\u540c\u6b65\u5220\u9664\u7684\u65b9\u5f0f\u4f7f\u4e00\u4e2aDelete Job\u88ab\u53d6\u6d88\u6216\u8005\u5b8c\u6210\u65f6\u7528\u6237\u80fd\u591f\u7acb\u523b\u6536\u5230\u6d88\u606f\uff0c\u6700\u540e\u6211\u4eec\u53ea\u8981\u6301\u4e45\u5316\u5df2\u5b8c\u6210\u7684Delete Job\uff0c\u4f9b\u7528\u6237show delete\u547d\u4ee4\u67e5\u627e\u5373\u53ef\u3002", "createdAt": "2020-03-25T03:38:37Z", "url": "https://github.com/apache/incubator-doris/pull/3191", "merged": true, "mergeCommit": {"oid": "b29cb9dbb3d32cf58a20036049420095011597e0"}, "closed": true, "closedAt": "2020-04-16T02:32:45Z", "author": {"login": "xy720"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVSCeOgBqjMyMDk1MTY3NTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcX5nAWAFqTM5Mzg3MzgyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b5dc0c3e30c1e02e14da091187f6d25f3ce7dc12", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/b5dc0c3e30c1e02e14da091187f6d25f3ce7dc12", "committedDate": "2020-03-25T03:24:47Z", "message": "commit 1: deleteV2"}, "afterCommit": {"oid": "7139a38c372fcbb0a203757eecb3b85f07b4e1f6", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/7139a38c372fcbb0a203757eecb3b85f07b4e1f6", "committedDate": "2020-04-07T11:55:10Z", "message": "commit 3: delete handler"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMDY5MzU4", "url": "https://github.com/apache/incubator-doris/pull/3191#pullrequestreview-390069358", "createdAt": "2020-04-08T15:11:31Z", "commit": {"oid": "1079ddafcafc794e3285d610c28d59fed5032191"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToxMTozMlrOGCz2NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTozNDo1NlrOGC07Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU5OTc5Nw==", "bodyText": "If begin transaction failed, exception will be thrown. So no need to check here.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r405599797", "createdAt": "2020-04-08T15:11:32Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteTask;\n+import org.apache.doris.task.MasterTaskExecutor;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.doris.transaction.TransactionStatus;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteTask\n+    private Map<Long, DeleteTask> idToDeleteTask;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    private MasterTaskExecutor executor;\n+\n+    private BlockingQueue<DeleteTask> queue;\n+\n+    private DeleteTaskChecker checker;\n+\n+    private ReentrantReadWriteLock lock;\n+\n+    public void readLock() {\n+        lock.readLock().lock();\n+    }\n+\n+    public void readUnlock() {\n+        lock.readLock().unlock();\n+    }\n+\n+    private void writeLock() {\n+        lock.writeLock().lock();\n+    }\n+\n+    private void writeUnlock() {\n+        lock.writeLock().unlock();\n+    }\n+\n+\n+    public DeleteHandler() {\n+        idToDeleteTask = Maps.newHashMap();\n+        dbToDeleteInfos = Maps.newHashMap();\n+        executor = new MasterTaskExecutor(Config.delete_thread_num);\n+        queue = new LinkedBlockingQueue(Config.delete_thread_num);\n+        lock = new ReentrantReadWriteLock(true);\n+        // start checker\n+        checker = new DeleteTaskChecker(queue);\n+        checker.start();\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteTask deleteTask = null;\n+        DeleteInfo deleteInfo = null;\n+        long transactionId;\n+        db.readLock();\n+        try {\n+            Table table = db.getTable(tableName);\n+            if (table == null) {\n+                throw new DdlException(\"Table does not exist. name: \" + tableName);\n+            }\n+\n+            if (table.getType() != Table.TableType.OLAP) {\n+                throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+            }\n+            OlapTable olapTable = (OlapTable) table;\n+\n+            if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                throw new DdlException(\"Table's state is not normal: \" + tableName);\n+            }\n+\n+\n+            if (partitionName == null) {\n+                if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                    throw new DdlException(\"This is a range partitioned table.\"\n+                            + \" You should specify partition in delete stmt\");\n+                } else {\n+                    // this is a unpartitioned table, use table name as partition name\n+                    partitionName = olapTable.getName();\n+                }\n+            }\n+\n+            Partition partition = olapTable.getPartition(partitionName);\n+            if (partition == null) {\n+                throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+            }\n+\n+            List<String> deleteConditions = Lists.newArrayList();\n+\n+            // pre check\n+            checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+            // generate label\n+            String label = \"delete_\" + UUID.randomUUID();\n+\n+            // begin txn here and generate txn id\n+            transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                    Lists.newArrayList(table.getId()), label,\"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                    TransactionState.LoadJobSourceType.FRONTEND, Config.stream_load_default_timeout_second);\n+\n+            TransactionState state = Catalog.getCurrentGlobalTransactionMgr()\n+                    .getTransactionState(transactionId);\n+            if (state == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1079ddafcafc794e3285d610c28d59fed5032191"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwMDIyNg==", "bodyText": "Use a concurrent map is enough", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r405600226", "createdAt": "2020-04-08T15:12:03Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteTask;\n+import org.apache.doris.task.MasterTaskExecutor;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.doris.transaction.TransactionStatus;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteTask\n+    private Map<Long, DeleteTask> idToDeleteTask;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    private MasterTaskExecutor executor;\n+\n+    private BlockingQueue<DeleteTask> queue;\n+\n+    private DeleteTaskChecker checker;\n+\n+    private ReentrantReadWriteLock lock;\n+\n+    public void readLock() {\n+        lock.readLock().lock();\n+    }\n+\n+    public void readUnlock() {\n+        lock.readLock().unlock();\n+    }\n+\n+    private void writeLock() {\n+        lock.writeLock().lock();\n+    }\n+\n+    private void writeUnlock() {\n+        lock.writeLock().unlock();\n+    }\n+\n+\n+    public DeleteHandler() {\n+        idToDeleteTask = Maps.newHashMap();\n+        dbToDeleteInfos = Maps.newHashMap();\n+        executor = new MasterTaskExecutor(Config.delete_thread_num);\n+        queue = new LinkedBlockingQueue(Config.delete_thread_num);\n+        lock = new ReentrantReadWriteLock(true);\n+        // start checker\n+        checker = new DeleteTaskChecker(queue);\n+        checker.start();\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteTask deleteTask = null;\n+        DeleteInfo deleteInfo = null;\n+        long transactionId;\n+        db.readLock();\n+        try {\n+            Table table = db.getTable(tableName);\n+            if (table == null) {\n+                throw new DdlException(\"Table does not exist. name: \" + tableName);\n+            }\n+\n+            if (table.getType() != Table.TableType.OLAP) {\n+                throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+            }\n+            OlapTable olapTable = (OlapTable) table;\n+\n+            if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                throw new DdlException(\"Table's state is not normal: \" + tableName);\n+            }\n+\n+\n+            if (partitionName == null) {\n+                if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                    throw new DdlException(\"This is a range partitioned table.\"\n+                            + \" You should specify partition in delete stmt\");\n+                } else {\n+                    // this is a unpartitioned table, use table name as partition name\n+                    partitionName = olapTable.getName();\n+                }\n+            }\n+\n+            Partition partition = olapTable.getPartition(partitionName);\n+            if (partition == null) {\n+                throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+            }\n+\n+            List<String> deleteConditions = Lists.newArrayList();\n+\n+            // pre check\n+            checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+            // generate label\n+            String label = \"delete_\" + UUID.randomUUID();\n+\n+            // begin txn here and generate txn id\n+            transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                    Lists.newArrayList(table.getId()), label,\"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                    TransactionState.LoadJobSourceType.FRONTEND, Config.stream_load_default_timeout_second);\n+\n+            TransactionState state = Catalog.getCurrentGlobalTransactionMgr()\n+                    .getTransactionState(transactionId);\n+            if (state == null) {\n+                throw new DdlException(\"begin transaction failed, cancel delete\");\n+            }\n+\n+            deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n+                    partition.getId(), partitionName,\n+                    -1, 0, deleteConditions);\n+\n+            // task in fe\n+            deleteTask = new DeleteTask(transactionId, deleteInfo);\n+\n+            writeLock();\n+            try {\n+                idToDeleteTask.put(transactionId, deleteTask);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1079ddafcafc794e3285d610c28d59fed5032191"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwNjkxMw==", "bodyText": "use commitAndPublishTransaction() instead, and then afterCommit() can be removed.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r405606913", "createdAt": "2020-04-08T15:21:03Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteTask;\n+import org.apache.doris.task.MasterTaskExecutor;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.doris.transaction.TransactionStatus;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteTask\n+    private Map<Long, DeleteTask> idToDeleteTask;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    private MasterTaskExecutor executor;\n+\n+    private BlockingQueue<DeleteTask> queue;\n+\n+    private DeleteTaskChecker checker;\n+\n+    private ReentrantReadWriteLock lock;\n+\n+    public void readLock() {\n+        lock.readLock().lock();\n+    }\n+\n+    public void readUnlock() {\n+        lock.readLock().unlock();\n+    }\n+\n+    private void writeLock() {\n+        lock.writeLock().lock();\n+    }\n+\n+    private void writeUnlock() {\n+        lock.writeLock().unlock();\n+    }\n+\n+\n+    public DeleteHandler() {\n+        idToDeleteTask = Maps.newHashMap();\n+        dbToDeleteInfos = Maps.newHashMap();\n+        executor = new MasterTaskExecutor(Config.delete_thread_num);\n+        queue = new LinkedBlockingQueue(Config.delete_thread_num);\n+        lock = new ReentrantReadWriteLock(true);\n+        // start checker\n+        checker = new DeleteTaskChecker(queue);\n+        checker.start();\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteTask deleteTask = null;\n+        DeleteInfo deleteInfo = null;\n+        long transactionId;\n+        db.readLock();\n+        try {\n+            Table table = db.getTable(tableName);\n+            if (table == null) {\n+                throw new DdlException(\"Table does not exist. name: \" + tableName);\n+            }\n+\n+            if (table.getType() != Table.TableType.OLAP) {\n+                throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+            }\n+            OlapTable olapTable = (OlapTable) table;\n+\n+            if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                throw new DdlException(\"Table's state is not normal: \" + tableName);\n+            }\n+\n+\n+            if (partitionName == null) {\n+                if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                    throw new DdlException(\"This is a range partitioned table.\"\n+                            + \" You should specify partition in delete stmt\");\n+                } else {\n+                    // this is a unpartitioned table, use table name as partition name\n+                    partitionName = olapTable.getName();\n+                }\n+            }\n+\n+            Partition partition = olapTable.getPartition(partitionName);\n+            if (partition == null) {\n+                throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+            }\n+\n+            List<String> deleteConditions = Lists.newArrayList();\n+\n+            // pre check\n+            checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+            // generate label\n+            String label = \"delete_\" + UUID.randomUUID();\n+\n+            // begin txn here and generate txn id\n+            transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                    Lists.newArrayList(table.getId()), label,\"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                    TransactionState.LoadJobSourceType.FRONTEND, Config.stream_load_default_timeout_second);\n+\n+            TransactionState state = Catalog.getCurrentGlobalTransactionMgr()\n+                    .getTransactionState(transactionId);\n+            if (state == null) {\n+                throw new DdlException(\"begin transaction failed, cancel delete\");\n+            }\n+\n+            deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n+                    partition.getId(), partitionName,\n+                    -1, 0, deleteConditions);\n+\n+            // task in fe\n+            deleteTask = new DeleteTask(transactionId, deleteInfo);\n+\n+            writeLock();\n+            try {\n+                idToDeleteTask.put(transactionId, deleteTask);\n+            } finally {\n+                writeUnlock();\n+            }\n+\n+            // task sent to be\n+            AgentBatchTask batchTask = new AgentBatchTask();\n+\n+            for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                long indexId = index.getId();\n+                int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n+\n+                for (Tablet tablet : index.getTablets()) {\n+                    long tabletId = tablet.getId();\n+\n+                    // set push type\n+                    TPushType type = TPushType.DELETE;\n+\n+                    Set<Long> allReplicas = new HashSet<Long>();\n+\n+                    for (Replica replica : tablet.getReplicas()) {\n+                        long replicaId = replica.getId();\n+                        allReplicas.add(replicaId);\n+\n+                        // create push task for each replica\n+                        PushTask pushTask = new PushTask(null,\n+                                replica.getBackendId(), db.getId(), olapTable.getId(),\n+                                partition.getId(), indexId,\n+                                tabletId, replicaId, schemaHash,\n+                                -1, 0, \"\", -1, 0,\n+                                -1, type, conditions,\n+                                true, TPriority.NORMAL,\n+                                TTaskType.REALTIME_PUSH,\n+                                transactionId,\n+                                Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n+                        pushTask.setIsSchemaChanging(true);\n+\n+                        if (AgentTaskQueue.addTask(pushTask)) {\n+                            batchTask.addTask(pushTask);\n+                            deleteTask.addTablet(tabletId);\n+                            deleteTask.addPushTask(pushTask);\n+                        }\n+\n+                    }\n+                }\n+            }\n+\n+            // submit push tasks\n+            if (batchTask.getTaskNum() > 0) {\n+                AgentTaskExecutor.submit(batchTask);\n+                queue.put(deleteTask);\n+            }\n+\n+        } catch (Throwable t) {\n+            LOG.warn(\"error occurred during delete process\", t);\n+            throw new DdlException(t.getMessage(), t);\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        long timeout = deleteTask.getTimeout();\n+        LOG.info(\"waiting delete task finish, signature: {}, timeout: {}\", transactionId, timeout);\n+        // wait until delete task finish or timeout\n+        deleteTask.join(timeout);\n+        if (deleteTask.isQuorum()) {\n+            commitTask(deleteTask, db);\n+        } else {\n+            boolean isSuccess = cancelTask(deleteTask, \"delete task timeout\");\n+            if (isSuccess) {\n+                throw new DdlException(\"timeout when waiting delete\");\n+            }\n+        }\n+\n+        // wait until transaction state become visible\n+        afterCommit(deleteTask, db, timeout);\n+    }\n+\n+    private void afterCommit(DeleteTask deleteTask, Database db, long leftTime) throws DdlException {\n+        try {\n+            long startDeleteTime = System.currentTimeMillis();\n+            long transactionId = deleteTask.getSignature();\n+            while (true) {\n+                db.writeLock();\n+                try {\n+                    // check if the job is aborted in transaction manager\n+                    TransactionState state = Catalog.getCurrentGlobalTransactionMgr()\n+                            .getTransactionState(transactionId);\n+                    if (state == null) {\n+                        LOG.warn(\"cancel delete, transactionId {},  because could not find transaction state\", transactionId);\n+                        cancelTask(deleteTask,\"transaction state lost\");\n+                        return;\n+                    }\n+                    TransactionStatus status = state.getTransactionStatus();\n+                    switch (status) {\n+                        case ABORTED:\n+                            cancelTask(deleteTask,\"delete transaction is aborted in transaction manager [\" + state + \"]\");\n+                            return;\n+                        case COMMITTED:\n+                            LOG.debug(\"delete task is already committed, just wait it to be visible, transactionId {}, transaction state {}\", transactionId, state);\n+                            return;\n+                        case VISIBLE:\n+                            LOG.debug(\"delete committed, transactionId: {}, transaction state {}\", transactionId, state);\n+                            removeTask(deleteTask);\n+                            return;\n+                    }\n+                    if (leftTime < System.currentTimeMillis() - startDeleteTime) {\n+                        cancelTask(deleteTask, \"delete timeout when waiting transaction commit\");\n+                    }\n+                } finally {\n+                    db.writeUnlock();\n+                }\n+                Thread.sleep(1000);\n+            }\n+        } catch (Exception e) {\n+            String failMsg = \"delete unknown, \" + e.getMessage();\n+            LOG.warn(failMsg, e);\n+            throw new DdlException(failMsg);\n+        }\n+    }\n+\n+    public class DeleteTaskChecker extends Thread {\n+        private BlockingQueue<DeleteTask> queue;\n+\n+        public DeleteTaskChecker(BlockingQueue<DeleteTask> queue) {\n+            this.queue = queue;\n+        }\n+\n+        @Override\n+        public void run() {\n+            LOG.info(\"delete task checker start\");\n+            try {\n+                loop();\n+            } finally {\n+                synchronized(queue) {\n+                    queue.clear();\n+                }\n+            }\n+        }\n+\n+        public void loop() {\n+            while (true) {\n+                try {\n+                    DeleteTask task = queue.take();\n+                    while (!task.isQuorum()) {\n+                        long signature = task.getSignature();\n+                        if (task.isCancel()) {\n+                            break;\n+                        }\n+                        if (!executor.submit(task)) {\n+                            Thread.sleep(1000);\n+                            continue;\n+                        }\n+                        // re add to the tail\n+                        queue.put(task);\n+                    }\n+                    // remove task isQuorum or isCanceled\n+                    removeTask(task);\n+                } catch (InterruptedException e) {\n+                    // do nothing\n+                }\n+            }\n+        }\n+    }\n+\n+    private void commitTask(DeleteTask task, Database db) {\n+        long transactionId = task.getSignature();\n+        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n+        TransactionState transactionState = globalTransactionMgr.getTransactionState(transactionId);\n+        List<TabletCommitInfo> tabletCommitInfos = new ArrayList<TabletCommitInfo>();\n+        db.writeLock();\n+        try {\n+            TabletInvertedIndex invertedIndex = Catalog.getCurrentInvertedIndex();\n+            for (TabletDeleteInfo tDeleteInfo : task.getTabletDeleteInfo()) {\n+                for (Replica replica : tDeleteInfo.getFinishedReplicas()) {\n+                    // the inverted index contains rolling up replica\n+                    Long tabletId = invertedIndex.getTabletIdByReplica(replica.getId());\n+                    if (tabletId == null) {\n+                        LOG.warn(\"could not find tablet id for replica {}, the tablet maybe dropped\", replica);\n+                        continue;\n+                    }\n+                    tabletCommitInfos.add(new TabletCommitInfo(tabletId, replica.getBackendId()));\n+                }\n+            }\n+            globalTransactionMgr.commitTransaction(db.getId(), transactionId, tabletCommitInfos);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1079ddafcafc794e3285d610c28d59fed5032191"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwODcxMw==", "bodyText": "Use GSON serde", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r405608713", "createdAt": "2020-04-08T15:23:23Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteTask;\n+import org.apache.doris.task.MasterTaskExecutor;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.doris.transaction.TransactionStatus;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteTask\n+    private Map<Long, DeleteTask> idToDeleteTask;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    private MasterTaskExecutor executor;\n+\n+    private BlockingQueue<DeleteTask> queue;\n+\n+    private DeleteTaskChecker checker;\n+\n+    private ReentrantReadWriteLock lock;\n+\n+    public void readLock() {\n+        lock.readLock().lock();\n+    }\n+\n+    public void readUnlock() {\n+        lock.readLock().unlock();\n+    }\n+\n+    private void writeLock() {\n+        lock.writeLock().lock();\n+    }\n+\n+    private void writeUnlock() {\n+        lock.writeLock().unlock();\n+    }\n+\n+\n+    public DeleteHandler() {\n+        idToDeleteTask = Maps.newHashMap();\n+        dbToDeleteInfos = Maps.newHashMap();\n+        executor = new MasterTaskExecutor(Config.delete_thread_num);\n+        queue = new LinkedBlockingQueue(Config.delete_thread_num);\n+        lock = new ReentrantReadWriteLock(true);\n+        // start checker\n+        checker = new DeleteTaskChecker(queue);\n+        checker.start();\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteTask deleteTask = null;\n+        DeleteInfo deleteInfo = null;\n+        long transactionId;\n+        db.readLock();\n+        try {\n+            Table table = db.getTable(tableName);\n+            if (table == null) {\n+                throw new DdlException(\"Table does not exist. name: \" + tableName);\n+            }\n+\n+            if (table.getType() != Table.TableType.OLAP) {\n+                throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+            }\n+            OlapTable olapTable = (OlapTable) table;\n+\n+            if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                throw new DdlException(\"Table's state is not normal: \" + tableName);\n+            }\n+\n+\n+            if (partitionName == null) {\n+                if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                    throw new DdlException(\"This is a range partitioned table.\"\n+                            + \" You should specify partition in delete stmt\");\n+                } else {\n+                    // this is a unpartitioned table, use table name as partition name\n+                    partitionName = olapTable.getName();\n+                }\n+            }\n+\n+            Partition partition = olapTable.getPartition(partitionName);\n+            if (partition == null) {\n+                throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+            }\n+\n+            List<String> deleteConditions = Lists.newArrayList();\n+\n+            // pre check\n+            checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+            // generate label\n+            String label = \"delete_\" + UUID.randomUUID();\n+\n+            // begin txn here and generate txn id\n+            transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                    Lists.newArrayList(table.getId()), label,\"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                    TransactionState.LoadJobSourceType.FRONTEND, Config.stream_load_default_timeout_second);\n+\n+            TransactionState state = Catalog.getCurrentGlobalTransactionMgr()\n+                    .getTransactionState(transactionId);\n+            if (state == null) {\n+                throw new DdlException(\"begin transaction failed, cancel delete\");\n+            }\n+\n+            deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n+                    partition.getId(), partitionName,\n+                    -1, 0, deleteConditions);\n+\n+            // task in fe\n+            deleteTask = new DeleteTask(transactionId, deleteInfo);\n+\n+            writeLock();\n+            try {\n+                idToDeleteTask.put(transactionId, deleteTask);\n+            } finally {\n+                writeUnlock();\n+            }\n+\n+            // task sent to be\n+            AgentBatchTask batchTask = new AgentBatchTask();\n+\n+            for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                long indexId = index.getId();\n+                int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n+\n+                for (Tablet tablet : index.getTablets()) {\n+                    long tabletId = tablet.getId();\n+\n+                    // set push type\n+                    TPushType type = TPushType.DELETE;\n+\n+                    Set<Long> allReplicas = new HashSet<Long>();\n+\n+                    for (Replica replica : tablet.getReplicas()) {\n+                        long replicaId = replica.getId();\n+                        allReplicas.add(replicaId);\n+\n+                        // create push task for each replica\n+                        PushTask pushTask = new PushTask(null,\n+                                replica.getBackendId(), db.getId(), olapTable.getId(),\n+                                partition.getId(), indexId,\n+                                tabletId, replicaId, schemaHash,\n+                                -1, 0, \"\", -1, 0,\n+                                -1, type, conditions,\n+                                true, TPriority.NORMAL,\n+                                TTaskType.REALTIME_PUSH,\n+                                transactionId,\n+                                Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n+                        pushTask.setIsSchemaChanging(true);\n+\n+                        if (AgentTaskQueue.addTask(pushTask)) {\n+                            batchTask.addTask(pushTask);\n+                            deleteTask.addTablet(tabletId);\n+                            deleteTask.addPushTask(pushTask);\n+                        }\n+\n+                    }\n+                }\n+            }\n+\n+            // submit push tasks\n+            if (batchTask.getTaskNum() > 0) {\n+                AgentTaskExecutor.submit(batchTask);\n+                queue.put(deleteTask);\n+            }\n+\n+        } catch (Throwable t) {\n+            LOG.warn(\"error occurred during delete process\", t);\n+            throw new DdlException(t.getMessage(), t);\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        long timeout = deleteTask.getTimeout();\n+        LOG.info(\"waiting delete task finish, signature: {}, timeout: {}\", transactionId, timeout);\n+        // wait until delete task finish or timeout\n+        deleteTask.join(timeout);\n+        if (deleteTask.isQuorum()) {\n+            commitTask(deleteTask, db);\n+        } else {\n+            boolean isSuccess = cancelTask(deleteTask, \"delete task timeout\");\n+            if (isSuccess) {\n+                throw new DdlException(\"timeout when waiting delete\");\n+            }\n+        }\n+\n+        // wait until transaction state become visible\n+        afterCommit(deleteTask, db, timeout);\n+    }\n+\n+    private void afterCommit(DeleteTask deleteTask, Database db, long leftTime) throws DdlException {\n+        try {\n+            long startDeleteTime = System.currentTimeMillis();\n+            long transactionId = deleteTask.getSignature();\n+            while (true) {\n+                db.writeLock();\n+                try {\n+                    // check if the job is aborted in transaction manager\n+                    TransactionState state = Catalog.getCurrentGlobalTransactionMgr()\n+                            .getTransactionState(transactionId);\n+                    if (state == null) {\n+                        LOG.warn(\"cancel delete, transactionId {},  because could not find transaction state\", transactionId);\n+                        cancelTask(deleteTask,\"transaction state lost\");\n+                        return;\n+                    }\n+                    TransactionStatus status = state.getTransactionStatus();\n+                    switch (status) {\n+                        case ABORTED:\n+                            cancelTask(deleteTask,\"delete transaction is aborted in transaction manager [\" + state + \"]\");\n+                            return;\n+                        case COMMITTED:\n+                            LOG.debug(\"delete task is already committed, just wait it to be visible, transactionId {}, transaction state {}\", transactionId, state);\n+                            return;\n+                        case VISIBLE:\n+                            LOG.debug(\"delete committed, transactionId: {}, transaction state {}\", transactionId, state);\n+                            removeTask(deleteTask);\n+                            return;\n+                    }\n+                    if (leftTime < System.currentTimeMillis() - startDeleteTime) {\n+                        cancelTask(deleteTask, \"delete timeout when waiting transaction commit\");\n+                    }\n+                } finally {\n+                    db.writeUnlock();\n+                }\n+                Thread.sleep(1000);\n+            }\n+        } catch (Exception e) {\n+            String failMsg = \"delete unknown, \" + e.getMessage();\n+            LOG.warn(failMsg, e);\n+            throw new DdlException(failMsg);\n+        }\n+    }\n+\n+    public class DeleteTaskChecker extends Thread {\n+        private BlockingQueue<DeleteTask> queue;\n+\n+        public DeleteTaskChecker(BlockingQueue<DeleteTask> queue) {\n+            this.queue = queue;\n+        }\n+\n+        @Override\n+        public void run() {\n+            LOG.info(\"delete task checker start\");\n+            try {\n+                loop();\n+            } finally {\n+                synchronized(queue) {\n+                    queue.clear();\n+                }\n+            }\n+        }\n+\n+        public void loop() {\n+            while (true) {\n+                try {\n+                    DeleteTask task = queue.take();\n+                    while (!task.isQuorum()) {\n+                        long signature = task.getSignature();\n+                        if (task.isCancel()) {\n+                            break;\n+                        }\n+                        if (!executor.submit(task)) {\n+                            Thread.sleep(1000);\n+                            continue;\n+                        }\n+                        // re add to the tail\n+                        queue.put(task);\n+                    }\n+                    // remove task isQuorum or isCanceled\n+                    removeTask(task);\n+                } catch (InterruptedException e) {\n+                    // do nothing\n+                }\n+            }\n+        }\n+    }\n+\n+    private void commitTask(DeleteTask task, Database db) {\n+        long transactionId = task.getSignature();\n+        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n+        TransactionState transactionState = globalTransactionMgr.getTransactionState(transactionId);\n+        List<TabletCommitInfo> tabletCommitInfos = new ArrayList<TabletCommitInfo>();\n+        db.writeLock();\n+        try {\n+            TabletInvertedIndex invertedIndex = Catalog.getCurrentInvertedIndex();\n+            for (TabletDeleteInfo tDeleteInfo : task.getTabletDeleteInfo()) {\n+                for (Replica replica : tDeleteInfo.getFinishedReplicas()) {\n+                    // the inverted index contains rolling up replica\n+                    Long tabletId = invertedIndex.getTabletIdByReplica(replica.getId());\n+                    if (tabletId == null) {\n+                        LOG.warn(\"could not find tablet id for replica {}, the tablet maybe dropped\", replica);\n+                        continue;\n+                    }\n+                    tabletCommitInfos.add(new TabletCommitInfo(tabletId, replica.getBackendId()));\n+                }\n+            }\n+            globalTransactionMgr.commitTransaction(db.getId(), transactionId, tabletCommitInfos);\n+        } catch (UserException e) {\n+            LOG.warn(\"errors while commit delete, transaction [{}], reason is {}\",\n+                    transactionState.getTransactionId(),  e);\n+            cancelTask(task, transactionState.getReason());\n+        } finally {\n+            db.writeUnlock();\n+        }\n+    }\n+\n+    public void removeTask(DeleteTask task) {\n+        task.unJoin();\n+        writeLock();\n+        try {\n+            long signature = task.getSignature();\n+            if (idToDeleteTask.containsKey(signature)) {\n+                idToDeleteTask.remove(signature);\n+            }\n+            for (PushTask pushTask : task.getPushTasks()) {\n+                AgentTaskQueue.removePushTask(pushTask.getBackendId(), pushTask.getSignature(),\n+                        pushTask.getVersion(), pushTask.getVersionHash(),\n+                        pushTask.getPushType(), pushTask.getTaskType());\n+            }\n+            if (task.isQuorum()) {\n+                DeleteInfo deleteInfo = task.getDeleteInfo();\n+                long dbId = deleteInfo.getDbId();\n+                if (dbToDeleteInfos.containsKey(dbId)) {\n+                    dbToDeleteInfos.get(dbId).add(deleteInfo);\n+                } else {\n+                    List<DeleteInfo> deleteInfoList = Lists.newArrayList();\n+                    deleteInfoList.add(deleteInfo);\n+                    dbToDeleteInfos.put(dbId, deleteInfoList);\n+                }\n+                Catalog.getInstance().getEditLog().logFinishSyncDelete(deleteInfo);\n+            }\n+        } finally {\n+            writeUnlock();\n+        }\n+    }\n+\n+    public boolean cancelTask(DeleteTask task, String reason) {\n+        try {\n+            if (task != null) {\n+                task.setCancel();\n+                Catalog.getCurrentGlobalTransactionMgr().abortTransaction(\n+                        task.getSignature(), reason);\n+                return true;\n+            }\n+        } catch (Exception e) {\n+            LOG.info(\"errors while abort transaction\", e);\n+        }\n+        return false;\n+    }\n+\n+    private void checkDeleteV2(OlapTable table, Partition partition, List<Predicate> conditions, List<String> deleteConditions, boolean preCheck)\n+            throws DdlException {\n+\n+        // check partition state\n+        Partition.PartitionState state = partition.getState();\n+        if (state != Partition.PartitionState.NORMAL) {\n+            // ErrorReport.reportDdlException(ErrorCode.ERR_BAD_PARTITION_STATE, partition.getName(), state.name());\n+            throw new DdlException(\"Partition[\" + partition.getName() + \"]' state is not NORMAL: \" + state.name());\n+        }\n+\n+        // check condition column is key column and condition value\n+        Map<String, Column> nameToColumn = Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);\n+        for (Column column : table.getBaseSchema()) {\n+            nameToColumn.put(column.getName(), column);\n+        }\n+        for (Predicate condition : conditions) {\n+            SlotRef slotRef = null;\n+            if (condition instanceof BinaryPredicate) {\n+                BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n+                slotRef = (SlotRef) binaryPredicate.getChild(0);\n+            } else if (condition instanceof IsNullPredicate) {\n+                IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n+                slotRef = (SlotRef) isNullPredicate.getChild(0);\n+            }\n+            String columnName = slotRef.getColumnName();\n+            if (!nameToColumn.containsKey(columnName)) {\n+                ErrorReport.reportDdlException(ErrorCode.ERR_BAD_FIELD_ERROR, columnName, table.getName());\n+            }\n+\n+            Column column = nameToColumn.get(columnName);\n+            if (!column.isKey()) {\n+                // ErrorReport.reportDdlException(ErrorCode.ERR_NOT_KEY_COLUMN, columnName);\n+                throw new DdlException(\"Column[\" + columnName + \"] is not key column\");\n+            }\n+\n+            if (condition instanceof BinaryPredicate) {\n+                String value = null;\n+                try {\n+                    BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n+                    value = ((LiteralExpr) binaryPredicate.getChild(1)).getStringValue();\n+                    LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n+                } catch (AnalysisException e) {\n+                    // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);\n+                    throw new DdlException(\"Invalid column value[\" + value + \"]\");\n+                }\n+            }\n+\n+            // set schema column name\n+            slotRef.setCol(column.getName());\n+        }\n+        Map<Long, List<Column>> indexIdToSchema = table.getIndexIdToSchema();\n+        for (MaterializedIndex index : partition.getMaterializedIndices(MaterializedIndex.IndexExtState.VISIBLE)) {\n+            // check table has condition column\n+            Map<String, Column> indexColNameToColumn = Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);\n+            for (Column column : indexIdToSchema.get(index.getId())) {\n+                indexColNameToColumn.put(column.getName(), column);\n+            }\n+            String indexName = table.getIndexNameById(index.getId());\n+            for (Predicate condition : conditions) {\n+                String columnName = null;\n+                if (condition instanceof BinaryPredicate) {\n+                    BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n+                    columnName = ((SlotRef) binaryPredicate.getChild(0)).getColumnName();\n+                } else if (condition instanceof IsNullPredicate) {\n+                    IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n+                    columnName = ((SlotRef) isNullPredicate.getChild(0)).getColumnName();\n+                }\n+                Column column = indexColNameToColumn.get(columnName);\n+                if (column == null) {\n+                    ErrorReport.reportDdlException(ErrorCode.ERR_BAD_FIELD_ERROR, columnName, indexName);\n+                }\n+\n+                if (table.getKeysType() == KeysType.DUP_KEYS && !column.isKey()) {\n+                    throw new DdlException(\"Column[\" + columnName + \"] is not key column in index[\" + indexName + \"]\");\n+                }\n+            }\n+        }\n+\n+        if (deleteConditions == null) {\n+            return;\n+        }\n+\n+        // save delete conditions\n+        for (Predicate condition : conditions) {\n+            if (condition instanceof BinaryPredicate) {\n+                BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n+                SlotRef slotRef = (SlotRef) binaryPredicate.getChild(0);\n+                String columnName = slotRef.getColumnName();\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(columnName).append(\" \").append(binaryPredicate.getOp().name()).append(\" \\\"\")\n+                        .append(((LiteralExpr) binaryPredicate.getChild(1)).getStringValue()).append(\"\\\"\");\n+                deleteConditions.add(sb.toString());\n+            } else if (condition instanceof IsNullPredicate) {\n+                IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n+                SlotRef slotRef = (SlotRef) isNullPredicate.getChild(0);\n+                String columnName = slotRef.getColumnName();\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(columnName);\n+                if (isNullPredicate.isNotNull()) {\n+                    sb.append(\" IS NOT NULL\");\n+                } else {\n+                    sb.append(\" IS NULL\");\n+                }\n+                deleteConditions.add(sb.toString());\n+            }\n+        }\n+    }\n+\n+    // show delete stmt\n+    public List<List<Comparable>> getDeleteInfosByDb(long dbId, boolean forUser) {\n+        LinkedList<List<Comparable>> infos = new LinkedList<List<Comparable>>();\n+        Database db = Catalog.getInstance().getDb(dbId);\n+        if (db == null) {\n+            return infos;\n+        }\n+\n+        String dbName = db.getFullName();\n+        readLock();\n+        try {\n+            List<DeleteInfo> deleteInfos = dbToDeleteInfos.get(dbId);\n+            if (deleteInfos == null) {\n+                return infos;\n+            }\n+\n+            for (DeleteInfo deleteInfo : deleteInfos) {\n+\n+                if (!Catalog.getCurrentCatalog().getAuth().checkTblPriv(ConnectContext.get(), dbName,\n+                        deleteInfo.getTableName(),\n+                        PrivPredicate.LOAD)) {\n+                    continue;\n+                }\n+\n+\n+                List<Comparable> info = Lists.newArrayList();\n+                if (!forUser) {\n+                    // There is no job for delete, set job id to -1\n+                    info.add(-1L);\n+                    info.add(deleteInfo.getTableId());\n+                }\n+                info.add(deleteInfo.getTableName());\n+                if (!forUser) {\n+                    info.add(deleteInfo.getPartitionId());\n+                }\n+                info.add(deleteInfo.getPartitionName());\n+\n+                info.add(TimeUtils.longToTimeString(deleteInfo.getCreateTimeMs()));\n+                String conds = Joiner.on(\", \").join(deleteInfo.getDeleteConditions());\n+                info.add(conds);\n+\n+                if (!forUser) {\n+                    info.add(deleteInfo.getPartitionVersion());\n+                    info.add(deleteInfo.getPartitionVersionHash());\n+                }\n+                // for loading state, should not display loading, show deleting instead\n+//                if (loadJob.getState() == LoadJob.JobState.LOADING) {\n+//                    info.add(\"DELETING\");\n+//                } else {\n+//                    info.add(loadJob.getState().name());\n+//                }\n+                info.add(\"FINISHED\");\n+                infos.add(info);\n+            }\n+\n+        } finally {\n+            readUnlock();\n+        }\n+\n+        // sort by createTimeMs\n+        int sortIndex;\n+        if (!forUser) {\n+            sortIndex = 5;\n+        } else {\n+            sortIndex = 2;\n+        }\n+        ListComparator<List<Comparable>> comparator = new ListComparator<List<Comparable>>(sortIndex);\n+        Collections.sort(infos, comparator);\n+        return infos;\n+    }\n+\n+    public boolean addFinishedReplica(Long transactionId, long tabletId, Replica replica) {\n+        writeLock();\n+        try {\n+            DeleteTask task = idToDeleteTask.get(transactionId);\n+            if (task != null) {\n+                return task.addFinishedReplica(tabletId, replica);\n+            } else {\n+                return false;\n+            }\n+        } finally {\n+            writeUnlock();\n+        }\n+    }\n+\n+    public void replayDelete(DeleteInfo deleteInfo, Catalog catalog) {\n+        Database db = catalog.getDb(deleteInfo.getDbId());\n+        db.writeLock();\n+        try {\n+            writeLock();\n+            try {\n+                // add to deleteInfos\n+                long dbId = deleteInfo.getDbId();\n+                List<DeleteInfo> deleteInfos = dbToDeleteInfos.get(dbId);\n+                if (deleteInfos == null) {\n+                    deleteInfos = Lists.newArrayList();\n+                    dbToDeleteInfos.put(dbId, deleteInfos);\n+                }\n+                deleteInfos.add(deleteInfo);\n+            } finally {\n+                writeUnlock();\n+            }\n+        } finally {\n+            db.writeUnlock();\n+        }\n+    }\n+\n+    // for delete handler, we only persist those delete already finished.\n+    @Override\n+    public void write(DataOutput out) throws IOException {\n+        out.writeInt(dbToDeleteInfos.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1079ddafcafc794e3285d610c28d59fed5032191"}, "originalPosition": 660}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxMDQ0Ng==", "bodyText": "this logic is wrong.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r405610446", "createdAt": "2020-04-08T15:25:35Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteTask;\n+import org.apache.doris.task.MasterTaskExecutor;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.doris.transaction.TransactionStatus;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteTask\n+    private Map<Long, DeleteTask> idToDeleteTask;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    private MasterTaskExecutor executor;\n+\n+    private BlockingQueue<DeleteTask> queue;\n+\n+    private DeleteTaskChecker checker;\n+\n+    private ReentrantReadWriteLock lock;\n+\n+    public void readLock() {\n+        lock.readLock().lock();\n+    }\n+\n+    public void readUnlock() {\n+        lock.readLock().unlock();\n+    }\n+\n+    private void writeLock() {\n+        lock.writeLock().lock();\n+    }\n+\n+    private void writeUnlock() {\n+        lock.writeLock().unlock();\n+    }\n+\n+\n+    public DeleteHandler() {\n+        idToDeleteTask = Maps.newHashMap();\n+        dbToDeleteInfos = Maps.newHashMap();\n+        executor = new MasterTaskExecutor(Config.delete_thread_num);\n+        queue = new LinkedBlockingQueue(Config.delete_thread_num);\n+        lock = new ReentrantReadWriteLock(true);\n+        // start checker\n+        checker = new DeleteTaskChecker(queue);\n+        checker.start();\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteTask deleteTask = null;\n+        DeleteInfo deleteInfo = null;\n+        long transactionId;\n+        db.readLock();\n+        try {\n+            Table table = db.getTable(tableName);\n+            if (table == null) {\n+                throw new DdlException(\"Table does not exist. name: \" + tableName);\n+            }\n+\n+            if (table.getType() != Table.TableType.OLAP) {\n+                throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+            }\n+            OlapTable olapTable = (OlapTable) table;\n+\n+            if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                throw new DdlException(\"Table's state is not normal: \" + tableName);\n+            }\n+\n+\n+            if (partitionName == null) {\n+                if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                    throw new DdlException(\"This is a range partitioned table.\"\n+                            + \" You should specify partition in delete stmt\");\n+                } else {\n+                    // this is a unpartitioned table, use table name as partition name\n+                    partitionName = olapTable.getName();\n+                }\n+            }\n+\n+            Partition partition = olapTable.getPartition(partitionName);\n+            if (partition == null) {\n+                throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+            }\n+\n+            List<String> deleteConditions = Lists.newArrayList();\n+\n+            // pre check\n+            checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+            // generate label\n+            String label = \"delete_\" + UUID.randomUUID();\n+\n+            // begin txn here and generate txn id\n+            transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                    Lists.newArrayList(table.getId()), label,\"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                    TransactionState.LoadJobSourceType.FRONTEND, Config.stream_load_default_timeout_second);\n+\n+            TransactionState state = Catalog.getCurrentGlobalTransactionMgr()\n+                    .getTransactionState(transactionId);\n+            if (state == null) {\n+                throw new DdlException(\"begin transaction failed, cancel delete\");\n+            }\n+\n+            deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n+                    partition.getId(), partitionName,\n+                    -1, 0, deleteConditions);\n+\n+            // task in fe\n+            deleteTask = new DeleteTask(transactionId, deleteInfo);\n+\n+            writeLock();\n+            try {\n+                idToDeleteTask.put(transactionId, deleteTask);\n+            } finally {\n+                writeUnlock();\n+            }\n+\n+            // task sent to be\n+            AgentBatchTask batchTask = new AgentBatchTask();\n+\n+            for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                long indexId = index.getId();\n+                int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n+\n+                for (Tablet tablet : index.getTablets()) {\n+                    long tabletId = tablet.getId();\n+\n+                    // set push type\n+                    TPushType type = TPushType.DELETE;\n+\n+                    Set<Long> allReplicas = new HashSet<Long>();\n+\n+                    for (Replica replica : tablet.getReplicas()) {\n+                        long replicaId = replica.getId();\n+                        allReplicas.add(replicaId);\n+\n+                        // create push task for each replica\n+                        PushTask pushTask = new PushTask(null,\n+                                replica.getBackendId(), db.getId(), olapTable.getId(),\n+                                partition.getId(), indexId,\n+                                tabletId, replicaId, schemaHash,\n+                                -1, 0, \"\", -1, 0,\n+                                -1, type, conditions,\n+                                true, TPriority.NORMAL,\n+                                TTaskType.REALTIME_PUSH,\n+                                transactionId,\n+                                Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n+                        pushTask.setIsSchemaChanging(true);\n+\n+                        if (AgentTaskQueue.addTask(pushTask)) {\n+                            batchTask.addTask(pushTask);\n+                            deleteTask.addTablet(tabletId);\n+                            deleteTask.addPushTask(pushTask);\n+                        }\n+\n+                    }\n+                }\n+            }\n+\n+            // submit push tasks\n+            if (batchTask.getTaskNum() > 0) {\n+                AgentTaskExecutor.submit(batchTask);\n+                queue.put(deleteTask);\n+            }\n+\n+        } catch (Throwable t) {\n+            LOG.warn(\"error occurred during delete process\", t);\n+            throw new DdlException(t.getMessage(), t);\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        long timeout = deleteTask.getTimeout();\n+        LOG.info(\"waiting delete task finish, signature: {}, timeout: {}\", transactionId, timeout);\n+        // wait until delete task finish or timeout\n+        deleteTask.join(timeout);\n+        if (deleteTask.isQuorum()) {\n+            commitTask(deleteTask, db);\n+        } else {\n+            boolean isSuccess = cancelTask(deleteTask, \"delete task timeout\");\n+            if (isSuccess) {\n+                throw new DdlException(\"timeout when waiting delete\");\n+            }\n+        }\n+\n+        // wait until transaction state become visible\n+        afterCommit(deleteTask, db, timeout);\n+    }\n+\n+    private void afterCommit(DeleteTask deleteTask, Database db, long leftTime) throws DdlException {\n+        try {\n+            long startDeleteTime = System.currentTimeMillis();\n+            long transactionId = deleteTask.getSignature();\n+            while (true) {\n+                db.writeLock();\n+                try {\n+                    // check if the job is aborted in transaction manager\n+                    TransactionState state = Catalog.getCurrentGlobalTransactionMgr()\n+                            .getTransactionState(transactionId);\n+                    if (state == null) {\n+                        LOG.warn(\"cancel delete, transactionId {},  because could not find transaction state\", transactionId);\n+                        cancelTask(deleteTask,\"transaction state lost\");\n+                        return;\n+                    }\n+                    TransactionStatus status = state.getTransactionStatus();\n+                    switch (status) {\n+                        case ABORTED:\n+                            cancelTask(deleteTask,\"delete transaction is aborted in transaction manager [\" + state + \"]\");\n+                            return;\n+                        case COMMITTED:\n+                            LOG.debug(\"delete task is already committed, just wait it to be visible, transactionId {}, transaction state {}\", transactionId, state);\n+                            return;\n+                        case VISIBLE:\n+                            LOG.debug(\"delete committed, transactionId: {}, transaction state {}\", transactionId, state);\n+                            removeTask(deleteTask);\n+                            return;\n+                    }\n+                    if (leftTime < System.currentTimeMillis() - startDeleteTime) {\n+                        cancelTask(deleteTask, \"delete timeout when waiting transaction commit\");\n+                    }\n+                } finally {\n+                    db.writeUnlock();\n+                }\n+                Thread.sleep(1000);\n+            }\n+        } catch (Exception e) {\n+            String failMsg = \"delete unknown, \" + e.getMessage();\n+            LOG.warn(failMsg, e);\n+            throw new DdlException(failMsg);\n+        }\n+    }\n+\n+    public class DeleteTaskChecker extends Thread {\n+        private BlockingQueue<DeleteTask> queue;\n+\n+        public DeleteTaskChecker(BlockingQueue<DeleteTask> queue) {\n+            this.queue = queue;\n+        }\n+\n+        @Override\n+        public void run() {\n+            LOG.info(\"delete task checker start\");\n+            try {\n+                loop();\n+            } finally {\n+                synchronized(queue) {\n+                    queue.clear();\n+                }\n+            }\n+        }\n+\n+        public void loop() {\n+            while (true) {\n+                try {\n+                    DeleteTask task = queue.take();\n+                    while (!task.isQuorum()) {\n+                        long signature = task.getSignature();\n+                        if (task.isCancel()) {\n+                            break;\n+                        }\n+                        if (!executor.submit(task)) {\n+                            Thread.sleep(1000);\n+                            continue;\n+                        }\n+                        // re add to the tail\n+                        queue.put(task);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1079ddafcafc794e3285d610c28d59fed5032191"}, "originalPosition": 358}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxNzQxNQ==", "bodyText": "You can not write log here, because the transaction may commit fail", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r405617415", "createdAt": "2020-04-08T15:34:56Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteTask;\n+import org.apache.doris.task.MasterTaskExecutor;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.doris.transaction.TransactionStatus;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteTask\n+    private Map<Long, DeleteTask> idToDeleteTask;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    private MasterTaskExecutor executor;\n+\n+    private BlockingQueue<DeleteTask> queue;\n+\n+    private DeleteTaskChecker checker;\n+\n+    private ReentrantReadWriteLock lock;\n+\n+    public void readLock() {\n+        lock.readLock().lock();\n+    }\n+\n+    public void readUnlock() {\n+        lock.readLock().unlock();\n+    }\n+\n+    private void writeLock() {\n+        lock.writeLock().lock();\n+    }\n+\n+    private void writeUnlock() {\n+        lock.writeLock().unlock();\n+    }\n+\n+\n+    public DeleteHandler() {\n+        idToDeleteTask = Maps.newHashMap();\n+        dbToDeleteInfos = Maps.newHashMap();\n+        executor = new MasterTaskExecutor(Config.delete_thread_num);\n+        queue = new LinkedBlockingQueue(Config.delete_thread_num);\n+        lock = new ReentrantReadWriteLock(true);\n+        // start checker\n+        checker = new DeleteTaskChecker(queue);\n+        checker.start();\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteTask deleteTask = null;\n+        DeleteInfo deleteInfo = null;\n+        long transactionId;\n+        db.readLock();\n+        try {\n+            Table table = db.getTable(tableName);\n+            if (table == null) {\n+                throw new DdlException(\"Table does not exist. name: \" + tableName);\n+            }\n+\n+            if (table.getType() != Table.TableType.OLAP) {\n+                throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+            }\n+            OlapTable olapTable = (OlapTable) table;\n+\n+            if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                throw new DdlException(\"Table's state is not normal: \" + tableName);\n+            }\n+\n+\n+            if (partitionName == null) {\n+                if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                    throw new DdlException(\"This is a range partitioned table.\"\n+                            + \" You should specify partition in delete stmt\");\n+                } else {\n+                    // this is a unpartitioned table, use table name as partition name\n+                    partitionName = olapTable.getName();\n+                }\n+            }\n+\n+            Partition partition = olapTable.getPartition(partitionName);\n+            if (partition == null) {\n+                throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+            }\n+\n+            List<String> deleteConditions = Lists.newArrayList();\n+\n+            // pre check\n+            checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+            // generate label\n+            String label = \"delete_\" + UUID.randomUUID();\n+\n+            // begin txn here and generate txn id\n+            transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                    Lists.newArrayList(table.getId()), label,\"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                    TransactionState.LoadJobSourceType.FRONTEND, Config.stream_load_default_timeout_second);\n+\n+            TransactionState state = Catalog.getCurrentGlobalTransactionMgr()\n+                    .getTransactionState(transactionId);\n+            if (state == null) {\n+                throw new DdlException(\"begin transaction failed, cancel delete\");\n+            }\n+\n+            deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n+                    partition.getId(), partitionName,\n+                    -1, 0, deleteConditions);\n+\n+            // task in fe\n+            deleteTask = new DeleteTask(transactionId, deleteInfo);\n+\n+            writeLock();\n+            try {\n+                idToDeleteTask.put(transactionId, deleteTask);\n+            } finally {\n+                writeUnlock();\n+            }\n+\n+            // task sent to be\n+            AgentBatchTask batchTask = new AgentBatchTask();\n+\n+            for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                long indexId = index.getId();\n+                int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n+\n+                for (Tablet tablet : index.getTablets()) {\n+                    long tabletId = tablet.getId();\n+\n+                    // set push type\n+                    TPushType type = TPushType.DELETE;\n+\n+                    Set<Long> allReplicas = new HashSet<Long>();\n+\n+                    for (Replica replica : tablet.getReplicas()) {\n+                        long replicaId = replica.getId();\n+                        allReplicas.add(replicaId);\n+\n+                        // create push task for each replica\n+                        PushTask pushTask = new PushTask(null,\n+                                replica.getBackendId(), db.getId(), olapTable.getId(),\n+                                partition.getId(), indexId,\n+                                tabletId, replicaId, schemaHash,\n+                                -1, 0, \"\", -1, 0,\n+                                -1, type, conditions,\n+                                true, TPriority.NORMAL,\n+                                TTaskType.REALTIME_PUSH,\n+                                transactionId,\n+                                Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n+                        pushTask.setIsSchemaChanging(true);\n+\n+                        if (AgentTaskQueue.addTask(pushTask)) {\n+                            batchTask.addTask(pushTask);\n+                            deleteTask.addTablet(tabletId);\n+                            deleteTask.addPushTask(pushTask);\n+                        }\n+\n+                    }\n+                }\n+            }\n+\n+            // submit push tasks\n+            if (batchTask.getTaskNum() > 0) {\n+                AgentTaskExecutor.submit(batchTask);\n+                queue.put(deleteTask);\n+            }\n+\n+        } catch (Throwable t) {\n+            LOG.warn(\"error occurred during delete process\", t);\n+            throw new DdlException(t.getMessage(), t);\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        long timeout = deleteTask.getTimeout();\n+        LOG.info(\"waiting delete task finish, signature: {}, timeout: {}\", transactionId, timeout);\n+        // wait until delete task finish or timeout\n+        deleteTask.join(timeout);\n+        if (deleteTask.isQuorum()) {\n+            commitTask(deleteTask, db);\n+        } else {\n+            boolean isSuccess = cancelTask(deleteTask, \"delete task timeout\");\n+            if (isSuccess) {\n+                throw new DdlException(\"timeout when waiting delete\");\n+            }\n+        }\n+\n+        // wait until transaction state become visible\n+        afterCommit(deleteTask, db, timeout);\n+    }\n+\n+    private void afterCommit(DeleteTask deleteTask, Database db, long leftTime) throws DdlException {\n+        try {\n+            long startDeleteTime = System.currentTimeMillis();\n+            long transactionId = deleteTask.getSignature();\n+            while (true) {\n+                db.writeLock();\n+                try {\n+                    // check if the job is aborted in transaction manager\n+                    TransactionState state = Catalog.getCurrentGlobalTransactionMgr()\n+                            .getTransactionState(transactionId);\n+                    if (state == null) {\n+                        LOG.warn(\"cancel delete, transactionId {},  because could not find transaction state\", transactionId);\n+                        cancelTask(deleteTask,\"transaction state lost\");\n+                        return;\n+                    }\n+                    TransactionStatus status = state.getTransactionStatus();\n+                    switch (status) {\n+                        case ABORTED:\n+                            cancelTask(deleteTask,\"delete transaction is aborted in transaction manager [\" + state + \"]\");\n+                            return;\n+                        case COMMITTED:\n+                            LOG.debug(\"delete task is already committed, just wait it to be visible, transactionId {}, transaction state {}\", transactionId, state);\n+                            return;\n+                        case VISIBLE:\n+                            LOG.debug(\"delete committed, transactionId: {}, transaction state {}\", transactionId, state);\n+                            removeTask(deleteTask);\n+                            return;\n+                    }\n+                    if (leftTime < System.currentTimeMillis() - startDeleteTime) {\n+                        cancelTask(deleteTask, \"delete timeout when waiting transaction commit\");\n+                    }\n+                } finally {\n+                    db.writeUnlock();\n+                }\n+                Thread.sleep(1000);\n+            }\n+        } catch (Exception e) {\n+            String failMsg = \"delete unknown, \" + e.getMessage();\n+            LOG.warn(failMsg, e);\n+            throw new DdlException(failMsg);\n+        }\n+    }\n+\n+    public class DeleteTaskChecker extends Thread {\n+        private BlockingQueue<DeleteTask> queue;\n+\n+        public DeleteTaskChecker(BlockingQueue<DeleteTask> queue) {\n+            this.queue = queue;\n+        }\n+\n+        @Override\n+        public void run() {\n+            LOG.info(\"delete task checker start\");\n+            try {\n+                loop();\n+            } finally {\n+                synchronized(queue) {\n+                    queue.clear();\n+                }\n+            }\n+        }\n+\n+        public void loop() {\n+            while (true) {\n+                try {\n+                    DeleteTask task = queue.take();\n+                    while (!task.isQuorum()) {\n+                        long signature = task.getSignature();\n+                        if (task.isCancel()) {\n+                            break;\n+                        }\n+                        if (!executor.submit(task)) {\n+                            Thread.sleep(1000);\n+                            continue;\n+                        }\n+                        // re add to the tail\n+                        queue.put(task);\n+                    }\n+                    // remove task isQuorum or isCanceled\n+                    removeTask(task);\n+                } catch (InterruptedException e) {\n+                    // do nothing\n+                }\n+            }\n+        }\n+    }\n+\n+    private void commitTask(DeleteTask task, Database db) {\n+        long transactionId = task.getSignature();\n+        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n+        TransactionState transactionState = globalTransactionMgr.getTransactionState(transactionId);\n+        List<TabletCommitInfo> tabletCommitInfos = new ArrayList<TabletCommitInfo>();\n+        db.writeLock();\n+        try {\n+            TabletInvertedIndex invertedIndex = Catalog.getCurrentInvertedIndex();\n+            for (TabletDeleteInfo tDeleteInfo : task.getTabletDeleteInfo()) {\n+                for (Replica replica : tDeleteInfo.getFinishedReplicas()) {\n+                    // the inverted index contains rolling up replica\n+                    Long tabletId = invertedIndex.getTabletIdByReplica(replica.getId());\n+                    if (tabletId == null) {\n+                        LOG.warn(\"could not find tablet id for replica {}, the tablet maybe dropped\", replica);\n+                        continue;\n+                    }\n+                    tabletCommitInfos.add(new TabletCommitInfo(tabletId, replica.getBackendId()));\n+                }\n+            }\n+            globalTransactionMgr.commitTransaction(db.getId(), transactionId, tabletCommitInfos);\n+        } catch (UserException e) {\n+            LOG.warn(\"errors while commit delete, transaction [{}], reason is {}\",\n+                    transactionState.getTransactionId(),  e);\n+            cancelTask(task, transactionState.getReason());\n+        } finally {\n+            db.writeUnlock();\n+        }\n+    }\n+\n+    public void removeTask(DeleteTask task) {\n+        task.unJoin();\n+        writeLock();\n+        try {\n+            long signature = task.getSignature();\n+            if (idToDeleteTask.containsKey(signature)) {\n+                idToDeleteTask.remove(signature);\n+            }\n+            for (PushTask pushTask : task.getPushTasks()) {\n+                AgentTaskQueue.removePushTask(pushTask.getBackendId(), pushTask.getSignature(),\n+                        pushTask.getVersion(), pushTask.getVersionHash(),\n+                        pushTask.getPushType(), pushTask.getTaskType());\n+            }\n+            if (task.isQuorum()) {\n+                DeleteInfo deleteInfo = task.getDeleteInfo();\n+                long dbId = deleteInfo.getDbId();\n+                if (dbToDeleteInfos.containsKey(dbId)) {\n+                    dbToDeleteInfos.get(dbId).add(deleteInfo);\n+                } else {\n+                    List<DeleteInfo> deleteInfoList = Lists.newArrayList();\n+                    deleteInfoList.add(deleteInfo);\n+                    dbToDeleteInfos.put(dbId, deleteInfoList);\n+                }\n+                Catalog.getInstance().getEditLog().logFinishSyncDelete(deleteInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1079ddafcafc794e3285d610c28d59fed5032191"}, "originalPosition": 421}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNzY3Mzg2", "url": "https://github.com/apache/incubator-doris/pull/3191#pullrequestreview-391767386", "createdAt": "2020-04-11T13:42:05Z", "commit": {"oid": "bb039e1c15fcc6a2760b5fddc1b481261acc437d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMzo0MjowNVrOGENTpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNDowMzo1OFrOGENcug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NTUwOQ==", "bodyText": "isSchemaChaning is useless, just set it to false", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r407065509", "createdAt": "2020-04-11T13:42:05Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.MarkedCountDownLatch;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteJob;\n+import org.apache.doris.task.DeleteJob.DeleteState;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteJob\n+    private Map<Long, DeleteJob> idToDeleteJob;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    public DeleteHandler() {\n+        idToDeleteJob = Maps.newConcurrentMap();\n+        dbToDeleteInfos = Maps.newConcurrentMap();\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteJob deleteJob = null;\n+        DeleteInfo deleteInfo = null;\n+        long transactionId;\n+        MarkedCountDownLatch<Long, Long> countDownLatch;\n+        db.readLock();\n+        try {\n+            Table table = db.getTable(tableName);\n+            if (table == null) {\n+                throw new DdlException(\"Table does not exist. name: \" + tableName);\n+            }\n+\n+            if (table.getType() != Table.TableType.OLAP) {\n+                throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+            }\n+            OlapTable olapTable = (OlapTable) table;\n+\n+            if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                throw new DdlException(\"Table's state is not normal: \" + tableName);\n+            }\n+\n+            if (partitionName == null) {\n+                if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                    throw new DdlException(\"This is a range partitioned table.\"\n+                            + \" You should specify partition in delete stmt\");\n+                } else {\n+                    // this is a unpartitioned table, use table name as partition name\n+                    partitionName = olapTable.getName();\n+                }\n+            }\n+\n+            Partition partition = olapTable.getPartition(partitionName);\n+            if (partition == null) {\n+                throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+            }\n+\n+            List<String> deleteConditions = Lists.newArrayList();\n+\n+            // pre check\n+            checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+            // generate label\n+            String label = \"delete_\" + UUID.randomUUID();\n+\n+            // begin txn here and generate txn id\n+            transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                    Lists.newArrayList(table.getId()), label,\"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                    TransactionState.LoadJobSourceType.FRONTEND, Config.stream_load_default_timeout_second);\n+\n+            deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n+                    partition.getId(), partitionName,\n+                    -1, 0, deleteConditions);\n+            deleteJob = new DeleteJob(transactionId, deleteInfo);\n+            idToDeleteJob.put(deleteJob.getTransactionId(), deleteJob);\n+            Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().addCallback(deleteJob);\n+            // task sent to be\n+            AgentBatchTask batchTask = new AgentBatchTask();\n+            // count total replica num\n+            int totalReplicaNum = 0;\n+            for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                for (Tablet tablet : index.getTablets()) {\n+                    totalReplicaNum += tablet.getReplicas().size();\n+                }\n+            }\n+            countDownLatch = new MarkedCountDownLatch<Long, Long>(totalReplicaNum);\n+\n+            for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                long indexId = index.getId();\n+                int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n+\n+                for (Tablet tablet : index.getTablets()) {\n+                    long tabletId = tablet.getId();\n+\n+                    // set push type\n+                    TPushType type = TPushType.DELETE;\n+\n+                    for (Replica replica : tablet.getReplicas()) {\n+                        long replicaId = replica.getId();\n+                        long backendId = replica.getBackendId();\n+                        countDownLatch.addMark(backendId, tabletId);\n+\n+                        // create push task for each replica\n+                        PushTask pushTask = new PushTask(null,\n+                                replica.getBackendId(), db.getId(), olapTable.getId(),\n+                                partition.getId(), indexId,\n+                                tabletId, replicaId, schemaHash,\n+                                -1, 0, \"\", -1, 0,\n+                                -1, type, conditions,\n+                                true, TPriority.NORMAL,\n+                                TTaskType.REALTIME_PUSH,\n+                                transactionId,\n+                                Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n+                        pushTask.setIsSchemaChanging(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb039e1c15fcc6a2760b5fddc1b481261acc437d"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NTY2Mw==", "bodyText": "If you put deleteInfo in idToDeleteJob, you need to make sure that the deleteInfo will be cleaned finally, even if any exception is thrown.\nSo I think you should clear the deleteInfo in finally block.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r407065663", "createdAt": "2020-04-11T13:43:30Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.MarkedCountDownLatch;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteJob;\n+import org.apache.doris.task.DeleteJob.DeleteState;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteJob\n+    private Map<Long, DeleteJob> idToDeleteJob;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    public DeleteHandler() {\n+        idToDeleteJob = Maps.newConcurrentMap();\n+        dbToDeleteInfos = Maps.newConcurrentMap();\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteJob deleteJob = null;\n+        DeleteInfo deleteInfo = null;\n+        long transactionId;\n+        MarkedCountDownLatch<Long, Long> countDownLatch;\n+        db.readLock();\n+        try {\n+            Table table = db.getTable(tableName);\n+            if (table == null) {\n+                throw new DdlException(\"Table does not exist. name: \" + tableName);\n+            }\n+\n+            if (table.getType() != Table.TableType.OLAP) {\n+                throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+            }\n+            OlapTable olapTable = (OlapTable) table;\n+\n+            if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                throw new DdlException(\"Table's state is not normal: \" + tableName);\n+            }\n+\n+            if (partitionName == null) {\n+                if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                    throw new DdlException(\"This is a range partitioned table.\"\n+                            + \" You should specify partition in delete stmt\");\n+                } else {\n+                    // this is a unpartitioned table, use table name as partition name\n+                    partitionName = olapTable.getName();\n+                }\n+            }\n+\n+            Partition partition = olapTable.getPartition(partitionName);\n+            if (partition == null) {\n+                throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+            }\n+\n+            List<String> deleteConditions = Lists.newArrayList();\n+\n+            // pre check\n+            checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+            // generate label\n+            String label = \"delete_\" + UUID.randomUUID();\n+\n+            // begin txn here and generate txn id\n+            transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                    Lists.newArrayList(table.getId()), label,\"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                    TransactionState.LoadJobSourceType.FRONTEND, Config.stream_load_default_timeout_second);\n+\n+            deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n+                    partition.getId(), partitionName,\n+                    -1, 0, deleteConditions);\n+            deleteJob = new DeleteJob(transactionId, deleteInfo);\n+            idToDeleteJob.put(deleteJob.getTransactionId(), deleteJob);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb039e1c15fcc6a2760b5fddc1b481261acc437d"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NTkwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public long getTimeout() {\n          \n          \n            \n                public long getTimeoutMs() {", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r407065902", "createdAt": "2020-04-11T13:45:38Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/task/DeleteJob.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.task;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.load.DeleteInfo;\n+import org.apache.doris.load.TabletDeleteInfo;\n+import org.apache.doris.transaction.AbstractTxnStateChangeCallback;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class DeleteJob extends AbstractTxnStateChangeCallback {\n+    private static final Logger LOG = LogManager.getLogger(DeleteJob.class);\n+\n+    public enum DeleteState {\n+        UN_QUORUM,\n+        QUORUM_FINISHED,\n+        FINISHED\n+    }\n+\n+    private DeleteState state;\n+\n+    private long signature;\n+    private Set<Long> totalTablets;\n+    private Set<Long> quorumTablets;\n+    private Set<Long> finishedTablets;\n+    Map<Long, TabletDeleteInfo> tabletDeleteInfoMap;\n+    private Set<PushTask> pushTasks;\n+    private DeleteInfo deleteInfo;\n+\n+    public DeleteJob(long transactionId, DeleteInfo deleteInfo) {\n+        this.signature = transactionId;\n+        this.deleteInfo = deleteInfo;\n+        totalTablets = Sets.newHashSet();\n+        finishedTablets = Sets.newHashSet();\n+        quorumTablets = Sets.newHashSet();\n+        tabletDeleteInfoMap = Maps.newConcurrentMap();\n+        pushTasks = Sets.newHashSet();\n+        state = DeleteState.UN_QUORUM;\n+    }\n+\n+    public void checkQuorum() throws DdlException {\n+        long dbId = deleteInfo.getDbId();\n+        long tableId = deleteInfo.getTableId();\n+        long partitionId = deleteInfo.getPartitionId();\n+        Database db = Catalog.getInstance().getDb(dbId);\n+        if (db == null) {\n+            LOG.warn(\"can not find database \"+ dbId +\" when commit delete\");\n+            return;\n+        }\n+\n+        short replicaNum = -1;\n+        db.readLock();\n+        try {\n+            OlapTable table = (OlapTable) db.getTable(tableId);\n+            if (table == null) {\n+                LOG.warn(\"can not find table \"+ tableId +\" when commit delete\");\n+                return;\n+            }\n+\n+            replicaNum = table.getPartitionInfo().getReplicationNum(partitionId);\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        short quorumNum = (short) (replicaNum / 2 + 1);\n+        for (TabletDeleteInfo tDeleteInfo : getTabletDeleteInfo()) {\n+            if (tDeleteInfo.getFinishedReplicas().size() == replicaNum) {\n+                finishedTablets.add(tDeleteInfo.getTabletId());\n+            }\n+            if (tDeleteInfo.getFinishedReplicas().size() >= quorumNum) {\n+                quorumTablets.add(tDeleteInfo.getTabletId());\n+            }\n+        }\n+        LOG.info(\"check delete job quorum, transaction id: {}, total tablets: {}, quorum tablets: {},\",\n+                signature, totalTablets.size(), quorumTablets.size());\n+\n+        if (finishedTablets.containsAll(totalTablets)) {\n+            setState(DeleteState.FINISHED);\n+        } else if (quorumTablets.containsAll(totalTablets)) {\n+            setState(DeleteState.QUORUM_FINISHED);\n+        }\n+    }\n+\n+    public void setState(DeleteState state) {\n+        this.state = state;\n+    }\n+\n+    public DeleteState getState() {\n+        return this.state;\n+    }\n+\n+    public boolean addTablet(long tabletId) {\n+        return totalTablets.add(tabletId);\n+    }\n+\n+    public boolean addPushTask(PushTask pushTask) {\n+        return pushTasks.add(pushTask);\n+    }\n+\n+    public boolean addFinishedReplica(long tabletId, Replica replica) {\n+        TabletDeleteInfo tDeleteInfo = tabletDeleteInfoMap.get(tabletId);\n+        if (tDeleteInfo == null) {\n+            tDeleteInfo = new TabletDeleteInfo(tabletId);\n+            tabletDeleteInfoMap.put(tabletId, tDeleteInfo);\n+        }\n+        return tDeleteInfo.addFinishedReplica(replica);\n+    }\n+\n+    public DeleteInfo getDeleteInfo() {\n+        return deleteInfo;\n+    }\n+\n+    public Set<PushTask> getPushTasks() {\n+        return pushTasks;\n+    }\n+\n+    @Override\n+    public long getId() {\n+        return this.signature;\n+    }\n+\n+    @Override\n+    public void afterVisible(TransactionState txnState, boolean txnOperated) {\n+        Catalog catalog = Catalog.getInstance();\n+        catalog.getEditLog().logFinishSyncDelete(deleteInfo);\n+        catalog.getDeleteHandler().recordFinishedJob(this);\n+    }\n+\n+    public long getTransactionId() {\n+        return this.signature;\n+    }\n+\n+    public Collection<TabletDeleteInfo> getTabletDeleteInfo() {\n+        return tabletDeleteInfoMap.values();\n+    }\n+\n+    public long getTimeout() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb039e1c15fcc6a2760b5fddc1b481261acc437d"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NTk2Mw==", "bodyText": "Add comment for this method.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r407065963", "createdAt": "2020-04-11T13:46:35Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/task/DeleteJob.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.task;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.load.DeleteInfo;\n+import org.apache.doris.load.TabletDeleteInfo;\n+import org.apache.doris.transaction.AbstractTxnStateChangeCallback;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class DeleteJob extends AbstractTxnStateChangeCallback {\n+    private static final Logger LOG = LogManager.getLogger(DeleteJob.class);\n+\n+    public enum DeleteState {\n+        UN_QUORUM,\n+        QUORUM_FINISHED,\n+        FINISHED\n+    }\n+\n+    private DeleteState state;\n+\n+    private long signature;\n+    private Set<Long> totalTablets;\n+    private Set<Long> quorumTablets;\n+    private Set<Long> finishedTablets;\n+    Map<Long, TabletDeleteInfo> tabletDeleteInfoMap;\n+    private Set<PushTask> pushTasks;\n+    private DeleteInfo deleteInfo;\n+\n+    public DeleteJob(long transactionId, DeleteInfo deleteInfo) {\n+        this.signature = transactionId;\n+        this.deleteInfo = deleteInfo;\n+        totalTablets = Sets.newHashSet();\n+        finishedTablets = Sets.newHashSet();\n+        quorumTablets = Sets.newHashSet();\n+        tabletDeleteInfoMap = Maps.newConcurrentMap();\n+        pushTasks = Sets.newHashSet();\n+        state = DeleteState.UN_QUORUM;\n+    }\n+\n+    public void checkQuorum() throws DdlException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb039e1c15fcc6a2760b5fddc1b481261acc437d"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NjM0MA==", "bodyText": "if  db == null, the state will be left as UN_QUORUM, and then the DeleteHandler will still try to finish the job, which is wrong.\nYou need to clarify the behavior of this function, such as what the return value is, when an exception is thrown, and whether the thrown exception can be properly handled by the caller.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r407066340", "createdAt": "2020-04-11T13:49:55Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/task/DeleteJob.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.task;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.load.DeleteInfo;\n+import org.apache.doris.load.TabletDeleteInfo;\n+import org.apache.doris.transaction.AbstractTxnStateChangeCallback;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class DeleteJob extends AbstractTxnStateChangeCallback {\n+    private static final Logger LOG = LogManager.getLogger(DeleteJob.class);\n+\n+    public enum DeleteState {\n+        UN_QUORUM,\n+        QUORUM_FINISHED,\n+        FINISHED\n+    }\n+\n+    private DeleteState state;\n+\n+    private long signature;\n+    private Set<Long> totalTablets;\n+    private Set<Long> quorumTablets;\n+    private Set<Long> finishedTablets;\n+    Map<Long, TabletDeleteInfo> tabletDeleteInfoMap;\n+    private Set<PushTask> pushTasks;\n+    private DeleteInfo deleteInfo;\n+\n+    public DeleteJob(long transactionId, DeleteInfo deleteInfo) {\n+        this.signature = transactionId;\n+        this.deleteInfo = deleteInfo;\n+        totalTablets = Sets.newHashSet();\n+        finishedTablets = Sets.newHashSet();\n+        quorumTablets = Sets.newHashSet();\n+        tabletDeleteInfoMap = Maps.newConcurrentMap();\n+        pushTasks = Sets.newHashSet();\n+        state = DeleteState.UN_QUORUM;\n+    }\n+\n+    public void checkQuorum() throws DdlException {\n+        long dbId = deleteInfo.getDbId();\n+        long tableId = deleteInfo.getTableId();\n+        long partitionId = deleteInfo.getPartitionId();\n+        Database db = Catalog.getInstance().getDb(dbId);\n+        if (db == null) {\n+            LOG.warn(\"can not find database \"+ dbId +\" when commit delete\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb039e1c15fcc6a2760b5fddc1b481261acc437d"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NjQwMw==", "bodyText": "Same problem to db==null.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r407066403", "createdAt": "2020-04-11T13:50:33Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/task/DeleteJob.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.task;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.load.DeleteInfo;\n+import org.apache.doris.load.TabletDeleteInfo;\n+import org.apache.doris.transaction.AbstractTxnStateChangeCallback;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class DeleteJob extends AbstractTxnStateChangeCallback {\n+    private static final Logger LOG = LogManager.getLogger(DeleteJob.class);\n+\n+    public enum DeleteState {\n+        UN_QUORUM,\n+        QUORUM_FINISHED,\n+        FINISHED\n+    }\n+\n+    private DeleteState state;\n+\n+    private long signature;\n+    private Set<Long> totalTablets;\n+    private Set<Long> quorumTablets;\n+    private Set<Long> finishedTablets;\n+    Map<Long, TabletDeleteInfo> tabletDeleteInfoMap;\n+    private Set<PushTask> pushTasks;\n+    private DeleteInfo deleteInfo;\n+\n+    public DeleteJob(long transactionId, DeleteInfo deleteInfo) {\n+        this.signature = transactionId;\n+        this.deleteInfo = deleteInfo;\n+        totalTablets = Sets.newHashSet();\n+        finishedTablets = Sets.newHashSet();\n+        quorumTablets = Sets.newHashSet();\n+        tabletDeleteInfoMap = Maps.newConcurrentMap();\n+        pushTasks = Sets.newHashSet();\n+        state = DeleteState.UN_QUORUM;\n+    }\n+\n+    public void checkQuorum() throws DdlException {\n+        long dbId = deleteInfo.getDbId();\n+        long tableId = deleteInfo.getTableId();\n+        long partitionId = deleteInfo.getPartitionId();\n+        Database db = Catalog.getInstance().getDb(dbId);\n+        if (db == null) {\n+            LOG.warn(\"can not find database \"+ dbId +\" when commit delete\");\n+            return;\n+        }\n+\n+        short replicaNum = -1;\n+        db.readLock();\n+        try {\n+            OlapTable table = (OlapTable) db.getTable(tableId);\n+            if (table == null) {\n+                LOG.warn(\"can not find table \"+ tableId +\" when commit delete\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb039e1c15fcc6a2760b5fddc1b481261acc437d"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NzE4MQ==", "bodyText": "After the while loop, the job may still failed.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r407067181", "createdAt": "2020-04-11T13:57:50Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.MarkedCountDownLatch;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteJob;\n+import org.apache.doris.task.DeleteJob.DeleteState;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteJob\n+    private Map<Long, DeleteJob> idToDeleteJob;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    public DeleteHandler() {\n+        idToDeleteJob = Maps.newConcurrentMap();\n+        dbToDeleteInfos = Maps.newConcurrentMap();\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteJob deleteJob = null;\n+        DeleteInfo deleteInfo = null;\n+        long transactionId;\n+        MarkedCountDownLatch<Long, Long> countDownLatch;\n+        db.readLock();\n+        try {\n+            Table table = db.getTable(tableName);\n+            if (table == null) {\n+                throw new DdlException(\"Table does not exist. name: \" + tableName);\n+            }\n+\n+            if (table.getType() != Table.TableType.OLAP) {\n+                throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+            }\n+            OlapTable olapTable = (OlapTable) table;\n+\n+            if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                throw new DdlException(\"Table's state is not normal: \" + tableName);\n+            }\n+\n+            if (partitionName == null) {\n+                if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                    throw new DdlException(\"This is a range partitioned table.\"\n+                            + \" You should specify partition in delete stmt\");\n+                } else {\n+                    // this is a unpartitioned table, use table name as partition name\n+                    partitionName = olapTable.getName();\n+                }\n+            }\n+\n+            Partition partition = olapTable.getPartition(partitionName);\n+            if (partition == null) {\n+                throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+            }\n+\n+            List<String> deleteConditions = Lists.newArrayList();\n+\n+            // pre check\n+            checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+            // generate label\n+            String label = \"delete_\" + UUID.randomUUID();\n+\n+            // begin txn here and generate txn id\n+            transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                    Lists.newArrayList(table.getId()), label,\"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                    TransactionState.LoadJobSourceType.FRONTEND, Config.stream_load_default_timeout_second);\n+\n+            deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n+                    partition.getId(), partitionName,\n+                    -1, 0, deleteConditions);\n+            deleteJob = new DeleteJob(transactionId, deleteInfo);\n+            idToDeleteJob.put(deleteJob.getTransactionId(), deleteJob);\n+            Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().addCallback(deleteJob);\n+            // task sent to be\n+            AgentBatchTask batchTask = new AgentBatchTask();\n+            // count total replica num\n+            int totalReplicaNum = 0;\n+            for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                for (Tablet tablet : index.getTablets()) {\n+                    totalReplicaNum += tablet.getReplicas().size();\n+                }\n+            }\n+            countDownLatch = new MarkedCountDownLatch<Long, Long>(totalReplicaNum);\n+\n+            for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                long indexId = index.getId();\n+                int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n+\n+                for (Tablet tablet : index.getTablets()) {\n+                    long tabletId = tablet.getId();\n+\n+                    // set push type\n+                    TPushType type = TPushType.DELETE;\n+\n+                    for (Replica replica : tablet.getReplicas()) {\n+                        long replicaId = replica.getId();\n+                        long backendId = replica.getBackendId();\n+                        countDownLatch.addMark(backendId, tabletId);\n+\n+                        // create push task for each replica\n+                        PushTask pushTask = new PushTask(null,\n+                                replica.getBackendId(), db.getId(), olapTable.getId(),\n+                                partition.getId(), indexId,\n+                                tabletId, replicaId, schemaHash,\n+                                -1, 0, \"\", -1, 0,\n+                                -1, type, conditions,\n+                                true, TPriority.NORMAL,\n+                                TTaskType.REALTIME_PUSH,\n+                                transactionId,\n+                                Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n+                        pushTask.setIsSchemaChanging(true);\n+                        pushTask.setCountDownLatch(countDownLatch);\n+\n+                        if (AgentTaskQueue.addTask(pushTask)) {\n+                            batchTask.addTask(pushTask);\n+                            deleteJob.addPushTask(pushTask);\n+                            deleteJob.addTablet(tabletId);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // submit push tasks\n+            if (batchTask.getTaskNum() > 0) {\n+                AgentTaskExecutor.submit(batchTask);\n+            }\n+\n+        } catch (Throwable t) {\n+            LOG.warn(\"error occurred during delete process\", t);\n+            throw new DdlException(t.getMessage(), t);\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        long timeoutMs = deleteJob.getTimeout();\n+        LOG.info(\"waiting delete Job finish, signature: {}, timeout: {}\", transactionId, timeoutMs);\n+        boolean ok = false;\n+        try {\n+            ok = countDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException e) {\n+            LOG.warn(\"InterruptedException: \", e);\n+            ok = false;\n+        }\n+\n+        if (ok) {\n+            commitJob(deleteJob, db, timeoutMs);\n+        } else {\n+            deleteJob.checkQuorum();\n+            if (deleteJob.getState() != DeleteState.UN_QUORUM) {\n+                long nowQuorumTimeMs = System.currentTimeMillis();\n+                long endQuorumTimeoutMs = nowQuorumTimeMs + timeoutMs / 2;\n+                // if job's state is finished or stay in quorum_finished for long time, try to commit it.\n+                try {\n+                    while (deleteJob.getState() == DeleteState.QUORUM_FINISHED && endQuorumTimeoutMs > nowQuorumTimeMs) {\n+                        deleteJob.checkQuorum();\n+                        Thread.sleep(1000);\n+                        nowQuorumTimeMs = System.currentTimeMillis();\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb039e1c15fcc6a2760b5fddc1b481261acc437d"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NzIxNw==", "bodyText": "You should handle this exception, for example, abort the transaction.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r407067217", "createdAt": "2020-04-11T13:58:15Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.MarkedCountDownLatch;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteJob;\n+import org.apache.doris.task.DeleteJob.DeleteState;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteJob\n+    private Map<Long, DeleteJob> idToDeleteJob;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    public DeleteHandler() {\n+        idToDeleteJob = Maps.newConcurrentMap();\n+        dbToDeleteInfos = Maps.newConcurrentMap();\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteJob deleteJob = null;\n+        DeleteInfo deleteInfo = null;\n+        long transactionId;\n+        MarkedCountDownLatch<Long, Long> countDownLatch;\n+        db.readLock();\n+        try {\n+            Table table = db.getTable(tableName);\n+            if (table == null) {\n+                throw new DdlException(\"Table does not exist. name: \" + tableName);\n+            }\n+\n+            if (table.getType() != Table.TableType.OLAP) {\n+                throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+            }\n+            OlapTable olapTable = (OlapTable) table;\n+\n+            if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                throw new DdlException(\"Table's state is not normal: \" + tableName);\n+            }\n+\n+            if (partitionName == null) {\n+                if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                    throw new DdlException(\"This is a range partitioned table.\"\n+                            + \" You should specify partition in delete stmt\");\n+                } else {\n+                    // this is a unpartitioned table, use table name as partition name\n+                    partitionName = olapTable.getName();\n+                }\n+            }\n+\n+            Partition partition = olapTable.getPartition(partitionName);\n+            if (partition == null) {\n+                throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+            }\n+\n+            List<String> deleteConditions = Lists.newArrayList();\n+\n+            // pre check\n+            checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+            // generate label\n+            String label = \"delete_\" + UUID.randomUUID();\n+\n+            // begin txn here and generate txn id\n+            transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                    Lists.newArrayList(table.getId()), label,\"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                    TransactionState.LoadJobSourceType.FRONTEND, Config.stream_load_default_timeout_second);\n+\n+            deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n+                    partition.getId(), partitionName,\n+                    -1, 0, deleteConditions);\n+            deleteJob = new DeleteJob(transactionId, deleteInfo);\n+            idToDeleteJob.put(deleteJob.getTransactionId(), deleteJob);\n+            Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().addCallback(deleteJob);\n+            // task sent to be\n+            AgentBatchTask batchTask = new AgentBatchTask();\n+            // count total replica num\n+            int totalReplicaNum = 0;\n+            for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                for (Tablet tablet : index.getTablets()) {\n+                    totalReplicaNum += tablet.getReplicas().size();\n+                }\n+            }\n+            countDownLatch = new MarkedCountDownLatch<Long, Long>(totalReplicaNum);\n+\n+            for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                long indexId = index.getId();\n+                int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n+\n+                for (Tablet tablet : index.getTablets()) {\n+                    long tabletId = tablet.getId();\n+\n+                    // set push type\n+                    TPushType type = TPushType.DELETE;\n+\n+                    for (Replica replica : tablet.getReplicas()) {\n+                        long replicaId = replica.getId();\n+                        long backendId = replica.getBackendId();\n+                        countDownLatch.addMark(backendId, tabletId);\n+\n+                        // create push task for each replica\n+                        PushTask pushTask = new PushTask(null,\n+                                replica.getBackendId(), db.getId(), olapTable.getId(),\n+                                partition.getId(), indexId,\n+                                tabletId, replicaId, schemaHash,\n+                                -1, 0, \"\", -1, 0,\n+                                -1, type, conditions,\n+                                true, TPriority.NORMAL,\n+                                TTaskType.REALTIME_PUSH,\n+                                transactionId,\n+                                Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n+                        pushTask.setIsSchemaChanging(true);\n+                        pushTask.setCountDownLatch(countDownLatch);\n+\n+                        if (AgentTaskQueue.addTask(pushTask)) {\n+                            batchTask.addTask(pushTask);\n+                            deleteJob.addPushTask(pushTask);\n+                            deleteJob.addTablet(tabletId);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // submit push tasks\n+            if (batchTask.getTaskNum() > 0) {\n+                AgentTaskExecutor.submit(batchTask);\n+            }\n+\n+        } catch (Throwable t) {\n+            LOG.warn(\"error occurred during delete process\", t);\n+            throw new DdlException(t.getMessage(), t);\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        long timeoutMs = deleteJob.getTimeout();\n+        LOG.info(\"waiting delete Job finish, signature: {}, timeout: {}\", transactionId, timeoutMs);\n+        boolean ok = false;\n+        try {\n+            ok = countDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException e) {\n+            LOG.warn(\"InterruptedException: \", e);\n+            ok = false;\n+        }\n+\n+        if (ok) {\n+            commitJob(deleteJob, db, timeoutMs);\n+        } else {\n+            deleteJob.checkQuorum();\n+            if (deleteJob.getState() != DeleteState.UN_QUORUM) {\n+                long nowQuorumTimeMs = System.currentTimeMillis();\n+                long endQuorumTimeoutMs = nowQuorumTimeMs + timeoutMs / 2;\n+                // if job's state is finished or stay in quorum_finished for long time, try to commit it.\n+                try {\n+                    while (deleteJob.getState() == DeleteState.QUORUM_FINISHED && endQuorumTimeoutMs > nowQuorumTimeMs) {\n+                        deleteJob.checkQuorum();\n+                        Thread.sleep(1000);\n+                        nowQuorumTimeMs = System.currentTimeMillis();\n+                    }\n+                    commitJob(deleteJob, db, timeoutMs);\n+                } catch (InterruptedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb039e1c15fcc6a2760b5fddc1b481261acc437d"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NzgzNA==", "bodyText": "!isSuccess does not mean the transaction is failed, it means the transaction is committed and publish timeout (not VISIBLE yet). So you should not cancel the job, but should tell the user the delete is success but will be taking effect later.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r407067834", "createdAt": "2020-04-11T14:03:58Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.MarkedCountDownLatch;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteJob;\n+import org.apache.doris.task.DeleteJob.DeleteState;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteJob\n+    private Map<Long, DeleteJob> idToDeleteJob;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    public DeleteHandler() {\n+        idToDeleteJob = Maps.newConcurrentMap();\n+        dbToDeleteInfos = Maps.newConcurrentMap();\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteJob deleteJob = null;\n+        DeleteInfo deleteInfo = null;\n+        long transactionId;\n+        MarkedCountDownLatch<Long, Long> countDownLatch;\n+        db.readLock();\n+        try {\n+            Table table = db.getTable(tableName);\n+            if (table == null) {\n+                throw new DdlException(\"Table does not exist. name: \" + tableName);\n+            }\n+\n+            if (table.getType() != Table.TableType.OLAP) {\n+                throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+            }\n+            OlapTable olapTable = (OlapTable) table;\n+\n+            if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                throw new DdlException(\"Table's state is not normal: \" + tableName);\n+            }\n+\n+            if (partitionName == null) {\n+                if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                    throw new DdlException(\"This is a range partitioned table.\"\n+                            + \" You should specify partition in delete stmt\");\n+                } else {\n+                    // this is a unpartitioned table, use table name as partition name\n+                    partitionName = olapTable.getName();\n+                }\n+            }\n+\n+            Partition partition = olapTable.getPartition(partitionName);\n+            if (partition == null) {\n+                throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+            }\n+\n+            List<String> deleteConditions = Lists.newArrayList();\n+\n+            // pre check\n+            checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+            // generate label\n+            String label = \"delete_\" + UUID.randomUUID();\n+\n+            // begin txn here and generate txn id\n+            transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                    Lists.newArrayList(table.getId()), label,\"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                    TransactionState.LoadJobSourceType.FRONTEND, Config.stream_load_default_timeout_second);\n+\n+            deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n+                    partition.getId(), partitionName,\n+                    -1, 0, deleteConditions);\n+            deleteJob = new DeleteJob(transactionId, deleteInfo);\n+            idToDeleteJob.put(deleteJob.getTransactionId(), deleteJob);\n+            Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().addCallback(deleteJob);\n+            // task sent to be\n+            AgentBatchTask batchTask = new AgentBatchTask();\n+            // count total replica num\n+            int totalReplicaNum = 0;\n+            for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                for (Tablet tablet : index.getTablets()) {\n+                    totalReplicaNum += tablet.getReplicas().size();\n+                }\n+            }\n+            countDownLatch = new MarkedCountDownLatch<Long, Long>(totalReplicaNum);\n+\n+            for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                long indexId = index.getId();\n+                int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n+\n+                for (Tablet tablet : index.getTablets()) {\n+                    long tabletId = tablet.getId();\n+\n+                    // set push type\n+                    TPushType type = TPushType.DELETE;\n+\n+                    for (Replica replica : tablet.getReplicas()) {\n+                        long replicaId = replica.getId();\n+                        long backendId = replica.getBackendId();\n+                        countDownLatch.addMark(backendId, tabletId);\n+\n+                        // create push task for each replica\n+                        PushTask pushTask = new PushTask(null,\n+                                replica.getBackendId(), db.getId(), olapTable.getId(),\n+                                partition.getId(), indexId,\n+                                tabletId, replicaId, schemaHash,\n+                                -1, 0, \"\", -1, 0,\n+                                -1, type, conditions,\n+                                true, TPriority.NORMAL,\n+                                TTaskType.REALTIME_PUSH,\n+                                transactionId,\n+                                Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n+                        pushTask.setIsSchemaChanging(true);\n+                        pushTask.setCountDownLatch(countDownLatch);\n+\n+                        if (AgentTaskQueue.addTask(pushTask)) {\n+                            batchTask.addTask(pushTask);\n+                            deleteJob.addPushTask(pushTask);\n+                            deleteJob.addTablet(tabletId);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // submit push tasks\n+            if (batchTask.getTaskNum() > 0) {\n+                AgentTaskExecutor.submit(batchTask);\n+            }\n+\n+        } catch (Throwable t) {\n+            LOG.warn(\"error occurred during delete process\", t);\n+            throw new DdlException(t.getMessage(), t);\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        long timeoutMs = deleteJob.getTimeout();\n+        LOG.info(\"waiting delete Job finish, signature: {}, timeout: {}\", transactionId, timeoutMs);\n+        boolean ok = false;\n+        try {\n+            ok = countDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException e) {\n+            LOG.warn(\"InterruptedException: \", e);\n+            ok = false;\n+        }\n+\n+        if (ok) {\n+            commitJob(deleteJob, db, timeoutMs);\n+        } else {\n+            deleteJob.checkQuorum();\n+            if (deleteJob.getState() != DeleteState.UN_QUORUM) {\n+                long nowQuorumTimeMs = System.currentTimeMillis();\n+                long endQuorumTimeoutMs = nowQuorumTimeMs + timeoutMs / 2;\n+                // if job's state is finished or stay in quorum_finished for long time, try to commit it.\n+                try {\n+                    while (deleteJob.getState() == DeleteState.QUORUM_FINISHED && endQuorumTimeoutMs > nowQuorumTimeMs) {\n+                        deleteJob.checkQuorum();\n+                        Thread.sleep(1000);\n+                        nowQuorumTimeMs = System.currentTimeMillis();\n+                    }\n+                    commitJob(deleteJob, db, timeoutMs);\n+                } catch (InterruptedException e) {\n+                }\n+            } else {\n+                List<Entry<Long, Long>> unfinishedMarks = countDownLatch.getLeftMarks();\n+                // only show at most 5 results\n+                List<Entry<Long, Long>> subList = unfinishedMarks.subList(0, Math.min(unfinishedMarks.size(), 5));\n+                String errMsg = \"Unfinished replicas:\" + Joiner.on(\", \").join(subList);\n+                LOG.warn(\"delete job timeout: {}, {}\", transactionId, errMsg);\n+                cancelJob(deleteJob, \"delete job timeout\");\n+                throw new DdlException(\"failed to delete replicas from job: {}, {}, transactionId, errMsg\");\n+            }\n+        }\n+    }\n+\n+    private void commitJob(DeleteJob job, Database db, long timeout) {\n+        long transactionId = job.getTransactionId();\n+        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n+        TransactionState transactionState = globalTransactionMgr.getTransactionState(transactionId);\n+        List<TabletCommitInfo> tabletCommitInfos = new ArrayList<TabletCommitInfo>();\n+        try {\n+            TabletInvertedIndex invertedIndex = Catalog.getCurrentInvertedIndex();\n+            for (TabletDeleteInfo tDeleteInfo : job.getTabletDeleteInfo()) {\n+                for (Replica replica : tDeleteInfo.getFinishedReplicas()) {\n+                    // the inverted index contains rolling up replica\n+                    Long tabletId = invertedIndex.getTabletIdByReplica(replica.getId());\n+                    if (tabletId == null) {\n+                        LOG.warn(\"could not find tablet id for replica {}, the tablet maybe dropped\", replica);\n+                        continue;\n+                    }\n+                    tabletCommitInfos.add(new TabletCommitInfo(tabletId, replica.getBackendId()));\n+                }\n+            }\n+            boolean isSuccess = globalTransactionMgr.commitAndPublishTransaction(db, transactionId, tabletCommitInfos, timeout);\n+            if (!isSuccess) {\n+                cancelJob(job, \"delete timeout when waiting transaction commit\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb039e1c15fcc6a2760b5fddc1b481261acc437d"}, "originalPosition": 281}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyODU5NjU4", "url": "https://github.com/apache/incubator-doris/pull/3191#pullrequestreview-392859658", "createdAt": "2020-04-14T12:03:18Z", "commit": {"oid": "f7da159334e579fbbcedc8d22b97148187fe33da"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMjowMzoxOFrOGFLWkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMjowODoxMFrOGFLgJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4MjA2Ng==", "bodyText": "You can not use the origin OP_FINISH_SYNC_DELETE, because they are different operations.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r408082066", "createdAt": "2020-04-14T12:03:18Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/persist/EditLog.java", "diffHunk": "@@ -378,8 +379,8 @@ public static void loadJournal(Catalog catalog, JournalEntity journal) {\n                     break;\n                 case OperationType.OP_FINISH_SYNC_DELETE: {\n                     DeleteInfo info = (DeleteInfo) journal.getData();\n-                    Load load = catalog.getLoadInstance();\n-                    load.replayDelete(info, catalog);\n+                    DeleteHandler deleteHandler = catalog.getDeleteHandler();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7da159334e579fbbcedc8d22b97148187fe33da"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4MjYzNQ==", "bodyText": "You should also show the delete info from Load, or after we upgrade the Doris, the old delete info can not be seen.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r408082635", "createdAt": "2020-04-14T12:04:15Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/qe/ShowExecutor.java", "diffHunk": "@@ -1053,8 +1054,8 @@ private void handleShowDelete() throws AnalysisException {\n         }\n         long dbId = db.getId();\n \n-        Load load = catalog.getLoadInstance();\n-        List<List<Comparable>> deleteInfos = load.getDeleteInfosByDb(dbId, true);\n+        DeleteHandler deleteHandler = catalog.getDeleteHandler();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7da159334e579fbbcedc8d22b97148187fe33da"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NDAyOA==", "bodyText": "There will be concurrent issue when visiting tabletDeleteInfoMap from different thread: the report task thread and DeleteHandler thread. So you should use ConcurrentHashMap", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r408084028", "createdAt": "2020-04-14T12:07:10Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/task/DeleteJob.java", "diffHunk": "@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.task;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.MetaNotFoundException;\n+import org.apache.doris.load.DeleteInfo;\n+import org.apache.doris.load.TabletDeleteInfo;\n+import org.apache.doris.transaction.AbstractTxnStateChangeCallback;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class DeleteJob extends AbstractTxnStateChangeCallback {\n+    private static final Logger LOG = LogManager.getLogger(DeleteJob.class);\n+\n+    public enum DeleteState {\n+        UN_QUORUM,\n+        QUORUM_FINISHED,\n+        FINISHED\n+    }\n+\n+    private DeleteState state;\n+\n+    // jobId(listenerId). use in beginTransaction to callback function\n+    private long id;\n+    // transaction id.\n+    private long signature;\n+    private Set<Long> totalTablets;\n+    private Set<Long> quorumTablets;\n+    private Set<Long> finishedTablets;\n+    Map<Long, TabletDeleteInfo> tabletDeleteInfoMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7da159334e579fbbcedc8d22b97148187fe33da"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NDUxNw==", "bodyText": "After changing tabletDeleteInfoMap to ConncurrentHashMap, you should use putIfAbsent to perform the atomic operation here.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r408084517", "createdAt": "2020-04-14T12:08:10Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/task/DeleteJob.java", "diffHunk": "@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.task;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.MetaNotFoundException;\n+import org.apache.doris.load.DeleteInfo;\n+import org.apache.doris.load.TabletDeleteInfo;\n+import org.apache.doris.transaction.AbstractTxnStateChangeCallback;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class DeleteJob extends AbstractTxnStateChangeCallback {\n+    private static final Logger LOG = LogManager.getLogger(DeleteJob.class);\n+\n+    public enum DeleteState {\n+        UN_QUORUM,\n+        QUORUM_FINISHED,\n+        FINISHED\n+    }\n+\n+    private DeleteState state;\n+\n+    // jobId(listenerId). use in beginTransaction to callback function\n+    private long id;\n+    // transaction id.\n+    private long signature;\n+    private Set<Long> totalTablets;\n+    private Set<Long> quorumTablets;\n+    private Set<Long> finishedTablets;\n+    Map<Long, TabletDeleteInfo> tabletDeleteInfoMap;\n+    private Set<PushTask> pushTasks;\n+    private DeleteInfo deleteInfo;\n+\n+    public DeleteJob(long id, long transactionId, DeleteInfo deleteInfo) {\n+        this.id = id;\n+        this.signature = transactionId;\n+        this.deleteInfo = deleteInfo;\n+        totalTablets = Sets.newHashSet();\n+        finishedTablets = Sets.newHashSet();\n+        quorumTablets = Sets.newHashSet();\n+        tabletDeleteInfoMap = Maps.newConcurrentMap();\n+        pushTasks = Sets.newHashSet();\n+        state = DeleteState.UN_QUORUM;\n+    }\n+\n+    /**\n+     * check and update if this job's state is QUORUM_FINISHED or FINISHED\n+     * The meaning of state:\n+     * QUORUM_FINISHED: For each tablet there are more than half of its replicas have been finished\n+     * FINISHED: All replicas of this jobs have finished\n+     */\n+    public void checkAndUpdateQuorum() throws MetaNotFoundException {\n+        long dbId = deleteInfo.getDbId();\n+        long tableId = deleteInfo.getTableId();\n+        long partitionId = deleteInfo.getPartitionId();\n+        Database db = Catalog.getInstance().getDb(dbId);\n+        if (db == null) {\n+            throw new MetaNotFoundException(\"can not find database \"+ dbId +\" when commit delete\");\n+        }\n+\n+        short replicaNum = -1;\n+        db.readLock();\n+        try {\n+            OlapTable table = (OlapTable) db.getTable(tableId);\n+            if (table == null) {\n+                throw new MetaNotFoundException(\"can not find table \"+ tableId +\" when commit delete\");\n+            }\n+            replicaNum = table.getPartitionInfo().getReplicationNum(partitionId);\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        short quorumNum = (short) (replicaNum / 2 + 1);\n+        for (TabletDeleteInfo tDeleteInfo : getTabletDeleteInfo()) {\n+            if (tDeleteInfo.getFinishedReplicas().size() == replicaNum) {\n+                finishedTablets.add(tDeleteInfo.getTabletId());\n+            }\n+            if (tDeleteInfo.getFinishedReplicas().size() >= quorumNum) {\n+                quorumTablets.add(tDeleteInfo.getTabletId());\n+            }\n+        }\n+        LOG.info(\"check delete job quorum, transaction id: {}, total tablets: {}, quorum tablets: {},\",\n+                signature, totalTablets.size(), quorumTablets.size());\n+\n+        if (finishedTablets.containsAll(totalTablets)) {\n+            setState(DeleteState.FINISHED);\n+        } else if (quorumTablets.containsAll(totalTablets)) {\n+            setState(DeleteState.QUORUM_FINISHED);\n+        }\n+    }\n+\n+    public void setState(DeleteState state) {\n+        this.state = state;\n+    }\n+\n+    public DeleteState getState() {\n+        return this.state;\n+    }\n+\n+    public boolean addTablet(long tabletId) {\n+        return totalTablets.add(tabletId);\n+    }\n+\n+    public boolean addPushTask(PushTask pushTask) {\n+        return pushTasks.add(pushTask);\n+    }\n+\n+    public boolean addFinishedReplica(long tabletId, Replica replica) {\n+        TabletDeleteInfo tDeleteInfo = tabletDeleteInfoMap.get(tabletId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7da159334e579fbbcedc8d22b97148187fe33da"}, "originalPosition": 136}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyODgzNzMz", "url": "https://github.com/apache/incubator-doris/pull/3191#pullrequestreview-392883733", "createdAt": "2020-04-14T12:37:35Z", "commit": {"oid": "f7da159334e579fbbcedc8d22b97148187fe33da"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMjozNzozNVrOGFMimQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMjo0MzowOFrOGFMwpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEwMTUyOQ==", "bodyText": "This method return boolean, but you never use it.\nI think return true means cancel succeed(txn failed), and return false means cancel failed(txn succeed).\nAnd the caller should use this return value to decide whether to return user success or failure.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r408101529", "createdAt": "2020-04-14T12:37:35Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,627 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.FeConstants;\n+import org.apache.doris.common.MarkedCountDownLatch;\n+import org.apache.doris.common.MetaNotFoundException;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteJob;\n+import org.apache.doris.task.DeleteJob.DeleteState;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.doris.transaction.TransactionStatus;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteJob\n+    private Map<Long, DeleteJob> idToDeleteJob;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    public DeleteHandler() {\n+        idToDeleteJob = Maps.newConcurrentMap();\n+        dbToDeleteInfos = Maps.newConcurrentMap();\n+    }\n+\n+    private enum CancelType {\n+        METADATA_MISSING,\n+        TIMEOUT,\n+        COMMIT_FAIL,\n+        UNKNOWN\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteJob deleteJob = null;\n+        try {\n+            MarkedCountDownLatch<Long, Long> countDownLatch;\n+            long transactionId = -1;\n+            db.readLock();\n+            try {\n+                Table table = db.getTable(tableName);\n+                if (table == null) {\n+                    throw new DdlException(\"Table does not exist. name: \" + tableName);\n+                }\n+\n+                if (table.getType() != Table.TableType.OLAP) {\n+                    throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+                }\n+                OlapTable olapTable = (OlapTable) table;\n+\n+                if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                    throw new DdlException(\"Table's state is not normal: \" + tableName);\n+                }\n+\n+                if (partitionName == null) {\n+                    if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                        throw new DdlException(\"This is a range partitioned table.\"\n+                                + \" You should specify partition in delete stmt\");\n+                    } else {\n+                        // this is a unpartitioned table, use table name as partition name\n+                        partitionName = olapTable.getName();\n+                    }\n+                }\n+\n+                Partition partition = olapTable.getPartition(partitionName);\n+                if (partition == null) {\n+                    throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+                }\n+\n+                List<String> deleteConditions = Lists.newArrayList();\n+\n+                // pre check\n+                checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+                // generate label\n+                String label = \"delete_\" + UUID.randomUUID();\n+                //generate jobId\n+                long jobId = Catalog.getCurrentCatalog().getNextId();\n+                // begin txn here and generate txn id\n+                transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                        Lists.newArrayList(table.getId()), label, null, \"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                        TransactionState.LoadJobSourceType.FRONTEND, jobId, Config.stream_load_default_timeout_second);\n+\n+                DeleteInfo deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n+                        partition.getId(), partitionName,\n+                        -1, 0, deleteConditions);\n+                deleteJob = new DeleteJob(jobId, transactionId, deleteInfo);\n+                idToDeleteJob.put(deleteJob.getTransactionId(), deleteJob);\n+\n+                Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().addCallback(deleteJob);\n+                // task sent to be\n+                AgentBatchTask batchTask = new AgentBatchTask();\n+                // count total replica num\n+                int totalReplicaNum = 0;\n+                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                    for (Tablet tablet : index.getTablets()) {\n+                        totalReplicaNum += tablet.getReplicas().size();\n+                    }\n+                }\n+                countDownLatch = new MarkedCountDownLatch<Long, Long>(totalReplicaNum);\n+\n+                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                    long indexId = index.getId();\n+                    int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n+\n+                    for (Tablet tablet : index.getTablets()) {\n+                        long tabletId = tablet.getId();\n+\n+                        // set push type\n+                        TPushType type = TPushType.DELETE;\n+\n+                        for (Replica replica : tablet.getReplicas()) {\n+                            long replicaId = replica.getId();\n+                            long backendId = replica.getBackendId();\n+                            countDownLatch.addMark(backendId, tabletId);\n+\n+                            // create push task for each replica\n+                            PushTask pushTask = new PushTask(null,\n+                                    replica.getBackendId(), db.getId(), olapTable.getId(),\n+                                    partition.getId(), indexId,\n+                                    tabletId, replicaId, schemaHash,\n+                                    -1, 0, \"\", -1, 0,\n+                                    -1, type, conditions,\n+                                    true, TPriority.NORMAL,\n+                                    TTaskType.REALTIME_PUSH,\n+                                    transactionId,\n+                                    Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n+                            pushTask.setIsSchemaChanging(false);\n+                            pushTask.setCountDownLatch(countDownLatch);\n+\n+                            if (AgentTaskQueue.addTask(pushTask)) {\n+                                batchTask.addTask(pushTask);\n+                                deleteJob.addPushTask(pushTask);\n+                                deleteJob.addTablet(tabletId);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // submit push tasks\n+                if (batchTask.getTaskNum() > 0) {\n+                    AgentTaskExecutor.submit(batchTask);\n+                }\n+\n+            } catch (Throwable t) {\n+                LOG.warn(\"error occurred during delete process\", t);\n+                // if transaction has been begun, need to abort it\n+                if (Catalog.getCurrentGlobalTransactionMgr().getTransactionState(transactionId) != null) {\n+                    cancelJob(deleteJob, CancelType.UNKNOWN, t.getMessage());\n+                }\n+                throw new DdlException(t.getMessage(), t);\n+            } finally {\n+                db.readUnlock();\n+            }\n+\n+            long timeoutMs = deleteJob.getTimeoutMs();\n+            LOG.info(\"waiting delete Job finish, signature: {}, timeout: {}\", transactionId, timeoutMs);\n+            boolean ok = false;\n+            try {\n+                ok = countDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);\n+            } catch (InterruptedException e) {\n+                LOG.warn(\"InterruptedException: \", e);\n+                ok = false;\n+            }\n+\n+            if (!ok) {\n+                try {\n+                    deleteJob.checkAndUpdateQuorum();\n+                } catch (MetaNotFoundException e) {\n+                    cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n+                    throw new DdlException(e.getMessage(), e);\n+                }\n+                DeleteState state = deleteJob.getState();\n+                switch (state) {\n+                    case UN_QUORUM:\n+                        List<Entry<Long, Long>> unfinishedMarks = countDownLatch.getLeftMarks();\n+                        // only show at most 5 results\n+                        List<Entry<Long, Long>> subList = unfinishedMarks.subList(0, Math.min(unfinishedMarks.size(), 5));\n+                        String errMsg = \"Unfinished replicas:\" + Joiner.on(\", \").join(subList);\n+                        LOG.warn(\"delete job timeout: transactionId {}, {}\", transactionId, errMsg);\n+                        cancelJob(deleteJob, CancelType.TIMEOUT, \"delete job timeout\");\n+                        throw new DdlException(\"failed to delete replicas from job: \" + transactionId + \", \" + errMsg);\n+                    case QUORUM_FINISHED:\n+                    case FINISHED:\n+                        try {\n+                            long nowQuorumTimeMs = System.currentTimeMillis();\n+                            long endQuorumTimeoutMs = nowQuorumTimeMs + timeoutMs / 2;\n+                            // if job's state is quorum_finished then wait for a period of time and commit it.\n+                            while (deleteJob.getState() == DeleteState.QUORUM_FINISHED && endQuorumTimeoutMs > nowQuorumTimeMs) {\n+                                deleteJob.checkAndUpdateQuorum();\n+                                Thread.sleep(1000);\n+                                nowQuorumTimeMs = System.currentTimeMillis();\n+                            }\n+                        } catch (MetaNotFoundException e) {\n+                            cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n+                            throw new DdlException(e.getMessage(), e);\n+                        } catch (InterruptedException e) {\n+                            cancelJob(deleteJob, CancelType.UNKNOWN, e.getMessage());\n+                            throw new DdlException(e.getMessage(), e);\n+                        }\n+                        commitJob(deleteJob, db, timeoutMs);\n+                        break;\n+                    default:\n+                        Preconditions.checkState(false, \"wrong delete job state: \" + state.name());\n+                        break;\n+                }\n+            } else {\n+                commitJob(deleteJob, db, timeoutMs);\n+            }\n+        } finally {\n+            if (!FeConstants.runningUnitTest) {\n+                clearJob(deleteJob);\n+            }\n+        }\n+    }\n+\n+    private void commitJob(DeleteJob job, Database db, long timeoutMs) throws DdlException {\n+        TransactionStatus status = null;\n+        try {\n+            unprotectedCommitJob(job, db, timeoutMs);\n+            status = Catalog.getCurrentGlobalTransactionMgr().\n+                    getTransactionState(job.getTransactionId()).getTransactionStatus();\n+        } catch (UserException e) {\n+            cancelJob(job, CancelType.COMMIT_FAIL, e.getMessage());\n+            throw new DdlException(e.getMessage(), e);\n+        }\n+\n+        switch (status) {\n+            case COMMITTED:\n+                // Although publish is unfinished we should tell user that commit already success.\n+                throw new DdlException(\"delete job is committed but may be taking effect later, transactionId: \" + job.getTransactionId());\n+            case VISIBLE:\n+                break;\n+            default:\n+                Preconditions.checkState(false, \"wrong transaction status: \" + status.name());\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * unprotected commit delete job\n+     * return true when successfully commit and publish\n+     * return false when successfully commit but publish unfinished.\n+     * A UserException thrown if both commit and publish failed.\n+     * @param job\n+     * @param db\n+     * @param timeoutMs\n+     * @return\n+     * @throws UserException\n+     */\n+    private boolean unprotectedCommitJob(DeleteJob job, Database db, long timeoutMs) throws UserException {\n+        long transactionId = job.getTransactionId();\n+        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n+        List<TabletCommitInfo> tabletCommitInfos = new ArrayList<TabletCommitInfo>();\n+        TabletInvertedIndex invertedIndex = Catalog.getCurrentInvertedIndex();\n+        for (TabletDeleteInfo tDeleteInfo : job.getTabletDeleteInfo()) {\n+            for (Replica replica : tDeleteInfo.getFinishedReplicas()) {\n+                // the inverted index contains rolling up replica\n+                Long tabletId = invertedIndex.getTabletIdByReplica(replica.getId());\n+                if (tabletId == null) {\n+                    LOG.warn(\"could not find tablet id for replica {}, the tablet maybe dropped\", replica);\n+                    continue;\n+                }\n+                tabletCommitInfos.add(new TabletCommitInfo(tabletId, replica.getBackendId()));\n+            }\n+        }\n+        return globalTransactionMgr.commitAndPublishTransaction(db, transactionId, tabletCommitInfos, timeoutMs);\n+    }\n+\n+    /**\n+     * This method should always be called in the end of the delete process to clean the job.\n+     * Better put it in finally block.\n+     * @param job\n+     */\n+    private void clearJob(DeleteJob job) {\n+        if (job != null) {\n+            long signature = job.getTransactionId();\n+            if (idToDeleteJob.containsKey(signature)) {\n+                idToDeleteJob.remove(signature);\n+            }\n+            for (PushTask pushTask : job.getPushTasks()) {\n+                AgentTaskQueue.removePushTask(pushTask.getBackendId(), pushTask.getSignature(),\n+                        pushTask.getVersion(), pushTask.getVersionHash(),\n+                        pushTask.getPushType(), pushTask.getTaskType());\n+            }\n+            Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().removeCallback(job.getId());\n+        }\n+    }\n+\n+    public void recordFinishedJob(DeleteJob job) {\n+        if (job != null) {\n+            long dbId = job.getDeleteInfo().getDbId();\n+            LOG.info(\"record finished deleteJob, transactionId {}, dbId {}\",\n+                    job.getTransactionId(), dbId);\n+            List<DeleteInfo> deleteInfoList = dbToDeleteInfos.get(dbId);\n+            if (deleteInfoList == null) {\n+                deleteInfoList = Lists.newArrayList();\n+                dbToDeleteInfos.put(dbId, deleteInfoList);\n+            }\n+            deleteInfoList.add(job.getDeleteInfo());\n+        }\n+    }\n+\n+    public boolean cancelJob(DeleteJob job, CancelType cancelType, String reason) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7da159334e579fbbcedc8d22b97148187fe33da"}, "originalPosition": 387}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEwNDI4NA==", "bodyText": "And if transaction is COMMITTED but not VISIBLE, you should return a transaction id to user, so that user can use that it to check transaction's state.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r408104284", "createdAt": "2020-04-14T12:41:50Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,627 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.FeConstants;\n+import org.apache.doris.common.MarkedCountDownLatch;\n+import org.apache.doris.common.MetaNotFoundException;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteJob;\n+import org.apache.doris.task.DeleteJob.DeleteState;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.doris.transaction.TransactionStatus;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteJob\n+    private Map<Long, DeleteJob> idToDeleteJob;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    public DeleteHandler() {\n+        idToDeleteJob = Maps.newConcurrentMap();\n+        dbToDeleteInfos = Maps.newConcurrentMap();\n+    }\n+\n+    private enum CancelType {\n+        METADATA_MISSING,\n+        TIMEOUT,\n+        COMMIT_FAIL,\n+        UNKNOWN\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteJob deleteJob = null;\n+        try {\n+            MarkedCountDownLatch<Long, Long> countDownLatch;\n+            long transactionId = -1;\n+            db.readLock();\n+            try {\n+                Table table = db.getTable(tableName);\n+                if (table == null) {\n+                    throw new DdlException(\"Table does not exist. name: \" + tableName);\n+                }\n+\n+                if (table.getType() != Table.TableType.OLAP) {\n+                    throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+                }\n+                OlapTable olapTable = (OlapTable) table;\n+\n+                if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                    throw new DdlException(\"Table's state is not normal: \" + tableName);\n+                }\n+\n+                if (partitionName == null) {\n+                    if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                        throw new DdlException(\"This is a range partitioned table.\"\n+                                + \" You should specify partition in delete stmt\");\n+                    } else {\n+                        // this is a unpartitioned table, use table name as partition name\n+                        partitionName = olapTable.getName();\n+                    }\n+                }\n+\n+                Partition partition = olapTable.getPartition(partitionName);\n+                if (partition == null) {\n+                    throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+                }\n+\n+                List<String> deleteConditions = Lists.newArrayList();\n+\n+                // pre check\n+                checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+                // generate label\n+                String label = \"delete_\" + UUID.randomUUID();\n+                //generate jobId\n+                long jobId = Catalog.getCurrentCatalog().getNextId();\n+                // begin txn here and generate txn id\n+                transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                        Lists.newArrayList(table.getId()), label, null, \"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                        TransactionState.LoadJobSourceType.FRONTEND, jobId, Config.stream_load_default_timeout_second);\n+\n+                DeleteInfo deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n+                        partition.getId(), partitionName,\n+                        -1, 0, deleteConditions);\n+                deleteJob = new DeleteJob(jobId, transactionId, deleteInfo);\n+                idToDeleteJob.put(deleteJob.getTransactionId(), deleteJob);\n+\n+                Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().addCallback(deleteJob);\n+                // task sent to be\n+                AgentBatchTask batchTask = new AgentBatchTask();\n+                // count total replica num\n+                int totalReplicaNum = 0;\n+                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                    for (Tablet tablet : index.getTablets()) {\n+                        totalReplicaNum += tablet.getReplicas().size();\n+                    }\n+                }\n+                countDownLatch = new MarkedCountDownLatch<Long, Long>(totalReplicaNum);\n+\n+                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                    long indexId = index.getId();\n+                    int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n+\n+                    for (Tablet tablet : index.getTablets()) {\n+                        long tabletId = tablet.getId();\n+\n+                        // set push type\n+                        TPushType type = TPushType.DELETE;\n+\n+                        for (Replica replica : tablet.getReplicas()) {\n+                            long replicaId = replica.getId();\n+                            long backendId = replica.getBackendId();\n+                            countDownLatch.addMark(backendId, tabletId);\n+\n+                            // create push task for each replica\n+                            PushTask pushTask = new PushTask(null,\n+                                    replica.getBackendId(), db.getId(), olapTable.getId(),\n+                                    partition.getId(), indexId,\n+                                    tabletId, replicaId, schemaHash,\n+                                    -1, 0, \"\", -1, 0,\n+                                    -1, type, conditions,\n+                                    true, TPriority.NORMAL,\n+                                    TTaskType.REALTIME_PUSH,\n+                                    transactionId,\n+                                    Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n+                            pushTask.setIsSchemaChanging(false);\n+                            pushTask.setCountDownLatch(countDownLatch);\n+\n+                            if (AgentTaskQueue.addTask(pushTask)) {\n+                                batchTask.addTask(pushTask);\n+                                deleteJob.addPushTask(pushTask);\n+                                deleteJob.addTablet(tabletId);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // submit push tasks\n+                if (batchTask.getTaskNum() > 0) {\n+                    AgentTaskExecutor.submit(batchTask);\n+                }\n+\n+            } catch (Throwable t) {\n+                LOG.warn(\"error occurred during delete process\", t);\n+                // if transaction has been begun, need to abort it\n+                if (Catalog.getCurrentGlobalTransactionMgr().getTransactionState(transactionId) != null) {\n+                    cancelJob(deleteJob, CancelType.UNKNOWN, t.getMessage());\n+                }\n+                throw new DdlException(t.getMessage(), t);\n+            } finally {\n+                db.readUnlock();\n+            }\n+\n+            long timeoutMs = deleteJob.getTimeoutMs();\n+            LOG.info(\"waiting delete Job finish, signature: {}, timeout: {}\", transactionId, timeoutMs);\n+            boolean ok = false;\n+            try {\n+                ok = countDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);\n+            } catch (InterruptedException e) {\n+                LOG.warn(\"InterruptedException: \", e);\n+                ok = false;\n+            }\n+\n+            if (!ok) {\n+                try {\n+                    deleteJob.checkAndUpdateQuorum();\n+                } catch (MetaNotFoundException e) {\n+                    cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n+                    throw new DdlException(e.getMessage(), e);\n+                }\n+                DeleteState state = deleteJob.getState();\n+                switch (state) {\n+                    case UN_QUORUM:\n+                        List<Entry<Long, Long>> unfinishedMarks = countDownLatch.getLeftMarks();\n+                        // only show at most 5 results\n+                        List<Entry<Long, Long>> subList = unfinishedMarks.subList(0, Math.min(unfinishedMarks.size(), 5));\n+                        String errMsg = \"Unfinished replicas:\" + Joiner.on(\", \").join(subList);\n+                        LOG.warn(\"delete job timeout: transactionId {}, {}\", transactionId, errMsg);\n+                        cancelJob(deleteJob, CancelType.TIMEOUT, \"delete job timeout\");\n+                        throw new DdlException(\"failed to delete replicas from job: \" + transactionId + \", \" + errMsg);\n+                    case QUORUM_FINISHED:\n+                    case FINISHED:\n+                        try {\n+                            long nowQuorumTimeMs = System.currentTimeMillis();\n+                            long endQuorumTimeoutMs = nowQuorumTimeMs + timeoutMs / 2;\n+                            // if job's state is quorum_finished then wait for a period of time and commit it.\n+                            while (deleteJob.getState() == DeleteState.QUORUM_FINISHED && endQuorumTimeoutMs > nowQuorumTimeMs) {\n+                                deleteJob.checkAndUpdateQuorum();\n+                                Thread.sleep(1000);\n+                                nowQuorumTimeMs = System.currentTimeMillis();\n+                            }\n+                        } catch (MetaNotFoundException e) {\n+                            cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n+                            throw new DdlException(e.getMessage(), e);\n+                        } catch (InterruptedException e) {\n+                            cancelJob(deleteJob, CancelType.UNKNOWN, e.getMessage());\n+                            throw new DdlException(e.getMessage(), e);\n+                        }\n+                        commitJob(deleteJob, db, timeoutMs);\n+                        break;\n+                    default:\n+                        Preconditions.checkState(false, \"wrong delete job state: \" + state.name());\n+                        break;\n+                }\n+            } else {\n+                commitJob(deleteJob, db, timeoutMs);\n+            }\n+        } finally {\n+            if (!FeConstants.runningUnitTest) {\n+                clearJob(deleteJob);\n+            }\n+        }\n+    }\n+\n+    private void commitJob(DeleteJob job, Database db, long timeoutMs) throws DdlException {\n+        TransactionStatus status = null;\n+        try {\n+            unprotectedCommitJob(job, db, timeoutMs);\n+            status = Catalog.getCurrentGlobalTransactionMgr().\n+                    getTransactionState(job.getTransactionId()).getTransactionStatus();\n+        } catch (UserException e) {\n+            cancelJob(job, CancelType.COMMIT_FAIL, e.getMessage());\n+            throw new DdlException(e.getMessage(), e);\n+        }\n+\n+        switch (status) {\n+            case COMMITTED:\n+                // Although publish is unfinished we should tell user that commit already success.\n+                throw new DdlException(\"delete job is committed but may be taking effect later, transactionId: \" + job.getTransactionId());\n+            case VISIBLE:\n+                break;\n+            default:\n+                Preconditions.checkState(false, \"wrong transaction status: \" + status.name());\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * unprotected commit delete job\n+     * return true when successfully commit and publish\n+     * return false when successfully commit but publish unfinished.\n+     * A UserException thrown if both commit and publish failed.\n+     * @param job\n+     * @param db\n+     * @param timeoutMs\n+     * @return\n+     * @throws UserException\n+     */\n+    private boolean unprotectedCommitJob(DeleteJob job, Database db, long timeoutMs) throws UserException {\n+        long transactionId = job.getTransactionId();\n+        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n+        List<TabletCommitInfo> tabletCommitInfos = new ArrayList<TabletCommitInfo>();\n+        TabletInvertedIndex invertedIndex = Catalog.getCurrentInvertedIndex();\n+        for (TabletDeleteInfo tDeleteInfo : job.getTabletDeleteInfo()) {\n+            for (Replica replica : tDeleteInfo.getFinishedReplicas()) {\n+                // the inverted index contains rolling up replica\n+                Long tabletId = invertedIndex.getTabletIdByReplica(replica.getId());\n+                if (tabletId == null) {\n+                    LOG.warn(\"could not find tablet id for replica {}, the tablet maybe dropped\", replica);\n+                    continue;\n+                }\n+                tabletCommitInfos.add(new TabletCommitInfo(tabletId, replica.getBackendId()));\n+            }\n+        }\n+        return globalTransactionMgr.commitAndPublishTransaction(db, transactionId, tabletCommitInfos, timeoutMs);\n+    }\n+\n+    /**\n+     * This method should always be called in the end of the delete process to clean the job.\n+     * Better put it in finally block.\n+     * @param job\n+     */\n+    private void clearJob(DeleteJob job) {\n+        if (job != null) {\n+            long signature = job.getTransactionId();\n+            if (idToDeleteJob.containsKey(signature)) {\n+                idToDeleteJob.remove(signature);\n+            }\n+            for (PushTask pushTask : job.getPushTasks()) {\n+                AgentTaskQueue.removePushTask(pushTask.getBackendId(), pushTask.getSignature(),\n+                        pushTask.getVersion(), pushTask.getVersionHash(),\n+                        pushTask.getPushType(), pushTask.getTaskType());\n+            }\n+            Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().removeCallback(job.getId());\n+        }\n+    }\n+\n+    public void recordFinishedJob(DeleteJob job) {\n+        if (job != null) {\n+            long dbId = job.getDeleteInfo().getDbId();\n+            LOG.info(\"record finished deleteJob, transactionId {}, dbId {}\",\n+                    job.getTransactionId(), dbId);\n+            List<DeleteInfo> deleteInfoList = dbToDeleteInfos.get(dbId);\n+            if (deleteInfoList == null) {\n+                deleteInfoList = Lists.newArrayList();\n+                dbToDeleteInfos.put(dbId, deleteInfoList);\n+            }\n+            deleteInfoList.add(job.getDeleteInfo());\n+        }\n+    }\n+\n+    public boolean cancelJob(DeleteJob job, CancelType cancelType, String reason) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEwMTUyOQ=="}, "originalCommit": {"oid": "f7da159334e579fbbcedc8d22b97148187fe33da"}, "originalPosition": 387}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEwNTEyNg==", "bodyText": "No need db lock here.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r408105126", "createdAt": "2020-04-14T12:43:08Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -0,0 +1,627 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DeleteStmt;\n+import org.apache.doris.analysis.IsNullPredicate;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.Predicate;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.KeysType;\n+import org.apache.doris.catalog.MaterializedIndex;\n+import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.catalog.Tablet;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.FeConstants;\n+import org.apache.doris.common.MarkedCountDownLatch;\n+import org.apache.doris.common.MetaNotFoundException;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.ListComparator;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.service.FrontendOptions;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.DeleteJob;\n+import org.apache.doris.task.DeleteJob.DeleteState;\n+import org.apache.doris.task.PushTask;\n+import org.apache.doris.thrift.TPriority;\n+import org.apache.doris.thrift.TPushType;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.doris.transaction.GlobalTransactionMgr;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.doris.transaction.TransactionStatus;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+public class DeleteHandler implements Writable {\n+    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n+\n+    // TransactionId -> DeleteJob\n+    private Map<Long, DeleteJob> idToDeleteJob;\n+\n+    // Db -> DeleteInfo list\n+    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n+\n+    public DeleteHandler() {\n+        idToDeleteJob = Maps.newConcurrentMap();\n+        dbToDeleteInfos = Maps.newConcurrentMap();\n+    }\n+\n+    private enum CancelType {\n+        METADATA_MISSING,\n+        TIMEOUT,\n+        COMMIT_FAIL,\n+        UNKNOWN\n+    }\n+\n+    public void process(DeleteStmt stmt) throws DdlException {\n+        String dbName = stmt.getDbName();\n+        String tableName = stmt.getTableName();\n+        String partitionName = stmt.getPartitionName();\n+        List<Predicate> conditions = stmt.getDeleteConditions();\n+        Database db = Catalog.getInstance().getDb(dbName);\n+        if (db == null) {\n+            throw new DdlException(\"Db does not exist. name: \" + dbName);\n+        }\n+\n+        DeleteJob deleteJob = null;\n+        try {\n+            MarkedCountDownLatch<Long, Long> countDownLatch;\n+            long transactionId = -1;\n+            db.readLock();\n+            try {\n+                Table table = db.getTable(tableName);\n+                if (table == null) {\n+                    throw new DdlException(\"Table does not exist. name: \" + tableName);\n+                }\n+\n+                if (table.getType() != Table.TableType.OLAP) {\n+                    throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n+                }\n+                OlapTable olapTable = (OlapTable) table;\n+\n+                if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n+                    throw new DdlException(\"Table's state is not normal: \" + tableName);\n+                }\n+\n+                if (partitionName == null) {\n+                    if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n+                        throw new DdlException(\"This is a range partitioned table.\"\n+                                + \" You should specify partition in delete stmt\");\n+                    } else {\n+                        // this is a unpartitioned table, use table name as partition name\n+                        partitionName = olapTable.getName();\n+                    }\n+                }\n+\n+                Partition partition = olapTable.getPartition(partitionName);\n+                if (partition == null) {\n+                    throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n+                }\n+\n+                List<String> deleteConditions = Lists.newArrayList();\n+\n+                // pre check\n+                checkDeleteV2(olapTable, partition, conditions, deleteConditions, true);\n+\n+                // generate label\n+                String label = \"delete_\" + UUID.randomUUID();\n+                //generate jobId\n+                long jobId = Catalog.getCurrentCatalog().getNextId();\n+                // begin txn here and generate txn id\n+                transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n+                        Lists.newArrayList(table.getId()), label, null, \"FE: \" + FrontendOptions.getLocalHostAddress(),\n+                        TransactionState.LoadJobSourceType.FRONTEND, jobId, Config.stream_load_default_timeout_second);\n+\n+                DeleteInfo deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n+                        partition.getId(), partitionName,\n+                        -1, 0, deleteConditions);\n+                deleteJob = new DeleteJob(jobId, transactionId, deleteInfo);\n+                idToDeleteJob.put(deleteJob.getTransactionId(), deleteJob);\n+\n+                Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().addCallback(deleteJob);\n+                // task sent to be\n+                AgentBatchTask batchTask = new AgentBatchTask();\n+                // count total replica num\n+                int totalReplicaNum = 0;\n+                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                    for (Tablet tablet : index.getTablets()) {\n+                        totalReplicaNum += tablet.getReplicas().size();\n+                    }\n+                }\n+                countDownLatch = new MarkedCountDownLatch<Long, Long>(totalReplicaNum);\n+\n+                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                    long indexId = index.getId();\n+                    int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n+\n+                    for (Tablet tablet : index.getTablets()) {\n+                        long tabletId = tablet.getId();\n+\n+                        // set push type\n+                        TPushType type = TPushType.DELETE;\n+\n+                        for (Replica replica : tablet.getReplicas()) {\n+                            long replicaId = replica.getId();\n+                            long backendId = replica.getBackendId();\n+                            countDownLatch.addMark(backendId, tabletId);\n+\n+                            // create push task for each replica\n+                            PushTask pushTask = new PushTask(null,\n+                                    replica.getBackendId(), db.getId(), olapTable.getId(),\n+                                    partition.getId(), indexId,\n+                                    tabletId, replicaId, schemaHash,\n+                                    -1, 0, \"\", -1, 0,\n+                                    -1, type, conditions,\n+                                    true, TPriority.NORMAL,\n+                                    TTaskType.REALTIME_PUSH,\n+                                    transactionId,\n+                                    Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n+                            pushTask.setIsSchemaChanging(false);\n+                            pushTask.setCountDownLatch(countDownLatch);\n+\n+                            if (AgentTaskQueue.addTask(pushTask)) {\n+                                batchTask.addTask(pushTask);\n+                                deleteJob.addPushTask(pushTask);\n+                                deleteJob.addTablet(tabletId);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // submit push tasks\n+                if (batchTask.getTaskNum() > 0) {\n+                    AgentTaskExecutor.submit(batchTask);\n+                }\n+\n+            } catch (Throwable t) {\n+                LOG.warn(\"error occurred during delete process\", t);\n+                // if transaction has been begun, need to abort it\n+                if (Catalog.getCurrentGlobalTransactionMgr().getTransactionState(transactionId) != null) {\n+                    cancelJob(deleteJob, CancelType.UNKNOWN, t.getMessage());\n+                }\n+                throw new DdlException(t.getMessage(), t);\n+            } finally {\n+                db.readUnlock();\n+            }\n+\n+            long timeoutMs = deleteJob.getTimeoutMs();\n+            LOG.info(\"waiting delete Job finish, signature: {}, timeout: {}\", transactionId, timeoutMs);\n+            boolean ok = false;\n+            try {\n+                ok = countDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);\n+            } catch (InterruptedException e) {\n+                LOG.warn(\"InterruptedException: \", e);\n+                ok = false;\n+            }\n+\n+            if (!ok) {\n+                try {\n+                    deleteJob.checkAndUpdateQuorum();\n+                } catch (MetaNotFoundException e) {\n+                    cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n+                    throw new DdlException(e.getMessage(), e);\n+                }\n+                DeleteState state = deleteJob.getState();\n+                switch (state) {\n+                    case UN_QUORUM:\n+                        List<Entry<Long, Long>> unfinishedMarks = countDownLatch.getLeftMarks();\n+                        // only show at most 5 results\n+                        List<Entry<Long, Long>> subList = unfinishedMarks.subList(0, Math.min(unfinishedMarks.size(), 5));\n+                        String errMsg = \"Unfinished replicas:\" + Joiner.on(\", \").join(subList);\n+                        LOG.warn(\"delete job timeout: transactionId {}, {}\", transactionId, errMsg);\n+                        cancelJob(deleteJob, CancelType.TIMEOUT, \"delete job timeout\");\n+                        throw new DdlException(\"failed to delete replicas from job: \" + transactionId + \", \" + errMsg);\n+                    case QUORUM_FINISHED:\n+                    case FINISHED:\n+                        try {\n+                            long nowQuorumTimeMs = System.currentTimeMillis();\n+                            long endQuorumTimeoutMs = nowQuorumTimeMs + timeoutMs / 2;\n+                            // if job's state is quorum_finished then wait for a period of time and commit it.\n+                            while (deleteJob.getState() == DeleteState.QUORUM_FINISHED && endQuorumTimeoutMs > nowQuorumTimeMs) {\n+                                deleteJob.checkAndUpdateQuorum();\n+                                Thread.sleep(1000);\n+                                nowQuorumTimeMs = System.currentTimeMillis();\n+                            }\n+                        } catch (MetaNotFoundException e) {\n+                            cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n+                            throw new DdlException(e.getMessage(), e);\n+                        } catch (InterruptedException e) {\n+                            cancelJob(deleteJob, CancelType.UNKNOWN, e.getMessage());\n+                            throw new DdlException(e.getMessage(), e);\n+                        }\n+                        commitJob(deleteJob, db, timeoutMs);\n+                        break;\n+                    default:\n+                        Preconditions.checkState(false, \"wrong delete job state: \" + state.name());\n+                        break;\n+                }\n+            } else {\n+                commitJob(deleteJob, db, timeoutMs);\n+            }\n+        } finally {\n+            if (!FeConstants.runningUnitTest) {\n+                clearJob(deleteJob);\n+            }\n+        }\n+    }\n+\n+    private void commitJob(DeleteJob job, Database db, long timeoutMs) throws DdlException {\n+        TransactionStatus status = null;\n+        try {\n+            unprotectedCommitJob(job, db, timeoutMs);\n+            status = Catalog.getCurrentGlobalTransactionMgr().\n+                    getTransactionState(job.getTransactionId()).getTransactionStatus();\n+        } catch (UserException e) {\n+            cancelJob(job, CancelType.COMMIT_FAIL, e.getMessage());\n+            throw new DdlException(e.getMessage(), e);\n+        }\n+\n+        switch (status) {\n+            case COMMITTED:\n+                // Although publish is unfinished we should tell user that commit already success.\n+                throw new DdlException(\"delete job is committed but may be taking effect later, transactionId: \" + job.getTransactionId());\n+            case VISIBLE:\n+                break;\n+            default:\n+                Preconditions.checkState(false, \"wrong transaction status: \" + status.name());\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * unprotected commit delete job\n+     * return true when successfully commit and publish\n+     * return false when successfully commit but publish unfinished.\n+     * A UserException thrown if both commit and publish failed.\n+     * @param job\n+     * @param db\n+     * @param timeoutMs\n+     * @return\n+     * @throws UserException\n+     */\n+    private boolean unprotectedCommitJob(DeleteJob job, Database db, long timeoutMs) throws UserException {\n+        long transactionId = job.getTransactionId();\n+        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n+        List<TabletCommitInfo> tabletCommitInfos = new ArrayList<TabletCommitInfo>();\n+        TabletInvertedIndex invertedIndex = Catalog.getCurrentInvertedIndex();\n+        for (TabletDeleteInfo tDeleteInfo : job.getTabletDeleteInfo()) {\n+            for (Replica replica : tDeleteInfo.getFinishedReplicas()) {\n+                // the inverted index contains rolling up replica\n+                Long tabletId = invertedIndex.getTabletIdByReplica(replica.getId());\n+                if (tabletId == null) {\n+                    LOG.warn(\"could not find tablet id for replica {}, the tablet maybe dropped\", replica);\n+                    continue;\n+                }\n+                tabletCommitInfos.add(new TabletCommitInfo(tabletId, replica.getBackendId()));\n+            }\n+        }\n+        return globalTransactionMgr.commitAndPublishTransaction(db, transactionId, tabletCommitInfos, timeoutMs);\n+    }\n+\n+    /**\n+     * This method should always be called in the end of the delete process to clean the job.\n+     * Better put it in finally block.\n+     * @param job\n+     */\n+    private void clearJob(DeleteJob job) {\n+        if (job != null) {\n+            long signature = job.getTransactionId();\n+            if (idToDeleteJob.containsKey(signature)) {\n+                idToDeleteJob.remove(signature);\n+            }\n+            for (PushTask pushTask : job.getPushTasks()) {\n+                AgentTaskQueue.removePushTask(pushTask.getBackendId(), pushTask.getSignature(),\n+                        pushTask.getVersion(), pushTask.getVersionHash(),\n+                        pushTask.getPushType(), pushTask.getTaskType());\n+            }\n+            Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().removeCallback(job.getId());\n+        }\n+    }\n+\n+    public void recordFinishedJob(DeleteJob job) {\n+        if (job != null) {\n+            long dbId = job.getDeleteInfo().getDbId();\n+            LOG.info(\"record finished deleteJob, transactionId {}, dbId {}\",\n+                    job.getTransactionId(), dbId);\n+            List<DeleteInfo> deleteInfoList = dbToDeleteInfos.get(dbId);\n+            if (deleteInfoList == null) {\n+                deleteInfoList = Lists.newArrayList();\n+                dbToDeleteInfos.put(dbId, deleteInfoList);\n+            }\n+            deleteInfoList.add(job.getDeleteInfo());\n+        }\n+    }\n+\n+    public boolean cancelJob(DeleteJob job, CancelType cancelType, String reason) {\n+        LOG.info(\"start to cancel delete job, transactionId: {}, cancelType: {}\", job.getTransactionId(), cancelType.name());\n+        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n+        try {\n+            if (job != null) {\n+                globalTransactionMgr.abortTransaction(job.getTransactionId(), reason);\n+            }\n+        } catch (Exception e) {\n+            TransactionState state = globalTransactionMgr.getTransactionState(job.getTransactionId());\n+            if (state == null) {\n+                LOG.warn(\"cancel delete job failed because txn not found, transactionId: {}\", job.getTransactionId());\n+            } else if (state.getTransactionStatus() == TransactionStatus.COMMITTED || state.getTransactionStatus() == TransactionStatus.VISIBLE) {\n+                LOG.warn(\"cancel delete job {} failed because it has been committed, transactionId: {}\", job.getTransactionId());\n+            } else {\n+                LOG.warn(\"errors while abort transaction\", e);\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public DeleteJob getDeleteJob(long transactionId) {\n+        return idToDeleteJob.get(transactionId);\n+    }\n+\n+    private void checkDeleteV2(OlapTable table, Partition partition, List<Predicate> conditions, List<String> deleteConditions, boolean preCheck)\n+            throws DdlException {\n+\n+        // check partition state\n+        Partition.PartitionState state = partition.getState();\n+        if (state != Partition.PartitionState.NORMAL) {\n+            // ErrorReport.reportDdlException(ErrorCode.ERR_BAD_PARTITION_STATE, partition.getName(), state.name());\n+            throw new DdlException(\"Partition[\" + partition.getName() + \"]' state is not NORMAL: \" + state.name());\n+        }\n+\n+        // check condition column is key column and condition value\n+        Map<String, Column> nameToColumn = Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);\n+        for (Column column : table.getBaseSchema()) {\n+            nameToColumn.put(column.getName(), column);\n+        }\n+        for (Predicate condition : conditions) {\n+            SlotRef slotRef = null;\n+            if (condition instanceof BinaryPredicate) {\n+                BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n+                slotRef = (SlotRef) binaryPredicate.getChild(0);\n+            } else if (condition instanceof IsNullPredicate) {\n+                IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n+                slotRef = (SlotRef) isNullPredicate.getChild(0);\n+            }\n+            String columnName = slotRef.getColumnName();\n+            if (!nameToColumn.containsKey(columnName)) {\n+                ErrorReport.reportDdlException(ErrorCode.ERR_BAD_FIELD_ERROR, columnName, table.getName());\n+            }\n+\n+            Column column = nameToColumn.get(columnName);\n+            if (!column.isKey()) {\n+                // ErrorReport.reportDdlException(ErrorCode.ERR_NOT_KEY_COLUMN, columnName);\n+                throw new DdlException(\"Column[\" + columnName + \"] is not key column\");\n+            }\n+\n+            if (condition instanceof BinaryPredicate) {\n+                String value = null;\n+                try {\n+                    BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n+                    value = ((LiteralExpr) binaryPredicate.getChild(1)).getStringValue();\n+                    LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n+                } catch (AnalysisException e) {\n+                    // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);\n+                    throw new DdlException(\"Invalid column value[\" + value + \"]\");\n+                }\n+            }\n+\n+            // set schema column name\n+            slotRef.setCol(column.getName());\n+        }\n+        Map<Long, List<Column>> indexIdToSchema = table.getIndexIdToSchema();\n+        for (MaterializedIndex index : partition.getMaterializedIndices(MaterializedIndex.IndexExtState.VISIBLE)) {\n+            // check table has condition column\n+            Map<String, Column> indexColNameToColumn = Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);\n+            for (Column column : indexIdToSchema.get(index.getId())) {\n+                indexColNameToColumn.put(column.getName(), column);\n+            }\n+            String indexName = table.getIndexNameById(index.getId());\n+            for (Predicate condition : conditions) {\n+                String columnName = null;\n+                if (condition instanceof BinaryPredicate) {\n+                    BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n+                    columnName = ((SlotRef) binaryPredicate.getChild(0)).getColumnName();\n+                } else if (condition instanceof IsNullPredicate) {\n+                    IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n+                    columnName = ((SlotRef) isNullPredicate.getChild(0)).getColumnName();\n+                }\n+                Column column = indexColNameToColumn.get(columnName);\n+                if (column == null) {\n+                    ErrorReport.reportDdlException(ErrorCode.ERR_BAD_FIELD_ERROR, columnName, indexName);\n+                }\n+\n+                if (table.getKeysType() == KeysType.DUP_KEYS && !column.isKey()) {\n+                    throw new DdlException(\"Column[\" + columnName + \"] is not key column in index[\" + indexName + \"]\");\n+                }\n+            }\n+        }\n+\n+        if (deleteConditions == null) {\n+            return;\n+        }\n+\n+        // save delete conditions\n+        for (Predicate condition : conditions) {\n+            if (condition instanceof BinaryPredicate) {\n+                BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n+                SlotRef slotRef = (SlotRef) binaryPredicate.getChild(0);\n+                String columnName = slotRef.getColumnName();\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(columnName).append(\" \").append(binaryPredicate.getOp().name()).append(\" \\\"\")\n+                        .append(((LiteralExpr) binaryPredicate.getChild(1)).getStringValue()).append(\"\\\"\");\n+                deleteConditions.add(sb.toString());\n+            } else if (condition instanceof IsNullPredicate) {\n+                IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n+                SlotRef slotRef = (SlotRef) isNullPredicate.getChild(0);\n+                String columnName = slotRef.getColumnName();\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(columnName);\n+                if (isNullPredicate.isNotNull()) {\n+                    sb.append(\" IS NOT NULL\");\n+                } else {\n+                    sb.append(\" IS NULL\");\n+                }\n+                deleteConditions.add(sb.toString());\n+            }\n+        }\n+    }\n+\n+    // show delete stmt\n+    public List<List<Comparable>> getDeleteInfosByDb(long dbId, boolean forUser) {\n+        LinkedList<List<Comparable>> infos = new LinkedList<List<Comparable>>();\n+        Database db = Catalog.getInstance().getDb(dbId);\n+        if (db == null) {\n+            return infos;\n+        }\n+\n+        String dbName = db.getFullName();\n+        List<DeleteInfo> deleteInfos = dbToDeleteInfos.get(dbId);\n+        if (deleteInfos == null) {\n+            return infos;\n+        }\n+\n+        for (DeleteInfo deleteInfo : deleteInfos) {\n+\n+            if (!Catalog.getCurrentCatalog().getAuth().checkTblPriv(ConnectContext.get(), dbName,\n+                    deleteInfo.getTableName(),\n+                    PrivPredicate.LOAD)) {\n+                continue;\n+            }\n+\n+\n+            List<Comparable> info = Lists.newArrayList();\n+            if (!forUser) {\n+                info.add(-1L);\n+                info.add(deleteInfo.getTableId());\n+            }\n+            info.add(deleteInfo.getTableName());\n+            if (!forUser) {\n+                info.add(deleteInfo.getPartitionId());\n+            }\n+            info.add(deleteInfo.getPartitionName());\n+\n+            info.add(TimeUtils.longToTimeString(deleteInfo.getCreateTimeMs()));\n+            String conds = Joiner.on(\", \").join(deleteInfo.getDeleteConditions());\n+            info.add(conds);\n+\n+            if (!forUser) {\n+                info.add(deleteInfo.getPartitionVersion());\n+                info.add(deleteInfo.getPartitionVersionHash());\n+            }\n+            // for loading state, should not display loading, show deleting instead\n+//                if (loadJob.getState() == LoadJob.JobState.LOADING) {\n+//                    info.add(\"DELETING\");\n+//                } else {\n+//                    info.add(loadJob.getState().name());\n+//                }\n+            info.add(\"FINISHED\");\n+            infos.add(info);\n+        }\n+        // sort by createTimeMs\n+        int sortIndex;\n+        if (!forUser) {\n+            sortIndex = 5;\n+        } else {\n+            sortIndex = 2;\n+        }\n+        ListComparator<List<Comparable>> comparator = new ListComparator<List<Comparable>>(sortIndex);\n+        Collections.sort(infos, comparator);\n+        return infos;\n+    }\n+\n+    public void replayDelete(DeleteInfo deleteInfo, Catalog catalog) {\n+        Database db = catalog.getDb(deleteInfo.getDbId());\n+        db.writeLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7da159334e579fbbcedc8d22b97148187fe33da"}, "originalPosition": 585}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9910f3b782d85fd8d6c0984cfb28b16f1f4b62d", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/e9910f3b782d85fd8d6c0984cfb28b16f1f4b62d", "committedDate": "2020-04-15T04:35:37Z", "message": "commit 1: deleteV2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "000982ea8eddfd1d78f1acecf99e0dfbeaf5ea51", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/000982ea8eddfd1d78f1acecf99e0dfbeaf5ea51", "committedDate": "2020-04-15T04:35:38Z", "message": "commit 2: delete handler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bc3679d39f1408ae785a7c231305a0218a95d23", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/1bc3679d39f1408ae785a7c231305a0218a95d23", "committedDate": "2020-04-15T04:35:38Z", "message": "commit 3: delete handler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "739a0bb38b24c18b02b39bbaef9d7a55f80e1642", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/739a0bb38b24c18b02b39bbaef9d7a55f80e1642", "committedDate": "2020-04-15T04:35:38Z", "message": "commit 3: delete handler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "927aadd439e850ebe804e08f72b7cf5acf09b1f2", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/927aadd439e850ebe804e08f72b7cf5acf09b1f2", "committedDate": "2020-04-15T04:35:38Z", "message": "commit 4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9530aae3dceec548796249905ed2085dbc78715d", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/9530aae3dceec548796249905ed2085dbc78715d", "committedDate": "2020-04-15T04:35:38Z", "message": "commit 5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "933a4523d23ce42d60d93e5c1849187817cbedef", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/933a4523d23ce42d60d93e5c1849187817cbedef", "committedDate": "2020-04-15T04:35:38Z", "message": "commit 6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f442fdb1b8f358ad21b3eb24f0daadcbb0a650d2", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/f442fdb1b8f358ad21b3eb24f0daadcbb0a650d2", "committedDate": "2020-04-15T04:37:32Z", "message": "commit 7"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52bc87a064b6ba246572672a93e13bfbab3cc871", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/52bc87a064b6ba246572672a93e13bfbab3cc871", "committedDate": "2020-04-15T04:37:32Z", "message": "commit 8"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f79ea527dc838dae6a052ea125fc97db0ed3e91", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/2f79ea527dc838dae6a052ea125fc97db0ed3e91", "committedDate": "2020-04-15T04:37:32Z", "message": "commit 9"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06547990c85e3c0ca7460852e82574c27ab27081", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/06547990c85e3c0ca7460852e82574c27ab27081", "committedDate": "2020-04-15T04:37:32Z", "message": "commit 10"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1571157cf56eeb1ef704c0d86bb016d29a95ca6c", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/1571157cf56eeb1ef704c0d86bb016d29a95ca6c", "committedDate": "2020-04-15T04:37:32Z", "message": "commit 11"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef29b1a2b1bf24301aa3d663be8c2b34ac150c2f", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/ef29b1a2b1bf24301aa3d663be8c2b34ac150c2f", "committedDate": "2020-04-15T04:37:32Z", "message": "commit 12"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f9cb8d09a96fd4974d9419b8f5eb503464e18ab", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/5f9cb8d09a96fd4974d9419b8f5eb503464e18ab", "committedDate": "2020-04-15T10:45:33Z", "message": "commit 13"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f7da159334e579fbbcedc8d22b97148187fe33da", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/f7da159334e579fbbcedc8d22b97148187fe33da", "committedDate": "2020-04-14T01:15:01Z", "message": "commit 11"}, "afterCommit": {"oid": "5f9cb8d09a96fd4974d9419b8f5eb503464e18ab", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/5f9cb8d09a96fd4974d9419b8f5eb503464e18ab", "committedDate": "2020-04-15T10:45:33Z", "message": "commit 13"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd9f6dfb501fb26f8856a15bcbdb8ccf3c63e8b3", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/bd9f6dfb501fb26f8856a15bcbdb8ccf3c63e8b3", "committedDate": "2020-04-15T13:02:22Z", "message": "commit 14"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf027fec5625c14ff9ae459a33e47c0e2a611b4f", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/cf027fec5625c14ff9ae459a33e47c0e2a611b4f", "committedDate": "2020-04-15T13:17:53Z", "message": "commit 15"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNzk0NDM0", "url": "https://github.com/apache/incubator-doris/pull/3191#pullrequestreview-393794434", "createdAt": "2020-04-15T13:52:38Z", "commit": {"oid": "cf027fec5625c14ff9ae459a33e47c0e2a611b4f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMzo1MjozOFrOGF6wrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDowMTozOVrOGF7MSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg1ODc5OA==", "bodyText": "QueryStateException should derived from UserException.\nBetter to just create a QueryState inside the QueryStateException, and here you can just call context.setState(e.getQueryState());. If other people use this exception, he will know how to use it.", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r408858798", "createdAt": "2020-04-15T13:52:38Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/qe/StmtExecutor.java", "diffHunk": "@@ -867,6 +867,8 @@ private void handleDdlStmt() {\n         try {\n             DdlExecutor.execute(context.getCatalog(), (DdlStmt) parsedStmt, originStmt);\n             context.getState().setOk();\n+        } catch (QueryStateException e) {\n+            context.getState().setOk(0L, 0, e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf027fec5625c14ff9ae459a33e47c0e2a611b4f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2NTg2NQ==", "bodyText": "No need to use synchronized here, I think you can just use a ConcurrentSet in TabletDeleteInfo", "url": "https://github.com/apache/incubator-doris/pull/3191#discussion_r408865865", "createdAt": "2020-04-15T14:01:39Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/task/DeleteJob.java", "diffHunk": "@@ -0,0 +1,190 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.task;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.MetaNotFoundException;\n+import org.apache.doris.load.DeleteInfo;\n+import org.apache.doris.load.TabletDeleteInfo;\n+import org.apache.doris.transaction.AbstractTxnStateChangeCallback;\n+import org.apache.doris.transaction.TransactionState;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class DeleteJob extends AbstractTxnStateChangeCallback {\n+    private static final Logger LOG = LogManager.getLogger(DeleteJob.class);\n+\n+    public enum DeleteState {\n+        UN_QUORUM,\n+        QUORUM_FINISHED,\n+        FINISHED\n+    }\n+\n+    private DeleteState state;\n+\n+    // jobId(listenerId). use in beginTransaction to callback function\n+    private long id;\n+    // transaction id.\n+    private long signature;\n+    private String label;\n+    private Set<Long> totalTablets;\n+    private Set<Long> quorumTablets;\n+    private Set<Long> finishedTablets;\n+    Map<Long, TabletDeleteInfo> tabletDeleteInfoMap;\n+    private Set<PushTask> pushTasks;\n+    private DeleteInfo deleteInfo;\n+\n+    public DeleteJob(long id, long transactionId, String label, DeleteInfo deleteInfo) {\n+        this.id = id;\n+        this.signature = transactionId;\n+        this.label = label;\n+        this.deleteInfo = deleteInfo;\n+        totalTablets = Sets.newHashSet();\n+        finishedTablets = Sets.newHashSet();\n+        quorumTablets = Sets.newHashSet();\n+        tabletDeleteInfoMap = Maps.newConcurrentMap();\n+        pushTasks = Sets.newHashSet();\n+        state = DeleteState.UN_QUORUM;\n+    }\n+\n+    /**\n+     * check and update if this job's state is QUORUM_FINISHED or FINISHED\n+     * The meaning of state:\n+     * QUORUM_FINISHED: For each tablet there are more than half of its replicas have been finished\n+     * FINISHED: All replicas of this jobs have finished\n+     */\n+    public void checkAndUpdateQuorum() throws MetaNotFoundException {\n+        long dbId = deleteInfo.getDbId();\n+        long tableId = deleteInfo.getTableId();\n+        long partitionId = deleteInfo.getPartitionId();\n+        Database db = Catalog.getInstance().getDb(dbId);\n+        if (db == null) {\n+            throw new MetaNotFoundException(\"can not find database \"+ dbId +\" when commit delete\");\n+        }\n+\n+        short replicaNum = -1;\n+        db.readLock();\n+        try {\n+            OlapTable table = (OlapTable) db.getTable(tableId);\n+            if (table == null) {\n+                throw new MetaNotFoundException(\"can not find table \"+ tableId +\" when commit delete\");\n+            }\n+            replicaNum = table.getPartitionInfo().getReplicationNum(partitionId);\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        short quorumNum = (short) (replicaNum / 2 + 1);\n+        for (TabletDeleteInfo tDeleteInfo : getTabletDeleteInfo()) {\n+            if (tDeleteInfo.getFinishedReplicas().size() == replicaNum) {\n+                finishedTablets.add(tDeleteInfo.getTabletId());\n+            }\n+            if (tDeleteInfo.getFinishedReplicas().size() >= quorumNum) {\n+                quorumTablets.add(tDeleteInfo.getTabletId());\n+            }\n+        }\n+        LOG.info(\"check delete job quorum, transaction id: {}, total tablets: {}, quorum tablets: {},\",\n+                signature, totalTablets.size(), quorumTablets.size());\n+\n+        if (finishedTablets.containsAll(totalTablets)) {\n+            setState(DeleteState.FINISHED);\n+        } else if (quorumTablets.containsAll(totalTablets)) {\n+            setState(DeleteState.QUORUM_FINISHED);\n+        }\n+    }\n+\n+    public void setState(DeleteState state) {\n+        this.state = state;\n+    }\n+\n+    public DeleteState getState() {\n+        return this.state;\n+    }\n+\n+    public boolean addTablet(long tabletId) {\n+        return totalTablets.add(tabletId);\n+    }\n+\n+    public boolean addPushTask(PushTask pushTask) {\n+        return pushTasks.add(pushTask);\n+    }\n+\n+    public boolean addFinishedReplica(long tabletId, Replica replica) {\n+        tabletDeleteInfoMap.putIfAbsent(tabletId, new TabletDeleteInfo(tabletId));\n+        TabletDeleteInfo tDeleteInfo =  tabletDeleteInfoMap.get(tabletId);\n+        synchronized (tDeleteInfo) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf027fec5625c14ff9ae459a33e47c0e2a611b4f"}, "originalPosition": 140}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a068e0bd0917dd89b14341b51c254a9b751833a", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/9a068e0bd0917dd89b14341b51c254a9b751833a", "committedDate": "2020-04-15T14:59:02Z", "message": "commit 16"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzODczODI3", "url": "https://github.com/apache/incubator-doris/pull/3191#pullrequestreview-393873827", "createdAt": "2020-04-15T15:13:32Z", "commit": {"oid": "9a068e0bd0917dd89b14341b51c254a9b751833a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3071, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}