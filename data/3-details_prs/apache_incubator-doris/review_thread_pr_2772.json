{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzMDk4NTMy", "number": 2772, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoxODo1N1rODYJ_CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMDowNDo1MlrODYreow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjU2MDA4OnYy", "diffSide": "RIGHT", "path": "be/src/util/bitmap_value.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoxODo1N1rOFd2fZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMzoxODo1OFrOFd39hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0NTc5Ng==", "bodyText": "I think we would better move Roaring64Map to a single file.\nAdd mark which method is different from roaring64map.hh.\nBesides, If we decide to keep ourself  Roaring64Map, we should porting the UT of Roaring64Map at the same time.", "url": "https://github.com/apache/incubator-doris/pull/2772#discussion_r366845796", "createdAt": "2020-01-15T12:18:57Z", "author": {"login": "kangkaisen"}, "path": "be/src/util/bitmap_value.h", "diffHunk": "@@ -0,0 +1,1245 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_UTIL_BITMAP_VALUE_H\n+#define DORIS_BE_SRC_UTIL_BITMAP_VALUE_H\n+\n+#include <algorithm>\n+#include <cstdarg>\n+#include <cstdio>\n+#include <limits>\n+#include <map>\n+#include <new>\n+#include <numeric>\n+#include <roaring/roaring.hh>\n+#include <stdexcept>\n+#include <string>\n+#include <utility>\n+\n+#include \"common/logging.h\"\n+#include \"util/coding.h\"\n+\n+namespace doris {\n+\n+class Roaring64MapSetBitForwardIterator;\n+\n+// serialized bitmap := TypeCode(1), Payload\n+// The format of payload depends on value of TypeCode which is defined below\n+struct BitmapTypeCode {\n+    enum type {\n+        // An empty bitmap. Payload is 0 byte.\n+        // added in 0.11\n+        EMPTY = 0,\n+        // A bitmap containing only one element that is in [0, UINT32_MAX]\n+        // Payload := UInt32LittleEndian(4 byte)\n+        // added in 0.11\n+        SINGLE32 = 1,\n+        // A bitmap whose maximum element is in [0, UINT32_MAX]\n+        // Payload := the standard RoaringBitmap format described by\n+        // https://github.com/RoaringBitmap/RoaringFormatSpec/\n+        // added in 0.11\n+        BITMAP32 = 2,\n+        // A bitmap containing only one element that is in (UINT32_MAX, UINT64_MAX]\n+        // Payload := UInt64LittleEndian(8 byte)\n+        // (added in 0.12)\n+        SINGLE64 = 3,\n+        // A bitmap whose maximum element is in (UINT32_MAX, UINT64_MAX].\n+        //\n+        // To support 64-bits elements, all elements with the same high 32 bits are stored in a\n+        // RoaringBitmap containing only the lower 32 bits. Thus we could use\n+        // map<uint32_t, RoaringBitmap> to represent bitmap of 64-bits ints.\n+        //\n+        // Since there is no standard format for 64-bits RoaringBitmap, we define our own as below\n+        // Payload := NumRoaring(vint64), { MapKey, MapValue }^NumRoaring\n+        // - MapKey := the shared high 32 bits in UInt32LittleEndian(4 byte)\n+        // - MapValue := the standard RoaringBitmap format\n+        //\n+        // added in 0.12\n+        BITMAP64 = 4\n+    };\n+};\n+\n+// Forked from https://github.com/RoaringBitmap/CRoaring/blob/v0.2.60/cpp/roaring64map.hh\n+// The main differences are\n+// - we use a custom serialized format (see BitmapTypeCode::BITMAP32 and BitmapTypeCode::BITMAP64)\n+// - added clear() and is32BitsEnough() member functions\n+class Roaring64Map {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a0cde414d5d49f4679bc5e4f0427af995f26de3"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2OTg5NA==", "bodyText": "I think we would better move Roaring64Map to a single file.\n\nYeah I've thought about it but failed to find a strong reason to do so. One motivation for a separate file is to spot changes we made via diff. However it turns out to not work because of code style formatting. So I think documenting what we've changed is enough for us to maintain, not to mention the class itself is really easy to understand :)\n\nAdd mark which method is different from roaring64map.hh\n\nYeah, I've tried to do so. Maybe not clear enough, let me try to improve it.\n\nBesides, If we decide to keep ourself Roaring64Map, we should porting the UT of Roaring64Map at the same time.\n\nSure, will port the UT as well", "url": "https://github.com/apache/incubator-doris/pull/2772#discussion_r366869894", "createdAt": "2020-01-15T13:18:58Z", "author": {"login": "gaodayue"}, "path": "be/src/util/bitmap_value.h", "diffHunk": "@@ -0,0 +1,1245 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_UTIL_BITMAP_VALUE_H\n+#define DORIS_BE_SRC_UTIL_BITMAP_VALUE_H\n+\n+#include <algorithm>\n+#include <cstdarg>\n+#include <cstdio>\n+#include <limits>\n+#include <map>\n+#include <new>\n+#include <numeric>\n+#include <roaring/roaring.hh>\n+#include <stdexcept>\n+#include <string>\n+#include <utility>\n+\n+#include \"common/logging.h\"\n+#include \"util/coding.h\"\n+\n+namespace doris {\n+\n+class Roaring64MapSetBitForwardIterator;\n+\n+// serialized bitmap := TypeCode(1), Payload\n+// The format of payload depends on value of TypeCode which is defined below\n+struct BitmapTypeCode {\n+    enum type {\n+        // An empty bitmap. Payload is 0 byte.\n+        // added in 0.11\n+        EMPTY = 0,\n+        // A bitmap containing only one element that is in [0, UINT32_MAX]\n+        // Payload := UInt32LittleEndian(4 byte)\n+        // added in 0.11\n+        SINGLE32 = 1,\n+        // A bitmap whose maximum element is in [0, UINT32_MAX]\n+        // Payload := the standard RoaringBitmap format described by\n+        // https://github.com/RoaringBitmap/RoaringFormatSpec/\n+        // added in 0.11\n+        BITMAP32 = 2,\n+        // A bitmap containing only one element that is in (UINT32_MAX, UINT64_MAX]\n+        // Payload := UInt64LittleEndian(8 byte)\n+        // (added in 0.12)\n+        SINGLE64 = 3,\n+        // A bitmap whose maximum element is in (UINT32_MAX, UINT64_MAX].\n+        //\n+        // To support 64-bits elements, all elements with the same high 32 bits are stored in a\n+        // RoaringBitmap containing only the lower 32 bits. Thus we could use\n+        // map<uint32_t, RoaringBitmap> to represent bitmap of 64-bits ints.\n+        //\n+        // Since there is no standard format for 64-bits RoaringBitmap, we define our own as below\n+        // Payload := NumRoaring(vint64), { MapKey, MapValue }^NumRoaring\n+        // - MapKey := the shared high 32 bits in UInt32LittleEndian(4 byte)\n+        // - MapValue := the standard RoaringBitmap format\n+        //\n+        // added in 0.12\n+        BITMAP64 = 4\n+    };\n+};\n+\n+// Forked from https://github.com/RoaringBitmap/CRoaring/blob/v0.2.60/cpp/roaring64map.hh\n+// The main differences are\n+// - we use a custom serialized format (see BitmapTypeCode::BITMAP32 and BitmapTypeCode::BITMAP64)\n+// - added clear() and is32BitsEnough() member functions\n+class Roaring64Map {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0NTc5Ng=="}, "originalCommit": {"oid": "7a0cde414d5d49f4679bc5e4f0427af995f26de3"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjAxOTM0OnYy", "diffSide": "RIGHT", "path": "be/src/exprs/bitmap_function.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMzo0ODoxMlrOFerFQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMjo1ODowMlrOFetnfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcwNzQ1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            static StringVal serialize(FunctionContext* ctx, BitmapValue& value) {\n          \n          \n            \n            static StringVal serialize(FunctionContext* ctx, const BitmapValue& value) {", "url": "https://github.com/apache/incubator-doris/pull/2772#discussion_r367707458", "createdAt": "2020-01-16T23:48:12Z", "author": {"login": "imay"}, "path": "be/src/exprs/bitmap_function.cpp", "diffHunk": "@@ -154,6 +154,12 @@ void read_from(const char** src, StringValue* result) {\n \n } // namespace detail\n \n+static StringVal serialize(FunctionContext* ctx, BitmapValue& value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397b523d565688a4dae0066db4bbcbd3c620f45c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyOTcyMg==", "bodyText": "BitmapValue::write isn't a const function because it has side-effect to runOptimize or shrink the bitmap.", "url": "https://github.com/apache/incubator-doris/pull/2772#discussion_r367729722", "createdAt": "2020-01-17T01:20:57Z", "author": {"login": "gaodayue"}, "path": "be/src/exprs/bitmap_function.cpp", "diffHunk": "@@ -154,6 +154,12 @@ void read_from(const char** src, StringValue* result) {\n \n } // namespace detail\n \n+static StringVal serialize(FunctionContext* ctx, BitmapValue& value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcwNzQ1OA=="}, "originalCommit": {"oid": "397b523d565688a4dae0066db4bbcbd3c620f45c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMTYzNA==", "bodyText": "In that case, prefer using pointer as argument.", "url": "https://github.com/apache/incubator-doris/pull/2772#discussion_r367731634", "createdAt": "2020-01-17T01:29:23Z", "author": {"login": "imay"}, "path": "be/src/exprs/bitmap_function.cpp", "diffHunk": "@@ -154,6 +154,12 @@ void read_from(const char** src, StringValue* result) {\n \n } // namespace detail\n \n+static StringVal serialize(FunctionContext* ctx, BitmapValue& value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcwNzQ1OA=="}, "originalCommit": {"oid": "397b523d565688a4dae0066db4bbcbd3c620f45c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0ODk4OQ==", "bodyText": "OK", "url": "https://github.com/apache/incubator-doris/pull/2772#discussion_r367748989", "createdAt": "2020-01-17T02:58:02Z", "author": {"login": "gaodayue"}, "path": "be/src/exprs/bitmap_function.cpp", "diffHunk": "@@ -154,6 +154,12 @@ void read_from(const char** src, StringValue* result) {\n \n } // namespace detail\n \n+static StringVal serialize(FunctionContext* ctx, BitmapValue& value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcwNzQ1OA=="}, "originalCommit": {"oid": "397b523d565688a4dae0066db4bbcbd3c620f45c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjA0NzcxOnYy", "diffSide": "RIGHT", "path": "be/src/util/bitmap_value.h", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMDowNDo1MlrOFerWHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoyMTowMFrOFeufqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcxMTc3Mg==", "bodyText": "better add comment that code is written in _bitmap.write.\nBy the way, the code is written in _bitmap.write and the code is read in BitmapValue. There is some coupling this way. Is there another way to do this?", "url": "https://github.com/apache/incubator-doris/pull/2772#discussion_r367711772", "createdAt": "2020-01-17T00:04:52Z", "author": {"login": "imay"}, "path": "be/src/util/bitmap_value.h", "diffHunk": "@@ -0,0 +1,1243 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_UTIL_BITMAP_VALUE_H\n+#define DORIS_BE_SRC_UTIL_BITMAP_VALUE_H\n+\n+#include <algorithm>\n+#include <cstdarg>\n+#include <cstdio>\n+#include <limits>\n+#include <map>\n+#include <new>\n+#include <numeric>\n+#include <roaring/roaring.hh>\n+#include <stdexcept>\n+#include <string>\n+#include <utility>\n+\n+#include \"common/logging.h\"\n+#include \"util/coding.h\"\n+\n+namespace doris {\n+\n+class Roaring64MapSetBitForwardIterator;\n+\n+// serialized bitmap := TypeCode(1), Payload\n+// The format of payload depends on value of TypeCode which is defined below\n+struct BitmapTypeCode {\n+    enum type {\n+        // An empty bitmap. Payload is 0 byte.\n+        // added in 0.11\n+        EMPTY = 0,\n+        // A bitmap containing only one element that is in [0, UINT32_MAX]\n+        // Payload := UInt32LittleEndian(4 byte)\n+        // added in 0.11\n+        SINGLE32 = 1,\n+        // A bitmap whose maximum element is in [0, UINT32_MAX]\n+        // Payload := the standard RoaringBitmap format described by\n+        // https://github.com/RoaringBitmap/RoaringFormatSpec/\n+        // added in 0.11\n+        BITMAP32 = 2,\n+        // A bitmap containing only one element that is in (UINT32_MAX, UINT64_MAX]\n+        // Payload := UInt64LittleEndian(8 byte)\n+        // added in 0.12\n+        SINGLE64 = 3,\n+        // A bitmap whose maximum element is in (UINT32_MAX, UINT64_MAX].\n+        //\n+        // To support 64-bits elements, all elements with the same high 32 bits are stored in a\n+        // RoaringBitmap containing only the lower 32 bits. Thus we could use\n+        // map<uint32_t, RoaringBitmap> to represent bitmap of 64-bits ints.\n+        //\n+        // Since there is no standard format for 64-bits RoaringBitmap, we define our own as below\n+        // Payload := NumRoaring(vint64), { MapKey, MapValue }^NumRoaring\n+        // - MapKey := the shared high 32 bits in UInt32LittleEndian(4 byte)\n+        // - MapValue := the standard RoaringBitmap format\n+        //\n+        // added in 0.12\n+        BITMAP64 = 4\n+    };\n+};\n+\n+// Forked from https://github.com/RoaringBitmap/CRoaring/blob/v0.2.60/cpp/roaring64map.hh\n+// What we change includes\n+// - a custom serialization format is used inside read()/write()/getSizeInBytes()\n+// - added clear() and is32BitsEnough()\n+class Roaring64Map {\n+public:\n+    /**\n+     * Create an empty bitmap\n+     */\n+    Roaring64Map() = default;\n+\n+    /**\n+     * Construct a bitmap from a list of 32-bit integer values.\n+     */\n+    Roaring64Map(size_t n, const uint32_t* data) { addMany(n, data); }\n+\n+    /**\n+     * Construct a bitmap from a list of 64-bit integer values.\n+     */\n+    Roaring64Map(size_t n, const uint64_t* data) { addMany(n, data); }\n+\n+    /**\n+     * Construct a 64-bit map from a 32-bit one\n+     */\n+    Roaring64Map(const Roaring& r) { emplaceOrInsert(0, r); }\n+\n+    /**\n+     * Construct a roaring object from the C struct.\n+     *\n+     * Passing a NULL point is unsafe.\n+     */\n+    Roaring64Map(roaring_bitmap_t* s) { emplaceOrInsert(0, s); }\n+\n+    /**\n+     * Construct a bitmap from a list of integer values.\n+     */\n+    static Roaring64Map bitmapOf(size_t n...) {\n+        Roaring64Map ans;\n+        va_list vl;\n+        va_start(vl, n);\n+        for (size_t i = 0; i < n; i++) {\n+            ans.add(va_arg(vl, uint64_t));\n+        }\n+        va_end(vl);\n+        return ans;\n+    }\n+\n+    /**\n+     * Add value x\n+     *\n+     */\n+    void add(uint32_t x) {\n+        roarings[0].add(x);\n+        roarings[0].setCopyOnWrite(copyOnWrite);\n+    }\n+    void add(uint64_t x) {\n+        roarings[highBytes(x)].add(lowBytes(x));\n+        roarings[highBytes(x)].setCopyOnWrite(copyOnWrite);\n+    }\n+\n+    /**\n+     * Add value x\n+     * Returns true if a new value was added, false if the value was already existing.\n+     */\n+    bool addChecked(uint32_t x) {\n+        bool result = roarings[0].addChecked(x);\n+        roarings[0].setCopyOnWrite(copyOnWrite);\n+        return result;\n+    }\n+    bool addChecked(uint64_t x) {\n+        bool result = roarings[highBytes(x)].addChecked(lowBytes(x));\n+        roarings[highBytes(x)].setCopyOnWrite(copyOnWrite);\n+        return result;\n+    }\n+\n+    /**\n+     * Add value n_args from pointer vals\n+     *\n+     */\n+    void addMany(size_t n_args, const uint32_t* vals) {\n+        for (size_t lcv = 0; lcv < n_args; lcv++) {\n+            roarings[0].add(vals[lcv]);\n+            roarings[0].setCopyOnWrite(copyOnWrite);\n+        }\n+    }\n+    void addMany(size_t n_args, const uint64_t* vals) {\n+        for (size_t lcv = 0; lcv < n_args; lcv++) {\n+            roarings[highBytes(vals[lcv])].add(lowBytes(vals[lcv]));\n+            roarings[highBytes(vals[lcv])].setCopyOnWrite(copyOnWrite);\n+        }\n+    }\n+\n+    /**\n+     * Remove value x\n+     *\n+     */\n+    void remove(uint32_t x) { roarings[0].remove(x); }\n+    void remove(uint64_t x) {\n+        auto roaring_iter = roarings.find(highBytes(x));\n+        if (roaring_iter != roarings.cend()) roaring_iter->second.remove(lowBytes(x));\n+    }\n+\n+    /**\n+     * Remove value x\n+     * Returns true if a new value was removed, false if the value was not existing.\n+     */\n+    bool removeChecked(uint32_t x) { return roarings[0].removeChecked(x); }\n+    bool removeChecked(uint64_t x) {\n+        auto roaring_iter = roarings.find(highBytes(x));\n+        if (roaring_iter != roarings.cend()) return roaring_iter->second.removeChecked(lowBytes(x));\n+        return false;\n+    }\n+\n+    /**\n+     * Return the largest value (if not empty)\n+     *\n+     */\n+    uint64_t maximum() const {\n+        for (auto roaring_iter = roarings.crbegin(); roaring_iter != roarings.crend();\n+             ++roaring_iter) {\n+            if (!roaring_iter->second.isEmpty()) {\n+                return uniteBytes(roaring_iter->first, roaring_iter->second.maximum());\n+            }\n+        }\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        return (std::numeric_limits<uint64_t>::min)();\n+    }\n+\n+    /**\n+     * Return the smallest value (if not empty)\n+     *\n+     */\n+    uint64_t minimum() const {\n+        for (auto roaring_iter = roarings.cbegin(); roaring_iter != roarings.cend();\n+             ++roaring_iter) {\n+            if (!roaring_iter->second.isEmpty()) {\n+                return uniteBytes(roaring_iter->first, roaring_iter->second.minimum());\n+            }\n+        }\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        return (std::numeric_limits<uint64_t>::max)();\n+    }\n+\n+    /**\n+     * Check if value x is present\n+     */\n+    bool contains(uint32_t x) const {\n+        return roarings.count(0) == 0 ? false : roarings.at(0).contains(x);\n+    }\n+    bool contains(uint64_t x) const {\n+        return roarings.count(highBytes(x)) == 0 ? false\n+                                                 : roarings.at(highBytes(x)).contains(lowBytes(x));\n+    }\n+\n+    /**\n+     * Compute the intersection between the current bitmap and the provided\n+     * bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     */\n+    Roaring64Map& operator&=(const Roaring64Map& r) {\n+        for (auto& map_entry : roarings) {\n+            if (r.roarings.count(map_entry.first) == 1)\n+                map_entry.second &= r.roarings.at(map_entry.first);\n+            else\n+                map_entry.second = Roaring();\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Compute the difference between the current bitmap and the provided\n+     * bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     */\n+    Roaring64Map& operator-=(const Roaring64Map& r) {\n+        for (auto& map_entry : roarings) {\n+            if (r.roarings.count(map_entry.first) == 1)\n+                map_entry.second -= r.roarings.at(map_entry.first);\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Compute the union between the current bitmap and the provided bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     *\n+     * See also the fastunion function to aggregate many bitmaps more quickly.\n+     */\n+    Roaring64Map& operator|=(const Roaring64Map& r) {\n+        for (const auto& map_entry : r.roarings) {\n+            if (roarings.count(map_entry.first) == 0) {\n+                roarings[map_entry.first] = map_entry.second;\n+                roarings[map_entry.first].setCopyOnWrite(copyOnWrite);\n+            } else\n+                roarings[map_entry.first] |= map_entry.second;\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Compute the symmetric union between the current bitmap and the provided\n+     * bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     */\n+    Roaring64Map& operator^=(const Roaring64Map& r) {\n+        for (const auto& map_entry : r.roarings) {\n+            if (roarings.count(map_entry.first) == 0) {\n+                roarings[map_entry.first] = map_entry.second;\n+                roarings[map_entry.first].setCopyOnWrite(copyOnWrite);\n+            } else\n+                roarings[map_entry.first] ^= map_entry.second;\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Exchange the content of this bitmap with another.\n+     */\n+    void swap(Roaring64Map& r) { roarings.swap(r.roarings); }\n+\n+    /**\n+     * Get the cardinality of the bitmap (number of elements).\n+     * Throws std::length_error in the special case where the bitmap is full\n+     * (cardinality() == 2^64). Check isFull() before calling to avoid\n+     * exception.\n+     */\n+    uint64_t cardinality() const {\n+        if (isFull()) {\n+            throw std::length_error(\n+                    \"bitmap is full, cardinality is 2^64, \"\n+                    \"unable to represent in a 64-bit integer\");\n+        }\n+        return std::accumulate(\n+                roarings.cbegin(), roarings.cend(), (uint64_t)0,\n+                [](uint64_t previous, const std::pair<uint32_t, Roaring>& map_entry) {\n+                    return previous + map_entry.second.cardinality();\n+                });\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is empty (cardinality is zero).\n+    */\n+    bool isEmpty() const {\n+        return std::all_of(roarings.cbegin(), roarings.cend(),\n+                           [](const std::pair<uint32_t, Roaring>& map_entry) {\n+                               return map_entry.second.isEmpty();\n+                           });\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is full (cardinality is max uint64_t + 1).\n+    */\n+    bool isFull() const {\n+        // only bother to check if map is fully saturated\n+        //\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        return roarings.size() == ((size_t)(std::numeric_limits<uint32_t>::max)()) + 1\n+                       ? std::all_of(roarings.cbegin(), roarings.cend(),\n+                                     [](const std::pair<uint32_t, Roaring>& roaring_map_entry) {\n+                                         // roarings within map are saturated if cardinality\n+                                         // is uint32_t max + 1\n+                                         return roaring_map_entry.second.cardinality() ==\n+                                                ((uint64_t)(std::numeric_limits<uint32_t>::max)()) +\n+                                                        1;\n+                                     })\n+                       : false;\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is subset of the other.\n+    */\n+    bool isSubset(const Roaring64Map& r) const {\n+        for (const auto& map_entry : roarings) {\n+            auto roaring_iter = r.roarings.find(map_entry.first);\n+            if (roaring_iter == roarings.cend())\n+                return false;\n+            else if (!map_entry.second.isSubset(roaring_iter->second))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is strict subset of the other.\n+    * Throws std::length_error in the special case where the bitmap is full\n+    * (cardinality() == 2^64). Check isFull() before calling to avoid exception.\n+    */\n+    bool isStrictSubset(const Roaring64Map& r) const {\n+        return isSubset(r) && cardinality() != r.cardinality();\n+    }\n+\n+    /**\n+     * Convert the bitmap to an array. Write the output to \"ans\",\n+     * caller is responsible to ensure that there is enough memory\n+     * allocated\n+     * (e.g., ans = new uint32[mybitmap.cardinality()];)\n+     */\n+    void toUint64Array(uint64_t* ans) const {\n+        // Annoyingly, VS 2017 marks std::accumulate() as [[nodiscard]]\n+        (void)std::accumulate(\n+                roarings.cbegin(), roarings.cend(), ans,\n+                [](uint64_t* previous, const std::pair<uint32_t, Roaring>& map_entry) {\n+                    for (uint32_t low_bits : map_entry.second)\n+                        *previous++ = uniteBytes(map_entry.first, low_bits);\n+                    return previous;\n+                });\n+    }\n+\n+    /**\n+     * Return true if the two bitmaps contain the same elements.\n+     */\n+    bool operator==(const Roaring64Map& r) const {\n+        // we cannot use operator == on the map because either side may contain\n+        // empty Roaring Bitmaps\n+        auto lhs_iter = roarings.cbegin();\n+        auto rhs_iter = r.roarings.cbegin();\n+        do {\n+            // if the left map has reached its end, ensure that the right map\n+            // contains only empty Bitmaps\n+            if (lhs_iter == roarings.cend()) {\n+                while (rhs_iter != r.roarings.cend()) {\n+                    if (rhs_iter->second.isEmpty()) {\n+                        ++rhs_iter;\n+                        continue;\n+                    }\n+                    return false;\n+                }\n+                return true;\n+            }\n+            // if the left map has an empty bitmap, skip it\n+            if (lhs_iter->second.isEmpty()) {\n+                ++lhs_iter;\n+                continue;\n+            }\n+\n+            do {\n+                // if the right map has reached its end, ensure that the right\n+                // map contains only empty Bitmaps\n+                if (rhs_iter == r.roarings.cend()) {\n+                    while (lhs_iter != roarings.cend()) {\n+                        if (lhs_iter->second.isEmpty()) {\n+                            ++lhs_iter;\n+                            continue;\n+                        }\n+                        return false;\n+                    }\n+                    return true;\n+                }\n+                // if the right map has an empty bitmap, skip it\n+                if (rhs_iter->second.isEmpty()) {\n+                    ++rhs_iter;\n+                    continue;\n+                }\n+            } while (false);\n+            // if neither map has reached its end ensure elements are equal and\n+            // move to the next element in both\n+        } while (lhs_iter++->second == rhs_iter++->second);\n+        return false;\n+    }\n+\n+    /**\n+     * compute the negation of the roaring bitmap within a specified interval.\n+     * areas outside the range are passed through unchanged.\n+     */\n+    void flip(uint64_t range_start, uint64_t range_end) {\n+        uint32_t start_high = highBytes(range_start);\n+        uint32_t start_low = lowBytes(range_start);\n+        uint32_t end_high = highBytes(range_end);\n+        uint32_t end_low = lowBytes(range_end);\n+\n+        if (start_high == end_high) {\n+            roarings[start_high].flip(start_low, end_low);\n+            return;\n+        }\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        roarings[start_high].flip(start_low, (std::numeric_limits<uint32_t>::max)());\n+        roarings[start_high++].setCopyOnWrite(copyOnWrite);\n+\n+        for (; start_high <= highBytes(range_end) - 1; ++start_high) {\n+            roarings[start_high].flip((std::numeric_limits<uint32_t>::min)(),\n+                                      (std::numeric_limits<uint32_t>::max)());\n+            roarings[start_high].setCopyOnWrite(copyOnWrite);\n+        }\n+\n+        roarings[start_high].flip((std::numeric_limits<uint32_t>::min)(), end_low);\n+        roarings[start_high].setCopyOnWrite(copyOnWrite);\n+    }\n+\n+    /**\n+     *  Remove run-length encoding even when it is more space efficient\n+     *  return whether a change was applied\n+     */\n+    bool removeRunCompression() {\n+        return std::accumulate(roarings.begin(), roarings.end(), false,\n+                               [](bool previous, std::pair<const uint32_t, Roaring>& map_entry) {\n+                                   return map_entry.second.removeRunCompression() && previous;\n+                               });\n+    }\n+\n+    /** convert array and bitmap containers to run containers when it is more\n+     * efficient;\n+     * also convert from run containers when more space efficient.  Returns\n+     * true if the result has at least one run container.\n+     * Additional savings might be possible by calling shrinkToFit().\n+     */\n+    bool runOptimize() {\n+        return std::accumulate(roarings.begin(), roarings.end(), false,\n+                               [](bool previous, std::pair<const uint32_t, Roaring>& map_entry) {\n+                                   return map_entry.second.runOptimize() && previous;\n+                               });\n+    }\n+\n+    /**\n+     * If needed, reallocate memory to shrink the memory usage. Returns\n+     * the number of bytes saved.\n+    */\n+    size_t shrinkToFit() {\n+        size_t savedBytes = 0;\n+        auto iter = roarings.begin();\n+        while (iter != roarings.cend()) {\n+            if (iter->second.isEmpty()) {\n+                // empty Roarings are 84 bytes\n+                savedBytes += 88;\n+                roarings.erase(iter++);\n+            } else {\n+                savedBytes += iter->second.shrinkToFit();\n+                iter++;\n+            }\n+        }\n+        return savedBytes;\n+    }\n+\n+    /**\n+     * Iterate over the bitmap elements. The function iterator is called once\n+     * for all the values with ptr (can be NULL) as the second parameter of each\n+     * call.\n+     *\n+     * roaring_iterator is simply a pointer to a function that returns bool\n+     * (true means that the iteration should continue while false means that it\n+     * should stop), and takes (uint32_t,void*) as inputs.\n+     */\n+    void iterate(roaring_iterator64 iterator, void* ptr) const {\n+        std::for_each(roarings.begin(), roarings.cend(),\n+                      [=](const std::pair<uint32_t, Roaring>& map_entry) {\n+                          roaring_iterate64(&map_entry.second.roaring, iterator,\n+                                            uint64_t(map_entry.first) << 32, ptr);\n+                      });\n+    }\n+\n+    /**\n+     * If the size of the roaring bitmap is strictly greater than rank, then\n+     this\n+       function returns true and set element to the element of given rank.\n+       Otherwise, it returns false.\n+     */\n+    bool select(uint64_t rnk, uint64_t* element) const {\n+        for (const auto& map_entry : roarings) {\n+            uint64_t sub_cardinality = (uint64_t)map_entry.second.cardinality();\n+            if (rnk < sub_cardinality) {\n+                *element = ((uint64_t)map_entry.first) << 32;\n+                // assuming little endian\n+                return map_entry.second.select((uint32_t)rnk, ((uint32_t*)element));\n+            }\n+            rnk -= sub_cardinality;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+    * Returns the number of integers that are smaller or equal to x.\n+    */\n+    uint64_t rank(uint64_t x) const {\n+        uint64_t result = 0;\n+        auto roaring_destination = roarings.find(highBytes(x));\n+        if (roaring_destination != roarings.cend()) {\n+            for (auto roaring_iter = roarings.cbegin(); roaring_iter != roaring_destination;\n+                 ++roaring_iter) {\n+                result += roaring_iter->second.cardinality();\n+            }\n+            result += roaring_destination->second.rank(lowBytes(x));\n+            return result;\n+        }\n+        roaring_destination = roarings.lower_bound(highBytes(x));\n+        for (auto roaring_iter = roarings.cbegin(); roaring_iter != roaring_destination;\n+             ++roaring_iter) {\n+            result += roaring_iter->second.cardinality();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * write a bitmap to a char buffer.\n+     * Returns how many bytes were written which should be getSizeInBytes().\n+     */\n+    size_t write(char* buf) const {\n+        if (is32BitsEnough()) {\n+            *(buf++) = BitmapTypeCode::type::BITMAP32;\n+            auto it = roarings.find(0);\n+            if (it == roarings.end()) { // empty bitmap\n+                Roaring r;\n+                return r.write(buf) + 1;\n+            }\n+            return it->second.write(buf) + 1;\n+        }\n+\n+        const char* orig = buf;\n+        // put type code\n+        *(buf++) = BitmapTypeCode::type::BITMAP64;\n+        // push map size\n+        buf = (char*)encode_varint64((uint8_t*)buf, roarings.size());\n+        std::for_each(roarings.cbegin(), roarings.cend(),\n+                      [&buf](const std::pair<uint32_t, Roaring>& map_entry) {\n+                          // push map key\n+                          encode_fixed32_le((uint8_t*)buf, map_entry.first);\n+                          buf += sizeof(uint32_t);\n+                          // push map value Roaring\n+                          buf += map_entry.second.write(buf);\n+                      });\n+        return buf - orig;\n+    }\n+\n+    /**\n+     * read a bitmap from a serialized version.\n+     *\n+     * This function is unsafe in the sense that if you provide bad data,\n+     * many bytes could be read, possibly causing a buffer overflow. See also readSafe.\n+     */\n+    static Roaring64Map read(const char* buf) {\n+        Roaring64Map result;\n+\n+        if (*buf == BitmapTypeCode::BITMAP32) {\n+            Roaring read = Roaring::read(buf + 1);\n+            result.emplaceOrInsert(0, read);\n+            return result;\n+        }\n+\n+        DCHECK_EQ(BitmapTypeCode::BITMAP64, *buf);\n+        buf++;\n+\n+        // get map size (varint64 took 1~10 bytes)\n+        uint64_t map_size;\n+        buf = reinterpret_cast<const char*>(\n+                decode_varint64_ptr(reinterpret_cast<const uint8_t*>(buf),\n+                                    reinterpret_cast<const uint8_t*>(buf + 10), &map_size));\n+        DCHECK(buf != nullptr);\n+        for (uint64_t lcv = 0; lcv < map_size; lcv++) {\n+            // get map key\n+            uint32_t key = decode_fixed32_le(reinterpret_cast<const uint8_t*>(buf));\n+            buf += sizeof(uint32_t);\n+            // read map value Roaring\n+            Roaring read = Roaring::read(buf);\n+            result.emplaceOrInsert(key, read);\n+            // forward buffer past the last Roaring Bitmap\n+            buf += read.getSizeInBytes();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * How many bytes are required to serialize this bitmap\n+     */\n+    size_t getSizeInBytes() const {\n+        if (is32BitsEnough()) {\n+            auto it = roarings.find(0);\n+            if (it == roarings.end()) { // empty bitmap\n+                Roaring r;\n+                return r.getSizeInBytes() + 1;\n+            }\n+            return it->second.getSizeInBytes() + 1;\n+        }\n+        // start with type code, map size and size of keys for each map entry\n+        size_t init = 1 + varint_length(roarings.size()) + roarings.size() * sizeof(uint32_t);\n+        return std::accumulate(roarings.cbegin(), roarings.cend(), init,\n+                               [=](size_t previous, const std::pair<uint32_t, Roaring>& map_entry) {\n+                                   // add in bytes used by each Roaring\n+                                   return previous + map_entry.second.getSizeInBytes();\n+                               });\n+    }\n+\n+    /**\n+     * remove all elements\n+     */\n+    void clear() { roarings.clear(); }\n+\n+    /**\n+     * Return whether all elements can be represented in 32 bits\n+     */\n+    bool is32BitsEnough() const { return maximum() <= std::numeric_limits<uint32_t>::max(); }\n+\n+    /**\n+     * Computes the intersection between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator&(const Roaring64Map& o) const { return Roaring64Map(*this) &= o; }\n+\n+    /**\n+     * Computes the difference between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator-(const Roaring64Map& o) const { return Roaring64Map(*this) -= o; }\n+\n+    /**\n+     * Computes the union between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator|(const Roaring64Map& o) const { return Roaring64Map(*this) |= o; }\n+\n+    /**\n+     * Computes the symmetric union between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator^(const Roaring64Map& o) const { return Roaring64Map(*this) ^= o; }\n+\n+    /**\n+     * Whether or not we apply copy and write.\n+     */\n+    void setCopyOnWrite(bool val) {\n+        if (copyOnWrite == val) return;\n+        copyOnWrite = val;\n+        std::for_each(roarings.begin(), roarings.end(),\n+                      [=](std::pair<const uint32_t, Roaring>& map_entry) {\n+                          map_entry.second.setCopyOnWrite(val);\n+                      });\n+    }\n+\n+    /**\n+     * Print the content of the bitmap\n+     */\n+    void printf() const {\n+        if (!isEmpty()) {\n+            auto map_iter = roarings.cbegin();\n+            while (map_iter->second.isEmpty()) ++map_iter;\n+            struct iter_data {\n+                uint32_t high_bits;\n+                char first_char = '{';\n+            } outer_iter_data;\n+            outer_iter_data.high_bits = roarings.begin()->first;\n+            map_iter->second.iterate(\n+                    [](uint32_t low_bits, void* inner_iter_data) -> bool {\n+                        std::printf(\"%c%llu\", ((iter_data*)inner_iter_data)->first_char,\n+                                    (long long unsigned)uniteBytes(\n+                                            ((iter_data*)inner_iter_data)->high_bits, low_bits));\n+                        ((iter_data*)inner_iter_data)->first_char = ',';\n+                        return true;\n+                    },\n+                    (void*)&outer_iter_data);\n+            std::for_each(\n+                    ++map_iter, roarings.cend(), [](const std::pair<uint32_t, Roaring>& map_entry) {\n+                        map_entry.second.iterate(\n+                                [](uint32_t low_bits, void* high_bits) -> bool {\n+                                    std::printf(\",%llu\", (long long unsigned)uniteBytes(\n+                                                                 *(uint32_t*)high_bits, low_bits));\n+                                    return true;\n+                                },\n+                                (void*)&map_entry.first);\n+                    });\n+        } else\n+            std::printf(\"{\");\n+        std::printf(\"}\\n\");\n+    }\n+\n+    /**\n+     * Print the content of the bitmap into a string\n+     */\n+    std::string toString() const {\n+        struct iter_data {\n+            std::string str;\n+            uint32_t high_bits;\n+            char first_char = '{';\n+        } outer_iter_data;\n+        if (!isEmpty()) {\n+            auto map_iter = roarings.cbegin();\n+            while (map_iter->second.isEmpty()) ++map_iter;\n+            outer_iter_data.high_bits = roarings.begin()->first;\n+            map_iter->second.iterate(\n+                    [](uint32_t low_bits, void* inner_iter_data) -> bool {\n+                        ((iter_data*)inner_iter_data)->str +=\n+                                ((iter_data*)inner_iter_data)->first_char;\n+                        ((iter_data*)inner_iter_data)->str += std::to_string(\n+                                uniteBytes(((iter_data*)inner_iter_data)->high_bits, low_bits));\n+                        ((iter_data*)inner_iter_data)->first_char = ',';\n+                        return true;\n+                    },\n+                    (void*)&outer_iter_data);\n+            std::for_each(\n+                    ++map_iter, roarings.cend(),\n+                    [&outer_iter_data](const std::pair<uint32_t, Roaring>& map_entry) {\n+                        outer_iter_data.high_bits = map_entry.first;\n+                        map_entry.second.iterate(\n+                                [](uint32_t low_bits, void* inner_iter_data) -> bool {\n+                                    ((iter_data*)inner_iter_data)->str +=\n+                                            ((iter_data*)inner_iter_data)->first_char;\n+                                    ((iter_data*)inner_iter_data)->str += std::to_string(uniteBytes(\n+                                            ((iter_data*)inner_iter_data)->high_bits, low_bits));\n+                                    return true;\n+                                },\n+                                (void*)&outer_iter_data);\n+                    });\n+        } else\n+            outer_iter_data.str = '{';\n+        outer_iter_data.str += '}';\n+        return outer_iter_data.str;\n+    }\n+\n+    /**\n+     * Whether or not copy and write is active.\n+     */\n+    bool getCopyOnWrite() const { return copyOnWrite; }\n+\n+    /**\n+     * computes the logical or (union) between \"n\" bitmaps (referenced by a\n+     * pointer).\n+     */\n+    static Roaring64Map fastunion(size_t n, const Roaring64Map** inputs) {\n+        Roaring64Map ans;\n+        // not particularly fast\n+        for (size_t lcv = 0; lcv < n; ++lcv) {\n+            ans |= *(inputs[lcv]);\n+        }\n+        return ans;\n+    }\n+\n+    friend class Roaring64MapSetBitForwardIterator;\n+    typedef Roaring64MapSetBitForwardIterator const_iterator;\n+\n+    /**\n+    * Returns an iterator that can be used to access the position of the\n+    * set bits. The running time complexity of a full scan is proportional to\n+    * the\n+    * number\n+    * of set bits: be aware that if you have long strings of 1s, this can be\n+    * very inefficient.\n+    *\n+    * It can be much faster to use the toArray method if you want to\n+    * retrieve the set bits.\n+    */\n+    const_iterator begin() const;\n+\n+    /**\n+    * A bogus iterator that can be used together with begin()\n+    * for constructions such as for(auto i = b.begin();\n+    * i!=b.end(); ++i) {}\n+    */\n+    const_iterator end() const;\n+\n+private:\n+    std::map<uint32_t, Roaring> roarings;\n+    bool copyOnWrite = false;\n+    static uint32_t highBytes(const uint64_t in) { return uint32_t(in >> 32); }\n+    static uint32_t lowBytes(const uint64_t in) { return uint32_t(in); }\n+    static uint64_t uniteBytes(const uint32_t highBytes, const uint32_t lowBytes) {\n+        return (uint64_t(highBytes) << 32) | uint64_t(lowBytes);\n+    }\n+    // this is needed to tolerate gcc's C++11 libstdc++ lacking emplace\n+    // prior to version 4.8\n+    void emplaceOrInsert(const uint32_t key, const Roaring& value) {\n+#if defined(__GLIBCXX__) && __GLIBCXX__ < 20130322\n+        roarings.insert(std::make_pair(key, value));\n+#else\n+        roarings.emplace(std::make_pair(key, value));\n+#endif\n+    }\n+};\n+\n+// Forked from https://github.com/RoaringBitmap/CRoaring/blob/v0.2.60/cpp/roaring64map.hh\n+// Used to go through the set bits. Not optimally fast, but convenient.\n+class Roaring64MapSetBitForwardIterator final {\n+public:\n+    typedef std::forward_iterator_tag iterator_category;\n+    typedef uint64_t* pointer;\n+    typedef uint64_t& reference_type;\n+    typedef uint64_t value_type;\n+    typedef int64_t difference_type;\n+    typedef Roaring64MapSetBitForwardIterator type_of_iterator;\n+\n+    /**\n+     * Provides the location of the set bit.\n+     */\n+    value_type operator*() const {\n+        return Roaring64Map::uniteBytes(map_iter->first, i.current_value);\n+    }\n+\n+    bool operator<(const type_of_iterator& o) {\n+        if (map_iter == map_end) return false;\n+        if (o.map_iter == o.map_end) return true;\n+        return **this < *o;\n+    }\n+\n+    bool operator<=(const type_of_iterator& o) {\n+        if (o.map_iter == o.map_end) return true;\n+        if (map_iter == map_end) return false;\n+        return **this <= *o;\n+    }\n+\n+    bool operator>(const type_of_iterator& o) {\n+        if (o.map_iter == o.map_end) return false;\n+        if (map_iter == map_end) return true;\n+        return **this > *o;\n+    }\n+\n+    bool operator>=(const type_of_iterator& o) {\n+        if (map_iter == map_end) return true;\n+        if (o.map_iter == o.map_end) return false;\n+        return **this >= *o;\n+    }\n+\n+    type_of_iterator& operator++() { // ++i, must returned inc. value\n+        if (i.has_value == true) roaring_advance_uint32_iterator(&i);\n+        while (!i.has_value) {\n+            map_iter++;\n+            if (map_iter == map_end) return *this;\n+            roaring_init_iterator(&map_iter->second.roaring, &i);\n+        }\n+        return *this;\n+    }\n+\n+    type_of_iterator operator++(int) { // i++, must return orig. value\n+        Roaring64MapSetBitForwardIterator orig(*this);\n+        roaring_advance_uint32_iterator(&i);\n+        while (!i.has_value) {\n+            map_iter++;\n+            if (map_iter == map_end) return orig;\n+            roaring_init_iterator(&map_iter->second.roaring, &i);\n+        }\n+        return orig;\n+    }\n+\n+    bool operator==(const Roaring64MapSetBitForwardIterator& o) {\n+        if (map_iter == map_end && o.map_iter == o.map_end) return true;\n+        if (o.map_iter == o.map_end) return false;\n+        return **this == *o;\n+    }\n+\n+    bool operator!=(const Roaring64MapSetBitForwardIterator& o) {\n+        if (map_iter == map_end && o.map_iter == o.map_end) return false;\n+        if (o.map_iter == o.map_end) return true;\n+        return **this != *o;\n+    }\n+\n+    Roaring64MapSetBitForwardIterator(const Roaring64Map& parent, bool exhausted = false)\n+            : map_end(parent.roarings.cend()) {\n+        if (exhausted || parent.roarings.empty()) {\n+            map_iter = parent.roarings.cend();\n+        } else {\n+            map_iter = parent.roarings.cbegin();\n+            roaring_init_iterator(&map_iter->second.roaring, &i);\n+            while (!i.has_value) {\n+                map_iter++;\n+                if (map_iter == map_end) return;\n+                roaring_init_iterator(&map_iter->second.roaring, &i);\n+            }\n+        }\n+    }\n+\n+private:\n+    std::map<uint32_t, Roaring>::const_iterator map_iter;\n+    std::map<uint32_t, Roaring>::const_iterator map_end;\n+    roaring_uint32_iterator_t i;\n+};\n+\n+inline Roaring64MapSetBitForwardIterator Roaring64Map::begin() const {\n+    return Roaring64MapSetBitForwardIterator(*this);\n+}\n+\n+inline Roaring64MapSetBitForwardIterator Roaring64Map::end() const {\n+    return Roaring64MapSetBitForwardIterator(*this, true);\n+}\n+\n+// Represent the in-memory and on-disk structure of Doris's BITMAP data type.\n+// Optimize for the case where the bitmap contains 0 or 1 element which is common\n+// for streaming load scenario.\n+class BitmapValue {\n+public:\n+    // Construct an empty bitmap.\n+    BitmapValue() : _type(EMPTY) {}\n+\n+    // Construct a bitmap with one element.\n+    explicit BitmapValue(uint64_t value) : _sv(value), _type(SINGLE) {}\n+\n+    // Construct a bitmap from serialized data.\n+    explicit BitmapValue(const char* src) {\n+        bool res = deserialize(src);\n+        DCHECK(res);\n+    }\n+\n+    // Construct a bitmap from given elements.\n+    explicit BitmapValue(const std::vector<uint64_t>& bits) {\n+        switch (bits.size()) {\n+            case 0:\n+                _type = EMPTY;\n+                break;\n+            case 1:\n+                _type = SINGLE;\n+                _sv = bits[0];\n+                break;\n+            default:\n+                _type = BITMAP;\n+                _bitmap.addMany(bits.size(), &bits[0]);\n+        }\n+    }\n+\n+    void add(uint64_t value) {\n+        switch (_type) {\n+            case EMPTY:\n+                _sv = value;\n+                _type = SINGLE;\n+                break;\n+            case SINGLE:\n+                _bitmap.add(_sv);\n+                _bitmap.add(value);\n+                _type = BITMAP;\n+                break;\n+            case BITMAP:\n+                _bitmap.add(value);\n+        }\n+    }\n+\n+    // Compute the union between the current bitmap and the provided bitmap.\n+    // Possible type transitions are:\n+    // EMPTY  -> SINGLE\n+    // EMPTY  -> BITMAP\n+    // SINGLE -> BITMAP\n+    BitmapValue& operator|=(const BitmapValue& rhs) {\n+        switch (rhs._type) {\n+            case EMPTY:\n+                break;\n+            case SINGLE:\n+                add(rhs._sv);\n+                break;\n+            case BITMAP:\n+                switch (_type) {\n+                    case EMPTY:\n+                        _bitmap = rhs._bitmap;\n+                        _type = BITMAP;\n+                        break;\n+                    case SINGLE:\n+                        _bitmap = rhs._bitmap;\n+                        _bitmap.add(_sv);\n+                        _type = BITMAP;\n+                        break;\n+                    case BITMAP:\n+                        _bitmap |= rhs._bitmap;\n+                }\n+                break;\n+        }\n+        return *this;\n+    }\n+\n+    // Compute the intersection between the current bitmap and the provided bitmap.\n+    // Possible type transitions are:\n+    // SINGLE -> EMPTY\n+    // BITMAP -> EMPTY\n+    // BITMAP -> SINGLE\n+    BitmapValue& operator&=(const BitmapValue& rhs) {\n+        switch (rhs._type) {\n+            case EMPTY:\n+                _type = EMPTY;\n+                _bitmap.clear();\n+                break;\n+            case SINGLE:\n+                switch (_type) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE:\n+                        if (_sv != rhs._sv) {\n+                            _type = EMPTY;\n+                        }\n+                        break;\n+                    case BITMAP:\n+                        if (!_bitmap.contains(rhs._sv)) {\n+                            _type = EMPTY;\n+                        } else {\n+                            _type = SINGLE;\n+                            _sv = rhs._sv;\n+                        }\n+                        _bitmap.clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP:\n+                switch (_type) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE:\n+                        if (!rhs._bitmap.contains(_sv)) {\n+                            _type = EMPTY;\n+                        }\n+                        break;\n+                    case BITMAP:\n+                        _bitmap &= rhs._bitmap;\n+                        _convert_to_smaller_type();\n+                        break;\n+                }\n+                break;\n+        }\n+        return *this;\n+    }\n+\n+    // check if value x is present\n+    bool contains(uint64_t x) {\n+        switch (_type) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE:\n+                return _sv == x;\n+            case BITMAP:\n+                return _bitmap.contains(x);\n+        }\n+        return false;\n+    }\n+\n+    // TODO should the return type be uint64_t?\n+    int64_t cardinality() const {\n+        switch (_type) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE:\n+                return 1;\n+            case BITMAP:\n+                return _bitmap.cardinality();\n+        }\n+        return 0;\n+    }\n+\n+    // Return how many bytes are required to serialize this bitmap.\n+    // See BitmapTypeCode for the serialized format.\n+    size_t getSizeInBytes() {\n+        size_t res = 0;\n+        switch (_type) {\n+            case EMPTY:\n+                res = 1;\n+                break;\n+            case SINGLE:\n+                if (_sv <= std::numeric_limits<uint32_t>::max()) {\n+                    res = 1 + sizeof(uint32_t);\n+                } else {\n+                    res = 1 + sizeof(uint64_t);\n+                }\n+                break;\n+            case BITMAP:\n+                DCHECK(_bitmap.cardinality() > 1);\n+                _bitmap.runOptimize();\n+                _bitmap.shrinkToFit();\n+                res = _bitmap.getSizeInBytes();\n+                break;\n+        }\n+        return res;\n+    }\n+\n+    // Serialize the bitmap value to dst, which should be large enough.\n+    // Client should call `getSizeInBytes` first to get the serialized size.\n+    void write(char* dst) {\n+        switch (_type) {\n+            case EMPTY:\n+                *dst = BitmapTypeCode::EMPTY;\n+                break;\n+            case SINGLE:\n+                if (_sv <= std::numeric_limits<uint32_t>::max()) {\n+                    *(dst++) = BitmapTypeCode::SINGLE32;\n+                    encode_fixed32_le(reinterpret_cast<uint8_t*>(dst), static_cast<uint32_t>(_sv));\n+                } else {\n+                    *(dst++) = BitmapTypeCode::SINGLE64;\n+                    encode_fixed64_le(reinterpret_cast<uint8_t*>(dst), _sv);\n+                }\n+                break;\n+            case BITMAP:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397b523d565688a4dae0066db4bbcbd3c620f45c"}, "originalPosition": 1149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyOTI4Mw==", "bodyText": "For BITMAP32 and BITMAP64, the type code is both read and write in Roaring64Map. For EMPTY/SINGLE32/SINGLE64, it can't be implemented in Roaring64Map because the purpose of single value optimization is to bypass the RoaringBitmap logic. I think the coupling is OK because Roaring64Map is indeed implementation details of BitmapValue, all clients only see BitmapValue and should never operate on Roaring64Map directly. Maybe I should put Roaring64Map into detail namespace to enforce that?", "url": "https://github.com/apache/incubator-doris/pull/2772#discussion_r367729283", "createdAt": "2020-01-17T01:18:57Z", "author": {"login": "gaodayue"}, "path": "be/src/util/bitmap_value.h", "diffHunk": "@@ -0,0 +1,1243 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_UTIL_BITMAP_VALUE_H\n+#define DORIS_BE_SRC_UTIL_BITMAP_VALUE_H\n+\n+#include <algorithm>\n+#include <cstdarg>\n+#include <cstdio>\n+#include <limits>\n+#include <map>\n+#include <new>\n+#include <numeric>\n+#include <roaring/roaring.hh>\n+#include <stdexcept>\n+#include <string>\n+#include <utility>\n+\n+#include \"common/logging.h\"\n+#include \"util/coding.h\"\n+\n+namespace doris {\n+\n+class Roaring64MapSetBitForwardIterator;\n+\n+// serialized bitmap := TypeCode(1), Payload\n+// The format of payload depends on value of TypeCode which is defined below\n+struct BitmapTypeCode {\n+    enum type {\n+        // An empty bitmap. Payload is 0 byte.\n+        // added in 0.11\n+        EMPTY = 0,\n+        // A bitmap containing only one element that is in [0, UINT32_MAX]\n+        // Payload := UInt32LittleEndian(4 byte)\n+        // added in 0.11\n+        SINGLE32 = 1,\n+        // A bitmap whose maximum element is in [0, UINT32_MAX]\n+        // Payload := the standard RoaringBitmap format described by\n+        // https://github.com/RoaringBitmap/RoaringFormatSpec/\n+        // added in 0.11\n+        BITMAP32 = 2,\n+        // A bitmap containing only one element that is in (UINT32_MAX, UINT64_MAX]\n+        // Payload := UInt64LittleEndian(8 byte)\n+        // added in 0.12\n+        SINGLE64 = 3,\n+        // A bitmap whose maximum element is in (UINT32_MAX, UINT64_MAX].\n+        //\n+        // To support 64-bits elements, all elements with the same high 32 bits are stored in a\n+        // RoaringBitmap containing only the lower 32 bits. Thus we could use\n+        // map<uint32_t, RoaringBitmap> to represent bitmap of 64-bits ints.\n+        //\n+        // Since there is no standard format for 64-bits RoaringBitmap, we define our own as below\n+        // Payload := NumRoaring(vint64), { MapKey, MapValue }^NumRoaring\n+        // - MapKey := the shared high 32 bits in UInt32LittleEndian(4 byte)\n+        // - MapValue := the standard RoaringBitmap format\n+        //\n+        // added in 0.12\n+        BITMAP64 = 4\n+    };\n+};\n+\n+// Forked from https://github.com/RoaringBitmap/CRoaring/blob/v0.2.60/cpp/roaring64map.hh\n+// What we change includes\n+// - a custom serialization format is used inside read()/write()/getSizeInBytes()\n+// - added clear() and is32BitsEnough()\n+class Roaring64Map {\n+public:\n+    /**\n+     * Create an empty bitmap\n+     */\n+    Roaring64Map() = default;\n+\n+    /**\n+     * Construct a bitmap from a list of 32-bit integer values.\n+     */\n+    Roaring64Map(size_t n, const uint32_t* data) { addMany(n, data); }\n+\n+    /**\n+     * Construct a bitmap from a list of 64-bit integer values.\n+     */\n+    Roaring64Map(size_t n, const uint64_t* data) { addMany(n, data); }\n+\n+    /**\n+     * Construct a 64-bit map from a 32-bit one\n+     */\n+    Roaring64Map(const Roaring& r) { emplaceOrInsert(0, r); }\n+\n+    /**\n+     * Construct a roaring object from the C struct.\n+     *\n+     * Passing a NULL point is unsafe.\n+     */\n+    Roaring64Map(roaring_bitmap_t* s) { emplaceOrInsert(0, s); }\n+\n+    /**\n+     * Construct a bitmap from a list of integer values.\n+     */\n+    static Roaring64Map bitmapOf(size_t n...) {\n+        Roaring64Map ans;\n+        va_list vl;\n+        va_start(vl, n);\n+        for (size_t i = 0; i < n; i++) {\n+            ans.add(va_arg(vl, uint64_t));\n+        }\n+        va_end(vl);\n+        return ans;\n+    }\n+\n+    /**\n+     * Add value x\n+     *\n+     */\n+    void add(uint32_t x) {\n+        roarings[0].add(x);\n+        roarings[0].setCopyOnWrite(copyOnWrite);\n+    }\n+    void add(uint64_t x) {\n+        roarings[highBytes(x)].add(lowBytes(x));\n+        roarings[highBytes(x)].setCopyOnWrite(copyOnWrite);\n+    }\n+\n+    /**\n+     * Add value x\n+     * Returns true if a new value was added, false if the value was already existing.\n+     */\n+    bool addChecked(uint32_t x) {\n+        bool result = roarings[0].addChecked(x);\n+        roarings[0].setCopyOnWrite(copyOnWrite);\n+        return result;\n+    }\n+    bool addChecked(uint64_t x) {\n+        bool result = roarings[highBytes(x)].addChecked(lowBytes(x));\n+        roarings[highBytes(x)].setCopyOnWrite(copyOnWrite);\n+        return result;\n+    }\n+\n+    /**\n+     * Add value n_args from pointer vals\n+     *\n+     */\n+    void addMany(size_t n_args, const uint32_t* vals) {\n+        for (size_t lcv = 0; lcv < n_args; lcv++) {\n+            roarings[0].add(vals[lcv]);\n+            roarings[0].setCopyOnWrite(copyOnWrite);\n+        }\n+    }\n+    void addMany(size_t n_args, const uint64_t* vals) {\n+        for (size_t lcv = 0; lcv < n_args; lcv++) {\n+            roarings[highBytes(vals[lcv])].add(lowBytes(vals[lcv]));\n+            roarings[highBytes(vals[lcv])].setCopyOnWrite(copyOnWrite);\n+        }\n+    }\n+\n+    /**\n+     * Remove value x\n+     *\n+     */\n+    void remove(uint32_t x) { roarings[0].remove(x); }\n+    void remove(uint64_t x) {\n+        auto roaring_iter = roarings.find(highBytes(x));\n+        if (roaring_iter != roarings.cend()) roaring_iter->second.remove(lowBytes(x));\n+    }\n+\n+    /**\n+     * Remove value x\n+     * Returns true if a new value was removed, false if the value was not existing.\n+     */\n+    bool removeChecked(uint32_t x) { return roarings[0].removeChecked(x); }\n+    bool removeChecked(uint64_t x) {\n+        auto roaring_iter = roarings.find(highBytes(x));\n+        if (roaring_iter != roarings.cend()) return roaring_iter->second.removeChecked(lowBytes(x));\n+        return false;\n+    }\n+\n+    /**\n+     * Return the largest value (if not empty)\n+     *\n+     */\n+    uint64_t maximum() const {\n+        for (auto roaring_iter = roarings.crbegin(); roaring_iter != roarings.crend();\n+             ++roaring_iter) {\n+            if (!roaring_iter->second.isEmpty()) {\n+                return uniteBytes(roaring_iter->first, roaring_iter->second.maximum());\n+            }\n+        }\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        return (std::numeric_limits<uint64_t>::min)();\n+    }\n+\n+    /**\n+     * Return the smallest value (if not empty)\n+     *\n+     */\n+    uint64_t minimum() const {\n+        for (auto roaring_iter = roarings.cbegin(); roaring_iter != roarings.cend();\n+             ++roaring_iter) {\n+            if (!roaring_iter->second.isEmpty()) {\n+                return uniteBytes(roaring_iter->first, roaring_iter->second.minimum());\n+            }\n+        }\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        return (std::numeric_limits<uint64_t>::max)();\n+    }\n+\n+    /**\n+     * Check if value x is present\n+     */\n+    bool contains(uint32_t x) const {\n+        return roarings.count(0) == 0 ? false : roarings.at(0).contains(x);\n+    }\n+    bool contains(uint64_t x) const {\n+        return roarings.count(highBytes(x)) == 0 ? false\n+                                                 : roarings.at(highBytes(x)).contains(lowBytes(x));\n+    }\n+\n+    /**\n+     * Compute the intersection between the current bitmap and the provided\n+     * bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     */\n+    Roaring64Map& operator&=(const Roaring64Map& r) {\n+        for (auto& map_entry : roarings) {\n+            if (r.roarings.count(map_entry.first) == 1)\n+                map_entry.second &= r.roarings.at(map_entry.first);\n+            else\n+                map_entry.second = Roaring();\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Compute the difference between the current bitmap and the provided\n+     * bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     */\n+    Roaring64Map& operator-=(const Roaring64Map& r) {\n+        for (auto& map_entry : roarings) {\n+            if (r.roarings.count(map_entry.first) == 1)\n+                map_entry.second -= r.roarings.at(map_entry.first);\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Compute the union between the current bitmap and the provided bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     *\n+     * See also the fastunion function to aggregate many bitmaps more quickly.\n+     */\n+    Roaring64Map& operator|=(const Roaring64Map& r) {\n+        for (const auto& map_entry : r.roarings) {\n+            if (roarings.count(map_entry.first) == 0) {\n+                roarings[map_entry.first] = map_entry.second;\n+                roarings[map_entry.first].setCopyOnWrite(copyOnWrite);\n+            } else\n+                roarings[map_entry.first] |= map_entry.second;\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Compute the symmetric union between the current bitmap and the provided\n+     * bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     */\n+    Roaring64Map& operator^=(const Roaring64Map& r) {\n+        for (const auto& map_entry : r.roarings) {\n+            if (roarings.count(map_entry.first) == 0) {\n+                roarings[map_entry.first] = map_entry.second;\n+                roarings[map_entry.first].setCopyOnWrite(copyOnWrite);\n+            } else\n+                roarings[map_entry.first] ^= map_entry.second;\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Exchange the content of this bitmap with another.\n+     */\n+    void swap(Roaring64Map& r) { roarings.swap(r.roarings); }\n+\n+    /**\n+     * Get the cardinality of the bitmap (number of elements).\n+     * Throws std::length_error in the special case where the bitmap is full\n+     * (cardinality() == 2^64). Check isFull() before calling to avoid\n+     * exception.\n+     */\n+    uint64_t cardinality() const {\n+        if (isFull()) {\n+            throw std::length_error(\n+                    \"bitmap is full, cardinality is 2^64, \"\n+                    \"unable to represent in a 64-bit integer\");\n+        }\n+        return std::accumulate(\n+                roarings.cbegin(), roarings.cend(), (uint64_t)0,\n+                [](uint64_t previous, const std::pair<uint32_t, Roaring>& map_entry) {\n+                    return previous + map_entry.second.cardinality();\n+                });\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is empty (cardinality is zero).\n+    */\n+    bool isEmpty() const {\n+        return std::all_of(roarings.cbegin(), roarings.cend(),\n+                           [](const std::pair<uint32_t, Roaring>& map_entry) {\n+                               return map_entry.second.isEmpty();\n+                           });\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is full (cardinality is max uint64_t + 1).\n+    */\n+    bool isFull() const {\n+        // only bother to check if map is fully saturated\n+        //\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        return roarings.size() == ((size_t)(std::numeric_limits<uint32_t>::max)()) + 1\n+                       ? std::all_of(roarings.cbegin(), roarings.cend(),\n+                                     [](const std::pair<uint32_t, Roaring>& roaring_map_entry) {\n+                                         // roarings within map are saturated if cardinality\n+                                         // is uint32_t max + 1\n+                                         return roaring_map_entry.second.cardinality() ==\n+                                                ((uint64_t)(std::numeric_limits<uint32_t>::max)()) +\n+                                                        1;\n+                                     })\n+                       : false;\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is subset of the other.\n+    */\n+    bool isSubset(const Roaring64Map& r) const {\n+        for (const auto& map_entry : roarings) {\n+            auto roaring_iter = r.roarings.find(map_entry.first);\n+            if (roaring_iter == roarings.cend())\n+                return false;\n+            else if (!map_entry.second.isSubset(roaring_iter->second))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is strict subset of the other.\n+    * Throws std::length_error in the special case where the bitmap is full\n+    * (cardinality() == 2^64). Check isFull() before calling to avoid exception.\n+    */\n+    bool isStrictSubset(const Roaring64Map& r) const {\n+        return isSubset(r) && cardinality() != r.cardinality();\n+    }\n+\n+    /**\n+     * Convert the bitmap to an array. Write the output to \"ans\",\n+     * caller is responsible to ensure that there is enough memory\n+     * allocated\n+     * (e.g., ans = new uint32[mybitmap.cardinality()];)\n+     */\n+    void toUint64Array(uint64_t* ans) const {\n+        // Annoyingly, VS 2017 marks std::accumulate() as [[nodiscard]]\n+        (void)std::accumulate(\n+                roarings.cbegin(), roarings.cend(), ans,\n+                [](uint64_t* previous, const std::pair<uint32_t, Roaring>& map_entry) {\n+                    for (uint32_t low_bits : map_entry.second)\n+                        *previous++ = uniteBytes(map_entry.first, low_bits);\n+                    return previous;\n+                });\n+    }\n+\n+    /**\n+     * Return true if the two bitmaps contain the same elements.\n+     */\n+    bool operator==(const Roaring64Map& r) const {\n+        // we cannot use operator == on the map because either side may contain\n+        // empty Roaring Bitmaps\n+        auto lhs_iter = roarings.cbegin();\n+        auto rhs_iter = r.roarings.cbegin();\n+        do {\n+            // if the left map has reached its end, ensure that the right map\n+            // contains only empty Bitmaps\n+            if (lhs_iter == roarings.cend()) {\n+                while (rhs_iter != r.roarings.cend()) {\n+                    if (rhs_iter->second.isEmpty()) {\n+                        ++rhs_iter;\n+                        continue;\n+                    }\n+                    return false;\n+                }\n+                return true;\n+            }\n+            // if the left map has an empty bitmap, skip it\n+            if (lhs_iter->second.isEmpty()) {\n+                ++lhs_iter;\n+                continue;\n+            }\n+\n+            do {\n+                // if the right map has reached its end, ensure that the right\n+                // map contains only empty Bitmaps\n+                if (rhs_iter == r.roarings.cend()) {\n+                    while (lhs_iter != roarings.cend()) {\n+                        if (lhs_iter->second.isEmpty()) {\n+                            ++lhs_iter;\n+                            continue;\n+                        }\n+                        return false;\n+                    }\n+                    return true;\n+                }\n+                // if the right map has an empty bitmap, skip it\n+                if (rhs_iter->second.isEmpty()) {\n+                    ++rhs_iter;\n+                    continue;\n+                }\n+            } while (false);\n+            // if neither map has reached its end ensure elements are equal and\n+            // move to the next element in both\n+        } while (lhs_iter++->second == rhs_iter++->second);\n+        return false;\n+    }\n+\n+    /**\n+     * compute the negation of the roaring bitmap within a specified interval.\n+     * areas outside the range are passed through unchanged.\n+     */\n+    void flip(uint64_t range_start, uint64_t range_end) {\n+        uint32_t start_high = highBytes(range_start);\n+        uint32_t start_low = lowBytes(range_start);\n+        uint32_t end_high = highBytes(range_end);\n+        uint32_t end_low = lowBytes(range_end);\n+\n+        if (start_high == end_high) {\n+            roarings[start_high].flip(start_low, end_low);\n+            return;\n+        }\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        roarings[start_high].flip(start_low, (std::numeric_limits<uint32_t>::max)());\n+        roarings[start_high++].setCopyOnWrite(copyOnWrite);\n+\n+        for (; start_high <= highBytes(range_end) - 1; ++start_high) {\n+            roarings[start_high].flip((std::numeric_limits<uint32_t>::min)(),\n+                                      (std::numeric_limits<uint32_t>::max)());\n+            roarings[start_high].setCopyOnWrite(copyOnWrite);\n+        }\n+\n+        roarings[start_high].flip((std::numeric_limits<uint32_t>::min)(), end_low);\n+        roarings[start_high].setCopyOnWrite(copyOnWrite);\n+    }\n+\n+    /**\n+     *  Remove run-length encoding even when it is more space efficient\n+     *  return whether a change was applied\n+     */\n+    bool removeRunCompression() {\n+        return std::accumulate(roarings.begin(), roarings.end(), false,\n+                               [](bool previous, std::pair<const uint32_t, Roaring>& map_entry) {\n+                                   return map_entry.second.removeRunCompression() && previous;\n+                               });\n+    }\n+\n+    /** convert array and bitmap containers to run containers when it is more\n+     * efficient;\n+     * also convert from run containers when more space efficient.  Returns\n+     * true if the result has at least one run container.\n+     * Additional savings might be possible by calling shrinkToFit().\n+     */\n+    bool runOptimize() {\n+        return std::accumulate(roarings.begin(), roarings.end(), false,\n+                               [](bool previous, std::pair<const uint32_t, Roaring>& map_entry) {\n+                                   return map_entry.second.runOptimize() && previous;\n+                               });\n+    }\n+\n+    /**\n+     * If needed, reallocate memory to shrink the memory usage. Returns\n+     * the number of bytes saved.\n+    */\n+    size_t shrinkToFit() {\n+        size_t savedBytes = 0;\n+        auto iter = roarings.begin();\n+        while (iter != roarings.cend()) {\n+            if (iter->second.isEmpty()) {\n+                // empty Roarings are 84 bytes\n+                savedBytes += 88;\n+                roarings.erase(iter++);\n+            } else {\n+                savedBytes += iter->second.shrinkToFit();\n+                iter++;\n+            }\n+        }\n+        return savedBytes;\n+    }\n+\n+    /**\n+     * Iterate over the bitmap elements. The function iterator is called once\n+     * for all the values with ptr (can be NULL) as the second parameter of each\n+     * call.\n+     *\n+     * roaring_iterator is simply a pointer to a function that returns bool\n+     * (true means that the iteration should continue while false means that it\n+     * should stop), and takes (uint32_t,void*) as inputs.\n+     */\n+    void iterate(roaring_iterator64 iterator, void* ptr) const {\n+        std::for_each(roarings.begin(), roarings.cend(),\n+                      [=](const std::pair<uint32_t, Roaring>& map_entry) {\n+                          roaring_iterate64(&map_entry.second.roaring, iterator,\n+                                            uint64_t(map_entry.first) << 32, ptr);\n+                      });\n+    }\n+\n+    /**\n+     * If the size of the roaring bitmap is strictly greater than rank, then\n+     this\n+       function returns true and set element to the element of given rank.\n+       Otherwise, it returns false.\n+     */\n+    bool select(uint64_t rnk, uint64_t* element) const {\n+        for (const auto& map_entry : roarings) {\n+            uint64_t sub_cardinality = (uint64_t)map_entry.second.cardinality();\n+            if (rnk < sub_cardinality) {\n+                *element = ((uint64_t)map_entry.first) << 32;\n+                // assuming little endian\n+                return map_entry.second.select((uint32_t)rnk, ((uint32_t*)element));\n+            }\n+            rnk -= sub_cardinality;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+    * Returns the number of integers that are smaller or equal to x.\n+    */\n+    uint64_t rank(uint64_t x) const {\n+        uint64_t result = 0;\n+        auto roaring_destination = roarings.find(highBytes(x));\n+        if (roaring_destination != roarings.cend()) {\n+            for (auto roaring_iter = roarings.cbegin(); roaring_iter != roaring_destination;\n+                 ++roaring_iter) {\n+                result += roaring_iter->second.cardinality();\n+            }\n+            result += roaring_destination->second.rank(lowBytes(x));\n+            return result;\n+        }\n+        roaring_destination = roarings.lower_bound(highBytes(x));\n+        for (auto roaring_iter = roarings.cbegin(); roaring_iter != roaring_destination;\n+             ++roaring_iter) {\n+            result += roaring_iter->second.cardinality();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * write a bitmap to a char buffer.\n+     * Returns how many bytes were written which should be getSizeInBytes().\n+     */\n+    size_t write(char* buf) const {\n+        if (is32BitsEnough()) {\n+            *(buf++) = BitmapTypeCode::type::BITMAP32;\n+            auto it = roarings.find(0);\n+            if (it == roarings.end()) { // empty bitmap\n+                Roaring r;\n+                return r.write(buf) + 1;\n+            }\n+            return it->second.write(buf) + 1;\n+        }\n+\n+        const char* orig = buf;\n+        // put type code\n+        *(buf++) = BitmapTypeCode::type::BITMAP64;\n+        // push map size\n+        buf = (char*)encode_varint64((uint8_t*)buf, roarings.size());\n+        std::for_each(roarings.cbegin(), roarings.cend(),\n+                      [&buf](const std::pair<uint32_t, Roaring>& map_entry) {\n+                          // push map key\n+                          encode_fixed32_le((uint8_t*)buf, map_entry.first);\n+                          buf += sizeof(uint32_t);\n+                          // push map value Roaring\n+                          buf += map_entry.second.write(buf);\n+                      });\n+        return buf - orig;\n+    }\n+\n+    /**\n+     * read a bitmap from a serialized version.\n+     *\n+     * This function is unsafe in the sense that if you provide bad data,\n+     * many bytes could be read, possibly causing a buffer overflow. See also readSafe.\n+     */\n+    static Roaring64Map read(const char* buf) {\n+        Roaring64Map result;\n+\n+        if (*buf == BitmapTypeCode::BITMAP32) {\n+            Roaring read = Roaring::read(buf + 1);\n+            result.emplaceOrInsert(0, read);\n+            return result;\n+        }\n+\n+        DCHECK_EQ(BitmapTypeCode::BITMAP64, *buf);\n+        buf++;\n+\n+        // get map size (varint64 took 1~10 bytes)\n+        uint64_t map_size;\n+        buf = reinterpret_cast<const char*>(\n+                decode_varint64_ptr(reinterpret_cast<const uint8_t*>(buf),\n+                                    reinterpret_cast<const uint8_t*>(buf + 10), &map_size));\n+        DCHECK(buf != nullptr);\n+        for (uint64_t lcv = 0; lcv < map_size; lcv++) {\n+            // get map key\n+            uint32_t key = decode_fixed32_le(reinterpret_cast<const uint8_t*>(buf));\n+            buf += sizeof(uint32_t);\n+            // read map value Roaring\n+            Roaring read = Roaring::read(buf);\n+            result.emplaceOrInsert(key, read);\n+            // forward buffer past the last Roaring Bitmap\n+            buf += read.getSizeInBytes();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * How many bytes are required to serialize this bitmap\n+     */\n+    size_t getSizeInBytes() const {\n+        if (is32BitsEnough()) {\n+            auto it = roarings.find(0);\n+            if (it == roarings.end()) { // empty bitmap\n+                Roaring r;\n+                return r.getSizeInBytes() + 1;\n+            }\n+            return it->second.getSizeInBytes() + 1;\n+        }\n+        // start with type code, map size and size of keys for each map entry\n+        size_t init = 1 + varint_length(roarings.size()) + roarings.size() * sizeof(uint32_t);\n+        return std::accumulate(roarings.cbegin(), roarings.cend(), init,\n+                               [=](size_t previous, const std::pair<uint32_t, Roaring>& map_entry) {\n+                                   // add in bytes used by each Roaring\n+                                   return previous + map_entry.second.getSizeInBytes();\n+                               });\n+    }\n+\n+    /**\n+     * remove all elements\n+     */\n+    void clear() { roarings.clear(); }\n+\n+    /**\n+     * Return whether all elements can be represented in 32 bits\n+     */\n+    bool is32BitsEnough() const { return maximum() <= std::numeric_limits<uint32_t>::max(); }\n+\n+    /**\n+     * Computes the intersection between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator&(const Roaring64Map& o) const { return Roaring64Map(*this) &= o; }\n+\n+    /**\n+     * Computes the difference between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator-(const Roaring64Map& o) const { return Roaring64Map(*this) -= o; }\n+\n+    /**\n+     * Computes the union between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator|(const Roaring64Map& o) const { return Roaring64Map(*this) |= o; }\n+\n+    /**\n+     * Computes the symmetric union between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator^(const Roaring64Map& o) const { return Roaring64Map(*this) ^= o; }\n+\n+    /**\n+     * Whether or not we apply copy and write.\n+     */\n+    void setCopyOnWrite(bool val) {\n+        if (copyOnWrite == val) return;\n+        copyOnWrite = val;\n+        std::for_each(roarings.begin(), roarings.end(),\n+                      [=](std::pair<const uint32_t, Roaring>& map_entry) {\n+                          map_entry.second.setCopyOnWrite(val);\n+                      });\n+    }\n+\n+    /**\n+     * Print the content of the bitmap\n+     */\n+    void printf() const {\n+        if (!isEmpty()) {\n+            auto map_iter = roarings.cbegin();\n+            while (map_iter->second.isEmpty()) ++map_iter;\n+            struct iter_data {\n+                uint32_t high_bits;\n+                char first_char = '{';\n+            } outer_iter_data;\n+            outer_iter_data.high_bits = roarings.begin()->first;\n+            map_iter->second.iterate(\n+                    [](uint32_t low_bits, void* inner_iter_data) -> bool {\n+                        std::printf(\"%c%llu\", ((iter_data*)inner_iter_data)->first_char,\n+                                    (long long unsigned)uniteBytes(\n+                                            ((iter_data*)inner_iter_data)->high_bits, low_bits));\n+                        ((iter_data*)inner_iter_data)->first_char = ',';\n+                        return true;\n+                    },\n+                    (void*)&outer_iter_data);\n+            std::for_each(\n+                    ++map_iter, roarings.cend(), [](const std::pair<uint32_t, Roaring>& map_entry) {\n+                        map_entry.second.iterate(\n+                                [](uint32_t low_bits, void* high_bits) -> bool {\n+                                    std::printf(\",%llu\", (long long unsigned)uniteBytes(\n+                                                                 *(uint32_t*)high_bits, low_bits));\n+                                    return true;\n+                                },\n+                                (void*)&map_entry.first);\n+                    });\n+        } else\n+            std::printf(\"{\");\n+        std::printf(\"}\\n\");\n+    }\n+\n+    /**\n+     * Print the content of the bitmap into a string\n+     */\n+    std::string toString() const {\n+        struct iter_data {\n+            std::string str;\n+            uint32_t high_bits;\n+            char first_char = '{';\n+        } outer_iter_data;\n+        if (!isEmpty()) {\n+            auto map_iter = roarings.cbegin();\n+            while (map_iter->second.isEmpty()) ++map_iter;\n+            outer_iter_data.high_bits = roarings.begin()->first;\n+            map_iter->second.iterate(\n+                    [](uint32_t low_bits, void* inner_iter_data) -> bool {\n+                        ((iter_data*)inner_iter_data)->str +=\n+                                ((iter_data*)inner_iter_data)->first_char;\n+                        ((iter_data*)inner_iter_data)->str += std::to_string(\n+                                uniteBytes(((iter_data*)inner_iter_data)->high_bits, low_bits));\n+                        ((iter_data*)inner_iter_data)->first_char = ',';\n+                        return true;\n+                    },\n+                    (void*)&outer_iter_data);\n+            std::for_each(\n+                    ++map_iter, roarings.cend(),\n+                    [&outer_iter_data](const std::pair<uint32_t, Roaring>& map_entry) {\n+                        outer_iter_data.high_bits = map_entry.first;\n+                        map_entry.second.iterate(\n+                                [](uint32_t low_bits, void* inner_iter_data) -> bool {\n+                                    ((iter_data*)inner_iter_data)->str +=\n+                                            ((iter_data*)inner_iter_data)->first_char;\n+                                    ((iter_data*)inner_iter_data)->str += std::to_string(uniteBytes(\n+                                            ((iter_data*)inner_iter_data)->high_bits, low_bits));\n+                                    return true;\n+                                },\n+                                (void*)&outer_iter_data);\n+                    });\n+        } else\n+            outer_iter_data.str = '{';\n+        outer_iter_data.str += '}';\n+        return outer_iter_data.str;\n+    }\n+\n+    /**\n+     * Whether or not copy and write is active.\n+     */\n+    bool getCopyOnWrite() const { return copyOnWrite; }\n+\n+    /**\n+     * computes the logical or (union) between \"n\" bitmaps (referenced by a\n+     * pointer).\n+     */\n+    static Roaring64Map fastunion(size_t n, const Roaring64Map** inputs) {\n+        Roaring64Map ans;\n+        // not particularly fast\n+        for (size_t lcv = 0; lcv < n; ++lcv) {\n+            ans |= *(inputs[lcv]);\n+        }\n+        return ans;\n+    }\n+\n+    friend class Roaring64MapSetBitForwardIterator;\n+    typedef Roaring64MapSetBitForwardIterator const_iterator;\n+\n+    /**\n+    * Returns an iterator that can be used to access the position of the\n+    * set bits. The running time complexity of a full scan is proportional to\n+    * the\n+    * number\n+    * of set bits: be aware that if you have long strings of 1s, this can be\n+    * very inefficient.\n+    *\n+    * It can be much faster to use the toArray method if you want to\n+    * retrieve the set bits.\n+    */\n+    const_iterator begin() const;\n+\n+    /**\n+    * A bogus iterator that can be used together with begin()\n+    * for constructions such as for(auto i = b.begin();\n+    * i!=b.end(); ++i) {}\n+    */\n+    const_iterator end() const;\n+\n+private:\n+    std::map<uint32_t, Roaring> roarings;\n+    bool copyOnWrite = false;\n+    static uint32_t highBytes(const uint64_t in) { return uint32_t(in >> 32); }\n+    static uint32_t lowBytes(const uint64_t in) { return uint32_t(in); }\n+    static uint64_t uniteBytes(const uint32_t highBytes, const uint32_t lowBytes) {\n+        return (uint64_t(highBytes) << 32) | uint64_t(lowBytes);\n+    }\n+    // this is needed to tolerate gcc's C++11 libstdc++ lacking emplace\n+    // prior to version 4.8\n+    void emplaceOrInsert(const uint32_t key, const Roaring& value) {\n+#if defined(__GLIBCXX__) && __GLIBCXX__ < 20130322\n+        roarings.insert(std::make_pair(key, value));\n+#else\n+        roarings.emplace(std::make_pair(key, value));\n+#endif\n+    }\n+};\n+\n+// Forked from https://github.com/RoaringBitmap/CRoaring/blob/v0.2.60/cpp/roaring64map.hh\n+// Used to go through the set bits. Not optimally fast, but convenient.\n+class Roaring64MapSetBitForwardIterator final {\n+public:\n+    typedef std::forward_iterator_tag iterator_category;\n+    typedef uint64_t* pointer;\n+    typedef uint64_t& reference_type;\n+    typedef uint64_t value_type;\n+    typedef int64_t difference_type;\n+    typedef Roaring64MapSetBitForwardIterator type_of_iterator;\n+\n+    /**\n+     * Provides the location of the set bit.\n+     */\n+    value_type operator*() const {\n+        return Roaring64Map::uniteBytes(map_iter->first, i.current_value);\n+    }\n+\n+    bool operator<(const type_of_iterator& o) {\n+        if (map_iter == map_end) return false;\n+        if (o.map_iter == o.map_end) return true;\n+        return **this < *o;\n+    }\n+\n+    bool operator<=(const type_of_iterator& o) {\n+        if (o.map_iter == o.map_end) return true;\n+        if (map_iter == map_end) return false;\n+        return **this <= *o;\n+    }\n+\n+    bool operator>(const type_of_iterator& o) {\n+        if (o.map_iter == o.map_end) return false;\n+        if (map_iter == map_end) return true;\n+        return **this > *o;\n+    }\n+\n+    bool operator>=(const type_of_iterator& o) {\n+        if (map_iter == map_end) return true;\n+        if (o.map_iter == o.map_end) return false;\n+        return **this >= *o;\n+    }\n+\n+    type_of_iterator& operator++() { // ++i, must returned inc. value\n+        if (i.has_value == true) roaring_advance_uint32_iterator(&i);\n+        while (!i.has_value) {\n+            map_iter++;\n+            if (map_iter == map_end) return *this;\n+            roaring_init_iterator(&map_iter->second.roaring, &i);\n+        }\n+        return *this;\n+    }\n+\n+    type_of_iterator operator++(int) { // i++, must return orig. value\n+        Roaring64MapSetBitForwardIterator orig(*this);\n+        roaring_advance_uint32_iterator(&i);\n+        while (!i.has_value) {\n+            map_iter++;\n+            if (map_iter == map_end) return orig;\n+            roaring_init_iterator(&map_iter->second.roaring, &i);\n+        }\n+        return orig;\n+    }\n+\n+    bool operator==(const Roaring64MapSetBitForwardIterator& o) {\n+        if (map_iter == map_end && o.map_iter == o.map_end) return true;\n+        if (o.map_iter == o.map_end) return false;\n+        return **this == *o;\n+    }\n+\n+    bool operator!=(const Roaring64MapSetBitForwardIterator& o) {\n+        if (map_iter == map_end && o.map_iter == o.map_end) return false;\n+        if (o.map_iter == o.map_end) return true;\n+        return **this != *o;\n+    }\n+\n+    Roaring64MapSetBitForwardIterator(const Roaring64Map& parent, bool exhausted = false)\n+            : map_end(parent.roarings.cend()) {\n+        if (exhausted || parent.roarings.empty()) {\n+            map_iter = parent.roarings.cend();\n+        } else {\n+            map_iter = parent.roarings.cbegin();\n+            roaring_init_iterator(&map_iter->second.roaring, &i);\n+            while (!i.has_value) {\n+                map_iter++;\n+                if (map_iter == map_end) return;\n+                roaring_init_iterator(&map_iter->second.roaring, &i);\n+            }\n+        }\n+    }\n+\n+private:\n+    std::map<uint32_t, Roaring>::const_iterator map_iter;\n+    std::map<uint32_t, Roaring>::const_iterator map_end;\n+    roaring_uint32_iterator_t i;\n+};\n+\n+inline Roaring64MapSetBitForwardIterator Roaring64Map::begin() const {\n+    return Roaring64MapSetBitForwardIterator(*this);\n+}\n+\n+inline Roaring64MapSetBitForwardIterator Roaring64Map::end() const {\n+    return Roaring64MapSetBitForwardIterator(*this, true);\n+}\n+\n+// Represent the in-memory and on-disk structure of Doris's BITMAP data type.\n+// Optimize for the case where the bitmap contains 0 or 1 element which is common\n+// for streaming load scenario.\n+class BitmapValue {\n+public:\n+    // Construct an empty bitmap.\n+    BitmapValue() : _type(EMPTY) {}\n+\n+    // Construct a bitmap with one element.\n+    explicit BitmapValue(uint64_t value) : _sv(value), _type(SINGLE) {}\n+\n+    // Construct a bitmap from serialized data.\n+    explicit BitmapValue(const char* src) {\n+        bool res = deserialize(src);\n+        DCHECK(res);\n+    }\n+\n+    // Construct a bitmap from given elements.\n+    explicit BitmapValue(const std::vector<uint64_t>& bits) {\n+        switch (bits.size()) {\n+            case 0:\n+                _type = EMPTY;\n+                break;\n+            case 1:\n+                _type = SINGLE;\n+                _sv = bits[0];\n+                break;\n+            default:\n+                _type = BITMAP;\n+                _bitmap.addMany(bits.size(), &bits[0]);\n+        }\n+    }\n+\n+    void add(uint64_t value) {\n+        switch (_type) {\n+            case EMPTY:\n+                _sv = value;\n+                _type = SINGLE;\n+                break;\n+            case SINGLE:\n+                _bitmap.add(_sv);\n+                _bitmap.add(value);\n+                _type = BITMAP;\n+                break;\n+            case BITMAP:\n+                _bitmap.add(value);\n+        }\n+    }\n+\n+    // Compute the union between the current bitmap and the provided bitmap.\n+    // Possible type transitions are:\n+    // EMPTY  -> SINGLE\n+    // EMPTY  -> BITMAP\n+    // SINGLE -> BITMAP\n+    BitmapValue& operator|=(const BitmapValue& rhs) {\n+        switch (rhs._type) {\n+            case EMPTY:\n+                break;\n+            case SINGLE:\n+                add(rhs._sv);\n+                break;\n+            case BITMAP:\n+                switch (_type) {\n+                    case EMPTY:\n+                        _bitmap = rhs._bitmap;\n+                        _type = BITMAP;\n+                        break;\n+                    case SINGLE:\n+                        _bitmap = rhs._bitmap;\n+                        _bitmap.add(_sv);\n+                        _type = BITMAP;\n+                        break;\n+                    case BITMAP:\n+                        _bitmap |= rhs._bitmap;\n+                }\n+                break;\n+        }\n+        return *this;\n+    }\n+\n+    // Compute the intersection between the current bitmap and the provided bitmap.\n+    // Possible type transitions are:\n+    // SINGLE -> EMPTY\n+    // BITMAP -> EMPTY\n+    // BITMAP -> SINGLE\n+    BitmapValue& operator&=(const BitmapValue& rhs) {\n+        switch (rhs._type) {\n+            case EMPTY:\n+                _type = EMPTY;\n+                _bitmap.clear();\n+                break;\n+            case SINGLE:\n+                switch (_type) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE:\n+                        if (_sv != rhs._sv) {\n+                            _type = EMPTY;\n+                        }\n+                        break;\n+                    case BITMAP:\n+                        if (!_bitmap.contains(rhs._sv)) {\n+                            _type = EMPTY;\n+                        } else {\n+                            _type = SINGLE;\n+                            _sv = rhs._sv;\n+                        }\n+                        _bitmap.clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP:\n+                switch (_type) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE:\n+                        if (!rhs._bitmap.contains(_sv)) {\n+                            _type = EMPTY;\n+                        }\n+                        break;\n+                    case BITMAP:\n+                        _bitmap &= rhs._bitmap;\n+                        _convert_to_smaller_type();\n+                        break;\n+                }\n+                break;\n+        }\n+        return *this;\n+    }\n+\n+    // check if value x is present\n+    bool contains(uint64_t x) {\n+        switch (_type) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE:\n+                return _sv == x;\n+            case BITMAP:\n+                return _bitmap.contains(x);\n+        }\n+        return false;\n+    }\n+\n+    // TODO should the return type be uint64_t?\n+    int64_t cardinality() const {\n+        switch (_type) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE:\n+                return 1;\n+            case BITMAP:\n+                return _bitmap.cardinality();\n+        }\n+        return 0;\n+    }\n+\n+    // Return how many bytes are required to serialize this bitmap.\n+    // See BitmapTypeCode for the serialized format.\n+    size_t getSizeInBytes() {\n+        size_t res = 0;\n+        switch (_type) {\n+            case EMPTY:\n+                res = 1;\n+                break;\n+            case SINGLE:\n+                if (_sv <= std::numeric_limits<uint32_t>::max()) {\n+                    res = 1 + sizeof(uint32_t);\n+                } else {\n+                    res = 1 + sizeof(uint64_t);\n+                }\n+                break;\n+            case BITMAP:\n+                DCHECK(_bitmap.cardinality() > 1);\n+                _bitmap.runOptimize();\n+                _bitmap.shrinkToFit();\n+                res = _bitmap.getSizeInBytes();\n+                break;\n+        }\n+        return res;\n+    }\n+\n+    // Serialize the bitmap value to dst, which should be large enough.\n+    // Client should call `getSizeInBytes` first to get the serialized size.\n+    void write(char* dst) {\n+        switch (_type) {\n+            case EMPTY:\n+                *dst = BitmapTypeCode::EMPTY;\n+                break;\n+            case SINGLE:\n+                if (_sv <= std::numeric_limits<uint32_t>::max()) {\n+                    *(dst++) = BitmapTypeCode::SINGLE32;\n+                    encode_fixed32_le(reinterpret_cast<uint8_t*>(dst), static_cast<uint32_t>(_sv));\n+                } else {\n+                    *(dst++) = BitmapTypeCode::SINGLE64;\n+                    encode_fixed64_le(reinterpret_cast<uint8_t*>(dst), _sv);\n+                }\n+                break;\n+            case BITMAP:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcxMTc3Mg=="}, "originalCommit": {"oid": "397b523d565688a4dae0066db4bbcbd3c620f45c"}, "originalPosition": 1149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzY3OA==", "bodyText": "I see that in deserialize method it checks the type code which Roaring64Map writes. If this is an inner class, this implementation is also OK. I have no problem about it.", "url": "https://github.com/apache/incubator-doris/pull/2772#discussion_r367733678", "createdAt": "2020-01-17T01:38:51Z", "author": {"login": "imay"}, "path": "be/src/util/bitmap_value.h", "diffHunk": "@@ -0,0 +1,1243 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_UTIL_BITMAP_VALUE_H\n+#define DORIS_BE_SRC_UTIL_BITMAP_VALUE_H\n+\n+#include <algorithm>\n+#include <cstdarg>\n+#include <cstdio>\n+#include <limits>\n+#include <map>\n+#include <new>\n+#include <numeric>\n+#include <roaring/roaring.hh>\n+#include <stdexcept>\n+#include <string>\n+#include <utility>\n+\n+#include \"common/logging.h\"\n+#include \"util/coding.h\"\n+\n+namespace doris {\n+\n+class Roaring64MapSetBitForwardIterator;\n+\n+// serialized bitmap := TypeCode(1), Payload\n+// The format of payload depends on value of TypeCode which is defined below\n+struct BitmapTypeCode {\n+    enum type {\n+        // An empty bitmap. Payload is 0 byte.\n+        // added in 0.11\n+        EMPTY = 0,\n+        // A bitmap containing only one element that is in [0, UINT32_MAX]\n+        // Payload := UInt32LittleEndian(4 byte)\n+        // added in 0.11\n+        SINGLE32 = 1,\n+        // A bitmap whose maximum element is in [0, UINT32_MAX]\n+        // Payload := the standard RoaringBitmap format described by\n+        // https://github.com/RoaringBitmap/RoaringFormatSpec/\n+        // added in 0.11\n+        BITMAP32 = 2,\n+        // A bitmap containing only one element that is in (UINT32_MAX, UINT64_MAX]\n+        // Payload := UInt64LittleEndian(8 byte)\n+        // added in 0.12\n+        SINGLE64 = 3,\n+        // A bitmap whose maximum element is in (UINT32_MAX, UINT64_MAX].\n+        //\n+        // To support 64-bits elements, all elements with the same high 32 bits are stored in a\n+        // RoaringBitmap containing only the lower 32 bits. Thus we could use\n+        // map<uint32_t, RoaringBitmap> to represent bitmap of 64-bits ints.\n+        //\n+        // Since there is no standard format for 64-bits RoaringBitmap, we define our own as below\n+        // Payload := NumRoaring(vint64), { MapKey, MapValue }^NumRoaring\n+        // - MapKey := the shared high 32 bits in UInt32LittleEndian(4 byte)\n+        // - MapValue := the standard RoaringBitmap format\n+        //\n+        // added in 0.12\n+        BITMAP64 = 4\n+    };\n+};\n+\n+// Forked from https://github.com/RoaringBitmap/CRoaring/blob/v0.2.60/cpp/roaring64map.hh\n+// What we change includes\n+// - a custom serialization format is used inside read()/write()/getSizeInBytes()\n+// - added clear() and is32BitsEnough()\n+class Roaring64Map {\n+public:\n+    /**\n+     * Create an empty bitmap\n+     */\n+    Roaring64Map() = default;\n+\n+    /**\n+     * Construct a bitmap from a list of 32-bit integer values.\n+     */\n+    Roaring64Map(size_t n, const uint32_t* data) { addMany(n, data); }\n+\n+    /**\n+     * Construct a bitmap from a list of 64-bit integer values.\n+     */\n+    Roaring64Map(size_t n, const uint64_t* data) { addMany(n, data); }\n+\n+    /**\n+     * Construct a 64-bit map from a 32-bit one\n+     */\n+    Roaring64Map(const Roaring& r) { emplaceOrInsert(0, r); }\n+\n+    /**\n+     * Construct a roaring object from the C struct.\n+     *\n+     * Passing a NULL point is unsafe.\n+     */\n+    Roaring64Map(roaring_bitmap_t* s) { emplaceOrInsert(0, s); }\n+\n+    /**\n+     * Construct a bitmap from a list of integer values.\n+     */\n+    static Roaring64Map bitmapOf(size_t n...) {\n+        Roaring64Map ans;\n+        va_list vl;\n+        va_start(vl, n);\n+        for (size_t i = 0; i < n; i++) {\n+            ans.add(va_arg(vl, uint64_t));\n+        }\n+        va_end(vl);\n+        return ans;\n+    }\n+\n+    /**\n+     * Add value x\n+     *\n+     */\n+    void add(uint32_t x) {\n+        roarings[0].add(x);\n+        roarings[0].setCopyOnWrite(copyOnWrite);\n+    }\n+    void add(uint64_t x) {\n+        roarings[highBytes(x)].add(lowBytes(x));\n+        roarings[highBytes(x)].setCopyOnWrite(copyOnWrite);\n+    }\n+\n+    /**\n+     * Add value x\n+     * Returns true if a new value was added, false if the value was already existing.\n+     */\n+    bool addChecked(uint32_t x) {\n+        bool result = roarings[0].addChecked(x);\n+        roarings[0].setCopyOnWrite(copyOnWrite);\n+        return result;\n+    }\n+    bool addChecked(uint64_t x) {\n+        bool result = roarings[highBytes(x)].addChecked(lowBytes(x));\n+        roarings[highBytes(x)].setCopyOnWrite(copyOnWrite);\n+        return result;\n+    }\n+\n+    /**\n+     * Add value n_args from pointer vals\n+     *\n+     */\n+    void addMany(size_t n_args, const uint32_t* vals) {\n+        for (size_t lcv = 0; lcv < n_args; lcv++) {\n+            roarings[0].add(vals[lcv]);\n+            roarings[0].setCopyOnWrite(copyOnWrite);\n+        }\n+    }\n+    void addMany(size_t n_args, const uint64_t* vals) {\n+        for (size_t lcv = 0; lcv < n_args; lcv++) {\n+            roarings[highBytes(vals[lcv])].add(lowBytes(vals[lcv]));\n+            roarings[highBytes(vals[lcv])].setCopyOnWrite(copyOnWrite);\n+        }\n+    }\n+\n+    /**\n+     * Remove value x\n+     *\n+     */\n+    void remove(uint32_t x) { roarings[0].remove(x); }\n+    void remove(uint64_t x) {\n+        auto roaring_iter = roarings.find(highBytes(x));\n+        if (roaring_iter != roarings.cend()) roaring_iter->second.remove(lowBytes(x));\n+    }\n+\n+    /**\n+     * Remove value x\n+     * Returns true if a new value was removed, false if the value was not existing.\n+     */\n+    bool removeChecked(uint32_t x) { return roarings[0].removeChecked(x); }\n+    bool removeChecked(uint64_t x) {\n+        auto roaring_iter = roarings.find(highBytes(x));\n+        if (roaring_iter != roarings.cend()) return roaring_iter->second.removeChecked(lowBytes(x));\n+        return false;\n+    }\n+\n+    /**\n+     * Return the largest value (if not empty)\n+     *\n+     */\n+    uint64_t maximum() const {\n+        for (auto roaring_iter = roarings.crbegin(); roaring_iter != roarings.crend();\n+             ++roaring_iter) {\n+            if (!roaring_iter->second.isEmpty()) {\n+                return uniteBytes(roaring_iter->first, roaring_iter->second.maximum());\n+            }\n+        }\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        return (std::numeric_limits<uint64_t>::min)();\n+    }\n+\n+    /**\n+     * Return the smallest value (if not empty)\n+     *\n+     */\n+    uint64_t minimum() const {\n+        for (auto roaring_iter = roarings.cbegin(); roaring_iter != roarings.cend();\n+             ++roaring_iter) {\n+            if (!roaring_iter->second.isEmpty()) {\n+                return uniteBytes(roaring_iter->first, roaring_iter->second.minimum());\n+            }\n+        }\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        return (std::numeric_limits<uint64_t>::max)();\n+    }\n+\n+    /**\n+     * Check if value x is present\n+     */\n+    bool contains(uint32_t x) const {\n+        return roarings.count(0) == 0 ? false : roarings.at(0).contains(x);\n+    }\n+    bool contains(uint64_t x) const {\n+        return roarings.count(highBytes(x)) == 0 ? false\n+                                                 : roarings.at(highBytes(x)).contains(lowBytes(x));\n+    }\n+\n+    /**\n+     * Compute the intersection between the current bitmap and the provided\n+     * bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     */\n+    Roaring64Map& operator&=(const Roaring64Map& r) {\n+        for (auto& map_entry : roarings) {\n+            if (r.roarings.count(map_entry.first) == 1)\n+                map_entry.second &= r.roarings.at(map_entry.first);\n+            else\n+                map_entry.second = Roaring();\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Compute the difference between the current bitmap and the provided\n+     * bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     */\n+    Roaring64Map& operator-=(const Roaring64Map& r) {\n+        for (auto& map_entry : roarings) {\n+            if (r.roarings.count(map_entry.first) == 1)\n+                map_entry.second -= r.roarings.at(map_entry.first);\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Compute the union between the current bitmap and the provided bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     *\n+     * See also the fastunion function to aggregate many bitmaps more quickly.\n+     */\n+    Roaring64Map& operator|=(const Roaring64Map& r) {\n+        for (const auto& map_entry : r.roarings) {\n+            if (roarings.count(map_entry.first) == 0) {\n+                roarings[map_entry.first] = map_entry.second;\n+                roarings[map_entry.first].setCopyOnWrite(copyOnWrite);\n+            } else\n+                roarings[map_entry.first] |= map_entry.second;\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Compute the symmetric union between the current bitmap and the provided\n+     * bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     */\n+    Roaring64Map& operator^=(const Roaring64Map& r) {\n+        for (const auto& map_entry : r.roarings) {\n+            if (roarings.count(map_entry.first) == 0) {\n+                roarings[map_entry.first] = map_entry.second;\n+                roarings[map_entry.first].setCopyOnWrite(copyOnWrite);\n+            } else\n+                roarings[map_entry.first] ^= map_entry.second;\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Exchange the content of this bitmap with another.\n+     */\n+    void swap(Roaring64Map& r) { roarings.swap(r.roarings); }\n+\n+    /**\n+     * Get the cardinality of the bitmap (number of elements).\n+     * Throws std::length_error in the special case where the bitmap is full\n+     * (cardinality() == 2^64). Check isFull() before calling to avoid\n+     * exception.\n+     */\n+    uint64_t cardinality() const {\n+        if (isFull()) {\n+            throw std::length_error(\n+                    \"bitmap is full, cardinality is 2^64, \"\n+                    \"unable to represent in a 64-bit integer\");\n+        }\n+        return std::accumulate(\n+                roarings.cbegin(), roarings.cend(), (uint64_t)0,\n+                [](uint64_t previous, const std::pair<uint32_t, Roaring>& map_entry) {\n+                    return previous + map_entry.second.cardinality();\n+                });\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is empty (cardinality is zero).\n+    */\n+    bool isEmpty() const {\n+        return std::all_of(roarings.cbegin(), roarings.cend(),\n+                           [](const std::pair<uint32_t, Roaring>& map_entry) {\n+                               return map_entry.second.isEmpty();\n+                           });\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is full (cardinality is max uint64_t + 1).\n+    */\n+    bool isFull() const {\n+        // only bother to check if map is fully saturated\n+        //\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        return roarings.size() == ((size_t)(std::numeric_limits<uint32_t>::max)()) + 1\n+                       ? std::all_of(roarings.cbegin(), roarings.cend(),\n+                                     [](const std::pair<uint32_t, Roaring>& roaring_map_entry) {\n+                                         // roarings within map are saturated if cardinality\n+                                         // is uint32_t max + 1\n+                                         return roaring_map_entry.second.cardinality() ==\n+                                                ((uint64_t)(std::numeric_limits<uint32_t>::max)()) +\n+                                                        1;\n+                                     })\n+                       : false;\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is subset of the other.\n+    */\n+    bool isSubset(const Roaring64Map& r) const {\n+        for (const auto& map_entry : roarings) {\n+            auto roaring_iter = r.roarings.find(map_entry.first);\n+            if (roaring_iter == roarings.cend())\n+                return false;\n+            else if (!map_entry.second.isSubset(roaring_iter->second))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is strict subset of the other.\n+    * Throws std::length_error in the special case where the bitmap is full\n+    * (cardinality() == 2^64). Check isFull() before calling to avoid exception.\n+    */\n+    bool isStrictSubset(const Roaring64Map& r) const {\n+        return isSubset(r) && cardinality() != r.cardinality();\n+    }\n+\n+    /**\n+     * Convert the bitmap to an array. Write the output to \"ans\",\n+     * caller is responsible to ensure that there is enough memory\n+     * allocated\n+     * (e.g., ans = new uint32[mybitmap.cardinality()];)\n+     */\n+    void toUint64Array(uint64_t* ans) const {\n+        // Annoyingly, VS 2017 marks std::accumulate() as [[nodiscard]]\n+        (void)std::accumulate(\n+                roarings.cbegin(), roarings.cend(), ans,\n+                [](uint64_t* previous, const std::pair<uint32_t, Roaring>& map_entry) {\n+                    for (uint32_t low_bits : map_entry.second)\n+                        *previous++ = uniteBytes(map_entry.first, low_bits);\n+                    return previous;\n+                });\n+    }\n+\n+    /**\n+     * Return true if the two bitmaps contain the same elements.\n+     */\n+    bool operator==(const Roaring64Map& r) const {\n+        // we cannot use operator == on the map because either side may contain\n+        // empty Roaring Bitmaps\n+        auto lhs_iter = roarings.cbegin();\n+        auto rhs_iter = r.roarings.cbegin();\n+        do {\n+            // if the left map has reached its end, ensure that the right map\n+            // contains only empty Bitmaps\n+            if (lhs_iter == roarings.cend()) {\n+                while (rhs_iter != r.roarings.cend()) {\n+                    if (rhs_iter->second.isEmpty()) {\n+                        ++rhs_iter;\n+                        continue;\n+                    }\n+                    return false;\n+                }\n+                return true;\n+            }\n+            // if the left map has an empty bitmap, skip it\n+            if (lhs_iter->second.isEmpty()) {\n+                ++lhs_iter;\n+                continue;\n+            }\n+\n+            do {\n+                // if the right map has reached its end, ensure that the right\n+                // map contains only empty Bitmaps\n+                if (rhs_iter == r.roarings.cend()) {\n+                    while (lhs_iter != roarings.cend()) {\n+                        if (lhs_iter->second.isEmpty()) {\n+                            ++lhs_iter;\n+                            continue;\n+                        }\n+                        return false;\n+                    }\n+                    return true;\n+                }\n+                // if the right map has an empty bitmap, skip it\n+                if (rhs_iter->second.isEmpty()) {\n+                    ++rhs_iter;\n+                    continue;\n+                }\n+            } while (false);\n+            // if neither map has reached its end ensure elements are equal and\n+            // move to the next element in both\n+        } while (lhs_iter++->second == rhs_iter++->second);\n+        return false;\n+    }\n+\n+    /**\n+     * compute the negation of the roaring bitmap within a specified interval.\n+     * areas outside the range are passed through unchanged.\n+     */\n+    void flip(uint64_t range_start, uint64_t range_end) {\n+        uint32_t start_high = highBytes(range_start);\n+        uint32_t start_low = lowBytes(range_start);\n+        uint32_t end_high = highBytes(range_end);\n+        uint32_t end_low = lowBytes(range_end);\n+\n+        if (start_high == end_high) {\n+            roarings[start_high].flip(start_low, end_low);\n+            return;\n+        }\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        roarings[start_high].flip(start_low, (std::numeric_limits<uint32_t>::max)());\n+        roarings[start_high++].setCopyOnWrite(copyOnWrite);\n+\n+        for (; start_high <= highBytes(range_end) - 1; ++start_high) {\n+            roarings[start_high].flip((std::numeric_limits<uint32_t>::min)(),\n+                                      (std::numeric_limits<uint32_t>::max)());\n+            roarings[start_high].setCopyOnWrite(copyOnWrite);\n+        }\n+\n+        roarings[start_high].flip((std::numeric_limits<uint32_t>::min)(), end_low);\n+        roarings[start_high].setCopyOnWrite(copyOnWrite);\n+    }\n+\n+    /**\n+     *  Remove run-length encoding even when it is more space efficient\n+     *  return whether a change was applied\n+     */\n+    bool removeRunCompression() {\n+        return std::accumulate(roarings.begin(), roarings.end(), false,\n+                               [](bool previous, std::pair<const uint32_t, Roaring>& map_entry) {\n+                                   return map_entry.second.removeRunCompression() && previous;\n+                               });\n+    }\n+\n+    /** convert array and bitmap containers to run containers when it is more\n+     * efficient;\n+     * also convert from run containers when more space efficient.  Returns\n+     * true if the result has at least one run container.\n+     * Additional savings might be possible by calling shrinkToFit().\n+     */\n+    bool runOptimize() {\n+        return std::accumulate(roarings.begin(), roarings.end(), false,\n+                               [](bool previous, std::pair<const uint32_t, Roaring>& map_entry) {\n+                                   return map_entry.second.runOptimize() && previous;\n+                               });\n+    }\n+\n+    /**\n+     * If needed, reallocate memory to shrink the memory usage. Returns\n+     * the number of bytes saved.\n+    */\n+    size_t shrinkToFit() {\n+        size_t savedBytes = 0;\n+        auto iter = roarings.begin();\n+        while (iter != roarings.cend()) {\n+            if (iter->second.isEmpty()) {\n+                // empty Roarings are 84 bytes\n+                savedBytes += 88;\n+                roarings.erase(iter++);\n+            } else {\n+                savedBytes += iter->second.shrinkToFit();\n+                iter++;\n+            }\n+        }\n+        return savedBytes;\n+    }\n+\n+    /**\n+     * Iterate over the bitmap elements. The function iterator is called once\n+     * for all the values with ptr (can be NULL) as the second parameter of each\n+     * call.\n+     *\n+     * roaring_iterator is simply a pointer to a function that returns bool\n+     * (true means that the iteration should continue while false means that it\n+     * should stop), and takes (uint32_t,void*) as inputs.\n+     */\n+    void iterate(roaring_iterator64 iterator, void* ptr) const {\n+        std::for_each(roarings.begin(), roarings.cend(),\n+                      [=](const std::pair<uint32_t, Roaring>& map_entry) {\n+                          roaring_iterate64(&map_entry.second.roaring, iterator,\n+                                            uint64_t(map_entry.first) << 32, ptr);\n+                      });\n+    }\n+\n+    /**\n+     * If the size of the roaring bitmap is strictly greater than rank, then\n+     this\n+       function returns true and set element to the element of given rank.\n+       Otherwise, it returns false.\n+     */\n+    bool select(uint64_t rnk, uint64_t* element) const {\n+        for (const auto& map_entry : roarings) {\n+            uint64_t sub_cardinality = (uint64_t)map_entry.second.cardinality();\n+            if (rnk < sub_cardinality) {\n+                *element = ((uint64_t)map_entry.first) << 32;\n+                // assuming little endian\n+                return map_entry.second.select((uint32_t)rnk, ((uint32_t*)element));\n+            }\n+            rnk -= sub_cardinality;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+    * Returns the number of integers that are smaller or equal to x.\n+    */\n+    uint64_t rank(uint64_t x) const {\n+        uint64_t result = 0;\n+        auto roaring_destination = roarings.find(highBytes(x));\n+        if (roaring_destination != roarings.cend()) {\n+            for (auto roaring_iter = roarings.cbegin(); roaring_iter != roaring_destination;\n+                 ++roaring_iter) {\n+                result += roaring_iter->second.cardinality();\n+            }\n+            result += roaring_destination->second.rank(lowBytes(x));\n+            return result;\n+        }\n+        roaring_destination = roarings.lower_bound(highBytes(x));\n+        for (auto roaring_iter = roarings.cbegin(); roaring_iter != roaring_destination;\n+             ++roaring_iter) {\n+            result += roaring_iter->second.cardinality();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * write a bitmap to a char buffer.\n+     * Returns how many bytes were written which should be getSizeInBytes().\n+     */\n+    size_t write(char* buf) const {\n+        if (is32BitsEnough()) {\n+            *(buf++) = BitmapTypeCode::type::BITMAP32;\n+            auto it = roarings.find(0);\n+            if (it == roarings.end()) { // empty bitmap\n+                Roaring r;\n+                return r.write(buf) + 1;\n+            }\n+            return it->second.write(buf) + 1;\n+        }\n+\n+        const char* orig = buf;\n+        // put type code\n+        *(buf++) = BitmapTypeCode::type::BITMAP64;\n+        // push map size\n+        buf = (char*)encode_varint64((uint8_t*)buf, roarings.size());\n+        std::for_each(roarings.cbegin(), roarings.cend(),\n+                      [&buf](const std::pair<uint32_t, Roaring>& map_entry) {\n+                          // push map key\n+                          encode_fixed32_le((uint8_t*)buf, map_entry.first);\n+                          buf += sizeof(uint32_t);\n+                          // push map value Roaring\n+                          buf += map_entry.second.write(buf);\n+                      });\n+        return buf - orig;\n+    }\n+\n+    /**\n+     * read a bitmap from a serialized version.\n+     *\n+     * This function is unsafe in the sense that if you provide bad data,\n+     * many bytes could be read, possibly causing a buffer overflow. See also readSafe.\n+     */\n+    static Roaring64Map read(const char* buf) {\n+        Roaring64Map result;\n+\n+        if (*buf == BitmapTypeCode::BITMAP32) {\n+            Roaring read = Roaring::read(buf + 1);\n+            result.emplaceOrInsert(0, read);\n+            return result;\n+        }\n+\n+        DCHECK_EQ(BitmapTypeCode::BITMAP64, *buf);\n+        buf++;\n+\n+        // get map size (varint64 took 1~10 bytes)\n+        uint64_t map_size;\n+        buf = reinterpret_cast<const char*>(\n+                decode_varint64_ptr(reinterpret_cast<const uint8_t*>(buf),\n+                                    reinterpret_cast<const uint8_t*>(buf + 10), &map_size));\n+        DCHECK(buf != nullptr);\n+        for (uint64_t lcv = 0; lcv < map_size; lcv++) {\n+            // get map key\n+            uint32_t key = decode_fixed32_le(reinterpret_cast<const uint8_t*>(buf));\n+            buf += sizeof(uint32_t);\n+            // read map value Roaring\n+            Roaring read = Roaring::read(buf);\n+            result.emplaceOrInsert(key, read);\n+            // forward buffer past the last Roaring Bitmap\n+            buf += read.getSizeInBytes();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * How many bytes are required to serialize this bitmap\n+     */\n+    size_t getSizeInBytes() const {\n+        if (is32BitsEnough()) {\n+            auto it = roarings.find(0);\n+            if (it == roarings.end()) { // empty bitmap\n+                Roaring r;\n+                return r.getSizeInBytes() + 1;\n+            }\n+            return it->second.getSizeInBytes() + 1;\n+        }\n+        // start with type code, map size and size of keys for each map entry\n+        size_t init = 1 + varint_length(roarings.size()) + roarings.size() * sizeof(uint32_t);\n+        return std::accumulate(roarings.cbegin(), roarings.cend(), init,\n+                               [=](size_t previous, const std::pair<uint32_t, Roaring>& map_entry) {\n+                                   // add in bytes used by each Roaring\n+                                   return previous + map_entry.second.getSizeInBytes();\n+                               });\n+    }\n+\n+    /**\n+     * remove all elements\n+     */\n+    void clear() { roarings.clear(); }\n+\n+    /**\n+     * Return whether all elements can be represented in 32 bits\n+     */\n+    bool is32BitsEnough() const { return maximum() <= std::numeric_limits<uint32_t>::max(); }\n+\n+    /**\n+     * Computes the intersection between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator&(const Roaring64Map& o) const { return Roaring64Map(*this) &= o; }\n+\n+    /**\n+     * Computes the difference between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator-(const Roaring64Map& o) const { return Roaring64Map(*this) -= o; }\n+\n+    /**\n+     * Computes the union between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator|(const Roaring64Map& o) const { return Roaring64Map(*this) |= o; }\n+\n+    /**\n+     * Computes the symmetric union between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator^(const Roaring64Map& o) const { return Roaring64Map(*this) ^= o; }\n+\n+    /**\n+     * Whether or not we apply copy and write.\n+     */\n+    void setCopyOnWrite(bool val) {\n+        if (copyOnWrite == val) return;\n+        copyOnWrite = val;\n+        std::for_each(roarings.begin(), roarings.end(),\n+                      [=](std::pair<const uint32_t, Roaring>& map_entry) {\n+                          map_entry.second.setCopyOnWrite(val);\n+                      });\n+    }\n+\n+    /**\n+     * Print the content of the bitmap\n+     */\n+    void printf() const {\n+        if (!isEmpty()) {\n+            auto map_iter = roarings.cbegin();\n+            while (map_iter->second.isEmpty()) ++map_iter;\n+            struct iter_data {\n+                uint32_t high_bits;\n+                char first_char = '{';\n+            } outer_iter_data;\n+            outer_iter_data.high_bits = roarings.begin()->first;\n+            map_iter->second.iterate(\n+                    [](uint32_t low_bits, void* inner_iter_data) -> bool {\n+                        std::printf(\"%c%llu\", ((iter_data*)inner_iter_data)->first_char,\n+                                    (long long unsigned)uniteBytes(\n+                                            ((iter_data*)inner_iter_data)->high_bits, low_bits));\n+                        ((iter_data*)inner_iter_data)->first_char = ',';\n+                        return true;\n+                    },\n+                    (void*)&outer_iter_data);\n+            std::for_each(\n+                    ++map_iter, roarings.cend(), [](const std::pair<uint32_t, Roaring>& map_entry) {\n+                        map_entry.second.iterate(\n+                                [](uint32_t low_bits, void* high_bits) -> bool {\n+                                    std::printf(\",%llu\", (long long unsigned)uniteBytes(\n+                                                                 *(uint32_t*)high_bits, low_bits));\n+                                    return true;\n+                                },\n+                                (void*)&map_entry.first);\n+                    });\n+        } else\n+            std::printf(\"{\");\n+        std::printf(\"}\\n\");\n+    }\n+\n+    /**\n+     * Print the content of the bitmap into a string\n+     */\n+    std::string toString() const {\n+        struct iter_data {\n+            std::string str;\n+            uint32_t high_bits;\n+            char first_char = '{';\n+        } outer_iter_data;\n+        if (!isEmpty()) {\n+            auto map_iter = roarings.cbegin();\n+            while (map_iter->second.isEmpty()) ++map_iter;\n+            outer_iter_data.high_bits = roarings.begin()->first;\n+            map_iter->second.iterate(\n+                    [](uint32_t low_bits, void* inner_iter_data) -> bool {\n+                        ((iter_data*)inner_iter_data)->str +=\n+                                ((iter_data*)inner_iter_data)->first_char;\n+                        ((iter_data*)inner_iter_data)->str += std::to_string(\n+                                uniteBytes(((iter_data*)inner_iter_data)->high_bits, low_bits));\n+                        ((iter_data*)inner_iter_data)->first_char = ',';\n+                        return true;\n+                    },\n+                    (void*)&outer_iter_data);\n+            std::for_each(\n+                    ++map_iter, roarings.cend(),\n+                    [&outer_iter_data](const std::pair<uint32_t, Roaring>& map_entry) {\n+                        outer_iter_data.high_bits = map_entry.first;\n+                        map_entry.second.iterate(\n+                                [](uint32_t low_bits, void* inner_iter_data) -> bool {\n+                                    ((iter_data*)inner_iter_data)->str +=\n+                                            ((iter_data*)inner_iter_data)->first_char;\n+                                    ((iter_data*)inner_iter_data)->str += std::to_string(uniteBytes(\n+                                            ((iter_data*)inner_iter_data)->high_bits, low_bits));\n+                                    return true;\n+                                },\n+                                (void*)&outer_iter_data);\n+                    });\n+        } else\n+            outer_iter_data.str = '{';\n+        outer_iter_data.str += '}';\n+        return outer_iter_data.str;\n+    }\n+\n+    /**\n+     * Whether or not copy and write is active.\n+     */\n+    bool getCopyOnWrite() const { return copyOnWrite; }\n+\n+    /**\n+     * computes the logical or (union) between \"n\" bitmaps (referenced by a\n+     * pointer).\n+     */\n+    static Roaring64Map fastunion(size_t n, const Roaring64Map** inputs) {\n+        Roaring64Map ans;\n+        // not particularly fast\n+        for (size_t lcv = 0; lcv < n; ++lcv) {\n+            ans |= *(inputs[lcv]);\n+        }\n+        return ans;\n+    }\n+\n+    friend class Roaring64MapSetBitForwardIterator;\n+    typedef Roaring64MapSetBitForwardIterator const_iterator;\n+\n+    /**\n+    * Returns an iterator that can be used to access the position of the\n+    * set bits. The running time complexity of a full scan is proportional to\n+    * the\n+    * number\n+    * of set bits: be aware that if you have long strings of 1s, this can be\n+    * very inefficient.\n+    *\n+    * It can be much faster to use the toArray method if you want to\n+    * retrieve the set bits.\n+    */\n+    const_iterator begin() const;\n+\n+    /**\n+    * A bogus iterator that can be used together with begin()\n+    * for constructions such as for(auto i = b.begin();\n+    * i!=b.end(); ++i) {}\n+    */\n+    const_iterator end() const;\n+\n+private:\n+    std::map<uint32_t, Roaring> roarings;\n+    bool copyOnWrite = false;\n+    static uint32_t highBytes(const uint64_t in) { return uint32_t(in >> 32); }\n+    static uint32_t lowBytes(const uint64_t in) { return uint32_t(in); }\n+    static uint64_t uniteBytes(const uint32_t highBytes, const uint32_t lowBytes) {\n+        return (uint64_t(highBytes) << 32) | uint64_t(lowBytes);\n+    }\n+    // this is needed to tolerate gcc's C++11 libstdc++ lacking emplace\n+    // prior to version 4.8\n+    void emplaceOrInsert(const uint32_t key, const Roaring& value) {\n+#if defined(__GLIBCXX__) && __GLIBCXX__ < 20130322\n+        roarings.insert(std::make_pair(key, value));\n+#else\n+        roarings.emplace(std::make_pair(key, value));\n+#endif\n+    }\n+};\n+\n+// Forked from https://github.com/RoaringBitmap/CRoaring/blob/v0.2.60/cpp/roaring64map.hh\n+// Used to go through the set bits. Not optimally fast, but convenient.\n+class Roaring64MapSetBitForwardIterator final {\n+public:\n+    typedef std::forward_iterator_tag iterator_category;\n+    typedef uint64_t* pointer;\n+    typedef uint64_t& reference_type;\n+    typedef uint64_t value_type;\n+    typedef int64_t difference_type;\n+    typedef Roaring64MapSetBitForwardIterator type_of_iterator;\n+\n+    /**\n+     * Provides the location of the set bit.\n+     */\n+    value_type operator*() const {\n+        return Roaring64Map::uniteBytes(map_iter->first, i.current_value);\n+    }\n+\n+    bool operator<(const type_of_iterator& o) {\n+        if (map_iter == map_end) return false;\n+        if (o.map_iter == o.map_end) return true;\n+        return **this < *o;\n+    }\n+\n+    bool operator<=(const type_of_iterator& o) {\n+        if (o.map_iter == o.map_end) return true;\n+        if (map_iter == map_end) return false;\n+        return **this <= *o;\n+    }\n+\n+    bool operator>(const type_of_iterator& o) {\n+        if (o.map_iter == o.map_end) return false;\n+        if (map_iter == map_end) return true;\n+        return **this > *o;\n+    }\n+\n+    bool operator>=(const type_of_iterator& o) {\n+        if (map_iter == map_end) return true;\n+        if (o.map_iter == o.map_end) return false;\n+        return **this >= *o;\n+    }\n+\n+    type_of_iterator& operator++() { // ++i, must returned inc. value\n+        if (i.has_value == true) roaring_advance_uint32_iterator(&i);\n+        while (!i.has_value) {\n+            map_iter++;\n+            if (map_iter == map_end) return *this;\n+            roaring_init_iterator(&map_iter->second.roaring, &i);\n+        }\n+        return *this;\n+    }\n+\n+    type_of_iterator operator++(int) { // i++, must return orig. value\n+        Roaring64MapSetBitForwardIterator orig(*this);\n+        roaring_advance_uint32_iterator(&i);\n+        while (!i.has_value) {\n+            map_iter++;\n+            if (map_iter == map_end) return orig;\n+            roaring_init_iterator(&map_iter->second.roaring, &i);\n+        }\n+        return orig;\n+    }\n+\n+    bool operator==(const Roaring64MapSetBitForwardIterator& o) {\n+        if (map_iter == map_end && o.map_iter == o.map_end) return true;\n+        if (o.map_iter == o.map_end) return false;\n+        return **this == *o;\n+    }\n+\n+    bool operator!=(const Roaring64MapSetBitForwardIterator& o) {\n+        if (map_iter == map_end && o.map_iter == o.map_end) return false;\n+        if (o.map_iter == o.map_end) return true;\n+        return **this != *o;\n+    }\n+\n+    Roaring64MapSetBitForwardIterator(const Roaring64Map& parent, bool exhausted = false)\n+            : map_end(parent.roarings.cend()) {\n+        if (exhausted || parent.roarings.empty()) {\n+            map_iter = parent.roarings.cend();\n+        } else {\n+            map_iter = parent.roarings.cbegin();\n+            roaring_init_iterator(&map_iter->second.roaring, &i);\n+            while (!i.has_value) {\n+                map_iter++;\n+                if (map_iter == map_end) return;\n+                roaring_init_iterator(&map_iter->second.roaring, &i);\n+            }\n+        }\n+    }\n+\n+private:\n+    std::map<uint32_t, Roaring>::const_iterator map_iter;\n+    std::map<uint32_t, Roaring>::const_iterator map_end;\n+    roaring_uint32_iterator_t i;\n+};\n+\n+inline Roaring64MapSetBitForwardIterator Roaring64Map::begin() const {\n+    return Roaring64MapSetBitForwardIterator(*this);\n+}\n+\n+inline Roaring64MapSetBitForwardIterator Roaring64Map::end() const {\n+    return Roaring64MapSetBitForwardIterator(*this, true);\n+}\n+\n+// Represent the in-memory and on-disk structure of Doris's BITMAP data type.\n+// Optimize for the case where the bitmap contains 0 or 1 element which is common\n+// for streaming load scenario.\n+class BitmapValue {\n+public:\n+    // Construct an empty bitmap.\n+    BitmapValue() : _type(EMPTY) {}\n+\n+    // Construct a bitmap with one element.\n+    explicit BitmapValue(uint64_t value) : _sv(value), _type(SINGLE) {}\n+\n+    // Construct a bitmap from serialized data.\n+    explicit BitmapValue(const char* src) {\n+        bool res = deserialize(src);\n+        DCHECK(res);\n+    }\n+\n+    // Construct a bitmap from given elements.\n+    explicit BitmapValue(const std::vector<uint64_t>& bits) {\n+        switch (bits.size()) {\n+            case 0:\n+                _type = EMPTY;\n+                break;\n+            case 1:\n+                _type = SINGLE;\n+                _sv = bits[0];\n+                break;\n+            default:\n+                _type = BITMAP;\n+                _bitmap.addMany(bits.size(), &bits[0]);\n+        }\n+    }\n+\n+    void add(uint64_t value) {\n+        switch (_type) {\n+            case EMPTY:\n+                _sv = value;\n+                _type = SINGLE;\n+                break;\n+            case SINGLE:\n+                _bitmap.add(_sv);\n+                _bitmap.add(value);\n+                _type = BITMAP;\n+                break;\n+            case BITMAP:\n+                _bitmap.add(value);\n+        }\n+    }\n+\n+    // Compute the union between the current bitmap and the provided bitmap.\n+    // Possible type transitions are:\n+    // EMPTY  -> SINGLE\n+    // EMPTY  -> BITMAP\n+    // SINGLE -> BITMAP\n+    BitmapValue& operator|=(const BitmapValue& rhs) {\n+        switch (rhs._type) {\n+            case EMPTY:\n+                break;\n+            case SINGLE:\n+                add(rhs._sv);\n+                break;\n+            case BITMAP:\n+                switch (_type) {\n+                    case EMPTY:\n+                        _bitmap = rhs._bitmap;\n+                        _type = BITMAP;\n+                        break;\n+                    case SINGLE:\n+                        _bitmap = rhs._bitmap;\n+                        _bitmap.add(_sv);\n+                        _type = BITMAP;\n+                        break;\n+                    case BITMAP:\n+                        _bitmap |= rhs._bitmap;\n+                }\n+                break;\n+        }\n+        return *this;\n+    }\n+\n+    // Compute the intersection between the current bitmap and the provided bitmap.\n+    // Possible type transitions are:\n+    // SINGLE -> EMPTY\n+    // BITMAP -> EMPTY\n+    // BITMAP -> SINGLE\n+    BitmapValue& operator&=(const BitmapValue& rhs) {\n+        switch (rhs._type) {\n+            case EMPTY:\n+                _type = EMPTY;\n+                _bitmap.clear();\n+                break;\n+            case SINGLE:\n+                switch (_type) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE:\n+                        if (_sv != rhs._sv) {\n+                            _type = EMPTY;\n+                        }\n+                        break;\n+                    case BITMAP:\n+                        if (!_bitmap.contains(rhs._sv)) {\n+                            _type = EMPTY;\n+                        } else {\n+                            _type = SINGLE;\n+                            _sv = rhs._sv;\n+                        }\n+                        _bitmap.clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP:\n+                switch (_type) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE:\n+                        if (!rhs._bitmap.contains(_sv)) {\n+                            _type = EMPTY;\n+                        }\n+                        break;\n+                    case BITMAP:\n+                        _bitmap &= rhs._bitmap;\n+                        _convert_to_smaller_type();\n+                        break;\n+                }\n+                break;\n+        }\n+        return *this;\n+    }\n+\n+    // check if value x is present\n+    bool contains(uint64_t x) {\n+        switch (_type) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE:\n+                return _sv == x;\n+            case BITMAP:\n+                return _bitmap.contains(x);\n+        }\n+        return false;\n+    }\n+\n+    // TODO should the return type be uint64_t?\n+    int64_t cardinality() const {\n+        switch (_type) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE:\n+                return 1;\n+            case BITMAP:\n+                return _bitmap.cardinality();\n+        }\n+        return 0;\n+    }\n+\n+    // Return how many bytes are required to serialize this bitmap.\n+    // See BitmapTypeCode for the serialized format.\n+    size_t getSizeInBytes() {\n+        size_t res = 0;\n+        switch (_type) {\n+            case EMPTY:\n+                res = 1;\n+                break;\n+            case SINGLE:\n+                if (_sv <= std::numeric_limits<uint32_t>::max()) {\n+                    res = 1 + sizeof(uint32_t);\n+                } else {\n+                    res = 1 + sizeof(uint64_t);\n+                }\n+                break;\n+            case BITMAP:\n+                DCHECK(_bitmap.cardinality() > 1);\n+                _bitmap.runOptimize();\n+                _bitmap.shrinkToFit();\n+                res = _bitmap.getSizeInBytes();\n+                break;\n+        }\n+        return res;\n+    }\n+\n+    // Serialize the bitmap value to dst, which should be large enough.\n+    // Client should call `getSizeInBytes` first to get the serialized size.\n+    void write(char* dst) {\n+        switch (_type) {\n+            case EMPTY:\n+                *dst = BitmapTypeCode::EMPTY;\n+                break;\n+            case SINGLE:\n+                if (_sv <= std::numeric_limits<uint32_t>::max()) {\n+                    *(dst++) = BitmapTypeCode::SINGLE32;\n+                    encode_fixed32_le(reinterpret_cast<uint8_t*>(dst), static_cast<uint32_t>(_sv));\n+                } else {\n+                    *(dst++) = BitmapTypeCode::SINGLE64;\n+                    encode_fixed64_le(reinterpret_cast<uint8_t*>(dst), _sv);\n+                }\n+                break;\n+            case BITMAP:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcxMTc3Mg=="}, "originalCommit": {"oid": "397b523d565688a4dae0066db4bbcbd3c620f45c"}, "originalPosition": 1149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2MzM3MA==", "bodyText": "OK, I've moved Roaring64Map and related class into doris::detail namespace", "url": "https://github.com/apache/incubator-doris/pull/2772#discussion_r367763370", "createdAt": "2020-01-17T04:21:00Z", "author": {"login": "gaodayue"}, "path": "be/src/util/bitmap_value.h", "diffHunk": "@@ -0,0 +1,1243 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_UTIL_BITMAP_VALUE_H\n+#define DORIS_BE_SRC_UTIL_BITMAP_VALUE_H\n+\n+#include <algorithm>\n+#include <cstdarg>\n+#include <cstdio>\n+#include <limits>\n+#include <map>\n+#include <new>\n+#include <numeric>\n+#include <roaring/roaring.hh>\n+#include <stdexcept>\n+#include <string>\n+#include <utility>\n+\n+#include \"common/logging.h\"\n+#include \"util/coding.h\"\n+\n+namespace doris {\n+\n+class Roaring64MapSetBitForwardIterator;\n+\n+// serialized bitmap := TypeCode(1), Payload\n+// The format of payload depends on value of TypeCode which is defined below\n+struct BitmapTypeCode {\n+    enum type {\n+        // An empty bitmap. Payload is 0 byte.\n+        // added in 0.11\n+        EMPTY = 0,\n+        // A bitmap containing only one element that is in [0, UINT32_MAX]\n+        // Payload := UInt32LittleEndian(4 byte)\n+        // added in 0.11\n+        SINGLE32 = 1,\n+        // A bitmap whose maximum element is in [0, UINT32_MAX]\n+        // Payload := the standard RoaringBitmap format described by\n+        // https://github.com/RoaringBitmap/RoaringFormatSpec/\n+        // added in 0.11\n+        BITMAP32 = 2,\n+        // A bitmap containing only one element that is in (UINT32_MAX, UINT64_MAX]\n+        // Payload := UInt64LittleEndian(8 byte)\n+        // added in 0.12\n+        SINGLE64 = 3,\n+        // A bitmap whose maximum element is in (UINT32_MAX, UINT64_MAX].\n+        //\n+        // To support 64-bits elements, all elements with the same high 32 bits are stored in a\n+        // RoaringBitmap containing only the lower 32 bits. Thus we could use\n+        // map<uint32_t, RoaringBitmap> to represent bitmap of 64-bits ints.\n+        //\n+        // Since there is no standard format for 64-bits RoaringBitmap, we define our own as below\n+        // Payload := NumRoaring(vint64), { MapKey, MapValue }^NumRoaring\n+        // - MapKey := the shared high 32 bits in UInt32LittleEndian(4 byte)\n+        // - MapValue := the standard RoaringBitmap format\n+        //\n+        // added in 0.12\n+        BITMAP64 = 4\n+    };\n+};\n+\n+// Forked from https://github.com/RoaringBitmap/CRoaring/blob/v0.2.60/cpp/roaring64map.hh\n+// What we change includes\n+// - a custom serialization format is used inside read()/write()/getSizeInBytes()\n+// - added clear() and is32BitsEnough()\n+class Roaring64Map {\n+public:\n+    /**\n+     * Create an empty bitmap\n+     */\n+    Roaring64Map() = default;\n+\n+    /**\n+     * Construct a bitmap from a list of 32-bit integer values.\n+     */\n+    Roaring64Map(size_t n, const uint32_t* data) { addMany(n, data); }\n+\n+    /**\n+     * Construct a bitmap from a list of 64-bit integer values.\n+     */\n+    Roaring64Map(size_t n, const uint64_t* data) { addMany(n, data); }\n+\n+    /**\n+     * Construct a 64-bit map from a 32-bit one\n+     */\n+    Roaring64Map(const Roaring& r) { emplaceOrInsert(0, r); }\n+\n+    /**\n+     * Construct a roaring object from the C struct.\n+     *\n+     * Passing a NULL point is unsafe.\n+     */\n+    Roaring64Map(roaring_bitmap_t* s) { emplaceOrInsert(0, s); }\n+\n+    /**\n+     * Construct a bitmap from a list of integer values.\n+     */\n+    static Roaring64Map bitmapOf(size_t n...) {\n+        Roaring64Map ans;\n+        va_list vl;\n+        va_start(vl, n);\n+        for (size_t i = 0; i < n; i++) {\n+            ans.add(va_arg(vl, uint64_t));\n+        }\n+        va_end(vl);\n+        return ans;\n+    }\n+\n+    /**\n+     * Add value x\n+     *\n+     */\n+    void add(uint32_t x) {\n+        roarings[0].add(x);\n+        roarings[0].setCopyOnWrite(copyOnWrite);\n+    }\n+    void add(uint64_t x) {\n+        roarings[highBytes(x)].add(lowBytes(x));\n+        roarings[highBytes(x)].setCopyOnWrite(copyOnWrite);\n+    }\n+\n+    /**\n+     * Add value x\n+     * Returns true if a new value was added, false if the value was already existing.\n+     */\n+    bool addChecked(uint32_t x) {\n+        bool result = roarings[0].addChecked(x);\n+        roarings[0].setCopyOnWrite(copyOnWrite);\n+        return result;\n+    }\n+    bool addChecked(uint64_t x) {\n+        bool result = roarings[highBytes(x)].addChecked(lowBytes(x));\n+        roarings[highBytes(x)].setCopyOnWrite(copyOnWrite);\n+        return result;\n+    }\n+\n+    /**\n+     * Add value n_args from pointer vals\n+     *\n+     */\n+    void addMany(size_t n_args, const uint32_t* vals) {\n+        for (size_t lcv = 0; lcv < n_args; lcv++) {\n+            roarings[0].add(vals[lcv]);\n+            roarings[0].setCopyOnWrite(copyOnWrite);\n+        }\n+    }\n+    void addMany(size_t n_args, const uint64_t* vals) {\n+        for (size_t lcv = 0; lcv < n_args; lcv++) {\n+            roarings[highBytes(vals[lcv])].add(lowBytes(vals[lcv]));\n+            roarings[highBytes(vals[lcv])].setCopyOnWrite(copyOnWrite);\n+        }\n+    }\n+\n+    /**\n+     * Remove value x\n+     *\n+     */\n+    void remove(uint32_t x) { roarings[0].remove(x); }\n+    void remove(uint64_t x) {\n+        auto roaring_iter = roarings.find(highBytes(x));\n+        if (roaring_iter != roarings.cend()) roaring_iter->second.remove(lowBytes(x));\n+    }\n+\n+    /**\n+     * Remove value x\n+     * Returns true if a new value was removed, false if the value was not existing.\n+     */\n+    bool removeChecked(uint32_t x) { return roarings[0].removeChecked(x); }\n+    bool removeChecked(uint64_t x) {\n+        auto roaring_iter = roarings.find(highBytes(x));\n+        if (roaring_iter != roarings.cend()) return roaring_iter->second.removeChecked(lowBytes(x));\n+        return false;\n+    }\n+\n+    /**\n+     * Return the largest value (if not empty)\n+     *\n+     */\n+    uint64_t maximum() const {\n+        for (auto roaring_iter = roarings.crbegin(); roaring_iter != roarings.crend();\n+             ++roaring_iter) {\n+            if (!roaring_iter->second.isEmpty()) {\n+                return uniteBytes(roaring_iter->first, roaring_iter->second.maximum());\n+            }\n+        }\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        return (std::numeric_limits<uint64_t>::min)();\n+    }\n+\n+    /**\n+     * Return the smallest value (if not empty)\n+     *\n+     */\n+    uint64_t minimum() const {\n+        for (auto roaring_iter = roarings.cbegin(); roaring_iter != roarings.cend();\n+             ++roaring_iter) {\n+            if (!roaring_iter->second.isEmpty()) {\n+                return uniteBytes(roaring_iter->first, roaring_iter->second.minimum());\n+            }\n+        }\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        return (std::numeric_limits<uint64_t>::max)();\n+    }\n+\n+    /**\n+     * Check if value x is present\n+     */\n+    bool contains(uint32_t x) const {\n+        return roarings.count(0) == 0 ? false : roarings.at(0).contains(x);\n+    }\n+    bool contains(uint64_t x) const {\n+        return roarings.count(highBytes(x)) == 0 ? false\n+                                                 : roarings.at(highBytes(x)).contains(lowBytes(x));\n+    }\n+\n+    /**\n+     * Compute the intersection between the current bitmap and the provided\n+     * bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     */\n+    Roaring64Map& operator&=(const Roaring64Map& r) {\n+        for (auto& map_entry : roarings) {\n+            if (r.roarings.count(map_entry.first) == 1)\n+                map_entry.second &= r.roarings.at(map_entry.first);\n+            else\n+                map_entry.second = Roaring();\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Compute the difference between the current bitmap and the provided\n+     * bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     */\n+    Roaring64Map& operator-=(const Roaring64Map& r) {\n+        for (auto& map_entry : roarings) {\n+            if (r.roarings.count(map_entry.first) == 1)\n+                map_entry.second -= r.roarings.at(map_entry.first);\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Compute the union between the current bitmap and the provided bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     *\n+     * See also the fastunion function to aggregate many bitmaps more quickly.\n+     */\n+    Roaring64Map& operator|=(const Roaring64Map& r) {\n+        for (const auto& map_entry : r.roarings) {\n+            if (roarings.count(map_entry.first) == 0) {\n+                roarings[map_entry.first] = map_entry.second;\n+                roarings[map_entry.first].setCopyOnWrite(copyOnWrite);\n+            } else\n+                roarings[map_entry.first] |= map_entry.second;\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Compute the symmetric union between the current bitmap and the provided\n+     * bitmap,\n+     * writing the result in the current bitmap. The provided bitmap is not\n+     * modified.\n+     */\n+    Roaring64Map& operator^=(const Roaring64Map& r) {\n+        for (const auto& map_entry : r.roarings) {\n+            if (roarings.count(map_entry.first) == 0) {\n+                roarings[map_entry.first] = map_entry.second;\n+                roarings[map_entry.first].setCopyOnWrite(copyOnWrite);\n+            } else\n+                roarings[map_entry.first] ^= map_entry.second;\n+        }\n+        return *this;\n+    }\n+\n+    /**\n+     * Exchange the content of this bitmap with another.\n+     */\n+    void swap(Roaring64Map& r) { roarings.swap(r.roarings); }\n+\n+    /**\n+     * Get the cardinality of the bitmap (number of elements).\n+     * Throws std::length_error in the special case where the bitmap is full\n+     * (cardinality() == 2^64). Check isFull() before calling to avoid\n+     * exception.\n+     */\n+    uint64_t cardinality() const {\n+        if (isFull()) {\n+            throw std::length_error(\n+                    \"bitmap is full, cardinality is 2^64, \"\n+                    \"unable to represent in a 64-bit integer\");\n+        }\n+        return std::accumulate(\n+                roarings.cbegin(), roarings.cend(), (uint64_t)0,\n+                [](uint64_t previous, const std::pair<uint32_t, Roaring>& map_entry) {\n+                    return previous + map_entry.second.cardinality();\n+                });\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is empty (cardinality is zero).\n+    */\n+    bool isEmpty() const {\n+        return std::all_of(roarings.cbegin(), roarings.cend(),\n+                           [](const std::pair<uint32_t, Roaring>& map_entry) {\n+                               return map_entry.second.isEmpty();\n+                           });\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is full (cardinality is max uint64_t + 1).\n+    */\n+    bool isFull() const {\n+        // only bother to check if map is fully saturated\n+        //\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        return roarings.size() == ((size_t)(std::numeric_limits<uint32_t>::max)()) + 1\n+                       ? std::all_of(roarings.cbegin(), roarings.cend(),\n+                                     [](const std::pair<uint32_t, Roaring>& roaring_map_entry) {\n+                                         // roarings within map are saturated if cardinality\n+                                         // is uint32_t max + 1\n+                                         return roaring_map_entry.second.cardinality() ==\n+                                                ((uint64_t)(std::numeric_limits<uint32_t>::max)()) +\n+                                                        1;\n+                                     })\n+                       : false;\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is subset of the other.\n+    */\n+    bool isSubset(const Roaring64Map& r) const {\n+        for (const auto& map_entry : roarings) {\n+            auto roaring_iter = r.roarings.find(map_entry.first);\n+            if (roaring_iter == roarings.cend())\n+                return false;\n+            else if (!map_entry.second.isSubset(roaring_iter->second))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+    * Returns true if the bitmap is strict subset of the other.\n+    * Throws std::length_error in the special case where the bitmap is full\n+    * (cardinality() == 2^64). Check isFull() before calling to avoid exception.\n+    */\n+    bool isStrictSubset(const Roaring64Map& r) const {\n+        return isSubset(r) && cardinality() != r.cardinality();\n+    }\n+\n+    /**\n+     * Convert the bitmap to an array. Write the output to \"ans\",\n+     * caller is responsible to ensure that there is enough memory\n+     * allocated\n+     * (e.g., ans = new uint32[mybitmap.cardinality()];)\n+     */\n+    void toUint64Array(uint64_t* ans) const {\n+        // Annoyingly, VS 2017 marks std::accumulate() as [[nodiscard]]\n+        (void)std::accumulate(\n+                roarings.cbegin(), roarings.cend(), ans,\n+                [](uint64_t* previous, const std::pair<uint32_t, Roaring>& map_entry) {\n+                    for (uint32_t low_bits : map_entry.second)\n+                        *previous++ = uniteBytes(map_entry.first, low_bits);\n+                    return previous;\n+                });\n+    }\n+\n+    /**\n+     * Return true if the two bitmaps contain the same elements.\n+     */\n+    bool operator==(const Roaring64Map& r) const {\n+        // we cannot use operator == on the map because either side may contain\n+        // empty Roaring Bitmaps\n+        auto lhs_iter = roarings.cbegin();\n+        auto rhs_iter = r.roarings.cbegin();\n+        do {\n+            // if the left map has reached its end, ensure that the right map\n+            // contains only empty Bitmaps\n+            if (lhs_iter == roarings.cend()) {\n+                while (rhs_iter != r.roarings.cend()) {\n+                    if (rhs_iter->second.isEmpty()) {\n+                        ++rhs_iter;\n+                        continue;\n+                    }\n+                    return false;\n+                }\n+                return true;\n+            }\n+            // if the left map has an empty bitmap, skip it\n+            if (lhs_iter->second.isEmpty()) {\n+                ++lhs_iter;\n+                continue;\n+            }\n+\n+            do {\n+                // if the right map has reached its end, ensure that the right\n+                // map contains only empty Bitmaps\n+                if (rhs_iter == r.roarings.cend()) {\n+                    while (lhs_iter != roarings.cend()) {\n+                        if (lhs_iter->second.isEmpty()) {\n+                            ++lhs_iter;\n+                            continue;\n+                        }\n+                        return false;\n+                    }\n+                    return true;\n+                }\n+                // if the right map has an empty bitmap, skip it\n+                if (rhs_iter->second.isEmpty()) {\n+                    ++rhs_iter;\n+                    continue;\n+                }\n+            } while (false);\n+            // if neither map has reached its end ensure elements are equal and\n+            // move to the next element in both\n+        } while (lhs_iter++->second == rhs_iter++->second);\n+        return false;\n+    }\n+\n+    /**\n+     * compute the negation of the roaring bitmap within a specified interval.\n+     * areas outside the range are passed through unchanged.\n+     */\n+    void flip(uint64_t range_start, uint64_t range_end) {\n+        uint32_t start_high = highBytes(range_start);\n+        uint32_t start_low = lowBytes(range_start);\n+        uint32_t end_high = highBytes(range_end);\n+        uint32_t end_low = lowBytes(range_end);\n+\n+        if (start_high == end_high) {\n+            roarings[start_high].flip(start_low, end_low);\n+            return;\n+        }\n+        // we put std::numeric_limits<>::max/min in parenthesis\n+        // to avoid a clash with the Windows.h header under Windows\n+        roarings[start_high].flip(start_low, (std::numeric_limits<uint32_t>::max)());\n+        roarings[start_high++].setCopyOnWrite(copyOnWrite);\n+\n+        for (; start_high <= highBytes(range_end) - 1; ++start_high) {\n+            roarings[start_high].flip((std::numeric_limits<uint32_t>::min)(),\n+                                      (std::numeric_limits<uint32_t>::max)());\n+            roarings[start_high].setCopyOnWrite(copyOnWrite);\n+        }\n+\n+        roarings[start_high].flip((std::numeric_limits<uint32_t>::min)(), end_low);\n+        roarings[start_high].setCopyOnWrite(copyOnWrite);\n+    }\n+\n+    /**\n+     *  Remove run-length encoding even when it is more space efficient\n+     *  return whether a change was applied\n+     */\n+    bool removeRunCompression() {\n+        return std::accumulate(roarings.begin(), roarings.end(), false,\n+                               [](bool previous, std::pair<const uint32_t, Roaring>& map_entry) {\n+                                   return map_entry.second.removeRunCompression() && previous;\n+                               });\n+    }\n+\n+    /** convert array and bitmap containers to run containers when it is more\n+     * efficient;\n+     * also convert from run containers when more space efficient.  Returns\n+     * true if the result has at least one run container.\n+     * Additional savings might be possible by calling shrinkToFit().\n+     */\n+    bool runOptimize() {\n+        return std::accumulate(roarings.begin(), roarings.end(), false,\n+                               [](bool previous, std::pair<const uint32_t, Roaring>& map_entry) {\n+                                   return map_entry.second.runOptimize() && previous;\n+                               });\n+    }\n+\n+    /**\n+     * If needed, reallocate memory to shrink the memory usage. Returns\n+     * the number of bytes saved.\n+    */\n+    size_t shrinkToFit() {\n+        size_t savedBytes = 0;\n+        auto iter = roarings.begin();\n+        while (iter != roarings.cend()) {\n+            if (iter->second.isEmpty()) {\n+                // empty Roarings are 84 bytes\n+                savedBytes += 88;\n+                roarings.erase(iter++);\n+            } else {\n+                savedBytes += iter->second.shrinkToFit();\n+                iter++;\n+            }\n+        }\n+        return savedBytes;\n+    }\n+\n+    /**\n+     * Iterate over the bitmap elements. The function iterator is called once\n+     * for all the values with ptr (can be NULL) as the second parameter of each\n+     * call.\n+     *\n+     * roaring_iterator is simply a pointer to a function that returns bool\n+     * (true means that the iteration should continue while false means that it\n+     * should stop), and takes (uint32_t,void*) as inputs.\n+     */\n+    void iterate(roaring_iterator64 iterator, void* ptr) const {\n+        std::for_each(roarings.begin(), roarings.cend(),\n+                      [=](const std::pair<uint32_t, Roaring>& map_entry) {\n+                          roaring_iterate64(&map_entry.second.roaring, iterator,\n+                                            uint64_t(map_entry.first) << 32, ptr);\n+                      });\n+    }\n+\n+    /**\n+     * If the size of the roaring bitmap is strictly greater than rank, then\n+     this\n+       function returns true and set element to the element of given rank.\n+       Otherwise, it returns false.\n+     */\n+    bool select(uint64_t rnk, uint64_t* element) const {\n+        for (const auto& map_entry : roarings) {\n+            uint64_t sub_cardinality = (uint64_t)map_entry.second.cardinality();\n+            if (rnk < sub_cardinality) {\n+                *element = ((uint64_t)map_entry.first) << 32;\n+                // assuming little endian\n+                return map_entry.second.select((uint32_t)rnk, ((uint32_t*)element));\n+            }\n+            rnk -= sub_cardinality;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+    * Returns the number of integers that are smaller or equal to x.\n+    */\n+    uint64_t rank(uint64_t x) const {\n+        uint64_t result = 0;\n+        auto roaring_destination = roarings.find(highBytes(x));\n+        if (roaring_destination != roarings.cend()) {\n+            for (auto roaring_iter = roarings.cbegin(); roaring_iter != roaring_destination;\n+                 ++roaring_iter) {\n+                result += roaring_iter->second.cardinality();\n+            }\n+            result += roaring_destination->second.rank(lowBytes(x));\n+            return result;\n+        }\n+        roaring_destination = roarings.lower_bound(highBytes(x));\n+        for (auto roaring_iter = roarings.cbegin(); roaring_iter != roaring_destination;\n+             ++roaring_iter) {\n+            result += roaring_iter->second.cardinality();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * write a bitmap to a char buffer.\n+     * Returns how many bytes were written which should be getSizeInBytes().\n+     */\n+    size_t write(char* buf) const {\n+        if (is32BitsEnough()) {\n+            *(buf++) = BitmapTypeCode::type::BITMAP32;\n+            auto it = roarings.find(0);\n+            if (it == roarings.end()) { // empty bitmap\n+                Roaring r;\n+                return r.write(buf) + 1;\n+            }\n+            return it->second.write(buf) + 1;\n+        }\n+\n+        const char* orig = buf;\n+        // put type code\n+        *(buf++) = BitmapTypeCode::type::BITMAP64;\n+        // push map size\n+        buf = (char*)encode_varint64((uint8_t*)buf, roarings.size());\n+        std::for_each(roarings.cbegin(), roarings.cend(),\n+                      [&buf](const std::pair<uint32_t, Roaring>& map_entry) {\n+                          // push map key\n+                          encode_fixed32_le((uint8_t*)buf, map_entry.first);\n+                          buf += sizeof(uint32_t);\n+                          // push map value Roaring\n+                          buf += map_entry.second.write(buf);\n+                      });\n+        return buf - orig;\n+    }\n+\n+    /**\n+     * read a bitmap from a serialized version.\n+     *\n+     * This function is unsafe in the sense that if you provide bad data,\n+     * many bytes could be read, possibly causing a buffer overflow. See also readSafe.\n+     */\n+    static Roaring64Map read(const char* buf) {\n+        Roaring64Map result;\n+\n+        if (*buf == BitmapTypeCode::BITMAP32) {\n+            Roaring read = Roaring::read(buf + 1);\n+            result.emplaceOrInsert(0, read);\n+            return result;\n+        }\n+\n+        DCHECK_EQ(BitmapTypeCode::BITMAP64, *buf);\n+        buf++;\n+\n+        // get map size (varint64 took 1~10 bytes)\n+        uint64_t map_size;\n+        buf = reinterpret_cast<const char*>(\n+                decode_varint64_ptr(reinterpret_cast<const uint8_t*>(buf),\n+                                    reinterpret_cast<const uint8_t*>(buf + 10), &map_size));\n+        DCHECK(buf != nullptr);\n+        for (uint64_t lcv = 0; lcv < map_size; lcv++) {\n+            // get map key\n+            uint32_t key = decode_fixed32_le(reinterpret_cast<const uint8_t*>(buf));\n+            buf += sizeof(uint32_t);\n+            // read map value Roaring\n+            Roaring read = Roaring::read(buf);\n+            result.emplaceOrInsert(key, read);\n+            // forward buffer past the last Roaring Bitmap\n+            buf += read.getSizeInBytes();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * How many bytes are required to serialize this bitmap\n+     */\n+    size_t getSizeInBytes() const {\n+        if (is32BitsEnough()) {\n+            auto it = roarings.find(0);\n+            if (it == roarings.end()) { // empty bitmap\n+                Roaring r;\n+                return r.getSizeInBytes() + 1;\n+            }\n+            return it->second.getSizeInBytes() + 1;\n+        }\n+        // start with type code, map size and size of keys for each map entry\n+        size_t init = 1 + varint_length(roarings.size()) + roarings.size() * sizeof(uint32_t);\n+        return std::accumulate(roarings.cbegin(), roarings.cend(), init,\n+                               [=](size_t previous, const std::pair<uint32_t, Roaring>& map_entry) {\n+                                   // add in bytes used by each Roaring\n+                                   return previous + map_entry.second.getSizeInBytes();\n+                               });\n+    }\n+\n+    /**\n+     * remove all elements\n+     */\n+    void clear() { roarings.clear(); }\n+\n+    /**\n+     * Return whether all elements can be represented in 32 bits\n+     */\n+    bool is32BitsEnough() const { return maximum() <= std::numeric_limits<uint32_t>::max(); }\n+\n+    /**\n+     * Computes the intersection between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator&(const Roaring64Map& o) const { return Roaring64Map(*this) &= o; }\n+\n+    /**\n+     * Computes the difference between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator-(const Roaring64Map& o) const { return Roaring64Map(*this) -= o; }\n+\n+    /**\n+     * Computes the union between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator|(const Roaring64Map& o) const { return Roaring64Map(*this) |= o; }\n+\n+    /**\n+     * Computes the symmetric union between two bitmaps and returns new bitmap.\n+     * The current bitmap and the provided bitmap are unchanged.\n+     */\n+    Roaring64Map operator^(const Roaring64Map& o) const { return Roaring64Map(*this) ^= o; }\n+\n+    /**\n+     * Whether or not we apply copy and write.\n+     */\n+    void setCopyOnWrite(bool val) {\n+        if (copyOnWrite == val) return;\n+        copyOnWrite = val;\n+        std::for_each(roarings.begin(), roarings.end(),\n+                      [=](std::pair<const uint32_t, Roaring>& map_entry) {\n+                          map_entry.second.setCopyOnWrite(val);\n+                      });\n+    }\n+\n+    /**\n+     * Print the content of the bitmap\n+     */\n+    void printf() const {\n+        if (!isEmpty()) {\n+            auto map_iter = roarings.cbegin();\n+            while (map_iter->second.isEmpty()) ++map_iter;\n+            struct iter_data {\n+                uint32_t high_bits;\n+                char first_char = '{';\n+            } outer_iter_data;\n+            outer_iter_data.high_bits = roarings.begin()->first;\n+            map_iter->second.iterate(\n+                    [](uint32_t low_bits, void* inner_iter_data) -> bool {\n+                        std::printf(\"%c%llu\", ((iter_data*)inner_iter_data)->first_char,\n+                                    (long long unsigned)uniteBytes(\n+                                            ((iter_data*)inner_iter_data)->high_bits, low_bits));\n+                        ((iter_data*)inner_iter_data)->first_char = ',';\n+                        return true;\n+                    },\n+                    (void*)&outer_iter_data);\n+            std::for_each(\n+                    ++map_iter, roarings.cend(), [](const std::pair<uint32_t, Roaring>& map_entry) {\n+                        map_entry.second.iterate(\n+                                [](uint32_t low_bits, void* high_bits) -> bool {\n+                                    std::printf(\",%llu\", (long long unsigned)uniteBytes(\n+                                                                 *(uint32_t*)high_bits, low_bits));\n+                                    return true;\n+                                },\n+                                (void*)&map_entry.first);\n+                    });\n+        } else\n+            std::printf(\"{\");\n+        std::printf(\"}\\n\");\n+    }\n+\n+    /**\n+     * Print the content of the bitmap into a string\n+     */\n+    std::string toString() const {\n+        struct iter_data {\n+            std::string str;\n+            uint32_t high_bits;\n+            char first_char = '{';\n+        } outer_iter_data;\n+        if (!isEmpty()) {\n+            auto map_iter = roarings.cbegin();\n+            while (map_iter->second.isEmpty()) ++map_iter;\n+            outer_iter_data.high_bits = roarings.begin()->first;\n+            map_iter->second.iterate(\n+                    [](uint32_t low_bits, void* inner_iter_data) -> bool {\n+                        ((iter_data*)inner_iter_data)->str +=\n+                                ((iter_data*)inner_iter_data)->first_char;\n+                        ((iter_data*)inner_iter_data)->str += std::to_string(\n+                                uniteBytes(((iter_data*)inner_iter_data)->high_bits, low_bits));\n+                        ((iter_data*)inner_iter_data)->first_char = ',';\n+                        return true;\n+                    },\n+                    (void*)&outer_iter_data);\n+            std::for_each(\n+                    ++map_iter, roarings.cend(),\n+                    [&outer_iter_data](const std::pair<uint32_t, Roaring>& map_entry) {\n+                        outer_iter_data.high_bits = map_entry.first;\n+                        map_entry.second.iterate(\n+                                [](uint32_t low_bits, void* inner_iter_data) -> bool {\n+                                    ((iter_data*)inner_iter_data)->str +=\n+                                            ((iter_data*)inner_iter_data)->first_char;\n+                                    ((iter_data*)inner_iter_data)->str += std::to_string(uniteBytes(\n+                                            ((iter_data*)inner_iter_data)->high_bits, low_bits));\n+                                    return true;\n+                                },\n+                                (void*)&outer_iter_data);\n+                    });\n+        } else\n+            outer_iter_data.str = '{';\n+        outer_iter_data.str += '}';\n+        return outer_iter_data.str;\n+    }\n+\n+    /**\n+     * Whether or not copy and write is active.\n+     */\n+    bool getCopyOnWrite() const { return copyOnWrite; }\n+\n+    /**\n+     * computes the logical or (union) between \"n\" bitmaps (referenced by a\n+     * pointer).\n+     */\n+    static Roaring64Map fastunion(size_t n, const Roaring64Map** inputs) {\n+        Roaring64Map ans;\n+        // not particularly fast\n+        for (size_t lcv = 0; lcv < n; ++lcv) {\n+            ans |= *(inputs[lcv]);\n+        }\n+        return ans;\n+    }\n+\n+    friend class Roaring64MapSetBitForwardIterator;\n+    typedef Roaring64MapSetBitForwardIterator const_iterator;\n+\n+    /**\n+    * Returns an iterator that can be used to access the position of the\n+    * set bits. The running time complexity of a full scan is proportional to\n+    * the\n+    * number\n+    * of set bits: be aware that if you have long strings of 1s, this can be\n+    * very inefficient.\n+    *\n+    * It can be much faster to use the toArray method if you want to\n+    * retrieve the set bits.\n+    */\n+    const_iterator begin() const;\n+\n+    /**\n+    * A bogus iterator that can be used together with begin()\n+    * for constructions such as for(auto i = b.begin();\n+    * i!=b.end(); ++i) {}\n+    */\n+    const_iterator end() const;\n+\n+private:\n+    std::map<uint32_t, Roaring> roarings;\n+    bool copyOnWrite = false;\n+    static uint32_t highBytes(const uint64_t in) { return uint32_t(in >> 32); }\n+    static uint32_t lowBytes(const uint64_t in) { return uint32_t(in); }\n+    static uint64_t uniteBytes(const uint32_t highBytes, const uint32_t lowBytes) {\n+        return (uint64_t(highBytes) << 32) | uint64_t(lowBytes);\n+    }\n+    // this is needed to tolerate gcc's C++11 libstdc++ lacking emplace\n+    // prior to version 4.8\n+    void emplaceOrInsert(const uint32_t key, const Roaring& value) {\n+#if defined(__GLIBCXX__) && __GLIBCXX__ < 20130322\n+        roarings.insert(std::make_pair(key, value));\n+#else\n+        roarings.emplace(std::make_pair(key, value));\n+#endif\n+    }\n+};\n+\n+// Forked from https://github.com/RoaringBitmap/CRoaring/blob/v0.2.60/cpp/roaring64map.hh\n+// Used to go through the set bits. Not optimally fast, but convenient.\n+class Roaring64MapSetBitForwardIterator final {\n+public:\n+    typedef std::forward_iterator_tag iterator_category;\n+    typedef uint64_t* pointer;\n+    typedef uint64_t& reference_type;\n+    typedef uint64_t value_type;\n+    typedef int64_t difference_type;\n+    typedef Roaring64MapSetBitForwardIterator type_of_iterator;\n+\n+    /**\n+     * Provides the location of the set bit.\n+     */\n+    value_type operator*() const {\n+        return Roaring64Map::uniteBytes(map_iter->first, i.current_value);\n+    }\n+\n+    bool operator<(const type_of_iterator& o) {\n+        if (map_iter == map_end) return false;\n+        if (o.map_iter == o.map_end) return true;\n+        return **this < *o;\n+    }\n+\n+    bool operator<=(const type_of_iterator& o) {\n+        if (o.map_iter == o.map_end) return true;\n+        if (map_iter == map_end) return false;\n+        return **this <= *o;\n+    }\n+\n+    bool operator>(const type_of_iterator& o) {\n+        if (o.map_iter == o.map_end) return false;\n+        if (map_iter == map_end) return true;\n+        return **this > *o;\n+    }\n+\n+    bool operator>=(const type_of_iterator& o) {\n+        if (map_iter == map_end) return true;\n+        if (o.map_iter == o.map_end) return false;\n+        return **this >= *o;\n+    }\n+\n+    type_of_iterator& operator++() { // ++i, must returned inc. value\n+        if (i.has_value == true) roaring_advance_uint32_iterator(&i);\n+        while (!i.has_value) {\n+            map_iter++;\n+            if (map_iter == map_end) return *this;\n+            roaring_init_iterator(&map_iter->second.roaring, &i);\n+        }\n+        return *this;\n+    }\n+\n+    type_of_iterator operator++(int) { // i++, must return orig. value\n+        Roaring64MapSetBitForwardIterator orig(*this);\n+        roaring_advance_uint32_iterator(&i);\n+        while (!i.has_value) {\n+            map_iter++;\n+            if (map_iter == map_end) return orig;\n+            roaring_init_iterator(&map_iter->second.roaring, &i);\n+        }\n+        return orig;\n+    }\n+\n+    bool operator==(const Roaring64MapSetBitForwardIterator& o) {\n+        if (map_iter == map_end && o.map_iter == o.map_end) return true;\n+        if (o.map_iter == o.map_end) return false;\n+        return **this == *o;\n+    }\n+\n+    bool operator!=(const Roaring64MapSetBitForwardIterator& o) {\n+        if (map_iter == map_end && o.map_iter == o.map_end) return false;\n+        if (o.map_iter == o.map_end) return true;\n+        return **this != *o;\n+    }\n+\n+    Roaring64MapSetBitForwardIterator(const Roaring64Map& parent, bool exhausted = false)\n+            : map_end(parent.roarings.cend()) {\n+        if (exhausted || parent.roarings.empty()) {\n+            map_iter = parent.roarings.cend();\n+        } else {\n+            map_iter = parent.roarings.cbegin();\n+            roaring_init_iterator(&map_iter->second.roaring, &i);\n+            while (!i.has_value) {\n+                map_iter++;\n+                if (map_iter == map_end) return;\n+                roaring_init_iterator(&map_iter->second.roaring, &i);\n+            }\n+        }\n+    }\n+\n+private:\n+    std::map<uint32_t, Roaring>::const_iterator map_iter;\n+    std::map<uint32_t, Roaring>::const_iterator map_end;\n+    roaring_uint32_iterator_t i;\n+};\n+\n+inline Roaring64MapSetBitForwardIterator Roaring64Map::begin() const {\n+    return Roaring64MapSetBitForwardIterator(*this);\n+}\n+\n+inline Roaring64MapSetBitForwardIterator Roaring64Map::end() const {\n+    return Roaring64MapSetBitForwardIterator(*this, true);\n+}\n+\n+// Represent the in-memory and on-disk structure of Doris's BITMAP data type.\n+// Optimize for the case where the bitmap contains 0 or 1 element which is common\n+// for streaming load scenario.\n+class BitmapValue {\n+public:\n+    // Construct an empty bitmap.\n+    BitmapValue() : _type(EMPTY) {}\n+\n+    // Construct a bitmap with one element.\n+    explicit BitmapValue(uint64_t value) : _sv(value), _type(SINGLE) {}\n+\n+    // Construct a bitmap from serialized data.\n+    explicit BitmapValue(const char* src) {\n+        bool res = deserialize(src);\n+        DCHECK(res);\n+    }\n+\n+    // Construct a bitmap from given elements.\n+    explicit BitmapValue(const std::vector<uint64_t>& bits) {\n+        switch (bits.size()) {\n+            case 0:\n+                _type = EMPTY;\n+                break;\n+            case 1:\n+                _type = SINGLE;\n+                _sv = bits[0];\n+                break;\n+            default:\n+                _type = BITMAP;\n+                _bitmap.addMany(bits.size(), &bits[0]);\n+        }\n+    }\n+\n+    void add(uint64_t value) {\n+        switch (_type) {\n+            case EMPTY:\n+                _sv = value;\n+                _type = SINGLE;\n+                break;\n+            case SINGLE:\n+                _bitmap.add(_sv);\n+                _bitmap.add(value);\n+                _type = BITMAP;\n+                break;\n+            case BITMAP:\n+                _bitmap.add(value);\n+        }\n+    }\n+\n+    // Compute the union between the current bitmap and the provided bitmap.\n+    // Possible type transitions are:\n+    // EMPTY  -> SINGLE\n+    // EMPTY  -> BITMAP\n+    // SINGLE -> BITMAP\n+    BitmapValue& operator|=(const BitmapValue& rhs) {\n+        switch (rhs._type) {\n+            case EMPTY:\n+                break;\n+            case SINGLE:\n+                add(rhs._sv);\n+                break;\n+            case BITMAP:\n+                switch (_type) {\n+                    case EMPTY:\n+                        _bitmap = rhs._bitmap;\n+                        _type = BITMAP;\n+                        break;\n+                    case SINGLE:\n+                        _bitmap = rhs._bitmap;\n+                        _bitmap.add(_sv);\n+                        _type = BITMAP;\n+                        break;\n+                    case BITMAP:\n+                        _bitmap |= rhs._bitmap;\n+                }\n+                break;\n+        }\n+        return *this;\n+    }\n+\n+    // Compute the intersection between the current bitmap and the provided bitmap.\n+    // Possible type transitions are:\n+    // SINGLE -> EMPTY\n+    // BITMAP -> EMPTY\n+    // BITMAP -> SINGLE\n+    BitmapValue& operator&=(const BitmapValue& rhs) {\n+        switch (rhs._type) {\n+            case EMPTY:\n+                _type = EMPTY;\n+                _bitmap.clear();\n+                break;\n+            case SINGLE:\n+                switch (_type) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE:\n+                        if (_sv != rhs._sv) {\n+                            _type = EMPTY;\n+                        }\n+                        break;\n+                    case BITMAP:\n+                        if (!_bitmap.contains(rhs._sv)) {\n+                            _type = EMPTY;\n+                        } else {\n+                            _type = SINGLE;\n+                            _sv = rhs._sv;\n+                        }\n+                        _bitmap.clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP:\n+                switch (_type) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE:\n+                        if (!rhs._bitmap.contains(_sv)) {\n+                            _type = EMPTY;\n+                        }\n+                        break;\n+                    case BITMAP:\n+                        _bitmap &= rhs._bitmap;\n+                        _convert_to_smaller_type();\n+                        break;\n+                }\n+                break;\n+        }\n+        return *this;\n+    }\n+\n+    // check if value x is present\n+    bool contains(uint64_t x) {\n+        switch (_type) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE:\n+                return _sv == x;\n+            case BITMAP:\n+                return _bitmap.contains(x);\n+        }\n+        return false;\n+    }\n+\n+    // TODO should the return type be uint64_t?\n+    int64_t cardinality() const {\n+        switch (_type) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE:\n+                return 1;\n+            case BITMAP:\n+                return _bitmap.cardinality();\n+        }\n+        return 0;\n+    }\n+\n+    // Return how many bytes are required to serialize this bitmap.\n+    // See BitmapTypeCode for the serialized format.\n+    size_t getSizeInBytes() {\n+        size_t res = 0;\n+        switch (_type) {\n+            case EMPTY:\n+                res = 1;\n+                break;\n+            case SINGLE:\n+                if (_sv <= std::numeric_limits<uint32_t>::max()) {\n+                    res = 1 + sizeof(uint32_t);\n+                } else {\n+                    res = 1 + sizeof(uint64_t);\n+                }\n+                break;\n+            case BITMAP:\n+                DCHECK(_bitmap.cardinality() > 1);\n+                _bitmap.runOptimize();\n+                _bitmap.shrinkToFit();\n+                res = _bitmap.getSizeInBytes();\n+                break;\n+        }\n+        return res;\n+    }\n+\n+    // Serialize the bitmap value to dst, which should be large enough.\n+    // Client should call `getSizeInBytes` first to get the serialized size.\n+    void write(char* dst) {\n+        switch (_type) {\n+            case EMPTY:\n+                *dst = BitmapTypeCode::EMPTY;\n+                break;\n+            case SINGLE:\n+                if (_sv <= std::numeric_limits<uint32_t>::max()) {\n+                    *(dst++) = BitmapTypeCode::SINGLE32;\n+                    encode_fixed32_le(reinterpret_cast<uint8_t*>(dst), static_cast<uint32_t>(_sv));\n+                } else {\n+                    *(dst++) = BitmapTypeCode::SINGLE64;\n+                    encode_fixed64_le(reinterpret_cast<uint8_t*>(dst), _sv);\n+                }\n+                break;\n+            case BITMAP:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcxMTc3Mg=="}, "originalCommit": {"oid": "397b523d565688a4dae0066db4bbcbd3c620f45c"}, "originalPosition": 1149}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2121, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}