{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3MTEyMjY5", "number": 3090, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNDo1NzoxNlrODngCHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNTowMzo1OVrODrsA-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNzQ1ODg3OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNDo1NzoxNlrOF1iOLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNDo1NzoxNlrOF1iOLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3OTUzMw==", "bodyText": "Why only support BITMAP64 and not support EMPTY, SINGLE32, BITMAP32, SINGLE64?\nPlease explain which concrete methods are custom.", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r391679533", "createdAt": "2020-03-12T14:57:16Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "diffHunk": "@@ -0,0 +1,1456 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.BitmapDataProvider;\n+import org.roaringbitmap.BitmapDataProviderSupplier;\n+import org.roaringbitmap.IntConsumer;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapSupplier;\n+import org.roaringbitmap.Util;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.roaringbitmap.longlong.ImmutableLongBitmapDataProvider;\n+import org.roaringbitmap.longlong.LongConsumer;\n+import org.roaringbitmap.longlong.LongIterator;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.math.BigInteger;\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import static org.apache.doris.common.util.Util.decodeVarint64;\n+import static org.apache.doris.common.util.Util.encodeVarint64;\n+\n+/**\n+ *  used in spark load progress to build 64 bits int bitmap\n+ *  forked from https://github.com/RoaringBitmap/RoaringBitmap/blob/RoaringBitmap-0.8.13/RoaringBitmap/src/main/java/org/roaringbitmap/longlong/Roaring64NavigableMap.java\n+ *  mainly overwrite serialize/deserialize method to keep the storage format consist with be's 64 bit int bitmap\n+ *  for bitmap using in doris,we don't care the way ordering long\n+ *  so disable constructor with args signedLongs and using the default order\n+ */\n+public class Roaring64Map {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d21566232411809199e0cf9ac6c208e555cdd454"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NTk5NjQzOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwMzowMToxNFrOF51oyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjo1OTozN1rOF6fa_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5MTk0NQ==", "bodyText": "4294967293 will return false.\nwhich is not consistent with is32BitsEnough in BE\nbool is32BitsEnough() const { return maximum() <= std::numeric_limits<uint32_t>::max(); }", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396191945", "createdAt": "2020-03-23T03:01:14Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,372 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  Keep compatibility with doris be's bitmap_value.h\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value){\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    // if singvalue is 32-bit enough,need to cast it to int and write to container at position 0 directly\n+                    if (isLongValue32bitEnough(singleValue)) {\n+                        bitmap.add((int)singleValue);\n+                    } else {\n+                        bitmap.add(singleValue);\n+                    }\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.add(value);\n+                break;\n+        }\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    bitmap.add(singleValue);\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.add(value);\n+                break;\n+        }\n+    }\n+\n+    public boolean contains(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE_VALUE:\n+                return singleValue == value;\n+            case BITMAP_VALUE:\n+                if (isLongValue32bitEnough(value)) {\n+                    return bitmap.contains((int)value);\n+                } else {\n+                    return bitmap.contains(value);\n+                }\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public long cardinality() {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE_VALUE:\n+                return 1;\n+            case BITMAP_VALUE:\n+                return bitmap.getLongCardinality();\n+        }\n+        return 0;\n+    }\n+\n+    public void serialize(DataOutput output) throws IOException {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                output.writeByte(EMPTY);\n+                break;\n+            case SINGLE_VALUE:\n+                // is 32-bit enough\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    output.write(SINGLE32);\n+                    output.writeInt((int)singleValue);\n+                } else {\n+                    output.writeByte(SINGLE64);\n+                    output.writeLong(singleValue);\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.serialize(output);\n+                break;\n+        }\n+    }\n+\n+    public void deserialize(DataInput input) throws IOException {\n+        clear();\n+        int bitmapType = input.readByte();\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE32:\n+                singleValue = input.readInt();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE64:\n+                singleValue = input.readLong();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case BITMAP32:\n+            case BITMAP64:\n+                bitmap = bitmap == null ? new Roaring64Map() : bitmap;\n+                bitmap.deserialize(input, bitmapType);\n+                this.bitmapType = BITMAP_VALUE;\n+                break;\n+            default:\n+                throw new RuntimeException(String.format(\"unknown bitmap type %s \", bitmapType));\n+        }\n+    }\n+\n+    // In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+    public void and(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.singleValue == other.singleValue) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                    case BITMAP_VALUE:\n+                        if (other.bitmap.contains(singleValue)) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.bitmap.contains(other.singleValue)) {\n+                            clear();\n+                            this.bitmapType = SINGLE_VALUE;\n+                            this.singleValue = other.singleValue;\n+                        } else {\n+                            clear();\n+                        }\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.and(other.bitmap);\n+                        convertToSmallerType();\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    // In-place bitwise OR (union) operation. The current bitmap is modified.\n+    public void or(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.singleValue = other.singleValue;\n+                        this.bitmapType = SINGLE_VALUE;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        long thisSingleValue = this.singleValue;\n+                        clear();\n+                        add(thisSingleValue);\n+                        add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        other.add(this.singleValue);\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.or(other.bitmap);\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public boolean equals(BitmapValue other) {\n+        boolean ret = false;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        ret = true;\n+                        break;\n+                    case SINGLE_VALUE:\n+                    case BITMAP_VALUE:\n+                        ret = false;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case BITMAP_VALUE:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        ret = this.singleValue == other.singleValue;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case SINGLE_VALUE:\n+                        ret = false;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        ret = bitmap.equals(other.bitmap);\n+                        break;\n+                }\n+                break;\n+        }\n+        return ret;\n+    }\n+\n+    public long getSizeInBytes() {\n+        long size = 0;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                size = 1;\n+                break;\n+            case SINGLE_VALUE:\n+                if (singleValue <= Integer.MAX_VALUE) {\n+                    size = 4;\n+                } else {\n+                    size = 8;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                size = bitmap.getSizeInBytes();\n+        }\n+        return size;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String toStringStr = \"{}\";\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                toStringStr = String.format(\"{%s}\", singleValue);\n+                break;\n+            case BITMAP_VALUE:\n+                toStringStr = this.bitmap.toString();\n+                break;\n+        }\n+        return toStringStr;\n+    }\n+\n+    public void clear() {\n+        this.bitmapType = EMPTY;\n+        this.bitmap = null;\n+    }\n+\n+    private void convertToSmallerType() {\n+        if (bitmapType == BITMAP_VALUE) {\n+            if (bitmap.getLongCardinality() == 0) {\n+                this.bitmap = null;\n+                this.bitmapType = EMPTY;\n+            } else if (bitmap.getLongCardinality() == 1) {\n+                this.singleValue = bitmap.select(0);\n+                this.bitmapType = SINGLE_VALUE;\n+                this.bitmap = null;\n+            }\n+        }\n+    }\n+\n+    private boolean isLongValue32bitEnough(long value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "792211134a47d85efb0480cc84a501c871262124"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyNjE2Nw==", "bodyText": "In java,32-bit integers can be represented and used with arithmetic operation using long.\nBut support 64-bit unsigned integer is really a complex thing in java system.\nSo here I think it's ok to support unsigned 32-bit integers in FE's bitmap.\nBut I prefer 64-bit unsigned integer not being considered for the time being.", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396326167", "createdAt": "2020-03-23T09:50:40Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,372 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  Keep compatibility with doris be's bitmap_value.h\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value){\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    // if singvalue is 32-bit enough,need to cast it to int and write to container at position 0 directly\n+                    if (isLongValue32bitEnough(singleValue)) {\n+                        bitmap.add((int)singleValue);\n+                    } else {\n+                        bitmap.add(singleValue);\n+                    }\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.add(value);\n+                break;\n+        }\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    bitmap.add(singleValue);\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.add(value);\n+                break;\n+        }\n+    }\n+\n+    public boolean contains(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE_VALUE:\n+                return singleValue == value;\n+            case BITMAP_VALUE:\n+                if (isLongValue32bitEnough(value)) {\n+                    return bitmap.contains((int)value);\n+                } else {\n+                    return bitmap.contains(value);\n+                }\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public long cardinality() {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE_VALUE:\n+                return 1;\n+            case BITMAP_VALUE:\n+                return bitmap.getLongCardinality();\n+        }\n+        return 0;\n+    }\n+\n+    public void serialize(DataOutput output) throws IOException {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                output.writeByte(EMPTY);\n+                break;\n+            case SINGLE_VALUE:\n+                // is 32-bit enough\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    output.write(SINGLE32);\n+                    output.writeInt((int)singleValue);\n+                } else {\n+                    output.writeByte(SINGLE64);\n+                    output.writeLong(singleValue);\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.serialize(output);\n+                break;\n+        }\n+    }\n+\n+    public void deserialize(DataInput input) throws IOException {\n+        clear();\n+        int bitmapType = input.readByte();\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE32:\n+                singleValue = input.readInt();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE64:\n+                singleValue = input.readLong();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case BITMAP32:\n+            case BITMAP64:\n+                bitmap = bitmap == null ? new Roaring64Map() : bitmap;\n+                bitmap.deserialize(input, bitmapType);\n+                this.bitmapType = BITMAP_VALUE;\n+                break;\n+            default:\n+                throw new RuntimeException(String.format(\"unknown bitmap type %s \", bitmapType));\n+        }\n+    }\n+\n+    // In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+    public void and(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.singleValue == other.singleValue) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                    case BITMAP_VALUE:\n+                        if (other.bitmap.contains(singleValue)) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.bitmap.contains(other.singleValue)) {\n+                            clear();\n+                            this.bitmapType = SINGLE_VALUE;\n+                            this.singleValue = other.singleValue;\n+                        } else {\n+                            clear();\n+                        }\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.and(other.bitmap);\n+                        convertToSmallerType();\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    // In-place bitwise OR (union) operation. The current bitmap is modified.\n+    public void or(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.singleValue = other.singleValue;\n+                        this.bitmapType = SINGLE_VALUE;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        long thisSingleValue = this.singleValue;\n+                        clear();\n+                        add(thisSingleValue);\n+                        add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        other.add(this.singleValue);\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.or(other.bitmap);\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public boolean equals(BitmapValue other) {\n+        boolean ret = false;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        ret = true;\n+                        break;\n+                    case SINGLE_VALUE:\n+                    case BITMAP_VALUE:\n+                        ret = false;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case BITMAP_VALUE:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        ret = this.singleValue == other.singleValue;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case SINGLE_VALUE:\n+                        ret = false;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        ret = bitmap.equals(other.bitmap);\n+                        break;\n+                }\n+                break;\n+        }\n+        return ret;\n+    }\n+\n+    public long getSizeInBytes() {\n+        long size = 0;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                size = 1;\n+                break;\n+            case SINGLE_VALUE:\n+                if (singleValue <= Integer.MAX_VALUE) {\n+                    size = 4;\n+                } else {\n+                    size = 8;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                size = bitmap.getSizeInBytes();\n+        }\n+        return size;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String toStringStr = \"{}\";\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                toStringStr = String.format(\"{%s}\", singleValue);\n+                break;\n+            case BITMAP_VALUE:\n+                toStringStr = this.bitmap.toString();\n+                break;\n+        }\n+        return toStringStr;\n+    }\n+\n+    public void clear() {\n+        this.bitmapType = EMPTY;\n+        this.bitmap = null;\n+    }\n+\n+    private void convertToSmallerType() {\n+        if (bitmapType == BITMAP_VALUE) {\n+            if (bitmap.getLongCardinality() == 0) {\n+                this.bitmap = null;\n+                this.bitmapType = EMPTY;\n+            } else if (bitmap.getLongCardinality() == 1) {\n+                this.singleValue = bitmap.select(0);\n+                this.bitmapType = SINGLE_VALUE;\n+                this.bitmap = null;\n+            }\n+        }\n+    }\n+\n+    private boolean isLongValue32bitEnough(long value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5MTk0NQ=="}, "originalCommit": {"oid": "792211134a47d85efb0480cc84a501c871262124"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3NjU0Mg==", "bodyText": "OK", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396876542", "createdAt": "2020-03-24T02:59:37Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,372 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  Keep compatibility with doris be's bitmap_value.h\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value){\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    // if singvalue is 32-bit enough,need to cast it to int and write to container at position 0 directly\n+                    if (isLongValue32bitEnough(singleValue)) {\n+                        bitmap.add((int)singleValue);\n+                    } else {\n+                        bitmap.add(singleValue);\n+                    }\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.add(value);\n+                break;\n+        }\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    bitmap.add(singleValue);\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.add(value);\n+                break;\n+        }\n+    }\n+\n+    public boolean contains(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE_VALUE:\n+                return singleValue == value;\n+            case BITMAP_VALUE:\n+                if (isLongValue32bitEnough(value)) {\n+                    return bitmap.contains((int)value);\n+                } else {\n+                    return bitmap.contains(value);\n+                }\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public long cardinality() {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE_VALUE:\n+                return 1;\n+            case BITMAP_VALUE:\n+                return bitmap.getLongCardinality();\n+        }\n+        return 0;\n+    }\n+\n+    public void serialize(DataOutput output) throws IOException {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                output.writeByte(EMPTY);\n+                break;\n+            case SINGLE_VALUE:\n+                // is 32-bit enough\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    output.write(SINGLE32);\n+                    output.writeInt((int)singleValue);\n+                } else {\n+                    output.writeByte(SINGLE64);\n+                    output.writeLong(singleValue);\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.serialize(output);\n+                break;\n+        }\n+    }\n+\n+    public void deserialize(DataInput input) throws IOException {\n+        clear();\n+        int bitmapType = input.readByte();\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE32:\n+                singleValue = input.readInt();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE64:\n+                singleValue = input.readLong();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case BITMAP32:\n+            case BITMAP64:\n+                bitmap = bitmap == null ? new Roaring64Map() : bitmap;\n+                bitmap.deserialize(input, bitmapType);\n+                this.bitmapType = BITMAP_VALUE;\n+                break;\n+            default:\n+                throw new RuntimeException(String.format(\"unknown bitmap type %s \", bitmapType));\n+        }\n+    }\n+\n+    // In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+    public void and(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.singleValue == other.singleValue) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                    case BITMAP_VALUE:\n+                        if (other.bitmap.contains(singleValue)) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.bitmap.contains(other.singleValue)) {\n+                            clear();\n+                            this.bitmapType = SINGLE_VALUE;\n+                            this.singleValue = other.singleValue;\n+                        } else {\n+                            clear();\n+                        }\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.and(other.bitmap);\n+                        convertToSmallerType();\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    // In-place bitwise OR (union) operation. The current bitmap is modified.\n+    public void or(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.singleValue = other.singleValue;\n+                        this.bitmapType = SINGLE_VALUE;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        long thisSingleValue = this.singleValue;\n+                        clear();\n+                        add(thisSingleValue);\n+                        add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        other.add(this.singleValue);\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.or(other.bitmap);\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public boolean equals(BitmapValue other) {\n+        boolean ret = false;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        ret = true;\n+                        break;\n+                    case SINGLE_VALUE:\n+                    case BITMAP_VALUE:\n+                        ret = false;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case BITMAP_VALUE:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        ret = this.singleValue == other.singleValue;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case SINGLE_VALUE:\n+                        ret = false;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        ret = bitmap.equals(other.bitmap);\n+                        break;\n+                }\n+                break;\n+        }\n+        return ret;\n+    }\n+\n+    public long getSizeInBytes() {\n+        long size = 0;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                size = 1;\n+                break;\n+            case SINGLE_VALUE:\n+                if (singleValue <= Integer.MAX_VALUE) {\n+                    size = 4;\n+                } else {\n+                    size = 8;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                size = bitmap.getSizeInBytes();\n+        }\n+        return size;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String toStringStr = \"{}\";\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                toStringStr = String.format(\"{%s}\", singleValue);\n+                break;\n+            case BITMAP_VALUE:\n+                toStringStr = this.bitmap.toString();\n+                break;\n+        }\n+        return toStringStr;\n+    }\n+\n+    public void clear() {\n+        this.bitmapType = EMPTY;\n+        this.bitmap = null;\n+    }\n+\n+    private void convertToSmallerType() {\n+        if (bitmapType == BITMAP_VALUE) {\n+            if (bitmap.getLongCardinality() == 0) {\n+                this.bitmap = null;\n+                this.bitmapType = EMPTY;\n+            } else if (bitmap.getLongCardinality() == 1) {\n+                this.singleValue = bitmap.select(0);\n+                this.bitmapType = SINGLE_VALUE;\n+                this.bitmap = null;\n+            }\n+        }\n+    }\n+\n+    private boolean isLongValue32bitEnough(long value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5MTk0NQ=="}, "originalCommit": {"oid": "792211134a47d85efb0480cc84a501c871262124"}, "originalPosition": 357}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NjAxMTg2OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwMzoxMzo1MlrOF51yKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjo1OTo1M1rOF6fbOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NDM0NA==", "bodyText": "/**\n     * Add value x\n     *\n     */\n    void add(uint32_t x) {\n        roarings[0].add(x);\n        roarings[0].setCopyOnWrite(copyOnWrite);\n    }\n    void add(uint64_t x) {\n        roarings[highBytes(x)].add(lowBytes(x));\n        roarings[highBytes(x)].setCopyOnWrite(copyOnWrite);\n    }\n\nIn BE.  container 0 content is 0 ~ std::numeric_limits<uint32_t>::max()", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396194344", "createdAt": "2020-03-23T03:13:52Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "diffHunk": "@@ -0,0 +1,1484 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.BitmapDataProvider;\n+import org.roaringbitmap.BitmapDataProviderSupplier;\n+import org.roaringbitmap.IntConsumer;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapSupplier;\n+import org.roaringbitmap.Util;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.roaringbitmap.longlong.ImmutableLongBitmapDataProvider;\n+import org.roaringbitmap.longlong.LongConsumer;\n+import org.roaringbitmap.longlong.LongIterator;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import static org.apache.doris.common.util.Util.decodeVarint64;\n+import static org.apache.doris.common.util.Util.encodeVarint64;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP32;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP64;\n+\n+/**\n+ *\n+ * forked version 0.8.13\n+ * major change as below :\n+ *  1. overwrite serialize/deserialize method\n+ *  2. add a new method is32BitsEnough\n+ *  3. fork some Util method from org.roaringbitmap.longlong RoaringIntPacking\n+ * for details to see the end of the class\n+ */\n+public class Roaring64Map {\n+\n+    // Not final to enable initialization in Externalizable.readObject\n+    private NavigableMap<Integer, BitmapDataProvider> highToBitmap;\n+\n+    // If true, we handle longs a plain java longs: -1 if right before 0\n+    // If false, we handle longs as unsigned longs: 0 has no predecessor and Long.MAX_VALUE + 1L is\n+    // expressed as a\n+    // negative long\n+    private boolean signedLongs = false;\n+\n+    private BitmapDataProviderSupplier supplier;\n+\n+    // By default, we cache cardinalities\n+    private transient boolean doCacheCardinalities = true;\n+\n+    // Prevent recomputing all cardinalities when requesting consecutive ranks\n+    private transient int firstHighNotValid = highestHigh() + 1;\n+\n+    // This boolean needs firstHighNotValid == Integer.MAX_VALUE to be allowed to be true\n+    // If false, it means nearly all cumulated cardinalities are valid, except high=Integer.MAX_VALUE\n+    // If true, it means all cumulated cardinalities are valid, even high=Integer.MAX_VALUE\n+    private transient boolean allValid = false;\n+\n+    // TODO: I would prefer not managing arrays myself\n+    private transient long[] sortedCumulatedCardinality = new long[0];\n+    private transient int[] sortedHighs = new int[0];\n+\n+    // We guess consecutive .addLong will be on proximate longs: we remember the bitmap attached to\n+    // this bucket in order\n+    // to skip the indirection\n+    private transient Map.Entry<Integer, BitmapDataProvider> latestAddedHigh = null;\n+\n+    private static final boolean DEFAULT_ORDER_IS_SIGNED = false;\n+    private static final boolean DEFAULT_CARDINALITIES_ARE_CACHED = true;\n+\n+    /**\n+     * By default, we consider longs are unsigned longs: normal longs: 0 is the lowest possible long.\n+     * Long.MAX_VALUE is followed by Long.MIN_VALUE. -1L is the highest possible value\n+     */\n+    public Roaring64Map() {\n+        this(DEFAULT_ORDER_IS_SIGNED);\n+    }\n+\n+    /**\n+     *\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     */\n+    public Roaring64Map(boolean signedLongs) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED);\n+    }\n+\n+    /**\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities) {\n+        this(signedLongs, cacheCardinalities, new RoaringBitmapSupplier());\n+    }\n+\n+    /**\n+     * By default, longs are managed as unsigned longs and cardinalities are cached.\n+     *\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(BitmapDataProviderSupplier supplier) {\n+        this(DEFAULT_ORDER_IS_SIGNED, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     * By default, we activating cardinalities caching.\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, BitmapDataProviderSupplier supplier) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities,\n+                        BitmapDataProviderSupplier supplier) {\n+        this.signedLongs = signedLongs;\n+        this.supplier = supplier;\n+\n+        if (signedLongs) {\n+            highToBitmap = new TreeMap<>();\n+        } else {\n+            highToBitmap = new TreeMap<>(unsignedComparator());\n+        }\n+\n+        this.doCacheCardinalities = cacheCardinalities;\n+        resetPerfHelpers();\n+    }\n+\n+    private void resetPerfHelpers() {\n+        firstHighNotValid = highestHigh(signedLongs) + 1;\n+        allValid = false;\n+\n+        sortedCumulatedCardinality = new long[0];\n+        sortedHighs = new int[0];\n+\n+        latestAddedHigh = null;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    NavigableMap<Integer, BitmapDataProvider> getHighToBitmap() {\n+        return highToBitmap;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    int getLowestInvalidHigh() {\n+        return firstHighNotValid;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    long[] getSortedCumulatedCardinality() {\n+        return sortedCumulatedCardinality;\n+    }\n+\n+    /**\n+     * Add the value to the container (set the value to \"true\"), whether it already appears or not.\n+     *\n+     * Java lacks native unsigned longs but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Long#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 9223372036854775807, -9223372036854775808, -9223372036854775807,..., -1.\n+     *\n+     * @param x long value\n+     */\n+    public void addLong(long x) {\n+        int high = high(x);\n+        int low = low(x);\n+\n+        // Copy the reference to prevent race-condition\n+        Map.Entry<Integer, BitmapDataProvider> local = latestAddedHigh;\n+\n+        BitmapDataProvider bitmap;\n+        if (local != null && local.getKey().intValue() == high) {\n+            bitmap = local.getValue();\n+        } else {\n+            bitmap = highToBitmap.get(high);\n+            if (bitmap == null) {\n+                bitmap = newRoaringBitmap();\n+                pushBitmapForHigh(high, bitmap);\n+            }\n+            latestAddedHigh = new AbstractMap.SimpleImmutableEntry<>(high, bitmap);\n+        }\n+        bitmap.add(low);\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /**\n+     * Add the integer value to the container (set the value to \"true\"), whether it already appears or\n+     * not.\n+     *\n+     * Javac lacks native unsigned integers but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Integer#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 2147483647, -2147483648, -2147483647,..., -1.\n+     *\n+     * @param x integer value\n+     */\n+    public void addInt(int x) {\n+        addLong(Util.toUnsignedLong(x));\n+    }\n+\n+    private BitmapDataProvider newRoaringBitmap() {\n+        return supplier.newEmpty();\n+    }\n+\n+    private void invalidateAboveHigh(int high) {\n+        // The cardinalities after this bucket may not be valid anymore\n+        if (compare(firstHighNotValid, high) > 0) {\n+            // High was valid up to now\n+            firstHighNotValid = high;\n+\n+            int indexNotValid = binarySearch(sortedHighs, firstHighNotValid);\n+\n+            final int indexAfterWhichToReset;\n+            if (indexNotValid >= 0) {\n+                indexAfterWhichToReset = indexNotValid;\n+            } else {\n+                // We have invalidate a high not already present: added a value for a brand new high\n+                indexAfterWhichToReset = -indexNotValid - 1;\n+            }\n+\n+            // This way, sortedHighs remains sorted, without making a new/shorter array\n+            Arrays.fill(sortedHighs, indexAfterWhichToReset, sortedHighs.length, highestHigh());\n+        }\n+        allValid = false;\n+    }\n+\n+    private int compare(int x, int y) {\n+        if (signedLongs) {\n+            return Integer.compare(x, y);\n+        } else {\n+            return compareUnsigned(x, y);\n+        }\n+    }\n+\n+    private void pushBitmapForHigh(int high, BitmapDataProvider bitmap) {\n+        // TODO .size is too slow\n+        // int nbHighBefore = highToBitmap.headMap(high).size();\n+\n+        BitmapDataProvider previous = highToBitmap.put(high, bitmap);\n+        assert previous == null : \"Should push only not-existing high\";\n+    }\n+\n+    /**\n+     * Returns the number of distinct integers added to the bitmap (e.g., number of bits set).\n+     *\n+     * @return the cardinality\n+     */\n+    public long getLongCardinality() {\n+        if (doCacheCardinalities) {\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+            int indexOk = ensureCumulatives(highestHigh());\n+\n+            // ensureCumulatives may have removed empty bitmaps\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+\n+\n+            return sortedCumulatedCardinality[indexOk - 1];\n+        } else {\n+            long cardinality = 0L;\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                cardinality += bitmap.getLongCardinality();\n+            }\n+            return cardinality;\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return the cardinality as an int\n+     *\n+     * @throws UnsupportedOperationException if the cardinality does not fit in an int\n+     */\n+    public int getIntCardinality() throws UnsupportedOperationException {\n+        long cardinality = getLongCardinality();\n+\n+        if (cardinality > Integer.MAX_VALUE) {\n+            // TODO: we should handle cardinality fitting in an unsigned int\n+            throw new UnsupportedOperationException(\n+                    \"Can not call .getIntCardinality as the cardinality is bigger than Integer.MAX_VALUE\");\n+        }\n+\n+        return (int) cardinality;\n+    }\n+\n+    /**\n+     * Return the jth value stored in this bitmap.\n+     *\n+     * @param j index of the value\n+     *\n+     * @return the value\n+     * @throws IllegalArgumentException if j is out of the bounds of the bitmap cardinality\n+     */\n+    public long select(final long j) throws IllegalArgumentException {\n+        if (!doCacheCardinalities) {\n+            return selectNoCache(j);\n+        }\n+\n+        // Ensure all cumulatives as we we have straightforward way to know in advance the high of the\n+        // j-th value\n+        int indexOk = ensureCumulatives(highestHigh());\n+\n+        if (highToBitmap.isEmpty()) {\n+            return throwSelectInvalidIndex(j);\n+        }\n+\n+        // Use normal binarySearch as cardinality does not depends on considering longs signed or\n+        // unsigned\n+        // We need sortedCumulatedCardinality not to contain duplicated, else binarySearch may return\n+        // any of the duplicates: we need to ensure it holds no high associated to an empty bitmap\n+        int position = Arrays.binarySearch(sortedCumulatedCardinality, 0, indexOk, j);\n+\n+        if (position >= 0) {\n+            if (position == indexOk - 1) {\n+                // .select has been called on this.getCardinality\n+                return throwSelectInvalidIndex(j);\n+            }\n+\n+            // There is a bucket leading to this cardinality: the j-th element is the first element of\n+            // next bucket\n+            int high = sortedHighs[position + 1];\n+            BitmapDataProvider nextBitmap = highToBitmap.get(high);\n+            return pack(high, nextBitmap.select(0));\n+        } else {\n+            // There is no bucket with this cardinality\n+            int insertionPoint = -position - 1;\n+\n+            final long previousBucketCardinality;\n+            if (insertionPoint == 0) {\n+                previousBucketCardinality = 0L;\n+            } else if (insertionPoint >= indexOk) {\n+                return throwSelectInvalidIndex(j);\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+\n+            // We get a 'select' query for a single bitmap: should fit in an int\n+            final int givenBitmapSelect = (int) (j - previousBucketCardinality);\n+\n+            int high = sortedHighs[insertionPoint];\n+            BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+            int low = lowBitmap.select(givenBitmapSelect);\n+\n+            return pack(high, low);\n+        }\n+    }\n+\n+    // For benchmarks: compute without using cardinalities cache\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long selectNoCache(long j) {\n+        long left = j;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            long lowCardinality = entry.getValue().getCardinality();\n+\n+            if (left >= lowCardinality) {\n+                left -= lowCardinality;\n+            } else {\n+                // It is legit for left to be negative\n+                int leftAsUnsignedInt = (int) left;\n+                return pack(entry.getKey(), entry.getValue().select(leftAsUnsignedInt));\n+            }\n+        }\n+\n+        return throwSelectInvalidIndex(j);\n+    }\n+\n+    private long throwSelectInvalidIndex(long j) {\n+        // see org.roaringbitmap.buffer.ImmutableRoaringBitmap.select(int)\n+        throw new IllegalArgumentException(\n+                \"select \" + j + \" when the cardinality is \" + this.getLongCardinality());\n+    }\n+\n+    /**\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public Iterator<Long> iterator() {\n+        final LongIterator it = getLongIterator();\n+\n+        return new Iterator<Long>() {\n+\n+            @Override\n+            public boolean hasNext() {\n+                return it.hasNext();\n+            }\n+\n+            @Override\n+            public Long next() {\n+                return it.next();\n+            }\n+\n+            @Override\n+            public void remove() {\n+                // TODO?\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    public void forEach(final LongConsumer lc) {\n+        for (final Map.Entry<Integer, BitmapDataProvider> highEntry : highToBitmap.entrySet()) {\n+            highEntry.getValue().forEach(new IntConsumer() {\n+\n+                @Override\n+                public void accept(int low) {\n+                    lc.accept(pack(highEntry.getKey(), low));\n+                }\n+            });\n+        }\n+    }\n+\n+    public long rankLong(long id) {\n+        int high = high(id);\n+        int low = low(id);\n+\n+        if (!doCacheCardinalities) {\n+            return rankLongNoCache(high, low);\n+        }\n+\n+        int indexOk = ensureCumulatives(high);\n+\n+        int highPosition = binarySearch(sortedHighs, 0, indexOk, high);\n+\n+        if (highPosition >= 0) {\n+            // There is a bucket holding this item\n+\n+            final long previousBucketCardinality;\n+            if (highPosition == 0) {\n+                previousBucketCardinality = 0;\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[highPosition - 1];\n+            }\n+\n+            BitmapDataProvider lowBitmap = highToBitmap.get(sortedHighs[highPosition]);\n+\n+            // Rank is previous cardinality plus rank in current bitmap\n+            return previousBucketCardinality + lowBitmap.rankLong(low);\n+        } else {\n+            // There is no bucket holding this item: insertionPoint is previous bitmap\n+            int insertionPoint = -highPosition - 1;\n+\n+            if (insertionPoint == 0) {\n+                // this key is before all inserted keys\n+                return 0;\n+            } else {\n+                // The rank is the cardinality of this previous bitmap\n+                return sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+        }\n+    }\n+\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long rankLongNoCache(int high, int low) {\n+        long result = 0L;\n+\n+        BitmapDataProvider lastBitmap = highToBitmap.get(high);\n+        if (lastBitmap == null) {\n+            // There is no value with same high: the rank is a sum of cardinalities\n+            for (Map.Entry<Integer, BitmapDataProvider> bitmap : highToBitmap.entrySet()) {\n+                if (bitmap.getKey().intValue() > high) {\n+                    break;\n+                } else {\n+                    result += bitmap.getValue().getLongCardinality();\n+                }\n+            }\n+        } else {\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                if (bitmap == lastBitmap) {\n+                    result += bitmap.rankLong(low);\n+                    break;\n+                } else {\n+                    result += bitmap.getLongCardinality();\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param high for which high bucket should we compute the cardinality\n+     * @return the highest validatedIndex\n+     */\n+    protected int ensureCumulatives(int high) {\n+        if (allValid) {\n+            // the whole array is valid (up-to its actual length, not its capacity)\n+            return highToBitmap.size();\n+        } else if (compare(high, firstHighNotValid) < 0) {\n+            // The high is strictly below the first not valid: it is valid\n+\n+            // sortedHighs may have only a subset of valid values on the right. However, these invalid\n+            // values have been set to maxValue, and we are here as high < firstHighNotValid ==> high <\n+            // maxHigh()\n+            int position = binarySearch(sortedHighs, high);\n+\n+            if (position >= 0) {\n+                // This high has a bitmap: +1 as this index will be used as right (excluded) bound in a\n+                // binary-search\n+                return position + 1;\n+            } else {\n+                // This high has no bitmap: it could be between 2 highs with bitmaps\n+                int insertionPosition = -position - 1;\n+                return insertionPosition;\n+            }\n+        } else {\n+\n+            // For each deprecated buckets\n+            SortedMap<Integer, BitmapDataProvider> tailMap =\n+                    highToBitmap.tailMap(firstHighNotValid, true);\n+\n+            // TODO .size on tailMap make an iterator: arg\n+            int indexOk = highToBitmap.size() - tailMap.size();\n+\n+            // TODO: It should be possible to compute indexOk based on sortedHighs array\n+            // assert indexOk == binarySearch(sortedHighs, firstHighNotValid);\n+\n+            Iterator<Map.Entry<Integer, BitmapDataProvider>> it = tailMap.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry<Integer, BitmapDataProvider> e = it.next();\n+                int currentHigh = e.getKey();\n+\n+                if (compare(currentHigh, high) > 0) {\n+                    // No need to compute more than needed\n+                    break;\n+                } else if (e.getValue().isEmpty()) {\n+                    // highToBitmap can not be modified as we iterate over it\n+                    if (latestAddedHigh != null && latestAddedHigh.getKey().intValue() == currentHigh) {\n+                        // Dismiss the cached bitmap as it is removed from the NavigableMap\n+                        latestAddedHigh = null;\n+                    }\n+                    it.remove();\n+                } else {\n+                    ensureOne(e, currentHigh, indexOk);\n+\n+                    // We have added one valid cardinality\n+                    indexOk++;\n+                }\n+\n+            }\n+\n+            if (highToBitmap.isEmpty() || indexOk == highToBitmap.size()) {\n+                // We have compute all cardinalities\n+                allValid = true;\n+            }\n+\n+            return indexOk;\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, key);\n+        } else {\n+            return unsignedBinarySearch(array, 0, array.length, key,\n+                    unsignedComparator());\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int from, int to, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, from, to, key);\n+        } else {\n+            return unsignedBinarySearch(array, from, to, key, unsignedComparator());\n+        }\n+    }\n+\n+    // From Arrays.binarySearch (Comparator). Check with org.roaringbitmap.Util.unsignedBinarySearch\n+    private static int unsignedBinarySearch(int[] a, int fromIndex, int toIndex, int key,\n+                                            Comparator<? super Integer> c) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+            int midVal = a[mid];\n+            int cmp = c.compare(midVal, key);\n+            if (cmp < 0) {\n+                low = mid + 1;\n+            } else if (cmp > 0) {\n+                high = mid - 1;\n+            } else {\n+                return mid; // key found\n+            }\n+        }\n+        return -(low + 1); // key not found.\n+    }\n+\n+    private void ensureOne(Map.Entry<Integer, BitmapDataProvider> e, int currentHigh, int indexOk) {\n+        // sortedHighs are valid only up to some index\n+        assert indexOk <= sortedHighs.length : indexOk + \" is bigger than \" + sortedHighs.length;\n+\n+        final int index;\n+        if (indexOk == 0) {\n+            if (sortedHighs.length == 0) {\n+                index = -1;\n+                // } else if (sortedHighs[0] == currentHigh) {\n+                // index = 0;\n+            } else {\n+                index = -1;\n+            }\n+        } else if (indexOk < sortedHighs.length) {\n+            index = -indexOk - 1;\n+        } else {\n+            index = -sortedHighs.length - 1;\n+        }\n+        assert index == binarySearch(sortedHighs, 0, indexOk, currentHigh) : \"Computed \" + index\n+                + \" differs from dummy binary-search index: \"\n+                + binarySearch(sortedHighs, 0, indexOk, currentHigh);\n+\n+        if (index >= 0) {\n+            // This would mean calling .ensureOne is useless: should never got here at the first time\n+            throw new IllegalStateException(\"Unexpectedly found \" + currentHigh + \" in \"\n+                    + Arrays.toString(sortedHighs) + \" strictly before index\" + indexOk);\n+        } else {\n+            int insertionPosition = -index - 1;\n+\n+            // This is a new key\n+            if (insertionPosition >= sortedHighs.length) {\n+                int previousSize = sortedHighs.length;\n+\n+                // TODO softer growing factor\n+                int newSize = Math.min(Integer.MAX_VALUE, sortedHighs.length * 2 + 1);\n+\n+                // Insertion at the end\n+                sortedHighs = Arrays.copyOf(sortedHighs, newSize);\n+                sortedCumulatedCardinality = Arrays.copyOf(sortedCumulatedCardinality, newSize);\n+\n+                // Not actually needed. But simplify the reading of array content\n+                Arrays.fill(sortedHighs, previousSize, sortedHighs.length, highestHigh());\n+                Arrays.fill(sortedCumulatedCardinality, previousSize, sortedHighs.length, Long.MAX_VALUE);\n+            }\n+            sortedHighs[insertionPosition] = currentHigh;\n+\n+            final long previousCardinality;\n+            if (insertionPosition >= 1) {\n+                previousCardinality = sortedCumulatedCardinality[insertionPosition - 1];\n+            } else {\n+                previousCardinality = 0;\n+            }\n+\n+            sortedCumulatedCardinality[insertionPosition] =\n+                    previousCardinality + e.getValue().getLongCardinality();\n+\n+            if (currentHigh == highestHigh()) {\n+                // We are already on the highest high. Do not set allValid as it is set anyway out of the\n+                // loop\n+                firstHighNotValid = currentHigh;\n+            } else {\n+                // The first not valid is the next high\n+                // TODO: The entry comes from a NavigableMap: it may be quite cheap to know the next high\n+                firstHighNotValid = currentHigh + 1;\n+            }\n+        }\n+    }\n+\n+\n+\n+    private int highestHigh() {\n+        return highestHigh(signedLongs);\n+    }\n+\n+    /**\n+     * In-place bitwise OR (union) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void or(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).or((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).or((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise XOR (symmetric difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void xor(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).xor((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).xor((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void and(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 == null) {\n+                // None of given high values are present in x2\n+                thisIterator.remove();\n+            } else {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).and((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).and((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * In-place bitwise ANDNOT (difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void andNot(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 != null) {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).andNot((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).andNot((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A string describing the bitmap.\n+     *\n+     * @return the string\n+     */\n+    @Override\n+    public String toString() {\n+        final StringBuilder answer = new StringBuilder();\n+        final LongIterator i = this.getLongIterator();\n+        answer.append(\"{\");\n+        if (i.hasNext()) {\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+        }\n+        while (i.hasNext()) {\n+            answer.append(\",\");\n+            // to avoid using too much memory, we limit the size\n+            if (answer.length() > 0x80000) {\n+                answer.append(\"...\");\n+                break;\n+            }\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+\n+        }\n+        answer.append(\"}\");\n+        return answer.toString();\n+    }\n+\n+\n+    /**\n+     *\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public LongIterator getLongIterator() {\n+        final Iterator<Map.Entry<Integer, BitmapDataProvider>> it = highToBitmap.entrySet().iterator();\n+\n+        return toIterator(it, false);\n+    }\n+\n+    protected LongIterator toIterator(final Iterator<Map.Entry<Integer, BitmapDataProvider>> it,\n+                                      final boolean reversed) {\n+        return new LongIterator() {\n+\n+            protected int currentKey;\n+            protected IntIterator currentIt;\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (currentIt == null) {\n+                    // Were initially empty\n+                    if (!moveToNextEntry(it)) {\n+                        return false;\n+                    }\n+                }\n+\n+                while (true) {\n+                    if (currentIt.hasNext()) {\n+                        return true;\n+                    } else {\n+                        if (!moveToNextEntry(it)) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            /**\n+             *\n+             * @param it the underlying iterator which has to be moved to next long\n+             * @return true if we MAY have more entries. false if there is definitely nothing more\n+             */\n+            private boolean moveToNextEntry(Iterator<Map.Entry<Integer, BitmapDataProvider>> it) {\n+                if (it.hasNext()) {\n+                    Map.Entry<Integer, BitmapDataProvider> next = it.next();\n+                    currentKey = next.getKey();\n+                    if (reversed) {\n+                        currentIt = next.getValue().getReverseIntIterator();\n+                    } else {\n+                        currentIt = next.getValue().getIntIterator();\n+                    }\n+\n+                    // We may have more long\n+                    return true;\n+                } else {\n+                    // We know there is nothing more\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public long next() {\n+                if (hasNext()) {\n+                    return pack(currentKey, currentIt.next());\n+                } else {\n+                    throw new IllegalStateException(\"empty\");\n+                }\n+            }\n+\n+            @Override\n+            public LongIterator clone() {\n+                throw new UnsupportedOperationException(\"TODO\");\n+            }\n+        };\n+    }\n+\n+    public boolean contains(long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            return false;\n+        }\n+\n+        int low = low(x);\n+        return lowBitmap.contains(low);\n+    }\n+\n+\n+    public int getSizeInBytes() {\n+        return (int) getLongSizeInBytes();\n+    }\n+\n+    public long getLongSizeInBytes() {\n+        long size = 8;\n+\n+        // Size of containers\n+        size += highToBitmap.values().stream().mapToLong(p -> p.getLongSizeInBytes()).sum();\n+\n+        // Size of Map data-structure: we consider each TreeMap entry costs 40 bytes\n+        // http://java-performance.info/memory-consumption-of-java-data-types-2/\n+        size += 8 + 40 * highToBitmap.size();\n+\n+        // Size of (boxed) Integers used as keys\n+        size += 16 * highToBitmap.size();\n+\n+        // The cache impacts the size in heap\n+        size += 8 * sortedCumulatedCardinality.length;\n+        size += 4 * sortedHighs.length;\n+\n+        return size;\n+    }\n+\n+    public boolean isEmpty() {\n+        return getLongCardinality() == 0L;\n+    }\n+\n+    public ImmutableLongBitmapDataProvider limit(long x) {\n+        throw new UnsupportedOperationException(\"TODO\");\n+    }\n+\n+    /**\n+     * Use a run-length encoding where it is estimated as more space efficient\n+     *\n+     * @return whether a change was applied\n+     */\n+    public boolean runOptimize() {\n+        boolean hasChanged = false;\n+        for (BitmapDataProvider lowBitmap : highToBitmap.values()) {\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                hasChanged |= ((RoaringBitmap) lowBitmap).runOptimize();\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                hasChanged |= ((MutableRoaringBitmap) lowBitmap).runOptimize();\n+            }\n+        }\n+        return hasChanged;\n+    }\n+\n+    public long serializedSizeInBytes() {\n+        long nbBytes = 0L;\n+\n+        // .writeBoolean for signedLongs boolean\n+        nbBytes += 1;\n+\n+        // .writeInt for number of different high values\n+        nbBytes += 4;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            // .writeInt for high\n+            nbBytes += 4;\n+\n+            // The low bitmap size in bytes\n+            nbBytes += entry.getValue().serializedSizeInBytes();\n+        }\n+\n+        return nbBytes;\n+    }\n+\n+    /**\n+     * reset to an empty bitmap; result occupies as much space a newly created bitmap.\n+     */\n+    public void clear() {\n+        this.highToBitmap.clear();\n+        resetPerfHelpers();\n+    }\n+\n+    /**\n+     * Return the set values as an array, if the cardinality is smaller than 2147483648. The long\n+     * values are in sorted order.\n+     *\n+     * @return array representing the set values.\n+     */\n+    public long[] toArray() {\n+        long cardinality = this.getLongCardinality();\n+        if (cardinality > Integer.MAX_VALUE) {\n+            throw new IllegalStateException(\"The cardinality does not fit in an array\");\n+        }\n+\n+        final long[] array = new long[(int) cardinality];\n+\n+        int pos = 0;\n+        LongIterator it = getLongIterator();\n+\n+        while (it.hasNext()) {\n+            array[pos++] = it.next();\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Generate a bitmap with the specified values set to true. The provided longs values don't have\n+     * to be in sorted order, but it may be preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     * @return a new bitmap\n+     */\n+    public static Roaring64Map bitmapOf(final long... dat) {\n+        final Roaring64Map ans = new Roaring64Map();\n+        ans.add(dat);\n+        return ans;\n+    }\n+\n+    /**\n+     * Set all the specified values to true. This can be expected to be slightly faster than calling\n+     * \"add\" repeatedly. The provided integers values don't have to be in sorted order, but it may be\n+     * preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     */\n+    public void add(long... dat) {\n+        for (long oneLong : dat) {\n+            addLong(oneLong);\n+        }\n+    }\n+\n+    /**\n+     * Add to the current bitmap all longs in [rangeStart,rangeEnd).\n+     *\n+     * @param rangeStart inclusive beginning of range\n+     * @param rangeEnd exclusive ending of range\n+     */\n+    public void add(final long rangeStart, final long rangeEnd) {\n+        int startHigh = high(rangeStart);\n+        int startLow = low(rangeStart);\n+\n+        int endHigh = high(rangeEnd);\n+        int endLow = low(rangeEnd);\n+\n+        for (int high = startHigh; high <= endHigh; high++) {\n+            final int currentStartLow;\n+            if (startHigh == high) {\n+                // The whole range starts in this bucket\n+                currentStartLow = startLow;\n+            } else {\n+                // Add the bucket from the beginning\n+                currentStartLow = 0;\n+            }\n+\n+            long startLowAsLong = Util.toUnsignedLong(currentStartLow);\n+\n+            final long endLowAsLong;\n+            if (endHigh == high) {\n+                // The whole range ends in this bucket\n+                endLowAsLong = Util.toUnsignedLong(endLow);\n+            } else {\n+                // Add the bucket until the end: we have a +1 as, in RoaringBitmap.add(long,long), the end\n+                // is excluded\n+                endLowAsLong = Util.toUnsignedLong(-1) + 1;\n+            }\n+\n+            if (endLowAsLong > startLowAsLong) {\n+                // Initialize the bitmap only if there is access data to write\n+                BitmapDataProvider bitmap = highToBitmap.get(high);\n+                if (bitmap == null) {\n+                    bitmap = new MutableRoaringBitmap();\n+                    pushBitmapForHigh(high, bitmap);\n+                }\n+\n+                if (bitmap instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else if (bitmap instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else {\n+                    throw new UnsupportedOperationException(\"TODO. Not for \" + bitmap.getClass());\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(startHigh);\n+    }\n+\n+    public LongIterator getReverseLongIterator() {\n+        return toIterator(highToBitmap.descendingMap().entrySet().iterator(), true);\n+    }\n+\n+    public void removeLong(long x) {\n+        int high = high(x);\n+\n+        BitmapDataProvider bitmap = highToBitmap.get(high);\n+\n+        if (bitmap != null) {\n+            int low = low(x);\n+            bitmap.remove(low);\n+\n+            // Invalidate only if actually modified\n+            invalidateAboveHigh(high);\n+        }\n+\n+    }\n+\n+    public void trim() {\n+        for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+            bitmap.trim();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return highToBitmap.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        Roaring64Map other = (Roaring64Map) obj;\n+        return Objects.equals(highToBitmap, other.highToBitmap);\n+    }\n+\n+\n+\n+    /**\n+     * Add the value if it is not already present, otherwise remove it.\n+     *\n+     * @param x long value\n+     */\n+    public void flip(final long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            // The value is not added: add it without any flip specific code\n+            addLong(x);\n+        } else {\n+            int low = low(x);\n+\n+            // .flip is not in BitmapDataProvider contract\n+            // TODO Is it relevant to calling .flip with a cast?\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                ((RoaringBitmap) lowBitmap).flip(low);\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                ((MutableRoaringBitmap) lowBitmap).flip(low);\n+            } else {\n+                // Fallback to a manual flip\n+                if (lowBitmap.contains(low)) {\n+                    lowBitmap.remove(low);\n+                } else {\n+                    lowBitmap.add(low);\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /* ------------------ method below from Roaring64NavigableMap and being overwritten ----------------------------- */\n+\n+    /**\n+     * Serialize this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from onve java version\n+     * to another, and from one RoaringBitmap version to another.\n+     *\n+     * Consider calling {@link #runOptimize} before serialization to improve compression.\n+     *\n+     * The current bitmap is not modified.\n+     *\n+     * @param out the DataOutput stream\n+     * @throws IOException Signals that an I/O exception has occurred.\n+     */\n+    public void serialize(DataOutput out) throws IOException {\n+        if (highToBitmap.size() == 0) {\n+            return;\n+        }\n+        if (is32BitsEnough()) {\n+            out.write(BITMAP32);\n+            highToBitmap.get(0).serialize(out);\n+            return;\n+        }\n+\n+        out.write(BITMAP64);\n+        encodeVarint64(highToBitmap.size(), out);\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            out.writeInt(entry.getKey().intValue());\n+            entry.getValue().serialize(out);\n+        }\n+    }\n+\n+\n+    /**\n+     * Deserialize (retrieve) this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from one java version to\n+     * another, and from one RoaringBitmap version to another.\n+     *\n+     * The current bitmap is overwritten.\n+     *\n+     * @param in the DataInput stream\n+     * @throws IOException Signals that an I/O exception has occurred.\n+     */\n+    public void deserialize(DataInput in, int bitmapType) throws IOException {\n+        this.clear();\n+        highToBitmap = new TreeMap<>();\n+\n+        long nbHighs = 1;\n+        if (bitmapType == BITMAP64) {\n+            nbHighs = decodeVarint64(in);\n+        }\n+\n+        for (int i = 0; i < nbHighs; i++) {\n+            int high = in.readInt();\n+            RoaringBitmap provider = new RoaringBitmap();\n+            provider.deserialize(in);\n+\n+            highToBitmap.put(high, provider);\n+        }\n+\n+        resetPerfHelpers();\n+    }\n+\n+\n+\n+    /*---------------------------- method below is new written for doris's own bitmap --------------------------------*/\n+\n+    public boolean is32BitsEnough() {\n+        return highToBitmap.size() == 1 && highToBitmap.get(0) != null;\n+    }\n+\n+    public void add(long value) {\n+        addLong(value);\n+    }\n+\n+    public void add(int value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "792211134a47d85efb0480cc84a501c871262124"}, "originalPosition": 1377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIwMTE0OA==", "bodyText": "Java doesn't support unsigned integer directly, must use additional method to transfer which means we need to judge whether a integer value fits in unsigned 32-bit manually\nSo I don't think there is a graceful implementation to support unsigned integer in java.\nJava types is narrower than C++,So I think if we want to transfer bitmap between C++ and java,it's better to keep C++ compatible with java types actively.", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396201148", "createdAt": "2020-03-23T03:50:46Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "diffHunk": "@@ -0,0 +1,1484 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.BitmapDataProvider;\n+import org.roaringbitmap.BitmapDataProviderSupplier;\n+import org.roaringbitmap.IntConsumer;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapSupplier;\n+import org.roaringbitmap.Util;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.roaringbitmap.longlong.ImmutableLongBitmapDataProvider;\n+import org.roaringbitmap.longlong.LongConsumer;\n+import org.roaringbitmap.longlong.LongIterator;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import static org.apache.doris.common.util.Util.decodeVarint64;\n+import static org.apache.doris.common.util.Util.encodeVarint64;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP32;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP64;\n+\n+/**\n+ *\n+ * forked version 0.8.13\n+ * major change as below :\n+ *  1. overwrite serialize/deserialize method\n+ *  2. add a new method is32BitsEnough\n+ *  3. fork some Util method from org.roaringbitmap.longlong RoaringIntPacking\n+ * for details to see the end of the class\n+ */\n+public class Roaring64Map {\n+\n+    // Not final to enable initialization in Externalizable.readObject\n+    private NavigableMap<Integer, BitmapDataProvider> highToBitmap;\n+\n+    // If true, we handle longs a plain java longs: -1 if right before 0\n+    // If false, we handle longs as unsigned longs: 0 has no predecessor and Long.MAX_VALUE + 1L is\n+    // expressed as a\n+    // negative long\n+    private boolean signedLongs = false;\n+\n+    private BitmapDataProviderSupplier supplier;\n+\n+    // By default, we cache cardinalities\n+    private transient boolean doCacheCardinalities = true;\n+\n+    // Prevent recomputing all cardinalities when requesting consecutive ranks\n+    private transient int firstHighNotValid = highestHigh() + 1;\n+\n+    // This boolean needs firstHighNotValid == Integer.MAX_VALUE to be allowed to be true\n+    // If false, it means nearly all cumulated cardinalities are valid, except high=Integer.MAX_VALUE\n+    // If true, it means all cumulated cardinalities are valid, even high=Integer.MAX_VALUE\n+    private transient boolean allValid = false;\n+\n+    // TODO: I would prefer not managing arrays myself\n+    private transient long[] sortedCumulatedCardinality = new long[0];\n+    private transient int[] sortedHighs = new int[0];\n+\n+    // We guess consecutive .addLong will be on proximate longs: we remember the bitmap attached to\n+    // this bucket in order\n+    // to skip the indirection\n+    private transient Map.Entry<Integer, BitmapDataProvider> latestAddedHigh = null;\n+\n+    private static final boolean DEFAULT_ORDER_IS_SIGNED = false;\n+    private static final boolean DEFAULT_CARDINALITIES_ARE_CACHED = true;\n+\n+    /**\n+     * By default, we consider longs are unsigned longs: normal longs: 0 is the lowest possible long.\n+     * Long.MAX_VALUE is followed by Long.MIN_VALUE. -1L is the highest possible value\n+     */\n+    public Roaring64Map() {\n+        this(DEFAULT_ORDER_IS_SIGNED);\n+    }\n+\n+    /**\n+     *\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     */\n+    public Roaring64Map(boolean signedLongs) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED);\n+    }\n+\n+    /**\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities) {\n+        this(signedLongs, cacheCardinalities, new RoaringBitmapSupplier());\n+    }\n+\n+    /**\n+     * By default, longs are managed as unsigned longs and cardinalities are cached.\n+     *\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(BitmapDataProviderSupplier supplier) {\n+        this(DEFAULT_ORDER_IS_SIGNED, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     * By default, we activating cardinalities caching.\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, BitmapDataProviderSupplier supplier) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities,\n+                        BitmapDataProviderSupplier supplier) {\n+        this.signedLongs = signedLongs;\n+        this.supplier = supplier;\n+\n+        if (signedLongs) {\n+            highToBitmap = new TreeMap<>();\n+        } else {\n+            highToBitmap = new TreeMap<>(unsignedComparator());\n+        }\n+\n+        this.doCacheCardinalities = cacheCardinalities;\n+        resetPerfHelpers();\n+    }\n+\n+    private void resetPerfHelpers() {\n+        firstHighNotValid = highestHigh(signedLongs) + 1;\n+        allValid = false;\n+\n+        sortedCumulatedCardinality = new long[0];\n+        sortedHighs = new int[0];\n+\n+        latestAddedHigh = null;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    NavigableMap<Integer, BitmapDataProvider> getHighToBitmap() {\n+        return highToBitmap;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    int getLowestInvalidHigh() {\n+        return firstHighNotValid;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    long[] getSortedCumulatedCardinality() {\n+        return sortedCumulatedCardinality;\n+    }\n+\n+    /**\n+     * Add the value to the container (set the value to \"true\"), whether it already appears or not.\n+     *\n+     * Java lacks native unsigned longs but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Long#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 9223372036854775807, -9223372036854775808, -9223372036854775807,..., -1.\n+     *\n+     * @param x long value\n+     */\n+    public void addLong(long x) {\n+        int high = high(x);\n+        int low = low(x);\n+\n+        // Copy the reference to prevent race-condition\n+        Map.Entry<Integer, BitmapDataProvider> local = latestAddedHigh;\n+\n+        BitmapDataProvider bitmap;\n+        if (local != null && local.getKey().intValue() == high) {\n+            bitmap = local.getValue();\n+        } else {\n+            bitmap = highToBitmap.get(high);\n+            if (bitmap == null) {\n+                bitmap = newRoaringBitmap();\n+                pushBitmapForHigh(high, bitmap);\n+            }\n+            latestAddedHigh = new AbstractMap.SimpleImmutableEntry<>(high, bitmap);\n+        }\n+        bitmap.add(low);\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /**\n+     * Add the integer value to the container (set the value to \"true\"), whether it already appears or\n+     * not.\n+     *\n+     * Javac lacks native unsigned integers but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Integer#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 2147483647, -2147483648, -2147483647,..., -1.\n+     *\n+     * @param x integer value\n+     */\n+    public void addInt(int x) {\n+        addLong(Util.toUnsignedLong(x));\n+    }\n+\n+    private BitmapDataProvider newRoaringBitmap() {\n+        return supplier.newEmpty();\n+    }\n+\n+    private void invalidateAboveHigh(int high) {\n+        // The cardinalities after this bucket may not be valid anymore\n+        if (compare(firstHighNotValid, high) > 0) {\n+            // High was valid up to now\n+            firstHighNotValid = high;\n+\n+            int indexNotValid = binarySearch(sortedHighs, firstHighNotValid);\n+\n+            final int indexAfterWhichToReset;\n+            if (indexNotValid >= 0) {\n+                indexAfterWhichToReset = indexNotValid;\n+            } else {\n+                // We have invalidate a high not already present: added a value for a brand new high\n+                indexAfterWhichToReset = -indexNotValid - 1;\n+            }\n+\n+            // This way, sortedHighs remains sorted, without making a new/shorter array\n+            Arrays.fill(sortedHighs, indexAfterWhichToReset, sortedHighs.length, highestHigh());\n+        }\n+        allValid = false;\n+    }\n+\n+    private int compare(int x, int y) {\n+        if (signedLongs) {\n+            return Integer.compare(x, y);\n+        } else {\n+            return compareUnsigned(x, y);\n+        }\n+    }\n+\n+    private void pushBitmapForHigh(int high, BitmapDataProvider bitmap) {\n+        // TODO .size is too slow\n+        // int nbHighBefore = highToBitmap.headMap(high).size();\n+\n+        BitmapDataProvider previous = highToBitmap.put(high, bitmap);\n+        assert previous == null : \"Should push only not-existing high\";\n+    }\n+\n+    /**\n+     * Returns the number of distinct integers added to the bitmap (e.g., number of bits set).\n+     *\n+     * @return the cardinality\n+     */\n+    public long getLongCardinality() {\n+        if (doCacheCardinalities) {\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+            int indexOk = ensureCumulatives(highestHigh());\n+\n+            // ensureCumulatives may have removed empty bitmaps\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+\n+\n+            return sortedCumulatedCardinality[indexOk - 1];\n+        } else {\n+            long cardinality = 0L;\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                cardinality += bitmap.getLongCardinality();\n+            }\n+            return cardinality;\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return the cardinality as an int\n+     *\n+     * @throws UnsupportedOperationException if the cardinality does not fit in an int\n+     */\n+    public int getIntCardinality() throws UnsupportedOperationException {\n+        long cardinality = getLongCardinality();\n+\n+        if (cardinality > Integer.MAX_VALUE) {\n+            // TODO: we should handle cardinality fitting in an unsigned int\n+            throw new UnsupportedOperationException(\n+                    \"Can not call .getIntCardinality as the cardinality is bigger than Integer.MAX_VALUE\");\n+        }\n+\n+        return (int) cardinality;\n+    }\n+\n+    /**\n+     * Return the jth value stored in this bitmap.\n+     *\n+     * @param j index of the value\n+     *\n+     * @return the value\n+     * @throws IllegalArgumentException if j is out of the bounds of the bitmap cardinality\n+     */\n+    public long select(final long j) throws IllegalArgumentException {\n+        if (!doCacheCardinalities) {\n+            return selectNoCache(j);\n+        }\n+\n+        // Ensure all cumulatives as we we have straightforward way to know in advance the high of the\n+        // j-th value\n+        int indexOk = ensureCumulatives(highestHigh());\n+\n+        if (highToBitmap.isEmpty()) {\n+            return throwSelectInvalidIndex(j);\n+        }\n+\n+        // Use normal binarySearch as cardinality does not depends on considering longs signed or\n+        // unsigned\n+        // We need sortedCumulatedCardinality not to contain duplicated, else binarySearch may return\n+        // any of the duplicates: we need to ensure it holds no high associated to an empty bitmap\n+        int position = Arrays.binarySearch(sortedCumulatedCardinality, 0, indexOk, j);\n+\n+        if (position >= 0) {\n+            if (position == indexOk - 1) {\n+                // .select has been called on this.getCardinality\n+                return throwSelectInvalidIndex(j);\n+            }\n+\n+            // There is a bucket leading to this cardinality: the j-th element is the first element of\n+            // next bucket\n+            int high = sortedHighs[position + 1];\n+            BitmapDataProvider nextBitmap = highToBitmap.get(high);\n+            return pack(high, nextBitmap.select(0));\n+        } else {\n+            // There is no bucket with this cardinality\n+            int insertionPoint = -position - 1;\n+\n+            final long previousBucketCardinality;\n+            if (insertionPoint == 0) {\n+                previousBucketCardinality = 0L;\n+            } else if (insertionPoint >= indexOk) {\n+                return throwSelectInvalidIndex(j);\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+\n+            // We get a 'select' query for a single bitmap: should fit in an int\n+            final int givenBitmapSelect = (int) (j - previousBucketCardinality);\n+\n+            int high = sortedHighs[insertionPoint];\n+            BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+            int low = lowBitmap.select(givenBitmapSelect);\n+\n+            return pack(high, low);\n+        }\n+    }\n+\n+    // For benchmarks: compute without using cardinalities cache\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long selectNoCache(long j) {\n+        long left = j;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            long lowCardinality = entry.getValue().getCardinality();\n+\n+            if (left >= lowCardinality) {\n+                left -= lowCardinality;\n+            } else {\n+                // It is legit for left to be negative\n+                int leftAsUnsignedInt = (int) left;\n+                return pack(entry.getKey(), entry.getValue().select(leftAsUnsignedInt));\n+            }\n+        }\n+\n+        return throwSelectInvalidIndex(j);\n+    }\n+\n+    private long throwSelectInvalidIndex(long j) {\n+        // see org.roaringbitmap.buffer.ImmutableRoaringBitmap.select(int)\n+        throw new IllegalArgumentException(\n+                \"select \" + j + \" when the cardinality is \" + this.getLongCardinality());\n+    }\n+\n+    /**\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public Iterator<Long> iterator() {\n+        final LongIterator it = getLongIterator();\n+\n+        return new Iterator<Long>() {\n+\n+            @Override\n+            public boolean hasNext() {\n+                return it.hasNext();\n+            }\n+\n+            @Override\n+            public Long next() {\n+                return it.next();\n+            }\n+\n+            @Override\n+            public void remove() {\n+                // TODO?\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    public void forEach(final LongConsumer lc) {\n+        for (final Map.Entry<Integer, BitmapDataProvider> highEntry : highToBitmap.entrySet()) {\n+            highEntry.getValue().forEach(new IntConsumer() {\n+\n+                @Override\n+                public void accept(int low) {\n+                    lc.accept(pack(highEntry.getKey(), low));\n+                }\n+            });\n+        }\n+    }\n+\n+    public long rankLong(long id) {\n+        int high = high(id);\n+        int low = low(id);\n+\n+        if (!doCacheCardinalities) {\n+            return rankLongNoCache(high, low);\n+        }\n+\n+        int indexOk = ensureCumulatives(high);\n+\n+        int highPosition = binarySearch(sortedHighs, 0, indexOk, high);\n+\n+        if (highPosition >= 0) {\n+            // There is a bucket holding this item\n+\n+            final long previousBucketCardinality;\n+            if (highPosition == 0) {\n+                previousBucketCardinality = 0;\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[highPosition - 1];\n+            }\n+\n+            BitmapDataProvider lowBitmap = highToBitmap.get(sortedHighs[highPosition]);\n+\n+            // Rank is previous cardinality plus rank in current bitmap\n+            return previousBucketCardinality + lowBitmap.rankLong(low);\n+        } else {\n+            // There is no bucket holding this item: insertionPoint is previous bitmap\n+            int insertionPoint = -highPosition - 1;\n+\n+            if (insertionPoint == 0) {\n+                // this key is before all inserted keys\n+                return 0;\n+            } else {\n+                // The rank is the cardinality of this previous bitmap\n+                return sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+        }\n+    }\n+\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long rankLongNoCache(int high, int low) {\n+        long result = 0L;\n+\n+        BitmapDataProvider lastBitmap = highToBitmap.get(high);\n+        if (lastBitmap == null) {\n+            // There is no value with same high: the rank is a sum of cardinalities\n+            for (Map.Entry<Integer, BitmapDataProvider> bitmap : highToBitmap.entrySet()) {\n+                if (bitmap.getKey().intValue() > high) {\n+                    break;\n+                } else {\n+                    result += bitmap.getValue().getLongCardinality();\n+                }\n+            }\n+        } else {\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                if (bitmap == lastBitmap) {\n+                    result += bitmap.rankLong(low);\n+                    break;\n+                } else {\n+                    result += bitmap.getLongCardinality();\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param high for which high bucket should we compute the cardinality\n+     * @return the highest validatedIndex\n+     */\n+    protected int ensureCumulatives(int high) {\n+        if (allValid) {\n+            // the whole array is valid (up-to its actual length, not its capacity)\n+            return highToBitmap.size();\n+        } else if (compare(high, firstHighNotValid) < 0) {\n+            // The high is strictly below the first not valid: it is valid\n+\n+            // sortedHighs may have only a subset of valid values on the right. However, these invalid\n+            // values have been set to maxValue, and we are here as high < firstHighNotValid ==> high <\n+            // maxHigh()\n+            int position = binarySearch(sortedHighs, high);\n+\n+            if (position >= 0) {\n+                // This high has a bitmap: +1 as this index will be used as right (excluded) bound in a\n+                // binary-search\n+                return position + 1;\n+            } else {\n+                // This high has no bitmap: it could be between 2 highs with bitmaps\n+                int insertionPosition = -position - 1;\n+                return insertionPosition;\n+            }\n+        } else {\n+\n+            // For each deprecated buckets\n+            SortedMap<Integer, BitmapDataProvider> tailMap =\n+                    highToBitmap.tailMap(firstHighNotValid, true);\n+\n+            // TODO .size on tailMap make an iterator: arg\n+            int indexOk = highToBitmap.size() - tailMap.size();\n+\n+            // TODO: It should be possible to compute indexOk based on sortedHighs array\n+            // assert indexOk == binarySearch(sortedHighs, firstHighNotValid);\n+\n+            Iterator<Map.Entry<Integer, BitmapDataProvider>> it = tailMap.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry<Integer, BitmapDataProvider> e = it.next();\n+                int currentHigh = e.getKey();\n+\n+                if (compare(currentHigh, high) > 0) {\n+                    // No need to compute more than needed\n+                    break;\n+                } else if (e.getValue().isEmpty()) {\n+                    // highToBitmap can not be modified as we iterate over it\n+                    if (latestAddedHigh != null && latestAddedHigh.getKey().intValue() == currentHigh) {\n+                        // Dismiss the cached bitmap as it is removed from the NavigableMap\n+                        latestAddedHigh = null;\n+                    }\n+                    it.remove();\n+                } else {\n+                    ensureOne(e, currentHigh, indexOk);\n+\n+                    // We have added one valid cardinality\n+                    indexOk++;\n+                }\n+\n+            }\n+\n+            if (highToBitmap.isEmpty() || indexOk == highToBitmap.size()) {\n+                // We have compute all cardinalities\n+                allValid = true;\n+            }\n+\n+            return indexOk;\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, key);\n+        } else {\n+            return unsignedBinarySearch(array, 0, array.length, key,\n+                    unsignedComparator());\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int from, int to, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, from, to, key);\n+        } else {\n+            return unsignedBinarySearch(array, from, to, key, unsignedComparator());\n+        }\n+    }\n+\n+    // From Arrays.binarySearch (Comparator). Check with org.roaringbitmap.Util.unsignedBinarySearch\n+    private static int unsignedBinarySearch(int[] a, int fromIndex, int toIndex, int key,\n+                                            Comparator<? super Integer> c) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+            int midVal = a[mid];\n+            int cmp = c.compare(midVal, key);\n+            if (cmp < 0) {\n+                low = mid + 1;\n+            } else if (cmp > 0) {\n+                high = mid - 1;\n+            } else {\n+                return mid; // key found\n+            }\n+        }\n+        return -(low + 1); // key not found.\n+    }\n+\n+    private void ensureOne(Map.Entry<Integer, BitmapDataProvider> e, int currentHigh, int indexOk) {\n+        // sortedHighs are valid only up to some index\n+        assert indexOk <= sortedHighs.length : indexOk + \" is bigger than \" + sortedHighs.length;\n+\n+        final int index;\n+        if (indexOk == 0) {\n+            if (sortedHighs.length == 0) {\n+                index = -1;\n+                // } else if (sortedHighs[0] == currentHigh) {\n+                // index = 0;\n+            } else {\n+                index = -1;\n+            }\n+        } else if (indexOk < sortedHighs.length) {\n+            index = -indexOk - 1;\n+        } else {\n+            index = -sortedHighs.length - 1;\n+        }\n+        assert index == binarySearch(sortedHighs, 0, indexOk, currentHigh) : \"Computed \" + index\n+                + \" differs from dummy binary-search index: \"\n+                + binarySearch(sortedHighs, 0, indexOk, currentHigh);\n+\n+        if (index >= 0) {\n+            // This would mean calling .ensureOne is useless: should never got here at the first time\n+            throw new IllegalStateException(\"Unexpectedly found \" + currentHigh + \" in \"\n+                    + Arrays.toString(sortedHighs) + \" strictly before index\" + indexOk);\n+        } else {\n+            int insertionPosition = -index - 1;\n+\n+            // This is a new key\n+            if (insertionPosition >= sortedHighs.length) {\n+                int previousSize = sortedHighs.length;\n+\n+                // TODO softer growing factor\n+                int newSize = Math.min(Integer.MAX_VALUE, sortedHighs.length * 2 + 1);\n+\n+                // Insertion at the end\n+                sortedHighs = Arrays.copyOf(sortedHighs, newSize);\n+                sortedCumulatedCardinality = Arrays.copyOf(sortedCumulatedCardinality, newSize);\n+\n+                // Not actually needed. But simplify the reading of array content\n+                Arrays.fill(sortedHighs, previousSize, sortedHighs.length, highestHigh());\n+                Arrays.fill(sortedCumulatedCardinality, previousSize, sortedHighs.length, Long.MAX_VALUE);\n+            }\n+            sortedHighs[insertionPosition] = currentHigh;\n+\n+            final long previousCardinality;\n+            if (insertionPosition >= 1) {\n+                previousCardinality = sortedCumulatedCardinality[insertionPosition - 1];\n+            } else {\n+                previousCardinality = 0;\n+            }\n+\n+            sortedCumulatedCardinality[insertionPosition] =\n+                    previousCardinality + e.getValue().getLongCardinality();\n+\n+            if (currentHigh == highestHigh()) {\n+                // We are already on the highest high. Do not set allValid as it is set anyway out of the\n+                // loop\n+                firstHighNotValid = currentHigh;\n+            } else {\n+                // The first not valid is the next high\n+                // TODO: The entry comes from a NavigableMap: it may be quite cheap to know the next high\n+                firstHighNotValid = currentHigh + 1;\n+            }\n+        }\n+    }\n+\n+\n+\n+    private int highestHigh() {\n+        return highestHigh(signedLongs);\n+    }\n+\n+    /**\n+     * In-place bitwise OR (union) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void or(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).or((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).or((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise XOR (symmetric difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void xor(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).xor((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).xor((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void and(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 == null) {\n+                // None of given high values are present in x2\n+                thisIterator.remove();\n+            } else {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).and((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).and((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * In-place bitwise ANDNOT (difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void andNot(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 != null) {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).andNot((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).andNot((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A string describing the bitmap.\n+     *\n+     * @return the string\n+     */\n+    @Override\n+    public String toString() {\n+        final StringBuilder answer = new StringBuilder();\n+        final LongIterator i = this.getLongIterator();\n+        answer.append(\"{\");\n+        if (i.hasNext()) {\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+        }\n+        while (i.hasNext()) {\n+            answer.append(\",\");\n+            // to avoid using too much memory, we limit the size\n+            if (answer.length() > 0x80000) {\n+                answer.append(\"...\");\n+                break;\n+            }\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+\n+        }\n+        answer.append(\"}\");\n+        return answer.toString();\n+    }\n+\n+\n+    /**\n+     *\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public LongIterator getLongIterator() {\n+        final Iterator<Map.Entry<Integer, BitmapDataProvider>> it = highToBitmap.entrySet().iterator();\n+\n+        return toIterator(it, false);\n+    }\n+\n+    protected LongIterator toIterator(final Iterator<Map.Entry<Integer, BitmapDataProvider>> it,\n+                                      final boolean reversed) {\n+        return new LongIterator() {\n+\n+            protected int currentKey;\n+            protected IntIterator currentIt;\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (currentIt == null) {\n+                    // Were initially empty\n+                    if (!moveToNextEntry(it)) {\n+                        return false;\n+                    }\n+                }\n+\n+                while (true) {\n+                    if (currentIt.hasNext()) {\n+                        return true;\n+                    } else {\n+                        if (!moveToNextEntry(it)) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            /**\n+             *\n+             * @param it the underlying iterator which has to be moved to next long\n+             * @return true if we MAY have more entries. false if there is definitely nothing more\n+             */\n+            private boolean moveToNextEntry(Iterator<Map.Entry<Integer, BitmapDataProvider>> it) {\n+                if (it.hasNext()) {\n+                    Map.Entry<Integer, BitmapDataProvider> next = it.next();\n+                    currentKey = next.getKey();\n+                    if (reversed) {\n+                        currentIt = next.getValue().getReverseIntIterator();\n+                    } else {\n+                        currentIt = next.getValue().getIntIterator();\n+                    }\n+\n+                    // We may have more long\n+                    return true;\n+                } else {\n+                    // We know there is nothing more\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public long next() {\n+                if (hasNext()) {\n+                    return pack(currentKey, currentIt.next());\n+                } else {\n+                    throw new IllegalStateException(\"empty\");\n+                }\n+            }\n+\n+            @Override\n+            public LongIterator clone() {\n+                throw new UnsupportedOperationException(\"TODO\");\n+            }\n+        };\n+    }\n+\n+    public boolean contains(long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            return false;\n+        }\n+\n+        int low = low(x);\n+        return lowBitmap.contains(low);\n+    }\n+\n+\n+    public int getSizeInBytes() {\n+        return (int) getLongSizeInBytes();\n+    }\n+\n+    public long getLongSizeInBytes() {\n+        long size = 8;\n+\n+        // Size of containers\n+        size += highToBitmap.values().stream().mapToLong(p -> p.getLongSizeInBytes()).sum();\n+\n+        // Size of Map data-structure: we consider each TreeMap entry costs 40 bytes\n+        // http://java-performance.info/memory-consumption-of-java-data-types-2/\n+        size += 8 + 40 * highToBitmap.size();\n+\n+        // Size of (boxed) Integers used as keys\n+        size += 16 * highToBitmap.size();\n+\n+        // The cache impacts the size in heap\n+        size += 8 * sortedCumulatedCardinality.length;\n+        size += 4 * sortedHighs.length;\n+\n+        return size;\n+    }\n+\n+    public boolean isEmpty() {\n+        return getLongCardinality() == 0L;\n+    }\n+\n+    public ImmutableLongBitmapDataProvider limit(long x) {\n+        throw new UnsupportedOperationException(\"TODO\");\n+    }\n+\n+    /**\n+     * Use a run-length encoding where it is estimated as more space efficient\n+     *\n+     * @return whether a change was applied\n+     */\n+    public boolean runOptimize() {\n+        boolean hasChanged = false;\n+        for (BitmapDataProvider lowBitmap : highToBitmap.values()) {\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                hasChanged |= ((RoaringBitmap) lowBitmap).runOptimize();\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                hasChanged |= ((MutableRoaringBitmap) lowBitmap).runOptimize();\n+            }\n+        }\n+        return hasChanged;\n+    }\n+\n+    public long serializedSizeInBytes() {\n+        long nbBytes = 0L;\n+\n+        // .writeBoolean for signedLongs boolean\n+        nbBytes += 1;\n+\n+        // .writeInt for number of different high values\n+        nbBytes += 4;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            // .writeInt for high\n+            nbBytes += 4;\n+\n+            // The low bitmap size in bytes\n+            nbBytes += entry.getValue().serializedSizeInBytes();\n+        }\n+\n+        return nbBytes;\n+    }\n+\n+    /**\n+     * reset to an empty bitmap; result occupies as much space a newly created bitmap.\n+     */\n+    public void clear() {\n+        this.highToBitmap.clear();\n+        resetPerfHelpers();\n+    }\n+\n+    /**\n+     * Return the set values as an array, if the cardinality is smaller than 2147483648. The long\n+     * values are in sorted order.\n+     *\n+     * @return array representing the set values.\n+     */\n+    public long[] toArray() {\n+        long cardinality = this.getLongCardinality();\n+        if (cardinality > Integer.MAX_VALUE) {\n+            throw new IllegalStateException(\"The cardinality does not fit in an array\");\n+        }\n+\n+        final long[] array = new long[(int) cardinality];\n+\n+        int pos = 0;\n+        LongIterator it = getLongIterator();\n+\n+        while (it.hasNext()) {\n+            array[pos++] = it.next();\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Generate a bitmap with the specified values set to true. The provided longs values don't have\n+     * to be in sorted order, but it may be preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     * @return a new bitmap\n+     */\n+    public static Roaring64Map bitmapOf(final long... dat) {\n+        final Roaring64Map ans = new Roaring64Map();\n+        ans.add(dat);\n+        return ans;\n+    }\n+\n+    /**\n+     * Set all the specified values to true. This can be expected to be slightly faster than calling\n+     * \"add\" repeatedly. The provided integers values don't have to be in sorted order, but it may be\n+     * preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     */\n+    public void add(long... dat) {\n+        for (long oneLong : dat) {\n+            addLong(oneLong);\n+        }\n+    }\n+\n+    /**\n+     * Add to the current bitmap all longs in [rangeStart,rangeEnd).\n+     *\n+     * @param rangeStart inclusive beginning of range\n+     * @param rangeEnd exclusive ending of range\n+     */\n+    public void add(final long rangeStart, final long rangeEnd) {\n+        int startHigh = high(rangeStart);\n+        int startLow = low(rangeStart);\n+\n+        int endHigh = high(rangeEnd);\n+        int endLow = low(rangeEnd);\n+\n+        for (int high = startHigh; high <= endHigh; high++) {\n+            final int currentStartLow;\n+            if (startHigh == high) {\n+                // The whole range starts in this bucket\n+                currentStartLow = startLow;\n+            } else {\n+                // Add the bucket from the beginning\n+                currentStartLow = 0;\n+            }\n+\n+            long startLowAsLong = Util.toUnsignedLong(currentStartLow);\n+\n+            final long endLowAsLong;\n+            if (endHigh == high) {\n+                // The whole range ends in this bucket\n+                endLowAsLong = Util.toUnsignedLong(endLow);\n+            } else {\n+                // Add the bucket until the end: we have a +1 as, in RoaringBitmap.add(long,long), the end\n+                // is excluded\n+                endLowAsLong = Util.toUnsignedLong(-1) + 1;\n+            }\n+\n+            if (endLowAsLong > startLowAsLong) {\n+                // Initialize the bitmap only if there is access data to write\n+                BitmapDataProvider bitmap = highToBitmap.get(high);\n+                if (bitmap == null) {\n+                    bitmap = new MutableRoaringBitmap();\n+                    pushBitmapForHigh(high, bitmap);\n+                }\n+\n+                if (bitmap instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else if (bitmap instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else {\n+                    throw new UnsupportedOperationException(\"TODO. Not for \" + bitmap.getClass());\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(startHigh);\n+    }\n+\n+    public LongIterator getReverseLongIterator() {\n+        return toIterator(highToBitmap.descendingMap().entrySet().iterator(), true);\n+    }\n+\n+    public void removeLong(long x) {\n+        int high = high(x);\n+\n+        BitmapDataProvider bitmap = highToBitmap.get(high);\n+\n+        if (bitmap != null) {\n+            int low = low(x);\n+            bitmap.remove(low);\n+\n+            // Invalidate only if actually modified\n+            invalidateAboveHigh(high);\n+        }\n+\n+    }\n+\n+    public void trim() {\n+        for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+            bitmap.trim();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return highToBitmap.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        Roaring64Map other = (Roaring64Map) obj;\n+        return Objects.equals(highToBitmap, other.highToBitmap);\n+    }\n+\n+\n+\n+    /**\n+     * Add the value if it is not already present, otherwise remove it.\n+     *\n+     * @param x long value\n+     */\n+    public void flip(final long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            // The value is not added: add it without any flip specific code\n+            addLong(x);\n+        } else {\n+            int low = low(x);\n+\n+            // .flip is not in BitmapDataProvider contract\n+            // TODO Is it relevant to calling .flip with a cast?\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                ((RoaringBitmap) lowBitmap).flip(low);\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                ((MutableRoaringBitmap) lowBitmap).flip(low);\n+            } else {\n+                // Fallback to a manual flip\n+                if (lowBitmap.contains(low)) {\n+                    lowBitmap.remove(low);\n+                } else {\n+                    lowBitmap.add(low);\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /* ------------------ method below from Roaring64NavigableMap and being overwritten ----------------------------- */\n+\n+    /**\n+     * Serialize this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from onve java version\n+     * to another, and from one RoaringBitmap version to another.\n+     *\n+     * Consider calling {@link #runOptimize} before serialization to improve compression.\n+     *\n+     * The current bitmap is not modified.\n+     *\n+     * @param out the DataOutput stream\n+     * @throws IOException Signals that an I/O exception has occurred.\n+     */\n+    public void serialize(DataOutput out) throws IOException {\n+        if (highToBitmap.size() == 0) {\n+            return;\n+        }\n+        if (is32BitsEnough()) {\n+            out.write(BITMAP32);\n+            highToBitmap.get(0).serialize(out);\n+            return;\n+        }\n+\n+        out.write(BITMAP64);\n+        encodeVarint64(highToBitmap.size(), out);\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            out.writeInt(entry.getKey().intValue());\n+            entry.getValue().serialize(out);\n+        }\n+    }\n+\n+\n+    /**\n+     * Deserialize (retrieve) this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from one java version to\n+     * another, and from one RoaringBitmap version to another.\n+     *\n+     * The current bitmap is overwritten.\n+     *\n+     * @param in the DataInput stream\n+     * @throws IOException Signals that an I/O exception has occurred.\n+     */\n+    public void deserialize(DataInput in, int bitmapType) throws IOException {\n+        this.clear();\n+        highToBitmap = new TreeMap<>();\n+\n+        long nbHighs = 1;\n+        if (bitmapType == BITMAP64) {\n+            nbHighs = decodeVarint64(in);\n+        }\n+\n+        for (int i = 0; i < nbHighs; i++) {\n+            int high = in.readInt();\n+            RoaringBitmap provider = new RoaringBitmap();\n+            provider.deserialize(in);\n+\n+            highToBitmap.put(high, provider);\n+        }\n+\n+        resetPerfHelpers();\n+    }\n+\n+\n+\n+    /*---------------------------- method below is new written for doris's own bitmap --------------------------------*/\n+\n+    public boolean is32BitsEnough() {\n+        return highToBitmap.size() == 1 && highToBitmap.get(0) != null;\n+    }\n+\n+    public void add(long value) {\n+        addLong(value);\n+    }\n+\n+    public void add(int value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NDM0NA=="}, "originalCommit": {"oid": "792211134a47d85efb0480cc84a501c871262124"}, "originalPosition": 1377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIwMzQxNQ==", "bodyText": "In Java\uff0cwe could convert signed integer to unsigned integer easily.\nThere is no any reason to change C++ implementation, you should change java implementation.", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396203415", "createdAt": "2020-03-23T04:03:31Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "diffHunk": "@@ -0,0 +1,1484 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.BitmapDataProvider;\n+import org.roaringbitmap.BitmapDataProviderSupplier;\n+import org.roaringbitmap.IntConsumer;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapSupplier;\n+import org.roaringbitmap.Util;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.roaringbitmap.longlong.ImmutableLongBitmapDataProvider;\n+import org.roaringbitmap.longlong.LongConsumer;\n+import org.roaringbitmap.longlong.LongIterator;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import static org.apache.doris.common.util.Util.decodeVarint64;\n+import static org.apache.doris.common.util.Util.encodeVarint64;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP32;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP64;\n+\n+/**\n+ *\n+ * forked version 0.8.13\n+ * major change as below :\n+ *  1. overwrite serialize/deserialize method\n+ *  2. add a new method is32BitsEnough\n+ *  3. fork some Util method from org.roaringbitmap.longlong RoaringIntPacking\n+ * for details to see the end of the class\n+ */\n+public class Roaring64Map {\n+\n+    // Not final to enable initialization in Externalizable.readObject\n+    private NavigableMap<Integer, BitmapDataProvider> highToBitmap;\n+\n+    // If true, we handle longs a plain java longs: -1 if right before 0\n+    // If false, we handle longs as unsigned longs: 0 has no predecessor and Long.MAX_VALUE + 1L is\n+    // expressed as a\n+    // negative long\n+    private boolean signedLongs = false;\n+\n+    private BitmapDataProviderSupplier supplier;\n+\n+    // By default, we cache cardinalities\n+    private transient boolean doCacheCardinalities = true;\n+\n+    // Prevent recomputing all cardinalities when requesting consecutive ranks\n+    private transient int firstHighNotValid = highestHigh() + 1;\n+\n+    // This boolean needs firstHighNotValid == Integer.MAX_VALUE to be allowed to be true\n+    // If false, it means nearly all cumulated cardinalities are valid, except high=Integer.MAX_VALUE\n+    // If true, it means all cumulated cardinalities are valid, even high=Integer.MAX_VALUE\n+    private transient boolean allValid = false;\n+\n+    // TODO: I would prefer not managing arrays myself\n+    private transient long[] sortedCumulatedCardinality = new long[0];\n+    private transient int[] sortedHighs = new int[0];\n+\n+    // We guess consecutive .addLong will be on proximate longs: we remember the bitmap attached to\n+    // this bucket in order\n+    // to skip the indirection\n+    private transient Map.Entry<Integer, BitmapDataProvider> latestAddedHigh = null;\n+\n+    private static final boolean DEFAULT_ORDER_IS_SIGNED = false;\n+    private static final boolean DEFAULT_CARDINALITIES_ARE_CACHED = true;\n+\n+    /**\n+     * By default, we consider longs are unsigned longs: normal longs: 0 is the lowest possible long.\n+     * Long.MAX_VALUE is followed by Long.MIN_VALUE. -1L is the highest possible value\n+     */\n+    public Roaring64Map() {\n+        this(DEFAULT_ORDER_IS_SIGNED);\n+    }\n+\n+    /**\n+     *\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     */\n+    public Roaring64Map(boolean signedLongs) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED);\n+    }\n+\n+    /**\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities) {\n+        this(signedLongs, cacheCardinalities, new RoaringBitmapSupplier());\n+    }\n+\n+    /**\n+     * By default, longs are managed as unsigned longs and cardinalities are cached.\n+     *\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(BitmapDataProviderSupplier supplier) {\n+        this(DEFAULT_ORDER_IS_SIGNED, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     * By default, we activating cardinalities caching.\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, BitmapDataProviderSupplier supplier) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities,\n+                        BitmapDataProviderSupplier supplier) {\n+        this.signedLongs = signedLongs;\n+        this.supplier = supplier;\n+\n+        if (signedLongs) {\n+            highToBitmap = new TreeMap<>();\n+        } else {\n+            highToBitmap = new TreeMap<>(unsignedComparator());\n+        }\n+\n+        this.doCacheCardinalities = cacheCardinalities;\n+        resetPerfHelpers();\n+    }\n+\n+    private void resetPerfHelpers() {\n+        firstHighNotValid = highestHigh(signedLongs) + 1;\n+        allValid = false;\n+\n+        sortedCumulatedCardinality = new long[0];\n+        sortedHighs = new int[0];\n+\n+        latestAddedHigh = null;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    NavigableMap<Integer, BitmapDataProvider> getHighToBitmap() {\n+        return highToBitmap;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    int getLowestInvalidHigh() {\n+        return firstHighNotValid;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    long[] getSortedCumulatedCardinality() {\n+        return sortedCumulatedCardinality;\n+    }\n+\n+    /**\n+     * Add the value to the container (set the value to \"true\"), whether it already appears or not.\n+     *\n+     * Java lacks native unsigned longs but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Long#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 9223372036854775807, -9223372036854775808, -9223372036854775807,..., -1.\n+     *\n+     * @param x long value\n+     */\n+    public void addLong(long x) {\n+        int high = high(x);\n+        int low = low(x);\n+\n+        // Copy the reference to prevent race-condition\n+        Map.Entry<Integer, BitmapDataProvider> local = latestAddedHigh;\n+\n+        BitmapDataProvider bitmap;\n+        if (local != null && local.getKey().intValue() == high) {\n+            bitmap = local.getValue();\n+        } else {\n+            bitmap = highToBitmap.get(high);\n+            if (bitmap == null) {\n+                bitmap = newRoaringBitmap();\n+                pushBitmapForHigh(high, bitmap);\n+            }\n+            latestAddedHigh = new AbstractMap.SimpleImmutableEntry<>(high, bitmap);\n+        }\n+        bitmap.add(low);\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /**\n+     * Add the integer value to the container (set the value to \"true\"), whether it already appears or\n+     * not.\n+     *\n+     * Javac lacks native unsigned integers but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Integer#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 2147483647, -2147483648, -2147483647,..., -1.\n+     *\n+     * @param x integer value\n+     */\n+    public void addInt(int x) {\n+        addLong(Util.toUnsignedLong(x));\n+    }\n+\n+    private BitmapDataProvider newRoaringBitmap() {\n+        return supplier.newEmpty();\n+    }\n+\n+    private void invalidateAboveHigh(int high) {\n+        // The cardinalities after this bucket may not be valid anymore\n+        if (compare(firstHighNotValid, high) > 0) {\n+            // High was valid up to now\n+            firstHighNotValid = high;\n+\n+            int indexNotValid = binarySearch(sortedHighs, firstHighNotValid);\n+\n+            final int indexAfterWhichToReset;\n+            if (indexNotValid >= 0) {\n+                indexAfterWhichToReset = indexNotValid;\n+            } else {\n+                // We have invalidate a high not already present: added a value for a brand new high\n+                indexAfterWhichToReset = -indexNotValid - 1;\n+            }\n+\n+            // This way, sortedHighs remains sorted, without making a new/shorter array\n+            Arrays.fill(sortedHighs, indexAfterWhichToReset, sortedHighs.length, highestHigh());\n+        }\n+        allValid = false;\n+    }\n+\n+    private int compare(int x, int y) {\n+        if (signedLongs) {\n+            return Integer.compare(x, y);\n+        } else {\n+            return compareUnsigned(x, y);\n+        }\n+    }\n+\n+    private void pushBitmapForHigh(int high, BitmapDataProvider bitmap) {\n+        // TODO .size is too slow\n+        // int nbHighBefore = highToBitmap.headMap(high).size();\n+\n+        BitmapDataProvider previous = highToBitmap.put(high, bitmap);\n+        assert previous == null : \"Should push only not-existing high\";\n+    }\n+\n+    /**\n+     * Returns the number of distinct integers added to the bitmap (e.g., number of bits set).\n+     *\n+     * @return the cardinality\n+     */\n+    public long getLongCardinality() {\n+        if (doCacheCardinalities) {\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+            int indexOk = ensureCumulatives(highestHigh());\n+\n+            // ensureCumulatives may have removed empty bitmaps\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+\n+\n+            return sortedCumulatedCardinality[indexOk - 1];\n+        } else {\n+            long cardinality = 0L;\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                cardinality += bitmap.getLongCardinality();\n+            }\n+            return cardinality;\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return the cardinality as an int\n+     *\n+     * @throws UnsupportedOperationException if the cardinality does not fit in an int\n+     */\n+    public int getIntCardinality() throws UnsupportedOperationException {\n+        long cardinality = getLongCardinality();\n+\n+        if (cardinality > Integer.MAX_VALUE) {\n+            // TODO: we should handle cardinality fitting in an unsigned int\n+            throw new UnsupportedOperationException(\n+                    \"Can not call .getIntCardinality as the cardinality is bigger than Integer.MAX_VALUE\");\n+        }\n+\n+        return (int) cardinality;\n+    }\n+\n+    /**\n+     * Return the jth value stored in this bitmap.\n+     *\n+     * @param j index of the value\n+     *\n+     * @return the value\n+     * @throws IllegalArgumentException if j is out of the bounds of the bitmap cardinality\n+     */\n+    public long select(final long j) throws IllegalArgumentException {\n+        if (!doCacheCardinalities) {\n+            return selectNoCache(j);\n+        }\n+\n+        // Ensure all cumulatives as we we have straightforward way to know in advance the high of the\n+        // j-th value\n+        int indexOk = ensureCumulatives(highestHigh());\n+\n+        if (highToBitmap.isEmpty()) {\n+            return throwSelectInvalidIndex(j);\n+        }\n+\n+        // Use normal binarySearch as cardinality does not depends on considering longs signed or\n+        // unsigned\n+        // We need sortedCumulatedCardinality not to contain duplicated, else binarySearch may return\n+        // any of the duplicates: we need to ensure it holds no high associated to an empty bitmap\n+        int position = Arrays.binarySearch(sortedCumulatedCardinality, 0, indexOk, j);\n+\n+        if (position >= 0) {\n+            if (position == indexOk - 1) {\n+                // .select has been called on this.getCardinality\n+                return throwSelectInvalidIndex(j);\n+            }\n+\n+            // There is a bucket leading to this cardinality: the j-th element is the first element of\n+            // next bucket\n+            int high = sortedHighs[position + 1];\n+            BitmapDataProvider nextBitmap = highToBitmap.get(high);\n+            return pack(high, nextBitmap.select(0));\n+        } else {\n+            // There is no bucket with this cardinality\n+            int insertionPoint = -position - 1;\n+\n+            final long previousBucketCardinality;\n+            if (insertionPoint == 0) {\n+                previousBucketCardinality = 0L;\n+            } else if (insertionPoint >= indexOk) {\n+                return throwSelectInvalidIndex(j);\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+\n+            // We get a 'select' query for a single bitmap: should fit in an int\n+            final int givenBitmapSelect = (int) (j - previousBucketCardinality);\n+\n+            int high = sortedHighs[insertionPoint];\n+            BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+            int low = lowBitmap.select(givenBitmapSelect);\n+\n+            return pack(high, low);\n+        }\n+    }\n+\n+    // For benchmarks: compute without using cardinalities cache\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long selectNoCache(long j) {\n+        long left = j;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            long lowCardinality = entry.getValue().getCardinality();\n+\n+            if (left >= lowCardinality) {\n+                left -= lowCardinality;\n+            } else {\n+                // It is legit for left to be negative\n+                int leftAsUnsignedInt = (int) left;\n+                return pack(entry.getKey(), entry.getValue().select(leftAsUnsignedInt));\n+            }\n+        }\n+\n+        return throwSelectInvalidIndex(j);\n+    }\n+\n+    private long throwSelectInvalidIndex(long j) {\n+        // see org.roaringbitmap.buffer.ImmutableRoaringBitmap.select(int)\n+        throw new IllegalArgumentException(\n+                \"select \" + j + \" when the cardinality is \" + this.getLongCardinality());\n+    }\n+\n+    /**\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public Iterator<Long> iterator() {\n+        final LongIterator it = getLongIterator();\n+\n+        return new Iterator<Long>() {\n+\n+            @Override\n+            public boolean hasNext() {\n+                return it.hasNext();\n+            }\n+\n+            @Override\n+            public Long next() {\n+                return it.next();\n+            }\n+\n+            @Override\n+            public void remove() {\n+                // TODO?\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    public void forEach(final LongConsumer lc) {\n+        for (final Map.Entry<Integer, BitmapDataProvider> highEntry : highToBitmap.entrySet()) {\n+            highEntry.getValue().forEach(new IntConsumer() {\n+\n+                @Override\n+                public void accept(int low) {\n+                    lc.accept(pack(highEntry.getKey(), low));\n+                }\n+            });\n+        }\n+    }\n+\n+    public long rankLong(long id) {\n+        int high = high(id);\n+        int low = low(id);\n+\n+        if (!doCacheCardinalities) {\n+            return rankLongNoCache(high, low);\n+        }\n+\n+        int indexOk = ensureCumulatives(high);\n+\n+        int highPosition = binarySearch(sortedHighs, 0, indexOk, high);\n+\n+        if (highPosition >= 0) {\n+            // There is a bucket holding this item\n+\n+            final long previousBucketCardinality;\n+            if (highPosition == 0) {\n+                previousBucketCardinality = 0;\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[highPosition - 1];\n+            }\n+\n+            BitmapDataProvider lowBitmap = highToBitmap.get(sortedHighs[highPosition]);\n+\n+            // Rank is previous cardinality plus rank in current bitmap\n+            return previousBucketCardinality + lowBitmap.rankLong(low);\n+        } else {\n+            // There is no bucket holding this item: insertionPoint is previous bitmap\n+            int insertionPoint = -highPosition - 1;\n+\n+            if (insertionPoint == 0) {\n+                // this key is before all inserted keys\n+                return 0;\n+            } else {\n+                // The rank is the cardinality of this previous bitmap\n+                return sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+        }\n+    }\n+\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long rankLongNoCache(int high, int low) {\n+        long result = 0L;\n+\n+        BitmapDataProvider lastBitmap = highToBitmap.get(high);\n+        if (lastBitmap == null) {\n+            // There is no value with same high: the rank is a sum of cardinalities\n+            for (Map.Entry<Integer, BitmapDataProvider> bitmap : highToBitmap.entrySet()) {\n+                if (bitmap.getKey().intValue() > high) {\n+                    break;\n+                } else {\n+                    result += bitmap.getValue().getLongCardinality();\n+                }\n+            }\n+        } else {\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                if (bitmap == lastBitmap) {\n+                    result += bitmap.rankLong(low);\n+                    break;\n+                } else {\n+                    result += bitmap.getLongCardinality();\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param high for which high bucket should we compute the cardinality\n+     * @return the highest validatedIndex\n+     */\n+    protected int ensureCumulatives(int high) {\n+        if (allValid) {\n+            // the whole array is valid (up-to its actual length, not its capacity)\n+            return highToBitmap.size();\n+        } else if (compare(high, firstHighNotValid) < 0) {\n+            // The high is strictly below the first not valid: it is valid\n+\n+            // sortedHighs may have only a subset of valid values on the right. However, these invalid\n+            // values have been set to maxValue, and we are here as high < firstHighNotValid ==> high <\n+            // maxHigh()\n+            int position = binarySearch(sortedHighs, high);\n+\n+            if (position >= 0) {\n+                // This high has a bitmap: +1 as this index will be used as right (excluded) bound in a\n+                // binary-search\n+                return position + 1;\n+            } else {\n+                // This high has no bitmap: it could be between 2 highs with bitmaps\n+                int insertionPosition = -position - 1;\n+                return insertionPosition;\n+            }\n+        } else {\n+\n+            // For each deprecated buckets\n+            SortedMap<Integer, BitmapDataProvider> tailMap =\n+                    highToBitmap.tailMap(firstHighNotValid, true);\n+\n+            // TODO .size on tailMap make an iterator: arg\n+            int indexOk = highToBitmap.size() - tailMap.size();\n+\n+            // TODO: It should be possible to compute indexOk based on sortedHighs array\n+            // assert indexOk == binarySearch(sortedHighs, firstHighNotValid);\n+\n+            Iterator<Map.Entry<Integer, BitmapDataProvider>> it = tailMap.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry<Integer, BitmapDataProvider> e = it.next();\n+                int currentHigh = e.getKey();\n+\n+                if (compare(currentHigh, high) > 0) {\n+                    // No need to compute more than needed\n+                    break;\n+                } else if (e.getValue().isEmpty()) {\n+                    // highToBitmap can not be modified as we iterate over it\n+                    if (latestAddedHigh != null && latestAddedHigh.getKey().intValue() == currentHigh) {\n+                        // Dismiss the cached bitmap as it is removed from the NavigableMap\n+                        latestAddedHigh = null;\n+                    }\n+                    it.remove();\n+                } else {\n+                    ensureOne(e, currentHigh, indexOk);\n+\n+                    // We have added one valid cardinality\n+                    indexOk++;\n+                }\n+\n+            }\n+\n+            if (highToBitmap.isEmpty() || indexOk == highToBitmap.size()) {\n+                // We have compute all cardinalities\n+                allValid = true;\n+            }\n+\n+            return indexOk;\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, key);\n+        } else {\n+            return unsignedBinarySearch(array, 0, array.length, key,\n+                    unsignedComparator());\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int from, int to, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, from, to, key);\n+        } else {\n+            return unsignedBinarySearch(array, from, to, key, unsignedComparator());\n+        }\n+    }\n+\n+    // From Arrays.binarySearch (Comparator). Check with org.roaringbitmap.Util.unsignedBinarySearch\n+    private static int unsignedBinarySearch(int[] a, int fromIndex, int toIndex, int key,\n+                                            Comparator<? super Integer> c) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+            int midVal = a[mid];\n+            int cmp = c.compare(midVal, key);\n+            if (cmp < 0) {\n+                low = mid + 1;\n+            } else if (cmp > 0) {\n+                high = mid - 1;\n+            } else {\n+                return mid; // key found\n+            }\n+        }\n+        return -(low + 1); // key not found.\n+    }\n+\n+    private void ensureOne(Map.Entry<Integer, BitmapDataProvider> e, int currentHigh, int indexOk) {\n+        // sortedHighs are valid only up to some index\n+        assert indexOk <= sortedHighs.length : indexOk + \" is bigger than \" + sortedHighs.length;\n+\n+        final int index;\n+        if (indexOk == 0) {\n+            if (sortedHighs.length == 0) {\n+                index = -1;\n+                // } else if (sortedHighs[0] == currentHigh) {\n+                // index = 0;\n+            } else {\n+                index = -1;\n+            }\n+        } else if (indexOk < sortedHighs.length) {\n+            index = -indexOk - 1;\n+        } else {\n+            index = -sortedHighs.length - 1;\n+        }\n+        assert index == binarySearch(sortedHighs, 0, indexOk, currentHigh) : \"Computed \" + index\n+                + \" differs from dummy binary-search index: \"\n+                + binarySearch(sortedHighs, 0, indexOk, currentHigh);\n+\n+        if (index >= 0) {\n+            // This would mean calling .ensureOne is useless: should never got here at the first time\n+            throw new IllegalStateException(\"Unexpectedly found \" + currentHigh + \" in \"\n+                    + Arrays.toString(sortedHighs) + \" strictly before index\" + indexOk);\n+        } else {\n+            int insertionPosition = -index - 1;\n+\n+            // This is a new key\n+            if (insertionPosition >= sortedHighs.length) {\n+                int previousSize = sortedHighs.length;\n+\n+                // TODO softer growing factor\n+                int newSize = Math.min(Integer.MAX_VALUE, sortedHighs.length * 2 + 1);\n+\n+                // Insertion at the end\n+                sortedHighs = Arrays.copyOf(sortedHighs, newSize);\n+                sortedCumulatedCardinality = Arrays.copyOf(sortedCumulatedCardinality, newSize);\n+\n+                // Not actually needed. But simplify the reading of array content\n+                Arrays.fill(sortedHighs, previousSize, sortedHighs.length, highestHigh());\n+                Arrays.fill(sortedCumulatedCardinality, previousSize, sortedHighs.length, Long.MAX_VALUE);\n+            }\n+            sortedHighs[insertionPosition] = currentHigh;\n+\n+            final long previousCardinality;\n+            if (insertionPosition >= 1) {\n+                previousCardinality = sortedCumulatedCardinality[insertionPosition - 1];\n+            } else {\n+                previousCardinality = 0;\n+            }\n+\n+            sortedCumulatedCardinality[insertionPosition] =\n+                    previousCardinality + e.getValue().getLongCardinality();\n+\n+            if (currentHigh == highestHigh()) {\n+                // We are already on the highest high. Do not set allValid as it is set anyway out of the\n+                // loop\n+                firstHighNotValid = currentHigh;\n+            } else {\n+                // The first not valid is the next high\n+                // TODO: The entry comes from a NavigableMap: it may be quite cheap to know the next high\n+                firstHighNotValid = currentHigh + 1;\n+            }\n+        }\n+    }\n+\n+\n+\n+    private int highestHigh() {\n+        return highestHigh(signedLongs);\n+    }\n+\n+    /**\n+     * In-place bitwise OR (union) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void or(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).or((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).or((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise XOR (symmetric difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void xor(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).xor((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).xor((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void and(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 == null) {\n+                // None of given high values are present in x2\n+                thisIterator.remove();\n+            } else {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).and((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).and((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * In-place bitwise ANDNOT (difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void andNot(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 != null) {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).andNot((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).andNot((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A string describing the bitmap.\n+     *\n+     * @return the string\n+     */\n+    @Override\n+    public String toString() {\n+        final StringBuilder answer = new StringBuilder();\n+        final LongIterator i = this.getLongIterator();\n+        answer.append(\"{\");\n+        if (i.hasNext()) {\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+        }\n+        while (i.hasNext()) {\n+            answer.append(\",\");\n+            // to avoid using too much memory, we limit the size\n+            if (answer.length() > 0x80000) {\n+                answer.append(\"...\");\n+                break;\n+            }\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+\n+        }\n+        answer.append(\"}\");\n+        return answer.toString();\n+    }\n+\n+\n+    /**\n+     *\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public LongIterator getLongIterator() {\n+        final Iterator<Map.Entry<Integer, BitmapDataProvider>> it = highToBitmap.entrySet().iterator();\n+\n+        return toIterator(it, false);\n+    }\n+\n+    protected LongIterator toIterator(final Iterator<Map.Entry<Integer, BitmapDataProvider>> it,\n+                                      final boolean reversed) {\n+        return new LongIterator() {\n+\n+            protected int currentKey;\n+            protected IntIterator currentIt;\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (currentIt == null) {\n+                    // Were initially empty\n+                    if (!moveToNextEntry(it)) {\n+                        return false;\n+                    }\n+                }\n+\n+                while (true) {\n+                    if (currentIt.hasNext()) {\n+                        return true;\n+                    } else {\n+                        if (!moveToNextEntry(it)) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            /**\n+             *\n+             * @param it the underlying iterator which has to be moved to next long\n+             * @return true if we MAY have more entries. false if there is definitely nothing more\n+             */\n+            private boolean moveToNextEntry(Iterator<Map.Entry<Integer, BitmapDataProvider>> it) {\n+                if (it.hasNext()) {\n+                    Map.Entry<Integer, BitmapDataProvider> next = it.next();\n+                    currentKey = next.getKey();\n+                    if (reversed) {\n+                        currentIt = next.getValue().getReverseIntIterator();\n+                    } else {\n+                        currentIt = next.getValue().getIntIterator();\n+                    }\n+\n+                    // We may have more long\n+                    return true;\n+                } else {\n+                    // We know there is nothing more\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public long next() {\n+                if (hasNext()) {\n+                    return pack(currentKey, currentIt.next());\n+                } else {\n+                    throw new IllegalStateException(\"empty\");\n+                }\n+            }\n+\n+            @Override\n+            public LongIterator clone() {\n+                throw new UnsupportedOperationException(\"TODO\");\n+            }\n+        };\n+    }\n+\n+    public boolean contains(long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            return false;\n+        }\n+\n+        int low = low(x);\n+        return lowBitmap.contains(low);\n+    }\n+\n+\n+    public int getSizeInBytes() {\n+        return (int) getLongSizeInBytes();\n+    }\n+\n+    public long getLongSizeInBytes() {\n+        long size = 8;\n+\n+        // Size of containers\n+        size += highToBitmap.values().stream().mapToLong(p -> p.getLongSizeInBytes()).sum();\n+\n+        // Size of Map data-structure: we consider each TreeMap entry costs 40 bytes\n+        // http://java-performance.info/memory-consumption-of-java-data-types-2/\n+        size += 8 + 40 * highToBitmap.size();\n+\n+        // Size of (boxed) Integers used as keys\n+        size += 16 * highToBitmap.size();\n+\n+        // The cache impacts the size in heap\n+        size += 8 * sortedCumulatedCardinality.length;\n+        size += 4 * sortedHighs.length;\n+\n+        return size;\n+    }\n+\n+    public boolean isEmpty() {\n+        return getLongCardinality() == 0L;\n+    }\n+\n+    public ImmutableLongBitmapDataProvider limit(long x) {\n+        throw new UnsupportedOperationException(\"TODO\");\n+    }\n+\n+    /**\n+     * Use a run-length encoding where it is estimated as more space efficient\n+     *\n+     * @return whether a change was applied\n+     */\n+    public boolean runOptimize() {\n+        boolean hasChanged = false;\n+        for (BitmapDataProvider lowBitmap : highToBitmap.values()) {\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                hasChanged |= ((RoaringBitmap) lowBitmap).runOptimize();\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                hasChanged |= ((MutableRoaringBitmap) lowBitmap).runOptimize();\n+            }\n+        }\n+        return hasChanged;\n+    }\n+\n+    public long serializedSizeInBytes() {\n+        long nbBytes = 0L;\n+\n+        // .writeBoolean for signedLongs boolean\n+        nbBytes += 1;\n+\n+        // .writeInt for number of different high values\n+        nbBytes += 4;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            // .writeInt for high\n+            nbBytes += 4;\n+\n+            // The low bitmap size in bytes\n+            nbBytes += entry.getValue().serializedSizeInBytes();\n+        }\n+\n+        return nbBytes;\n+    }\n+\n+    /**\n+     * reset to an empty bitmap; result occupies as much space a newly created bitmap.\n+     */\n+    public void clear() {\n+        this.highToBitmap.clear();\n+        resetPerfHelpers();\n+    }\n+\n+    /**\n+     * Return the set values as an array, if the cardinality is smaller than 2147483648. The long\n+     * values are in sorted order.\n+     *\n+     * @return array representing the set values.\n+     */\n+    public long[] toArray() {\n+        long cardinality = this.getLongCardinality();\n+        if (cardinality > Integer.MAX_VALUE) {\n+            throw new IllegalStateException(\"The cardinality does not fit in an array\");\n+        }\n+\n+        final long[] array = new long[(int) cardinality];\n+\n+        int pos = 0;\n+        LongIterator it = getLongIterator();\n+\n+        while (it.hasNext()) {\n+            array[pos++] = it.next();\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Generate a bitmap with the specified values set to true. The provided longs values don't have\n+     * to be in sorted order, but it may be preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     * @return a new bitmap\n+     */\n+    public static Roaring64Map bitmapOf(final long... dat) {\n+        final Roaring64Map ans = new Roaring64Map();\n+        ans.add(dat);\n+        return ans;\n+    }\n+\n+    /**\n+     * Set all the specified values to true. This can be expected to be slightly faster than calling\n+     * \"add\" repeatedly. The provided integers values don't have to be in sorted order, but it may be\n+     * preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     */\n+    public void add(long... dat) {\n+        for (long oneLong : dat) {\n+            addLong(oneLong);\n+        }\n+    }\n+\n+    /**\n+     * Add to the current bitmap all longs in [rangeStart,rangeEnd).\n+     *\n+     * @param rangeStart inclusive beginning of range\n+     * @param rangeEnd exclusive ending of range\n+     */\n+    public void add(final long rangeStart, final long rangeEnd) {\n+        int startHigh = high(rangeStart);\n+        int startLow = low(rangeStart);\n+\n+        int endHigh = high(rangeEnd);\n+        int endLow = low(rangeEnd);\n+\n+        for (int high = startHigh; high <= endHigh; high++) {\n+            final int currentStartLow;\n+            if (startHigh == high) {\n+                // The whole range starts in this bucket\n+                currentStartLow = startLow;\n+            } else {\n+                // Add the bucket from the beginning\n+                currentStartLow = 0;\n+            }\n+\n+            long startLowAsLong = Util.toUnsignedLong(currentStartLow);\n+\n+            final long endLowAsLong;\n+            if (endHigh == high) {\n+                // The whole range ends in this bucket\n+                endLowAsLong = Util.toUnsignedLong(endLow);\n+            } else {\n+                // Add the bucket until the end: we have a +1 as, in RoaringBitmap.add(long,long), the end\n+                // is excluded\n+                endLowAsLong = Util.toUnsignedLong(-1) + 1;\n+            }\n+\n+            if (endLowAsLong > startLowAsLong) {\n+                // Initialize the bitmap only if there is access data to write\n+                BitmapDataProvider bitmap = highToBitmap.get(high);\n+                if (bitmap == null) {\n+                    bitmap = new MutableRoaringBitmap();\n+                    pushBitmapForHigh(high, bitmap);\n+                }\n+\n+                if (bitmap instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else if (bitmap instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else {\n+                    throw new UnsupportedOperationException(\"TODO. Not for \" + bitmap.getClass());\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(startHigh);\n+    }\n+\n+    public LongIterator getReverseLongIterator() {\n+        return toIterator(highToBitmap.descendingMap().entrySet().iterator(), true);\n+    }\n+\n+    public void removeLong(long x) {\n+        int high = high(x);\n+\n+        BitmapDataProvider bitmap = highToBitmap.get(high);\n+\n+        if (bitmap != null) {\n+            int low = low(x);\n+            bitmap.remove(low);\n+\n+            // Invalidate only if actually modified\n+            invalidateAboveHigh(high);\n+        }\n+\n+    }\n+\n+    public void trim() {\n+        for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+            bitmap.trim();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return highToBitmap.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        Roaring64Map other = (Roaring64Map) obj;\n+        return Objects.equals(highToBitmap, other.highToBitmap);\n+    }\n+\n+\n+\n+    /**\n+     * Add the value if it is not already present, otherwise remove it.\n+     *\n+     * @param x long value\n+     */\n+    public void flip(final long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            // The value is not added: add it without any flip specific code\n+            addLong(x);\n+        } else {\n+            int low = low(x);\n+\n+            // .flip is not in BitmapDataProvider contract\n+            // TODO Is it relevant to calling .flip with a cast?\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                ((RoaringBitmap) lowBitmap).flip(low);\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                ((MutableRoaringBitmap) lowBitmap).flip(low);\n+            } else {\n+                // Fallback to a manual flip\n+                if (lowBitmap.contains(low)) {\n+                    lowBitmap.remove(low);\n+                } else {\n+                    lowBitmap.add(low);\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /* ------------------ method below from Roaring64NavigableMap and being overwritten ----------------------------- */\n+\n+    /**\n+     * Serialize this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from onve java version\n+     * to another, and from one RoaringBitmap version to another.\n+     *\n+     * Consider calling {@link #runOptimize} before serialization to improve compression.\n+     *\n+     * The current bitmap is not modified.\n+     *\n+     * @param out the DataOutput stream\n+     * @throws IOException Signals that an I/O exception has occurred.\n+     */\n+    public void serialize(DataOutput out) throws IOException {\n+        if (highToBitmap.size() == 0) {\n+            return;\n+        }\n+        if (is32BitsEnough()) {\n+            out.write(BITMAP32);\n+            highToBitmap.get(0).serialize(out);\n+            return;\n+        }\n+\n+        out.write(BITMAP64);\n+        encodeVarint64(highToBitmap.size(), out);\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            out.writeInt(entry.getKey().intValue());\n+            entry.getValue().serialize(out);\n+        }\n+    }\n+\n+\n+    /**\n+     * Deserialize (retrieve) this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from one java version to\n+     * another, and from one RoaringBitmap version to another.\n+     *\n+     * The current bitmap is overwritten.\n+     *\n+     * @param in the DataInput stream\n+     * @throws IOException Signals that an I/O exception has occurred.\n+     */\n+    public void deserialize(DataInput in, int bitmapType) throws IOException {\n+        this.clear();\n+        highToBitmap = new TreeMap<>();\n+\n+        long nbHighs = 1;\n+        if (bitmapType == BITMAP64) {\n+            nbHighs = decodeVarint64(in);\n+        }\n+\n+        for (int i = 0; i < nbHighs; i++) {\n+            int high = in.readInt();\n+            RoaringBitmap provider = new RoaringBitmap();\n+            provider.deserialize(in);\n+\n+            highToBitmap.put(high, provider);\n+        }\n+\n+        resetPerfHelpers();\n+    }\n+\n+\n+\n+    /*---------------------------- method below is new written for doris's own bitmap --------------------------------*/\n+\n+    public boolean is32BitsEnough() {\n+        return highToBitmap.size() == 1 && highToBitmap.get(0) != null;\n+    }\n+\n+    public void add(long value) {\n+        addLong(value);\n+    }\n+\n+    public void add(int value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NDM0NA=="}, "originalCommit": {"oid": "792211134a47d85efb0480cc84a501c871262124"}, "originalPosition": 1377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyODc3NA==", "bodyText": "OK.\nNow for Doris's  BitmapValue,\njava version support range [0, Long.MAX_VALUE]\nC++ version support range [0,Long.MAX_VALUE * 2]", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396328774", "createdAt": "2020-03-23T09:54:33Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "diffHunk": "@@ -0,0 +1,1484 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.BitmapDataProvider;\n+import org.roaringbitmap.BitmapDataProviderSupplier;\n+import org.roaringbitmap.IntConsumer;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapSupplier;\n+import org.roaringbitmap.Util;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.roaringbitmap.longlong.ImmutableLongBitmapDataProvider;\n+import org.roaringbitmap.longlong.LongConsumer;\n+import org.roaringbitmap.longlong.LongIterator;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import static org.apache.doris.common.util.Util.decodeVarint64;\n+import static org.apache.doris.common.util.Util.encodeVarint64;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP32;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP64;\n+\n+/**\n+ *\n+ * forked version 0.8.13\n+ * major change as below :\n+ *  1. overwrite serialize/deserialize method\n+ *  2. add a new method is32BitsEnough\n+ *  3. fork some Util method from org.roaringbitmap.longlong RoaringIntPacking\n+ * for details to see the end of the class\n+ */\n+public class Roaring64Map {\n+\n+    // Not final to enable initialization in Externalizable.readObject\n+    private NavigableMap<Integer, BitmapDataProvider> highToBitmap;\n+\n+    // If true, we handle longs a plain java longs: -1 if right before 0\n+    // If false, we handle longs as unsigned longs: 0 has no predecessor and Long.MAX_VALUE + 1L is\n+    // expressed as a\n+    // negative long\n+    private boolean signedLongs = false;\n+\n+    private BitmapDataProviderSupplier supplier;\n+\n+    // By default, we cache cardinalities\n+    private transient boolean doCacheCardinalities = true;\n+\n+    // Prevent recomputing all cardinalities when requesting consecutive ranks\n+    private transient int firstHighNotValid = highestHigh() + 1;\n+\n+    // This boolean needs firstHighNotValid == Integer.MAX_VALUE to be allowed to be true\n+    // If false, it means nearly all cumulated cardinalities are valid, except high=Integer.MAX_VALUE\n+    // If true, it means all cumulated cardinalities are valid, even high=Integer.MAX_VALUE\n+    private transient boolean allValid = false;\n+\n+    // TODO: I would prefer not managing arrays myself\n+    private transient long[] sortedCumulatedCardinality = new long[0];\n+    private transient int[] sortedHighs = new int[0];\n+\n+    // We guess consecutive .addLong will be on proximate longs: we remember the bitmap attached to\n+    // this bucket in order\n+    // to skip the indirection\n+    private transient Map.Entry<Integer, BitmapDataProvider> latestAddedHigh = null;\n+\n+    private static final boolean DEFAULT_ORDER_IS_SIGNED = false;\n+    private static final boolean DEFAULT_CARDINALITIES_ARE_CACHED = true;\n+\n+    /**\n+     * By default, we consider longs are unsigned longs: normal longs: 0 is the lowest possible long.\n+     * Long.MAX_VALUE is followed by Long.MIN_VALUE. -1L is the highest possible value\n+     */\n+    public Roaring64Map() {\n+        this(DEFAULT_ORDER_IS_SIGNED);\n+    }\n+\n+    /**\n+     *\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     */\n+    public Roaring64Map(boolean signedLongs) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED);\n+    }\n+\n+    /**\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities) {\n+        this(signedLongs, cacheCardinalities, new RoaringBitmapSupplier());\n+    }\n+\n+    /**\n+     * By default, longs are managed as unsigned longs and cardinalities are cached.\n+     *\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(BitmapDataProviderSupplier supplier) {\n+        this(DEFAULT_ORDER_IS_SIGNED, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     * By default, we activating cardinalities caching.\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, BitmapDataProviderSupplier supplier) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities,\n+                        BitmapDataProviderSupplier supplier) {\n+        this.signedLongs = signedLongs;\n+        this.supplier = supplier;\n+\n+        if (signedLongs) {\n+            highToBitmap = new TreeMap<>();\n+        } else {\n+            highToBitmap = new TreeMap<>(unsignedComparator());\n+        }\n+\n+        this.doCacheCardinalities = cacheCardinalities;\n+        resetPerfHelpers();\n+    }\n+\n+    private void resetPerfHelpers() {\n+        firstHighNotValid = highestHigh(signedLongs) + 1;\n+        allValid = false;\n+\n+        sortedCumulatedCardinality = new long[0];\n+        sortedHighs = new int[0];\n+\n+        latestAddedHigh = null;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    NavigableMap<Integer, BitmapDataProvider> getHighToBitmap() {\n+        return highToBitmap;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    int getLowestInvalidHigh() {\n+        return firstHighNotValid;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    long[] getSortedCumulatedCardinality() {\n+        return sortedCumulatedCardinality;\n+    }\n+\n+    /**\n+     * Add the value to the container (set the value to \"true\"), whether it already appears or not.\n+     *\n+     * Java lacks native unsigned longs but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Long#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 9223372036854775807, -9223372036854775808, -9223372036854775807,..., -1.\n+     *\n+     * @param x long value\n+     */\n+    public void addLong(long x) {\n+        int high = high(x);\n+        int low = low(x);\n+\n+        // Copy the reference to prevent race-condition\n+        Map.Entry<Integer, BitmapDataProvider> local = latestAddedHigh;\n+\n+        BitmapDataProvider bitmap;\n+        if (local != null && local.getKey().intValue() == high) {\n+            bitmap = local.getValue();\n+        } else {\n+            bitmap = highToBitmap.get(high);\n+            if (bitmap == null) {\n+                bitmap = newRoaringBitmap();\n+                pushBitmapForHigh(high, bitmap);\n+            }\n+            latestAddedHigh = new AbstractMap.SimpleImmutableEntry<>(high, bitmap);\n+        }\n+        bitmap.add(low);\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /**\n+     * Add the integer value to the container (set the value to \"true\"), whether it already appears or\n+     * not.\n+     *\n+     * Javac lacks native unsigned integers but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Integer#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 2147483647, -2147483648, -2147483647,..., -1.\n+     *\n+     * @param x integer value\n+     */\n+    public void addInt(int x) {\n+        addLong(Util.toUnsignedLong(x));\n+    }\n+\n+    private BitmapDataProvider newRoaringBitmap() {\n+        return supplier.newEmpty();\n+    }\n+\n+    private void invalidateAboveHigh(int high) {\n+        // The cardinalities after this bucket may not be valid anymore\n+        if (compare(firstHighNotValid, high) > 0) {\n+            // High was valid up to now\n+            firstHighNotValid = high;\n+\n+            int indexNotValid = binarySearch(sortedHighs, firstHighNotValid);\n+\n+            final int indexAfterWhichToReset;\n+            if (indexNotValid >= 0) {\n+                indexAfterWhichToReset = indexNotValid;\n+            } else {\n+                // We have invalidate a high not already present: added a value for a brand new high\n+                indexAfterWhichToReset = -indexNotValid - 1;\n+            }\n+\n+            // This way, sortedHighs remains sorted, without making a new/shorter array\n+            Arrays.fill(sortedHighs, indexAfterWhichToReset, sortedHighs.length, highestHigh());\n+        }\n+        allValid = false;\n+    }\n+\n+    private int compare(int x, int y) {\n+        if (signedLongs) {\n+            return Integer.compare(x, y);\n+        } else {\n+            return compareUnsigned(x, y);\n+        }\n+    }\n+\n+    private void pushBitmapForHigh(int high, BitmapDataProvider bitmap) {\n+        // TODO .size is too slow\n+        // int nbHighBefore = highToBitmap.headMap(high).size();\n+\n+        BitmapDataProvider previous = highToBitmap.put(high, bitmap);\n+        assert previous == null : \"Should push only not-existing high\";\n+    }\n+\n+    /**\n+     * Returns the number of distinct integers added to the bitmap (e.g., number of bits set).\n+     *\n+     * @return the cardinality\n+     */\n+    public long getLongCardinality() {\n+        if (doCacheCardinalities) {\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+            int indexOk = ensureCumulatives(highestHigh());\n+\n+            // ensureCumulatives may have removed empty bitmaps\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+\n+\n+            return sortedCumulatedCardinality[indexOk - 1];\n+        } else {\n+            long cardinality = 0L;\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                cardinality += bitmap.getLongCardinality();\n+            }\n+            return cardinality;\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return the cardinality as an int\n+     *\n+     * @throws UnsupportedOperationException if the cardinality does not fit in an int\n+     */\n+    public int getIntCardinality() throws UnsupportedOperationException {\n+        long cardinality = getLongCardinality();\n+\n+        if (cardinality > Integer.MAX_VALUE) {\n+            // TODO: we should handle cardinality fitting in an unsigned int\n+            throw new UnsupportedOperationException(\n+                    \"Can not call .getIntCardinality as the cardinality is bigger than Integer.MAX_VALUE\");\n+        }\n+\n+        return (int) cardinality;\n+    }\n+\n+    /**\n+     * Return the jth value stored in this bitmap.\n+     *\n+     * @param j index of the value\n+     *\n+     * @return the value\n+     * @throws IllegalArgumentException if j is out of the bounds of the bitmap cardinality\n+     */\n+    public long select(final long j) throws IllegalArgumentException {\n+        if (!doCacheCardinalities) {\n+            return selectNoCache(j);\n+        }\n+\n+        // Ensure all cumulatives as we we have straightforward way to know in advance the high of the\n+        // j-th value\n+        int indexOk = ensureCumulatives(highestHigh());\n+\n+        if (highToBitmap.isEmpty()) {\n+            return throwSelectInvalidIndex(j);\n+        }\n+\n+        // Use normal binarySearch as cardinality does not depends on considering longs signed or\n+        // unsigned\n+        // We need sortedCumulatedCardinality not to contain duplicated, else binarySearch may return\n+        // any of the duplicates: we need to ensure it holds no high associated to an empty bitmap\n+        int position = Arrays.binarySearch(sortedCumulatedCardinality, 0, indexOk, j);\n+\n+        if (position >= 0) {\n+            if (position == indexOk - 1) {\n+                // .select has been called on this.getCardinality\n+                return throwSelectInvalidIndex(j);\n+            }\n+\n+            // There is a bucket leading to this cardinality: the j-th element is the first element of\n+            // next bucket\n+            int high = sortedHighs[position + 1];\n+            BitmapDataProvider nextBitmap = highToBitmap.get(high);\n+            return pack(high, nextBitmap.select(0));\n+        } else {\n+            // There is no bucket with this cardinality\n+            int insertionPoint = -position - 1;\n+\n+            final long previousBucketCardinality;\n+            if (insertionPoint == 0) {\n+                previousBucketCardinality = 0L;\n+            } else if (insertionPoint >= indexOk) {\n+                return throwSelectInvalidIndex(j);\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+\n+            // We get a 'select' query for a single bitmap: should fit in an int\n+            final int givenBitmapSelect = (int) (j - previousBucketCardinality);\n+\n+            int high = sortedHighs[insertionPoint];\n+            BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+            int low = lowBitmap.select(givenBitmapSelect);\n+\n+            return pack(high, low);\n+        }\n+    }\n+\n+    // For benchmarks: compute without using cardinalities cache\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long selectNoCache(long j) {\n+        long left = j;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            long lowCardinality = entry.getValue().getCardinality();\n+\n+            if (left >= lowCardinality) {\n+                left -= lowCardinality;\n+            } else {\n+                // It is legit for left to be negative\n+                int leftAsUnsignedInt = (int) left;\n+                return pack(entry.getKey(), entry.getValue().select(leftAsUnsignedInt));\n+            }\n+        }\n+\n+        return throwSelectInvalidIndex(j);\n+    }\n+\n+    private long throwSelectInvalidIndex(long j) {\n+        // see org.roaringbitmap.buffer.ImmutableRoaringBitmap.select(int)\n+        throw new IllegalArgumentException(\n+                \"select \" + j + \" when the cardinality is \" + this.getLongCardinality());\n+    }\n+\n+    /**\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public Iterator<Long> iterator() {\n+        final LongIterator it = getLongIterator();\n+\n+        return new Iterator<Long>() {\n+\n+            @Override\n+            public boolean hasNext() {\n+                return it.hasNext();\n+            }\n+\n+            @Override\n+            public Long next() {\n+                return it.next();\n+            }\n+\n+            @Override\n+            public void remove() {\n+                // TODO?\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    public void forEach(final LongConsumer lc) {\n+        for (final Map.Entry<Integer, BitmapDataProvider> highEntry : highToBitmap.entrySet()) {\n+            highEntry.getValue().forEach(new IntConsumer() {\n+\n+                @Override\n+                public void accept(int low) {\n+                    lc.accept(pack(highEntry.getKey(), low));\n+                }\n+            });\n+        }\n+    }\n+\n+    public long rankLong(long id) {\n+        int high = high(id);\n+        int low = low(id);\n+\n+        if (!doCacheCardinalities) {\n+            return rankLongNoCache(high, low);\n+        }\n+\n+        int indexOk = ensureCumulatives(high);\n+\n+        int highPosition = binarySearch(sortedHighs, 0, indexOk, high);\n+\n+        if (highPosition >= 0) {\n+            // There is a bucket holding this item\n+\n+            final long previousBucketCardinality;\n+            if (highPosition == 0) {\n+                previousBucketCardinality = 0;\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[highPosition - 1];\n+            }\n+\n+            BitmapDataProvider lowBitmap = highToBitmap.get(sortedHighs[highPosition]);\n+\n+            // Rank is previous cardinality plus rank in current bitmap\n+            return previousBucketCardinality + lowBitmap.rankLong(low);\n+        } else {\n+            // There is no bucket holding this item: insertionPoint is previous bitmap\n+            int insertionPoint = -highPosition - 1;\n+\n+            if (insertionPoint == 0) {\n+                // this key is before all inserted keys\n+                return 0;\n+            } else {\n+                // The rank is the cardinality of this previous bitmap\n+                return sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+        }\n+    }\n+\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long rankLongNoCache(int high, int low) {\n+        long result = 0L;\n+\n+        BitmapDataProvider lastBitmap = highToBitmap.get(high);\n+        if (lastBitmap == null) {\n+            // There is no value with same high: the rank is a sum of cardinalities\n+            for (Map.Entry<Integer, BitmapDataProvider> bitmap : highToBitmap.entrySet()) {\n+                if (bitmap.getKey().intValue() > high) {\n+                    break;\n+                } else {\n+                    result += bitmap.getValue().getLongCardinality();\n+                }\n+            }\n+        } else {\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                if (bitmap == lastBitmap) {\n+                    result += bitmap.rankLong(low);\n+                    break;\n+                } else {\n+                    result += bitmap.getLongCardinality();\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param high for which high bucket should we compute the cardinality\n+     * @return the highest validatedIndex\n+     */\n+    protected int ensureCumulatives(int high) {\n+        if (allValid) {\n+            // the whole array is valid (up-to its actual length, not its capacity)\n+            return highToBitmap.size();\n+        } else if (compare(high, firstHighNotValid) < 0) {\n+            // The high is strictly below the first not valid: it is valid\n+\n+            // sortedHighs may have only a subset of valid values on the right. However, these invalid\n+            // values have been set to maxValue, and we are here as high < firstHighNotValid ==> high <\n+            // maxHigh()\n+            int position = binarySearch(sortedHighs, high);\n+\n+            if (position >= 0) {\n+                // This high has a bitmap: +1 as this index will be used as right (excluded) bound in a\n+                // binary-search\n+                return position + 1;\n+            } else {\n+                // This high has no bitmap: it could be between 2 highs with bitmaps\n+                int insertionPosition = -position - 1;\n+                return insertionPosition;\n+            }\n+        } else {\n+\n+            // For each deprecated buckets\n+            SortedMap<Integer, BitmapDataProvider> tailMap =\n+                    highToBitmap.tailMap(firstHighNotValid, true);\n+\n+            // TODO .size on tailMap make an iterator: arg\n+            int indexOk = highToBitmap.size() - tailMap.size();\n+\n+            // TODO: It should be possible to compute indexOk based on sortedHighs array\n+            // assert indexOk == binarySearch(sortedHighs, firstHighNotValid);\n+\n+            Iterator<Map.Entry<Integer, BitmapDataProvider>> it = tailMap.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry<Integer, BitmapDataProvider> e = it.next();\n+                int currentHigh = e.getKey();\n+\n+                if (compare(currentHigh, high) > 0) {\n+                    // No need to compute more than needed\n+                    break;\n+                } else if (e.getValue().isEmpty()) {\n+                    // highToBitmap can not be modified as we iterate over it\n+                    if (latestAddedHigh != null && latestAddedHigh.getKey().intValue() == currentHigh) {\n+                        // Dismiss the cached bitmap as it is removed from the NavigableMap\n+                        latestAddedHigh = null;\n+                    }\n+                    it.remove();\n+                } else {\n+                    ensureOne(e, currentHigh, indexOk);\n+\n+                    // We have added one valid cardinality\n+                    indexOk++;\n+                }\n+\n+            }\n+\n+            if (highToBitmap.isEmpty() || indexOk == highToBitmap.size()) {\n+                // We have compute all cardinalities\n+                allValid = true;\n+            }\n+\n+            return indexOk;\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, key);\n+        } else {\n+            return unsignedBinarySearch(array, 0, array.length, key,\n+                    unsignedComparator());\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int from, int to, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, from, to, key);\n+        } else {\n+            return unsignedBinarySearch(array, from, to, key, unsignedComparator());\n+        }\n+    }\n+\n+    // From Arrays.binarySearch (Comparator). Check with org.roaringbitmap.Util.unsignedBinarySearch\n+    private static int unsignedBinarySearch(int[] a, int fromIndex, int toIndex, int key,\n+                                            Comparator<? super Integer> c) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+            int midVal = a[mid];\n+            int cmp = c.compare(midVal, key);\n+            if (cmp < 0) {\n+                low = mid + 1;\n+            } else if (cmp > 0) {\n+                high = mid - 1;\n+            } else {\n+                return mid; // key found\n+            }\n+        }\n+        return -(low + 1); // key not found.\n+    }\n+\n+    private void ensureOne(Map.Entry<Integer, BitmapDataProvider> e, int currentHigh, int indexOk) {\n+        // sortedHighs are valid only up to some index\n+        assert indexOk <= sortedHighs.length : indexOk + \" is bigger than \" + sortedHighs.length;\n+\n+        final int index;\n+        if (indexOk == 0) {\n+            if (sortedHighs.length == 0) {\n+                index = -1;\n+                // } else if (sortedHighs[0] == currentHigh) {\n+                // index = 0;\n+            } else {\n+                index = -1;\n+            }\n+        } else if (indexOk < sortedHighs.length) {\n+            index = -indexOk - 1;\n+        } else {\n+            index = -sortedHighs.length - 1;\n+        }\n+        assert index == binarySearch(sortedHighs, 0, indexOk, currentHigh) : \"Computed \" + index\n+                + \" differs from dummy binary-search index: \"\n+                + binarySearch(sortedHighs, 0, indexOk, currentHigh);\n+\n+        if (index >= 0) {\n+            // This would mean calling .ensureOne is useless: should never got here at the first time\n+            throw new IllegalStateException(\"Unexpectedly found \" + currentHigh + \" in \"\n+                    + Arrays.toString(sortedHighs) + \" strictly before index\" + indexOk);\n+        } else {\n+            int insertionPosition = -index - 1;\n+\n+            // This is a new key\n+            if (insertionPosition >= sortedHighs.length) {\n+                int previousSize = sortedHighs.length;\n+\n+                // TODO softer growing factor\n+                int newSize = Math.min(Integer.MAX_VALUE, sortedHighs.length * 2 + 1);\n+\n+                // Insertion at the end\n+                sortedHighs = Arrays.copyOf(sortedHighs, newSize);\n+                sortedCumulatedCardinality = Arrays.copyOf(sortedCumulatedCardinality, newSize);\n+\n+                // Not actually needed. But simplify the reading of array content\n+                Arrays.fill(sortedHighs, previousSize, sortedHighs.length, highestHigh());\n+                Arrays.fill(sortedCumulatedCardinality, previousSize, sortedHighs.length, Long.MAX_VALUE);\n+            }\n+            sortedHighs[insertionPosition] = currentHigh;\n+\n+            final long previousCardinality;\n+            if (insertionPosition >= 1) {\n+                previousCardinality = sortedCumulatedCardinality[insertionPosition - 1];\n+            } else {\n+                previousCardinality = 0;\n+            }\n+\n+            sortedCumulatedCardinality[insertionPosition] =\n+                    previousCardinality + e.getValue().getLongCardinality();\n+\n+            if (currentHigh == highestHigh()) {\n+                // We are already on the highest high. Do not set allValid as it is set anyway out of the\n+                // loop\n+                firstHighNotValid = currentHigh;\n+            } else {\n+                // The first not valid is the next high\n+                // TODO: The entry comes from a NavigableMap: it may be quite cheap to know the next high\n+                firstHighNotValid = currentHigh + 1;\n+            }\n+        }\n+    }\n+\n+\n+\n+    private int highestHigh() {\n+        return highestHigh(signedLongs);\n+    }\n+\n+    /**\n+     * In-place bitwise OR (union) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void or(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).or((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).or((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise XOR (symmetric difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void xor(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).xor((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).xor((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void and(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 == null) {\n+                // None of given high values are present in x2\n+                thisIterator.remove();\n+            } else {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).and((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).and((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * In-place bitwise ANDNOT (difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void andNot(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 != null) {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).andNot((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).andNot((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A string describing the bitmap.\n+     *\n+     * @return the string\n+     */\n+    @Override\n+    public String toString() {\n+        final StringBuilder answer = new StringBuilder();\n+        final LongIterator i = this.getLongIterator();\n+        answer.append(\"{\");\n+        if (i.hasNext()) {\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+        }\n+        while (i.hasNext()) {\n+            answer.append(\",\");\n+            // to avoid using too much memory, we limit the size\n+            if (answer.length() > 0x80000) {\n+                answer.append(\"...\");\n+                break;\n+            }\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+\n+        }\n+        answer.append(\"}\");\n+        return answer.toString();\n+    }\n+\n+\n+    /**\n+     *\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public LongIterator getLongIterator() {\n+        final Iterator<Map.Entry<Integer, BitmapDataProvider>> it = highToBitmap.entrySet().iterator();\n+\n+        return toIterator(it, false);\n+    }\n+\n+    protected LongIterator toIterator(final Iterator<Map.Entry<Integer, BitmapDataProvider>> it,\n+                                      final boolean reversed) {\n+        return new LongIterator() {\n+\n+            protected int currentKey;\n+            protected IntIterator currentIt;\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (currentIt == null) {\n+                    // Were initially empty\n+                    if (!moveToNextEntry(it)) {\n+                        return false;\n+                    }\n+                }\n+\n+                while (true) {\n+                    if (currentIt.hasNext()) {\n+                        return true;\n+                    } else {\n+                        if (!moveToNextEntry(it)) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            /**\n+             *\n+             * @param it the underlying iterator which has to be moved to next long\n+             * @return true if we MAY have more entries. false if there is definitely nothing more\n+             */\n+            private boolean moveToNextEntry(Iterator<Map.Entry<Integer, BitmapDataProvider>> it) {\n+                if (it.hasNext()) {\n+                    Map.Entry<Integer, BitmapDataProvider> next = it.next();\n+                    currentKey = next.getKey();\n+                    if (reversed) {\n+                        currentIt = next.getValue().getReverseIntIterator();\n+                    } else {\n+                        currentIt = next.getValue().getIntIterator();\n+                    }\n+\n+                    // We may have more long\n+                    return true;\n+                } else {\n+                    // We know there is nothing more\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public long next() {\n+                if (hasNext()) {\n+                    return pack(currentKey, currentIt.next());\n+                } else {\n+                    throw new IllegalStateException(\"empty\");\n+                }\n+            }\n+\n+            @Override\n+            public LongIterator clone() {\n+                throw new UnsupportedOperationException(\"TODO\");\n+            }\n+        };\n+    }\n+\n+    public boolean contains(long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            return false;\n+        }\n+\n+        int low = low(x);\n+        return lowBitmap.contains(low);\n+    }\n+\n+\n+    public int getSizeInBytes() {\n+        return (int) getLongSizeInBytes();\n+    }\n+\n+    public long getLongSizeInBytes() {\n+        long size = 8;\n+\n+        // Size of containers\n+        size += highToBitmap.values().stream().mapToLong(p -> p.getLongSizeInBytes()).sum();\n+\n+        // Size of Map data-structure: we consider each TreeMap entry costs 40 bytes\n+        // http://java-performance.info/memory-consumption-of-java-data-types-2/\n+        size += 8 + 40 * highToBitmap.size();\n+\n+        // Size of (boxed) Integers used as keys\n+        size += 16 * highToBitmap.size();\n+\n+        // The cache impacts the size in heap\n+        size += 8 * sortedCumulatedCardinality.length;\n+        size += 4 * sortedHighs.length;\n+\n+        return size;\n+    }\n+\n+    public boolean isEmpty() {\n+        return getLongCardinality() == 0L;\n+    }\n+\n+    public ImmutableLongBitmapDataProvider limit(long x) {\n+        throw new UnsupportedOperationException(\"TODO\");\n+    }\n+\n+    /**\n+     * Use a run-length encoding where it is estimated as more space efficient\n+     *\n+     * @return whether a change was applied\n+     */\n+    public boolean runOptimize() {\n+        boolean hasChanged = false;\n+        for (BitmapDataProvider lowBitmap : highToBitmap.values()) {\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                hasChanged |= ((RoaringBitmap) lowBitmap).runOptimize();\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                hasChanged |= ((MutableRoaringBitmap) lowBitmap).runOptimize();\n+            }\n+        }\n+        return hasChanged;\n+    }\n+\n+    public long serializedSizeInBytes() {\n+        long nbBytes = 0L;\n+\n+        // .writeBoolean for signedLongs boolean\n+        nbBytes += 1;\n+\n+        // .writeInt for number of different high values\n+        nbBytes += 4;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            // .writeInt for high\n+            nbBytes += 4;\n+\n+            // The low bitmap size in bytes\n+            nbBytes += entry.getValue().serializedSizeInBytes();\n+        }\n+\n+        return nbBytes;\n+    }\n+\n+    /**\n+     * reset to an empty bitmap; result occupies as much space a newly created bitmap.\n+     */\n+    public void clear() {\n+        this.highToBitmap.clear();\n+        resetPerfHelpers();\n+    }\n+\n+    /**\n+     * Return the set values as an array, if the cardinality is smaller than 2147483648. The long\n+     * values are in sorted order.\n+     *\n+     * @return array representing the set values.\n+     */\n+    public long[] toArray() {\n+        long cardinality = this.getLongCardinality();\n+        if (cardinality > Integer.MAX_VALUE) {\n+            throw new IllegalStateException(\"The cardinality does not fit in an array\");\n+        }\n+\n+        final long[] array = new long[(int) cardinality];\n+\n+        int pos = 0;\n+        LongIterator it = getLongIterator();\n+\n+        while (it.hasNext()) {\n+            array[pos++] = it.next();\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Generate a bitmap with the specified values set to true. The provided longs values don't have\n+     * to be in sorted order, but it may be preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     * @return a new bitmap\n+     */\n+    public static Roaring64Map bitmapOf(final long... dat) {\n+        final Roaring64Map ans = new Roaring64Map();\n+        ans.add(dat);\n+        return ans;\n+    }\n+\n+    /**\n+     * Set all the specified values to true. This can be expected to be slightly faster than calling\n+     * \"add\" repeatedly. The provided integers values don't have to be in sorted order, but it may be\n+     * preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     */\n+    public void add(long... dat) {\n+        for (long oneLong : dat) {\n+            addLong(oneLong);\n+        }\n+    }\n+\n+    /**\n+     * Add to the current bitmap all longs in [rangeStart,rangeEnd).\n+     *\n+     * @param rangeStart inclusive beginning of range\n+     * @param rangeEnd exclusive ending of range\n+     */\n+    public void add(final long rangeStart, final long rangeEnd) {\n+        int startHigh = high(rangeStart);\n+        int startLow = low(rangeStart);\n+\n+        int endHigh = high(rangeEnd);\n+        int endLow = low(rangeEnd);\n+\n+        for (int high = startHigh; high <= endHigh; high++) {\n+            final int currentStartLow;\n+            if (startHigh == high) {\n+                // The whole range starts in this bucket\n+                currentStartLow = startLow;\n+            } else {\n+                // Add the bucket from the beginning\n+                currentStartLow = 0;\n+            }\n+\n+            long startLowAsLong = Util.toUnsignedLong(currentStartLow);\n+\n+            final long endLowAsLong;\n+            if (endHigh == high) {\n+                // The whole range ends in this bucket\n+                endLowAsLong = Util.toUnsignedLong(endLow);\n+            } else {\n+                // Add the bucket until the end: we have a +1 as, in RoaringBitmap.add(long,long), the end\n+                // is excluded\n+                endLowAsLong = Util.toUnsignedLong(-1) + 1;\n+            }\n+\n+            if (endLowAsLong > startLowAsLong) {\n+                // Initialize the bitmap only if there is access data to write\n+                BitmapDataProvider bitmap = highToBitmap.get(high);\n+                if (bitmap == null) {\n+                    bitmap = new MutableRoaringBitmap();\n+                    pushBitmapForHigh(high, bitmap);\n+                }\n+\n+                if (bitmap instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else if (bitmap instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else {\n+                    throw new UnsupportedOperationException(\"TODO. Not for \" + bitmap.getClass());\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(startHigh);\n+    }\n+\n+    public LongIterator getReverseLongIterator() {\n+        return toIterator(highToBitmap.descendingMap().entrySet().iterator(), true);\n+    }\n+\n+    public void removeLong(long x) {\n+        int high = high(x);\n+\n+        BitmapDataProvider bitmap = highToBitmap.get(high);\n+\n+        if (bitmap != null) {\n+            int low = low(x);\n+            bitmap.remove(low);\n+\n+            // Invalidate only if actually modified\n+            invalidateAboveHigh(high);\n+        }\n+\n+    }\n+\n+    public void trim() {\n+        for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+            bitmap.trim();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return highToBitmap.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        Roaring64Map other = (Roaring64Map) obj;\n+        return Objects.equals(highToBitmap, other.highToBitmap);\n+    }\n+\n+\n+\n+    /**\n+     * Add the value if it is not already present, otherwise remove it.\n+     *\n+     * @param x long value\n+     */\n+    public void flip(final long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            // The value is not added: add it without any flip specific code\n+            addLong(x);\n+        } else {\n+            int low = low(x);\n+\n+            // .flip is not in BitmapDataProvider contract\n+            // TODO Is it relevant to calling .flip with a cast?\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                ((RoaringBitmap) lowBitmap).flip(low);\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                ((MutableRoaringBitmap) lowBitmap).flip(low);\n+            } else {\n+                // Fallback to a manual flip\n+                if (lowBitmap.contains(low)) {\n+                    lowBitmap.remove(low);\n+                } else {\n+                    lowBitmap.add(low);\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /* ------------------ method below from Roaring64NavigableMap and being overwritten ----------------------------- */\n+\n+    /**\n+     * Serialize this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from onve java version\n+     * to another, and from one RoaringBitmap version to another.\n+     *\n+     * Consider calling {@link #runOptimize} before serialization to improve compression.\n+     *\n+     * The current bitmap is not modified.\n+     *\n+     * @param out the DataOutput stream\n+     * @throws IOException Signals that an I/O exception has occurred.\n+     */\n+    public void serialize(DataOutput out) throws IOException {\n+        if (highToBitmap.size() == 0) {\n+            return;\n+        }\n+        if (is32BitsEnough()) {\n+            out.write(BITMAP32);\n+            highToBitmap.get(0).serialize(out);\n+            return;\n+        }\n+\n+        out.write(BITMAP64);\n+        encodeVarint64(highToBitmap.size(), out);\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            out.writeInt(entry.getKey().intValue());\n+            entry.getValue().serialize(out);\n+        }\n+    }\n+\n+\n+    /**\n+     * Deserialize (retrieve) this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from one java version to\n+     * another, and from one RoaringBitmap version to another.\n+     *\n+     * The current bitmap is overwritten.\n+     *\n+     * @param in the DataInput stream\n+     * @throws IOException Signals that an I/O exception has occurred.\n+     */\n+    public void deserialize(DataInput in, int bitmapType) throws IOException {\n+        this.clear();\n+        highToBitmap = new TreeMap<>();\n+\n+        long nbHighs = 1;\n+        if (bitmapType == BITMAP64) {\n+            nbHighs = decodeVarint64(in);\n+        }\n+\n+        for (int i = 0; i < nbHighs; i++) {\n+            int high = in.readInt();\n+            RoaringBitmap provider = new RoaringBitmap();\n+            provider.deserialize(in);\n+\n+            highToBitmap.put(high, provider);\n+        }\n+\n+        resetPerfHelpers();\n+    }\n+\n+\n+\n+    /*---------------------------- method below is new written for doris's own bitmap --------------------------------*/\n+\n+    public boolean is32BitsEnough() {\n+        return highToBitmap.size() == 1 && highToBitmap.get(0) != null;\n+    }\n+\n+    public void add(long value) {\n+        addLong(value);\n+    }\n+\n+    public void add(int value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NDM0NA=="}, "originalCommit": {"oid": "792211134a47d85efb0480cc84a501c871262124"}, "originalPosition": 1377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3NjYwMQ==", "bodyText": "OK", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396876601", "createdAt": "2020-03-24T02:59:53Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "diffHunk": "@@ -0,0 +1,1484 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.BitmapDataProvider;\n+import org.roaringbitmap.BitmapDataProviderSupplier;\n+import org.roaringbitmap.IntConsumer;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapSupplier;\n+import org.roaringbitmap.Util;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.roaringbitmap.longlong.ImmutableLongBitmapDataProvider;\n+import org.roaringbitmap.longlong.LongConsumer;\n+import org.roaringbitmap.longlong.LongIterator;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import static org.apache.doris.common.util.Util.decodeVarint64;\n+import static org.apache.doris.common.util.Util.encodeVarint64;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP32;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP64;\n+\n+/**\n+ *\n+ * forked version 0.8.13\n+ * major change as below :\n+ *  1. overwrite serialize/deserialize method\n+ *  2. add a new method is32BitsEnough\n+ *  3. fork some Util method from org.roaringbitmap.longlong RoaringIntPacking\n+ * for details to see the end of the class\n+ */\n+public class Roaring64Map {\n+\n+    // Not final to enable initialization in Externalizable.readObject\n+    private NavigableMap<Integer, BitmapDataProvider> highToBitmap;\n+\n+    // If true, we handle longs a plain java longs: -1 if right before 0\n+    // If false, we handle longs as unsigned longs: 0 has no predecessor and Long.MAX_VALUE + 1L is\n+    // expressed as a\n+    // negative long\n+    private boolean signedLongs = false;\n+\n+    private BitmapDataProviderSupplier supplier;\n+\n+    // By default, we cache cardinalities\n+    private transient boolean doCacheCardinalities = true;\n+\n+    // Prevent recomputing all cardinalities when requesting consecutive ranks\n+    private transient int firstHighNotValid = highestHigh() + 1;\n+\n+    // This boolean needs firstHighNotValid == Integer.MAX_VALUE to be allowed to be true\n+    // If false, it means nearly all cumulated cardinalities are valid, except high=Integer.MAX_VALUE\n+    // If true, it means all cumulated cardinalities are valid, even high=Integer.MAX_VALUE\n+    private transient boolean allValid = false;\n+\n+    // TODO: I would prefer not managing arrays myself\n+    private transient long[] sortedCumulatedCardinality = new long[0];\n+    private transient int[] sortedHighs = new int[0];\n+\n+    // We guess consecutive .addLong will be on proximate longs: we remember the bitmap attached to\n+    // this bucket in order\n+    // to skip the indirection\n+    private transient Map.Entry<Integer, BitmapDataProvider> latestAddedHigh = null;\n+\n+    private static final boolean DEFAULT_ORDER_IS_SIGNED = false;\n+    private static final boolean DEFAULT_CARDINALITIES_ARE_CACHED = true;\n+\n+    /**\n+     * By default, we consider longs are unsigned longs: normal longs: 0 is the lowest possible long.\n+     * Long.MAX_VALUE is followed by Long.MIN_VALUE. -1L is the highest possible value\n+     */\n+    public Roaring64Map() {\n+        this(DEFAULT_ORDER_IS_SIGNED);\n+    }\n+\n+    /**\n+     *\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     */\n+    public Roaring64Map(boolean signedLongs) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED);\n+    }\n+\n+    /**\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities) {\n+        this(signedLongs, cacheCardinalities, new RoaringBitmapSupplier());\n+    }\n+\n+    /**\n+     * By default, longs are managed as unsigned longs and cardinalities are cached.\n+     *\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(BitmapDataProviderSupplier supplier) {\n+        this(DEFAULT_ORDER_IS_SIGNED, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     * By default, we activating cardinalities caching.\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, BitmapDataProviderSupplier supplier) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities,\n+                        BitmapDataProviderSupplier supplier) {\n+        this.signedLongs = signedLongs;\n+        this.supplier = supplier;\n+\n+        if (signedLongs) {\n+            highToBitmap = new TreeMap<>();\n+        } else {\n+            highToBitmap = new TreeMap<>(unsignedComparator());\n+        }\n+\n+        this.doCacheCardinalities = cacheCardinalities;\n+        resetPerfHelpers();\n+    }\n+\n+    private void resetPerfHelpers() {\n+        firstHighNotValid = highestHigh(signedLongs) + 1;\n+        allValid = false;\n+\n+        sortedCumulatedCardinality = new long[0];\n+        sortedHighs = new int[0];\n+\n+        latestAddedHigh = null;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    NavigableMap<Integer, BitmapDataProvider> getHighToBitmap() {\n+        return highToBitmap;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    int getLowestInvalidHigh() {\n+        return firstHighNotValid;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    long[] getSortedCumulatedCardinality() {\n+        return sortedCumulatedCardinality;\n+    }\n+\n+    /**\n+     * Add the value to the container (set the value to \"true\"), whether it already appears or not.\n+     *\n+     * Java lacks native unsigned longs but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Long#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 9223372036854775807, -9223372036854775808, -9223372036854775807,..., -1.\n+     *\n+     * @param x long value\n+     */\n+    public void addLong(long x) {\n+        int high = high(x);\n+        int low = low(x);\n+\n+        // Copy the reference to prevent race-condition\n+        Map.Entry<Integer, BitmapDataProvider> local = latestAddedHigh;\n+\n+        BitmapDataProvider bitmap;\n+        if (local != null && local.getKey().intValue() == high) {\n+            bitmap = local.getValue();\n+        } else {\n+            bitmap = highToBitmap.get(high);\n+            if (bitmap == null) {\n+                bitmap = newRoaringBitmap();\n+                pushBitmapForHigh(high, bitmap);\n+            }\n+            latestAddedHigh = new AbstractMap.SimpleImmutableEntry<>(high, bitmap);\n+        }\n+        bitmap.add(low);\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /**\n+     * Add the integer value to the container (set the value to \"true\"), whether it already appears or\n+     * not.\n+     *\n+     * Javac lacks native unsigned integers but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Integer#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 2147483647, -2147483648, -2147483647,..., -1.\n+     *\n+     * @param x integer value\n+     */\n+    public void addInt(int x) {\n+        addLong(Util.toUnsignedLong(x));\n+    }\n+\n+    private BitmapDataProvider newRoaringBitmap() {\n+        return supplier.newEmpty();\n+    }\n+\n+    private void invalidateAboveHigh(int high) {\n+        // The cardinalities after this bucket may not be valid anymore\n+        if (compare(firstHighNotValid, high) > 0) {\n+            // High was valid up to now\n+            firstHighNotValid = high;\n+\n+            int indexNotValid = binarySearch(sortedHighs, firstHighNotValid);\n+\n+            final int indexAfterWhichToReset;\n+            if (indexNotValid >= 0) {\n+                indexAfterWhichToReset = indexNotValid;\n+            } else {\n+                // We have invalidate a high not already present: added a value for a brand new high\n+                indexAfterWhichToReset = -indexNotValid - 1;\n+            }\n+\n+            // This way, sortedHighs remains sorted, without making a new/shorter array\n+            Arrays.fill(sortedHighs, indexAfterWhichToReset, sortedHighs.length, highestHigh());\n+        }\n+        allValid = false;\n+    }\n+\n+    private int compare(int x, int y) {\n+        if (signedLongs) {\n+            return Integer.compare(x, y);\n+        } else {\n+            return compareUnsigned(x, y);\n+        }\n+    }\n+\n+    private void pushBitmapForHigh(int high, BitmapDataProvider bitmap) {\n+        // TODO .size is too slow\n+        // int nbHighBefore = highToBitmap.headMap(high).size();\n+\n+        BitmapDataProvider previous = highToBitmap.put(high, bitmap);\n+        assert previous == null : \"Should push only not-existing high\";\n+    }\n+\n+    /**\n+     * Returns the number of distinct integers added to the bitmap (e.g., number of bits set).\n+     *\n+     * @return the cardinality\n+     */\n+    public long getLongCardinality() {\n+        if (doCacheCardinalities) {\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+            int indexOk = ensureCumulatives(highestHigh());\n+\n+            // ensureCumulatives may have removed empty bitmaps\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+\n+\n+            return sortedCumulatedCardinality[indexOk - 1];\n+        } else {\n+            long cardinality = 0L;\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                cardinality += bitmap.getLongCardinality();\n+            }\n+            return cardinality;\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return the cardinality as an int\n+     *\n+     * @throws UnsupportedOperationException if the cardinality does not fit in an int\n+     */\n+    public int getIntCardinality() throws UnsupportedOperationException {\n+        long cardinality = getLongCardinality();\n+\n+        if (cardinality > Integer.MAX_VALUE) {\n+            // TODO: we should handle cardinality fitting in an unsigned int\n+            throw new UnsupportedOperationException(\n+                    \"Can not call .getIntCardinality as the cardinality is bigger than Integer.MAX_VALUE\");\n+        }\n+\n+        return (int) cardinality;\n+    }\n+\n+    /**\n+     * Return the jth value stored in this bitmap.\n+     *\n+     * @param j index of the value\n+     *\n+     * @return the value\n+     * @throws IllegalArgumentException if j is out of the bounds of the bitmap cardinality\n+     */\n+    public long select(final long j) throws IllegalArgumentException {\n+        if (!doCacheCardinalities) {\n+            return selectNoCache(j);\n+        }\n+\n+        // Ensure all cumulatives as we we have straightforward way to know in advance the high of the\n+        // j-th value\n+        int indexOk = ensureCumulatives(highestHigh());\n+\n+        if (highToBitmap.isEmpty()) {\n+            return throwSelectInvalidIndex(j);\n+        }\n+\n+        // Use normal binarySearch as cardinality does not depends on considering longs signed or\n+        // unsigned\n+        // We need sortedCumulatedCardinality not to contain duplicated, else binarySearch may return\n+        // any of the duplicates: we need to ensure it holds no high associated to an empty bitmap\n+        int position = Arrays.binarySearch(sortedCumulatedCardinality, 0, indexOk, j);\n+\n+        if (position >= 0) {\n+            if (position == indexOk - 1) {\n+                // .select has been called on this.getCardinality\n+                return throwSelectInvalidIndex(j);\n+            }\n+\n+            // There is a bucket leading to this cardinality: the j-th element is the first element of\n+            // next bucket\n+            int high = sortedHighs[position + 1];\n+            BitmapDataProvider nextBitmap = highToBitmap.get(high);\n+            return pack(high, nextBitmap.select(0));\n+        } else {\n+            // There is no bucket with this cardinality\n+            int insertionPoint = -position - 1;\n+\n+            final long previousBucketCardinality;\n+            if (insertionPoint == 0) {\n+                previousBucketCardinality = 0L;\n+            } else if (insertionPoint >= indexOk) {\n+                return throwSelectInvalidIndex(j);\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+\n+            // We get a 'select' query for a single bitmap: should fit in an int\n+            final int givenBitmapSelect = (int) (j - previousBucketCardinality);\n+\n+            int high = sortedHighs[insertionPoint];\n+            BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+            int low = lowBitmap.select(givenBitmapSelect);\n+\n+            return pack(high, low);\n+        }\n+    }\n+\n+    // For benchmarks: compute without using cardinalities cache\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long selectNoCache(long j) {\n+        long left = j;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            long lowCardinality = entry.getValue().getCardinality();\n+\n+            if (left >= lowCardinality) {\n+                left -= lowCardinality;\n+            } else {\n+                // It is legit for left to be negative\n+                int leftAsUnsignedInt = (int) left;\n+                return pack(entry.getKey(), entry.getValue().select(leftAsUnsignedInt));\n+            }\n+        }\n+\n+        return throwSelectInvalidIndex(j);\n+    }\n+\n+    private long throwSelectInvalidIndex(long j) {\n+        // see org.roaringbitmap.buffer.ImmutableRoaringBitmap.select(int)\n+        throw new IllegalArgumentException(\n+                \"select \" + j + \" when the cardinality is \" + this.getLongCardinality());\n+    }\n+\n+    /**\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public Iterator<Long> iterator() {\n+        final LongIterator it = getLongIterator();\n+\n+        return new Iterator<Long>() {\n+\n+            @Override\n+            public boolean hasNext() {\n+                return it.hasNext();\n+            }\n+\n+            @Override\n+            public Long next() {\n+                return it.next();\n+            }\n+\n+            @Override\n+            public void remove() {\n+                // TODO?\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    public void forEach(final LongConsumer lc) {\n+        for (final Map.Entry<Integer, BitmapDataProvider> highEntry : highToBitmap.entrySet()) {\n+            highEntry.getValue().forEach(new IntConsumer() {\n+\n+                @Override\n+                public void accept(int low) {\n+                    lc.accept(pack(highEntry.getKey(), low));\n+                }\n+            });\n+        }\n+    }\n+\n+    public long rankLong(long id) {\n+        int high = high(id);\n+        int low = low(id);\n+\n+        if (!doCacheCardinalities) {\n+            return rankLongNoCache(high, low);\n+        }\n+\n+        int indexOk = ensureCumulatives(high);\n+\n+        int highPosition = binarySearch(sortedHighs, 0, indexOk, high);\n+\n+        if (highPosition >= 0) {\n+            // There is a bucket holding this item\n+\n+            final long previousBucketCardinality;\n+            if (highPosition == 0) {\n+                previousBucketCardinality = 0;\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[highPosition - 1];\n+            }\n+\n+            BitmapDataProvider lowBitmap = highToBitmap.get(sortedHighs[highPosition]);\n+\n+            // Rank is previous cardinality plus rank in current bitmap\n+            return previousBucketCardinality + lowBitmap.rankLong(low);\n+        } else {\n+            // There is no bucket holding this item: insertionPoint is previous bitmap\n+            int insertionPoint = -highPosition - 1;\n+\n+            if (insertionPoint == 0) {\n+                // this key is before all inserted keys\n+                return 0;\n+            } else {\n+                // The rank is the cardinality of this previous bitmap\n+                return sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+        }\n+    }\n+\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long rankLongNoCache(int high, int low) {\n+        long result = 0L;\n+\n+        BitmapDataProvider lastBitmap = highToBitmap.get(high);\n+        if (lastBitmap == null) {\n+            // There is no value with same high: the rank is a sum of cardinalities\n+            for (Map.Entry<Integer, BitmapDataProvider> bitmap : highToBitmap.entrySet()) {\n+                if (bitmap.getKey().intValue() > high) {\n+                    break;\n+                } else {\n+                    result += bitmap.getValue().getLongCardinality();\n+                }\n+            }\n+        } else {\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                if (bitmap == lastBitmap) {\n+                    result += bitmap.rankLong(low);\n+                    break;\n+                } else {\n+                    result += bitmap.getLongCardinality();\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param high for which high bucket should we compute the cardinality\n+     * @return the highest validatedIndex\n+     */\n+    protected int ensureCumulatives(int high) {\n+        if (allValid) {\n+            // the whole array is valid (up-to its actual length, not its capacity)\n+            return highToBitmap.size();\n+        } else if (compare(high, firstHighNotValid) < 0) {\n+            // The high is strictly below the first not valid: it is valid\n+\n+            // sortedHighs may have only a subset of valid values on the right. However, these invalid\n+            // values have been set to maxValue, and we are here as high < firstHighNotValid ==> high <\n+            // maxHigh()\n+            int position = binarySearch(sortedHighs, high);\n+\n+            if (position >= 0) {\n+                // This high has a bitmap: +1 as this index will be used as right (excluded) bound in a\n+                // binary-search\n+                return position + 1;\n+            } else {\n+                // This high has no bitmap: it could be between 2 highs with bitmaps\n+                int insertionPosition = -position - 1;\n+                return insertionPosition;\n+            }\n+        } else {\n+\n+            // For each deprecated buckets\n+            SortedMap<Integer, BitmapDataProvider> tailMap =\n+                    highToBitmap.tailMap(firstHighNotValid, true);\n+\n+            // TODO .size on tailMap make an iterator: arg\n+            int indexOk = highToBitmap.size() - tailMap.size();\n+\n+            // TODO: It should be possible to compute indexOk based on sortedHighs array\n+            // assert indexOk == binarySearch(sortedHighs, firstHighNotValid);\n+\n+            Iterator<Map.Entry<Integer, BitmapDataProvider>> it = tailMap.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry<Integer, BitmapDataProvider> e = it.next();\n+                int currentHigh = e.getKey();\n+\n+                if (compare(currentHigh, high) > 0) {\n+                    // No need to compute more than needed\n+                    break;\n+                } else if (e.getValue().isEmpty()) {\n+                    // highToBitmap can not be modified as we iterate over it\n+                    if (latestAddedHigh != null && latestAddedHigh.getKey().intValue() == currentHigh) {\n+                        // Dismiss the cached bitmap as it is removed from the NavigableMap\n+                        latestAddedHigh = null;\n+                    }\n+                    it.remove();\n+                } else {\n+                    ensureOne(e, currentHigh, indexOk);\n+\n+                    // We have added one valid cardinality\n+                    indexOk++;\n+                }\n+\n+            }\n+\n+            if (highToBitmap.isEmpty() || indexOk == highToBitmap.size()) {\n+                // We have compute all cardinalities\n+                allValid = true;\n+            }\n+\n+            return indexOk;\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, key);\n+        } else {\n+            return unsignedBinarySearch(array, 0, array.length, key,\n+                    unsignedComparator());\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int from, int to, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, from, to, key);\n+        } else {\n+            return unsignedBinarySearch(array, from, to, key, unsignedComparator());\n+        }\n+    }\n+\n+    // From Arrays.binarySearch (Comparator). Check with org.roaringbitmap.Util.unsignedBinarySearch\n+    private static int unsignedBinarySearch(int[] a, int fromIndex, int toIndex, int key,\n+                                            Comparator<? super Integer> c) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+            int midVal = a[mid];\n+            int cmp = c.compare(midVal, key);\n+            if (cmp < 0) {\n+                low = mid + 1;\n+            } else if (cmp > 0) {\n+                high = mid - 1;\n+            } else {\n+                return mid; // key found\n+            }\n+        }\n+        return -(low + 1); // key not found.\n+    }\n+\n+    private void ensureOne(Map.Entry<Integer, BitmapDataProvider> e, int currentHigh, int indexOk) {\n+        // sortedHighs are valid only up to some index\n+        assert indexOk <= sortedHighs.length : indexOk + \" is bigger than \" + sortedHighs.length;\n+\n+        final int index;\n+        if (indexOk == 0) {\n+            if (sortedHighs.length == 0) {\n+                index = -1;\n+                // } else if (sortedHighs[0] == currentHigh) {\n+                // index = 0;\n+            } else {\n+                index = -1;\n+            }\n+        } else if (indexOk < sortedHighs.length) {\n+            index = -indexOk - 1;\n+        } else {\n+            index = -sortedHighs.length - 1;\n+        }\n+        assert index == binarySearch(sortedHighs, 0, indexOk, currentHigh) : \"Computed \" + index\n+                + \" differs from dummy binary-search index: \"\n+                + binarySearch(sortedHighs, 0, indexOk, currentHigh);\n+\n+        if (index >= 0) {\n+            // This would mean calling .ensureOne is useless: should never got here at the first time\n+            throw new IllegalStateException(\"Unexpectedly found \" + currentHigh + \" in \"\n+                    + Arrays.toString(sortedHighs) + \" strictly before index\" + indexOk);\n+        } else {\n+            int insertionPosition = -index - 1;\n+\n+            // This is a new key\n+            if (insertionPosition >= sortedHighs.length) {\n+                int previousSize = sortedHighs.length;\n+\n+                // TODO softer growing factor\n+                int newSize = Math.min(Integer.MAX_VALUE, sortedHighs.length * 2 + 1);\n+\n+                // Insertion at the end\n+                sortedHighs = Arrays.copyOf(sortedHighs, newSize);\n+                sortedCumulatedCardinality = Arrays.copyOf(sortedCumulatedCardinality, newSize);\n+\n+                // Not actually needed. But simplify the reading of array content\n+                Arrays.fill(sortedHighs, previousSize, sortedHighs.length, highestHigh());\n+                Arrays.fill(sortedCumulatedCardinality, previousSize, sortedHighs.length, Long.MAX_VALUE);\n+            }\n+            sortedHighs[insertionPosition] = currentHigh;\n+\n+            final long previousCardinality;\n+            if (insertionPosition >= 1) {\n+                previousCardinality = sortedCumulatedCardinality[insertionPosition - 1];\n+            } else {\n+                previousCardinality = 0;\n+            }\n+\n+            sortedCumulatedCardinality[insertionPosition] =\n+                    previousCardinality + e.getValue().getLongCardinality();\n+\n+            if (currentHigh == highestHigh()) {\n+                // We are already on the highest high. Do not set allValid as it is set anyway out of the\n+                // loop\n+                firstHighNotValid = currentHigh;\n+            } else {\n+                // The first not valid is the next high\n+                // TODO: The entry comes from a NavigableMap: it may be quite cheap to know the next high\n+                firstHighNotValid = currentHigh + 1;\n+            }\n+        }\n+    }\n+\n+\n+\n+    private int highestHigh() {\n+        return highestHigh(signedLongs);\n+    }\n+\n+    /**\n+     * In-place bitwise OR (union) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void or(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).or((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).or((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise XOR (symmetric difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void xor(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).xor((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).xor((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void and(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 == null) {\n+                // None of given high values are present in x2\n+                thisIterator.remove();\n+            } else {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).and((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).and((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * In-place bitwise ANDNOT (difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void andNot(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 != null) {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).andNot((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).andNot((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A string describing the bitmap.\n+     *\n+     * @return the string\n+     */\n+    @Override\n+    public String toString() {\n+        final StringBuilder answer = new StringBuilder();\n+        final LongIterator i = this.getLongIterator();\n+        answer.append(\"{\");\n+        if (i.hasNext()) {\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+        }\n+        while (i.hasNext()) {\n+            answer.append(\",\");\n+            // to avoid using too much memory, we limit the size\n+            if (answer.length() > 0x80000) {\n+                answer.append(\"...\");\n+                break;\n+            }\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+\n+        }\n+        answer.append(\"}\");\n+        return answer.toString();\n+    }\n+\n+\n+    /**\n+     *\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public LongIterator getLongIterator() {\n+        final Iterator<Map.Entry<Integer, BitmapDataProvider>> it = highToBitmap.entrySet().iterator();\n+\n+        return toIterator(it, false);\n+    }\n+\n+    protected LongIterator toIterator(final Iterator<Map.Entry<Integer, BitmapDataProvider>> it,\n+                                      final boolean reversed) {\n+        return new LongIterator() {\n+\n+            protected int currentKey;\n+            protected IntIterator currentIt;\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (currentIt == null) {\n+                    // Were initially empty\n+                    if (!moveToNextEntry(it)) {\n+                        return false;\n+                    }\n+                }\n+\n+                while (true) {\n+                    if (currentIt.hasNext()) {\n+                        return true;\n+                    } else {\n+                        if (!moveToNextEntry(it)) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            /**\n+             *\n+             * @param it the underlying iterator which has to be moved to next long\n+             * @return true if we MAY have more entries. false if there is definitely nothing more\n+             */\n+            private boolean moveToNextEntry(Iterator<Map.Entry<Integer, BitmapDataProvider>> it) {\n+                if (it.hasNext()) {\n+                    Map.Entry<Integer, BitmapDataProvider> next = it.next();\n+                    currentKey = next.getKey();\n+                    if (reversed) {\n+                        currentIt = next.getValue().getReverseIntIterator();\n+                    } else {\n+                        currentIt = next.getValue().getIntIterator();\n+                    }\n+\n+                    // We may have more long\n+                    return true;\n+                } else {\n+                    // We know there is nothing more\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public long next() {\n+                if (hasNext()) {\n+                    return pack(currentKey, currentIt.next());\n+                } else {\n+                    throw new IllegalStateException(\"empty\");\n+                }\n+            }\n+\n+            @Override\n+            public LongIterator clone() {\n+                throw new UnsupportedOperationException(\"TODO\");\n+            }\n+        };\n+    }\n+\n+    public boolean contains(long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            return false;\n+        }\n+\n+        int low = low(x);\n+        return lowBitmap.contains(low);\n+    }\n+\n+\n+    public int getSizeInBytes() {\n+        return (int) getLongSizeInBytes();\n+    }\n+\n+    public long getLongSizeInBytes() {\n+        long size = 8;\n+\n+        // Size of containers\n+        size += highToBitmap.values().stream().mapToLong(p -> p.getLongSizeInBytes()).sum();\n+\n+        // Size of Map data-structure: we consider each TreeMap entry costs 40 bytes\n+        // http://java-performance.info/memory-consumption-of-java-data-types-2/\n+        size += 8 + 40 * highToBitmap.size();\n+\n+        // Size of (boxed) Integers used as keys\n+        size += 16 * highToBitmap.size();\n+\n+        // The cache impacts the size in heap\n+        size += 8 * sortedCumulatedCardinality.length;\n+        size += 4 * sortedHighs.length;\n+\n+        return size;\n+    }\n+\n+    public boolean isEmpty() {\n+        return getLongCardinality() == 0L;\n+    }\n+\n+    public ImmutableLongBitmapDataProvider limit(long x) {\n+        throw new UnsupportedOperationException(\"TODO\");\n+    }\n+\n+    /**\n+     * Use a run-length encoding where it is estimated as more space efficient\n+     *\n+     * @return whether a change was applied\n+     */\n+    public boolean runOptimize() {\n+        boolean hasChanged = false;\n+        for (BitmapDataProvider lowBitmap : highToBitmap.values()) {\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                hasChanged |= ((RoaringBitmap) lowBitmap).runOptimize();\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                hasChanged |= ((MutableRoaringBitmap) lowBitmap).runOptimize();\n+            }\n+        }\n+        return hasChanged;\n+    }\n+\n+    public long serializedSizeInBytes() {\n+        long nbBytes = 0L;\n+\n+        // .writeBoolean for signedLongs boolean\n+        nbBytes += 1;\n+\n+        // .writeInt for number of different high values\n+        nbBytes += 4;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            // .writeInt for high\n+            nbBytes += 4;\n+\n+            // The low bitmap size in bytes\n+            nbBytes += entry.getValue().serializedSizeInBytes();\n+        }\n+\n+        return nbBytes;\n+    }\n+\n+    /**\n+     * reset to an empty bitmap; result occupies as much space a newly created bitmap.\n+     */\n+    public void clear() {\n+        this.highToBitmap.clear();\n+        resetPerfHelpers();\n+    }\n+\n+    /**\n+     * Return the set values as an array, if the cardinality is smaller than 2147483648. The long\n+     * values are in sorted order.\n+     *\n+     * @return array representing the set values.\n+     */\n+    public long[] toArray() {\n+        long cardinality = this.getLongCardinality();\n+        if (cardinality > Integer.MAX_VALUE) {\n+            throw new IllegalStateException(\"The cardinality does not fit in an array\");\n+        }\n+\n+        final long[] array = new long[(int) cardinality];\n+\n+        int pos = 0;\n+        LongIterator it = getLongIterator();\n+\n+        while (it.hasNext()) {\n+            array[pos++] = it.next();\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Generate a bitmap with the specified values set to true. The provided longs values don't have\n+     * to be in sorted order, but it may be preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     * @return a new bitmap\n+     */\n+    public static Roaring64Map bitmapOf(final long... dat) {\n+        final Roaring64Map ans = new Roaring64Map();\n+        ans.add(dat);\n+        return ans;\n+    }\n+\n+    /**\n+     * Set all the specified values to true. This can be expected to be slightly faster than calling\n+     * \"add\" repeatedly. The provided integers values don't have to be in sorted order, but it may be\n+     * preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     */\n+    public void add(long... dat) {\n+        for (long oneLong : dat) {\n+            addLong(oneLong);\n+        }\n+    }\n+\n+    /**\n+     * Add to the current bitmap all longs in [rangeStart,rangeEnd).\n+     *\n+     * @param rangeStart inclusive beginning of range\n+     * @param rangeEnd exclusive ending of range\n+     */\n+    public void add(final long rangeStart, final long rangeEnd) {\n+        int startHigh = high(rangeStart);\n+        int startLow = low(rangeStart);\n+\n+        int endHigh = high(rangeEnd);\n+        int endLow = low(rangeEnd);\n+\n+        for (int high = startHigh; high <= endHigh; high++) {\n+            final int currentStartLow;\n+            if (startHigh == high) {\n+                // The whole range starts in this bucket\n+                currentStartLow = startLow;\n+            } else {\n+                // Add the bucket from the beginning\n+                currentStartLow = 0;\n+            }\n+\n+            long startLowAsLong = Util.toUnsignedLong(currentStartLow);\n+\n+            final long endLowAsLong;\n+            if (endHigh == high) {\n+                // The whole range ends in this bucket\n+                endLowAsLong = Util.toUnsignedLong(endLow);\n+            } else {\n+                // Add the bucket until the end: we have a +1 as, in RoaringBitmap.add(long,long), the end\n+                // is excluded\n+                endLowAsLong = Util.toUnsignedLong(-1) + 1;\n+            }\n+\n+            if (endLowAsLong > startLowAsLong) {\n+                // Initialize the bitmap only if there is access data to write\n+                BitmapDataProvider bitmap = highToBitmap.get(high);\n+                if (bitmap == null) {\n+                    bitmap = new MutableRoaringBitmap();\n+                    pushBitmapForHigh(high, bitmap);\n+                }\n+\n+                if (bitmap instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else if (bitmap instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else {\n+                    throw new UnsupportedOperationException(\"TODO. Not for \" + bitmap.getClass());\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(startHigh);\n+    }\n+\n+    public LongIterator getReverseLongIterator() {\n+        return toIterator(highToBitmap.descendingMap().entrySet().iterator(), true);\n+    }\n+\n+    public void removeLong(long x) {\n+        int high = high(x);\n+\n+        BitmapDataProvider bitmap = highToBitmap.get(high);\n+\n+        if (bitmap != null) {\n+            int low = low(x);\n+            bitmap.remove(low);\n+\n+            // Invalidate only if actually modified\n+            invalidateAboveHigh(high);\n+        }\n+\n+    }\n+\n+    public void trim() {\n+        for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+            bitmap.trim();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return highToBitmap.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        Roaring64Map other = (Roaring64Map) obj;\n+        return Objects.equals(highToBitmap, other.highToBitmap);\n+    }\n+\n+\n+\n+    /**\n+     * Add the value if it is not already present, otherwise remove it.\n+     *\n+     * @param x long value\n+     */\n+    public void flip(final long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            // The value is not added: add it without any flip specific code\n+            addLong(x);\n+        } else {\n+            int low = low(x);\n+\n+            // .flip is not in BitmapDataProvider contract\n+            // TODO Is it relevant to calling .flip with a cast?\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                ((RoaringBitmap) lowBitmap).flip(low);\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                ((MutableRoaringBitmap) lowBitmap).flip(low);\n+            } else {\n+                // Fallback to a manual flip\n+                if (lowBitmap.contains(low)) {\n+                    lowBitmap.remove(low);\n+                } else {\n+                    lowBitmap.add(low);\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /* ------------------ method below from Roaring64NavigableMap and being overwritten ----------------------------- */\n+\n+    /**\n+     * Serialize this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from onve java version\n+     * to another, and from one RoaringBitmap version to another.\n+     *\n+     * Consider calling {@link #runOptimize} before serialization to improve compression.\n+     *\n+     * The current bitmap is not modified.\n+     *\n+     * @param out the DataOutput stream\n+     * @throws IOException Signals that an I/O exception has occurred.\n+     */\n+    public void serialize(DataOutput out) throws IOException {\n+        if (highToBitmap.size() == 0) {\n+            return;\n+        }\n+        if (is32BitsEnough()) {\n+            out.write(BITMAP32);\n+            highToBitmap.get(0).serialize(out);\n+            return;\n+        }\n+\n+        out.write(BITMAP64);\n+        encodeVarint64(highToBitmap.size(), out);\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            out.writeInt(entry.getKey().intValue());\n+            entry.getValue().serialize(out);\n+        }\n+    }\n+\n+\n+    /**\n+     * Deserialize (retrieve) this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from one java version to\n+     * another, and from one RoaringBitmap version to another.\n+     *\n+     * The current bitmap is overwritten.\n+     *\n+     * @param in the DataInput stream\n+     * @throws IOException Signals that an I/O exception has occurred.\n+     */\n+    public void deserialize(DataInput in, int bitmapType) throws IOException {\n+        this.clear();\n+        highToBitmap = new TreeMap<>();\n+\n+        long nbHighs = 1;\n+        if (bitmapType == BITMAP64) {\n+            nbHighs = decodeVarint64(in);\n+        }\n+\n+        for (int i = 0; i < nbHighs; i++) {\n+            int high = in.readInt();\n+            RoaringBitmap provider = new RoaringBitmap();\n+            provider.deserialize(in);\n+\n+            highToBitmap.put(high, provider);\n+        }\n+\n+        resetPerfHelpers();\n+    }\n+\n+\n+\n+    /*---------------------------- method below is new written for doris's own bitmap --------------------------------*/\n+\n+    public boolean is32BitsEnough() {\n+        return highToBitmap.size() == 1 && highToBitmap.get(0) != null;\n+    }\n+\n+    public void add(long value) {\n+        addLong(value);\n+    }\n+\n+    public void add(int value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NDM0NA=="}, "originalCommit": {"oid": "792211134a47d85efb0480cc84a501c871262124"}, "originalPosition": 1377}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDI4NjEwOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMzoyNTo1NFrOF6fzJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNDo0NzowMlrOF6g3RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4MjcyNQ==", "bodyText": "Would better keep the method name and body consistent with BE implementation", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396882725", "createdAt": "2020-03-24T03:25:54Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.Util;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  try to keep compatibility with doris be's bitmap_value.h,but still has some difference from bitmap_value.h\n+ *  major difference from be:\n+ *      1. java bitmap support integer range [0, Long.MAX],while be's bitmap support range [0, Long.MAX * 2]\n+ *          Now Long.MAX_VALUE is enough for doris's spark load and support unsigned integer in java need to pay more\n+ *      2. getSizeInBytes method is different from fe to be, details description see method comment\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value) {\n+        add(Util.toUnsignedLong(value));\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    bitmap.add(singleValue);\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.addLong(value);\n+                break;\n+        }\n+    }\n+\n+    public boolean contains(int value) {\n+        return contains(Util.toUnsignedLong(value));\n+    }\n+\n+    public boolean contains(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE_VALUE:\n+                return singleValue == value;\n+            case BITMAP_VALUE:\n+                return bitmap.contains(value);\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public long cardinality() {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE_VALUE:\n+                return 1;\n+            case BITMAP_VALUE:\n+                return bitmap.getLongCardinality();\n+        }\n+        return 0;\n+    }\n+\n+    public void serialize(DataOutput output) throws IOException {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                output.writeByte(EMPTY);\n+                break;\n+            case SINGLE_VALUE:\n+                // is 32-bit enough\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    output.write(SINGLE32);\n+                    output.writeInt((int)singleValue);\n+                } else {\n+                    output.writeByte(SINGLE64);\n+                    output.writeLong(singleValue);\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.serialize(output);\n+                break;\n+        }\n+    }\n+\n+    public void deserialize(DataInput input) throws IOException {\n+        clear();\n+        int bitmapType = input.readByte();\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE32:\n+                singleValue = Util.toUnsignedLong(input.readInt());\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE64:\n+                singleValue = input.readLong();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case BITMAP32:\n+            case BITMAP64:\n+                bitmap = bitmap == null ? new Roaring64Map() : bitmap;\n+                bitmap.deserialize(input, bitmapType);\n+                this.bitmapType = BITMAP_VALUE;\n+                break;\n+            default:\n+                throw new RuntimeException(String.format(\"unknown bitmap type %s \", bitmapType));\n+        }\n+    }\n+\n+    // In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+    public void and(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.singleValue == other.singleValue) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                    case BITMAP_VALUE:\n+                        if (other.bitmap.contains(singleValue)) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.bitmap.contains(other.singleValue)) {\n+                            clear();\n+                            this.bitmapType = SINGLE_VALUE;\n+                            this.singleValue = other.singleValue;\n+                        } else {\n+                            clear();\n+                        }\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.and(other.bitmap);\n+                        convertToSmallerType();\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    // In-place bitwise OR (union) operation. The current bitmap is modified.\n+    public void or(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.singleValue = other.singleValue;\n+                        this.bitmapType = SINGLE_VALUE;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        long thisSingleValue = this.singleValue;\n+                        clear();\n+                        add(thisSingleValue);\n+                        add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        other.add(this.singleValue);\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.or(other.bitmap);\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public boolean equals(BitmapValue other) {\n+        boolean ret = false;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        ret = true;\n+                        break;\n+                    case SINGLE_VALUE:\n+                    case BITMAP_VALUE:\n+                        ret = false;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case BITMAP_VALUE:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        ret = this.singleValue == other.singleValue;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case SINGLE_VALUE:\n+                        ret = false;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        ret = bitmap.equals(other.bitmap);\n+                        break;\n+                }\n+                break;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     *  usage note:\n+     *      now getSizeInBytes is different from be' impl\n+     *      The reason is that java's roaring didn't implement method #shrinkToFit but be's getSizeInBytes need it\n+     *      Implementing java's shrinkToFit means refactor roaring whose fields are all unaccess in Doris Fe's package\n+     *      That would be an another big project\n+     */\n+    // TODO(wb): keep getSizeInBytes consistent with be and refactor roaring\n+    public long getSizeInBytes() {\n+        long size = 0;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                size = 1;\n+                break;\n+            case SINGLE_VALUE:\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    size = 1 + 4;\n+                } else {\n+                    size = 1 + 8;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                size = 1 + bitmap.getSizeInBytes();\n+        }\n+        return size;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String toStringStr = \"{}\";\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                toStringStr = String.format(\"{%s}\", singleValue);\n+                break;\n+            case BITMAP_VALUE:\n+                toStringStr = this.bitmap.toString();\n+                break;\n+        }\n+        return toStringStr;\n+    }\n+\n+    public void clear() {\n+        this.bitmapType = EMPTY;\n+        this.bitmap = null;\n+    }\n+\n+    private void convertToSmallerType() {\n+        if (bitmapType == BITMAP_VALUE) {\n+            if (bitmap.getLongCardinality() == 0) {\n+                this.bitmap = null;\n+                this.bitmapType = EMPTY;\n+            } else if (bitmap.getLongCardinality() == 1) {\n+                this.singleValue = bitmap.select(0);\n+                this.bitmapType = SINGLE_VALUE;\n+                this.bitmap = null;\n+            }\n+        }\n+    }\n+\n+    private boolean isLongValue32bitEnough(long value) {\n+        return value >> 32 == 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b96746713b8d4d93cabb832c3f3017fc385c727d"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwMDE2NA==", "bodyText": "So here can use compare Integer.MAX_VALUE * 2 to instead of >>.\nBut be doesn't have isLongValue32bitEnough , I prefer to make it a method", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396900164", "createdAt": "2020-03-24T04:47:02Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.Util;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  try to keep compatibility with doris be's bitmap_value.h,but still has some difference from bitmap_value.h\n+ *  major difference from be:\n+ *      1. java bitmap support integer range [0, Long.MAX],while be's bitmap support range [0, Long.MAX * 2]\n+ *          Now Long.MAX_VALUE is enough for doris's spark load and support unsigned integer in java need to pay more\n+ *      2. getSizeInBytes method is different from fe to be, details description see method comment\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value) {\n+        add(Util.toUnsignedLong(value));\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    bitmap.add(singleValue);\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.addLong(value);\n+                break;\n+        }\n+    }\n+\n+    public boolean contains(int value) {\n+        return contains(Util.toUnsignedLong(value));\n+    }\n+\n+    public boolean contains(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE_VALUE:\n+                return singleValue == value;\n+            case BITMAP_VALUE:\n+                return bitmap.contains(value);\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public long cardinality() {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE_VALUE:\n+                return 1;\n+            case BITMAP_VALUE:\n+                return bitmap.getLongCardinality();\n+        }\n+        return 0;\n+    }\n+\n+    public void serialize(DataOutput output) throws IOException {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                output.writeByte(EMPTY);\n+                break;\n+            case SINGLE_VALUE:\n+                // is 32-bit enough\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    output.write(SINGLE32);\n+                    output.writeInt((int)singleValue);\n+                } else {\n+                    output.writeByte(SINGLE64);\n+                    output.writeLong(singleValue);\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.serialize(output);\n+                break;\n+        }\n+    }\n+\n+    public void deserialize(DataInput input) throws IOException {\n+        clear();\n+        int bitmapType = input.readByte();\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE32:\n+                singleValue = Util.toUnsignedLong(input.readInt());\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE64:\n+                singleValue = input.readLong();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case BITMAP32:\n+            case BITMAP64:\n+                bitmap = bitmap == null ? new Roaring64Map() : bitmap;\n+                bitmap.deserialize(input, bitmapType);\n+                this.bitmapType = BITMAP_VALUE;\n+                break;\n+            default:\n+                throw new RuntimeException(String.format(\"unknown bitmap type %s \", bitmapType));\n+        }\n+    }\n+\n+    // In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+    public void and(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.singleValue == other.singleValue) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                    case BITMAP_VALUE:\n+                        if (other.bitmap.contains(singleValue)) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.bitmap.contains(other.singleValue)) {\n+                            clear();\n+                            this.bitmapType = SINGLE_VALUE;\n+                            this.singleValue = other.singleValue;\n+                        } else {\n+                            clear();\n+                        }\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.and(other.bitmap);\n+                        convertToSmallerType();\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    // In-place bitwise OR (union) operation. The current bitmap is modified.\n+    public void or(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.singleValue = other.singleValue;\n+                        this.bitmapType = SINGLE_VALUE;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        long thisSingleValue = this.singleValue;\n+                        clear();\n+                        add(thisSingleValue);\n+                        add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        other.add(this.singleValue);\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.or(other.bitmap);\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public boolean equals(BitmapValue other) {\n+        boolean ret = false;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        ret = true;\n+                        break;\n+                    case SINGLE_VALUE:\n+                    case BITMAP_VALUE:\n+                        ret = false;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case BITMAP_VALUE:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        ret = this.singleValue == other.singleValue;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case SINGLE_VALUE:\n+                        ret = false;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        ret = bitmap.equals(other.bitmap);\n+                        break;\n+                }\n+                break;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     *  usage note:\n+     *      now getSizeInBytes is different from be' impl\n+     *      The reason is that java's roaring didn't implement method #shrinkToFit but be's getSizeInBytes need it\n+     *      Implementing java's shrinkToFit means refactor roaring whose fields are all unaccess in Doris Fe's package\n+     *      That would be an another big project\n+     */\n+    // TODO(wb): keep getSizeInBytes consistent with be and refactor roaring\n+    public long getSizeInBytes() {\n+        long size = 0;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                size = 1;\n+                break;\n+            case SINGLE_VALUE:\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    size = 1 + 4;\n+                } else {\n+                    size = 1 + 8;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                size = 1 + bitmap.getSizeInBytes();\n+        }\n+        return size;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String toStringStr = \"{}\";\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                toStringStr = String.format(\"{%s}\", singleValue);\n+                break;\n+            case BITMAP_VALUE:\n+                toStringStr = this.bitmap.toString();\n+                break;\n+        }\n+        return toStringStr;\n+    }\n+\n+    public void clear() {\n+        this.bitmapType = EMPTY;\n+        this.bitmap = null;\n+    }\n+\n+    private void convertToSmallerType() {\n+        if (bitmapType == BITMAP_VALUE) {\n+            if (bitmap.getLongCardinality() == 0) {\n+                this.bitmap = null;\n+                this.bitmapType = EMPTY;\n+            } else if (bitmap.getLongCardinality() == 1) {\n+                this.singleValue = bitmap.select(0);\n+                this.bitmapType = SINGLE_VALUE;\n+                this.bitmap = null;\n+            }\n+        }\n+    }\n+\n+    private boolean isLongValue32bitEnough(long value) {\n+        return value >> 32 == 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4MjcyNQ=="}, "originalCommit": {"oid": "b96746713b8d4d93cabb832c3f3017fc385c727d"}, "originalPosition": 351}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDMwMzYyOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMzozNzo1OFrOF6f-GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNDo0NTowOVrOF6g10g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NTUyOQ==", "bodyText": "would better use new Roaring64Map(), not null.", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396885529", "createdAt": "2020-03-24T03:37:58Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.Util;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  try to keep compatibility with doris be's bitmap_value.h,but still has some difference from bitmap_value.h\n+ *  major difference from be:\n+ *      1. java bitmap support integer range [0, Long.MAX],while be's bitmap support range [0, Long.MAX * 2]\n+ *          Now Long.MAX_VALUE is enough for doris's spark load and support unsigned integer in java need to pay more\n+ *      2. getSizeInBytes method is different from fe to be, details description see method comment\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value) {\n+        add(Util.toUnsignedLong(value));\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    bitmap.add(singleValue);\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.addLong(value);\n+                break;\n+        }\n+    }\n+\n+    public boolean contains(int value) {\n+        return contains(Util.toUnsignedLong(value));\n+    }\n+\n+    public boolean contains(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE_VALUE:\n+                return singleValue == value;\n+            case BITMAP_VALUE:\n+                return bitmap.contains(value);\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public long cardinality() {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE_VALUE:\n+                return 1;\n+            case BITMAP_VALUE:\n+                return bitmap.getLongCardinality();\n+        }\n+        return 0;\n+    }\n+\n+    public void serialize(DataOutput output) throws IOException {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                output.writeByte(EMPTY);\n+                break;\n+            case SINGLE_VALUE:\n+                // is 32-bit enough\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    output.write(SINGLE32);\n+                    output.writeInt((int)singleValue);\n+                } else {\n+                    output.writeByte(SINGLE64);\n+                    output.writeLong(singleValue);\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.serialize(output);\n+                break;\n+        }\n+    }\n+\n+    public void deserialize(DataInput input) throws IOException {\n+        clear();\n+        int bitmapType = input.readByte();\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE32:\n+                singleValue = Util.toUnsignedLong(input.readInt());\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE64:\n+                singleValue = input.readLong();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case BITMAP32:\n+            case BITMAP64:\n+                bitmap = bitmap == null ? new Roaring64Map() : bitmap;\n+                bitmap.deserialize(input, bitmapType);\n+                this.bitmapType = BITMAP_VALUE;\n+                break;\n+            default:\n+                throw new RuntimeException(String.format(\"unknown bitmap type %s \", bitmapType));\n+        }\n+    }\n+\n+    // In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+    public void and(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.singleValue == other.singleValue) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                    case BITMAP_VALUE:\n+                        if (other.bitmap.contains(singleValue)) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.bitmap.contains(other.singleValue)) {\n+                            clear();\n+                            this.bitmapType = SINGLE_VALUE;\n+                            this.singleValue = other.singleValue;\n+                        } else {\n+                            clear();\n+                        }\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.and(other.bitmap);\n+                        convertToSmallerType();\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    // In-place bitwise OR (union) operation. The current bitmap is modified.\n+    public void or(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.singleValue = other.singleValue;\n+                        this.bitmapType = SINGLE_VALUE;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        long thisSingleValue = this.singleValue;\n+                        clear();\n+                        add(thisSingleValue);\n+                        add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        other.add(this.singleValue);\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.or(other.bitmap);\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public boolean equals(BitmapValue other) {\n+        boolean ret = false;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        ret = true;\n+                        break;\n+                    case SINGLE_VALUE:\n+                    case BITMAP_VALUE:\n+                        ret = false;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case BITMAP_VALUE:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        ret = this.singleValue == other.singleValue;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case SINGLE_VALUE:\n+                        ret = false;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        ret = bitmap.equals(other.bitmap);\n+                        break;\n+                }\n+                break;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     *  usage note:\n+     *      now getSizeInBytes is different from be' impl\n+     *      The reason is that java's roaring didn't implement method #shrinkToFit but be's getSizeInBytes need it\n+     *      Implementing java's shrinkToFit means refactor roaring whose fields are all unaccess in Doris Fe's package\n+     *      That would be an another big project\n+     */\n+    // TODO(wb): keep getSizeInBytes consistent with be and refactor roaring\n+    public long getSizeInBytes() {\n+        long size = 0;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                size = 1;\n+                break;\n+            case SINGLE_VALUE:\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    size = 1 + 4;\n+                } else {\n+                    size = 1 + 8;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                size = 1 + bitmap.getSizeInBytes();\n+        }\n+        return size;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String toStringStr = \"{}\";\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                toStringStr = String.format(\"{%s}\", singleValue);\n+                break;\n+            case BITMAP_VALUE:\n+                toStringStr = this.bitmap.toString();\n+                break;\n+        }\n+        return toStringStr;\n+    }\n+\n+    public void clear() {\n+        this.bitmapType = EMPTY;\n+        this.bitmap = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b96746713b8d4d93cabb832c3f3017fc385c727d"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg5OTc5NA==", "bodyText": "For status from bitmap to single value,calling clear()  is necessary.\nnew a bitmap here costs more memory;\nWe just need to keep the status transfer logic correct,NPE can be avoid.", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396899794", "createdAt": "2020-03-24T04:45:09Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.Util;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  try to keep compatibility with doris be's bitmap_value.h,but still has some difference from bitmap_value.h\n+ *  major difference from be:\n+ *      1. java bitmap support integer range [0, Long.MAX],while be's bitmap support range [0, Long.MAX * 2]\n+ *          Now Long.MAX_VALUE is enough for doris's spark load and support unsigned integer in java need to pay more\n+ *      2. getSizeInBytes method is different from fe to be, details description see method comment\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value) {\n+        add(Util.toUnsignedLong(value));\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    bitmap.add(singleValue);\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.addLong(value);\n+                break;\n+        }\n+    }\n+\n+    public boolean contains(int value) {\n+        return contains(Util.toUnsignedLong(value));\n+    }\n+\n+    public boolean contains(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE_VALUE:\n+                return singleValue == value;\n+            case BITMAP_VALUE:\n+                return bitmap.contains(value);\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public long cardinality() {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE_VALUE:\n+                return 1;\n+            case BITMAP_VALUE:\n+                return bitmap.getLongCardinality();\n+        }\n+        return 0;\n+    }\n+\n+    public void serialize(DataOutput output) throws IOException {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                output.writeByte(EMPTY);\n+                break;\n+            case SINGLE_VALUE:\n+                // is 32-bit enough\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    output.write(SINGLE32);\n+                    output.writeInt((int)singleValue);\n+                } else {\n+                    output.writeByte(SINGLE64);\n+                    output.writeLong(singleValue);\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.serialize(output);\n+                break;\n+        }\n+    }\n+\n+    public void deserialize(DataInput input) throws IOException {\n+        clear();\n+        int bitmapType = input.readByte();\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE32:\n+                singleValue = Util.toUnsignedLong(input.readInt());\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE64:\n+                singleValue = input.readLong();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case BITMAP32:\n+            case BITMAP64:\n+                bitmap = bitmap == null ? new Roaring64Map() : bitmap;\n+                bitmap.deserialize(input, bitmapType);\n+                this.bitmapType = BITMAP_VALUE;\n+                break;\n+            default:\n+                throw new RuntimeException(String.format(\"unknown bitmap type %s \", bitmapType));\n+        }\n+    }\n+\n+    // In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+    public void and(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.singleValue == other.singleValue) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                    case BITMAP_VALUE:\n+                        if (other.bitmap.contains(singleValue)) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.bitmap.contains(other.singleValue)) {\n+                            clear();\n+                            this.bitmapType = SINGLE_VALUE;\n+                            this.singleValue = other.singleValue;\n+                        } else {\n+                            clear();\n+                        }\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.and(other.bitmap);\n+                        convertToSmallerType();\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    // In-place bitwise OR (union) operation. The current bitmap is modified.\n+    public void or(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.singleValue = other.singleValue;\n+                        this.bitmapType = SINGLE_VALUE;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        long thisSingleValue = this.singleValue;\n+                        clear();\n+                        add(thisSingleValue);\n+                        add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        other.add(this.singleValue);\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.or(other.bitmap);\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public boolean equals(BitmapValue other) {\n+        boolean ret = false;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        ret = true;\n+                        break;\n+                    case SINGLE_VALUE:\n+                    case BITMAP_VALUE:\n+                        ret = false;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case BITMAP_VALUE:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        ret = this.singleValue == other.singleValue;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case SINGLE_VALUE:\n+                        ret = false;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        ret = bitmap.equals(other.bitmap);\n+                        break;\n+                }\n+                break;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     *  usage note:\n+     *      now getSizeInBytes is different from be' impl\n+     *      The reason is that java's roaring didn't implement method #shrinkToFit but be's getSizeInBytes need it\n+     *      Implementing java's shrinkToFit means refactor roaring whose fields are all unaccess in Doris Fe's package\n+     *      That would be an another big project\n+     */\n+    // TODO(wb): keep getSizeInBytes consistent with be and refactor roaring\n+    public long getSizeInBytes() {\n+        long size = 0;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                size = 1;\n+                break;\n+            case SINGLE_VALUE:\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    size = 1 + 4;\n+                } else {\n+                    size = 1 + 8;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                size = 1 + bitmap.getSizeInBytes();\n+        }\n+        return size;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String toStringStr = \"{}\";\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                toStringStr = String.format(\"{%s}\", singleValue);\n+                break;\n+            case BITMAP_VALUE:\n+                toStringStr = this.bitmap.toString();\n+                break;\n+        }\n+        return toStringStr;\n+    }\n+\n+    public void clear() {\n+        this.bitmapType = EMPTY;\n+        this.bitmap = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NTUyOQ=="}, "originalCommit": {"oid": "b96746713b8d4d93cabb832c3f3017fc385c727d"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDMwOTIyOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMzo0MjoyN1rOF6gBnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNTowMTozNFrOF6hD0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NjQyOQ==", "bodyText": "This check is unnecessary.\nIf you add this check, you must change the singleValue to invalid value when clear.", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396886429", "createdAt": "2020-03-24T03:42:27Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.Util;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  try to keep compatibility with doris be's bitmap_value.h,but still has some difference from bitmap_value.h\n+ *  major difference from be:\n+ *      1. java bitmap support integer range [0, Long.MAX],while be's bitmap support range [0, Long.MAX * 2]\n+ *          Now Long.MAX_VALUE is enough for doris's spark load and support unsigned integer in java need to pay more\n+ *      2. getSizeInBytes method is different from fe to be, details description see method comment\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value) {\n+        add(Util.toUnsignedLong(value));\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b96746713b8d4d93cabb832c3f3017fc385c727d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwMzM3OA==", "bodyText": "If user input two identical value in a row, the check can avoid the generation of a bitmap.\nAnd change singleValue to invalid is not a necessary operator, because single value must comes from empty,even after BitmapValue clear();", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396903378", "createdAt": "2020-03-24T05:01:34Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.Util;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  try to keep compatibility with doris be's bitmap_value.h,but still has some difference from bitmap_value.h\n+ *  major difference from be:\n+ *      1. java bitmap support integer range [0, Long.MAX],while be's bitmap support range [0, Long.MAX * 2]\n+ *          Now Long.MAX_VALUE is enough for doris's spark load and support unsigned integer in java need to pay more\n+ *      2. getSizeInBytes method is different from fe to be, details description see method comment\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value) {\n+        add(Util.toUnsignedLong(value));\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NjQyOQ=="}, "originalCommit": {"oid": "b96746713b8d4d93cabb832c3f3017fc385c727d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDMxMjUyOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMzo0NDo1MFrOF6gDqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNDo0NTowM1rOF6g1xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4Njk1NA==", "bodyText": "Would better change the singleValue to a negative value.", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396886954", "createdAt": "2020-03-24T03:44:50Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.Util;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  try to keep compatibility with doris be's bitmap_value.h,but still has some difference from bitmap_value.h\n+ *  major difference from be:\n+ *      1. java bitmap support integer range [0, Long.MAX],while be's bitmap support range [0, Long.MAX * 2]\n+ *          Now Long.MAX_VALUE is enough for doris's spark load and support unsigned integer in java need to pay more\n+ *      2. getSizeInBytes method is different from fe to be, details description see method comment\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value) {\n+        add(Util.toUnsignedLong(value));\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    bitmap.add(singleValue);\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.addLong(value);\n+                break;\n+        }\n+    }\n+\n+    public boolean contains(int value) {\n+        return contains(Util.toUnsignedLong(value));\n+    }\n+\n+    public boolean contains(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE_VALUE:\n+                return singleValue == value;\n+            case BITMAP_VALUE:\n+                return bitmap.contains(value);\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public long cardinality() {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE_VALUE:\n+                return 1;\n+            case BITMAP_VALUE:\n+                return bitmap.getLongCardinality();\n+        }\n+        return 0;\n+    }\n+\n+    public void serialize(DataOutput output) throws IOException {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                output.writeByte(EMPTY);\n+                break;\n+            case SINGLE_VALUE:\n+                // is 32-bit enough\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    output.write(SINGLE32);\n+                    output.writeInt((int)singleValue);\n+                } else {\n+                    output.writeByte(SINGLE64);\n+                    output.writeLong(singleValue);\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.serialize(output);\n+                break;\n+        }\n+    }\n+\n+    public void deserialize(DataInput input) throws IOException {\n+        clear();\n+        int bitmapType = input.readByte();\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE32:\n+                singleValue = Util.toUnsignedLong(input.readInt());\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE64:\n+                singleValue = input.readLong();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case BITMAP32:\n+            case BITMAP64:\n+                bitmap = bitmap == null ? new Roaring64Map() : bitmap;\n+                bitmap.deserialize(input, bitmapType);\n+                this.bitmapType = BITMAP_VALUE;\n+                break;\n+            default:\n+                throw new RuntimeException(String.format(\"unknown bitmap type %s \", bitmapType));\n+        }\n+    }\n+\n+    // In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+    public void and(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.singleValue == other.singleValue) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                    case BITMAP_VALUE:\n+                        if (other.bitmap.contains(singleValue)) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.bitmap.contains(other.singleValue)) {\n+                            clear();\n+                            this.bitmapType = SINGLE_VALUE;\n+                            this.singleValue = other.singleValue;\n+                        } else {\n+                            clear();\n+                        }\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.and(other.bitmap);\n+                        convertToSmallerType();\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    // In-place bitwise OR (union) operation. The current bitmap is modified.\n+    public void or(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.singleValue = other.singleValue;\n+                        this.bitmapType = SINGLE_VALUE;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        long thisSingleValue = this.singleValue;\n+                        clear();\n+                        add(thisSingleValue);\n+                        add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        other.add(this.singleValue);\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.or(other.bitmap);\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public boolean equals(BitmapValue other) {\n+        boolean ret = false;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        ret = true;\n+                        break;\n+                    case SINGLE_VALUE:\n+                    case BITMAP_VALUE:\n+                        ret = false;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case BITMAP_VALUE:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        ret = this.singleValue == other.singleValue;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case SINGLE_VALUE:\n+                        ret = false;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        ret = bitmap.equals(other.bitmap);\n+                        break;\n+                }\n+                break;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     *  usage note:\n+     *      now getSizeInBytes is different from be' impl\n+     *      The reason is that java's roaring didn't implement method #shrinkToFit but be's getSizeInBytes need it\n+     *      Implementing java's shrinkToFit means refactor roaring whose fields are all unaccess in Doris Fe's package\n+     *      That would be an another big project\n+     */\n+    // TODO(wb): keep getSizeInBytes consistent with be and refactor roaring\n+    public long getSizeInBytes() {\n+        long size = 0;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                size = 1;\n+                break;\n+            case SINGLE_VALUE:\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    size = 1 + 4;\n+                } else {\n+                    size = 1 + 8;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                size = 1 + bitmap.getSizeInBytes();\n+        }\n+        return size;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String toStringStr = \"{}\";\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                toStringStr = String.format(\"{%s}\", singleValue);\n+                break;\n+            case BITMAP_VALUE:\n+                toStringStr = this.bitmap.toString();\n+                break;\n+        }\n+        return toStringStr;\n+    }\n+\n+    public void clear() {\n+        this.bitmapType = EMPTY;\n+        this.bitmap = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b96746713b8d4d93cabb832c3f3017fc385c727d"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg5OTc4Mg==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396899782", "createdAt": "2020-03-24T04:45:03Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.Util;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  try to keep compatibility with doris be's bitmap_value.h,but still has some difference from bitmap_value.h\n+ *  major difference from be:\n+ *      1. java bitmap support integer range [0, Long.MAX],while be's bitmap support range [0, Long.MAX * 2]\n+ *          Now Long.MAX_VALUE is enough for doris's spark load and support unsigned integer in java need to pay more\n+ *      2. getSizeInBytes method is different from fe to be, details description see method comment\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value) {\n+        add(Util.toUnsignedLong(value));\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    bitmap.add(singleValue);\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.addLong(value);\n+                break;\n+        }\n+    }\n+\n+    public boolean contains(int value) {\n+        return contains(Util.toUnsignedLong(value));\n+    }\n+\n+    public boolean contains(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE_VALUE:\n+                return singleValue == value;\n+            case BITMAP_VALUE:\n+                return bitmap.contains(value);\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public long cardinality() {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE_VALUE:\n+                return 1;\n+            case BITMAP_VALUE:\n+                return bitmap.getLongCardinality();\n+        }\n+        return 0;\n+    }\n+\n+    public void serialize(DataOutput output) throws IOException {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                output.writeByte(EMPTY);\n+                break;\n+            case SINGLE_VALUE:\n+                // is 32-bit enough\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    output.write(SINGLE32);\n+                    output.writeInt((int)singleValue);\n+                } else {\n+                    output.writeByte(SINGLE64);\n+                    output.writeLong(singleValue);\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.serialize(output);\n+                break;\n+        }\n+    }\n+\n+    public void deserialize(DataInput input) throws IOException {\n+        clear();\n+        int bitmapType = input.readByte();\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE32:\n+                singleValue = Util.toUnsignedLong(input.readInt());\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE64:\n+                singleValue = input.readLong();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case BITMAP32:\n+            case BITMAP64:\n+                bitmap = bitmap == null ? new Roaring64Map() : bitmap;\n+                bitmap.deserialize(input, bitmapType);\n+                this.bitmapType = BITMAP_VALUE;\n+                break;\n+            default:\n+                throw new RuntimeException(String.format(\"unknown bitmap type %s \", bitmapType));\n+        }\n+    }\n+\n+    // In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+    public void and(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.singleValue == other.singleValue) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                    case BITMAP_VALUE:\n+                        if (other.bitmap.contains(singleValue)) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.bitmap.contains(other.singleValue)) {\n+                            clear();\n+                            this.bitmapType = SINGLE_VALUE;\n+                            this.singleValue = other.singleValue;\n+                        } else {\n+                            clear();\n+                        }\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.and(other.bitmap);\n+                        convertToSmallerType();\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    // In-place bitwise OR (union) operation. The current bitmap is modified.\n+    public void or(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.singleValue = other.singleValue;\n+                        this.bitmapType = SINGLE_VALUE;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        long thisSingleValue = this.singleValue;\n+                        clear();\n+                        add(thisSingleValue);\n+                        add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        other.add(this.singleValue);\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.or(other.bitmap);\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public boolean equals(BitmapValue other) {\n+        boolean ret = false;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        ret = true;\n+                        break;\n+                    case SINGLE_VALUE:\n+                    case BITMAP_VALUE:\n+                        ret = false;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case BITMAP_VALUE:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        ret = this.singleValue == other.singleValue;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case SINGLE_VALUE:\n+                        ret = false;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        ret = bitmap.equals(other.bitmap);\n+                        break;\n+                }\n+                break;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     *  usage note:\n+     *      now getSizeInBytes is different from be' impl\n+     *      The reason is that java's roaring didn't implement method #shrinkToFit but be's getSizeInBytes need it\n+     *      Implementing java's shrinkToFit means refactor roaring whose fields are all unaccess in Doris Fe's package\n+     *      That would be an another big project\n+     */\n+    // TODO(wb): keep getSizeInBytes consistent with be and refactor roaring\n+    public long getSizeInBytes() {\n+        long size = 0;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                size = 1;\n+                break;\n+            case SINGLE_VALUE:\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    size = 1 + 4;\n+                } else {\n+                    size = 1 + 8;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                size = 1 + bitmap.getSizeInBytes();\n+        }\n+        return size;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String toStringStr = \"{}\";\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                toStringStr = String.format(\"{%s}\", singleValue);\n+                break;\n+            case BITMAP_VALUE:\n+                toStringStr = this.bitmap.toString();\n+                break;\n+        }\n+        return toStringStr;\n+    }\n+\n+    public void clear() {\n+        this.bitmapType = EMPTY;\n+        this.bitmap = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4Njk1NA=="}, "originalCommit": {"oid": "b96746713b8d4d93cabb832c3f3017fc385c727d"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTM2NTA3OnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNTowMzo1OVrOF8LTkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwMjo1MDoxNlrOF8haXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY0NDExNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Unlike RoaringBitmap, there is no specification for now: it may change from onve java version\n          \n          \n            \n                 * Unlike RoaringBitmap, there is no specification for now: it may change from one java version", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r398644115", "createdAt": "2020-03-26T15:03:59Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "diffHunk": "@@ -0,0 +1,1462 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.BitmapDataProvider;\n+import org.roaringbitmap.BitmapDataProviderSupplier;\n+import org.roaringbitmap.IntConsumer;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapSupplier;\n+import org.roaringbitmap.Util;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.roaringbitmap.longlong.ImmutableLongBitmapDataProvider;\n+import org.roaringbitmap.longlong.LongConsumer;\n+import org.roaringbitmap.longlong.LongIterator;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import static org.apache.doris.common.util.Util.decodeVarint64;\n+import static org.apache.doris.common.util.Util.encodeVarint64;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP32;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP64;\n+\n+/**\n+ *\n+ * forked version 0.8.13\n+ * major change as below :\n+ *  1. overwrite serialize/deserialize method\n+ *  2. add a new method is32BitsEnough\n+ *  3. fork some Util method from org.roaringbitmap.longlong RoaringIntPacking\n+ * for details to see the end of the class\n+ */\n+public class Roaring64Map {\n+\n+    // Not final to enable initialization in Externalizable.readObject\n+    private NavigableMap<Integer, BitmapDataProvider> highToBitmap;\n+\n+    // If true, we handle longs a plain java longs: -1 if right before 0\n+    // If false, we handle longs as unsigned longs: 0 has no predecessor and Long.MAX_VALUE + 1L is\n+    // expressed as a\n+    // negative long\n+    private boolean signedLongs = false;\n+\n+    private BitmapDataProviderSupplier supplier;\n+\n+    // By default, we cache cardinalities\n+    private transient boolean doCacheCardinalities = true;\n+\n+    // Prevent recomputing all cardinalities when requesting consecutive ranks\n+    private transient int firstHighNotValid = highestHigh() + 1;\n+\n+    // This boolean needs firstHighNotValid == Integer.MAX_VALUE to be allowed to be true\n+    // If false, it means nearly all cumulated cardinalities are valid, except high=Integer.MAX_VALUE\n+    // If true, it means all cumulated cardinalities are valid, even high=Integer.MAX_VALUE\n+    private transient boolean allValid = false;\n+\n+    // TODO: I would prefer not managing arrays myself\n+    private transient long[] sortedCumulatedCardinality = new long[0];\n+    private transient int[] sortedHighs = new int[0];\n+\n+    // We guess consecutive .addLong will be on proximate longs: we remember the bitmap attached to\n+    // this bucket in order\n+    // to skip the indirection\n+    private transient Map.Entry<Integer, BitmapDataProvider> latestAddedHigh = null;\n+\n+    private static final boolean DEFAULT_ORDER_IS_SIGNED = false;\n+    private static final boolean DEFAULT_CARDINALITIES_ARE_CACHED = true;\n+\n+    /**\n+     * By default, we consider longs are unsigned longs: normal longs: 0 is the lowest possible long.\n+     * Long.MAX_VALUE is followed by Long.MIN_VALUE. -1L is the highest possible value\n+     */\n+    public Roaring64Map() {\n+        this(DEFAULT_ORDER_IS_SIGNED);\n+    }\n+\n+    /**\n+     *\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     */\n+    public Roaring64Map(boolean signedLongs) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED);\n+    }\n+\n+    /**\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities) {\n+        this(signedLongs, cacheCardinalities, new RoaringBitmapSupplier());\n+    }\n+\n+    /**\n+     * By default, longs are managed as unsigned longs and cardinalities are cached.\n+     *\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(BitmapDataProviderSupplier supplier) {\n+        this(DEFAULT_ORDER_IS_SIGNED, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     * By default, we activating cardinalities caching.\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, BitmapDataProviderSupplier supplier) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities,\n+                        BitmapDataProviderSupplier supplier) {\n+        this.signedLongs = signedLongs;\n+        this.supplier = supplier;\n+\n+        if (signedLongs) {\n+            highToBitmap = new TreeMap<>();\n+        } else {\n+            highToBitmap = new TreeMap<>(unsignedComparator());\n+        }\n+\n+        this.doCacheCardinalities = cacheCardinalities;\n+        resetPerfHelpers();\n+    }\n+\n+    private void resetPerfHelpers() {\n+        firstHighNotValid = highestHigh(signedLongs) + 1;\n+        allValid = false;\n+\n+        sortedCumulatedCardinality = new long[0];\n+        sortedHighs = new int[0];\n+\n+        latestAddedHigh = null;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    NavigableMap<Integer, BitmapDataProvider> getHighToBitmap() {\n+        return highToBitmap;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    int getLowestInvalidHigh() {\n+        return firstHighNotValid;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    long[] getSortedCumulatedCardinality() {\n+        return sortedCumulatedCardinality;\n+    }\n+\n+    /**\n+     * Add the value to the container (set the value to \"true\"), whether it already appears or not.\n+     *\n+     * Java lacks native unsigned longs but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Long#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 9223372036854775807, -9223372036854775808, -9223372036854775807,..., -1.\n+     *\n+     * @param x long value\n+     */\n+    public void addLong(long x) {\n+        int high = high(x);\n+        int low = low(x);\n+\n+        // Copy the reference to prevent race-condition\n+        Map.Entry<Integer, BitmapDataProvider> local = latestAddedHigh;\n+\n+        BitmapDataProvider bitmap;\n+        if (local != null && local.getKey().intValue() == high) {\n+            bitmap = local.getValue();\n+        } else {\n+            bitmap = highToBitmap.get(high);\n+            if (bitmap == null) {\n+                bitmap = newRoaringBitmap();\n+                pushBitmapForHigh(high, bitmap);\n+            }\n+            latestAddedHigh = new AbstractMap.SimpleImmutableEntry<>(high, bitmap);\n+        }\n+        bitmap.add(low);\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /**\n+     * Add the integer value to the container (set the value to \"true\"), whether it already appears or\n+     * not.\n+     *\n+     * Javac lacks native unsigned integers but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Integer#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 2147483647, -2147483648, -2147483647,..., -1.\n+     *\n+     * @param x integer value\n+     */\n+    public void addInt(int x) {\n+        addLong(Util.toUnsignedLong(x));\n+    }\n+\n+    private BitmapDataProvider newRoaringBitmap() {\n+        return supplier.newEmpty();\n+    }\n+\n+    private void invalidateAboveHigh(int high) {\n+        // The cardinalities after this bucket may not be valid anymore\n+        if (compare(firstHighNotValid, high) > 0) {\n+            // High was valid up to now\n+            firstHighNotValid = high;\n+\n+            int indexNotValid = binarySearch(sortedHighs, firstHighNotValid);\n+\n+            final int indexAfterWhichToReset;\n+            if (indexNotValid >= 0) {\n+                indexAfterWhichToReset = indexNotValid;\n+            } else {\n+                // We have invalidate a high not already present: added a value for a brand new high\n+                indexAfterWhichToReset = -indexNotValid - 1;\n+            }\n+\n+            // This way, sortedHighs remains sorted, without making a new/shorter array\n+            Arrays.fill(sortedHighs, indexAfterWhichToReset, sortedHighs.length, highestHigh());\n+        }\n+        allValid = false;\n+    }\n+\n+    private int compare(int x, int y) {\n+        if (signedLongs) {\n+            return Integer.compare(x, y);\n+        } else {\n+            return compareUnsigned(x, y);\n+        }\n+    }\n+\n+    private void pushBitmapForHigh(int high, BitmapDataProvider bitmap) {\n+        // TODO .size is too slow\n+        // int nbHighBefore = highToBitmap.headMap(high).size();\n+\n+        BitmapDataProvider previous = highToBitmap.put(high, bitmap);\n+        assert previous == null : \"Should push only not-existing high\";\n+    }\n+\n+    /**\n+     * Returns the number of distinct integers added to the bitmap (e.g., number of bits set).\n+     *\n+     * @return the cardinality\n+     */\n+    public long getLongCardinality() {\n+        if (doCacheCardinalities) {\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+            int indexOk = ensureCumulatives(highestHigh());\n+\n+            // ensureCumulatives may have removed empty bitmaps\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+\n+\n+            return sortedCumulatedCardinality[indexOk - 1];\n+        } else {\n+            long cardinality = 0L;\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                cardinality += bitmap.getLongCardinality();\n+            }\n+            return cardinality;\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return the cardinality as an int\n+     *\n+     * @throws UnsupportedOperationException if the cardinality does not fit in an int\n+     */\n+    public int getIntCardinality() throws UnsupportedOperationException {\n+        long cardinality = getLongCardinality();\n+\n+        if (cardinality > Integer.MAX_VALUE) {\n+            // TODO: we should handle cardinality fitting in an unsigned int\n+            throw new UnsupportedOperationException(\n+                    \"Can not call .getIntCardinality as the cardinality is bigger than Integer.MAX_VALUE\");\n+        }\n+\n+        return (int) cardinality;\n+    }\n+\n+    /**\n+     * Return the jth value stored in this bitmap.\n+     *\n+     * @param j index of the value\n+     *\n+     * @return the value\n+     * @throws IllegalArgumentException if j is out of the bounds of the bitmap cardinality\n+     */\n+    public long select(final long j) throws IllegalArgumentException {\n+        if (!doCacheCardinalities) {\n+            return selectNoCache(j);\n+        }\n+\n+        // Ensure all cumulatives as we we have straightforward way to know in advance the high of the\n+        // j-th value\n+        int indexOk = ensureCumulatives(highestHigh());\n+\n+        if (highToBitmap.isEmpty()) {\n+            return throwSelectInvalidIndex(j);\n+        }\n+\n+        // Use normal binarySearch as cardinality does not depends on considering longs signed or\n+        // unsigned\n+        // We need sortedCumulatedCardinality not to contain duplicated, else binarySearch may return\n+        // any of the duplicates: we need to ensure it holds no high associated to an empty bitmap\n+        int position = Arrays.binarySearch(sortedCumulatedCardinality, 0, indexOk, j);\n+\n+        if (position >= 0) {\n+            if (position == indexOk - 1) {\n+                // .select has been called on this.getCardinality\n+                return throwSelectInvalidIndex(j);\n+            }\n+\n+            // There is a bucket leading to this cardinality: the j-th element is the first element of\n+            // next bucket\n+            int high = sortedHighs[position + 1];\n+            BitmapDataProvider nextBitmap = highToBitmap.get(high);\n+            return pack(high, nextBitmap.select(0));\n+        } else {\n+            // There is no bucket with this cardinality\n+            int insertionPoint = -position - 1;\n+\n+            final long previousBucketCardinality;\n+            if (insertionPoint == 0) {\n+                previousBucketCardinality = 0L;\n+            } else if (insertionPoint >= indexOk) {\n+                return throwSelectInvalidIndex(j);\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+\n+            // We get a 'select' query for a single bitmap: should fit in an int\n+            final int givenBitmapSelect = (int) (j - previousBucketCardinality);\n+\n+            int high = sortedHighs[insertionPoint];\n+            BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+            int low = lowBitmap.select(givenBitmapSelect);\n+\n+            return pack(high, low);\n+        }\n+    }\n+\n+    // For benchmarks: compute without using cardinalities cache\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long selectNoCache(long j) {\n+        long left = j;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            long lowCardinality = entry.getValue().getCardinality();\n+\n+            if (left >= lowCardinality) {\n+                left -= lowCardinality;\n+            } else {\n+                // It is legit for left to be negative\n+                int leftAsUnsignedInt = (int) left;\n+                return pack(entry.getKey(), entry.getValue().select(leftAsUnsignedInt));\n+            }\n+        }\n+\n+        return throwSelectInvalidIndex(j);\n+    }\n+\n+    private long throwSelectInvalidIndex(long j) {\n+        // see org.roaringbitmap.buffer.ImmutableRoaringBitmap.select(int)\n+        throw new IllegalArgumentException(\n+                \"select \" + j + \" when the cardinality is \" + this.getLongCardinality());\n+    }\n+\n+    /**\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public Iterator<Long> iterator() {\n+        final LongIterator it = getLongIterator();\n+\n+        return new Iterator<Long>() {\n+\n+            @Override\n+            public boolean hasNext() {\n+                return it.hasNext();\n+            }\n+\n+            @Override\n+            public Long next() {\n+                return it.next();\n+            }\n+\n+            @Override\n+            public void remove() {\n+                // TODO?\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    public void forEach(final LongConsumer lc) {\n+        for (final Map.Entry<Integer, BitmapDataProvider> highEntry : highToBitmap.entrySet()) {\n+            highEntry.getValue().forEach(new IntConsumer() {\n+\n+                @Override\n+                public void accept(int low) {\n+                    lc.accept(pack(highEntry.getKey(), low));\n+                }\n+            });\n+        }\n+    }\n+\n+    public long rankLong(long id) {\n+        int high = high(id);\n+        int low = low(id);\n+\n+        if (!doCacheCardinalities) {\n+            return rankLongNoCache(high, low);\n+        }\n+\n+        int indexOk = ensureCumulatives(high);\n+\n+        int highPosition = binarySearch(sortedHighs, 0, indexOk, high);\n+\n+        if (highPosition >= 0) {\n+            // There is a bucket holding this item\n+\n+            final long previousBucketCardinality;\n+            if (highPosition == 0) {\n+                previousBucketCardinality = 0;\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[highPosition - 1];\n+            }\n+\n+            BitmapDataProvider lowBitmap = highToBitmap.get(sortedHighs[highPosition]);\n+\n+            // Rank is previous cardinality plus rank in current bitmap\n+            return previousBucketCardinality + lowBitmap.rankLong(low);\n+        } else {\n+            // There is no bucket holding this item: insertionPoint is previous bitmap\n+            int insertionPoint = -highPosition - 1;\n+\n+            if (insertionPoint == 0) {\n+                // this key is before all inserted keys\n+                return 0;\n+            } else {\n+                // The rank is the cardinality of this previous bitmap\n+                return sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+        }\n+    }\n+\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long rankLongNoCache(int high, int low) {\n+        long result = 0L;\n+\n+        BitmapDataProvider lastBitmap = highToBitmap.get(high);\n+        if (lastBitmap == null) {\n+            // There is no value with same high: the rank is a sum of cardinalities\n+            for (Map.Entry<Integer, BitmapDataProvider> bitmap : highToBitmap.entrySet()) {\n+                if (bitmap.getKey().intValue() > high) {\n+                    break;\n+                } else {\n+                    result += bitmap.getValue().getLongCardinality();\n+                }\n+            }\n+        } else {\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                if (bitmap == lastBitmap) {\n+                    result += bitmap.rankLong(low);\n+                    break;\n+                } else {\n+                    result += bitmap.getLongCardinality();\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param high for which high bucket should we compute the cardinality\n+     * @return the highest validatedIndex\n+     */\n+    protected int ensureCumulatives(int high) {\n+        if (allValid) {\n+            // the whole array is valid (up-to its actual length, not its capacity)\n+            return highToBitmap.size();\n+        } else if (compare(high, firstHighNotValid) < 0) {\n+            // The high is strictly below the first not valid: it is valid\n+\n+            // sortedHighs may have only a subset of valid values on the right. However, these invalid\n+            // values have been set to maxValue, and we are here as high < firstHighNotValid ==> high <\n+            // maxHigh()\n+            int position = binarySearch(sortedHighs, high);\n+\n+            if (position >= 0) {\n+                // This high has a bitmap: +1 as this index will be used as right (excluded) bound in a\n+                // binary-search\n+                return position + 1;\n+            } else {\n+                // This high has no bitmap: it could be between 2 highs with bitmaps\n+                int insertionPosition = -position - 1;\n+                return insertionPosition;\n+            }\n+        } else {\n+\n+            // For each deprecated buckets\n+            SortedMap<Integer, BitmapDataProvider> tailMap =\n+                    highToBitmap.tailMap(firstHighNotValid, true);\n+\n+            // TODO .size on tailMap make an iterator: arg\n+            int indexOk = highToBitmap.size() - tailMap.size();\n+\n+            // TODO: It should be possible to compute indexOk based on sortedHighs array\n+            // assert indexOk == binarySearch(sortedHighs, firstHighNotValid);\n+\n+            Iterator<Map.Entry<Integer, BitmapDataProvider>> it = tailMap.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry<Integer, BitmapDataProvider> e = it.next();\n+                int currentHigh = e.getKey();\n+\n+                if (compare(currentHigh, high) > 0) {\n+                    // No need to compute more than needed\n+                    break;\n+                } else if (e.getValue().isEmpty()) {\n+                    // highToBitmap can not be modified as we iterate over it\n+                    if (latestAddedHigh != null && latestAddedHigh.getKey().intValue() == currentHigh) {\n+                        // Dismiss the cached bitmap as it is removed from the NavigableMap\n+                        latestAddedHigh = null;\n+                    }\n+                    it.remove();\n+                } else {\n+                    ensureOne(e, currentHigh, indexOk);\n+\n+                    // We have added one valid cardinality\n+                    indexOk++;\n+                }\n+\n+            }\n+\n+            if (highToBitmap.isEmpty() || indexOk == highToBitmap.size()) {\n+                // We have compute all cardinalities\n+                allValid = true;\n+            }\n+\n+            return indexOk;\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, key);\n+        } else {\n+            return unsignedBinarySearch(array, 0, array.length, key,\n+                    unsignedComparator());\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int from, int to, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, from, to, key);\n+        } else {\n+            return unsignedBinarySearch(array, from, to, key, unsignedComparator());\n+        }\n+    }\n+\n+    // From Arrays.binarySearch (Comparator). Check with org.roaringbitmap.Util.unsignedBinarySearch\n+    private static int unsignedBinarySearch(int[] a, int fromIndex, int toIndex, int key,\n+                                            Comparator<? super Integer> c) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+            int midVal = a[mid];\n+            int cmp = c.compare(midVal, key);\n+            if (cmp < 0) {\n+                low = mid + 1;\n+            } else if (cmp > 0) {\n+                high = mid - 1;\n+            } else {\n+                return mid; // key found\n+            }\n+        }\n+        return -(low + 1); // key not found.\n+    }\n+\n+    private void ensureOne(Map.Entry<Integer, BitmapDataProvider> e, int currentHigh, int indexOk) {\n+        // sortedHighs are valid only up to some index\n+        assert indexOk <= sortedHighs.length : indexOk + \" is bigger than \" + sortedHighs.length;\n+\n+        final int index;\n+        if (indexOk == 0) {\n+            if (sortedHighs.length == 0) {\n+                index = -1;\n+                // } else if (sortedHighs[0] == currentHigh) {\n+                // index = 0;\n+            } else {\n+                index = -1;\n+            }\n+        } else if (indexOk < sortedHighs.length) {\n+            index = -indexOk - 1;\n+        } else {\n+            index = -sortedHighs.length - 1;\n+        }\n+        assert index == binarySearch(sortedHighs, 0, indexOk, currentHigh) : \"Computed \" + index\n+                + \" differs from dummy binary-search index: \"\n+                + binarySearch(sortedHighs, 0, indexOk, currentHigh);\n+\n+        if (index >= 0) {\n+            // This would mean calling .ensureOne is useless: should never got here at the first time\n+            throw new IllegalStateException(\"Unexpectedly found \" + currentHigh + \" in \"\n+                    + Arrays.toString(sortedHighs) + \" strictly before index\" + indexOk);\n+        } else {\n+            int insertionPosition = -index - 1;\n+\n+            // This is a new key\n+            if (insertionPosition >= sortedHighs.length) {\n+                int previousSize = sortedHighs.length;\n+\n+                // TODO softer growing factor\n+                int newSize = Math.min(Integer.MAX_VALUE, sortedHighs.length * 2 + 1);\n+\n+                // Insertion at the end\n+                sortedHighs = Arrays.copyOf(sortedHighs, newSize);\n+                sortedCumulatedCardinality = Arrays.copyOf(sortedCumulatedCardinality, newSize);\n+\n+                // Not actually needed. But simplify the reading of array content\n+                Arrays.fill(sortedHighs, previousSize, sortedHighs.length, highestHigh());\n+                Arrays.fill(sortedCumulatedCardinality, previousSize, sortedHighs.length, Long.MAX_VALUE);\n+            }\n+            sortedHighs[insertionPosition] = currentHigh;\n+\n+            final long previousCardinality;\n+            if (insertionPosition >= 1) {\n+                previousCardinality = sortedCumulatedCardinality[insertionPosition - 1];\n+            } else {\n+                previousCardinality = 0;\n+            }\n+\n+            sortedCumulatedCardinality[insertionPosition] =\n+                    previousCardinality + e.getValue().getLongCardinality();\n+\n+            if (currentHigh == highestHigh()) {\n+                // We are already on the highest high. Do not set allValid as it is set anyway out of the\n+                // loop\n+                firstHighNotValid = currentHigh;\n+            } else {\n+                // The first not valid is the next high\n+                // TODO: The entry comes from a NavigableMap: it may be quite cheap to know the next high\n+                firstHighNotValid = currentHigh + 1;\n+            }\n+        }\n+    }\n+\n+\n+\n+    private int highestHigh() {\n+        return highestHigh(signedLongs);\n+    }\n+\n+    /**\n+     * In-place bitwise OR (union) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void or(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).or((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).or((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise XOR (symmetric difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void xor(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).xor((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).xor((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void and(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 == null) {\n+                // None of given high values are present in x2\n+                thisIterator.remove();\n+            } else {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).and((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).and((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * In-place bitwise ANDNOT (difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void andNot(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 != null) {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).andNot((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).andNot((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A string describing the bitmap.\n+     *\n+     * @return the string\n+     */\n+    @Override\n+    public String toString() {\n+        final StringBuilder answer = new StringBuilder();\n+        final LongIterator i = this.getLongIterator();\n+        answer.append(\"{\");\n+        if (i.hasNext()) {\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+        }\n+        while (i.hasNext()) {\n+            answer.append(\",\");\n+            // to avoid using too much memory, we limit the size\n+            if (answer.length() > 0x80000) {\n+                answer.append(\"...\");\n+                break;\n+            }\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+\n+        }\n+        answer.append(\"}\");\n+        return answer.toString();\n+    }\n+\n+\n+    /**\n+     *\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public LongIterator getLongIterator() {\n+        final Iterator<Map.Entry<Integer, BitmapDataProvider>> it = highToBitmap.entrySet().iterator();\n+\n+        return toIterator(it, false);\n+    }\n+\n+    protected LongIterator toIterator(final Iterator<Map.Entry<Integer, BitmapDataProvider>> it,\n+                                      final boolean reversed) {\n+        return new LongIterator() {\n+\n+            protected int currentKey;\n+            protected IntIterator currentIt;\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (currentIt == null) {\n+                    // Were initially empty\n+                    if (!moveToNextEntry(it)) {\n+                        return false;\n+                    }\n+                }\n+\n+                while (true) {\n+                    if (currentIt.hasNext()) {\n+                        return true;\n+                    } else {\n+                        if (!moveToNextEntry(it)) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            /**\n+             *\n+             * @param it the underlying iterator which has to be moved to next long\n+             * @return true if we MAY have more entries. false if there is definitely nothing more\n+             */\n+            private boolean moveToNextEntry(Iterator<Map.Entry<Integer, BitmapDataProvider>> it) {\n+                if (it.hasNext()) {\n+                    Map.Entry<Integer, BitmapDataProvider> next = it.next();\n+                    currentKey = next.getKey();\n+                    if (reversed) {\n+                        currentIt = next.getValue().getReverseIntIterator();\n+                    } else {\n+                        currentIt = next.getValue().getIntIterator();\n+                    }\n+\n+                    // We may have more long\n+                    return true;\n+                } else {\n+                    // We know there is nothing more\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public long next() {\n+                if (hasNext()) {\n+                    return pack(currentKey, currentIt.next());\n+                } else {\n+                    throw new IllegalStateException(\"empty\");\n+                }\n+            }\n+\n+            @Override\n+            public LongIterator clone() {\n+                throw new UnsupportedOperationException(\"TODO\");\n+            }\n+        };\n+    }\n+\n+    public boolean contains(long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            return false;\n+        }\n+\n+        int low = low(x);\n+        return lowBitmap.contains(low);\n+    }\n+\n+\n+    public int getSizeInBytes() {\n+        return (int) getLongSizeInBytes();\n+    }\n+\n+    public long getLongSizeInBytes() {\n+        long size = 8;\n+\n+        // Size of containers\n+        size += highToBitmap.values().stream().mapToLong(p -> p.getLongSizeInBytes()).sum();\n+\n+        // Size of Map data-structure: we consider each TreeMap entry costs 40 bytes\n+        // http://java-performance.info/memory-consumption-of-java-data-types-2/\n+        size += 8 + 40 * highToBitmap.size();\n+\n+        // Size of (boxed) Integers used as keys\n+        size += 16 * highToBitmap.size();\n+\n+        // The cache impacts the size in heap\n+        size += 8 * sortedCumulatedCardinality.length;\n+        size += 4 * sortedHighs.length;\n+\n+        return size;\n+    }\n+\n+    public boolean isEmpty() {\n+        return getLongCardinality() == 0L;\n+    }\n+\n+    public ImmutableLongBitmapDataProvider limit(long x) {\n+        throw new UnsupportedOperationException(\"TODO\");\n+    }\n+\n+    /**\n+     * Use a run-length encoding where it is estimated as more space efficient\n+     *\n+     * @return whether a change was applied\n+     */\n+    public boolean runOptimize() {\n+        boolean hasChanged = false;\n+        for (BitmapDataProvider lowBitmap : highToBitmap.values()) {\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                hasChanged |= ((RoaringBitmap) lowBitmap).runOptimize();\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                hasChanged |= ((MutableRoaringBitmap) lowBitmap).runOptimize();\n+            }\n+        }\n+        return hasChanged;\n+    }\n+\n+    public long serializedSizeInBytes() {\n+        long nbBytes = 0L;\n+\n+        // .writeBoolean for signedLongs boolean\n+        nbBytes += 1;\n+\n+        // .writeInt for number of different high values\n+        nbBytes += 4;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            // .writeInt for high\n+            nbBytes += 4;\n+\n+            // The low bitmap size in bytes\n+            nbBytes += entry.getValue().serializedSizeInBytes();\n+        }\n+\n+        return nbBytes;\n+    }\n+\n+    /**\n+     * reset to an empty bitmap; result occupies as much space a newly created bitmap.\n+     */\n+    public void clear() {\n+        this.highToBitmap.clear();\n+        resetPerfHelpers();\n+    }\n+\n+    /**\n+     * Return the set values as an array, if the cardinality is smaller than 2147483648. The long\n+     * values are in sorted order.\n+     *\n+     * @return array representing the set values.\n+     */\n+    public long[] toArray() {\n+        long cardinality = this.getLongCardinality();\n+        if (cardinality > Integer.MAX_VALUE) {\n+            throw new IllegalStateException(\"The cardinality does not fit in an array\");\n+        }\n+\n+        final long[] array = new long[(int) cardinality];\n+\n+        int pos = 0;\n+        LongIterator it = getLongIterator();\n+\n+        while (it.hasNext()) {\n+            array[pos++] = it.next();\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Generate a bitmap with the specified values set to true. The provided longs values don't have\n+     * to be in sorted order, but it may be preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     * @return a new bitmap\n+     */\n+    public static Roaring64Map bitmapOf(final long... dat) {\n+        final Roaring64Map ans = new Roaring64Map();\n+        ans.add(dat);\n+        return ans;\n+    }\n+\n+    /**\n+     * Set all the specified values to true. This can be expected to be slightly faster than calling\n+     * \"add\" repeatedly. The provided integers values don't have to be in sorted order, but it may be\n+     * preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     */\n+    public void add(long... dat) {\n+        for (long oneLong : dat) {\n+            addLong(oneLong);\n+        }\n+    }\n+\n+    /**\n+     * Add to the current bitmap all longs in [rangeStart,rangeEnd).\n+     *\n+     * @param rangeStart inclusive beginning of range\n+     * @param rangeEnd exclusive ending of range\n+     */\n+    public void add(final long rangeStart, final long rangeEnd) {\n+        int startHigh = high(rangeStart);\n+        int startLow = low(rangeStart);\n+\n+        int endHigh = high(rangeEnd);\n+        int endLow = low(rangeEnd);\n+\n+        for (int high = startHigh; high <= endHigh; high++) {\n+            final int currentStartLow;\n+            if (startHigh == high) {\n+                // The whole range starts in this bucket\n+                currentStartLow = startLow;\n+            } else {\n+                // Add the bucket from the beginning\n+                currentStartLow = 0;\n+            }\n+\n+            long startLowAsLong = Util.toUnsignedLong(currentStartLow);\n+\n+            final long endLowAsLong;\n+            if (endHigh == high) {\n+                // The whole range ends in this bucket\n+                endLowAsLong = Util.toUnsignedLong(endLow);\n+            } else {\n+                // Add the bucket until the end: we have a +1 as, in RoaringBitmap.add(long,long), the end\n+                // is excluded\n+                endLowAsLong = Util.toUnsignedLong(-1) + 1;\n+            }\n+\n+            if (endLowAsLong > startLowAsLong) {\n+                // Initialize the bitmap only if there is access data to write\n+                BitmapDataProvider bitmap = highToBitmap.get(high);\n+                if (bitmap == null) {\n+                    bitmap = new MutableRoaringBitmap();\n+                    pushBitmapForHigh(high, bitmap);\n+                }\n+\n+                if (bitmap instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else if (bitmap instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else {\n+                    throw new UnsupportedOperationException(\"TODO. Not for \" + bitmap.getClass());\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(startHigh);\n+    }\n+\n+    public LongIterator getReverseLongIterator() {\n+        return toIterator(highToBitmap.descendingMap().entrySet().iterator(), true);\n+    }\n+\n+    public void removeLong(long x) {\n+        int high = high(x);\n+\n+        BitmapDataProvider bitmap = highToBitmap.get(high);\n+\n+        if (bitmap != null) {\n+            int low = low(x);\n+            bitmap.remove(low);\n+\n+            // Invalidate only if actually modified\n+            invalidateAboveHigh(high);\n+        }\n+\n+    }\n+\n+    public void trim() {\n+        for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+            bitmap.trim();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return highToBitmap.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        Roaring64Map other = (Roaring64Map) obj;\n+        return Objects.equals(highToBitmap, other.highToBitmap);\n+    }\n+\n+\n+\n+    /**\n+     * Add the value if it is not already present, otherwise remove it.\n+     *\n+     * @param x long value\n+     */\n+    public void flip(final long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            // The value is not added: add it without any flip specific code\n+            addLong(x);\n+        } else {\n+            int low = low(x);\n+\n+            // .flip is not in BitmapDataProvider contract\n+            // TODO Is it relevant to calling .flip with a cast?\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                ((RoaringBitmap) lowBitmap).flip(low);\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                ((MutableRoaringBitmap) lowBitmap).flip(low);\n+            } else {\n+                // Fallback to a manual flip\n+                if (lowBitmap.contains(low)) {\n+                    lowBitmap.remove(low);\n+                } else {\n+                    lowBitmap.add(low);\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /* ------------------ method below from Roaring64NavigableMap and being overwritten ----------------------------- */\n+\n+    /**\n+     * Serialize this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from onve java version", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3791cce57938755efc442cb6036ddea3916ebdcd"}, "originalPosition": 1304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAwNjMwMQ==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r399006301", "createdAt": "2020-03-27T02:50:16Z", "author": {"login": "wangbo"}, "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "diffHunk": "@@ -0,0 +1,1462 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.BitmapDataProvider;\n+import org.roaringbitmap.BitmapDataProviderSupplier;\n+import org.roaringbitmap.IntConsumer;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapSupplier;\n+import org.roaringbitmap.Util;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.roaringbitmap.longlong.ImmutableLongBitmapDataProvider;\n+import org.roaringbitmap.longlong.LongConsumer;\n+import org.roaringbitmap.longlong.LongIterator;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import static org.apache.doris.common.util.Util.decodeVarint64;\n+import static org.apache.doris.common.util.Util.encodeVarint64;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP32;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP64;\n+\n+/**\n+ *\n+ * forked version 0.8.13\n+ * major change as below :\n+ *  1. overwrite serialize/deserialize method\n+ *  2. add a new method is32BitsEnough\n+ *  3. fork some Util method from org.roaringbitmap.longlong RoaringIntPacking\n+ * for details to see the end of the class\n+ */\n+public class Roaring64Map {\n+\n+    // Not final to enable initialization in Externalizable.readObject\n+    private NavigableMap<Integer, BitmapDataProvider> highToBitmap;\n+\n+    // If true, we handle longs a plain java longs: -1 if right before 0\n+    // If false, we handle longs as unsigned longs: 0 has no predecessor and Long.MAX_VALUE + 1L is\n+    // expressed as a\n+    // negative long\n+    private boolean signedLongs = false;\n+\n+    private BitmapDataProviderSupplier supplier;\n+\n+    // By default, we cache cardinalities\n+    private transient boolean doCacheCardinalities = true;\n+\n+    // Prevent recomputing all cardinalities when requesting consecutive ranks\n+    private transient int firstHighNotValid = highestHigh() + 1;\n+\n+    // This boolean needs firstHighNotValid == Integer.MAX_VALUE to be allowed to be true\n+    // If false, it means nearly all cumulated cardinalities are valid, except high=Integer.MAX_VALUE\n+    // If true, it means all cumulated cardinalities are valid, even high=Integer.MAX_VALUE\n+    private transient boolean allValid = false;\n+\n+    // TODO: I would prefer not managing arrays myself\n+    private transient long[] sortedCumulatedCardinality = new long[0];\n+    private transient int[] sortedHighs = new int[0];\n+\n+    // We guess consecutive .addLong will be on proximate longs: we remember the bitmap attached to\n+    // this bucket in order\n+    // to skip the indirection\n+    private transient Map.Entry<Integer, BitmapDataProvider> latestAddedHigh = null;\n+\n+    private static final boolean DEFAULT_ORDER_IS_SIGNED = false;\n+    private static final boolean DEFAULT_CARDINALITIES_ARE_CACHED = true;\n+\n+    /**\n+     * By default, we consider longs are unsigned longs: normal longs: 0 is the lowest possible long.\n+     * Long.MAX_VALUE is followed by Long.MIN_VALUE. -1L is the highest possible value\n+     */\n+    public Roaring64Map() {\n+        this(DEFAULT_ORDER_IS_SIGNED);\n+    }\n+\n+    /**\n+     *\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     */\n+    public Roaring64Map(boolean signedLongs) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED);\n+    }\n+\n+    /**\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities) {\n+        this(signedLongs, cacheCardinalities, new RoaringBitmapSupplier());\n+    }\n+\n+    /**\n+     * By default, longs are managed as unsigned longs and cardinalities are cached.\n+     *\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(BitmapDataProviderSupplier supplier) {\n+        this(DEFAULT_ORDER_IS_SIGNED, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     * By default, we activating cardinalities caching.\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, BitmapDataProviderSupplier supplier) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities,\n+                        BitmapDataProviderSupplier supplier) {\n+        this.signedLongs = signedLongs;\n+        this.supplier = supplier;\n+\n+        if (signedLongs) {\n+            highToBitmap = new TreeMap<>();\n+        } else {\n+            highToBitmap = new TreeMap<>(unsignedComparator());\n+        }\n+\n+        this.doCacheCardinalities = cacheCardinalities;\n+        resetPerfHelpers();\n+    }\n+\n+    private void resetPerfHelpers() {\n+        firstHighNotValid = highestHigh(signedLongs) + 1;\n+        allValid = false;\n+\n+        sortedCumulatedCardinality = new long[0];\n+        sortedHighs = new int[0];\n+\n+        latestAddedHigh = null;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    NavigableMap<Integer, BitmapDataProvider> getHighToBitmap() {\n+        return highToBitmap;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    int getLowestInvalidHigh() {\n+        return firstHighNotValid;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    long[] getSortedCumulatedCardinality() {\n+        return sortedCumulatedCardinality;\n+    }\n+\n+    /**\n+     * Add the value to the container (set the value to \"true\"), whether it already appears or not.\n+     *\n+     * Java lacks native unsigned longs but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Long#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 9223372036854775807, -9223372036854775808, -9223372036854775807,..., -1.\n+     *\n+     * @param x long value\n+     */\n+    public void addLong(long x) {\n+        int high = high(x);\n+        int low = low(x);\n+\n+        // Copy the reference to prevent race-condition\n+        Map.Entry<Integer, BitmapDataProvider> local = latestAddedHigh;\n+\n+        BitmapDataProvider bitmap;\n+        if (local != null && local.getKey().intValue() == high) {\n+            bitmap = local.getValue();\n+        } else {\n+            bitmap = highToBitmap.get(high);\n+            if (bitmap == null) {\n+                bitmap = newRoaringBitmap();\n+                pushBitmapForHigh(high, bitmap);\n+            }\n+            latestAddedHigh = new AbstractMap.SimpleImmutableEntry<>(high, bitmap);\n+        }\n+        bitmap.add(low);\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /**\n+     * Add the integer value to the container (set the value to \"true\"), whether it already appears or\n+     * not.\n+     *\n+     * Javac lacks native unsigned integers but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Integer#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 2147483647, -2147483648, -2147483647,..., -1.\n+     *\n+     * @param x integer value\n+     */\n+    public void addInt(int x) {\n+        addLong(Util.toUnsignedLong(x));\n+    }\n+\n+    private BitmapDataProvider newRoaringBitmap() {\n+        return supplier.newEmpty();\n+    }\n+\n+    private void invalidateAboveHigh(int high) {\n+        // The cardinalities after this bucket may not be valid anymore\n+        if (compare(firstHighNotValid, high) > 0) {\n+            // High was valid up to now\n+            firstHighNotValid = high;\n+\n+            int indexNotValid = binarySearch(sortedHighs, firstHighNotValid);\n+\n+            final int indexAfterWhichToReset;\n+            if (indexNotValid >= 0) {\n+                indexAfterWhichToReset = indexNotValid;\n+            } else {\n+                // We have invalidate a high not already present: added a value for a brand new high\n+                indexAfterWhichToReset = -indexNotValid - 1;\n+            }\n+\n+            // This way, sortedHighs remains sorted, without making a new/shorter array\n+            Arrays.fill(sortedHighs, indexAfterWhichToReset, sortedHighs.length, highestHigh());\n+        }\n+        allValid = false;\n+    }\n+\n+    private int compare(int x, int y) {\n+        if (signedLongs) {\n+            return Integer.compare(x, y);\n+        } else {\n+            return compareUnsigned(x, y);\n+        }\n+    }\n+\n+    private void pushBitmapForHigh(int high, BitmapDataProvider bitmap) {\n+        // TODO .size is too slow\n+        // int nbHighBefore = highToBitmap.headMap(high).size();\n+\n+        BitmapDataProvider previous = highToBitmap.put(high, bitmap);\n+        assert previous == null : \"Should push only not-existing high\";\n+    }\n+\n+    /**\n+     * Returns the number of distinct integers added to the bitmap (e.g., number of bits set).\n+     *\n+     * @return the cardinality\n+     */\n+    public long getLongCardinality() {\n+        if (doCacheCardinalities) {\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+            int indexOk = ensureCumulatives(highestHigh());\n+\n+            // ensureCumulatives may have removed empty bitmaps\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+\n+\n+            return sortedCumulatedCardinality[indexOk - 1];\n+        } else {\n+            long cardinality = 0L;\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                cardinality += bitmap.getLongCardinality();\n+            }\n+            return cardinality;\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return the cardinality as an int\n+     *\n+     * @throws UnsupportedOperationException if the cardinality does not fit in an int\n+     */\n+    public int getIntCardinality() throws UnsupportedOperationException {\n+        long cardinality = getLongCardinality();\n+\n+        if (cardinality > Integer.MAX_VALUE) {\n+            // TODO: we should handle cardinality fitting in an unsigned int\n+            throw new UnsupportedOperationException(\n+                    \"Can not call .getIntCardinality as the cardinality is bigger than Integer.MAX_VALUE\");\n+        }\n+\n+        return (int) cardinality;\n+    }\n+\n+    /**\n+     * Return the jth value stored in this bitmap.\n+     *\n+     * @param j index of the value\n+     *\n+     * @return the value\n+     * @throws IllegalArgumentException if j is out of the bounds of the bitmap cardinality\n+     */\n+    public long select(final long j) throws IllegalArgumentException {\n+        if (!doCacheCardinalities) {\n+            return selectNoCache(j);\n+        }\n+\n+        // Ensure all cumulatives as we we have straightforward way to know in advance the high of the\n+        // j-th value\n+        int indexOk = ensureCumulatives(highestHigh());\n+\n+        if (highToBitmap.isEmpty()) {\n+            return throwSelectInvalidIndex(j);\n+        }\n+\n+        // Use normal binarySearch as cardinality does not depends on considering longs signed or\n+        // unsigned\n+        // We need sortedCumulatedCardinality not to contain duplicated, else binarySearch may return\n+        // any of the duplicates: we need to ensure it holds no high associated to an empty bitmap\n+        int position = Arrays.binarySearch(sortedCumulatedCardinality, 0, indexOk, j);\n+\n+        if (position >= 0) {\n+            if (position == indexOk - 1) {\n+                // .select has been called on this.getCardinality\n+                return throwSelectInvalidIndex(j);\n+            }\n+\n+            // There is a bucket leading to this cardinality: the j-th element is the first element of\n+            // next bucket\n+            int high = sortedHighs[position + 1];\n+            BitmapDataProvider nextBitmap = highToBitmap.get(high);\n+            return pack(high, nextBitmap.select(0));\n+        } else {\n+            // There is no bucket with this cardinality\n+            int insertionPoint = -position - 1;\n+\n+            final long previousBucketCardinality;\n+            if (insertionPoint == 0) {\n+                previousBucketCardinality = 0L;\n+            } else if (insertionPoint >= indexOk) {\n+                return throwSelectInvalidIndex(j);\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+\n+            // We get a 'select' query for a single bitmap: should fit in an int\n+            final int givenBitmapSelect = (int) (j - previousBucketCardinality);\n+\n+            int high = sortedHighs[insertionPoint];\n+            BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+            int low = lowBitmap.select(givenBitmapSelect);\n+\n+            return pack(high, low);\n+        }\n+    }\n+\n+    // For benchmarks: compute without using cardinalities cache\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long selectNoCache(long j) {\n+        long left = j;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            long lowCardinality = entry.getValue().getCardinality();\n+\n+            if (left >= lowCardinality) {\n+                left -= lowCardinality;\n+            } else {\n+                // It is legit for left to be negative\n+                int leftAsUnsignedInt = (int) left;\n+                return pack(entry.getKey(), entry.getValue().select(leftAsUnsignedInt));\n+            }\n+        }\n+\n+        return throwSelectInvalidIndex(j);\n+    }\n+\n+    private long throwSelectInvalidIndex(long j) {\n+        // see org.roaringbitmap.buffer.ImmutableRoaringBitmap.select(int)\n+        throw new IllegalArgumentException(\n+                \"select \" + j + \" when the cardinality is \" + this.getLongCardinality());\n+    }\n+\n+    /**\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public Iterator<Long> iterator() {\n+        final LongIterator it = getLongIterator();\n+\n+        return new Iterator<Long>() {\n+\n+            @Override\n+            public boolean hasNext() {\n+                return it.hasNext();\n+            }\n+\n+            @Override\n+            public Long next() {\n+                return it.next();\n+            }\n+\n+            @Override\n+            public void remove() {\n+                // TODO?\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    public void forEach(final LongConsumer lc) {\n+        for (final Map.Entry<Integer, BitmapDataProvider> highEntry : highToBitmap.entrySet()) {\n+            highEntry.getValue().forEach(new IntConsumer() {\n+\n+                @Override\n+                public void accept(int low) {\n+                    lc.accept(pack(highEntry.getKey(), low));\n+                }\n+            });\n+        }\n+    }\n+\n+    public long rankLong(long id) {\n+        int high = high(id);\n+        int low = low(id);\n+\n+        if (!doCacheCardinalities) {\n+            return rankLongNoCache(high, low);\n+        }\n+\n+        int indexOk = ensureCumulatives(high);\n+\n+        int highPosition = binarySearch(sortedHighs, 0, indexOk, high);\n+\n+        if (highPosition >= 0) {\n+            // There is a bucket holding this item\n+\n+            final long previousBucketCardinality;\n+            if (highPosition == 0) {\n+                previousBucketCardinality = 0;\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[highPosition - 1];\n+            }\n+\n+            BitmapDataProvider lowBitmap = highToBitmap.get(sortedHighs[highPosition]);\n+\n+            // Rank is previous cardinality plus rank in current bitmap\n+            return previousBucketCardinality + lowBitmap.rankLong(low);\n+        } else {\n+            // There is no bucket holding this item: insertionPoint is previous bitmap\n+            int insertionPoint = -highPosition - 1;\n+\n+            if (insertionPoint == 0) {\n+                // this key is before all inserted keys\n+                return 0;\n+            } else {\n+                // The rank is the cardinality of this previous bitmap\n+                return sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+        }\n+    }\n+\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long rankLongNoCache(int high, int low) {\n+        long result = 0L;\n+\n+        BitmapDataProvider lastBitmap = highToBitmap.get(high);\n+        if (lastBitmap == null) {\n+            // There is no value with same high: the rank is a sum of cardinalities\n+            for (Map.Entry<Integer, BitmapDataProvider> bitmap : highToBitmap.entrySet()) {\n+                if (bitmap.getKey().intValue() > high) {\n+                    break;\n+                } else {\n+                    result += bitmap.getValue().getLongCardinality();\n+                }\n+            }\n+        } else {\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                if (bitmap == lastBitmap) {\n+                    result += bitmap.rankLong(low);\n+                    break;\n+                } else {\n+                    result += bitmap.getLongCardinality();\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param high for which high bucket should we compute the cardinality\n+     * @return the highest validatedIndex\n+     */\n+    protected int ensureCumulatives(int high) {\n+        if (allValid) {\n+            // the whole array is valid (up-to its actual length, not its capacity)\n+            return highToBitmap.size();\n+        } else if (compare(high, firstHighNotValid) < 0) {\n+            // The high is strictly below the first not valid: it is valid\n+\n+            // sortedHighs may have only a subset of valid values on the right. However, these invalid\n+            // values have been set to maxValue, and we are here as high < firstHighNotValid ==> high <\n+            // maxHigh()\n+            int position = binarySearch(sortedHighs, high);\n+\n+            if (position >= 0) {\n+                // This high has a bitmap: +1 as this index will be used as right (excluded) bound in a\n+                // binary-search\n+                return position + 1;\n+            } else {\n+                // This high has no bitmap: it could be between 2 highs with bitmaps\n+                int insertionPosition = -position - 1;\n+                return insertionPosition;\n+            }\n+        } else {\n+\n+            // For each deprecated buckets\n+            SortedMap<Integer, BitmapDataProvider> tailMap =\n+                    highToBitmap.tailMap(firstHighNotValid, true);\n+\n+            // TODO .size on tailMap make an iterator: arg\n+            int indexOk = highToBitmap.size() - tailMap.size();\n+\n+            // TODO: It should be possible to compute indexOk based on sortedHighs array\n+            // assert indexOk == binarySearch(sortedHighs, firstHighNotValid);\n+\n+            Iterator<Map.Entry<Integer, BitmapDataProvider>> it = tailMap.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry<Integer, BitmapDataProvider> e = it.next();\n+                int currentHigh = e.getKey();\n+\n+                if (compare(currentHigh, high) > 0) {\n+                    // No need to compute more than needed\n+                    break;\n+                } else if (e.getValue().isEmpty()) {\n+                    // highToBitmap can not be modified as we iterate over it\n+                    if (latestAddedHigh != null && latestAddedHigh.getKey().intValue() == currentHigh) {\n+                        // Dismiss the cached bitmap as it is removed from the NavigableMap\n+                        latestAddedHigh = null;\n+                    }\n+                    it.remove();\n+                } else {\n+                    ensureOne(e, currentHigh, indexOk);\n+\n+                    // We have added one valid cardinality\n+                    indexOk++;\n+                }\n+\n+            }\n+\n+            if (highToBitmap.isEmpty() || indexOk == highToBitmap.size()) {\n+                // We have compute all cardinalities\n+                allValid = true;\n+            }\n+\n+            return indexOk;\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, key);\n+        } else {\n+            return unsignedBinarySearch(array, 0, array.length, key,\n+                    unsignedComparator());\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int from, int to, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, from, to, key);\n+        } else {\n+            return unsignedBinarySearch(array, from, to, key, unsignedComparator());\n+        }\n+    }\n+\n+    // From Arrays.binarySearch (Comparator). Check with org.roaringbitmap.Util.unsignedBinarySearch\n+    private static int unsignedBinarySearch(int[] a, int fromIndex, int toIndex, int key,\n+                                            Comparator<? super Integer> c) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+            int midVal = a[mid];\n+            int cmp = c.compare(midVal, key);\n+            if (cmp < 0) {\n+                low = mid + 1;\n+            } else if (cmp > 0) {\n+                high = mid - 1;\n+            } else {\n+                return mid; // key found\n+            }\n+        }\n+        return -(low + 1); // key not found.\n+    }\n+\n+    private void ensureOne(Map.Entry<Integer, BitmapDataProvider> e, int currentHigh, int indexOk) {\n+        // sortedHighs are valid only up to some index\n+        assert indexOk <= sortedHighs.length : indexOk + \" is bigger than \" + sortedHighs.length;\n+\n+        final int index;\n+        if (indexOk == 0) {\n+            if (sortedHighs.length == 0) {\n+                index = -1;\n+                // } else if (sortedHighs[0] == currentHigh) {\n+                // index = 0;\n+            } else {\n+                index = -1;\n+            }\n+        } else if (indexOk < sortedHighs.length) {\n+            index = -indexOk - 1;\n+        } else {\n+            index = -sortedHighs.length - 1;\n+        }\n+        assert index == binarySearch(sortedHighs, 0, indexOk, currentHigh) : \"Computed \" + index\n+                + \" differs from dummy binary-search index: \"\n+                + binarySearch(sortedHighs, 0, indexOk, currentHigh);\n+\n+        if (index >= 0) {\n+            // This would mean calling .ensureOne is useless: should never got here at the first time\n+            throw new IllegalStateException(\"Unexpectedly found \" + currentHigh + \" in \"\n+                    + Arrays.toString(sortedHighs) + \" strictly before index\" + indexOk);\n+        } else {\n+            int insertionPosition = -index - 1;\n+\n+            // This is a new key\n+            if (insertionPosition >= sortedHighs.length) {\n+                int previousSize = sortedHighs.length;\n+\n+                // TODO softer growing factor\n+                int newSize = Math.min(Integer.MAX_VALUE, sortedHighs.length * 2 + 1);\n+\n+                // Insertion at the end\n+                sortedHighs = Arrays.copyOf(sortedHighs, newSize);\n+                sortedCumulatedCardinality = Arrays.copyOf(sortedCumulatedCardinality, newSize);\n+\n+                // Not actually needed. But simplify the reading of array content\n+                Arrays.fill(sortedHighs, previousSize, sortedHighs.length, highestHigh());\n+                Arrays.fill(sortedCumulatedCardinality, previousSize, sortedHighs.length, Long.MAX_VALUE);\n+            }\n+            sortedHighs[insertionPosition] = currentHigh;\n+\n+            final long previousCardinality;\n+            if (insertionPosition >= 1) {\n+                previousCardinality = sortedCumulatedCardinality[insertionPosition - 1];\n+            } else {\n+                previousCardinality = 0;\n+            }\n+\n+            sortedCumulatedCardinality[insertionPosition] =\n+                    previousCardinality + e.getValue().getLongCardinality();\n+\n+            if (currentHigh == highestHigh()) {\n+                // We are already on the highest high. Do not set allValid as it is set anyway out of the\n+                // loop\n+                firstHighNotValid = currentHigh;\n+            } else {\n+                // The first not valid is the next high\n+                // TODO: The entry comes from a NavigableMap: it may be quite cheap to know the next high\n+                firstHighNotValid = currentHigh + 1;\n+            }\n+        }\n+    }\n+\n+\n+\n+    private int highestHigh() {\n+        return highestHigh(signedLongs);\n+    }\n+\n+    /**\n+     * In-place bitwise OR (union) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void or(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).or((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).or((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise XOR (symmetric difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void xor(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).xor((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).xor((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void and(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 == null) {\n+                // None of given high values are present in x2\n+                thisIterator.remove();\n+            } else {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).and((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).and((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * In-place bitwise ANDNOT (difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void andNot(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 != null) {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).andNot((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).andNot((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A string describing the bitmap.\n+     *\n+     * @return the string\n+     */\n+    @Override\n+    public String toString() {\n+        final StringBuilder answer = new StringBuilder();\n+        final LongIterator i = this.getLongIterator();\n+        answer.append(\"{\");\n+        if (i.hasNext()) {\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+        }\n+        while (i.hasNext()) {\n+            answer.append(\",\");\n+            // to avoid using too much memory, we limit the size\n+            if (answer.length() > 0x80000) {\n+                answer.append(\"...\");\n+                break;\n+            }\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+\n+        }\n+        answer.append(\"}\");\n+        return answer.toString();\n+    }\n+\n+\n+    /**\n+     *\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public LongIterator getLongIterator() {\n+        final Iterator<Map.Entry<Integer, BitmapDataProvider>> it = highToBitmap.entrySet().iterator();\n+\n+        return toIterator(it, false);\n+    }\n+\n+    protected LongIterator toIterator(final Iterator<Map.Entry<Integer, BitmapDataProvider>> it,\n+                                      final boolean reversed) {\n+        return new LongIterator() {\n+\n+            protected int currentKey;\n+            protected IntIterator currentIt;\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (currentIt == null) {\n+                    // Were initially empty\n+                    if (!moveToNextEntry(it)) {\n+                        return false;\n+                    }\n+                }\n+\n+                while (true) {\n+                    if (currentIt.hasNext()) {\n+                        return true;\n+                    } else {\n+                        if (!moveToNextEntry(it)) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            /**\n+             *\n+             * @param it the underlying iterator which has to be moved to next long\n+             * @return true if we MAY have more entries. false if there is definitely nothing more\n+             */\n+            private boolean moveToNextEntry(Iterator<Map.Entry<Integer, BitmapDataProvider>> it) {\n+                if (it.hasNext()) {\n+                    Map.Entry<Integer, BitmapDataProvider> next = it.next();\n+                    currentKey = next.getKey();\n+                    if (reversed) {\n+                        currentIt = next.getValue().getReverseIntIterator();\n+                    } else {\n+                        currentIt = next.getValue().getIntIterator();\n+                    }\n+\n+                    // We may have more long\n+                    return true;\n+                } else {\n+                    // We know there is nothing more\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public long next() {\n+                if (hasNext()) {\n+                    return pack(currentKey, currentIt.next());\n+                } else {\n+                    throw new IllegalStateException(\"empty\");\n+                }\n+            }\n+\n+            @Override\n+            public LongIterator clone() {\n+                throw new UnsupportedOperationException(\"TODO\");\n+            }\n+        };\n+    }\n+\n+    public boolean contains(long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            return false;\n+        }\n+\n+        int low = low(x);\n+        return lowBitmap.contains(low);\n+    }\n+\n+\n+    public int getSizeInBytes() {\n+        return (int) getLongSizeInBytes();\n+    }\n+\n+    public long getLongSizeInBytes() {\n+        long size = 8;\n+\n+        // Size of containers\n+        size += highToBitmap.values().stream().mapToLong(p -> p.getLongSizeInBytes()).sum();\n+\n+        // Size of Map data-structure: we consider each TreeMap entry costs 40 bytes\n+        // http://java-performance.info/memory-consumption-of-java-data-types-2/\n+        size += 8 + 40 * highToBitmap.size();\n+\n+        // Size of (boxed) Integers used as keys\n+        size += 16 * highToBitmap.size();\n+\n+        // The cache impacts the size in heap\n+        size += 8 * sortedCumulatedCardinality.length;\n+        size += 4 * sortedHighs.length;\n+\n+        return size;\n+    }\n+\n+    public boolean isEmpty() {\n+        return getLongCardinality() == 0L;\n+    }\n+\n+    public ImmutableLongBitmapDataProvider limit(long x) {\n+        throw new UnsupportedOperationException(\"TODO\");\n+    }\n+\n+    /**\n+     * Use a run-length encoding where it is estimated as more space efficient\n+     *\n+     * @return whether a change was applied\n+     */\n+    public boolean runOptimize() {\n+        boolean hasChanged = false;\n+        for (BitmapDataProvider lowBitmap : highToBitmap.values()) {\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                hasChanged |= ((RoaringBitmap) lowBitmap).runOptimize();\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                hasChanged |= ((MutableRoaringBitmap) lowBitmap).runOptimize();\n+            }\n+        }\n+        return hasChanged;\n+    }\n+\n+    public long serializedSizeInBytes() {\n+        long nbBytes = 0L;\n+\n+        // .writeBoolean for signedLongs boolean\n+        nbBytes += 1;\n+\n+        // .writeInt for number of different high values\n+        nbBytes += 4;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            // .writeInt for high\n+            nbBytes += 4;\n+\n+            // The low bitmap size in bytes\n+            nbBytes += entry.getValue().serializedSizeInBytes();\n+        }\n+\n+        return nbBytes;\n+    }\n+\n+    /**\n+     * reset to an empty bitmap; result occupies as much space a newly created bitmap.\n+     */\n+    public void clear() {\n+        this.highToBitmap.clear();\n+        resetPerfHelpers();\n+    }\n+\n+    /**\n+     * Return the set values as an array, if the cardinality is smaller than 2147483648. The long\n+     * values are in sorted order.\n+     *\n+     * @return array representing the set values.\n+     */\n+    public long[] toArray() {\n+        long cardinality = this.getLongCardinality();\n+        if (cardinality > Integer.MAX_VALUE) {\n+            throw new IllegalStateException(\"The cardinality does not fit in an array\");\n+        }\n+\n+        final long[] array = new long[(int) cardinality];\n+\n+        int pos = 0;\n+        LongIterator it = getLongIterator();\n+\n+        while (it.hasNext()) {\n+            array[pos++] = it.next();\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Generate a bitmap with the specified values set to true. The provided longs values don't have\n+     * to be in sorted order, but it may be preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     * @return a new bitmap\n+     */\n+    public static Roaring64Map bitmapOf(final long... dat) {\n+        final Roaring64Map ans = new Roaring64Map();\n+        ans.add(dat);\n+        return ans;\n+    }\n+\n+    /**\n+     * Set all the specified values to true. This can be expected to be slightly faster than calling\n+     * \"add\" repeatedly. The provided integers values don't have to be in sorted order, but it may be\n+     * preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     */\n+    public void add(long... dat) {\n+        for (long oneLong : dat) {\n+            addLong(oneLong);\n+        }\n+    }\n+\n+    /**\n+     * Add to the current bitmap all longs in [rangeStart,rangeEnd).\n+     *\n+     * @param rangeStart inclusive beginning of range\n+     * @param rangeEnd exclusive ending of range\n+     */\n+    public void add(final long rangeStart, final long rangeEnd) {\n+        int startHigh = high(rangeStart);\n+        int startLow = low(rangeStart);\n+\n+        int endHigh = high(rangeEnd);\n+        int endLow = low(rangeEnd);\n+\n+        for (int high = startHigh; high <= endHigh; high++) {\n+            final int currentStartLow;\n+            if (startHigh == high) {\n+                // The whole range starts in this bucket\n+                currentStartLow = startLow;\n+            } else {\n+                // Add the bucket from the beginning\n+                currentStartLow = 0;\n+            }\n+\n+            long startLowAsLong = Util.toUnsignedLong(currentStartLow);\n+\n+            final long endLowAsLong;\n+            if (endHigh == high) {\n+                // The whole range ends in this bucket\n+                endLowAsLong = Util.toUnsignedLong(endLow);\n+            } else {\n+                // Add the bucket until the end: we have a +1 as, in RoaringBitmap.add(long,long), the end\n+                // is excluded\n+                endLowAsLong = Util.toUnsignedLong(-1) + 1;\n+            }\n+\n+            if (endLowAsLong > startLowAsLong) {\n+                // Initialize the bitmap only if there is access data to write\n+                BitmapDataProvider bitmap = highToBitmap.get(high);\n+                if (bitmap == null) {\n+                    bitmap = new MutableRoaringBitmap();\n+                    pushBitmapForHigh(high, bitmap);\n+                }\n+\n+                if (bitmap instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else if (bitmap instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else {\n+                    throw new UnsupportedOperationException(\"TODO. Not for \" + bitmap.getClass());\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(startHigh);\n+    }\n+\n+    public LongIterator getReverseLongIterator() {\n+        return toIterator(highToBitmap.descendingMap().entrySet().iterator(), true);\n+    }\n+\n+    public void removeLong(long x) {\n+        int high = high(x);\n+\n+        BitmapDataProvider bitmap = highToBitmap.get(high);\n+\n+        if (bitmap != null) {\n+            int low = low(x);\n+            bitmap.remove(low);\n+\n+            // Invalidate only if actually modified\n+            invalidateAboveHigh(high);\n+        }\n+\n+    }\n+\n+    public void trim() {\n+        for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+            bitmap.trim();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return highToBitmap.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        Roaring64Map other = (Roaring64Map) obj;\n+        return Objects.equals(highToBitmap, other.highToBitmap);\n+    }\n+\n+\n+\n+    /**\n+     * Add the value if it is not already present, otherwise remove it.\n+     *\n+     * @param x long value\n+     */\n+    public void flip(final long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            // The value is not added: add it without any flip specific code\n+            addLong(x);\n+        } else {\n+            int low = low(x);\n+\n+            // .flip is not in BitmapDataProvider contract\n+            // TODO Is it relevant to calling .flip with a cast?\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                ((RoaringBitmap) lowBitmap).flip(low);\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                ((MutableRoaringBitmap) lowBitmap).flip(low);\n+            } else {\n+                // Fallback to a manual flip\n+                if (lowBitmap.contains(low)) {\n+                    lowBitmap.remove(low);\n+                } else {\n+                    lowBitmap.add(low);\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /* ------------------ method below from Roaring64NavigableMap and being overwritten ----------------------------- */\n+\n+    /**\n+     * Serialize this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from onve java version", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY0NDExNQ=="}, "originalCommit": {"oid": "3791cce57938755efc442cb6036ddea3916ebdcd"}, "originalPosition": 1304}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2103, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}