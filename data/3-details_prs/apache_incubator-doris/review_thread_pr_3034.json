{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzNDgyMTMz", "number": 3034, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMTowOTowMVrODlAJSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODoxNDowMFrODltfTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTI2MjgyOnYy", "diffSide": "RIGHT", "path": "be/src/exec/intersect_node.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMTowOTowMVrOFxpGHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMTowOTowMVrOFxpGHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5Nzg1NQ==", "bodyText": "use std::unique_ptr and std::unordered_set instead.", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387597855", "createdAt": "2020-03-04T11:09:01Z", "author": {"login": "chaoyli"}, "path": "be/src/exec/intersect_node.h", "diffHunk": "@@ -20,11 +20,17 @@\n #define  DORIS_BE_SRC_QUERY_EXEC_INTERSECT_NODE_H\n \n #include \"exec/exec_node.h\"\n-#include \"runtime/row_batch.h\"\n-#include \"runtime/runtime_state.h\"\n+\n+#include <boost/unordered_set.hpp>\n+#include <boost/scoped_ptr.hpp>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78da6934195e4aeb2824c7944019cb0ea13047d1"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTU2NTM0OnYy", "diffSide": "RIGHT", "path": "be/src/exec/intersect_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjo1MDowMFrOFxr95A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjo1MDowMFrOFxr95A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY0NDkwMA==", "bodyText": "Move the TODO?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387644900", "createdAt": "2020-03-04T12:50:00Z", "author": {"login": "morningman"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -17,36 +17,23 @@\n \n #include \"exec/intersect_node.h\"\n \n+#include \"exec/hash_table.hpp\"\n #include \"exprs/expr.h\"\n+#include \"runtime/row_batch.h\"\n+#include \"runtime/runtime_state.h\"\n \n namespace doris {\n // TODO(yangzhengguo) implememt this class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTU4MjgyOnYy", "diffSide": "RIGHT", "path": "be/src/exec/intersect_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjo1NTozMFrOFxsIhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjo1NTozMFrOFxsIhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY0NzYyMw==", "bodyText": "What's this comment mean?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387647623", "createdAt": "2020-03-04T12:55:30Z", "author": {"login": "morningman"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +43,177 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    // pre-computeselect k4 from t where k4 <4 the tuple index of build tuples in the output row", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTYwODQ0OnYy", "diffSide": "RIGHT", "path": "be/src/exec/intersect_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMzowMzowNVrOFxsYVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMzowMzowNVrOFxsYVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1MTY2OQ==", "bodyText": "the _children.size() is 2, so is it possible to enter this else?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387651669", "createdAt": "2020-03-04T13:03:05Z", "author": {"login": "morningman"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +43,177 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    // pre-computeselect k4 from t where k4 <4 the tuple index of build tuples in the output row\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(1)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // build hash table\n+        HashTable* temp_tbl =\n+                new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size, false,\n+                              _find_nulls, id(), mem_tracker(), 1024);\n+        if (i == 1) {\n+            _hash_tbl.reset(temp_tbl);\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+            RETURN_IF_ERROR(child(0)->open(state));\n+\n+            while (true) {\n+                RETURN_IF_CANCELLED(state);\n+                bool eos = true;\n+                RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+                // take ownership of tuple data of build_batch\n+                _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+                RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect, while constructing the hash table.\");\n+                for (int i = 0; i < build_batch.num_rows(); ++i) {\n+                    _hash_tbl->insert(build_batch.get_row(i));\n+                }\n+                VLOG_ROW << \"hash table content: \"\n+                         << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+                build_batch.reset();\n+\n+                if (eos) {\n+                    break;\n+                }\n+            }\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTY0NDg0OnYy", "diffSide": "RIGHT", "path": "be/src/exec/intersect_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMzoxMzo1MFrOFxst_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMzoxMzo1MFrOFxst_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1NzIxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect , while constructing the hash table.\");\n          \n          \n            \n                        RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect , while probing the hash table.\");", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387657215", "createdAt": "2020-03-04T13:13:50Z", "author": {"login": "morningman"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +43,177 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    // pre-computeselect k4 from t where k4 <4 the tuple index of build tuples in the output row\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(1)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // build hash table\n+        HashTable* temp_tbl =\n+                new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size, false,\n+                              _find_nulls, id(), mem_tracker(), 1024);\n+        if (i == 1) {\n+            _hash_tbl.reset(temp_tbl);\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+            RETURN_IF_ERROR(child(0)->open(state));\n+\n+            while (true) {\n+                RETURN_IF_CANCELLED(state);\n+                bool eos = true;\n+                RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+                // take ownership of tuple data of build_batch\n+                _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+                RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect, while constructing the hash table.\");\n+                for (int i = 0; i < build_batch.num_rows(); ++i) {\n+                    _hash_tbl->insert(build_batch.get_row(i));\n+                }\n+                VLOG_ROW << \"hash table content: \"\n+                         << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+                build_batch.reset();\n+\n+                if (eos) {\n+                    break;\n+                }\n+            }\n+        } else {\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (_hash_tbl_iterator.matched()) {\n+                    temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl->close();\n+            _hash_tbl.reset(temp_tbl);\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        while (true) {\n+            RETURN_IF_CANCELLED(state);\n+            bool eos = true;\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect , while constructing the hash table.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTY1NjQ0OnYy", "diffSide": "RIGHT", "path": "be/src/exec/intersect_node.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMzoxNzowOFrOFxs1HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMzoxNzowOFrOFxs1HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1OTAzNg==", "bodyText": "Not used?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387659036", "createdAt": "2020-03-04T13:17:08Z", "author": {"login": "morningman"}, "path": "be/src/exec/intersect_node.h", "diffHunk": "@@ -38,61 +44,36 @@ class IntersectNode : public ExecNode {\n \n     virtual Status init(const TPlanNode& tnode, RuntimeState* state = nullptr);\n     virtual Status prepare(RuntimeState* state);\n-    virtual void codegen(RuntimeState* state);\n     virtual Status open(RuntimeState* state);\n     virtual Status get_next(RuntimeState* state, RowBatch* row_batch, bool* eos);\n     // virtual Status reset(RuntimeState* state);\n     virtual Status close(RuntimeState* state);\n \n private:\n-    /// Tuple id resolved in Prepare() to set tuple_desc_;\n-    const int _tuple_id;\n-\n-    /// Descriptor for tuples this union node constructs.\n-    const TupleDescriptor* _tuple_desc;\n-\n-    /// Index of the first non-passthrough child; i.e. a child that needs materialization.\n-    /// 0 when all children are materialized, '_children.size()' when no children are\n-    /// materialized.\n-    const int _first_materialized_child_idx;\n-\n-    /// Const exprs materialized by this node. These exprs don't refer to any children.\n-    /// Only materialized by the first fragment instance to avoid duplication.\n+    // Const exprs materialized by this node. These exprs don't refer to any children.\n+    // Only materialized by the first fragment instance to avoid duplication.\n     std::vector<std::vector<ExprContext*>> _const_expr_lists;\n \n-    /// Exprs materialized by this node. The i-th result expr list refers to the i-th child.\n+    // Exprs materialized by this node. The i-th result expr list refers to the i-th child.\n     std::vector<std::vector<ExprContext*>> _child_expr_lists;\n \n-    /////////////////////////////////////////\n-    /// BEGIN: Members that must be Reset()\n-\n-    /// Index of current child.\n-    int _child_idx;\n-\n-    /// Current row batch of current child. We reset the pointer to a new RowBatch\n-    /// when switching to a different child.\n-    std::unique_ptr<RowBatch> _child_batch;\n-\n-    /// Index of current row in child_row_batch_.\n-    int _child_row_idx;\n-\n-    typedef void (*IntersectMaterializeBatchFn)(IntersectNode*, RowBatch*, uint8_t**);\n-    /// Vector of pointers to codegen'ed materialize_batch functions. The vector contains one\n-    /// function for each child. The size of the vector should be equal to the number of\n-    /// children. If a child is passthrough, there should be a NULL for that child. If\n-    /// Codegen is disabled, there should be a NULL for every child.\n-    std::vector<IntersectMaterializeBatchFn> _codegend_except_materialize_batch_fns;\n+    boost::scoped_ptr<HashTable> _hash_tbl;\n+    HashTable::Iterator _hash_tbl_iterator;\n+    boost::scoped_ptr<RowBatch> _probe_batch;\n \n-    /// Saved from the last to GetNext() on the current child.\n-    bool _child_eos;\n+    boost::scoped_ptr<MemPool> _build_pool;  // holds everything referenced in _hash_tbl\n \n-    /// Index of current const result expr list.\n-    int _const_expr_list_idx;\n+    // _build_tuple_idx[i] is the tuple index of child(1)'s tuple[i] in the output row\n+    std::vector<int> _build_tuple_idx;\n+    int _build_tuple_size;\n+    int _build_tuple_row_size;\n+    std::vector<bool> _find_nulls;\n \n-    /// Index of the child that needs to be closed on the next GetNext() call. Should be set\n-    /// to -1 if no child needs to be closed.\n-    int _to_close_child_idx;\n+    // for right outer joins, keep track of what's been joined\n+    typedef boost::unordered_set<TupleRow*> TempTupleRowSet;\n+    TempTupleRowSet _temp_rows;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODU5Njc2OnYy", "diffSide": "RIGHT", "path": "be/src/exec/intersect_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzoyOTo1MlrOFyvVlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzoyOTo1MlrOFyvVlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0ODY5NQ==", "bodyText": "const_expr_list not use? why not delete it?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388748695", "createdAt": "2020-03-06T07:29:52Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -17,36 +17,21 @@\n \n #include \"exec/intersect_node.h\"\n \n+#include \"exec/hash_table.hpp\"\n #include \"exprs/expr.h\"\n+#include \"runtime/row_batch.h\"\n+#include \"runtime/runtime_state.h\"\n \n namespace doris {\n-// TODO(yangzhengguo) implememt this class\n-IntersectNode::IntersectNode(ObjectPool* pool, const TPlanNode& tnode,\n-    const DescriptorTbl& descs)\n-    : ExecNode(pool, tnode, descs),\n-      _tuple_id(tnode.intersect_node.tuple_id),\n-      _tuple_desc(nullptr),\n-      _first_materialized_child_idx(tnode.intersect_node.first_materialized_child_idx),\n-      _child_idx(0),\n-      _child_batch(nullptr),\n-      _child_row_idx(0),\n-      _child_eos(false),\n-      _const_expr_list_idx(0),\n-      _to_close_child_idx(-1) {\n-}\n+IntersectNode::IntersectNode(ObjectPool* pool, const TPlanNode& tnode, const DescriptorTbl& descs)\n+        : ExecNode(pool, tnode, descs) {}\n \n Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n-    // RETURN_IF_ERROR(ExecNode::init(tnode, state));\n     RETURN_IF_ERROR(ExecNode::init(tnode, state));\n     DCHECK(tnode.__isset.intersect_node);\n     DCHECK_EQ(_conjunct_ctxs.size(), 0);\n-    // Create const_expr_ctx_lists_ from thrift exprs.\n-    auto& const_texpr_lists = tnode.intersect_node.const_expr_lists;\n-    for (auto& texprs : const_texpr_lists) {\n-        std::vector<ExprContext*> ctxs;\n-        RETURN_IF_ERROR(Expr::create_expr_trees(_pool, texprs, &ctxs));\n-        _const_expr_lists.push_back(ctxs);\n-    }\n+    DCHECK_GE(_children.size(), 2);\n+    DCHECK_EQ(tnode.intersect_node.const_expr_lists.size(), 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9ce0d7a19cd42f4d35152553996d12075ae69b"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODYyNTkxOnYy", "diffSide": "RIGHT", "path": "be/src/exec/intersect_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzo0Mzo0OFrOFyvnGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzo0Mzo0OFrOFyvnGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1MzE3OA==", "bodyText": "child\uff081\uff09\uff1f", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388753178", "createdAt": "2020-03-06T07:43:48Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(1)->row_desc().tuple_descriptors()[i];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9ce0d7a19cd42f4d35152553996d12075ae69b"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODY2OTMyOnYy", "diffSide": "RIGHT", "path": "be/src/exec/intersect_node.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODowNDowMVrOFywBNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwOToxMjozNlrOFyxu0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1OTg2MQ==", "bodyText": "why use _build_tuple_size? if 100 table intersect, the build_tuple_size = 100?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388759861", "createdAt": "2020-03-06T08:04:01Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "073464879d9d1cde63e99aafddbb3a2644a3425c"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc4NzkyMA==", "bodyText": "it means number of Tuples in the build tuple row  not table count", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388787920", "createdAt": "2020-03-06T09:12:36Z", "author": {"login": "yangzhg"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1OTg2MQ=="}, "originalCommit": {"oid": "073464879d9d1cde63e99aafddbb3a2644a3425c"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODY4MzA5OnYy", "diffSide": "RIGHT", "path": "be/src/exec/intersect_node.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODoxMDoxNlrOFywJkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwOToxMzo1MVrOFyxw-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MjAwMQ==", "bodyText": "if i > 0, we can also enter this branch,  child(0) may be wrong?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388762001", "createdAt": "2020-03-06T08:10:16Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),\n+                                          mem_tracker(), 1024));\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "073464879d9d1cde63e99aafddbb3a2644a3425c"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc4ODQ3NQ==", "bodyText": "no  it always use the first table\u2018s row desc", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388788475", "createdAt": "2020-03-06T09:13:51Z", "author": {"login": "yangzhg"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),\n+                                          mem_tracker(), 1024));\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MjAwMQ=="}, "originalCommit": {"oid": "073464879d9d1cde63e99aafddbb3a2644a3425c"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODY4NzA4OnYy", "diffSide": "RIGHT", "path": "be/src/exec/intersect_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODoxMTo0N1rOFywL1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODoxMTo0N1rOFywL1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MjU4Mw==", "bodyText": "when i = 0, the first table build  _hash_tbl , but you can't set matched() function.\nwhen i = 1, the _hash_tbl's \" _hash_tbl_iterator.matched() \"is true of false?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388762583", "createdAt": "2020-03-06T08:11:47Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),\n+                                          mem_tracker(), 1024));\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+            RETURN_IF_ERROR(child(0)->open(state));\n+\n+            while (true) {\n+                RETURN_IF_CANCELLED(state);\n+                bool eos = true;\n+                RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+                // take ownership of tuple data of build_batch\n+                _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+                RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect, while constructing the hash table.\");\n+                for (int j = 0; j < build_batch.num_rows(); ++j) {\n+                    _hash_tbl->insert(build_batch.get_row(j));\n+                }\n+                VLOG_ROW << \"hash table content: \"\n+                         << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+                build_batch.reset();\n+\n+                if (eos) {\n+                    break;\n+                }\n+            }\n+            // using next child to probe\n+            if (i < _children.size() - 1) {\n+                ++i;\n+            } else {\n+                break;\n+            }\n+        } else {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  false, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (_hash_tbl_iterator.matched()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "073464879d9d1cde63e99aafddbb3a2644a3425c"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODY5MTk5OnYy", "diffSide": "RIGHT", "path": "be/src/exec/intersect_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODoxNDowMFrOFywO2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODoxNDowMFrOFywO2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MzM1Mg==", "bodyText": "do you test the null value? can null  output.", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388763352", "createdAt": "2020-03-06T08:14:00Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),\n+                                          mem_tracker(), 1024));\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+            RETURN_IF_ERROR(child(0)->open(state));\n+\n+            while (true) {\n+                RETURN_IF_CANCELLED(state);\n+                bool eos = true;\n+                RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+                // take ownership of tuple data of build_batch\n+                _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+                RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect, while constructing the hash table.\");\n+                for (int j = 0; j < build_batch.num_rows(); ++j) {\n+                    _hash_tbl->insert(build_batch.get_row(j));\n+                }\n+                VLOG_ROW << \"hash table content: \"\n+                         << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+                build_batch.reset();\n+\n+                if (eos) {\n+                    break;\n+                }\n+            }\n+            // using next child to probe\n+            if (i < _children.size() - 1) {\n+                ++i;\n+            } else {\n+                break;\n+            }\n+        } else {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  false, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (_hash_tbl_iterator.matched()) {\n+                    temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                }\n+                _hash_tbl_iterator.next<false>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "073464879d9d1cde63e99aafddbb3a2644a3425c"}, "originalPosition": 150}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2065, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}