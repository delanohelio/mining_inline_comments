{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwNDgzNjMx", "number": 3637, "title": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch", "bodyText": "This CL adds MemSubTablet, MemTablet, WriteTx, PartialRowBatch classes, with partial write support.\nPart of #3466", "createdAt": "2020-05-20T03:27:25Z", "url": "https://github.com/apache/incubator-doris/pull/3637", "merged": true, "mergeCommit": {"oid": "7524c5ef63becb184583dae4111a19bcb0b43e22"}, "closed": true, "closedAt": "2020-05-30T02:33:11Z", "author": {"login": "decster"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjK52OAFqTQxNTQ1MjgwMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcmNsvFAFqTQyMTM3MDcxNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDUyODAx", "url": "https://github.com/apache/incubator-doris/pull/3637#pullrequestreview-415452801", "createdAt": "2020-05-20T15:24:54Z", "commit": {"oid": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNToyNDo1NFrOGYRRmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNToyNDo1NFrOGYRRmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEwMjA0Mw==", "bodyText": "The abbreviation of transaction is Txn. So better rename to WriteTxn", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428102043", "createdAt": "2020-05-20T15:24:54Z", "author": {"login": "morningman"}, "path": "be/src/olap/memory/write_tx.h", "diffHunk": "@@ -0,0 +1,58 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+#include \"olap/memory/partial_row_batch.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class PartialRowBatch;\n+\n+// Class for write transaction\n+//\n+// Note: Currently it stores all its operations in memory, to make things simple,\n+// so we can quickly complete the whole create/read/write pipeline. The data structure may\n+// change as the project evolves.\n+//\n+// TODO: add write to/load from WritexTx files in future.\n+class WriteTx {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODM5NzAz", "url": "https://github.com/apache/incubator-doris/pull/3637#pullrequestreview-415839703", "createdAt": "2020-05-21T02:33:22Z", "commit": {"oid": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjozMzoyMlrOGYkNsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMzowMDoxOFrOGYkn5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMjMzNg==", "bodyText": "Better to give a example about how to use this class.", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428412336", "createdAt": "2020-05-21T02:33:22Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/mem_sub_tablet.h", "diffHunk": "@@ -0,0 +1,101 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class HashIndex;\n+class ColumnReader;\n+class PartialRowReader;\n+class Column;\n+class ColumnWriter;\n+\n+// A MemTablet can contain multiple MemSubTablets (currently only one).\n+// MemSubTablet hold a HashIndex and a collection of columns.\n+// It supports single-writer multi-reader concurrently.\n+class MemSubTablet {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNDAwOA==", "bodyText": "Give an example about how to use this class", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428414008", "createdAt": "2020-05-21T02:40:01Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/partial_row_batch.h", "diffHunk": "@@ -0,0 +1,140 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// A chunk of memory that stores a batch of serialized partial rows\n+//\n+// Serialization format for a batch:\n+// 4 byte len | serialized partial row\n+// 4 byte len | serialized partial row\n+// ...\n+// 4 byte len | serialized partial row\n+//\n+// Serialization format for a partial row\n+// bit vector(se + null) byte size (2 byte) |\n+// bit vector mark set cells |\n+// bit vector mark nullable cells' null value |\n+// 8bit padding\n+// serialized not null cells\n+//\n+// Note: currently only fixed length column types are supported. All length and scalar types store\n+// in native byte order(little endian in x86-64).\n+//\n+// Note: The serialization format is simple, it only provides basic functionalities\n+// so we can quickly complete the whole create/read/write pipeline. The format may change\n+// as the project evolves.\n+class PartialRowBatch {\n+public:\n+    static const size_t DEFAULT_BYTE_CAPACITY = 1 << 20;\n+    static const size_t DEFAULT_ROW_CAPACIT = 1 << 16;\n+\n+    PartialRowBatch(scoped_refptr<Schema>* schema, size_t byte_capacity = DEFAULT_BYTE_CAPACITY,\n+                    size_t row_capacity = DEFAULT_ROW_CAPACIT);\n+    ~PartialRowBatch();\n+\n+    const Schema& schema() const { return *_schema.get(); }\n+\n+    size_t row_size() const { return _row_offsets.size(); }\n+    size_t row_capacity() const { return _row_capacity; }\n+    size_t byte_size() const { return _bsize; }\n+    size_t byte_capacity() const { return _byte_capacity; }\n+\n+    const uint8_t* get_row(size_t idx) const;\n+\n+private:\n+    friend class PartialRowWriter;\n+    friend class PartialRowReader;\n+    scoped_refptr<Schema> _schema;\n+    vector<uint32_t> _row_offsets;\n+    uint8_t* _data;\n+    size_t _bsize;\n+    size_t _byte_capacity;\n+    size_t _row_capacity;\n+};\n+\n+// Writer for PartialRowBatch", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNTQyMw==", "bodyText": "Seems the same with one in above function.", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428415423", "createdAt": "2020-05-21T02:45:42Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/partial_row_batch.cpp", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/partial_row_batch.h\"\n+\n+#include \"util/bitmap.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Methods for PartialRowBatch\n+\n+PartialRowBatch::PartialRowBatch(scoped_refptr<Schema>* schema, size_t byte_capacity,\n+                                 size_t row_capacity)\n+        : _schema(*schema) {\n+    _data = reinterpret_cast<uint8_t*>(aligned_malloc(byte_capacity, 64));\n+    _bsize = 0;\n+    if (!_data) {\n+        _byte_capacity = 0;\n+        _row_capacity = 0;\n+    }\n+    _byte_capacity = byte_capacity;\n+    _row_capacity = row_capacity;\n+}\n+\n+PartialRowBatch::~PartialRowBatch() {\n+    if (_data) {\n+        free(_data);\n+        _data = nullptr;\n+    }\n+    _bsize = 0;\n+    _byte_capacity = 0;\n+    _row_capacity = 0;\n+}\n+\n+const uint8_t* PartialRowBatch::get_row(size_t idx) const {\n+    if (!_data || idx >= _row_offsets.size()) {\n+        return nullptr;\n+    }\n+    return _data + _row_offsets[idx] + 4;\n+}\n+\n+// Methods for PartialRowWriter\n+\n+PartialRowWriter::PartialRowWriter(const Schema& schema)\n+        : _schema(schema), _bit_set_size(_schema.cid_size()), _bit_null_size(0) {\n+    _temp_cells.resize(_schema.cid_size());\n+}\n+\n+PartialRowWriter::~PartialRowWriter() {}\n+\n+void PartialRowWriter::start_row() {\n+    _bit_null_size = 0;\n+    memset(&(_temp_cells[0]), 0, sizeof(CellInfo) * _temp_cells.size());\n+}\n+\n+Status PartialRowWriter::write_row_to_batch(PartialRowBatch* batch) {\n+    if (batch->_row_offsets.size() >= batch->row_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    size_t row_byte_size = byte_size();\n+    if (batch->byte_size() + row_byte_size + 4 > batch->byte_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    *reinterpret_cast<uint32_t*>(batch->_data + batch->_bsize) = row_byte_size;\n+    uint8_t* pos = batch->_data + batch->_bsize + 4;\n+    RETURN_IF_ERROR(write(&pos));\n+    batch->_row_offsets.push_back(batch->_bsize);\n+    batch->_bsize = pos - batch->_data;\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set(const string& col, const void* data) {\n+    auto cs = _schema.get_by_name(col);\n+    if (!cs) {\n+        return Status::NotFound(\"col name not found\");\n+    }\n+    if (cs->type() == ColumnType::OLAP_FIELD_TYPE_VARCHAR) {\n+        return Status::NotSupported(\"var length type not supported\");\n+    }\n+    uint32_t cid = cs->cid();\n+    if (cs->is_nullable() || data) {\n+        if (cs->is_nullable() && !_temp_cells[cid].isnullable) {\n+            _bit_null_size++;\n+        }\n+        _temp_cells[cid].isnullable = cs->is_nullable();\n+        _temp_cells[cid].isset = 1;\n+        _temp_cells[cid].data = reinterpret_cast<const uint8_t*>(data);\n+    } else {\n+        return Status::InvalidArgument(\"not nullable\");\n+    }\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set(uint32_t cid, const void* data) {\n+    auto cs = _schema.get_by_cid(cid);\n+    if (!cs) {\n+        return Status::NotFound(\"cid not found\");\n+    }\n+    if (cs->is_nullable() || data) {\n+        if (cs->is_nullable() && !_temp_cells[cid].isnullable) {\n+            _bit_null_size++;\n+        }\n+        _temp_cells[cid].isnullable = cs->is_nullable();\n+        _temp_cells[cid].isset = 1;\n+        _temp_cells[cid].data = reinterpret_cast<const uint8_t*>(data);\n+    } else {\n+        return Status::InvalidArgument(\"not nullable column set to null\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNjA4Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (_temp_cells[i].data) {\n          \n          \n            \n                    if (_temp_cells[i].data != nullptr) {\n          \n      \n    \n    \n  \n\nprefer ptr != nullptr for pointer type", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428416082", "createdAt": "2020-05-21T02:48:27Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/partial_row_batch.cpp", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/partial_row_batch.h\"\n+\n+#include \"util/bitmap.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Methods for PartialRowBatch\n+\n+PartialRowBatch::PartialRowBatch(scoped_refptr<Schema>* schema, size_t byte_capacity,\n+                                 size_t row_capacity)\n+        : _schema(*schema) {\n+    _data = reinterpret_cast<uint8_t*>(aligned_malloc(byte_capacity, 64));\n+    _bsize = 0;\n+    if (!_data) {\n+        _byte_capacity = 0;\n+        _row_capacity = 0;\n+    }\n+    _byte_capacity = byte_capacity;\n+    _row_capacity = row_capacity;\n+}\n+\n+PartialRowBatch::~PartialRowBatch() {\n+    if (_data) {\n+        free(_data);\n+        _data = nullptr;\n+    }\n+    _bsize = 0;\n+    _byte_capacity = 0;\n+    _row_capacity = 0;\n+}\n+\n+const uint8_t* PartialRowBatch::get_row(size_t idx) const {\n+    if (!_data || idx >= _row_offsets.size()) {\n+        return nullptr;\n+    }\n+    return _data + _row_offsets[idx] + 4;\n+}\n+\n+// Methods for PartialRowWriter\n+\n+PartialRowWriter::PartialRowWriter(const Schema& schema)\n+        : _schema(schema), _bit_set_size(_schema.cid_size()), _bit_null_size(0) {\n+    _temp_cells.resize(_schema.cid_size());\n+}\n+\n+PartialRowWriter::~PartialRowWriter() {}\n+\n+void PartialRowWriter::start_row() {\n+    _bit_null_size = 0;\n+    memset(&(_temp_cells[0]), 0, sizeof(CellInfo) * _temp_cells.size());\n+}\n+\n+Status PartialRowWriter::write_row_to_batch(PartialRowBatch* batch) {\n+    if (batch->_row_offsets.size() >= batch->row_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    size_t row_byte_size = byte_size();\n+    if (batch->byte_size() + row_byte_size + 4 > batch->byte_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    *reinterpret_cast<uint32_t*>(batch->_data + batch->_bsize) = row_byte_size;\n+    uint8_t* pos = batch->_data + batch->_bsize + 4;\n+    RETURN_IF_ERROR(write(&pos));\n+    batch->_row_offsets.push_back(batch->_bsize);\n+    batch->_bsize = pos - batch->_data;\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set(const string& col, const void* data) {\n+    auto cs = _schema.get_by_name(col);\n+    if (!cs) {\n+        return Status::NotFound(\"col name not found\");\n+    }\n+    if (cs->type() == ColumnType::OLAP_FIELD_TYPE_VARCHAR) {\n+        return Status::NotSupported(\"var length type not supported\");\n+    }\n+    uint32_t cid = cs->cid();\n+    if (cs->is_nullable() || data) {\n+        if (cs->is_nullable() && !_temp_cells[cid].isnullable) {\n+            _bit_null_size++;\n+        }\n+        _temp_cells[cid].isnullable = cs->is_nullable();\n+        _temp_cells[cid].isset = 1;\n+        _temp_cells[cid].data = reinterpret_cast<const uint8_t*>(data);\n+    } else {\n+        return Status::InvalidArgument(\"not nullable\");\n+    }\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set(uint32_t cid, const void* data) {\n+    auto cs = _schema.get_by_cid(cid);\n+    if (!cs) {\n+        return Status::NotFound(\"cid not found\");\n+    }\n+    if (cs->is_nullable() || data) {\n+        if (cs->is_nullable() && !_temp_cells[cid].isnullable) {\n+            _bit_null_size++;\n+        }\n+        _temp_cells[cid].isnullable = cs->is_nullable();\n+        _temp_cells[cid].isset = 1;\n+        _temp_cells[cid].data = reinterpret_cast<const uint8_t*>(data);\n+    } else {\n+        return Status::InvalidArgument(\"not nullable column set to null\");\n+    }\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set_delete() {\n+    // TODO: support delete\n+    // _temp_cells[0].isset = 1;\n+    return Status::NotSupported(\"delete not supported\");\n+}\n+\n+size_t PartialRowWriter::byte_size() const {\n+    // TODO: support delete\n+    size_t bit_all_size = num_block(_bit_set_size + _bit_null_size, 8);\n+    size_t data_size = 2 + bit_all_size;\n+    for (size_t i = 1; i < _temp_cells.size(); i++) {\n+        if (_temp_cells[i].data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNjI2NA==", "bodyText": "seems this can be done in constructor.", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428416264", "createdAt": "2020-05-21T02:49:05Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/partial_row_batch.cpp", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/partial_row_batch.h\"\n+\n+#include \"util/bitmap.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Methods for PartialRowBatch\n+\n+PartialRowBatch::PartialRowBatch(scoped_refptr<Schema>* schema, size_t byte_capacity,\n+                                 size_t row_capacity)\n+        : _schema(*schema) {\n+    _data = reinterpret_cast<uint8_t*>(aligned_malloc(byte_capacity, 64));\n+    _bsize = 0;\n+    if (!_data) {\n+        _byte_capacity = 0;\n+        _row_capacity = 0;\n+    }\n+    _byte_capacity = byte_capacity;\n+    _row_capacity = row_capacity;\n+}\n+\n+PartialRowBatch::~PartialRowBatch() {\n+    if (_data) {\n+        free(_data);\n+        _data = nullptr;\n+    }\n+    _bsize = 0;\n+    _byte_capacity = 0;\n+    _row_capacity = 0;\n+}\n+\n+const uint8_t* PartialRowBatch::get_row(size_t idx) const {\n+    if (!_data || idx >= _row_offsets.size()) {\n+        return nullptr;\n+    }\n+    return _data + _row_offsets[idx] + 4;\n+}\n+\n+// Methods for PartialRowWriter\n+\n+PartialRowWriter::PartialRowWriter(const Schema& schema)\n+        : _schema(schema), _bit_set_size(_schema.cid_size()), _bit_null_size(0) {\n+    _temp_cells.resize(_schema.cid_size());\n+}\n+\n+PartialRowWriter::~PartialRowWriter() {}\n+\n+void PartialRowWriter::start_row() {\n+    _bit_null_size = 0;\n+    memset(&(_temp_cells[0]), 0, sizeof(CellInfo) * _temp_cells.size());\n+}\n+\n+Status PartialRowWriter::write_row_to_batch(PartialRowBatch* batch) {\n+    if (batch->_row_offsets.size() >= batch->row_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    size_t row_byte_size = byte_size();\n+    if (batch->byte_size() + row_byte_size + 4 > batch->byte_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    *reinterpret_cast<uint32_t*>(batch->_data + batch->_bsize) = row_byte_size;\n+    uint8_t* pos = batch->_data + batch->_bsize + 4;\n+    RETURN_IF_ERROR(write(&pos));\n+    batch->_row_offsets.push_back(batch->_bsize);\n+    batch->_bsize = pos - batch->_data;\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set(const string& col, const void* data) {\n+    auto cs = _schema.get_by_name(col);\n+    if (!cs) {\n+        return Status::NotFound(\"col name not found\");\n+    }\n+    if (cs->type() == ColumnType::OLAP_FIELD_TYPE_VARCHAR) {\n+        return Status::NotSupported(\"var length type not supported\");\n+    }\n+    uint32_t cid = cs->cid();\n+    if (cs->is_nullable() || data) {\n+        if (cs->is_nullable() && !_temp_cells[cid].isnullable) {\n+            _bit_null_size++;\n+        }\n+        _temp_cells[cid].isnullable = cs->is_nullable();\n+        _temp_cells[cid].isset = 1;\n+        _temp_cells[cid].data = reinterpret_cast<const uint8_t*>(data);\n+    } else {\n+        return Status::InvalidArgument(\"not nullable\");\n+    }\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set(uint32_t cid, const void* data) {\n+    auto cs = _schema.get_by_cid(cid);\n+    if (!cs) {\n+        return Status::NotFound(\"cid not found\");\n+    }\n+    if (cs->is_nullable() || data) {\n+        if (cs->is_nullable() && !_temp_cells[cid].isnullable) {\n+            _bit_null_size++;\n+        }\n+        _temp_cells[cid].isnullable = cs->is_nullable();\n+        _temp_cells[cid].isset = 1;\n+        _temp_cells[cid].data = reinterpret_cast<const uint8_t*>(data);\n+    } else {\n+        return Status::InvalidArgument(\"not nullable column set to null\");\n+    }\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set_delete() {\n+    // TODO: support delete\n+    // _temp_cells[0].isset = 1;\n+    return Status::NotSupported(\"delete not supported\");\n+}\n+\n+size_t PartialRowWriter::byte_size() const {\n+    // TODO: support delete\n+    size_t bit_all_size = num_block(_bit_set_size + _bit_null_size, 8);\n+    size_t data_size = 2 + bit_all_size;\n+    for (size_t i = 1; i < _temp_cells.size(); i++) {\n+        if (_temp_cells[i].data) {\n+            size_t bsize = _schema.get_column_byte_size(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxOTA0Ng==", "bodyText": "Why not construct all items that the batch needs, and construct the batch. If then, the batch can be immutable and this class will not operate batch's private member.", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428419046", "createdAt": "2020-05-21T03:00:18Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/partial_row_batch.cpp", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/partial_row_batch.h\"\n+\n+#include \"util/bitmap.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Methods for PartialRowBatch\n+\n+PartialRowBatch::PartialRowBatch(scoped_refptr<Schema>* schema, size_t byte_capacity,\n+                                 size_t row_capacity)\n+        : _schema(*schema) {\n+    _data = reinterpret_cast<uint8_t*>(aligned_malloc(byte_capacity, 64));\n+    _bsize = 0;\n+    if (!_data) {\n+        _byte_capacity = 0;\n+        _row_capacity = 0;\n+    }\n+    _byte_capacity = byte_capacity;\n+    _row_capacity = row_capacity;\n+}\n+\n+PartialRowBatch::~PartialRowBatch() {\n+    if (_data) {\n+        free(_data);\n+        _data = nullptr;\n+    }\n+    _bsize = 0;\n+    _byte_capacity = 0;\n+    _row_capacity = 0;\n+}\n+\n+const uint8_t* PartialRowBatch::get_row(size_t idx) const {\n+    if (!_data || idx >= _row_offsets.size()) {\n+        return nullptr;\n+    }\n+    return _data + _row_offsets[idx] + 4;\n+}\n+\n+// Methods for PartialRowWriter\n+\n+PartialRowWriter::PartialRowWriter(const Schema& schema)\n+        : _schema(schema), _bit_set_size(_schema.cid_size()), _bit_null_size(0) {\n+    _temp_cells.resize(_schema.cid_size());\n+}\n+\n+PartialRowWriter::~PartialRowWriter() {}\n+\n+void PartialRowWriter::start_row() {\n+    _bit_null_size = 0;\n+    memset(&(_temp_cells[0]), 0, sizeof(CellInfo) * _temp_cells.size());\n+}\n+\n+Status PartialRowWriter::write_row_to_batch(PartialRowBatch* batch) {\n+    if (batch->_row_offsets.size() >= batch->row_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    size_t row_byte_size = byte_size();\n+    if (batch->byte_size() + row_byte_size + 4 > batch->byte_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    *reinterpret_cast<uint32_t*>(batch->_data + batch->_bsize) = row_byte_size;\n+    uint8_t* pos = batch->_data + batch->_bsize + 4;\n+    RETURN_IF_ERROR(write(&pos));\n+    batch->_row_offsets.push_back(batch->_bsize);\n+    batch->_bsize = pos - batch->_data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NzAwMjE2", "url": "https://github.com/apache/incubator-doris/pull/3637#pullrequestreview-416700216", "createdAt": "2020-05-22T07:22:55Z", "commit": {"oid": "ab209d1392c4d69252da3ddf3f3fdeb82346822a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwNzoyMjo1NVrOGZNPTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMjoyODoyNFrOGZVU4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4NDQ5NA==", "bodyText": "write_txn use txn abbreviation, so I think you can unify the name in this pull request.", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429084494", "createdAt": "2020-05-22T07:22:55Z", "author": {"login": "chaoyli"}, "path": "be/src/olap/memory/CMakeLists.txt", "diffHunk": "@@ -29,5 +29,8 @@ add_library(Memory STATIC\n     delta_index.cpp\n     hash_index.cpp\n     mem_tablet.cpp\n+    mem_sub_tablet.cpp\n+    partial_row_batch.cpp\n     schema.cpp\n+    write_txn.cpp", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab209d1392c4d69252da3ddf3f3fdeb82346822a"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEyMjM1NQ==", "bodyText": "If update failed, this place add the _num_update will be non-sense.\nI think it should be placed after success operation.", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429122355", "createdAt": "2020-05-22T08:47:22Z", "author": {"login": "chaoyli"}, "path": "be/src/olap/memory/mem_sub_tablet.cpp", "diffHunk": "@@ -0,0 +1,235 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/mem_sub_tablet.h\"\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_reader.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/hash_index.h\"\n+#include \"olap/memory/partial_row_batch.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+Status MemSubTablet::create(uint64_t version, const Schema& schema,\n+                            std::unique_ptr<MemSubTablet>* ret) {\n+    std::unique_ptr<MemSubTablet> tmp(new MemSubTablet());\n+    tmp->_versions.reserve(64);\n+    tmp->_versions.emplace_back(version, 0);\n+    tmp->_columns.resize(schema.cid_size());\n+    for (size_t i = 0; i < schema.num_columns(); i++) {\n+        // TODO: support storage_type != c.type\n+        auto& c = *schema.get(i);\n+        if (!supported(c.type())) {\n+            return Status::NotSupported(\"column type not supported\");\n+        }\n+        tmp->_columns[c.cid()].reset(new Column(c, c.type(), version));\n+    }\n+    tmp.swap(*ret);\n+    return Status::OK();\n+}\n+\n+MemSubTablet::MemSubTablet() : _index(new HashIndex(1 << 16)) {}\n+\n+MemSubTablet::~MemSubTablet() {}\n+\n+Status MemSubTablet::get_size(uint64_t version, size_t* size) const {\n+    std::lock_guard<std::mutex> lg(_lock);\n+    if (version == static_cast<uint64_t>(-1)) {\n+        // get latest\n+        *size = _versions.back().size;\n+        return Status::OK();\n+    }\n+    if (_versions[0].version > version) {\n+        return Status::NotFound(\"get_size failed, version too old\");\n+    }\n+    for (size_t i = 1; i < _versions.size(); i++) {\n+        if (_versions[i].version > version) {\n+            *size = _versions[i - 1].size;\n+            return Status::OK();\n+        }\n+    }\n+    *size = _versions.back().size;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::read_column(uint64_t version, uint32_t cid,\n+                                 std::unique_ptr<ColumnReader>* reader) {\n+    scoped_refptr<Column> cl;\n+    {\n+        std::lock_guard<std::mutex> lg(_lock);\n+        if (cid < _columns.size()) {\n+            cl = _columns[cid];\n+        }\n+    }\n+    if (!cl) {\n+        return Status::NotFound(\"column not found\");\n+    }\n+    return cl->create_reader(version, reader);\n+}\n+\n+Status MemSubTablet::get_index_to_read(scoped_refptr<HashIndex>* index) {\n+    *index = _index;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::begin_write(scoped_refptr<Schema>* schema) {\n+    _schema = *schema;\n+    _row_size = latest_size();\n+    _write_index = _index;\n+    _writers.clear();\n+    _writers.resize(_columns.size());\n+    // precache key columns\n+    for (size_t i = 0; i < _schema->num_key_columns(); i++) {\n+        uint32_t cid = _schema->get(i)->cid();\n+        if (!_writers[cid]) {\n+            RETURN_IF_ERROR(_columns[cid]->create_writer(&_writers[cid]));\n+        }\n+    }\n+    _temp_hash_entries.reserve(8);\n+\n+    // setup stats\n+    _write_start = GetMonoTimeSecondsAsDouble();\n+    _num_insert = 0;\n+    _num_update = 0;\n+    _num_update_cell = 0;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row(const PartialRowReader& row) {\n+    DCHECK_GE(row.cell_size(), 1);\n+    const ColumnSchema* dsc;\n+    const void* key;\n+    // get key column and find in hash index\n+    // TODO: support multi-column row key\n+    row.get_cell(0, &dsc, &key);\n+    ColumnWriter* keyw = _writers[1].get();\n+    // find candidate rowids, and check equality\n+    uint64_t hashcode = keyw->hashcode(key, 0);\n+    _temp_hash_entries.clear();\n+    uint32_t newslot = _write_index->find(hashcode, &_temp_hash_entries);\n+    uint32_t rid = -1;\n+    for (size_t i = 0; i < _temp_hash_entries.size(); i++) {\n+        uint32_t test_rid = _temp_hash_entries[i];\n+        if (keyw->equals(test_rid, key, 0)) {\n+            rid = test_rid;\n+            break;\n+        }\n+    }\n+    // if rowkey not found, do insertion/append\n+    if (rid == -1) {\n+        _num_insert++;\n+        rid = _row_size;\n+        // add all columns\n+        //DLOG(INFO) << StringPrintf\"insert rid=%u\", rid);\n+        for (size_t i = 0; i < row.cell_size(); i++) {\n+            const void* data;\n+            RETURN_IF_ERROR(row.get_cell(i, &dsc, &data));\n+            uint32_t cid = dsc->cid();\n+            if (!_writers[cid]) {\n+                RETURN_IF_ERROR(_columns[cid]->create_writer(&_writers[cid]));\n+            }\n+            RETURN_IF_ERROR(_writers[cid]->insert(rid, data));\n+        }\n+        _write_index->set(newslot, hashcode, rid);\n+        _row_size++;\n+        if (_write_index->need_rebuild()) {\n+            scoped_refptr<HashIndex> new_index;\n+            // TODO: trace memory usage\n+            size_t new_capacity = _row_size * 2;\n+            while (true) {\n+                new_index = rebuild_hash_index(new_capacity);\n+                if (new_index) {\n+                    break;\n+                } else {\n+                    new_capacity += 1 << 16;\n+                }\n+            }\n+            _write_index = new_index;\n+        }\n+    } else {\n+        // rowkey found, do update\n+        _num_update++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE4Nzg0OA==", "bodyText": "finish_batch is the function name", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429187848", "createdAt": "2020-05-22T11:15:35Z", "author": {"login": "chaoyli"}, "path": "be/src/olap/memory/partial_row_batch.h", "diffHunk": "@@ -0,0 +1,172 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// A chunk of memory that stores a batch of serialized partial rows\n+// User can iterate through all the partial rows, get each partial row's cells.\n+//\n+// Serialization format for a batch:\n+// 4 byte len | serialized partial row\n+// 4 byte len | serialized partial row\n+// ...\n+// 4 byte len | serialized partial row\n+//\n+// Serialization format for a partial row\n+// bit vector(se + null) byte size (2 byte) |\n+// bit vector mark set cells |\n+// bit vector mark nullable cells' null value |\n+// 8bit padding\n+// serialized not null cells\n+//\n+// Example usage:\n+// PartialRowBatch rb(&schema);\n+// rb.load(buffer);\n+// while (true) {\n+//     bool has;\n+//     rb.next(&has);\n+//     if (!has) break;\n+//     for (size_t j=0; j < reader.cell_size(); j++) {\n+//         const ColumnSchema* cs = nullptr;\n+//         const void* data = nullptr;\n+//         // get column cell type and data\n+//         rb.get_cell(j, &cs, &data);\n+//     }\n+// }\n+//\n+// Note: currently only fixed length column types are supported. All length and scalar types store\n+// in native byte order(little endian in x86-64).\n+//\n+// Note: The serialization format is simple, it only provides basic functionalities\n+// so we can quickly complete the whole create/read/write pipeline. The format may change\n+// as the project evolves.\n+class PartialRowBatch {\n+public:\n+    explicit PartialRowBatch(scoped_refptr<Schema>* schema);\n+    ~PartialRowBatch();\n+\n+    const Schema& schema() const { return *_schema.get(); }\n+\n+    // Load from a serialized buffer\n+    Status load(std::vector<uint8_t>&& buffer);\n+\n+    // Return row count in this batch\n+    size_t row_size() const { return _row_size; }\n+\n+    // Iterate to next row, mark has_row to false if there is no more rows\n+    Status next_row(bool* has_row);\n+\n+    // Get row operation cell count\n+    size_t cur_row_cell_size() const { return _cells.size(); }\n+    // Get row operation cell by index idx, return ColumnSchema and data pointer\n+    Status cur_row_get_cell(size_t idx, const ColumnSchema** cs, const void** data) const;\n+\n+private:\n+    scoped_refptr<Schema> _schema;\n+\n+    bool _delete = false;\n+    size_t _bit_set_size = 0;\n+    struct CellInfo {\n+        CellInfo(uint32_t cid, const void* data)\n+                : cid(cid), data(reinterpret_cast<const uint8_t*>(data)) {}\n+        uint32_t cid = 0;\n+        const uint8_t* data = nullptr;\n+    };\n+    vector<CellInfo> _cells;\n+\n+    size_t _next_row = 0;\n+    size_t _row_size = 0;\n+    const uint8_t* _pos = nullptr;\n+    std::vector<uint8_t> _buffer;\n+};\n+\n+// Writer for PartialRowBatch\n+//\n+// Example usage:\n+// scoped_refptr<Schema> sc;\n+// Schema::create(\"id int,uv int,pv int,city tinyint null\", &sc);\n+// PartialRowWriter writer(*sc.get());\n+// writer.start_batch();\n+// for (auto& row : rows) {\n+//     writer.start_row();\n+//     writer.set(\"column_name\", value);\n+//     ...\n+//     writer.set(column_id, value);\n+//     writer.end_row();\n+// }\n+// vector<uint8_t> buffer;\n+// writer.end_batch(&buffer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab209d1392c4d69252da3ddf3f3fdeb82346822a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE5MDk5OQ==", "bodyText": "If insert failed, this place add the _num_insert will be non-sense.\nI think it should be placed after success operation.", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429190999", "createdAt": "2020-05-22T11:23:49Z", "author": {"login": "chaoyli"}, "path": "be/src/olap/memory/mem_sub_tablet.cpp", "diffHunk": "@@ -0,0 +1,247 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/mem_sub_tablet.h\"\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_reader.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/hash_index.h\"\n+#include \"olap/memory/partial_row_batch.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+Status MemSubTablet::create(uint64_t version, const Schema& schema,\n+                            std::unique_ptr<MemSubTablet>* ret) {\n+    std::unique_ptr<MemSubTablet> tmp(new MemSubTablet());\n+    tmp->_versions.reserve(64);\n+    tmp->_versions.emplace_back(version, 0);\n+    tmp->_columns.resize(schema.cid_size());\n+    for (size_t i = 0; i < schema.num_columns(); i++) {\n+        // TODO: support storage_type != c.type\n+        auto& c = *schema.get(i);\n+        if (!supported(c.type())) {\n+            return Status::NotSupported(\"column type not supported\");\n+        }\n+        tmp->_columns[c.cid()].reset(new Column(c, c.type(), version));\n+    }\n+    tmp.swap(*ret);\n+    return Status::OK();\n+}\n+\n+MemSubTablet::MemSubTablet() : _index(new HashIndex(1 << 16)) {}\n+\n+MemSubTablet::~MemSubTablet() {}\n+\n+Status MemSubTablet::get_size(uint64_t version, size_t* size) const {\n+    std::lock_guard<std::mutex> lg(_lock);\n+    if (version == static_cast<uint64_t>(-1)) {\n+        // get latest\n+        *size = _versions.back().size;\n+        return Status::OK();\n+    }\n+    if (_versions[0].version > version) {\n+        return Status::NotFound(\"get_size failed, version too old\");\n+    }\n+    for (size_t i = 1; i < _versions.size(); i++) {\n+        if (_versions[i].version > version) {\n+            *size = _versions[i - 1].size;\n+            return Status::OK();\n+        }\n+    }\n+    *size = _versions.back().size;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::read_column(uint64_t version, uint32_t cid,\n+                                 std::unique_ptr<ColumnReader>* reader) {\n+    scoped_refptr<Column> cl;\n+    {\n+        std::lock_guard<std::mutex> lg(_lock);\n+        if (cid < _columns.size()) {\n+            cl = _columns[cid];\n+        }\n+    }\n+    if (!cl) {\n+        return Status::NotFound(\"column not found\");\n+    }\n+    return cl->create_reader(version, reader);\n+}\n+\n+Status MemSubTablet::get_index_to_read(scoped_refptr<HashIndex>* index) {\n+    *index = _index;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::begin_write(scoped_refptr<Schema>* schema) {\n+    _schema = *schema;\n+    _row_size = latest_size();\n+    _write_index = _index;\n+    _writers.clear();\n+    _writers.resize(_columns.size());\n+    // precache key columns\n+    for (size_t i = 0; i < _schema->num_key_columns(); i++) {\n+        uint32_t cid = _schema->get(i)->cid();\n+        if (!_writers[cid]) {\n+            RETURN_IF_ERROR(_columns[cid]->create_writer(&_writers[cid]));\n+        }\n+    }\n+    _temp_hash_entries.reserve(8);\n+\n+    // setup stats\n+    _write_start = GetMonoTimeSecondsAsDouble();\n+    _num_insert = 0;\n+    _num_update = 0;\n+    _num_update_cell = 0;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row_batch(PartialRowBatch* batch) {\n+    while (true) {\n+        bool has_row = false;\n+        RETURN_IF_ERROR(batch->next_row(&has_row));\n+        if (!has_row) {\n+            break;\n+        }\n+        RETURN_IF_ERROR(apply_partial_row(*batch));\n+    }\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row(const PartialRowBatch& row) {\n+    DCHECK_GE(row.cur_row_cell_size(), 1);\n+    const ColumnSchema* dsc;\n+    const void* key;\n+    // get key column and find in hash index\n+    // TODO: support multi-column row key\n+    row.cur_row_get_cell(0, &dsc, &key);\n+    ColumnWriter* keyw = _writers[1].get();\n+    // find candidate rowids, and check equality\n+    uint64_t hashcode = keyw->hashcode(key, 0);\n+    _temp_hash_entries.clear();\n+    uint32_t newslot = _write_index->find(hashcode, &_temp_hash_entries);\n+    uint32_t rid = -1;\n+    for (size_t i = 0; i < _temp_hash_entries.size(); i++) {\n+        uint32_t test_rid = _temp_hash_entries[i];\n+        if (keyw->equals(test_rid, key, 0)) {\n+            rid = test_rid;\n+            break;\n+        }\n+    }\n+    // if rowkey not found, do insertion/append\n+    if (rid == -1) {\n+        _num_insert++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab209d1392c4d69252da3ddf3f3fdeb82346822a"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIxNjk5Mw==", "bodyText": "_bit_nullable_size", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429216993", "createdAt": "2020-05-22T12:28:24Z", "author": {"login": "chaoyli"}, "path": "be/src/olap/memory/partial_row_batch.h", "diffHunk": "@@ -0,0 +1,172 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// A chunk of memory that stores a batch of serialized partial rows\n+// User can iterate through all the partial rows, get each partial row's cells.\n+//\n+// Serialization format for a batch:\n+// 4 byte len | serialized partial row\n+// 4 byte len | serialized partial row\n+// ...\n+// 4 byte len | serialized partial row\n+//\n+// Serialization format for a partial row\n+// bit vector(se + null) byte size (2 byte) |\n+// bit vector mark set cells |\n+// bit vector mark nullable cells' null value |\n+// 8bit padding\n+// serialized not null cells\n+//\n+// Example usage:\n+// PartialRowBatch rb(&schema);\n+// rb.load(buffer);\n+// while (true) {\n+//     bool has;\n+//     rb.next(&has);\n+//     if (!has) break;\n+//     for (size_t j=0; j < reader.cell_size(); j++) {\n+//         const ColumnSchema* cs = nullptr;\n+//         const void* data = nullptr;\n+//         // get column cell type and data\n+//         rb.get_cell(j, &cs, &data);\n+//     }\n+// }\n+//\n+// Note: currently only fixed length column types are supported. All length and scalar types store\n+// in native byte order(little endian in x86-64).\n+//\n+// Note: The serialization format is simple, it only provides basic functionalities\n+// so we can quickly complete the whole create/read/write pipeline. The format may change\n+// as the project evolves.\n+class PartialRowBatch {\n+public:\n+    explicit PartialRowBatch(scoped_refptr<Schema>* schema);\n+    ~PartialRowBatch();\n+\n+    const Schema& schema() const { return *_schema.get(); }\n+\n+    // Load from a serialized buffer\n+    Status load(std::vector<uint8_t>&& buffer);\n+\n+    // Return row count in this batch\n+    size_t row_size() const { return _row_size; }\n+\n+    // Iterate to next row, mark has_row to false if there is no more rows\n+    Status next_row(bool* has_row);\n+\n+    // Get row operation cell count\n+    size_t cur_row_cell_size() const { return _cells.size(); }\n+    // Get row operation cell by index idx, return ColumnSchema and data pointer\n+    Status cur_row_get_cell(size_t idx, const ColumnSchema** cs, const void** data) const;\n+\n+private:\n+    scoped_refptr<Schema> _schema;\n+\n+    bool _delete = false;\n+    size_t _bit_set_size = 0;\n+    struct CellInfo {\n+        CellInfo(uint32_t cid, const void* data)\n+                : cid(cid), data(reinterpret_cast<const uint8_t*>(data)) {}\n+        uint32_t cid = 0;\n+        const uint8_t* data = nullptr;\n+    };\n+    vector<CellInfo> _cells;\n+\n+    size_t _next_row = 0;\n+    size_t _row_size = 0;\n+    const uint8_t* _pos = nullptr;\n+    std::vector<uint8_t> _buffer;\n+};\n+\n+// Writer for PartialRowBatch\n+//\n+// Example usage:\n+// scoped_refptr<Schema> sc;\n+// Schema::create(\"id int,uv int,pv int,city tinyint null\", &sc);\n+// PartialRowWriter writer(*sc.get());\n+// writer.start_batch();\n+// for (auto& row : rows) {\n+//     writer.start_row();\n+//     writer.set(\"column_name\", value);\n+//     ...\n+//     writer.set(column_id, value);\n+//     writer.end_row();\n+// }\n+// vector<uint8_t> buffer;\n+// writer.end_batch(&buffer);\n+class PartialRowWriter {\n+public:\n+    static const size_t DEFAULT_BYTE_CAPACITY = 1 << 20;\n+    static const size_t DEFAULT_ROW_CAPACIT = 1 << 16;\n+\n+    explicit PartialRowWriter(scoped_refptr<Schema>* schema);\n+    ~PartialRowWriter();\n+\n+    Status start_batch(size_t row_capacity = DEFAULT_ROW_CAPACIT,\n+                       size_t byte_capacity = DEFAULT_BYTE_CAPACITY);\n+\n+    // Start writing a new row\n+    Status start_row();\n+\n+    // Set cell value by column name\n+    // param data's memory must remain valid before calling build\n+    Status set(const string& col, const void* data);\n+\n+    // Set cell value by column id\n+    // param data's memory must remain valid before calling build\n+    Status set(uint32_t cid, const void* data);\n+\n+    // set this row is delete operation\n+    Status set_delete();\n+\n+    // Finish writing a row\n+    Status end_row();\n+\n+    // Finish writing the whole ParitialRowBatch, return a serialized buffer\n+    Status finish_batch(vector<uint8_t>* buffer);\n+\n+private:\n+    Status set(const ColumnSchema* cs, uint32_t cid, const void* data);\n+    size_t byte_size() const;\n+    Status write(uint8_t** ppos);\n+\n+    scoped_refptr<Schema> _schema;\n+    struct CellInfo {\n+        CellInfo() = default;\n+        uint32_t isset = 0;\n+        uint32_t isnullable = 0;\n+        const uint8_t* data = nullptr;\n+    };\n+    vector<CellInfo> _temp_cells;\n+    size_t _bit_set_size = 0;\n+    size_t _bit_null_size = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab209d1392c4d69252da3ddf3f3fdeb82346822a"}, "originalPosition": 164}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3NTYyMTA4", "url": "https://github.com/apache/incubator-doris/pull/3637#pullrequestreview-417562108", "createdAt": "2020-05-25T08:54:03Z", "commit": {"oid": "753de3c4509689b64b7fe09d7334e3abd7128e4e"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3OTI0OTUz", "url": "https://github.com/apache/incubator-doris/pull/3637#pullrequestreview-417924953", "createdAt": "2020-05-26T01:50:02Z", "commit": {"oid": "753de3c4509689b64b7fe09d7334e3abd7128e4e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMTo1MDowMlrOGaMWKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMTo1ODowMFrOGaMc2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDExODQ0Mg==", "bodyText": "we prefer _writers[cid] == nullptr for pointer compare", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r430118442", "createdAt": "2020-05-26T01:50:02Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/mem_sub_tablet.cpp", "diffHunk": "@@ -0,0 +1,247 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/mem_sub_tablet.h\"\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_reader.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/hash_index.h\"\n+#include \"olap/memory/partial_row_batch.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+Status MemSubTablet::create(uint64_t version, const Schema& schema,\n+                            std::unique_ptr<MemSubTablet>* ret) {\n+    std::unique_ptr<MemSubTablet> tmp(new MemSubTablet());\n+    tmp->_versions.reserve(64);\n+    tmp->_versions.emplace_back(version, 0);\n+    tmp->_columns.resize(schema.cid_size());\n+    for (size_t i = 0; i < schema.num_columns(); i++) {\n+        // TODO: support storage_type != c.type\n+        auto& c = *schema.get(i);\n+        if (!supported(c.type())) {\n+            return Status::NotSupported(\"column type not supported\");\n+        }\n+        tmp->_columns[c.cid()].reset(new Column(c, c.type(), version));\n+    }\n+    tmp.swap(*ret);\n+    return Status::OK();\n+}\n+\n+MemSubTablet::MemSubTablet() : _index(new HashIndex(1 << 16)) {}\n+\n+MemSubTablet::~MemSubTablet() {}\n+\n+Status MemSubTablet::get_size(uint64_t version, size_t* size) const {\n+    std::lock_guard<std::mutex> lg(_lock);\n+    if (version == static_cast<uint64_t>(-1)) {\n+        // get latest\n+        *size = _versions.back().size;\n+        return Status::OK();\n+    }\n+    if (_versions[0].version > version) {\n+        return Status::NotFound(\"get_size failed, version too old\");\n+    }\n+    for (size_t i = 1; i < _versions.size(); i++) {\n+        if (_versions[i].version > version) {\n+            *size = _versions[i - 1].size;\n+            return Status::OK();\n+        }\n+    }\n+    *size = _versions.back().size;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::read_column(uint64_t version, uint32_t cid,\n+                                 std::unique_ptr<ColumnReader>* reader) {\n+    scoped_refptr<Column> cl;\n+    {\n+        std::lock_guard<std::mutex> lg(_lock);\n+        if (cid < _columns.size()) {\n+            cl = _columns[cid];\n+        }\n+    }\n+    if (!cl) {\n+        return Status::NotFound(\"column not found\");\n+    }\n+    return cl->create_reader(version, reader);\n+}\n+\n+Status MemSubTablet::get_index_to_read(scoped_refptr<HashIndex>* index) {\n+    *index = _index;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::begin_write(scoped_refptr<Schema>* schema) {\n+    _schema = *schema;\n+    _row_size = latest_size();\n+    _write_index = _index;\n+    _writers.clear();\n+    _writers.resize(_columns.size());\n+    // precache key columns\n+    for (size_t i = 0; i < _schema->num_key_columns(); i++) {\n+        uint32_t cid = _schema->get(i)->cid();\n+        if (!_writers[cid]) {\n+            RETURN_IF_ERROR(_columns[cid]->create_writer(&_writers[cid]));\n+        }\n+    }\n+    _temp_hash_entries.reserve(8);\n+\n+    // setup stats\n+    _write_start = GetMonoTimeSecondsAsDouble();\n+    _num_insert = 0;\n+    _num_update = 0;\n+    _num_update_cell = 0;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row_batch(PartialRowBatch* batch) {\n+    while (true) {\n+        bool has_row = false;\n+        RETURN_IF_ERROR(batch->next_row(&has_row));\n+        if (!has_row) {\n+            break;\n+        }\n+        RETURN_IF_ERROR(apply_partial_row(*batch));\n+    }\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row(const PartialRowBatch& row) {\n+    DCHECK_GE(row.cur_row_cell_size(), 1);\n+    const ColumnSchema* dsc;\n+    const void* key;\n+    // get key column and find in hash index\n+    // TODO: support multi-column row key\n+    row.cur_row_get_cell(0, &dsc, &key);\n+    ColumnWriter* keyw = _writers[1].get();\n+    // find candidate rowids, and check equality\n+    uint64_t hashcode = keyw->hashcode(key, 0);\n+    _temp_hash_entries.clear();\n+    uint32_t newslot = _write_index->find(hashcode, &_temp_hash_entries);\n+    uint32_t rid = -1;\n+    for (size_t i = 0; i < _temp_hash_entries.size(); i++) {\n+        uint32_t test_rid = _temp_hash_entries[i];\n+        if (keyw->equals(test_rid, key, 0)) {\n+            rid = test_rid;\n+            break;\n+        }\n+    }\n+    // if rowkey not found, do insertion/append\n+    if (rid == -1) {\n+        rid = _row_size;\n+        // add all columns\n+        //DLOG(INFO) << StringPrintf\"insert rid=%u\", rid);\n+        for (size_t i = 0; i < row.cur_row_cell_size(); i++) {\n+            const void* data;\n+            RETURN_IF_ERROR(row.cur_row_get_cell(i, &dsc, &data));\n+            uint32_t cid = dsc->cid();\n+            if (!_writers[cid]) {\n+                RETURN_IF_ERROR(_columns[cid]->create_writer(&_writers[cid]));\n+            }\n+            RETURN_IF_ERROR(_writers[cid]->insert(rid, data));\n+        }\n+        _write_index->set(newslot, hashcode, rid);\n+        _row_size++;\n+        if (_write_index->need_rebuild()) {\n+            scoped_refptr<HashIndex> new_index;\n+            // TODO: trace memory usage\n+            size_t new_capacity = _row_size * 2;\n+            while (true) {\n+                new_index = rebuild_hash_index(new_capacity);\n+                if (new_index) {\n+                    break;\n+                } else {\n+                    new_capacity += 1 << 16;\n+                }\n+            }\n+            _write_index = new_index;\n+        }\n+        _num_insert++;\n+    } else {\n+        // rowkey found, do update\n+        // add non-key columns\n+        for (size_t i = 1; i < row.cur_row_cell_size(); i++) {\n+            const void* data;\n+            RETURN_IF_ERROR(row.cur_row_get_cell(i, &dsc, &data));\n+            uint32_t cid = dsc->cid();\n+            if (cid > _schema->num_key_columns()) {\n+                if (!_writers[cid]) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "753de3c4509689b64b7fe09d7334e3abd7128e4e"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDExOTQyMQ==", "bodyText": "Better to create a partial row to do this apply rather than PartialRowBatch", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r430119421", "createdAt": "2020-05-26T01:54:41Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/mem_sub_tablet.cpp", "diffHunk": "@@ -0,0 +1,247 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/mem_sub_tablet.h\"\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_reader.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/hash_index.h\"\n+#include \"olap/memory/partial_row_batch.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+Status MemSubTablet::create(uint64_t version, const Schema& schema,\n+                            std::unique_ptr<MemSubTablet>* ret) {\n+    std::unique_ptr<MemSubTablet> tmp(new MemSubTablet());\n+    tmp->_versions.reserve(64);\n+    tmp->_versions.emplace_back(version, 0);\n+    tmp->_columns.resize(schema.cid_size());\n+    for (size_t i = 0; i < schema.num_columns(); i++) {\n+        // TODO: support storage_type != c.type\n+        auto& c = *schema.get(i);\n+        if (!supported(c.type())) {\n+            return Status::NotSupported(\"column type not supported\");\n+        }\n+        tmp->_columns[c.cid()].reset(new Column(c, c.type(), version));\n+    }\n+    tmp.swap(*ret);\n+    return Status::OK();\n+}\n+\n+MemSubTablet::MemSubTablet() : _index(new HashIndex(1 << 16)) {}\n+\n+MemSubTablet::~MemSubTablet() {}\n+\n+Status MemSubTablet::get_size(uint64_t version, size_t* size) const {\n+    std::lock_guard<std::mutex> lg(_lock);\n+    if (version == static_cast<uint64_t>(-1)) {\n+        // get latest\n+        *size = _versions.back().size;\n+        return Status::OK();\n+    }\n+    if (_versions[0].version > version) {\n+        return Status::NotFound(\"get_size failed, version too old\");\n+    }\n+    for (size_t i = 1; i < _versions.size(); i++) {\n+        if (_versions[i].version > version) {\n+            *size = _versions[i - 1].size;\n+            return Status::OK();\n+        }\n+    }\n+    *size = _versions.back().size;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::read_column(uint64_t version, uint32_t cid,\n+                                 std::unique_ptr<ColumnReader>* reader) {\n+    scoped_refptr<Column> cl;\n+    {\n+        std::lock_guard<std::mutex> lg(_lock);\n+        if (cid < _columns.size()) {\n+            cl = _columns[cid];\n+        }\n+    }\n+    if (!cl) {\n+        return Status::NotFound(\"column not found\");\n+    }\n+    return cl->create_reader(version, reader);\n+}\n+\n+Status MemSubTablet::get_index_to_read(scoped_refptr<HashIndex>* index) {\n+    *index = _index;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::begin_write(scoped_refptr<Schema>* schema) {\n+    _schema = *schema;\n+    _row_size = latest_size();\n+    _write_index = _index;\n+    _writers.clear();\n+    _writers.resize(_columns.size());\n+    // precache key columns\n+    for (size_t i = 0; i < _schema->num_key_columns(); i++) {\n+        uint32_t cid = _schema->get(i)->cid();\n+        if (!_writers[cid]) {\n+            RETURN_IF_ERROR(_columns[cid]->create_writer(&_writers[cid]));\n+        }\n+    }\n+    _temp_hash_entries.reserve(8);\n+\n+    // setup stats\n+    _write_start = GetMonoTimeSecondsAsDouble();\n+    _num_insert = 0;\n+    _num_update = 0;\n+    _num_update_cell = 0;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row_batch(PartialRowBatch* batch) {\n+    while (true) {\n+        bool has_row = false;\n+        RETURN_IF_ERROR(batch->next_row(&has_row));\n+        if (!has_row) {\n+            break;\n+        }\n+        RETURN_IF_ERROR(apply_partial_row(*batch));\n+    }\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row(const PartialRowBatch& row) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "753de3c4509689b64b7fe09d7334e3abd7128e4e"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyMDE1Mg==", "bodyText": "should add some method to avoid multiple write.\nFor example one try to begin_write while another writer is writing.", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r430120152", "createdAt": "2020-05-26T01:58:00Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/mem_sub_tablet.cpp", "diffHunk": "@@ -0,0 +1,247 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/mem_sub_tablet.h\"\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_reader.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/hash_index.h\"\n+#include \"olap/memory/partial_row_batch.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+Status MemSubTablet::create(uint64_t version, const Schema& schema,\n+                            std::unique_ptr<MemSubTablet>* ret) {\n+    std::unique_ptr<MemSubTablet> tmp(new MemSubTablet());\n+    tmp->_versions.reserve(64);\n+    tmp->_versions.emplace_back(version, 0);\n+    tmp->_columns.resize(schema.cid_size());\n+    for (size_t i = 0; i < schema.num_columns(); i++) {\n+        // TODO: support storage_type != c.type\n+        auto& c = *schema.get(i);\n+        if (!supported(c.type())) {\n+            return Status::NotSupported(\"column type not supported\");\n+        }\n+        tmp->_columns[c.cid()].reset(new Column(c, c.type(), version));\n+    }\n+    tmp.swap(*ret);\n+    return Status::OK();\n+}\n+\n+MemSubTablet::MemSubTablet() : _index(new HashIndex(1 << 16)) {}\n+\n+MemSubTablet::~MemSubTablet() {}\n+\n+Status MemSubTablet::get_size(uint64_t version, size_t* size) const {\n+    std::lock_guard<std::mutex> lg(_lock);\n+    if (version == static_cast<uint64_t>(-1)) {\n+        // get latest\n+        *size = _versions.back().size;\n+        return Status::OK();\n+    }\n+    if (_versions[0].version > version) {\n+        return Status::NotFound(\"get_size failed, version too old\");\n+    }\n+    for (size_t i = 1; i < _versions.size(); i++) {\n+        if (_versions[i].version > version) {\n+            *size = _versions[i - 1].size;\n+            return Status::OK();\n+        }\n+    }\n+    *size = _versions.back().size;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::read_column(uint64_t version, uint32_t cid,\n+                                 std::unique_ptr<ColumnReader>* reader) {\n+    scoped_refptr<Column> cl;\n+    {\n+        std::lock_guard<std::mutex> lg(_lock);\n+        if (cid < _columns.size()) {\n+            cl = _columns[cid];\n+        }\n+    }\n+    if (!cl) {\n+        return Status::NotFound(\"column not found\");\n+    }\n+    return cl->create_reader(version, reader);\n+}\n+\n+Status MemSubTablet::get_index_to_read(scoped_refptr<HashIndex>* index) {\n+    *index = _index;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::begin_write(scoped_refptr<Schema>* schema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "753de3c4509689b64b7fe09d7334e3abd7128e4e"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjg5Nzc5", "url": "https://github.com/apache/incubator-doris/pull/3637#pullrequestreview-420689779", "createdAt": "2020-05-29T06:43:17Z", "commit": {"oid": "6dcfd8b739fbc971d415e1d8ce64b236dccd2e05"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d11a2cb2360386003c286d93e3c4493715865ef", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/8d11a2cb2360386003c286d93e3c4493715865ef", "committedDate": "2020-05-29T06:52:33Z", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68cf5007be546133055b6c968761fefc1ed51c52", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/68cf5007be546133055b6c968761fefc1ed51c52", "committedDate": "2020-05-29T06:52:33Z", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch: refactor PartialRowBatch, add more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77d9c770710b488bae6990d0e2cc88f89e845929", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/77d9c770710b488bae6990d0e2cc88f89e845929", "committedDate": "2020-05-29T06:52:33Z", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch: address review issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cc653c2db2feb80645a3f31e46015c3182b0ae9", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/6cc653c2db2feb80645a3f31e46015c3182b0ae9", "committedDate": "2020-05-29T06:52:33Z", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch: fix compile Werror"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73c9b07e9cb26ef3491b5a1b9c6b9a58fed9babe", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/73c9b07e9cb26ef3491b5a1b9c6b9a58fed9babe", "committedDate": "2020-05-29T06:52:33Z", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch: address review comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0637fb5f25697e5cb3ebd410b9b01e342c1ffdd", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/e0637fb5f25697e5cb3ebd410b9b01e342c1ffdd", "committedDate": "2020-05-29T06:52:33Z", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch: address review comment"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6dcfd8b739fbc971d415e1d8ce64b236dccd2e05", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/6dcfd8b739fbc971d415e1d8ce64b236dccd2e05", "committedDate": "2020-05-28T07:11:54Z", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch: address review comment"}, "afterCommit": {"oid": "e0637fb5f25697e5cb3ebd410b9b01e342c1ffdd", "author": {"user": {"login": "decster", "name": "Binglin Chang"}}, "url": "https://github.com/apache/incubator-doris/commit/e0637fb5f25697e5cb3ebd410b9b01e342c1ffdd", "committedDate": "2020-05-29T06:52:33Z", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch: address review comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwODAwNzc1", "url": "https://github.com/apache/incubator-doris/pull/3637#pullrequestreview-420800775", "createdAt": "2020-05-29T09:37:26Z", "commit": {"oid": "e0637fb5f25697e5cb3ebd410b9b01e342c1ffdd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzcwNzE1", "url": "https://github.com/apache/incubator-doris/pull/3637#pullrequestreview-421370715", "createdAt": "2020-05-30T02:32:50Z", "commit": {"oid": "e0637fb5f25697e5cb3ebd410b9b01e342c1ffdd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2696, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}