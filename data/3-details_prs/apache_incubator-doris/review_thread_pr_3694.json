{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzMjc0NTk5", "number": 3694, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzowNjozMlrOD_64KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNDowNjoxN1rOD_7Zbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzUxNTI5OnYy", "diffSide": "RIGHT", "path": "be/src/exec/olap_scan_node.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzowNjozMlrOGa36pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNjozNTozOVrOGa7RkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzMjI5Mg==", "bodyText": "I think we should do this work directly in FE, Not add a todo here. In FE we could directly get a empty set for this query.", "url": "https://github.com/apache/incubator-doris/pull/3694#discussion_r430832292", "createdAt": "2020-05-27T03:06:32Z", "author": {"login": "kangkaisen"}, "path": "be/src/exec/olap_scan_node.cpp", "diffHunk": "@@ -884,25 +910,54 @@ Status OlapScanNode::normalize_in_predicate(SlotDescriptor* slot, ColumnValueRan\n                     case TYPE_INT:\n                     case TYPE_BIGINT:\n                     case TYPE_LARGEINT: {\n+                        range->clear();\n                         range->add_fixed_value(*reinterpret_cast<T*>(value));\n                         break;\n                     }\n                     case TYPE_BOOLEAN: {\n                         bool v = *reinterpret_cast<bool*>(value);\n+                        range->clear();\n                         range->add_fixed_value(*reinterpret_cast<T*>(&v));\n                         break;\n                     }\n                     default: {\n                         LOG(WARNING) << \"Normalize filter fail, Unsupport Primitive type. [type=\"\n-                                     << expr->type() << \"]\";\n+                            << expr->type() << \"]\";\n                         return Status::InternalError(\"Normalize filter fail, Unsupport Primitive type\");\n                     }\n-                    }\n                 }\n+\n+                meet_eq_binary = true;\n+            } // end for each binary predicate child\n+        } // end of handling eq binary predicate\n+\n+        if (range->get_fixed_value_size() > 0) {\n+            // this columns already meet some eq predicates(IN or Binary),\n+            // There is no need to continue to iterate.\n+            // TODO(cmy): In fact, this part of the judgment should be completed in\n+            // the FE query planning stage. For the following predicate conditions,\n+            // it should be possible to eliminate at the FE side.\n+            //      WHERE A = 1 and A in (2,3,4)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a915c56081bf094a11285b78ac25556e1f719093"}, "originalPosition": 361}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjU3Mg==", "bodyText": "I will try to solve this in next PR.", "url": "https://github.com/apache/incubator-doris/pull/3694#discussion_r430842572", "createdAt": "2020-05-27T03:52:47Z", "author": {"login": "morningman"}, "path": "be/src/exec/olap_scan_node.cpp", "diffHunk": "@@ -884,25 +910,54 @@ Status OlapScanNode::normalize_in_predicate(SlotDescriptor* slot, ColumnValueRan\n                     case TYPE_INT:\n                     case TYPE_BIGINT:\n                     case TYPE_LARGEINT: {\n+                        range->clear();\n                         range->add_fixed_value(*reinterpret_cast<T*>(value));\n                         break;\n                     }\n                     case TYPE_BOOLEAN: {\n                         bool v = *reinterpret_cast<bool*>(value);\n+                        range->clear();\n                         range->add_fixed_value(*reinterpret_cast<T*>(&v));\n                         break;\n                     }\n                     default: {\n                         LOG(WARNING) << \"Normalize filter fail, Unsupport Primitive type. [type=\"\n-                                     << expr->type() << \"]\";\n+                            << expr->type() << \"]\";\n                         return Status::InternalError(\"Normalize filter fail, Unsupport Primitive type\");\n                     }\n-                    }\n                 }\n+\n+                meet_eq_binary = true;\n+            } // end for each binary predicate child\n+        } // end of handling eq binary predicate\n+\n+        if (range->get_fixed_value_size() > 0) {\n+            // this columns already meet some eq predicates(IN or Binary),\n+            // There is no need to continue to iterate.\n+            // TODO(cmy): In fact, this part of the judgment should be completed in\n+            // the FE query planning stage. For the following predicate conditions,\n+            // it should be possible to eliminate at the FE side.\n+            //      WHERE A = 1 and A in (2,3,4)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzMjI5Mg=="}, "originalCommit": {"oid": "a915c56081bf094a11285b78ac25556e1f719093"}, "originalPosition": 361}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NzMxMg==", "bodyText": "OK", "url": "https://github.com/apache/incubator-doris/pull/3694#discussion_r430887312", "createdAt": "2020-05-27T06:35:39Z", "author": {"login": "kangkaisen"}, "path": "be/src/exec/olap_scan_node.cpp", "diffHunk": "@@ -884,25 +910,54 @@ Status OlapScanNode::normalize_in_predicate(SlotDescriptor* slot, ColumnValueRan\n                     case TYPE_INT:\n                     case TYPE_BIGINT:\n                     case TYPE_LARGEINT: {\n+                        range->clear();\n                         range->add_fixed_value(*reinterpret_cast<T*>(value));\n                         break;\n                     }\n                     case TYPE_BOOLEAN: {\n                         bool v = *reinterpret_cast<bool*>(value);\n+                        range->clear();\n                         range->add_fixed_value(*reinterpret_cast<T*>(&v));\n                         break;\n                     }\n                     default: {\n                         LOG(WARNING) << \"Normalize filter fail, Unsupport Primitive type. [type=\"\n-                                     << expr->type() << \"]\";\n+                            << expr->type() << \"]\";\n                         return Status::InternalError(\"Normalize filter fail, Unsupport Primitive type\");\n                     }\n-                    }\n                 }\n+\n+                meet_eq_binary = true;\n+            } // end for each binary predicate child\n+        } // end of handling eq binary predicate\n+\n+        if (range->get_fixed_value_size() > 0) {\n+            // this columns already meet some eq predicates(IN or Binary),\n+            // There is no need to continue to iterate.\n+            // TODO(cmy): In fact, this part of the judgment should be completed in\n+            // the FE query planning stage. For the following predicate conditions,\n+            // it should be possible to eliminate at the FE side.\n+            //      WHERE A = 1 and A in (2,3,4)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzMjI5Mg=="}, "originalCommit": {"oid": "a915c56081bf094a11285b78ac25556e1f719093"}, "originalPosition": 361}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzUxNzA5OnYy", "diffSide": "RIGHT", "path": "be/src/exec/olap_scan_node.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzowNzo1MlrOGa373w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo1MzoxNVrOGa4jRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzMjYwNw==", "bodyText": "eq binary is also binary. So I think we would better also change the normalize_binary_predicate name.", "url": "https://github.com/apache/incubator-doris/pull/3694#discussion_r430832607", "createdAt": "2020-05-27T03:07:52Z", "author": {"login": "kangkaisen"}, "path": "be/src/exec/olap_scan_node.cpp", "diffHunk": "@@ -715,7 +714,7 @@ Status OlapScanNode::start_scan_thread(RuntimeState* state) {\n template<class T>\n Status OlapScanNode::normalize_predicate(ColumnValueRange<T>& range, SlotDescriptor* slot) {\n     // 1. Normalize InPredicate, add to ColumnValueRange\n-    RETURN_IF_ERROR(normalize_in_predicate(slot, &range));\n+    RETURN_IF_ERROR(normalize_in_and_eq_predicate(slot, &range));\n \n     // 2. Normalize BinaryPredicate , add to ColumnValueRange\n     RETURN_IF_ERROR(normalize_binary_predicate(slot, &range));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a915c56081bf094a11285b78ac25556e1f719093"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjY5Mg==", "bodyText": "OK", "url": "https://github.com/apache/incubator-doris/pull/3694#discussion_r430842692", "createdAt": "2020-05-27T03:53:15Z", "author": {"login": "morningman"}, "path": "be/src/exec/olap_scan_node.cpp", "diffHunk": "@@ -715,7 +714,7 @@ Status OlapScanNode::start_scan_thread(RuntimeState* state) {\n template<class T>\n Status OlapScanNode::normalize_predicate(ColumnValueRange<T>& range, SlotDescriptor* slot) {\n     // 1. Normalize InPredicate, add to ColumnValueRange\n-    RETURN_IF_ERROR(normalize_in_predicate(slot, &range));\n+    RETURN_IF_ERROR(normalize_in_and_eq_predicate(slot, &range));\n \n     // 2. Normalize BinaryPredicate , add to ColumnValueRange\n     RETURN_IF_ERROR(normalize_binary_predicate(slot, &range));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzMjYwNw=="}, "originalCommit": {"oid": "a915c56081bf094a11285b78ac25556e1f719093"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzU5NjU5OnYy", "diffSide": "RIGHT", "path": "be/src/exec/olap_scan_node.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNDowMzoyMFrOGa4rzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwOTowNzowOFrOGbARbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NDg3OA==", "bodyText": "754 line can guarantee it's a single coulumn predicate?", "url": "https://github.com/apache/incubator-doris/pull/3694#discussion_r430844878", "createdAt": "2020-05-27T04:03:20Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/olap_scan_node.cpp", "diffHunk": "@@ -736,100 +735,114 @@ static bool ignore_cast(SlotDescriptor* slot, Expr* expr) {\n     return false;\n }\n \n+// Construct the ColumnValueRange for one specified column\n+// It will only handle the InPredicate and eq BinaryPredicate in _conjunct_ctxs.\n+// It will try to push down conditions of that column as much as possible,\n+// But if the number of conditions exceeds the limit, none of conditions will be pushed down.\n template<class T>\n-Status OlapScanNode::normalize_in_predicate(SlotDescriptor* slot, ColumnValueRange<T>* range) {\n+Status OlapScanNode::normalize_in_and_eq_predicate(SlotDescriptor* slot, ColumnValueRange<T>* range) {\n+    bool meet_eq_binary = false;\n     for (int conj_idx = 0; conj_idx < _conjunct_ctxs.size(); ++conj_idx) {\n         // 1. Normalize in conjuncts like 'where col in (v1, v2, v3)'\n         if (TExprOpcode::FILTER_IN == _conjunct_ctxs[conj_idx]->root()->op()) {\n             InPredicate* pred = dynamic_cast<InPredicate*>(_conjunct_ctxs[conj_idx]->root());\n             if (pred->is_not_in()) {\n+                // can not push down NOT IN predicate to storage engine\n                 continue;\n             }\n \n             if (Expr::type_without_cast(pred->get_child(0)) != TExprNodeType::SLOT_REF) {\n+                // not a slot ref(column)\n+                continue;\n+            }\n+\n+            std::vector<SlotId> slot_ids;\n+            if (pred->get_child(0)->get_slot_ids(&slot_ids) != 1) {\n+                // not a single column predicate\n+                continue;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddabaaaad252513aa5f449f4779e6c976fd168cc"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk2OTE5OQ==", "bodyText": "I am not sure about that, looks like line 754 can guarantee.\nBut just leave this judgement, because no matter what, we still have to call get_slot_ids() to get the slot id and check if it equals to the slot->id() later.", "url": "https://github.com/apache/incubator-doris/pull/3694#discussion_r430969199", "createdAt": "2020-05-27T09:07:08Z", "author": {"login": "morningman"}, "path": "be/src/exec/olap_scan_node.cpp", "diffHunk": "@@ -736,100 +735,114 @@ static bool ignore_cast(SlotDescriptor* slot, Expr* expr) {\n     return false;\n }\n \n+// Construct the ColumnValueRange for one specified column\n+// It will only handle the InPredicate and eq BinaryPredicate in _conjunct_ctxs.\n+// It will try to push down conditions of that column as much as possible,\n+// But if the number of conditions exceeds the limit, none of conditions will be pushed down.\n template<class T>\n-Status OlapScanNode::normalize_in_predicate(SlotDescriptor* slot, ColumnValueRange<T>* range) {\n+Status OlapScanNode::normalize_in_and_eq_predicate(SlotDescriptor* slot, ColumnValueRange<T>* range) {\n+    bool meet_eq_binary = false;\n     for (int conj_idx = 0; conj_idx < _conjunct_ctxs.size(); ++conj_idx) {\n         // 1. Normalize in conjuncts like 'where col in (v1, v2, v3)'\n         if (TExprOpcode::FILTER_IN == _conjunct_ctxs[conj_idx]->root()->op()) {\n             InPredicate* pred = dynamic_cast<InPredicate*>(_conjunct_ctxs[conj_idx]->root());\n             if (pred->is_not_in()) {\n+                // can not push down NOT IN predicate to storage engine\n                 continue;\n             }\n \n             if (Expr::type_without_cast(pred->get_child(0)) != TExprNodeType::SLOT_REF) {\n+                // not a slot ref(column)\n+                continue;\n+            }\n+\n+            std::vector<SlotId> slot_ids;\n+            if (pred->get_child(0)->get_slot_ids(&slot_ids) != 1) {\n+                // not a single column predicate\n+                continue;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NDg3OA=="}, "originalCommit": {"oid": "ddabaaaad252513aa5f449f4779e6c976fd168cc"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzYwMDQ3OnYy", "diffSide": "RIGHT", "path": "be/src/exec/olap_scan_node.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNDowNjoxN1rOGa4uPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwOTowNDozNVrOGbALKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NTUwMg==", "bodyText": "Whether \u201drange->clear()\u201c can be preceded by the switch statement", "url": "https://github.com/apache/incubator-doris/pull/3694#discussion_r430845502", "createdAt": "2020-05-27T04:06:17Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/olap_scan_node.cpp", "diffHunk": "@@ -838,39 +851,52 @@ Status OlapScanNode::normalize_in_predicate(SlotDescriptor* slot, ColumnValueRan\n                         != TExprNodeType::SLOT_REF) {\n                     continue;\n                 }\n+\n+                std::vector<SlotId> slot_ids;\n+                if (pred->get_child(child_idx)->get_slot_ids(&slot_ids) != 1) {\n+                    // not a single column predicate\n+                    continue;\n+                }\n+\n+                if (slot_ids[0] != slot->id()) {\n+                    // predicate not related to current column\n+                    continue;\n+                }\n+\n                 if (pred->get_child(child_idx)->type().type != slot->type().type) {\n                     if (!ignore_cast(slot, pred->get_child(child_idx))) {\n+                        // the type of predicate not match the slot's type\n                         continue;\n                     }\n                 }\n \n-                std::vector<SlotId> slot_ids;\n-                if (1 == pred->get_child(child_idx)->get_slot_ids(&slot_ids)) {\n-                    if (slot_ids[0] != slot->id()) {\n-                        continue;\n-                    }\n-\n-                    Expr* expr = pred->get_child(1 - child_idx);\n-                    if (!expr->is_constant()) {\n-                        continue;\n-                    }\n+                Expr* expr = pred->get_child(1 - child_idx);\n+                if (!expr->is_constant()) {\n+                    // only handle constant value\n+                    continue;\n+                }\n \n-                    void* value = _conjunct_ctxs[conj_idx]->get_value(expr, NULL);\n-                    // for case: where col = null\n-                    if (value == NULL) {\n-                        continue;\n-                    }\n+                void* value = _conjunct_ctxs[conj_idx]->get_value(expr, NULL);\n+                // for case: where col = null\n+                if (value == NULL) {\n+                    continue;\n+                }\n \n-                    switch (slot->type().type) {\n+                // begin to push condition value into ColumnValueRange\n+                // clear the ColumnValueRange before adding new fixed values.\n+                // because for AND compound predicates, it can overwrite previous conditions\n+                switch (slot->type().type) {\n                     case TYPE_TINYINT: {\n                         int32_t v = *reinterpret_cast<int8_t*>(value);\n+                        range->clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddabaaaad252513aa5f449f4779e6c976fd168cc"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk2NzU5Mg==", "bodyText": "OK", "url": "https://github.com/apache/incubator-doris/pull/3694#discussion_r430967592", "createdAt": "2020-05-27T09:04:35Z", "author": {"login": "morningman"}, "path": "be/src/exec/olap_scan_node.cpp", "diffHunk": "@@ -838,39 +851,52 @@ Status OlapScanNode::normalize_in_predicate(SlotDescriptor* slot, ColumnValueRan\n                         != TExprNodeType::SLOT_REF) {\n                     continue;\n                 }\n+\n+                std::vector<SlotId> slot_ids;\n+                if (pred->get_child(child_idx)->get_slot_ids(&slot_ids) != 1) {\n+                    // not a single column predicate\n+                    continue;\n+                }\n+\n+                if (slot_ids[0] != slot->id()) {\n+                    // predicate not related to current column\n+                    continue;\n+                }\n+\n                 if (pred->get_child(child_idx)->type().type != slot->type().type) {\n                     if (!ignore_cast(slot, pred->get_child(child_idx))) {\n+                        // the type of predicate not match the slot's type\n                         continue;\n                     }\n                 }\n \n-                std::vector<SlotId> slot_ids;\n-                if (1 == pred->get_child(child_idx)->get_slot_ids(&slot_ids)) {\n-                    if (slot_ids[0] != slot->id()) {\n-                        continue;\n-                    }\n-\n-                    Expr* expr = pred->get_child(1 - child_idx);\n-                    if (!expr->is_constant()) {\n-                        continue;\n-                    }\n+                Expr* expr = pred->get_child(1 - child_idx);\n+                if (!expr->is_constant()) {\n+                    // only handle constant value\n+                    continue;\n+                }\n \n-                    void* value = _conjunct_ctxs[conj_idx]->get_value(expr, NULL);\n-                    // for case: where col = null\n-                    if (value == NULL) {\n-                        continue;\n-                    }\n+                void* value = _conjunct_ctxs[conj_idx]->get_value(expr, NULL);\n+                // for case: where col = null\n+                if (value == NULL) {\n+                    continue;\n+                }\n \n-                    switch (slot->type().type) {\n+                // begin to push condition value into ColumnValueRange\n+                // clear the ColumnValueRange before adding new fixed values.\n+                // because for AND compound predicates, it can overwrite previous conditions\n+                switch (slot->type().type) {\n                     case TYPE_TINYINT: {\n                         int32_t v = *reinterpret_cast<int8_t*>(value);\n+                        range->clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NTUwMg=="}, "originalCommit": {"oid": "ddabaaaad252513aa5f449f4779e6c976fd168cc"}, "originalPosition": 316}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1626, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}