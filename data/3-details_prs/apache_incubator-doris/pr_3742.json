{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1OTMwMjg3", "number": 3742, "title": "[Spark load][Be 1/1] Be handle push task", "bodyText": "1\u3001Add a PushBrokerReader in push_handle.cpp.\n2\u3001PushBrokerReader wraps the ParquetScanner to support reading data from parquet format file through broker.\n#3433", "createdAt": "2020-06-01T11:49:51Z", "url": "https://github.com/apache/incubator-doris/pull/3742", "merged": true, "mergeCommit": {"oid": "f189a2e7b869d864b488d42e5a0c6529f22ec6c2"}, "closed": true, "closedAt": "2020-06-22T11:57:59Z", "author": {"login": "xy720"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnCC1VAFqTQyMTk1MjQyMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABctvjvXgFqTQzNDg1Mjg3NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxOTUyNDIy", "url": "https://github.com/apache/incubator-doris/pull/3742#pullrequestreview-421952422", "createdAt": "2020-06-01T15:32:01Z", "commit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozMjowMVrOGdO-sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozMjowMVrOGdO-sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMwNzMxNA==", "bodyText": "I think for reader, close maybe better than finalize.", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r433307314", "createdAt": "2020-06-01T15:32:01Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/push_handler.h", "diffHunk": "@@ -209,6 +216,44 @@ class LzoBinaryReader: public IBinaryReader {\n     size_t _next_row_start;\n };\n \n+class PushBrokerReader {\n+public:\n+    PushBrokerReader() \n+        : _ready(false),\n+          _eof(false) {}\n+    ~PushBrokerReader() {}\n+\n+    OLAPStatus init(const Schema* schema,\n+                    const TBrokerScanRange& t_scan_range,\n+                    const TDescriptorTable& t_desc_tbl);\n+    OLAPStatus next(ContiguousRow* row);\n+    void print_profile();\n+\n+    OLAPStatus finalize() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxOTU1OTQ5", "url": "https://github.com/apache/incubator-doris/pull/3742#pullrequestreview-421955949", "createdAt": "2020-06-01T15:36:19Z", "commit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozNjoxOVrOGdPPJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozNjoxOVrOGdPPJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxMTUyNQ==", "bodyText": "Why don't set a memory limit?", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r433311525", "createdAt": "2020-06-01T15:36:19Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -761,6 +915,126 @@ OLAPStatus LzoBinaryReader::_next_block() {\n   return res;\n }\n \n+OLAPStatus PushBrokerReader::init(const Schema* schema,\n+                                  const TBrokerScanRange& t_scan_range,\n+                                  const TDescriptorTable& t_desc_tbl) {\n+    // init schema\n+    _schema = schema;\n+\n+    // init runtime state, runtime profile, counter\n+    TUniqueId dummy_id;\n+    dummy_id.hi = 0;\n+    dummy_id.lo = 0;\n+    TPlanFragmentExecParams params;\n+    params.fragment_instance_id = dummy_id;\n+    params.query_id = dummy_id;\n+    TExecPlanFragmentParams fragment_params;\n+    fragment_params.params = params;\n+    fragment_params.protocol_version = PaloInternalServiceVersion::V1;\n+    TQueryOptions query_options;\n+    TQueryGlobals query_globals;\n+    _runtime_state.reset(new RuntimeState(fragment_params, query_options, query_globals,\n+                                          ExecEnv::GetInstance()));\n+    DescriptorTbl* desc_tbl = NULL;\n+    Status status = DescriptorTbl::create(_runtime_state->obj_pool(), t_desc_tbl, &desc_tbl);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to create descriptor table, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_state->set_desc_tbl(desc_tbl);\n+    status = _runtime_state->init_mem_trackers(dummy_id);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to init mem trackers, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_profile.reset(new RuntimeProfile(_runtime_state->obj_pool(), \"PushBrokerReader\"));\n+    _mem_tracker.reset(new MemTracker(-1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 224}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxOTU2NTYx", "url": "https://github.com/apache/incubator-doris/pull/3742#pullrequestreview-421956561", "createdAt": "2020-06-01T15:37:05Z", "commit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozNzowNlrOGdPR0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozNzowNlrOGdPR0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxMjIwOQ==", "bodyText": "You should do a code format by clang-format.", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r433312209", "createdAt": "2020-06-01T15:37:06Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -761,6 +915,126 @@ OLAPStatus LzoBinaryReader::_next_block() {\n   return res;\n }\n \n+OLAPStatus PushBrokerReader::init(const Schema* schema,\n+                                  const TBrokerScanRange& t_scan_range,\n+                                  const TDescriptorTable& t_desc_tbl) {\n+    // init schema\n+    _schema = schema;\n+\n+    // init runtime state, runtime profile, counter\n+    TUniqueId dummy_id;\n+    dummy_id.hi = 0;\n+    dummy_id.lo = 0;\n+    TPlanFragmentExecParams params;\n+    params.fragment_instance_id = dummy_id;\n+    params.query_id = dummy_id;\n+    TExecPlanFragmentParams fragment_params;\n+    fragment_params.params = params;\n+    fragment_params.protocol_version = PaloInternalServiceVersion::V1;\n+    TQueryOptions query_options;\n+    TQueryGlobals query_globals;\n+    _runtime_state.reset(new RuntimeState(fragment_params, query_options, query_globals,\n+                                          ExecEnv::GetInstance()));\n+    DescriptorTbl* desc_tbl = NULL;\n+    Status status = DescriptorTbl::create(_runtime_state->obj_pool(), t_desc_tbl, &desc_tbl);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to create descriptor table, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_state->set_desc_tbl(desc_tbl);\n+    status = _runtime_state->init_mem_trackers(dummy_id);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to init mem trackers, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_profile.reset(new RuntimeProfile(_runtime_state->obj_pool(), \"PushBrokerReader\"));\n+    _mem_tracker.reset(new MemTracker(-1));\n+    _mem_pool.reset(new MemPool(_mem_tracker.get()));\n+    _counter.reset(new ScannerCounter());\n+\n+    // init scanner\n+    BaseScanner *scanner = nullptr;\n+    switch (t_scan_range.ranges[0].format_type) {\n+    case TFileFormatType::FORMAT_PARQUET:\n+        scanner = new ParquetScanner(_runtime_state.get(),\n+                                  _runtime_profile.get(),\n+                                  t_scan_range.params,\n+                                  t_scan_range.ranges,\n+                                  t_scan_range.broker_addresses,\n+                                  _counter.get());\n+        break;\n+    default:\n+        LOG(WARNING) << \"Unsupported file format type: \" << t_scan_range.ranges[0].format_type;\n+\t\treturn OLAP_ERR_PUSH_INIT_ERROR;\n+\t}\n+    _scanner.reset(scanner); \n+    status = _scanner->open();\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to open scanner, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    // init tuple\n+    auto tuple_id = t_scan_range.params.dest_tuple_id;\n+    _tuple_desc = _runtime_state->desc_tbl().get_tuple_descriptor(tuple_id);\n+    if (_tuple_desc == nullptr) {\n+        std::stringstream ss;\n+        LOG(WARNING) << \"Failed to get tuple descriptor, tuple_id: \" << tuple_id;\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    int tuple_buffer_size = _tuple_desc->byte_size();\n+    void* tuple_buffer = _mem_pool->allocate(tuple_buffer_size);\n+    if (tuple_buffer == nullptr) {\n+        LOG(WARNING) << \"Allocate memory for tuple failed\";\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _tuple = reinterpret_cast<Tuple*>(tuple_buffer);\n+\n+    _ready = true;\n+\treturn OLAP_SUCCESS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 268}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxOTU2ODY4", "url": "https://github.com/apache/incubator-doris/pull/3742#pullrequestreview-421956868", "createdAt": "2020-06-01T15:37:28Z", "commit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozNzoyOFrOGdPTQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozNzoyOFrOGdPTQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxMjU3Nw==", "bodyText": "Remove", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r433312577", "createdAt": "2020-06-01T15:37:28Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -761,6 +915,126 @@ OLAPStatus LzoBinaryReader::_next_block() {\n   return res;\n }\n \n+OLAPStatus PushBrokerReader::init(const Schema* schema,\n+                                  const TBrokerScanRange& t_scan_range,\n+                                  const TDescriptorTable& t_desc_tbl) {\n+    // init schema\n+    _schema = schema;\n+\n+    // init runtime state, runtime profile, counter\n+    TUniqueId dummy_id;\n+    dummy_id.hi = 0;\n+    dummy_id.lo = 0;\n+    TPlanFragmentExecParams params;\n+    params.fragment_instance_id = dummy_id;\n+    params.query_id = dummy_id;\n+    TExecPlanFragmentParams fragment_params;\n+    fragment_params.params = params;\n+    fragment_params.protocol_version = PaloInternalServiceVersion::V1;\n+    TQueryOptions query_options;\n+    TQueryGlobals query_globals;\n+    _runtime_state.reset(new RuntimeState(fragment_params, query_options, query_globals,\n+                                          ExecEnv::GetInstance()));\n+    DescriptorTbl* desc_tbl = NULL;\n+    Status status = DescriptorTbl::create(_runtime_state->obj_pool(), t_desc_tbl, &desc_tbl);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to create descriptor table, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_state->set_desc_tbl(desc_tbl);\n+    status = _runtime_state->init_mem_trackers(dummy_id);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to init mem trackers, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_profile.reset(new RuntimeProfile(_runtime_state->obj_pool(), \"PushBrokerReader\"));\n+    _mem_tracker.reset(new MemTracker(-1));\n+    _mem_pool.reset(new MemPool(_mem_tracker.get()));\n+    _counter.reset(new ScannerCounter());\n+\n+    // init scanner\n+    BaseScanner *scanner = nullptr;\n+    switch (t_scan_range.ranges[0].format_type) {\n+    case TFileFormatType::FORMAT_PARQUET:\n+        scanner = new ParquetScanner(_runtime_state.get(),\n+                                  _runtime_profile.get(),\n+                                  t_scan_range.params,\n+                                  t_scan_range.ranges,\n+                                  t_scan_range.broker_addresses,\n+                                  _counter.get());\n+        break;\n+    default:\n+        LOG(WARNING) << \"Unsupported file format type: \" << t_scan_range.ranges[0].format_type;\n+\t\treturn OLAP_ERR_PUSH_INIT_ERROR;\n+\t}\n+    _scanner.reset(scanner); \n+    status = _scanner->open();\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to open scanner, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    // init tuple\n+    auto tuple_id = t_scan_range.params.dest_tuple_id;\n+    _tuple_desc = _runtime_state->desc_tbl().get_tuple_descriptor(tuple_id);\n+    if (_tuple_desc == nullptr) {\n+        std::stringstream ss;\n+        LOG(WARNING) << \"Failed to get tuple descriptor, tuple_id: \" << tuple_id;\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    int tuple_buffer_size = _tuple_desc->byte_size();\n+    void* tuple_buffer = _mem_pool->allocate(tuple_buffer_size);\n+    if (tuple_buffer == nullptr) {\n+        LOG(WARNING) << \"Allocate memory for tuple failed\";\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _tuple = reinterpret_cast<Tuple*>(tuple_buffer);\n+\n+    _ready = true;\n+\treturn OLAP_SUCCESS;\n+}\n+\n+OLAPStatus PushBrokerReader::next(ContiguousRow* row) {\n+    if (!_ready || row == nullptr) {\n+        return OLAP_ERR_INPUT_PARAMETER_ERROR;\n+    }\n+\n+    memset(_tuple, 0, _tuple_desc->num_null_bytes());\n+    // Get from scanner\n+    Status status = _scanner->get_next(_tuple, _mem_pool.get(), &_eof);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Scanner get next tuple failed\";\n+        return OLAP_ERR_PUSH_INPUT_DATA_ERROR;\n+    }\n+    if (_eof) {\n+        return OLAP_SUCCESS;\n+    }\n+    //LOG(INFO) << \"row data: \" << _tuple->to_string(*_tuple_desc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 286}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxOTYwMzY2", "url": "https://github.com/apache/incubator-doris/pull/3742#pullrequestreview-421960366", "createdAt": "2020-06-01T15:42:10Z", "commit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTo0MjoxMVrOGdPkGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTo0MjoxMVrOGdPkGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxNjg4OA==", "bodyText": "Add a comment for these lines code.", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r433316888", "createdAt": "2020-06-01T15:42:11Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -761,6 +915,126 @@ OLAPStatus LzoBinaryReader::_next_block() {\n   return res;\n }\n \n+OLAPStatus PushBrokerReader::init(const Schema* schema,\n+                                  const TBrokerScanRange& t_scan_range,\n+                                  const TDescriptorTable& t_desc_tbl) {\n+    // init schema\n+    _schema = schema;\n+\n+    // init runtime state, runtime profile, counter\n+    TUniqueId dummy_id;\n+    dummy_id.hi = 0;\n+    dummy_id.lo = 0;\n+    TPlanFragmentExecParams params;\n+    params.fragment_instance_id = dummy_id;\n+    params.query_id = dummy_id;\n+    TExecPlanFragmentParams fragment_params;\n+    fragment_params.params = params;\n+    fragment_params.protocol_version = PaloInternalServiceVersion::V1;\n+    TQueryOptions query_options;\n+    TQueryGlobals query_globals;\n+    _runtime_state.reset(new RuntimeState(fragment_params, query_options, query_globals,\n+                                          ExecEnv::GetInstance()));\n+    DescriptorTbl* desc_tbl = NULL;\n+    Status status = DescriptorTbl::create(_runtime_state->obj_pool(), t_desc_tbl, &desc_tbl);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to create descriptor table, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_state->set_desc_tbl(desc_tbl);\n+    status = _runtime_state->init_mem_trackers(dummy_id);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to init mem trackers, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_profile.reset(new RuntimeProfile(_runtime_state->obj_pool(), \"PushBrokerReader\"));\n+    _mem_tracker.reset(new MemTracker(-1));\n+    _mem_pool.reset(new MemPool(_mem_tracker.get()));\n+    _counter.reset(new ScannerCounter());\n+\n+    // init scanner\n+    BaseScanner *scanner = nullptr;\n+    switch (t_scan_range.ranges[0].format_type) {\n+    case TFileFormatType::FORMAT_PARQUET:\n+        scanner = new ParquetScanner(_runtime_state.get(),\n+                                  _runtime_profile.get(),\n+                                  t_scan_range.params,\n+                                  t_scan_range.ranges,\n+                                  t_scan_range.broker_addresses,\n+                                  _counter.get());\n+        break;\n+    default:\n+        LOG(WARNING) << \"Unsupported file format type: \" << t_scan_range.ranges[0].format_type;\n+\t\treturn OLAP_ERR_PUSH_INIT_ERROR;\n+\t}\n+    _scanner.reset(scanner); \n+    status = _scanner->open();\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to open scanner, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    // init tuple\n+    auto tuple_id = t_scan_range.params.dest_tuple_id;\n+    _tuple_desc = _runtime_state->desc_tbl().get_tuple_descriptor(tuple_id);\n+    if (_tuple_desc == nullptr) {\n+        std::stringstream ss;\n+        LOG(WARNING) << \"Failed to get tuple descriptor, tuple_id: \" << tuple_id;\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    int tuple_buffer_size = _tuple_desc->byte_size();\n+    void* tuple_buffer = _mem_pool->allocate(tuple_buffer_size);\n+    if (tuple_buffer == nullptr) {\n+        LOG(WARNING) << \"Allocate memory for tuple failed\";\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _tuple = reinterpret_cast<Tuple*>(tuple_buffer);\n+\n+    _ready = true;\n+\treturn OLAP_SUCCESS;\n+}\n+\n+OLAPStatus PushBrokerReader::next(ContiguousRow* row) {\n+    if (!_ready || row == nullptr) {\n+        return OLAP_ERR_INPUT_PARAMETER_ERROR;\n+    }\n+\n+    memset(_tuple, 0, _tuple_desc->num_null_bytes());\n+    // Get from scanner\n+    Status status = _scanner->get_next(_tuple, _mem_pool.get(), &_eof);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Scanner get next tuple failed\";\n+        return OLAP_ERR_PUSH_INPUT_DATA_ERROR;\n+    }\n+    if (_eof) {\n+        return OLAP_SUCCESS;\n+    }\n+    //LOG(INFO) << \"row data: \" << _tuple->to_string(*_tuple_desc);\n+\n+    auto slot_descs = _tuple_desc->slots();\n+    size_t num_key_columns = _schema->num_key_columns();\n+    for (size_t i = 0; i < slot_descs.size(); ++i) {\n+        auto cell = row->cell(i);\n+        const SlotDescriptor* slot = slot_descs[i];\n+        bool is_null = _tuple->is_null(slot->null_indicator_offset());\n+        const void* value = _tuple->get_slot(slot->tuple_offset());\n+        _schema->column(i)->consume(&cell, (const char*)value, is_null, \n+                                    _mem_pool.get(), _runtime_state->obj_pool());\n+        if (i >= num_key_columns) {\n+            _schema->column(i)->agg_finalize(&cell, _mem_pool.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 298}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99e6ed77529382a8ea1c6dc72011062ecc6f7637", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/99e6ed77529382a8ea1c6dc72011062ecc6f7637", "committedDate": "2020-06-04T07:25:33Z", "message": "submit-spark-load-be-part"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00332c2d29b4a4b0b56d6500a4287b9e20f735c1", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/00332c2d29b4a4b0b56d6500a4287b9e20f735c1", "committedDate": "2020-06-04T07:27:42Z", "message": "fix run-ut.sh"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c9a7dbb50768ac3ceb6cb48dc91a0331e831193", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/6c9a7dbb50768ac3ceb6cb48dc91a0331e831193", "committedDate": "2020-06-04T07:27:42Z", "message": "fix ut test data"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c97c3b0d3d92d0481e074120de3a19467aacf7c7", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/c97c3b0d3d92d0481e074120de3a19467aacf7c7", "committedDate": "2020-06-04T07:27:42Z", "message": "add comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6dde2f9185fec3ae121e7c862edb045d9213e0d8", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/6dde2f9185fec3ae121e7c862edb045d9213e0d8", "committedDate": "2020-06-04T07:21:22Z", "message": "resolve conflict"}, "afterCommit": {"oid": "c97c3b0d3d92d0481e074120de3a19467aacf7c7", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/c97c3b0d3d92d0481e074120de3a19467aacf7c7", "committedDate": "2020-06-04T07:27:42Z", "message": "add comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32770821db2c5912dfcefab5e2c7707a495c3dc2", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/32770821db2c5912dfcefab5e2c7707a495c3dc2", "committedDate": "2020-06-04T07:41:09Z", "message": "change functionName finalize to close"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0cbadd4e2ba4dd9d9254d345fc083df735412e4", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/b0cbadd4e2ba4dd9d9254d345fc083df735412e4", "committedDate": "2020-06-04T07:43:45Z", "message": "fix ut"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0Mzc3OTM3", "url": "https://github.com/apache/incubator-doris/pull/3742#pullrequestreview-424377937", "createdAt": "2020-06-04T12:12:09Z", "commit": {"oid": "b0cbadd4e2ba4dd9d9254d345fc083df735412e4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjoxMjowOVrOGfC0qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjoyNTowM1rOGfDQBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwNTI4OA==", "bodyText": "reader->close()", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r435205288", "createdAt": "2020-06-04T12:12:09Z", "author": {"login": "wyb"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -248,6 +259,149 @@ void PushHandler::_get_tablet_infos(const vector<TabletVars>& tablet_vars,\n   }\n }\n \n+OLAPStatus PushHandler::_convert_v2(TabletSharedPtr cur_tablet,\n+                                    TabletSharedPtr new_tablet,\n+                                    RowsetSharedPtr* cur_rowset,\n+                                    RowsetSharedPtr* new_rowset) {\n+    OLAPStatus res = OLAP_SUCCESS;\n+    PushBrokerReader* reader = nullptr;\n+    Schema* schema = nullptr;\n+    uint32_t num_rows = 0;\n+    PUniqueId load_id;\n+    load_id.set_hi(0);\n+    load_id.set_lo(0);\n+\n+    do {\n+        VLOG(3) << \"start to convert delta file.\";\n+\n+        // 1. init RowsetBuilder of cur_tablet for current push\n+        VLOG(3) << \"init rowset builder. tablet=\" << cur_tablet->full_name()\n+            << \", block_row_size=\" << cur_tablet->num_rows_per_row_block();\n+        RowsetWriterContext context;\n+        context.rowset_id = StorageEngine::instance()->next_rowset_id();\n+        context.tablet_uid = cur_tablet->tablet_uid();\n+        context.tablet_id = cur_tablet->tablet_id();\n+        context.partition_id = _request.partition_id;\n+        context.tablet_schema_hash = cur_tablet->schema_hash();\n+        context.rowset_type = StorageEngine::instance()->default_rowset_type();\n+        context.rowset_path_prefix = cur_tablet->tablet_path();\n+        context.tablet_schema = &(cur_tablet->tablet_schema());\n+        context.rowset_state = PREPARED;\n+        context.txn_id = _request.transaction_id;\n+        context.load_id = load_id;\n+        // although the spark load output files are fully sorted,\n+        // but it depends on thirparty implementation, so we conservatively\n+        // set this value to OVERLAP_UNKNOWN\n+        context.segments_overlap = OVERLAP_UNKNOWN;\n+\n+        std::unique_ptr<RowsetWriter> rowset_writer;\n+        res = RowsetFactory::create_rowset_writer(context, &rowset_writer);\n+        if (OLAP_SUCCESS != res) {\n+            LOG(WARNING) << \"failed to init rowset writer, tablet=\" << cur_tablet->full_name()\n+                         << \", txn_id=\" << _request.transaction_id\n+                         << \", res=\" << res;\n+            break;\n+        }\n+\n+        // 2. Init PushBrokerReader to read broker file if exist,\n+        //    in case of empty push this will be skipped.\n+        std::string path = _request.broker_scan_range.ranges[0].path;\n+        LOG(INFO) << \"tablet=\" << cur_tablet->full_name() << \", file path=\" << path\n+                  << \", file size=\" << _request.broker_scan_range.ranges[0].file_size;\n+        if (!path.empty()) {\n+            reader = new(std::nothrow) PushBrokerReader();\n+            if (reader == nullptr) {\n+                LOG(WARNING) << \"fail to create reader. tablet=\" << cur_tablet->full_name();\n+                res = OLAP_ERR_MALLOC_ERROR;\n+                break;\n+            }\n+\n+            // init schema\n+            schema = new(std::nothrow) Schema(cur_tablet->tablet_schema());\n+            if (schema == nullptr) {\n+                LOG(WARNING) << \"fail to create schema. tablet=\" << cur_tablet->full_name();\n+                res = OLAP_ERR_MALLOC_ERROR;\n+                break;\n+            }\n+\n+            // init Reader\n+            if (OLAP_SUCCESS != (res = reader->init(schema, \n+                                                    _request.broker_scan_range,\n+                                                    _request.desc_tbl))) {\n+                LOG(WARNING) << \"fail to init reader. res=\" << res\n+                             << \", tablet=\" << cur_tablet->full_name();\n+                res = OLAP_ERR_PUSH_INIT_ERROR;\n+                break;\n+            }\n+\n+            // 3. Init Row\n+            uint8_t* tuple_buf = reader->mem_pool()->allocate(schema->schema_size());\n+            ContiguousRow row(schema, tuple_buf);\n+\n+            // 4. Read data from broker and write into SegmentGroup of cur_tablet\n+            // Convert from raw to delta\n+            VLOG(3) << \"start to convert etl file to delta.\";\n+            while (!reader->eof()) {\n+                res = reader->next(&row);\n+                if (OLAP_SUCCESS != res) {\n+                    LOG(WARNING) << \"read next row failed.\"\n+                        << \" res=\" << res << \" read_rows=\" << num_rows;\n+                    break;\n+                } else {\n+                    if (reader->eof()) {\n+                        break;\n+                    }\n+                    if (OLAP_SUCCESS != (res = rowset_writer->add_row(row))) {\n+                        LOG(WARNING) << \"fail to attach row to rowset_writer. \"\n+                            << \"res=\" << res\n+                            << \", tablet=\" << cur_tablet->full_name()\n+                            << \", read_rows=\" << num_rows;\n+                        break;\n+                    }\n+                    num_rows++;\n+                }\n+            }\n+\n+            reader->print_profile();\n+            reader->finalize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0cbadd4e2ba4dd9d9254d345fc083df735412e4"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwNTk3OQ==", "bodyText": "IBinaryReader should use finalize", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r435205979", "createdAt": "2020-06-04T12:13:26Z", "author": {"login": "wyb"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -368,7 +522,7 @@ OLAPStatus PushHandler::_convert(TabletSharedPtr cur_tablet,\n                 }\n             }\n \n-            reader->finalize();\n+            reader->close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0cbadd4e2ba4dd9d9254d345fc083df735412e4"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxMjI5NQ==", "bodyText": "Later you can improve this by copying the buffer directly", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r435212295", "createdAt": "2020-06-04T12:25:03Z", "author": {"login": "wyb"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -761,6 +915,126 @@ OLAPStatus LzoBinaryReader::_next_block() {\n   return res;\n }\n \n+OLAPStatus PushBrokerReader::init(const Schema* schema,\n+                                  const TBrokerScanRange& t_scan_range,\n+                                  const TDescriptorTable& t_desc_tbl) {\n+    // init schema\n+    _schema = schema;\n+\n+    // init runtime state, runtime profile, counter\n+    TUniqueId dummy_id;\n+    dummy_id.hi = 0;\n+    dummy_id.lo = 0;\n+    TPlanFragmentExecParams params;\n+    params.fragment_instance_id = dummy_id;\n+    params.query_id = dummy_id;\n+    TExecPlanFragmentParams fragment_params;\n+    fragment_params.params = params;\n+    fragment_params.protocol_version = PaloInternalServiceVersion::V1;\n+    TQueryOptions query_options;\n+    TQueryGlobals query_globals;\n+    _runtime_state.reset(new RuntimeState(fragment_params, query_options, query_globals,\n+                                          ExecEnv::GetInstance()));\n+    DescriptorTbl* desc_tbl = NULL;\n+    Status status = DescriptorTbl::create(_runtime_state->obj_pool(), t_desc_tbl, &desc_tbl);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to create descriptor table, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_state->set_desc_tbl(desc_tbl);\n+    status = _runtime_state->init_mem_trackers(dummy_id);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to init mem trackers, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _runtime_profile.reset(new RuntimeProfile(_runtime_state->obj_pool(), \"PushBrokerReader\"));\n+    _mem_tracker.reset(new MemTracker(-1));\n+    _mem_pool.reset(new MemPool(_mem_tracker.get()));\n+    _counter.reset(new ScannerCounter());\n+\n+    // init scanner\n+    BaseScanner *scanner = nullptr;\n+    switch (t_scan_range.ranges[0].format_type) {\n+    case TFileFormatType::FORMAT_PARQUET:\n+        scanner = new ParquetScanner(_runtime_state.get(),\n+                                  _runtime_profile.get(),\n+                                  t_scan_range.params,\n+                                  t_scan_range.ranges,\n+                                  t_scan_range.broker_addresses,\n+                                  _counter.get());\n+        break;\n+    default:\n+        LOG(WARNING) << \"Unsupported file format type: \" << t_scan_range.ranges[0].format_type;\n+\t\treturn OLAP_ERR_PUSH_INIT_ERROR;\n+\t}\n+    _scanner.reset(scanner); \n+    status = _scanner->open();\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Failed to open scanner, msg: \" << status.get_error_msg();\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    // init tuple\n+    auto tuple_id = t_scan_range.params.dest_tuple_id;\n+    _tuple_desc = _runtime_state->desc_tbl().get_tuple_descriptor(tuple_id);\n+    if (_tuple_desc == nullptr) {\n+        std::stringstream ss;\n+        LOG(WARNING) << \"Failed to get tuple descriptor, tuple_id: \" << tuple_id;\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+\n+    int tuple_buffer_size = _tuple_desc->byte_size();\n+    void* tuple_buffer = _mem_pool->allocate(tuple_buffer_size);\n+    if (tuple_buffer == nullptr) {\n+        LOG(WARNING) << \"Allocate memory for tuple failed\";\n+        return OLAP_ERR_PUSH_INIT_ERROR;\n+    }\n+    _tuple = reinterpret_cast<Tuple*>(tuple_buffer);\n+\n+    _ready = true;\n+\treturn OLAP_SUCCESS;\n+}\n+\n+OLAPStatus PushBrokerReader::next(ContiguousRow* row) {\n+    if (!_ready || row == nullptr) {\n+        return OLAP_ERR_INPUT_PARAMETER_ERROR;\n+    }\n+\n+    memset(_tuple, 0, _tuple_desc->num_null_bytes());\n+    // Get from scanner\n+    Status status = _scanner->get_next(_tuple, _mem_pool.get(), &_eof);\n+    if (UNLIKELY(!status.ok())) {\n+        LOG(WARNING) << \"Scanner get next tuple failed\";\n+        return OLAP_ERR_PUSH_INPUT_DATA_ERROR;\n+    }\n+    if (_eof) {\n+        return OLAP_SUCCESS;\n+    }\n+    //LOG(INFO) << \"row data: \" << _tuple->to_string(*_tuple_desc);\n+\n+    auto slot_descs = _tuple_desc->slots();\n+    size_t num_key_columns = _schema->num_key_columns();\n+    for (size_t i = 0; i < slot_descs.size(); ++i) {\n+        auto cell = row->cell(i);\n+        const SlotDescriptor* slot = slot_descs[i];\n+        bool is_null = _tuple->is_null(slot->null_indicator_offset());\n+        const void* value = _tuple->get_slot(slot->tuple_offset());\n+        _schema->column(i)->consume(&cell, (const char*)value, is_null, \n+                                    _mem_pool.get(), _runtime_state->obj_pool());\n+        if (i >= num_key_columns) {\n+            _schema->column(i)->agg_finalize(&cell, _mem_pool.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxNjg4OA=="}, "originalCommit": {"oid": "07c373a87c9fafd48eb8bcda7f0fda4ab472e442"}, "originalPosition": 298}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "395ada00a75e6b3952ba03697d6e49c5c0a34c71", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/395ada00a75e6b3952ba03697d6e49c5c0a34c71", "committedDate": "2020-06-05T05:28:44Z", "message": "reset function name to finalize"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9500dd7a20bfa112093346acb1cd1341dad0fd8a", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/9500dd7a20bfa112093346acb1cd1341dad0fd8a", "committedDate": "2020-06-05T05:39:52Z", "message": "set function name to close"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTE3MTU4", "url": "https://github.com/apache/incubator-doris/pull/3742#pullrequestreview-434117158", "createdAt": "2020-06-19T14:23:07Z", "commit": {"oid": "9500dd7a20bfa112093346acb1cd1341dad0fd8a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNDoyMzowOFrOGmWoEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNDoyMzowOFrOGmWoEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2OTc3OA==", "bodyText": "Could use std::unique_ptr?", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r442869778", "createdAt": "2020-06-19T14:23:08Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/push_handler.cpp", "diffHunk": "@@ -248,6 +259,149 @@ void PushHandler::_get_tablet_infos(const vector<TabletVars>& tablet_vars,\n   }\n }\n \n+OLAPStatus PushHandler::_convert_v2(TabletSharedPtr cur_tablet,\n+                                    TabletSharedPtr new_tablet,\n+                                    RowsetSharedPtr* cur_rowset,\n+                                    RowsetSharedPtr* new_rowset) {\n+    OLAPStatus res = OLAP_SUCCESS;\n+    PushBrokerReader* reader = nullptr;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9500dd7a20bfa112093346acb1cd1341dad0fd8a"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTIwNjQ4", "url": "https://github.com/apache/incubator-doris/pull/3742#pullrequestreview-434120648", "createdAt": "2020-06-19T14:27:28Z", "commit": {"oid": "9500dd7a20bfa112093346acb1cd1341dad0fd8a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNDoyNzoyOVrOGmWxug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNDoyNzoyOVrOGmWxug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3MjI1MA==", "bodyText": "Would better add a comment for these four push types.", "url": "https://github.com/apache/incubator-doris/pull/3742#discussion_r442872250", "createdAt": "2020-06-19T14:27:29Z", "author": {"login": "kangkaisen"}, "path": "be/src/olap/olap_common.h", "diffHunk": "@@ -169,6 +169,7 @@ enum PushType {\n     PUSH_NORMAL = 1,\n     PUSH_FOR_DELETE = 2,\n     PUSH_FOR_LOAD_DELETE = 3,\n+    PUSH_NORMAL_V2 = 4,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9500dd7a20bfa112093346acb1cd1341dad0fd8a"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1479c7d9885f2e68e923763edf49032253040b97", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/1479c7d9885f2e68e923763edf49032253040b97", "committedDate": "2020-06-22T06:43:49Z", "message": "use unique_ptr"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7d643d9c7317c19c917a053a51f2a50e3510924", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/e7d643d9c7317c19c917a053a51f2a50e3510924", "committedDate": "2020-06-22T10:45:38Z", "message": "fix unique_ptr"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODIzNjg0", "url": "https://github.com/apache/incubator-doris/pull/3742#pullrequestreview-434823684", "createdAt": "2020-06-22T11:10:27Z", "commit": {"oid": "e7d643d9c7317c19c917a053a51f2a50e3510924"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bf38c090aa6ab0c43e472edca0112790f079189", "author": {"user": {"login": "xy720", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/3bf38c090aa6ab0c43e472edca0112790f079189", "committedDate": "2020-06-22T11:34:16Z", "message": "fix some mistake"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODUyODc1", "url": "https://github.com/apache/incubator-doris/pull/3742#pullrequestreview-434852875", "createdAt": "2020-06-22T11:57:15Z", "commit": {"oid": "3bf38c090aa6ab0c43e472edca0112790f079189"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2408, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}