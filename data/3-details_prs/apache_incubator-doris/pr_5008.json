{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwOTEyOTQ4", "number": 5008, "title": "[Optimize][Cache]Implementation of Separated Page Cache", "bodyText": "Proposed changes\n#4995\nImplementation of Separated Page Cache\n\nAdd config \"index_page_cache_ratio\" to set the ratio of capacity of index page cache\nChange the member of StoragePageCache to maintain two type of cache\nChange the interface of StoragePageCache for selecting type of cache\nChange the usage of page cache in read_and_decompress_page in page_io.cpp\n\nadd page type as argument\ncheck if current page type is available in StoragePageCache (cover the situation of ratio == 0 or 1)\n\n\nAdd type as argument in superior call of read_and_decompress_page\nChange Unit Test\n\nTypes of changes\nWhat types of changes does your code introduce to Doris?\nPut an x in the boxes that apply\n\n[] Bugfix (non-breaking change which fixes an issue)\n New feature (non-breaking change which adds functionality)\n[] Breaking change (fix or feature that would cause existing functionality to not work as expected)\n[] Documentation Update (if none of the other choices apply)\n Code refactor (Modify the code structure, format the code, etc...)\n\nChecklist\nPut an x in the boxes that apply. You can also fill these out after creating the PR. If you're unsure about any of them, don't hesitate to ask. We're here to help! This is simply a reminder of what we are going to look for before merging your code.\n\n I have create an issue on (Fix #4995), and have described the bug/feature there in detail\n Compiling and unit tests pass locally with my changes\n I have added tests that prove my fix is effective or that my feature works\n[] If this change need a document change, I have updated the document\n Any dependent changes have been merged", "createdAt": "2020-12-02T10:26:39Z", "url": "https://github.com/apache/incubator-doris/pull/5008", "merged": true, "mergeCommit": {"oid": "6c098e45fc33342da6bb47dbdc34dda1e40a3cec"}, "closed": true, "closedAt": "2021-01-04T04:19:24Z", "author": {"login": "Skysheepwang"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkDuTcAFqTU0Njc1ODM5Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdsud-ygFqTU2MDc3MzE3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NzU4Mzky", "url": "https://github.com/apache/incubator-doris/pull/5008#pullrequestreview-546758392", "createdAt": "2020-12-08T05:35:02Z", "commit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTozNTowMlrOIBH3HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNTo1ODowMVrOIBIXIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA0ODI4NA==", "bodyText": "I think it's better to give more description, such as what does the left size used for?", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538048284", "createdAt": "2020-12-08T05:35:02Z", "author": {"login": "acelyc111"}, "path": "be/src/common/config.h", "diffHunk": "@@ -260,6 +260,8 @@ CONF_Int64(index_stream_cache_capacity, \"10737418240\");\n \n // Cache for storage page size\n CONF_String(storage_page_cache_limit, \"20G\");\n+// Ratio for index page cache", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA0OTEzNw==", "bodyText": "Better to define it as a static function", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538049137", "createdAt": "2020-12-08T05:37:23Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.h", "diffHunk": "@@ -53,36 +54,44 @@ class StoragePageCache {\n     };\n \n     // Create global instance of this class\n-    static void create_global_cache(size_t capacity);\n+    static void create_global_cache(size_t capacity, double index_cache_ratio);\n \n     // Return global instance.\n     // Client should call create_global_cache before.\n     static StoragePageCache* instance() { return _s_instance; }\n \n-    StoragePageCache(size_t capacity);\n+    StoragePageCache(size_t capacity, double index_cache_ratio);\n \n     // Lookup the given page in the cache.\n     //\n     // If the page is found, the cache entry will be written into handle.\n     // PageCacheHandle will release cache entry to cache when it\n     // destructs.\n     //\n+    // Cache type selection is determined by page_type argument\n+    //\n     // Return true if entry is found, otherwise return false.\n-    bool lookup(const CacheKey& key, PageCacheHandle* handle);\n+    bool lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type);\n \n     // Insert a page with key into this cache.\n     // Given handle will be set to valid reference.\n     // This function is thread-safe, and when two clients insert two same key\n     // concurrently, this function can assure that only one page is cached.\n     // The in_memory page will have higher priority.\n     void insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                bool in_memory = false);\n+                segment_v2::PageTypePB page_type, bool in_memory = false);\n+\n+    // Page cache available check.\n+    // When ratio is set to 0 or 1, the index or data cache will not be allocated.\n+    bool is_cache_available(segment_v2::PageTypePB page_type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1MTk1NA==", "bodyText": "For double type values, better to use expression like std::abs(index_cache_ratio) < 1e-6 to judge whether they are equaled. If you think it's too ugly, you can use percentagle int value instead.", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538051954", "createdAt": "2020-12-08T05:45:20Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1MzIyNA==", "bodyText": "What if the other values passed, how about add CHECK(false) << \"xxx\" in else scope?", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538053224", "createdAt": "2020-12-08T05:48:58Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio == 1) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio > 0 && index_cache_ratio < 1) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", static_cast<size_t>(capacity * (1 - index_cache_ratio))));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", static_cast<size_t>(capacity * index_cache_ratio)));\n+    }   ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NDIwOQ==", "bodyText": "There are some duplicate code, how about define a function like Cache::Handle* get_cache(segment_v2::PageTypePB page_type) to get lru_handle  at first, then do the same thing as before?", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538054209", "createdAt": "2020-12-08T05:51:49Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio == 1) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio > 0 && index_cache_ratio < 1) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", static_cast<size_t>(capacity * (1 - index_cache_ratio))));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", static_cast<size_t>(capacity * index_cache_ratio)));\n+    }   \n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n-    if (lru_handle == nullptr) {\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NDM1Mg==", "bodyText": "Same", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538054352", "createdAt": "2020-12-08T05:52:11Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio == 1) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio > 0 && index_cache_ratio < 1) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", static_cast<size_t>(capacity * (1 - index_cache_ratio))));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", static_cast<size_t>(capacity * index_cache_ratio)));\n+    }   \n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n-    if (lru_handle == nullptr) {\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;\n+    default:\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->insert(key.encode(), data.data, data.size, deleter, priority);\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->insert(key.encode(), data.data, data.size, deleter, priority);\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NDk4OQ==", "bodyText": "If you do the refactor as mentioned above, you can simply judge whether the return Cache*  is nullptr or not", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538054989", "createdAt": "2020-12-08T05:54:03Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio == 1) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio > 0 && index_cache_ratio < 1) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", static_cast<size_t>(capacity * (1 - index_cache_ratio))));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", static_cast<size_t>(capacity * index_cache_ratio)));\n+    }   \n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n-    if (lru_handle == nullptr) {\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;\n+    default:\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->insert(key.encode(), data.data, data.size, deleter, priority);\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->insert(key.encode(), data.data, data.size, deleter, priority);\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;\n+    default:\n+        break;\n+    }\n+}\n+\n+bool StoragePageCache::is_cache_available(segment_v2::PageTypePB page_type) {\n+    if (page_type == segment_v2::DATA_PAGE && _index_cache_ratio == 1) {\n+        return false;\n+    }\n+    else if (page_type == segment_v2::INDEX_PAGE && _index_cache_ratio == 0) {\n+        return false;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NjQzNA==", "bodyText": "Add descriptions.", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538056434", "createdAt": "2020-12-08T05:57:52Z", "author": {"login": "acelyc111"}, "path": "docs/en/administrator-guide/config/be_config.md", "diffHunk": "@@ -695,6 +695,8 @@ Indicates how many tablets in this data directory failed to load. At the same ti\n \n ### `storage_page_cache_limit`\n \n+### `index_page_cache_ratio`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NjQ4Mg==", "bodyText": "Add descriptions.", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538056482", "createdAt": "2020-12-08T05:58:01Z", "author": {"login": "acelyc111"}, "path": "docs/zh-CN/administrator-guide/config/be_config.md", "diffHunk": "@@ -693,6 +693,8 @@ load tablets from header failed, failed tablets size: xxx, path=xxx\n \n ### `storage_page_cache_limit`\n \n+### `index_page_cache_ratio`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe9cf7be97076f8c8c545789e032ef734412a180"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5e2cfa883a42df52aade1ad5b87454e3e77a9aea", "author": {"user": {"login": "Skysheepwang", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/5e2cfa883a42df52aade1ad5b87454e3e77a9aea", "committedDate": "2020-12-09T07:42:49Z", "message": "fix bugs"}, "afterCommit": {"oid": "0086e4efcdff1ebeb77ff4843bc18b2e087ef041", "author": {"user": {"login": "Skysheepwang", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/0086e4efcdff1ebeb77ff4843bc18b2e087ef041", "committedDate": "2020-12-09T07:44:53Z", "message": "improve implementation following acelyc111 's review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MjMyMTgz", "url": "https://github.com/apache/incubator-doris/pull/5008#pullrequestreview-548232183", "createdAt": "2020-12-09T14:23:12Z", "commit": {"oid": "0086e4efcdff1ebeb77ff4843bc18b2e087ef041"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDoyMzoxMlrOICXIxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDoyNTo0NFrOICXQjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0NzE0Mg==", "bodyText": "How about\nauto cache = _get_page_cache(page_type);\nauto lru_handle = cache->lookup(key.encode());\nif (lru_handle == nullptr) {\n    return false;\n}\n*handle = PageCacheHandle(cache, lru_handle);\nreturn true;", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539347142", "createdAt": "2020-12-09T14:23:12Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,70 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    }\n+    else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n     return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0086e4efcdff1ebeb77ff4843bc18b2e087ef041"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0ODAyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (_get_page_cache(page_type) == nullptr) {\n          \n          \n            \n                    return false;\n          \n          \n            \n                }\n          \n          \n            \n                return true;\n          \n          \n            \n                return _get_page_cache(page_type) != nullptr;", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539348025", "createdAt": "2020-12-09T14:24:24Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,70 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    }\n+    else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->insert(key.encode(), data.data, data.size, deleter, priority);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n+}\n+\n+bool StoragePageCache::is_cache_available(segment_v2::PageTypePB page_type) {\n+    if (_get_page_cache(page_type) == nullptr) {\n+        return false;\n+    }\n+    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0086e4efcdff1ebeb77ff4843bc18b2e087ef041"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0OTEzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Cache::Handle* lru_handle = nullptr;\n          \n          \n            \n                lru_handle = _get_page_cache(page_type)->insert(key.encode(), data.data, data.size, deleter, priority);\n          \n          \n            \n                *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n          \n          \n            \n                auto cache = _get_page_cache(page_type);\n          \n          \n            \n                Cache::Handle* lru_handle = cache->insert(key.encode(), data.data, data.size, deleter, priority);\n          \n          \n            \n                *handle = PageCacheHandle(cache, lru_handle);", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539349132", "createdAt": "2020-12-09T14:25:44Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,70 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    }\n+    else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->insert(key.encode(), data.data, data.size, deleter, priority);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0086e4efcdff1ebeb77ff4843bc18b2e087ef041"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4OTg5Mjg2", "url": "https://github.com/apache/incubator-doris/pull/5008#pullrequestreview-548989286", "createdAt": "2020-12-10T09:15:10Z", "commit": {"oid": "c02b4de626bb5658dcedec67dee0be713a001aed"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOToxNToxMFrOIC-9bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOToxNToxMFrOIC-9bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5OTU5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                }\n          \n          \n            \n                else if (index_cache_percentage == 100) {\n          \n          \n            \n                    _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n          \n          \n            \n                }\n          \n          \n            \n                else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n          \n          \n            \n                    _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n          \n          \n            \n                    _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n          \n          \n            \n                }\n          \n          \n            \n                else {\n          \n          \n            \n                } else if (index_cache_percentage == 100) {\n          \n          \n            \n                    _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n          \n          \n            \n                } else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n          \n          \n            \n                    _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n          \n          \n            \n                    _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n          \n          \n            \n                } else {", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539999599", "createdAt": "2020-12-10T09:15:10Z", "author": {"login": "acelyc111"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,51 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    }\n+    else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c02b4de626bb5658dcedec67dee0be713a001aed"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5MDMwNDI4", "url": "https://github.com/apache/incubator-doris/pull/5008#pullrequestreview-549030428", "createdAt": "2020-12-10T10:02:21Z", "commit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5MDMwNjY0", "url": "https://github.com/apache/incubator-doris/pull/5008#pullrequestreview-549030664", "createdAt": "2020-12-10T10:02:38Z", "commit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMzcwNDg0", "url": "https://github.com/apache/incubator-doris/pull/5008#pullrequestreview-551370484", "createdAt": "2020-12-14T13:36:23Z", "commit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzozNjoyM1rOIFQufA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzo0MDo0NlrOIFQ6gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4NzgzNg==", "bodyText": "the cache maybe null if the index_page_cache_percentage is 0 or 100", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542387836", "createdAt": "2020-12-14T13:36:23Z", "author": {"login": "morningman"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,48 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    } else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    } else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    } else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    auto cache = _get_page_cache(page_type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4ODkxNA==", "bodyText": "cache may be null", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542388914", "createdAt": "2020-12-14T13:37:53Z", "author": {"login": "morningman"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,48 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    } else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    } else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    } else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    auto cache = _get_page_cache(page_type);\n+    auto lru_handle = cache->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(cache, lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    auto cache = _get_page_cache(page_type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM5MDkxMw==", "bodyText": "I think the check of is_cache_available() can be put into lookup() method for easy to use?\nAs well as the following insert logic", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542390913", "createdAt": "2020-12-14T13:40:46Z", "author": {"login": "morningman"}, "path": "be/src/olap/rowset/segment_v2/page_io.cpp", "diffHunk": "@@ -112,7 +112,7 @@ Status PageIO::read_and_decompress_page(const PageReadOptions& opts, PageHandle*\n     auto cache = StoragePageCache::instance();\n     PageCacheHandle cache_handle;\n     StoragePageCache::CacheKey cache_key(opts.rblock->path(), opts.page_pointer.offset);\n-    if (opts.use_page_cache && cache->lookup(cache_key, &cache_handle)) {\n+    if (opts.use_page_cache && cache->is_cache_available(opts.type) && cache->lookup(cache_key, &cache_handle, opts.type)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNTAyODI4", "url": "https://github.com/apache/incubator-doris/pull/5008#pullrequestreview-553502828", "createdAt": "2020-12-16T09:31:45Z", "commit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "state": "DISMISSED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOTozMTo0NlrOIG7-CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOTozMTo0NlrOIG7-CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE0NDkwNQ==", "bodyText": "Ok", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r544144905", "createdAt": "2020-12-16T09:31:46Z", "author": {"login": "morningman"}, "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,48 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    } else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    } else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    } else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    auto cache = _get_page_cache(page_type);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4NzgzNg=="}, "originalCommit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c"}, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e0248a305493f08105722a75bf6cb4ac3394392c", "author": {"user": {"login": "Skysheepwang", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/e0248a305493f08105722a75bf6cb4ac3394392c", "committedDate": "2020-12-10T09:22:57Z", "message": "fix code format problem\n\nCo-authored-by: Yingchun Lai <405403881@qq.com>"}, "afterCommit": {"oid": "adb95fce0b9a66d0973852278e7f41380270a614", "author": {"user": {"login": "Skysheepwang", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/adb95fce0b9a66d0973852278e7f41380270a614", "committedDate": "2020-12-16T09:38:56Z", "message": "Implementation of Separated Page Cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d", "author": {"user": {"login": "Skysheepwang", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d", "committedDate": "2020-12-16T09:52:42Z", "message": "Implementation of Separated Page Cache"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "adb95fce0b9a66d0973852278e7f41380270a614", "author": {"user": {"login": "Skysheepwang", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/adb95fce0b9a66d0973852278e7f41380270a614", "committedDate": "2020-12-16T09:38:56Z", "message": "Implementation of Separated Page Cache"}, "afterCommit": {"oid": "2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d", "author": {"user": {"login": "Skysheepwang", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d", "committedDate": "2020-12-16T09:52:42Z", "message": "Implementation of Separated Page Cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDkwNzEw", "url": "https://github.com/apache/incubator-doris/pull/5008#pullrequestreview-555490710", "createdAt": "2020-12-18T13:38:33Z", "commit": {"oid": "2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NzYyMjM4", "url": "https://github.com/apache/incubator-doris/pull/5008#pullrequestreview-556762238", "createdAt": "2020-12-22T01:28:41Z", "commit": {"oid": "2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d7c2aa5a8cb7c13f8a78ad1de7f7629f1dc362bd", "author": {"user": {"login": "Skysheepwang", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/d7c2aa5a8cb7c13f8a78ad1de7f7629f1dc362bd", "committedDate": "2020-12-22T03:26:59Z", "message": "fix old tablet inserting bug"}, "afterCommit": {"oid": "2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d", "author": {"user": {"login": "Skysheepwang", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d", "committedDate": "2020-12-16T09:52:42Z", "message": "Implementation of Separated Page Cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2ODA2MTIy", "url": "https://github.com/apache/incubator-doris/pull/5008#pullrequestreview-556806122", "createdAt": "2020-12-22T04:06:09Z", "commit": {"oid": "2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4Mjk3MzMw", "url": "https://github.com/apache/incubator-doris/pull/5008#pullrequestreview-558297330", "createdAt": "2020-12-24T01:40:17Z", "commit": {"oid": "2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "140a8e52bd9e81d0bd339bee37f522884da1955c", "author": {"user": {"login": "Skysheepwang", "name": null}}, "url": "https://github.com/apache/incubator-doris/commit/140a8e52bd9e81d0bd339bee37f522884da1955c", "committedDate": "2020-12-24T02:07:52Z", "message": "Merge branch 'master' into master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNzczMTc5", "url": "https://github.com/apache/incubator-doris/pull/5008#pullrequestreview-560773179", "createdAt": "2021-01-04T04:18:17Z", "commit": {"oid": "140a8e52bd9e81d0bd339bee37f522884da1955c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4670, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}