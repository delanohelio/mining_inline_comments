{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyNTkyNjMy", "number": 4248, "title": "[Feature][Cache] Cache proxy and coordinator #2581", "bodyText": "Proposed changes\n\nCache's abstract proxy class and BE's Cache implementation\nCache coordinator implemented by consistent hashing\n#2581\n\nTypes of changes\nWhat types of changes does your code introduce to Doris?\nPut an x in the boxes that apply\n\n[] Bugfix (non-breaking change which fixes an issue)\n New feature (non-breaking change which adds functionality)\n[] Breaking change (fix or feature that would cause existing functionality to not work as expected)\n[] Documentation Update (if none of the other choices apply)\n[] Code refactor (Modify the code structure, format the code, etc...)\n\nChecklist\nPut an x in the boxes that apply. You can also fill these out after creating the PR. If you're unsure about any of them, don't hesitate to ask. We're here to help! This is simply a reminder of what we are going to look for before merging your code.\n\n I have create an issue on #ISSUE, and have described the bug/feature there in detail\n Compiling and unit tests pass locally with my changes\n I have added tests that prove my fix is effective or that my feature works\n[] If this change need a document change, I have updated the document\n[] Any dependent changes have been merged\n\nFurther comments\nIf this is a relatively large or complex change, kick off the discussion at dev@doris.apache.org by explaining why you chose the solution you did and what alternatives you considered, etc...", "createdAt": "2020-08-04T07:47:38Z", "url": "https://github.com/apache/incubator-doris/pull/4248", "merged": true, "mergeCommit": {"oid": "4ad943e45d0f71cacbde524394ea0f14a7440666"}, "closed": true, "closedAt": "2020-08-10T08:40:26Z", "author": {"login": "marising"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7huMMAH2gAyNDYyNTkyNjMyOmFlMzY4MjE0MWMxOWY1ZjUzOWZmYjk0YTdmYTJkZWM2MjdlYThiMzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7755TgFqTQ2MTcwNzEwMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32", "author": {"user": {"login": "marising", "name": "HaiBo Li"}}, "url": "https://github.com/apache/incubator-doris/commit/ae3682141c19f5f539ffb94a7fa2dec627ea8b32", "committedDate": "2020-08-04T07:44:56Z", "message": "[Feature][Cache] Cache proxy and coordinator #2581\n1. Cache's abstract proxy class and BE's Cache implementation\n2. Cache coordinator implemented by consistent hashing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNzI3MDYy", "url": "https://github.com/apache/incubator-doris/pull/4248#pullrequestreview-460727062", "createdAt": "2020-08-04T11:30:14Z", "commit": {"oid": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMTozMDoxNFrOG7cVZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMTo1MDowN1rOG73STw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4MzM5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Encapsulates access to BE, including network and other exception handlin\n          \n          \n            \n             * Encapsulates access to BE, including network and other exception handling", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r464983399", "createdAt": "2020-08-04T11:30:14Z", "author": {"login": "kangkaisen"}, "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheBeProxy.java", "diffHunk": "@@ -0,0 +1,167 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.proto.PCacheStatus;\n+import org.apache.doris.proto.PCacheResponse;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PClearType;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.qe.SimpleScheduler;\n+import org.apache.doris.rpc.BackendServiceProxy;\n+import org.apache.doris.rpc.RpcException;\n+import org.apache.doris.system.Backend;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.thrift.TNetworkAddress;\n+\n+import org.apache.doris.thrift.TStatusCode;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.List;\n+\n+/**\n+ * Encapsulates access to BE, including network and other exception handlin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk5MTgxNA==", "bodyText": "Please code format this file.", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r464991814", "createdAt": "2020-08-04T11:47:51Z", "author": {"login": "kangkaisen"}, "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheBeProxy.java", "diffHunk": "@@ -0,0 +1,167 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.proto.PCacheStatus;\n+import org.apache.doris.proto.PCacheResponse;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PClearType;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.qe.SimpleScheduler;\n+import org.apache.doris.rpc.BackendServiceProxy;\n+import org.apache.doris.rpc.RpcException;\n+import org.apache.doris.system.Backend;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.thrift.TNetworkAddress;\n+\n+import org.apache.doris.thrift.TStatusCode;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.List;\n+\n+/**\n+ * Encapsulates access to BE, including network and other exception handlin\n+ */\n+public class CacheBeProxy extends CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public void updateCache(UpdateCacheRequest request, Status status) {\n+        PUniqueId sqlKey = request.sql_key;\n+        Backend backend = CacheCoordinator.getInstance().findBackend(sqlKey);\n+        if (backend == null) {\n+            LOG.warn(\"update cache can't find backend, sqlKey {}\", sqlKey);\n+            return;\n+        }\n+        TNetworkAddress address = new TNetworkAddress(backend.getHost(), backend.getBrpcPort());\n+        try {\n+            PUpdateCacheRequest updateRequest = request.getRpcRequest();\n+            Future<PCacheResponse> future = BackendServiceProxy.getInstance().updateCache(address, updateRequest);\n+            PCacheResponse response = future.get(10000,TimeUnit.MICROSECONDS);\n+            if( response.status == PCacheStatus.CACHE_OK) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxNTYwMg==", "bodyText": "If do nothing, we could remove finally.", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465415602", "createdAt": "2020-08-05T01:15:38Z", "author": {"login": "kangkaisen"}, "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheBeProxy.java", "diffHunk": "@@ -0,0 +1,167 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.proto.PCacheStatus;\n+import org.apache.doris.proto.PCacheResponse;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PClearType;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.qe.SimpleScheduler;\n+import org.apache.doris.rpc.BackendServiceProxy;\n+import org.apache.doris.rpc.RpcException;\n+import org.apache.doris.system.Backend;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.thrift.TNetworkAddress;\n+\n+import org.apache.doris.thrift.TStatusCode;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.List;\n+\n+/**\n+ * Encapsulates access to BE, including network and other exception handlin\n+ */\n+public class CacheBeProxy extends CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public void updateCache(UpdateCacheRequest request, Status status) {\n+        PUniqueId sqlKey = request.sql_key;\n+        Backend backend = CacheCoordinator.getInstance().findBackend(sqlKey);\n+        if (backend == null) {\n+            LOG.warn(\"update cache can't find backend, sqlKey {}\", sqlKey);\n+            return;\n+        }\n+        TNetworkAddress address = new TNetworkAddress(backend.getHost(), backend.getBrpcPort());\n+        try {\n+            PUpdateCacheRequest updateRequest = request.getRpcRequest();\n+            Future<PCacheResponse> future = BackendServiceProxy.getInstance().updateCache(address, updateRequest);\n+            PCacheResponse response = future.get(10000,TimeUnit.MICROSECONDS);\n+            if( response.status == PCacheStatus.CACHE_OK) {\n+                status.setStatus(new Status(TStatusCode.OK, \"CACHE_OK\"));\n+            }else {\n+                status.setStatus(response.status.toString());\n+            }\n+        } catch (Exception e) {\n+            LOG.warn(\"update cache exception, sqlKey {}, e {}\", sqlKey, e);\n+            status.setRpcStatus(e.getMessage());\n+            SimpleScheduler.addToBlacklist(backend.getId());\n+        } finally {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMDI1OA==", "bodyText": "What's the meaning of checkBackend?  which clearBackend firstly, then addBackend. rebuildBackend or resetBackend seems better?", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465420258", "createdAt": "2020-08-05T01:32:55Z", "author": {"login": "kangkaisen"}, "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheCoordinator.java", "diffHunk": "@@ -0,0 +1,162 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.qe.SimpleScheduler;\n+import org.apache.doris.system.Backend;\n+import org.apache.doris.proto.PUniqueId;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.Iterator;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Use consistent hashing to find the BE corresponding to the key to avoid the change of BE leading to failure to hit the Cache\n+ */\n+public class CacheCoordinator {\n+    private static final Logger LOG = LogManager.getLogger(CacheCoordinator.class);\n+    private static final int VIRTUAL_NODES = 10;\n+    private static final int REFRESH_NODE_TIME = 300000;\n+    public boolean DebugModel = false;\n+    private Hashtable<Long, Backend> realNodes = new Hashtable<>();\n+    private SortedMap<Long, Backend> virtualNodes = new TreeMap<>();\n+    private static Lock belock = new ReentrantLock();\n+\n+    private long lastRefreshTime;\n+    private static CacheCoordinator cachePartition;\n+\n+    public static CacheCoordinator getInstance() {\n+        if (cachePartition == null) {\n+            cachePartition = new CacheCoordinator();\n+        }\n+        return cachePartition;\n+    }\n+\n+    protected CacheCoordinator() {\n+    }\n+\n+    /**\n+     * Using the consistent hash and the hi part of sqlkey to get the backend node\n+     *\n+     * @param sqlKey 128 bit's sql md5\n+     * @return Backend\n+     */\n+    public Backend findBackend(PUniqueId sqlKey) {\n+        checkBackend();\n+        Backend virtualNode = null;\n+        try {\n+            belock.lock();\n+            SortedMap<Long, Backend> headMap = virtualNodes.headMap(sqlKey.hi);\n+            SortedMap<Long, Backend> tailMap = virtualNodes.tailMap(sqlKey.hi);\n+            int retryTimes = 0;\n+            while (true) {\n+                if (tailMap == null || tailMap.size() == 0) {\n+                    tailMap = headMap;\n+                    retryTimes += 1;\n+                }\n+                Long key = tailMap.firstKey();\n+                virtualNode = tailMap.get(key);\n+                if (SimpleScheduler.isAlive(virtualNode)) {\n+                    break;\n+                } else {\n+                    LOG.debug(\"backend {} not alive, key {}, retry {}\", virtualNode.getId(), key, retryTimes);\n+                    virtualNode = null;\n+                }\n+                tailMap = tailMap.tailMap(key + 1);\n+                retryTimes++;\n+                if (retryTimes >= 5) {\n+                    LOG.warn(\"find backend, reach max retry times {}\", retryTimes);\n+                    break;\n+                }\n+            }\n+        } finally {\n+            belock.unlock();\n+        }\n+        return virtualNode;\n+    }\n+\n+    public void checkBackend() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMDYyOA==", "bodyText": "getParam \uff1f", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465420628", "createdAt": "2020-08-05T01:34:30Z", "author": {"login": "kangkaisen"}, "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheProxy.java", "diffHunk": "@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.proto.PCacheParam;\n+import org.apache.doris.proto.PCacheValue;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.thrift.TResultBatch;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.util.List;\n+\n+/**\n+ * It encapsulates the request and response parameters and methods, \n+ * Based on this abstract class, the cache can be placed in FE/BE  and other places such as redis\n+ */\n+public abstract class CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public static class CacheParam extends PCacheParam {\n+        public CacheParam(PCacheParam param) {\n+            partition_key = param.partition_key;\n+            last_version = param.last_version;\n+            last_version_time = param.last_version_time;\n+        }\n+\n+        public CacheParam(long partitionKey, long lastVersion, long lastVersionTime) {\n+            partition_key = partitionKey;\n+            last_version = lastVersion;\n+            last_version_time = lastVersionTime;\n+        }\n+\n+        public PCacheParam getRParam() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMDY2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public void Debug() {\n          \n          \n            \n                    public void debug() {", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465420667", "createdAt": "2020-08-05T01:34:39Z", "author": {"login": "kangkaisen"}, "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheProxy.java", "diffHunk": "@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.proto.PCacheParam;\n+import org.apache.doris.proto.PCacheValue;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.thrift.TResultBatch;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.util.List;\n+\n+/**\n+ * It encapsulates the request and response parameters and methods, \n+ * Based on this abstract class, the cache can be placed in FE/BE  and other places such as redis\n+ */\n+public abstract class CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public static class CacheParam extends PCacheParam {\n+        public CacheParam(PCacheParam param) {\n+            partition_key = param.partition_key;\n+            last_version = param.last_version;\n+            last_version_time = param.last_version_time;\n+        }\n+\n+        public CacheParam(long partitionKey, long lastVersion, long lastVersionTime) {\n+            partition_key = partitionKey;\n+            last_version = lastVersion;\n+            last_version_time = lastVersionTime;\n+        }\n+\n+        public PCacheParam getRParam() {\n+            PCacheParam param = new PCacheParam();\n+            param.partition_key = partition_key;\n+            param.last_version = last_version;\n+            param.last_version_time = last_version_time;\n+            return param;\n+        }\n+\n+        public void Debug() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMTI0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        row = Lists.newArrayList();\n          \n          \n            \n                        rows = Lists.newArrayList();", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465421246", "createdAt": "2020-08-05T01:36:40Z", "author": {"login": "kangkaisen"}, "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheProxy.java", "diffHunk": "@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.proto.PCacheParam;\n+import org.apache.doris.proto.PCacheValue;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.thrift.TResultBatch;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.util.List;\n+\n+/**\n+ * It encapsulates the request and response parameters and methods, \n+ * Based on this abstract class, the cache can be placed in FE/BE  and other places such as redis\n+ */\n+public abstract class CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public static class CacheParam extends PCacheParam {\n+        public CacheParam(PCacheParam param) {\n+            partition_key = param.partition_key;\n+            last_version = param.last_version;\n+            last_version_time = param.last_version_time;\n+        }\n+\n+        public CacheParam(long partitionKey, long lastVersion, long lastVersionTime) {\n+            partition_key = partitionKey;\n+            last_version = lastVersion;\n+            last_version_time = lastVersionTime;\n+        }\n+\n+        public PCacheParam getRParam() {\n+            PCacheParam param = new PCacheParam();\n+            param.partition_key = partition_key;\n+            param.last_version = last_version;\n+            param.last_version_time = last_version_time;\n+            return param;\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"cache param, part key {}, version {}, time {}\",\n+                    partition_key, last_version, last_version_time);\n+        }\n+    }\n+\n+    public static class CacheValue extends PCacheValue {\n+        public CacheParam param;\n+        public TResultBatch resultBatch;\n+\n+        public CacheValue() {\n+            param = null;\n+            row = Lists.newArrayList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMjcyNQ==", "bodyText": "Need a concrete method name", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465422725", "createdAt": "2020-08-05T01:42:24Z", "author": {"login": "kangkaisen"}, "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheProxy.java", "diffHunk": "@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.proto.PCacheParam;\n+import org.apache.doris.proto.PCacheValue;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.thrift.TResultBatch;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.util.List;\n+\n+/**\n+ * It encapsulates the request and response parameters and methods, \n+ * Based on this abstract class, the cache can be placed in FE/BE  and other places such as redis\n+ */\n+public abstract class CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public static class CacheParam extends PCacheParam {\n+        public CacheParam(PCacheParam param) {\n+            partition_key = param.partition_key;\n+            last_version = param.last_version;\n+            last_version_time = param.last_version_time;\n+        }\n+\n+        public CacheParam(long partitionKey, long lastVersion, long lastVersionTime) {\n+            partition_key = partitionKey;\n+            last_version = lastVersion;\n+            last_version_time = lastVersionTime;\n+        }\n+\n+        public PCacheParam getRParam() {\n+            PCacheParam param = new PCacheParam();\n+            param.partition_key = partition_key;\n+            param.last_version = last_version;\n+            param.last_version_time = last_version_time;\n+            return param;\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"cache param, part key {}, version {}, time {}\",\n+                    partition_key, last_version, last_version_time);\n+        }\n+    }\n+\n+    public static class CacheValue extends PCacheValue {\n+        public CacheParam param;\n+        public TResultBatch resultBatch;\n+\n+        public CacheValue() {\n+            param = null;\n+            row = Lists.newArrayList();\n+            data_size = 0;\n+            resultBatch = new TResultBatch();\n+        }\n+\n+        public void addRpcResult(PCacheValue value) {\n+            param = new CacheParam(value.param);\n+            data_size += value.data_size;\n+            row.addAll(value.row);\n+        }\n+\n+        public RowBatch getRowBatch() {\n+            for (byte[] one : row) {\n+                resultBatch.addToRows(ByteBuffer.wrap(one));\n+            }\n+            RowBatch batch = new RowBatch();\n+            resultBatch.setPacket_seq(1);\n+            resultBatch.setIs_compressed(false);\n+            batch.setBatch(resultBatch);\n+            batch.setEos(true);\n+            return batch;\n+        }\n+\n+        public void addUpdateResult(long partitionKey, long lastVersion, long lastVersionTime, List<byte[]> rowList) {\n+            param = new CacheParam(partitionKey, lastVersion, lastVersionTime);\n+            for (byte[] buf : rowList) {\n+                data_size += buf.length;\n+                row.add(buf);\n+            }\n+        }\n+\n+        public PCacheValue getRpcValue() {\n+            PCacheValue value = new PCacheValue();\n+            value.param = param.getRParam();\n+            value.data_size = data_size;\n+            value.row = row;\n+            return value;\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"cache value, partkey {}, ver:{}, time {}, row_num {}, data_size {}\",\n+                    param.partition_key, param.last_version, param.last_version_time,\n+                    row.size(),\n+                    data_size);\n+            for (int i = 0; i < row.size(); i++) {\n+                LOG.info(\"{}:{}\", i, row.get(i));\n+            }\n+        }\n+    }\n+\n+    public static class UpdateCacheRequest extends PUpdateCacheRequest {\n+        public int value_count;\n+        public int row_count;\n+        public int data_size;\n+        private String sqlStr;\n+        private List<CacheValue> valueList;\n+\n+        public UpdateCacheRequest(String sqlStr) {\n+            this.sqlStr = sqlStr;\n+            this.sql_key = getMd5(this.sqlStr);\n+            this.valueList = Lists.newArrayList();\n+            value_count = 0;\n+            row_count = 0;\n+            data_size = 0;\n+        }\n+\n+        public void addValue(long partitionKey, long lastVersion, long lastVersionTime, List<byte[]> rowList) {\n+            CacheValue value = new CacheValue();\n+            value.addUpdateResult(partitionKey, lastVersion, lastVersionTime, rowList);\n+            valueList.add(value);\n+            value_count++;\n+        }\n+\n+        public PUpdateCacheRequest getRpcRequest() {\n+            value_count = valueList.size();\n+            PUpdateCacheRequest request = new PUpdateCacheRequest();\n+            request.value = Lists.newArrayList();\n+            request.sql_key = sql_key;\n+            for (CacheValue value : valueList) {\n+                request.value.add(value.getRpcValue());\n+                row_count += value.row.size();\n+                data_size = value.data_size;\n+            }\n+            return request;\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"update cache request, sql_key {}, value_size {}\", DebugUtil.printId(sql_key),\n+                    valueList.size());\n+            for (CacheValue value : valueList) {\n+                value.Debug();\n+            }\n+        }\n+    }\n+\n+\n+    public static class FetchCacheRequest extends PFetchCacheRequest {\n+        private String sqlStr;\n+        private List<CacheParam> paramList;\n+\n+        public FetchCacheRequest(String sqlStr) {\n+            this.sqlStr = sqlStr;\n+            this.sql_key = getMd5(this.sqlStr);\n+            this.paramList = Lists.newArrayList();\n+        }\n+\n+        public void addParam(long partitionKey, long lastVersion, long lastVersionTime) {\n+            CacheParam param = new CacheParam(partitionKey, lastVersion, lastVersionTime);\n+            paramList.add(param);\n+        }\n+\n+        public PFetchCacheRequest getRpcRequest() {\n+            PFetchCacheRequest request = new PFetchCacheRequest();\n+            request.param = Lists.newArrayList();\n+            request.sql_key = sql_key;\n+            for (CacheParam param : paramList) {\n+                request.param.add(param.getRParam());\n+            }\n+            return request;\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"fetch cache request, sql_key {}, param count {}\", DebugUtil.printId(sql_key), paramList.size());\n+            for (CacheParam param : paramList) {\n+                param.Debug();\n+            }\n+        }\n+    }\n+\n+    public static class FetchCacheResult extends PFetchCacheResult {\n+        public int all_count;\n+        public int value_count;\n+        public int row_count;\n+        public int data_size;\n+        private List<CacheValue> valueList;\n+\n+        public FetchCacheResult() {\n+            valueList = Lists.newArrayList();\n+            all_count = 0;\n+            value_count = 0;\n+            row_count = 0;\n+            data_size = 0;\n+        }\n+\n+        public List<CacheValue> getValueList() {\n+            return valueList;\n+        }\n+\n+        public void setResult(PFetchCacheResult rpcResult) {\n+            value_count = rpcResult.value.size();\n+            for (int i = 0; i < rpcResult.value.size(); i++) {\n+                PCacheValue rpcValue = rpcResult.value.get(i);\n+                CacheValue value = new CacheValue();\n+                value.addRpcResult(rpcValue);\n+                valueList.add(value);\n+                row_count += value.row.size();\n+                data_size += value.data_size;\n+            }\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"fetch cache result, value size {}\", valueList.size());\n+            for (CacheValue value : valueList) {\n+                value.Debug();\n+            }\n+        }\n+    }\n+\n+    public enum CacheProxyType {\n+        FE,\n+        BE,\n+        OUTER\n+    }\n+\n+    protected CacheProxy(){\n+    }\n+\n+    public static CacheProxy getCacheProxy(CacheProxyType type) {\n+        switch (type) {\n+            case BE:\n+                return new CacheBeProxy();\n+            case FE:\n+            case OUTER:\n+                return null;\n+        }\n+        return null;\n+    }\n+\n+    public abstract void updateCache(UpdateCacheRequest request, Status status);\n+\n+    public abstract FetchCacheResult fetchCache(FetchCacheRequest request, int timeoutMs, Status status);\n+\n+    public abstract void clearCache(PClearCacheRequest clearRequest);\n+\n+\n+    public static PUniqueId getMd5(String str) {\n+        MessageDigest msgDigest;\n+        try {\n+            //128 bit\n+            msgDigest = MessageDigest.getInstance(\"MD5\");\n+        } catch (Exception e) {\n+            return null;\n+        }\n+        final byte[] digest = msgDigest.digest(str.getBytes());\n+        PUniqueId key = new PUniqueId();\n+        key.lo = getLong(digest, 0);//64 bit\n+        key.hi = getLong(digest, 8);//64 bit\n+        return key;\n+    }\n+\n+    public static final long getLong(final byte[] array, final int offset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyNDk3NQ==", "bodyText": "Would better make the 10000 static const value. In the future, we maybe need it to be configurable.", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465424975", "createdAt": "2020-08-05T01:50:07Z", "author": {"login": "kangkaisen"}, "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheBeProxy.java", "diffHunk": "@@ -0,0 +1,167 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.proto.PCacheStatus;\n+import org.apache.doris.proto.PCacheResponse;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PClearType;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.qe.SimpleScheduler;\n+import org.apache.doris.rpc.BackendServiceProxy;\n+import org.apache.doris.rpc.RpcException;\n+import org.apache.doris.system.Backend;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.thrift.TNetworkAddress;\n+\n+import org.apache.doris.thrift.TStatusCode;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.List;\n+\n+/**\n+ * Encapsulates access to BE, including network and other exception handlin\n+ */\n+public class CacheBeProxy extends CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public void updateCache(UpdateCacheRequest request, Status status) {\n+        PUniqueId sqlKey = request.sql_key;\n+        Backend backend = CacheCoordinator.getInstance().findBackend(sqlKey);\n+        if (backend == null) {\n+            LOG.warn(\"update cache can't find backend, sqlKey {}\", sqlKey);\n+            return;\n+        }\n+        TNetworkAddress address = new TNetworkAddress(backend.getHost(), backend.getBrpcPort());\n+        try {\n+            PUpdateCacheRequest updateRequest = request.getRpcRequest();\n+            Future<PCacheResponse> future = BackendServiceProxy.getInstance().updateCache(address, updateRequest);\n+            PCacheResponse response = future.get(10000,TimeUnit.MICROSECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48b1efb950ba3131f4b513b420aeb7354ed006c8", "author": {"user": {"login": "marising", "name": "HaiBo Li"}}, "url": "https://github.com/apache/incubator-doris/commit/48b1efb950ba3131f4b513b420aeb7354ed006c8", "committedDate": "2020-08-05T08:01:16Z", "message": "Adjusted the formatting code, naming and variables according to the comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNzA3MTAx", "url": "https://github.com/apache/incubator-doris/pull/4248#pullrequestreview-461707101", "createdAt": "2020-08-05T14:15:15Z", "commit": {"oid": "48b1efb950ba3131f4b513b420aeb7354ed006c8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2140, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}