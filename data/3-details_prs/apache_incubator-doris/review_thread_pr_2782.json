{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNjM0Nzk1", "number": 2782, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMzoxNDoxN1rODYf4rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxNToxMjozNlrODcqnsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MDE0ODMwOnYy", "diffSide": "RIGHT", "path": "be/src/env/env_posix.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMzoxNDoxN1rOFeY5Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwMDo1NTozNVrOFfMpqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwOTQ2Mg==", "bodyText": "How about change the name to make if different with another new_random_access_file() method?", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r367409462", "createdAt": "2020-01-16T13:14:17Z", "author": {"login": "morningman"}, "path": "be/src/env/env_posix.cpp", "diffHunk": "@@ -498,6 +499,11 @@ class PosixEnv : public Env {\n         return Status::OK();\n     }\n \n+    Status new_random_access_file(const std::string& fname,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7a5b0c62dbc8a1858c6e1ebe278b0b8d824f35"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgxMzM1MQ==", "bodyText": "I think it is just ok, because of overload is common.", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r367813351", "createdAt": "2020-01-17T08:17:00Z", "author": {"login": "kangpinghuang"}, "path": "be/src/env/env_posix.cpp", "diffHunk": "@@ -498,6 +499,11 @@ class PosixEnv : public Env {\n         return Status::OK();\n     }\n \n+    Status new_random_access_file(const std::string& fname,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwOTQ2Mg=="}, "originalCommit": {"oid": "1a7a5b0c62dbc8a1858c6e1ebe278b0b8d824f35"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NzQ1MQ==", "bodyText": "ok, I will add some comments.", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368257451", "createdAt": "2020-01-19T00:55:35Z", "author": {"login": "kangpinghuang"}, "path": "be/src/env/env_posix.cpp", "diffHunk": "@@ -498,6 +499,11 @@ class PosixEnv : public Env {\n         return Status::OK();\n     }\n \n+    Status new_random_access_file(const std::string& fname,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwOTQ2Mg=="}, "originalCommit": {"oid": "1a7a5b0c62dbc8a1858c6e1ebe278b0b8d824f35"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjU5MzcyOnYy", "diffSide": "RIGHT", "path": "be/src/common/config.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNzoxMDoyMFrOFewchQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwODozMTozNVrOFfNvrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5NTMzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                CONF_Int32(file_cache_expiry_period_ms, \"60000\");\n          \n          \n            \n                CONF_Int32(fd_cache_expiry_period_ms, \"60000\");", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r367795333", "createdAt": "2020-01-17T07:10:20Z", "author": {"login": "gaodayue"}, "path": "be/src/common/config.h", "diffHunk": "@@ -221,6 +221,7 @@ namespace config {\n     CONF_Bool(row_nums_check, \"true\")\n     //file descriptors cache, by default, cache 32768 descriptors\n     CONF_Int32(file_descriptor_cache_capacity, \"32768\");\n+    CONF_Int32(file_cache_expiry_period_ms, \"60000\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7a5b0c62dbc8a1858c6e1ebe278b0b8d824f35"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3NTM3NQ==", "bodyText": "done", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368275375", "createdAt": "2020-01-19T08:31:35Z", "author": {"login": "kangpinghuang"}, "path": "be/src/common/config.h", "diffHunk": "@@ -221,6 +221,7 @@ namespace config {\n     CONF_Bool(row_nums_check, \"true\")\n     //file descriptors cache, by default, cache 32768 descriptors\n     CONF_Int32(file_descriptor_cache_capacity, \"32768\");\n+    CONF_Int32(file_cache_expiry_period_ms, \"60000\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5NTMzMw=="}, "originalCommit": {"oid": "1a7a5b0c62dbc8a1858c6e1ebe278b0b8d824f35"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3Mjc3MDY0OnYy", "diffSide": "RIGHT", "path": "be/src/util/file_cache.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwODo0NToyN1rOFeyIsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwODozMTo0NFrOFfNvsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgyMzAyNA==", "bodyText": "what does the TODO mean here?", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r367823024", "createdAt": "2020-01-17T08:45:27Z", "author": {"login": "gaodayue"}, "path": "be/src/util/file_cache.cpp", "diffHunk": "@@ -0,0 +1,416 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/file_cache.h\"\n+\n+#include <atomic>\n+#include <cstdint>\n+#include <cstring>\n+#include <memory>\n+#include <mutex>\n+#include <ostream>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+#include <chrono>\n+#include <functional>\n+\n+#include \"env/env.h\"\n+#include \"gutil/strings/substitute.h\"\n+\n+namespace doris {\n+\n+namespace internal {\n+\n+template <class FileType>\n+class OpenedFileHandle;\n+\n+// Encapsulates common descriptor fields and methods.\n+template <class FileType>\n+class BaseDescriptor {\n+public:\n+    BaseDescriptor(FileCache<FileType>* file_cache, const std::string& filename)\n+        : _file_cache(file_cache), _file_name(filename) { }\n+\n+    ~BaseDescriptor() {\n+        // The (now expired) weak_ptr remains in '_descriptors', to be removed\n+        // by the next call to RunDescriptorExpiry(). Removing it here would\n+        // risk a deadlock on recursive acquisition of '_lock'.\n+\n+        if (deleted()) {\n+            cache()->erase(filename());\n+\n+            WARN_IF_ERROR(env()->delete_file(filename()), \"delete file failed:\");\n+        }\n+    }\n+\n+    // Insert a pointer to an open file object(FileType*) into the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the inserted entry. The handle always contains an\n+    // open file.\n+    OpenedFileHandle<FileType> insert_into_cache(void* file_ptr) const {\n+        // TODO(hkp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b4a8168a3f5aa79480e4c3e4158b5f592c11788"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3NTM3OA==", "bodyText": "remove", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368275378", "createdAt": "2020-01-19T08:31:44Z", "author": {"login": "kangpinghuang"}, "path": "be/src/util/file_cache.cpp", "diffHunk": "@@ -0,0 +1,416 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/file_cache.h\"\n+\n+#include <atomic>\n+#include <cstdint>\n+#include <cstring>\n+#include <memory>\n+#include <mutex>\n+#include <ostream>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+#include <chrono>\n+#include <functional>\n+\n+#include \"env/env.h\"\n+#include \"gutil/strings/substitute.h\"\n+\n+namespace doris {\n+\n+namespace internal {\n+\n+template <class FileType>\n+class OpenedFileHandle;\n+\n+// Encapsulates common descriptor fields and methods.\n+template <class FileType>\n+class BaseDescriptor {\n+public:\n+    BaseDescriptor(FileCache<FileType>* file_cache, const std::string& filename)\n+        : _file_cache(file_cache), _file_name(filename) { }\n+\n+    ~BaseDescriptor() {\n+        // The (now expired) weak_ptr remains in '_descriptors', to be removed\n+        // by the next call to RunDescriptorExpiry(). Removing it here would\n+        // risk a deadlock on recursive acquisition of '_lock'.\n+\n+        if (deleted()) {\n+            cache()->erase(filename());\n+\n+            WARN_IF_ERROR(env()->delete_file(filename()), \"delete file failed:\");\n+        }\n+    }\n+\n+    // Insert a pointer to an open file object(FileType*) into the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the inserted entry. The handle always contains an\n+    // open file.\n+    OpenedFileHandle<FileType> insert_into_cache(void* file_ptr) const {\n+        // TODO(hkp)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgyMzAyNA=="}, "originalCommit": {"oid": "5b4a8168a3f5aa79480e4c3e4158b5f592c11788"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3Mjc3MjEzOnYy", "diffSide": "RIGHT", "path": "be/src/util/file_cache.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwODo0NjoxMVrOFeyJrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwODozMjowMlrOFfNvxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgyMzI3Ng==", "bodyText": "The third argument should be 1, since cache's capacity is set to max_open_files.", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r367823276", "createdAt": "2020-01-17T08:46:11Z", "author": {"login": "gaodayue"}, "path": "be/src/util/file_cache.cpp", "diffHunk": "@@ -0,0 +1,416 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/file_cache.h\"\n+\n+#include <atomic>\n+#include <cstdint>\n+#include <cstring>\n+#include <memory>\n+#include <mutex>\n+#include <ostream>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+#include <chrono>\n+#include <functional>\n+\n+#include \"env/env.h\"\n+#include \"gutil/strings/substitute.h\"\n+\n+namespace doris {\n+\n+namespace internal {\n+\n+template <class FileType>\n+class OpenedFileHandle;\n+\n+// Encapsulates common descriptor fields and methods.\n+template <class FileType>\n+class BaseDescriptor {\n+public:\n+    BaseDescriptor(FileCache<FileType>* file_cache, const std::string& filename)\n+        : _file_cache(file_cache), _file_name(filename) { }\n+\n+    ~BaseDescriptor() {\n+        // The (now expired) weak_ptr remains in '_descriptors', to be removed\n+        // by the next call to RunDescriptorExpiry(). Removing it here would\n+        // risk a deadlock on recursive acquisition of '_lock'.\n+\n+        if (deleted()) {\n+            cache()->erase(filename());\n+\n+            WARN_IF_ERROR(env()->delete_file(filename()), \"delete file failed:\");\n+        }\n+    }\n+\n+    // Insert a pointer to an open file object(FileType*) into the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the inserted entry. The handle always contains an\n+    // open file.\n+    OpenedFileHandle<FileType> insert_into_cache(void* file_ptr) const {\n+        // TODO(hkp)\n+        auto deleter = [](const doris::CacheKey& key, void* value) {\n+            delete (FileType*)value;\n+        };\n+        FileType* file = reinterpret_cast<FileType*>(file_ptr);\n+        CacheKey key(file->file_name());\n+        auto lru_handle = cache()->insert(key, file_ptr, sizeof(file_ptr), deleter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b4a8168a3f5aa79480e4c3e4158b5f592c11788"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3NTM5OQ==", "bodyText": "done", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368275399", "createdAt": "2020-01-19T08:32:02Z", "author": {"login": "kangpinghuang"}, "path": "be/src/util/file_cache.cpp", "diffHunk": "@@ -0,0 +1,416 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/file_cache.h\"\n+\n+#include <atomic>\n+#include <cstdint>\n+#include <cstring>\n+#include <memory>\n+#include <mutex>\n+#include <ostream>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+#include <chrono>\n+#include <functional>\n+\n+#include \"env/env.h\"\n+#include \"gutil/strings/substitute.h\"\n+\n+namespace doris {\n+\n+namespace internal {\n+\n+template <class FileType>\n+class OpenedFileHandle;\n+\n+// Encapsulates common descriptor fields and methods.\n+template <class FileType>\n+class BaseDescriptor {\n+public:\n+    BaseDescriptor(FileCache<FileType>* file_cache, const std::string& filename)\n+        : _file_cache(file_cache), _file_name(filename) { }\n+\n+    ~BaseDescriptor() {\n+        // The (now expired) weak_ptr remains in '_descriptors', to be removed\n+        // by the next call to RunDescriptorExpiry(). Removing it here would\n+        // risk a deadlock on recursive acquisition of '_lock'.\n+\n+        if (deleted()) {\n+            cache()->erase(filename());\n+\n+            WARN_IF_ERROR(env()->delete_file(filename()), \"delete file failed:\");\n+        }\n+    }\n+\n+    // Insert a pointer to an open file object(FileType*) into the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the inserted entry. The handle always contains an\n+    // open file.\n+    OpenedFileHandle<FileType> insert_into_cache(void* file_ptr) const {\n+        // TODO(hkp)\n+        auto deleter = [](const doris::CacheKey& key, void* value) {\n+            delete (FileType*)value;\n+        };\n+        FileType* file = reinterpret_cast<FileType*>(file_ptr);\n+        CacheKey key(file->file_name());\n+        auto lru_handle = cache()->insert(key, file_ptr, sizeof(file_ptr), deleter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgyMzI3Ng=="}, "originalCommit": {"oid": "5b4a8168a3f5aa79480e4c3e4158b5f592c11788"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3Mjc3NTU5OnYy", "diffSide": "RIGHT", "path": "be/src/util/file_cache.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwODo0NzoyOFrOFeyLtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwODozMTo1M1rOFfNvwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgyMzc5Nw==", "bodyText": "what does the TODO mean?", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r367823797", "createdAt": "2020-01-17T08:47:28Z", "author": {"login": "gaodayue"}, "path": "be/src/util/file_cache.cpp", "diffHunk": "@@ -0,0 +1,416 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/file_cache.h\"\n+\n+#include <atomic>\n+#include <cstdint>\n+#include <cstring>\n+#include <memory>\n+#include <mutex>\n+#include <ostream>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+#include <chrono>\n+#include <functional>\n+\n+#include \"env/env.h\"\n+#include \"gutil/strings/substitute.h\"\n+\n+namespace doris {\n+\n+namespace internal {\n+\n+template <class FileType>\n+class OpenedFileHandle;\n+\n+// Encapsulates common descriptor fields and methods.\n+template <class FileType>\n+class BaseDescriptor {\n+public:\n+    BaseDescriptor(FileCache<FileType>* file_cache, const std::string& filename)\n+        : _file_cache(file_cache), _file_name(filename) { }\n+\n+    ~BaseDescriptor() {\n+        // The (now expired) weak_ptr remains in '_descriptors', to be removed\n+        // by the next call to RunDescriptorExpiry(). Removing it here would\n+        // risk a deadlock on recursive acquisition of '_lock'.\n+\n+        if (deleted()) {\n+            cache()->erase(filename());\n+\n+            WARN_IF_ERROR(env()->delete_file(filename()), \"delete file failed:\");\n+        }\n+    }\n+\n+    // Insert a pointer to an open file object(FileType*) into the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the inserted entry. The handle always contains an\n+    // open file.\n+    OpenedFileHandle<FileType> insert_into_cache(void* file_ptr) const {\n+        // TODO(hkp)\n+        auto deleter = [](const doris::CacheKey& key, void* value) {\n+            delete (FileType*)value;\n+        };\n+        FileType* file = reinterpret_cast<FileType*>(file_ptr);\n+        CacheKey key(file->file_name());\n+        auto lru_handle = cache()->insert(key, file_ptr, sizeof(file_ptr), deleter);\n+        return OpenedFileHandle<FileType>(this, lru_handle);\n+    }\n+\n+    // Retrieves a pointer to an open file object from the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the looked up entry. The handle may or may not\n+    // contain an open file, depending on whether the cache hit or missed.\n+    OpenedFileHandle<FileType> lookup_from_cache() const {\n+        // TODO(hkp): use lru_cache to replace", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b4a8168a3f5aa79480e4c3e4158b5f592c11788"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3NTM5Mg==", "bodyText": "remove", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368275392", "createdAt": "2020-01-19T08:31:53Z", "author": {"login": "kangpinghuang"}, "path": "be/src/util/file_cache.cpp", "diffHunk": "@@ -0,0 +1,416 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/file_cache.h\"\n+\n+#include <atomic>\n+#include <cstdint>\n+#include <cstring>\n+#include <memory>\n+#include <mutex>\n+#include <ostream>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+#include <chrono>\n+#include <functional>\n+\n+#include \"env/env.h\"\n+#include \"gutil/strings/substitute.h\"\n+\n+namespace doris {\n+\n+namespace internal {\n+\n+template <class FileType>\n+class OpenedFileHandle;\n+\n+// Encapsulates common descriptor fields and methods.\n+template <class FileType>\n+class BaseDescriptor {\n+public:\n+    BaseDescriptor(FileCache<FileType>* file_cache, const std::string& filename)\n+        : _file_cache(file_cache), _file_name(filename) { }\n+\n+    ~BaseDescriptor() {\n+        // The (now expired) weak_ptr remains in '_descriptors', to be removed\n+        // by the next call to RunDescriptorExpiry(). Removing it here would\n+        // risk a deadlock on recursive acquisition of '_lock'.\n+\n+        if (deleted()) {\n+            cache()->erase(filename());\n+\n+            WARN_IF_ERROR(env()->delete_file(filename()), \"delete file failed:\");\n+        }\n+    }\n+\n+    // Insert a pointer to an open file object(FileType*) into the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the inserted entry. The handle always contains an\n+    // open file.\n+    OpenedFileHandle<FileType> insert_into_cache(void* file_ptr) const {\n+        // TODO(hkp)\n+        auto deleter = [](const doris::CacheKey& key, void* value) {\n+            delete (FileType*)value;\n+        };\n+        FileType* file = reinterpret_cast<FileType*>(file_ptr);\n+        CacheKey key(file->file_name());\n+        auto lru_handle = cache()->insert(key, file_ptr, sizeof(file_ptr), deleter);\n+        return OpenedFileHandle<FileType>(this, lru_handle);\n+    }\n+\n+    // Retrieves a pointer to an open file object from the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the looked up entry. The handle may or may not\n+    // contain an open file, depending on whether the cache hit or missed.\n+    OpenedFileHandle<FileType> lookup_from_cache() const {\n+        // TODO(hkp): use lru_cache to replace", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgyMzc5Nw=="}, "originalCommit": {"oid": "5b4a8168a3f5aa79480e4c3e4158b5f592c11788"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTc4NTYxOnYy", "diffSide": "RIGHT", "path": "be/src/common/config.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwOToyMzowOFrOFfN7-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwOToyMzowOFrOFfN7-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3ODUyMQ==", "bodyText": "I think second is enough", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368278521", "createdAt": "2020-01-19T09:23:08Z", "author": {"login": "imay"}, "path": "be/src/common/config.h", "diffHunk": "@@ -221,6 +221,7 @@ namespace config {\n     CONF_Bool(row_nums_check, \"true\")\n     //file descriptors cache, by default, cache 32768 descriptors\n     CONF_Int32(file_descriptor_cache_capacity, \"32768\");\n+    CONF_Int32(fd_cache_expiry_period_ms, \"60000\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18db99c1c49302561884e8c530782fb59d47390"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTc4NzM5OnYy", "diffSide": "RIGHT", "path": "be/src/env/env.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwOToyNzoxN1rOFfN86w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwOToyNzoxN1rOFfN86w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3ODc2Mw==", "bodyText": "I think this function is not necessary, the above function can achieve your purpose.\nstd::unique_ptr<RandomAccessFile> file;\nnew_random_access_file(opts, fname, &file);\nstd::shared_ptr<RandomAccessFile> shared_file(file.release());\n\nAnd this is not a good way to make file cache in this env. Need to let the caller decide whether to cache.", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368278763", "createdAt": "2020-01-19T09:27:17Z", "author": {"login": "imay"}, "path": "be/src/env/env.h", "diffHunk": "@@ -73,6 +76,9 @@ class Env {\n                                           const std::string& fname,\n                                           std::unique_ptr<RandomAccessFile>* result) = 0;\n \n+    virtual Status new_random_access_file(const std::string& fname,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18db99c1c49302561884e8c530782fb59d47390"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTc4ODUxOnYy", "diffSide": "RIGHT", "path": "be/src/util/file_cache.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwOTozMDoxNFrOFfN9jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwODo1NjoxMFrOFfXEpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3ODkyNQ==", "bodyText": "should add some UT for this new added class.", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368278925", "createdAt": "2020-01-19T09:30:14Z", "author": {"login": "imay"}, "path": "be/src/util/file_cache.h", "diffHunk": "@@ -0,0 +1,316 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <condition_variable>\n+#include <mutex>\n+#include <thread>\n+\n+#include \"common/status.h\"\n+#include \"env/env.h\"\n+#include \"util/spinlock.h\"\n+#include \"util/once.h\"\n+#include \"olap/lru_cache.h\"\n+\n+namespace doris {\n+\n+class Env;\n+\n+template <class FileType>\n+class FileCache;\n+\n+template <class FileType>\n+class OpenedFileHandle;\n+\n+namespace internal {\n+\n+template <class FileType>\n+class Descriptor;\n+\n+} // namespace internal\n+\n+// Encapsulates common descriptor fields and methods.\n+template <class FileType>\n+class BaseDescriptor {\n+public:\n+    BaseDescriptor(FileCache<FileType>* file_cache, const std::string& filename)\n+        : _file_cache(file_cache), _file_name(filename) { }\n+\n+    ~BaseDescriptor() {\n+        // The (now expired) weak_ptr remains in '_descriptors', to be removed\n+        // by the next call to RunDescriptorExpiry(). Removing it here would\n+        // risk a deadlock on recursive acquisition of '_lock'.\n+\n+        if (deleted()) {\n+            cache()->erase(filename());\n+\n+            WARN_IF_ERROR(env()->delete_file(filename()), \"delete file failed:\");\n+        }\n+    }\n+\n+    // Insert a pointer to an open file object(FileType*) into the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the inserted entry. The handle always contains an\n+    // open file.\n+    OpenedFileHandle<FileType> insert_into_cache(void* file_ptr) const {\n+        auto deleter = [](const doris::CacheKey& key, void* value) {\n+            delete (FileType*)value;\n+        };\n+        FileType* file = reinterpret_cast<FileType*>(file_ptr);\n+        CacheKey key(file->file_name());\n+        auto lru_handle = cache()->insert(key, file_ptr, 1, deleter);\n+        return OpenedFileHandle<FileType>(this, lru_handle);\n+    }\n+\n+    // Retrieves a pointer to an open file object from the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the looked up entry. The handle may or may not\n+    // contain an open file, depending on whether the cache hit or missed.\n+    OpenedFileHandle<FileType> lookup_from_cache() const {\n+        CacheKey key(filename());\n+        return OpenedFileHandle<FileType>(this, cache()->lookup(key));\n+    }\n+\n+    // Mark this descriptor as to-be-deleted later.\n+    void mark_deleted() {\n+        DCHECK(!deleted());\n+        while (true) {\n+            auto v = _flags.load();\n+            if (_flags.compare_exchange_weak(v, v | FILE_DELETED)) return;\n+        }\n+    }\n+\n+    // Mark this descriptor as invalidated. No further access is allowed\n+    // to this file.\n+    void mark_invalidated() {\n+        DCHECK(!invalidated());\n+        while (true) {\n+            auto v = _flags.load();\n+            if (_flags.compare_exchange_weak(v, v | INVALIDATED)) return;\n+        }\n+    }\n+\n+    Cache* cache() const { return _file_cache->_cache.get(); }\n+\n+    Env* env() const { return _file_cache->_env; }\n+\n+    const std::string& filename() const { return _file_name; }\n+\n+    bool deleted() const { return _flags.load() & FILE_DELETED; }\n+    bool invalidated() const { return _flags.load() & INVALIDATED; }\n+\n+private:\n+    FileCache<FileType>* _file_cache;\n+    std::string _file_name;\n+    enum Flags { FILE_DELETED = 1 << 0, INVALIDATED = 1 << 1 };\n+    std::atomic<uint8_t> _flags{0};\n+\n+    DISALLOW_COPY_AND_ASSIGN(BaseDescriptor);\n+};\n+\n+// A \"smart\" retrieved LRU cache handle.\n+//\n+// The cache handle is released when this object goes out of scope, possibly\n+// closing the opened file if it is no longer in the cache.\n+template <class FileType>\n+class OpenedFileHandle {\n+public:\n+    // A not-yet-but-soon-to-be opened descriptor.\n+    explicit OpenedFileHandle(const BaseDescriptor<FileType>* desc)\n+        : _desc(desc), _handle(nullptr) { }\n+\n+    // An opened descriptor. Its handle may or may not contain an open file.\n+    OpenedFileHandle(const BaseDescriptor<FileType>* desc,\n+                     Cache::Handle* handle) : _desc(desc), _handle(handle) { }\n+\n+    ~OpenedFileHandle() {\n+        if (_handle != nullptr) {\n+            _desc->cache()->release(_handle);\n+        }\n+    }\n+\n+    OpenedFileHandle(OpenedFileHandle&& other) noexcept {\n+        std::swap(_desc, other._desc);\n+        std::swap(_handle, other._handle);\n+    }\n+\n+    OpenedFileHandle& operator=(OpenedFileHandle&& other) noexcept {\n+        std::swap(_desc, other._desc);\n+        std::swap(_handle, other._handle);\n+        return *this;\n+    }\n+\n+    bool opened() {\n+        return _handle != nullptr;\n+    }\n+\n+    FileType* file() const {\n+        DCHECK(_handle != nullptr);\n+        return reinterpret_cast<FileType*>(_desc->cache()->value(_handle));\n+    }\n+\n+private:\n+    const BaseDescriptor<FileType>* _desc;\n+    Cache::Handle* _handle;\n+};\n+\n+// Cache of open files.\n+//\n+// The purpose of this cache is to enforce an upper bound on the maximum number\n+// of files open at a time. Files opened through the cache may be closed at any\n+// time, only to be reopened upon next use.\n+//\n+// The file cache can be viewed as having two logical parts: the client-facing\n+// API and the LRU cache.\n+//\n+// Client-facing API\n+// -----------------\n+// The core of the client-facing API is the cache descriptor. A descriptor\n+// uniquely identifies an opened file. To a client, a descriptor is just an\n+// open file interface of the variety defined in util/env.h. Clients open\n+// descriptors via the OpenExistingFile() cache method.\n+//\n+// Descriptors are shared objects; an existing descriptor is handed back to a\n+// client if a file with the same name is already opened. To facilitate\n+// descriptor sharing, the file cache maintains a by-file-name descriptor map.\n+// The values are weak references to the descriptors so that map entries don't\n+// affect the descriptor lifecycle.\n+//\n+// LRU cache\n+// ---------\n+// The lower half of the file cache is a standard LRU cache whose keys are file\n+// names and whose values are pointers to opened file objects allocated on the\n+// heap. Unlike the descriptor map, this cache has an upper bound on capacity,\n+// and handles are evicted (and closed) according to an LRU algorithm.\n+//\n+// Whenever a descriptor is used by a client in file I/O, its file name is used\n+// in an LRU cache lookup. If found, the underlying file is still open and the\n+// file access is performed. Otherwise, the file must have been evicted and\n+// closed, so it is reopened and reinserted (possibly evicting a different open\n+// file) before the file access is performed.\n+//\n+// Other notes\n+// -----------\n+// In a world where files are opened and closed transparently, file deletion\n+// demands special care if UNIX semantics are to be preserved. When a call to\n+// DeleteFile() is made to a file with an opened descriptor, the descriptor is\n+// simply \"marked\" as to-be-deleted-later. Only when all references to the\n+// descriptor are dropped is the file actually deleted. If there is no open\n+// descriptor, the file is deleted immediately.\n+//\n+// Every public method in the file cache is thread safe.\n+template <class FileType>\n+class FileCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18db99c1c49302561884e8c530782fb59d47390"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQyODE5OA==", "bodyText": "done", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368428198", "createdAt": "2020-01-20T08:56:10Z", "author": {"login": "kangpinghuang"}, "path": "be/src/util/file_cache.h", "diffHunk": "@@ -0,0 +1,316 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <condition_variable>\n+#include <mutex>\n+#include <thread>\n+\n+#include \"common/status.h\"\n+#include \"env/env.h\"\n+#include \"util/spinlock.h\"\n+#include \"util/once.h\"\n+#include \"olap/lru_cache.h\"\n+\n+namespace doris {\n+\n+class Env;\n+\n+template <class FileType>\n+class FileCache;\n+\n+template <class FileType>\n+class OpenedFileHandle;\n+\n+namespace internal {\n+\n+template <class FileType>\n+class Descriptor;\n+\n+} // namespace internal\n+\n+// Encapsulates common descriptor fields and methods.\n+template <class FileType>\n+class BaseDescriptor {\n+public:\n+    BaseDescriptor(FileCache<FileType>* file_cache, const std::string& filename)\n+        : _file_cache(file_cache), _file_name(filename) { }\n+\n+    ~BaseDescriptor() {\n+        // The (now expired) weak_ptr remains in '_descriptors', to be removed\n+        // by the next call to RunDescriptorExpiry(). Removing it here would\n+        // risk a deadlock on recursive acquisition of '_lock'.\n+\n+        if (deleted()) {\n+            cache()->erase(filename());\n+\n+            WARN_IF_ERROR(env()->delete_file(filename()), \"delete file failed:\");\n+        }\n+    }\n+\n+    // Insert a pointer to an open file object(FileType*) into the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the inserted entry. The handle always contains an\n+    // open file.\n+    OpenedFileHandle<FileType> insert_into_cache(void* file_ptr) const {\n+        auto deleter = [](const doris::CacheKey& key, void* value) {\n+            delete (FileType*)value;\n+        };\n+        FileType* file = reinterpret_cast<FileType*>(file_ptr);\n+        CacheKey key(file->file_name());\n+        auto lru_handle = cache()->insert(key, file_ptr, 1, deleter);\n+        return OpenedFileHandle<FileType>(this, lru_handle);\n+    }\n+\n+    // Retrieves a pointer to an open file object from the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the looked up entry. The handle may or may not\n+    // contain an open file, depending on whether the cache hit or missed.\n+    OpenedFileHandle<FileType> lookup_from_cache() const {\n+        CacheKey key(filename());\n+        return OpenedFileHandle<FileType>(this, cache()->lookup(key));\n+    }\n+\n+    // Mark this descriptor as to-be-deleted later.\n+    void mark_deleted() {\n+        DCHECK(!deleted());\n+        while (true) {\n+            auto v = _flags.load();\n+            if (_flags.compare_exchange_weak(v, v | FILE_DELETED)) return;\n+        }\n+    }\n+\n+    // Mark this descriptor as invalidated. No further access is allowed\n+    // to this file.\n+    void mark_invalidated() {\n+        DCHECK(!invalidated());\n+        while (true) {\n+            auto v = _flags.load();\n+            if (_flags.compare_exchange_weak(v, v | INVALIDATED)) return;\n+        }\n+    }\n+\n+    Cache* cache() const { return _file_cache->_cache.get(); }\n+\n+    Env* env() const { return _file_cache->_env; }\n+\n+    const std::string& filename() const { return _file_name; }\n+\n+    bool deleted() const { return _flags.load() & FILE_DELETED; }\n+    bool invalidated() const { return _flags.load() & INVALIDATED; }\n+\n+private:\n+    FileCache<FileType>* _file_cache;\n+    std::string _file_name;\n+    enum Flags { FILE_DELETED = 1 << 0, INVALIDATED = 1 << 1 };\n+    std::atomic<uint8_t> _flags{0};\n+\n+    DISALLOW_COPY_AND_ASSIGN(BaseDescriptor);\n+};\n+\n+// A \"smart\" retrieved LRU cache handle.\n+//\n+// The cache handle is released when this object goes out of scope, possibly\n+// closing the opened file if it is no longer in the cache.\n+template <class FileType>\n+class OpenedFileHandle {\n+public:\n+    // A not-yet-but-soon-to-be opened descriptor.\n+    explicit OpenedFileHandle(const BaseDescriptor<FileType>* desc)\n+        : _desc(desc), _handle(nullptr) { }\n+\n+    // An opened descriptor. Its handle may or may not contain an open file.\n+    OpenedFileHandle(const BaseDescriptor<FileType>* desc,\n+                     Cache::Handle* handle) : _desc(desc), _handle(handle) { }\n+\n+    ~OpenedFileHandle() {\n+        if (_handle != nullptr) {\n+            _desc->cache()->release(_handle);\n+        }\n+    }\n+\n+    OpenedFileHandle(OpenedFileHandle&& other) noexcept {\n+        std::swap(_desc, other._desc);\n+        std::swap(_handle, other._handle);\n+    }\n+\n+    OpenedFileHandle& operator=(OpenedFileHandle&& other) noexcept {\n+        std::swap(_desc, other._desc);\n+        std::swap(_handle, other._handle);\n+        return *this;\n+    }\n+\n+    bool opened() {\n+        return _handle != nullptr;\n+    }\n+\n+    FileType* file() const {\n+        DCHECK(_handle != nullptr);\n+        return reinterpret_cast<FileType*>(_desc->cache()->value(_handle));\n+    }\n+\n+private:\n+    const BaseDescriptor<FileType>* _desc;\n+    Cache::Handle* _handle;\n+};\n+\n+// Cache of open files.\n+//\n+// The purpose of this cache is to enforce an upper bound on the maximum number\n+// of files open at a time. Files opened through the cache may be closed at any\n+// time, only to be reopened upon next use.\n+//\n+// The file cache can be viewed as having two logical parts: the client-facing\n+// API and the LRU cache.\n+//\n+// Client-facing API\n+// -----------------\n+// The core of the client-facing API is the cache descriptor. A descriptor\n+// uniquely identifies an opened file. To a client, a descriptor is just an\n+// open file interface of the variety defined in util/env.h. Clients open\n+// descriptors via the OpenExistingFile() cache method.\n+//\n+// Descriptors are shared objects; an existing descriptor is handed back to a\n+// client if a file with the same name is already opened. To facilitate\n+// descriptor sharing, the file cache maintains a by-file-name descriptor map.\n+// The values are weak references to the descriptors so that map entries don't\n+// affect the descriptor lifecycle.\n+//\n+// LRU cache\n+// ---------\n+// The lower half of the file cache is a standard LRU cache whose keys are file\n+// names and whose values are pointers to opened file objects allocated on the\n+// heap. Unlike the descriptor map, this cache has an upper bound on capacity,\n+// and handles are evicted (and closed) according to an LRU algorithm.\n+//\n+// Whenever a descriptor is used by a client in file I/O, its file name is used\n+// in an LRU cache lookup. If found, the underlying file is still open and the\n+// file access is performed. Otherwise, the file must have been evicted and\n+// closed, so it is reopened and reinserted (possibly evicting a different open\n+// file) before the file access is performed.\n+//\n+// Other notes\n+// -----------\n+// In a world where files are opened and closed transparently, file deletion\n+// demands special care if UNIX semantics are to be preserved. When a call to\n+// DeleteFile() is made to a file with an opened descriptor, the descriptor is\n+// simply \"marked\" as to-be-deleted-later. Only when all references to the\n+// descriptor are dropped is the file actually deleted. If there is no open\n+// descriptor, the file is deleted immediately.\n+//\n+// Every public method in the file cache is thread safe.\n+template <class FileType>\n+class FileCache {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3ODkyNQ=="}, "originalCommit": {"oid": "d18db99c1c49302561884e8c530782fb59d47390"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjc1NzIwOnYy", "diffSide": "RIGHT", "path": "be/src/olap/rowset/segment_v2/bitmap_index_reader.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOToxMzowOFrOFkqf5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOToxMzowOFrOFkqf5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk4OTM0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                explicit BitmapIndexReader(const std::string file_name,\n          \n          \n            \n                explicit BitmapIndexReader(const std::string& file_name,", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r373989349", "createdAt": "2020-02-03T09:13:08Z", "author": {"login": "imay"}, "path": "be/src/olap/rowset/segment_v2/bitmap_index_reader.h", "diffHunk": "@@ -40,9 +40,9 @@ class IndexedColumnIterator;\n \n class BitmapIndexReader {\n public:\n-    explicit BitmapIndexReader(RandomAccessFile* file,\n+    explicit BitmapIndexReader(const std::string file_name,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjc5MTQ0OnYy", "diffSide": "RIGHT", "path": "be/src/util/file_cache.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOToyNDo1OVrOFkq0Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOToyNDo1OVrOFkq0Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5NDUzNA==", "bodyText": "Is OpenedFileCache better?", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r373994534", "createdAt": "2020-02-03T09:24:59Z", "author": {"login": "imay"}, "path": "be/src/util/file_cache.h", "diffHunk": "@@ -0,0 +1,129 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"olap/lru_cache.h\"\n+\n+namespace doris {\n+\n+class Env;\n+\n+// A \"smart\" retrieved LRU cache handle.\n+//\n+// The cache handle is released when this object goes out of scope, possibly\n+// closing the opened file if it is no longer in the cache.\n+template <class FileType>\n+class OpenedFileHandle {\n+public:\n+    OpenedFileHandle() : _cache(nullptr), _handle(nullptr) { }\n+\n+    // A opened file handle\n+    explicit OpenedFileHandle(Cache* cache, Cache::Handle* handle)\n+        : _cache(cache), _handle(handle) { }\n+\n+    // release cache handle\n+    ~OpenedFileHandle() {\n+        if (_handle != nullptr) {\n+            _cache->release(_handle);\n+        }\n+    }\n+\n+    OpenedFileHandle(OpenedFileHandle&& other) noexcept {\n+        std::swap(_cache, other._cache);\n+        std::swap(_handle, other._handle);\n+    }\n+\n+    OpenedFileHandle& operator=(OpenedFileHandle&& other) noexcept {\n+        std::swap(_cache, other._cache);\n+        std::swap(_handle, other._handle);\n+        return *this;\n+    }\n+\n+    FileType* file() const {\n+        DCHECK(_handle != nullptr);\n+        return reinterpret_cast<FileType*>(_cache->value(_handle));\n+    }\n+\n+private:\n+    Cache* _cache;\n+    Cache::Handle* _handle;\n+};\n+\n+// Cache of open files.\n+//\n+// The purpose of this cache is to enforce an upper bound on the maximum number\n+// of files open at a time. Files opened through the cache may be closed at any\n+// time, only to be reopened upon next use.\n+//\n+// The file cache can be viewed as having two logical parts: the client-facing\n+// File handle and the LRU cache.\n+//\n+// Client-facing API\n+// -----------------\n+// The core of the client-facing API is the cache descriptor. A descriptor\n+\n+// LRU cache\n+// ---------\n+// The lower half of the file cache is a standard LRU cache whose keys are file\n+// names and whose values are pointers to opened file objects allocated on the\n+// heap. Unlike the descriptor map, this cache has an upper bound on capacity,\n+// and handles are evicted (and closed) according to an LRU algorithm.\n+//\n+// Whenever a descriptor is used by a client in file I/O, its file name is used\n+// in an LRU cache lookup. If found, the underlying file is still open and the\n+// file access is performed. Otherwise, the file must have been evicted and\n+// closed, so it is reopened and reinserted (possibly evicting a different open\n+// file) before the file access is performed.\n+//\n+// Every public method in the file cache is thread safe.\n+template <class FileType>\n+class FileCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjgwNjU2OnYy", "diffSide": "RIGHT", "path": "be/src/olap/rowset/segment_v2/segment_iterator.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOToyOTo1MlrOFkq9FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOToyOTo1MlrOFkq9FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5NjgyMQ==", "bodyText": "Why not use OpenedFileHandle directly?", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r373996821", "createdAt": "2020-02-03T09:29:52Z", "author": {"login": "imay"}, "path": "be/src/olap/rowset/segment_v2/segment_iterator.h", "diffHunk": "@@ -120,6 +121,9 @@ class SegmentIterator : public RowwiseIterator {\n     // used to binary search the rowid for a given key\n     // only used in `_get_row_ranges_by_keys`\n     std::unique_ptr<RowBlockV2> _seek_block;\n+\n+    // Handle for file to read\n+    std::unique_ptr<OpenedFileHandle<RandomAccessFile>> _file_handle;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjgxNTU2OnYy", "diffSide": "RIGHT", "path": "be/src/olap/rowset/segment_v2/indexed_column_reader.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOTozMjo0OFrOFkrChQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOTozMjo0OFrOFkrChQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5ODIxMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                RandomAccessFile* _file;\n          \n          \n            \n                RandomAccessFile* _file = nullptr;", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r373998213", "createdAt": "2020-02-03T09:32:48Z", "author": {"login": "imay"}, "path": "be/src/olap/rowset/segment_v2/indexed_column_reader.h", "diffHunk": "@@ -131,6 +140,10 @@ class IndexedColumnIterator {\n     std::unique_ptr<ParsedPage> _data_page;\n     // next_batch() will read from this position\n     rowid_t _current_rowid = 0;\n+    // open file handle\n+    std::unique_ptr<OpenedFileHandle<RandomAccessFile>> _file_handle;\n+    // file to read\n+    RandomAccessFile* _file;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjgxNjAxOnYy", "diffSide": "RIGHT", "path": "be/src/olap/rowset/segment_v2/indexed_column_reader.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOTozMjo1NVrOFkrCww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOTozMjo1NVrOFkrCww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5ODI3NQ==", "bodyText": "Use OpenedFileHandle directly?", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r373998275", "createdAt": "2020-02-03T09:32:55Z", "author": {"login": "imay"}, "path": "be/src/olap/rowset/segment_v2/indexed_column_reader.h", "diffHunk": "@@ -131,6 +140,10 @@ class IndexedColumnIterator {\n     std::unique_ptr<ParsedPage> _data_page;\n     // next_batch() will read from this position\n     rowid_t _current_rowid = 0;\n+    // open file handle\n+    std::unique_ptr<OpenedFileHandle<RandomAccessFile>> _file_handle;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjgxNjcwOnYy", "diffSide": "RIGHT", "path": "be/src/olap/rowset/segment_v2/indexed_column_reader.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOTozMzowOFrOFkrDKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOTozMzowOFrOFkrDKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5ODM3OQ==", "bodyText": "use OpenedFileHandle directly?", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r373998379", "createdAt": "2020-02-03T09:33:08Z", "author": {"login": "imay"}, "path": "be/src/olap/rowset/segment_v2/indexed_column_reader.h", "diffHunk": "@@ -131,6 +140,10 @@ class IndexedColumnIterator {\n     std::unique_ptr<ParsedPage> _data_page;\n     // next_batch() will read from this position\n     rowid_t _current_rowid = 0;\n+    // open file handle\n+    std::unique_ptr<OpenedFileHandle<RandomAccessFile>> _file_handle;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjg5MTU4OnYy", "diffSide": "RIGHT", "path": "be/src/env/env.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOTo1NTozN1rOFkru4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOTo1NTozN1rOFkru4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDAwOTU3MQ==", "bodyText": "is it useful?", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r374009571", "createdAt": "2020-02-03T09:55:37Z", "author": {"login": "imay"}, "path": "be/src/env/env.h", "diffHunk": "@@ -230,6 +233,12 @@ class RandomAccessFile {\n     RandomAccessFile() { }\n     virtual ~RandomAccessFile() { }\n \n+    // get the cache handle of file\n+    // only realized for file in cache\n+    virtual Status file_handle(std::unique_ptr<OpenedFileHandle<RandomAccessFile>>* file) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzg1MDA4OnYy", "diffSide": "RIGHT", "path": "be/src/env/env.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxNToxMjozNlrOFk0xdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxNToxMjozNlrOFk0xdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE1NzY4Nw==", "bodyText": "useless", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r374157687", "createdAt": "2020-02-03T15:12:36Z", "author": {"login": "imay"}, "path": "be/src/env/env.h", "diffHunk": "@@ -25,6 +25,9 @@ class WritableFileOptions;\n class RandomAccessFileOptions;\n class RandomRWFileOptions;\n \n+template <class FileType>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450e16613032a2dfcd5ea983109d11d5b01293ea"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2139, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}