{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNjU2NzEz", "number": 3278, "title": "Optimzie where cluase when have duplicate ors", "bodyText": "improve performent describe in #3245\nfor example sql\nselect\n   avg(ss_quantity),\n   avg(ss_ext_sales_price),\n   avg(ss_ext_wholesale_cost),\n   sum(ss_ext_wholesale_cost)\nfrom\n   store_sales,\n   customer_address\nwhere\n   (\n      (\n         ss_addr_sk = ca_address_sk\n         and ca_country = 'United States'\n         and ca_state in ('CO', 'IL', 'MN')\n         and ss_net_profit between 100\n         and 200\n      )\n      or (\n         ss_addr_sk = ca_address_sk\n         and ca_country = 'United States'\n         and ca_state in ('OH', 'MT', 'NM')\n         and ss_net_profit between 150\n         and 300\n      )\n      or (\n         ss_addr_sk = ca_address_sk\n         and ca_country = 'United States'\n         and ca_state in ('TX', 'MO', 'MI')\n         and ss_net_profit between 50\n         and 250\n      )\n   )\n\nnow can be finished in 20s", "createdAt": "2020-04-08T06:36:02Z", "url": "https://github.com/apache/incubator-doris/pull/3278", "merged": true, "mergeCommit": {"oid": "8699bb7bd47033c6dd5db3e9021ef3cc5d324f63"}, "closed": true, "closedAt": "2020-04-09T13:57:46Z", "author": {"login": "yangzhg"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcViBxcABqjMyMTI3MTkzMjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcV84amgFqTM5MDgxMzgwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e28e4c876ebd65d8e3458157cc0450ec19e09fa", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/3e28e4c876ebd65d8e3458157cc0450ec19e09fa", "committedDate": "2020-04-08T06:28:35Z", "message": "optimize duplicated ors"}, "afterCommit": {"oid": "411a43e8f53435d2bb86999f5b66bf43476eb4d2", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/411a43e8f53435d2bb86999f5b66bf43476eb4d2", "committedDate": "2020-04-08T06:37:00Z", "message": "optimize duplicated ors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/865e7124da66e3a956dffba1d40be4cb550048ba", "committedDate": "2020-04-08T07:56:43Z", "message": "optimize duplicated ors"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "411a43e8f53435d2bb86999f5b66bf43476eb4d2", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/411a43e8f53435d2bb86999f5b66bf43476eb4d2", "committedDate": "2020-04-08T06:37:00Z", "message": "optimize duplicated ors"}, "afterCommit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/865e7124da66e3a956dffba1d40be4cb550048ba", "committedDate": "2020-04-08T07:56:43Z", "message": "optimize duplicated ors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5Nzc2MDM0", "url": "https://github.com/apache/incubator-doris/pull/3278#pullrequestreview-389776034", "createdAt": "2020-04-08T08:52:15Z", "commit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwODo1MjoxNVrOGClYgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwODo1MjoxNVrOGClYgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM2MjgxNw==", "bodyText": "Could we move this improve to ExprRewriteRule ?", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405362817", "createdAt": "2020-04-08T08:52:15Z", "author": {"login": "kangkaisen"}, "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMDQ3MDI3", "url": "https://github.com/apache/incubator-doris/pull/3278#pullrequestreview-390047027", "createdAt": "2020-04-08T14:48:13Z", "commit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo0ODoxM1rOGCyyZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1MzoxM1rOGCzBEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MjQzOQ==", "bodyText": "Only exprs.size() < 2 is enough.\nexprs will not be NULL here.", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405582439", "createdAt": "2020-04-08T14:48:13Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {\n+        if (CollectionUtils.isEmpty(exprs) || exprs.size() < 2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MzI4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // 1. remove duplcated elemnents [[a,a], [a, b], [a,b]] => [[a], [a,b]]\n          \n          \n            \n                    // 1. remove duplicated elements [[a,a], [a, b], [a,b]] => [[a], [a,b]]", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405583281", "createdAt": "2020-04-08T14:49:24Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {\n+        if (CollectionUtils.isEmpty(exprs) || exprs.size() < 2) {\n+            return null;\n+        }\n+        // 1. remove duplcated elemnents [[a,a], [a, b], [a,b]] => [[a], [a,b]]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NDA2NQ==", "bodyText": "Better NOT to modify the parameter. It will make the method error-prone", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405584065", "createdAt": "2020-04-08T14:50:27Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {\n+        if (CollectionUtils.isEmpty(exprs) || exprs.size() < 2) {\n+            return null;\n+        }\n+        // 1. remove duplcated elemnents [[a,a], [a, b], [a,b]] => [[a], [a,b]]\n+        Set<Set<Expr>> set = new LinkedHashSet<>();\n+        for (List<Expr> ex : exprs) {\n+            Set<Expr> es = new LinkedHashSet<>();\n+            es.addAll(ex);\n+            set.add(es);\n+        }\n+        exprs.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NjE5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.info(\"rewrite ors: \" + result.toSql());\n          \n          \n            \n                    LOG.debug(\"rewrite ors: \" + result.toSql());", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405586193", "createdAt": "2020-04-08T14:53:13Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {\n+        if (CollectionUtils.isEmpty(exprs) || exprs.size() < 2) {\n+            return null;\n+        }\n+        // 1. remove duplcated elemnents [[a,a], [a, b], [a,b]] => [[a], [a,b]]\n+        Set<Set<Expr>> set = new LinkedHashSet<>();\n+        for (List<Expr> ex : exprs) {\n+            Set<Expr> es = new LinkedHashSet<>();\n+            es.addAll(ex);\n+            set.add(es);\n+        }\n+        exprs.clear();\n+        for (Set<Expr> es : set) {\n+            List<Expr> el = new ArrayList<>();\n+            el.addAll(es);\n+            exprs.add(el);\n+        }\n+        if (exprs.size() == 1) {\n+            return makeCompound(exprs.get(0), CompoundPredicate.Operator.AND);\n+        }\n+        // 2. find duplcate cross the clause\n+        List<Expr> cloneExprs = new ArrayList<>(exprs.get(0));\n+        for (int i = 1; i < exprs.size(); ++i) {\n+            cloneExprs.retainAll(exprs.get(i));\n+        }\n+        List<Expr> temp = new ArrayList<>();\n+        if (CollectionUtils.isNotEmpty(cloneExprs)) {\n+            temp.add(makeCompound(cloneExprs, CompoundPredicate.Operator.AND));\n+        }\n+\n+        for (List<Expr> exprList : exprs) {\n+            exprList.removeAll(cloneExprs);\n+            temp.add(makeCompound(exprList, CompoundPredicate.Operator.AND));\n+        }\n+\n+        // rebuild CompoundPredicate if found duplicate predicate will build \uff08predcate) and (.. or ..)  predicate in\n+        // step 1: will build (.. or ..)\n+        Expr result = CollectionUtils.isNotEmpty(cloneExprs) ? new CompoundPredicate(CompoundPredicate.Operator.AND,\n+                temp.get(0), makeCompound(temp.subList(1, temp.size()), CompoundPredicate.Operator.OR))\n+                : makeCompound(temp, CompoundPredicate.Operator.OR);\n+        LOG.info(\"rewrite ors: \" + result.toSql());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba"}, "originalPosition": 128}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c73cd6b81f747b4ee4ec490a169b9618e169991", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/8c73cd6b81f747b4ee4ec490a169b9618e169991", "committedDate": "2020-04-09T01:56:25Z", "message": "fix some typo and pr comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwODEzODA2", "url": "https://github.com/apache/incubator-doris/pull/3278#pullrequestreview-390813806", "createdAt": "2020-04-09T13:54:25Z", "commit": {"oid": "8c73cd6b81f747b4ee4ec490a169b9618e169991"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3187, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}