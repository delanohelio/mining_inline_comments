{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3MjE0NDQ5", "number": 3580, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMTo0NDozOVrOD8tDTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMzowNDoyMVrOD9Oh-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTc5Mjc2OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/column.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMTo0NDozOVrOGVzuhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMToxNjo0M1rOGWAuLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMDc3Mg==", "bodyText": "better to add #undef CREATE_READER after usage", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425520772", "createdAt": "2020-05-15T01:44:39Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/column.cpp", "diffHunk": "@@ -105,19 +108,102 @@ Status Column::capture_version(uint64_t version, vector<ColumnDelta*>* deltas,\n     return Status::OK();\n }\n \n-void Column::capture_latest(vector<ColumnDelta*>* deltas) const {\n+void Column::capture_latest(vector<ColumnDelta*>* deltas, uint64_t* version) const {\n     deltas->reserve(_versions.size() - _base_idx - 1);\n     for (size_t i = _base_idx + 1; i < _versions.size(); i++) {\n         deltas->emplace_back(_versions[i].delta.get());\n     }\n+    *version = _versions.back().version;\n }\n \n Status Column::read(uint64_t version, std::unique_ptr<ColumnReader>* reader) {\n-    return Status::NotSupported(\"not supported\");\n+    ColumnType type = schema().type();\n+    bool nullable = schema().is_nullable();\n+    vector<ColumnDelta*> deltas;\n+    uint64_t real_version;\n+    RETURN_IF_ERROR(capture_version(version, &deltas, &real_version));\n+\n+#define CREATE_READER(T)                                                                          \\\n+    if (nullable) {                                                                               \\\n+        (*reader).reset(                                                                          \\\n+                new TypedColumnReader<T, true>(this, version, real_version, std::move(deltas)));  \\\n+    } else {                                                                                      \\\n+        (*reader).reset(                                                                          \\\n+                new TypedColumnReader<T, false>(this, version, real_version, std::move(deltas))); \\\n+    }\n+\n+    switch (type) {\n+    case OLAP_FIELD_TYPE_BOOL:\n+    case OLAP_FIELD_TYPE_TINYINT:\n+        CREATE_READER(int8_t)\n+        break;\n+    case OLAP_FIELD_TYPE_SMALLINT:\n+        CREATE_READER(int16_t)\n+        break;\n+    case OLAP_FIELD_TYPE_INT:\n+        CREATE_READER(int32_t)\n+        break;\n+    case OLAP_FIELD_TYPE_BIGINT:\n+        CREATE_READER(int64_t)\n+        break;\n+    case OLAP_FIELD_TYPE_LARGEINT:\n+        CREATE_READER(int128_t)\n+        break;\n+    case OLAP_FIELD_TYPE_FLOAT:\n+        CREATE_READER(float)\n+        break;\n+    case OLAP_FIELD_TYPE_DOUBLE:\n+        CREATE_READER(double)\n+        break;\n+    default:\n+        return Status::NotSupported(\"create column reader: type not supported\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczMzY3OA==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425733678", "createdAt": "2020-05-15T11:16:43Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/column.cpp", "diffHunk": "@@ -105,19 +108,102 @@ Status Column::capture_version(uint64_t version, vector<ColumnDelta*>* deltas,\n     return Status::OK();\n }\n \n-void Column::capture_latest(vector<ColumnDelta*>* deltas) const {\n+void Column::capture_latest(vector<ColumnDelta*>* deltas, uint64_t* version) const {\n     deltas->reserve(_versions.size() - _base_idx - 1);\n     for (size_t i = _base_idx + 1; i < _versions.size(); i++) {\n         deltas->emplace_back(_versions[i].delta.get());\n     }\n+    *version = _versions.back().version;\n }\n \n Status Column::read(uint64_t version, std::unique_ptr<ColumnReader>* reader) {\n-    return Status::NotSupported(\"not supported\");\n+    ColumnType type = schema().type();\n+    bool nullable = schema().is_nullable();\n+    vector<ColumnDelta*> deltas;\n+    uint64_t real_version;\n+    RETURN_IF_ERROR(capture_version(version, &deltas, &real_version));\n+\n+#define CREATE_READER(T)                                                                          \\\n+    if (nullable) {                                                                               \\\n+        (*reader).reset(                                                                          \\\n+                new TypedColumnReader<T, true>(this, version, real_version, std::move(deltas)));  \\\n+    } else {                                                                                      \\\n+        (*reader).reset(                                                                          \\\n+                new TypedColumnReader<T, false>(this, version, real_version, std::move(deltas))); \\\n+    }\n+\n+    switch (type) {\n+    case OLAP_FIELD_TYPE_BOOL:\n+    case OLAP_FIELD_TYPE_TINYINT:\n+        CREATE_READER(int8_t)\n+        break;\n+    case OLAP_FIELD_TYPE_SMALLINT:\n+        CREATE_READER(int16_t)\n+        break;\n+    case OLAP_FIELD_TYPE_INT:\n+        CREATE_READER(int32_t)\n+        break;\n+    case OLAP_FIELD_TYPE_BIGINT:\n+        CREATE_READER(int64_t)\n+        break;\n+    case OLAP_FIELD_TYPE_LARGEINT:\n+        CREATE_READER(int128_t)\n+        break;\n+    case OLAP_FIELD_TYPE_FLOAT:\n+        CREATE_READER(float)\n+        break;\n+    case OLAP_FIELD_TYPE_DOUBLE:\n+        CREATE_READER(double)\n+        break;\n+    default:\n+        return Status::NotSupported(\"create column reader: type not supported\");\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMDc3Mg=="}, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTc5NTA1OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/column_reader.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMTo0NTo1MFrOGVzv2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMToxOTozMlrOGWAy1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMTExNA==", "bodyText": "Is this thread-safe? Better declare it in the comment.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425521114", "createdAt": "2020-05-15T01:45:50Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/column_reader.h", "diffHunk": "@@ -0,0 +1,95 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Holder for a ColumnBlock\n+// Although ColumnBlock support reference counting, we avoid using it because\n+// a reader already hold a proxy to all the ColumnBlocks, it's unnecessary\n+// and inefficient to inc/dec refcount, so we use this holder instead.\n+//\n+// If the underlying column data doesn't need merge-on-read, we can use the\n+// underlying base's ColumnBlock directly, and _own_cb equals false.\n+//\n+// If there are some deltas need to be merged, a new ColumnBlock will be\n+// created, and _own_cb equals true.\n+class ColumnBlockHolder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczNDg2OQ==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425734869", "createdAt": "2020-05-15T11:19:32Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/column_reader.h", "diffHunk": "@@ -0,0 +1,95 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Holder for a ColumnBlock\n+// Although ColumnBlock support reference counting, we avoid using it because\n+// a reader already hold a proxy to all the ColumnBlocks, it's unnecessary\n+// and inefficient to inc/dec refcount, so we use this holder instead.\n+//\n+// If the underlying column data doesn't need merge-on-read, we can use the\n+// underlying base's ColumnBlock directly, and _own_cb equals false.\n+//\n+// If there are some deltas need to be merged, a new ColumnBlock will be\n+// created, and _own_cb equals true.\n+class ColumnBlockHolder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMTExNA=="}, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTgwMDY4OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/typed_column_writer.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMTo0OTowMVrOGVzzLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMToyNToyOFrOGWA9jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMTk2NA==", "bodyText": "default value", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425521964", "createdAt": "2020-05-15T01:49:01Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/typed_column_writer.h", "diffHunk": "@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/typed_column_reader.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Used to hold temporary nullable update cells in ColumnWriter\n+template <class T>\n+class NullableUpdateType {\n+public:\n+    bool& isnull() { return _isnull; }\n+    T& value() { return _value; }\n+\n+private:\n+    bool _isnull;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczNzYxMg==", "bodyText": "I rethought about this, actually, maybe we should avoid initializing those fields for performance reasons, because these fields will be properly assigned in related methods.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425737612", "createdAt": "2020-05-15T11:25:28Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/typed_column_writer.h", "diffHunk": "@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/typed_column_reader.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Used to hold temporary nullable update cells in ColumnWriter\n+template <class T>\n+class NullableUpdateType {\n+public:\n+    bool& isnull() { return _isnull; }\n+    T& value() { return _value; }\n+\n+private:\n+    bool _isnull;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMTk2NA=="}, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTgxMzMxOnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/column_writer.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMTo1Njo1OVrOGVz6mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTowNToyMFrOGV8oyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMzg2Nw==", "bodyText": "Is the class a writer of class or a writer of part of column?\nIn my opinion, column will contain all data for a table \"column\", and its data is not written at one time. One Writer may update some part of column data.\nIf my understanding is right, I think ColumnBlockWriter/ColumnChunkWriter is a better name.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425523867", "createdAt": "2020-05-15T01:56:59Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->write(&writer).ok());\n+//   writer->insert(new_rowid, &value, 0);\n+//   writer->update(rowid, &value, 0);\n+//   writer->finalize(new_version);\n+//   // get new column refptr\n+//   // if a COW has been done, column will point to new column object\n+//   // else column will remain the same.\n+//   writer->get_new_column(&column);\n+class ColumnWriter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2Njc2MQ==", "bodyText": "Is the class a writer of class or a writer of part of column?\n\nIt is the writer of a whole column, it will write all the inserts/updates of this column of a writetx.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425666761", "createdAt": "2020-05-15T09:05:20Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->write(&writer).ok());\n+//   writer->insert(new_rowid, &value, 0);\n+//   writer->update(rowid, &value, 0);\n+//   writer->finalize(new_version);\n+//   // get new column refptr\n+//   // if a COW has been done, column will point to new column object\n+//   // else column will remain the same.\n+//   writer->get_new_column(&column);\n+class ColumnWriter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMzg2Nw=="}, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTgxNDg3OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/column_writer.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMTo1Nzo0OVrOGVz7kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTowNjowMVrOGV8qgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyNDExNQ==", "bodyText": "And how about delete operation.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425524115", "createdAt": "2020-05-15T01:57:49Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->write(&writer).ok());\n+//   writer->insert(new_rowid, &value, 0);\n+//   writer->update(rowid, &value, 0);\n+//   writer->finalize(new_version);\n+//   // get new column refptr\n+//   // if a COW has been done, column will point to new column object\n+//   // else column will remain the same.\n+//   writer->get_new_column(&column);\n+class ColumnWriter {\n+public:\n+    virtual ~ColumnWriter() {}\n+\n+    // Get cell by rid, caller needs to make sure rid is in valid range\n+    //\n+    // Note: this is the same method as ColumnReader::get\n+    virtual const void* get(const uint32_t rid) const = 0;\n+\n+    // Borrow a vtable slot to do typed hashcode calculation, mainly used to find\n+    // row by rowkey using hash index.\n+    //\n+    // It's designed to support array operator, so there are two parameters for user\n+    // to pass array start and array index.\n+    //\n+    // Note: this is the same method as ColumnReader::hashcode\n+    virtual uint64_t hashcode(const void* rhs, size_t rhs_idx) const = 0;\n+\n+    // Check cell equality, mainly used to find row by rowkey using hash index.\n+    //\n+    // Note: this is the same method as ColumnReader::equals\n+    virtual bool equals(const uint32_t rid, const void* rhs, size_t rhs_idx) const = 0;\n+\n+    virtual string debug_string() const = 0;\n+\n+    // Insert/append a cell at specified row\n+    virtual Status insert(uint32_t rid, const void* value) = 0;\n+\n+    // Update a cell at specified row\n+    virtual Status update(uint32_t rid, const void* value) = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2NzIwMw==", "bodyText": "delete is handled in a special delete flag column.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425667203", "createdAt": "2020-05-15T09:06:01Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->write(&writer).ok());\n+//   writer->insert(new_rowid, &value, 0);\n+//   writer->update(rowid, &value, 0);\n+//   writer->finalize(new_version);\n+//   // get new column refptr\n+//   // if a COW has been done, column will point to new column object\n+//   // else column will remain the same.\n+//   writer->get_new_column(&column);\n+class ColumnWriter {\n+public:\n+    virtual ~ColumnWriter() {}\n+\n+    // Get cell by rid, caller needs to make sure rid is in valid range\n+    //\n+    // Note: this is the same method as ColumnReader::get\n+    virtual const void* get(const uint32_t rid) const = 0;\n+\n+    // Borrow a vtable slot to do typed hashcode calculation, mainly used to find\n+    // row by rowkey using hash index.\n+    //\n+    // It's designed to support array operator, so there are two parameters for user\n+    // to pass array start and array index.\n+    //\n+    // Note: this is the same method as ColumnReader::hashcode\n+    virtual uint64_t hashcode(const void* rhs, size_t rhs_idx) const = 0;\n+\n+    // Check cell equality, mainly used to find row by rowkey using hash index.\n+    //\n+    // Note: this is the same method as ColumnReader::equals\n+    virtual bool equals(const uint32_t rid, const void* rhs, size_t rhs_idx) const = 0;\n+\n+    virtual string debug_string() const = 0;\n+\n+    // Insert/append a cell at specified row\n+    virtual Status insert(uint32_t rid, const void* value) = 0;\n+\n+    // Update a cell at specified row\n+    virtual Status update(uint32_t rid, const void* value) = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyNDExNQ=="}, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTI0MTAwOnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/column.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMTo1Njo0MlrOGWB0Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODoxMDoyNVrOGWY-xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc1MTYyMg==", "bodyText": "Write is the meaning of write actual data. This name may be confused.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425751622", "createdAt": "2020-05-15T11:56:42Z", "author": {"login": "chaoyli"}, "path": "be/src/olap/memory/column.cpp", "diffHunk": "@@ -105,19 +108,102 @@ Status Column::capture_version(uint64_t version, vector<ColumnDelta*>* deltas,\n     return Status::OK();\n }\n \n-void Column::capture_latest(vector<ColumnDelta*>* deltas) const {\n+void Column::capture_latest(vector<ColumnDelta*>* deltas, uint64_t* version) const {\n     deltas->reserve(_versions.size() - _base_idx - 1);\n     for (size_t i = _base_idx + 1; i < _versions.size(); i++) {\n         deltas->emplace_back(_versions[i].delta.get());\n     }\n+    *version = _versions.back().version;\n }\n \n Status Column::read(uint64_t version, std::unique_ptr<ColumnReader>* reader) {\n-    return Status::NotSupported(\"not supported\");\n+    ColumnType type = schema().type();\n+    bool nullable = schema().is_nullable();\n+    vector<ColumnDelta*> deltas;\n+    uint64_t real_version;\n+    RETURN_IF_ERROR(capture_version(version, &deltas, &real_version));\n+\n+#define CREATE_READER(T)                                                                          \\\n+    if (nullable) {                                                                               \\\n+        (*reader).reset(                                                                          \\\n+                new TypedColumnReader<T, true>(this, version, real_version, std::move(deltas)));  \\\n+    } else {                                                                                      \\\n+        (*reader).reset(                                                                          \\\n+                new TypedColumnReader<T, false>(this, version, real_version, std::move(deltas))); \\\n+    }\n+\n+    switch (type) {\n+    case OLAP_FIELD_TYPE_BOOL:\n+    case OLAP_FIELD_TYPE_TINYINT:\n+        CREATE_READER(int8_t)\n+        break;\n+    case OLAP_FIELD_TYPE_SMALLINT:\n+        CREATE_READER(int16_t)\n+        break;\n+    case OLAP_FIELD_TYPE_INT:\n+        CREATE_READER(int32_t)\n+        break;\n+    case OLAP_FIELD_TYPE_BIGINT:\n+        CREATE_READER(int64_t)\n+        break;\n+    case OLAP_FIELD_TYPE_LARGEINT:\n+        CREATE_READER(int128_t)\n+        break;\n+    case OLAP_FIELD_TYPE_FLOAT:\n+        CREATE_READER(float)\n+        break;\n+    case OLAP_FIELD_TYPE_DOUBLE:\n+        CREATE_READER(double)\n+        break;\n+    default:\n+        return Status::NotSupported(\"create column reader: type not supported\");\n+    }\n+    return Status::OK();\n }\n \n Status Column::write(std::unique_ptr<ColumnWriter>* writer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMTE0MQ==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426131141", "createdAt": "2020-05-16T08:10:25Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/column.cpp", "diffHunk": "@@ -105,19 +108,102 @@ Status Column::capture_version(uint64_t version, vector<ColumnDelta*>* deltas,\n     return Status::OK();\n }\n \n-void Column::capture_latest(vector<ColumnDelta*>* deltas) const {\n+void Column::capture_latest(vector<ColumnDelta*>* deltas, uint64_t* version) const {\n     deltas->reserve(_versions.size() - _base_idx - 1);\n     for (size_t i = _base_idx + 1; i < _versions.size(); i++) {\n         deltas->emplace_back(_versions[i].delta.get());\n     }\n+    *version = _versions.back().version;\n }\n \n Status Column::read(uint64_t version, std::unique_ptr<ColumnReader>* reader) {\n-    return Status::NotSupported(\"not supported\");\n+    ColumnType type = schema().type();\n+    bool nullable = schema().is_nullable();\n+    vector<ColumnDelta*> deltas;\n+    uint64_t real_version;\n+    RETURN_IF_ERROR(capture_version(version, &deltas, &real_version));\n+\n+#define CREATE_READER(T)                                                                          \\\n+    if (nullable) {                                                                               \\\n+        (*reader).reset(                                                                          \\\n+                new TypedColumnReader<T, true>(this, version, real_version, std::move(deltas)));  \\\n+    } else {                                                                                      \\\n+        (*reader).reset(                                                                          \\\n+                new TypedColumnReader<T, false>(this, version, real_version, std::move(deltas))); \\\n+    }\n+\n+    switch (type) {\n+    case OLAP_FIELD_TYPE_BOOL:\n+    case OLAP_FIELD_TYPE_TINYINT:\n+        CREATE_READER(int8_t)\n+        break;\n+    case OLAP_FIELD_TYPE_SMALLINT:\n+        CREATE_READER(int16_t)\n+        break;\n+    case OLAP_FIELD_TYPE_INT:\n+        CREATE_READER(int32_t)\n+        break;\n+    case OLAP_FIELD_TYPE_BIGINT:\n+        CREATE_READER(int64_t)\n+        break;\n+    case OLAP_FIELD_TYPE_LARGEINT:\n+        CREATE_READER(int128_t)\n+        break;\n+    case OLAP_FIELD_TYPE_FLOAT:\n+        CREATE_READER(float)\n+        break;\n+    case OLAP_FIELD_TYPE_DOUBLE:\n+        CREATE_READER(double)\n+        break;\n+    default:\n+        return Status::NotSupported(\"create column reader: type not supported\");\n+    }\n+    return Status::OK();\n }\n \n Status Column::write(std::unique_ptr<ColumnWriter>* writer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc1MTYyMg=="}, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTM3NDg3OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/typed_column_reader.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMjo0MDowMFrOGWDIWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODoxMjoyM1rOGWY_Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3MzE0Nw==", "bodyText": "I found page/block are used interleaved. It's better to use one name to remove misapprehension.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425773147", "createdAt": "2020-05-15T12:40:00Z", "author": {"login": "chaoyli"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,208 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// This method needs to be shared by reader/writer, so extract it as template function\n+template <class Reader, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const Reader& reader, const uint32_t rid) {\n+    for (ssize_t i = reader._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = reader._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < reader._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*reader._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        bool isnull = (*reader._base)[bid]->is_null(idx);\n+        if (isnull) {\n+            return nullptr;\n+        } else {\n+            return &((*reader._base)[bid]->data().template as<ST>()[idx]);\n+        }\n+    } else {\n+        return &((*reader._base)[bid]->data().template as<ST>()[idx]);\n+    }\n+}\n+\n+template <class T, class ST>\n+inline uint64_t TypedColumnHashcode(const void* rhs, size_t rhs_idx) {\n+    if (std::is_same<T, ST>::value) {\n+        const T* prhs = ((const T*)rhs) + rhs_idx;\n+        return HashUtil::fnv_hash64(prhs, sizeof(T), 0);\n+    } else {\n+        // TODO: support other type's hash\n+        return 0;\n+    }\n+}\n+\n+template <class Reader, class T, bool Nullable, class ST>\n+bool TypedColumnEquals(const Reader& reader, const uint32_t rid, const void* rhs, size_t rhs_idx) {\n+    const T& rhs_value = ((const T*)rhs)[rhs_idx];\n+    for (ssize_t i = reader._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = reader._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                CHECK(false) << \"only used for key column\";\n+                return false;\n+            } else {\n+                return (pdelta->data().template as<T>()[pos]) == rhs_value;\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < reader._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*reader._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        CHECK(false) << \"only used for key column\";\n+        return false;\n+    } else {\n+        DCHECK(rhs);\n+        return ((*reader._base)[bid]->data().template as<T>()[idx]) == rhs_value;\n+    }\n+}\n+\n+// ColumnReader typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T>\n+class TypedColumnReader : public ColumnReader {\n+public:\n+    TypedColumnReader(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnReader<T, Nullable, ST>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    Status get_block(size_t nrows, size_t block, ColumnBlockHolder* cbh) const {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMTI3OA==", "bodyText": "fixed, all renamed to block", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426131278", "createdAt": "2020-05-16T08:12:23Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,208 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// This method needs to be shared by reader/writer, so extract it as template function\n+template <class Reader, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const Reader& reader, const uint32_t rid) {\n+    for (ssize_t i = reader._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = reader._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < reader._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*reader._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        bool isnull = (*reader._base)[bid]->is_null(idx);\n+        if (isnull) {\n+            return nullptr;\n+        } else {\n+            return &((*reader._base)[bid]->data().template as<ST>()[idx]);\n+        }\n+    } else {\n+        return &((*reader._base)[bid]->data().template as<ST>()[idx]);\n+    }\n+}\n+\n+template <class T, class ST>\n+inline uint64_t TypedColumnHashcode(const void* rhs, size_t rhs_idx) {\n+    if (std::is_same<T, ST>::value) {\n+        const T* prhs = ((const T*)rhs) + rhs_idx;\n+        return HashUtil::fnv_hash64(prhs, sizeof(T), 0);\n+    } else {\n+        // TODO: support other type's hash\n+        return 0;\n+    }\n+}\n+\n+template <class Reader, class T, bool Nullable, class ST>\n+bool TypedColumnEquals(const Reader& reader, const uint32_t rid, const void* rhs, size_t rhs_idx) {\n+    const T& rhs_value = ((const T*)rhs)[rhs_idx];\n+    for (ssize_t i = reader._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = reader._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                CHECK(false) << \"only used for key column\";\n+                return false;\n+            } else {\n+                return (pdelta->data().template as<T>()[pos]) == rhs_value;\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < reader._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*reader._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        CHECK(false) << \"only used for key column\";\n+        return false;\n+    } else {\n+        DCHECK(rhs);\n+        return ((*reader._base)[bid]->data().template as<T>()[idx]) == rhs_value;\n+    }\n+}\n+\n+// ColumnReader typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T>\n+class TypedColumnReader : public ColumnReader {\n+public:\n+    TypedColumnReader(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnReader<T, Nullable, ST>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    Status get_block(size_t nrows, size_t block, ColumnBlockHolder* cbh) const {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3MzE0Nw=="}, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTM5MDk4OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/typed_column_reader.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMjo0NDozN1rOGWDSdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODoxNDo1MlrOGWY_8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3NTczMw==", "bodyText": "class Reader is ambiguous", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425775733", "createdAt": "2020-05-15T12:44:37Z", "author": {"login": "chaoyli"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,208 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// This method needs to be shared by reader/writer, so extract it as template function\n+template <class Reader, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const Reader& reader, const uint32_t rid) {\n+    for (ssize_t i = reader._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = reader._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < reader._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*reader._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        bool isnull = (*reader._base)[bid]->is_null(idx);\n+        if (isnull) {\n+            return nullptr;\n+        } else {\n+            return &((*reader._base)[bid]->data().template as<ST>()[idx]);\n+        }\n+    } else {\n+        return &((*reader._base)[bid]->data().template as<ST>()[idx]);\n+    }\n+}\n+\n+template <class T, class ST>\n+inline uint64_t TypedColumnHashcode(const void* rhs, size_t rhs_idx) {\n+    if (std::is_same<T, ST>::value) {\n+        const T* prhs = ((const T*)rhs) + rhs_idx;\n+        return HashUtil::fnv_hash64(prhs, sizeof(T), 0);\n+    } else {\n+        // TODO: support other type's hash\n+        return 0;\n+    }\n+}\n+\n+template <class Reader, class T, bool Nullable, class ST>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMTQ0MQ==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426131441", "createdAt": "2020-05-16T08:14:52Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,208 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// This method needs to be shared by reader/writer, so extract it as template function\n+template <class Reader, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const Reader& reader, const uint32_t rid) {\n+    for (ssize_t i = reader._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = reader._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < reader._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*reader._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        bool isnull = (*reader._base)[bid]->is_null(idx);\n+        if (isnull) {\n+            return nullptr;\n+        } else {\n+            return &((*reader._base)[bid]->data().template as<ST>()[idx]);\n+        }\n+    } else {\n+        return &((*reader._base)[bid]->data().template as<ST>()[idx]);\n+    }\n+}\n+\n+template <class T, class ST>\n+inline uint64_t TypedColumnHashcode(const void* rhs, size_t rhs_idx) {\n+    if (std::is_same<T, ST>::value) {\n+        const T* prhs = ((const T*)rhs) + rhs_idx;\n+        return HashUtil::fnv_hash64(prhs, sizeof(T), 0);\n+    } else {\n+        // TODO: support other type's hash\n+        return 0;\n+    }\n+}\n+\n+template <class Reader, class T, bool Nullable, class ST>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3NTczMw=="}, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTM5ODU3OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/typed_column_reader.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMjo0Njo0N1rOGWDXLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODoyODowM1rOGWZEVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3Njk0Mw==", "bodyText": "What the function want to return, may be add a comment to elaborate it.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425776943", "createdAt": "2020-05-15T12:46:47Z", "author": {"login": "chaoyli"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,208 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// This method needs to be shared by reader/writer, so extract it as template function\n+template <class Reader, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const Reader& reader, const uint32_t rid) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMjU2NA==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426132564", "createdAt": "2020-05-16T08:28:03Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,208 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// This method needs to be shared by reader/writer, so extract it as template function\n+template <class Reader, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const Reader& reader, const uint32_t rid) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3Njk0Mw=="}, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTQwNTI4OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/column_writer.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMjo0ODozM1rOGWDbMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODoxNjozNVrOGWZAew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3Nzk3MA==", "bodyText": "writer->insert(new_rowid, &value);\nwriter->update(rowid, &value);", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425777970", "createdAt": "2020-05-15T12:48:33Z", "author": {"login": "chaoyli"}, "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->write(&writer).ok());\n+//   writer->insert(new_rowid, &value, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMTU3OQ==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426131579", "createdAt": "2020-05-16T08:16:35Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->write(&writer).ok());\n+//   writer->insert(new_rowid, &value, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3Nzk3MA=="}, "originalCommit": {"oid": "1d3270e8505e511397c9656d96020949bab17486"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzkxMzk4OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/column_writer.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNTo1NTo0MFrOGWbFyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QxNToyNjo1NFrOGWhrlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2NTcwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            //   RETURN_IF_ERROR(column->write(&writer).ok());\n          \n          \n            \n            //   RETURN_IF_ERROR(column->create_writer(&writer).ok());", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426165706", "createdAt": "2020-05-16T15:55:40Z", "author": {"login": "morningman"}, "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->write(&writer).ok());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdd2a1e2ab18cecb5c36b8bba873bdd4472ebe56"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3MzY4Ng==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426273686", "createdAt": "2020-05-17T15:26:54Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->write(&writer).ok());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2NTcwNg=="}, "originalCommit": {"oid": "fdd2a1e2ab18cecb5c36b8bba873bdd4472ebe56"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTE5NjQxOnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/typed_column_reader.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMTo1MzozM1rOGWldVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODoxNzozNVrOGWsPlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNTU3NA==", "bodyText": "Give some comments for this template parameters to help others understand", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426335574", "createdAt": "2020-05-18T01:53:33Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0Njc0Mg==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426446742", "createdAt": "2020-05-18T08:17:35Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNTU3NA=="}, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTIwMDMyOnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/typed_column_reader.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMTo1NzoyOVrOGWlfwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODoxNzo0M1rOGWsP4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNjE5Mw==", "bodyText": "It will be better if you can give some comment about how this function works", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426336193", "createdAt": "2020-05-18T01:57:29Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const RW& rw, const uint32_t rid) {\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < rw._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*rw._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        bool isnull = (*rw._base)[bid]->is_null(idx);\n+        if (isnull) {\n+            return nullptr;\n+        } else {\n+            return &((*rw._base)[bid]->data().template as<ST>()[idx]);\n+        }\n+    } else {\n+        return &((*rw._base)[bid]->data().template as<ST>()[idx]);\n+    }\n+}\n+\n+// Get a cell's hashcode of a typed array\n+template <class T, class ST>\n+inline uint64_t TypedColumnHashcode(const void* rhs, size_t rhs_idx) {\n+    if (std::is_same<T, ST>::value) {\n+        const T* prhs = ((const T*)rhs) + rhs_idx;\n+        return HashUtil::fnv_hash64(prhs, sizeof(T), 0);\n+    } else {\n+        // TODO: support other type's hash\n+        return 0;\n+    }\n+}\n+\n+// Compare equality of a typed array's cell with this column's cell\n+template <class RW, class T, bool Nullable, class ST>\n+bool TypedColumnEquals(const RW& rw, const uint32_t rid, const void* rhs, size_t rhs_idx) {\n+    const T& rhs_value = ((const T*)rhs)[rhs_idx];\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                CHECK(false) << \"only used for key column\";\n+                return false;\n+            } else {\n+                return (pdelta->data().template as<T>()[pos]) == rhs_value;\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < rw._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*rw._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        CHECK(false) << \"only used for key column\";\n+        return false;\n+    } else {\n+        DCHECK(rhs);\n+        return ((*rw._base)[bid]->data().template as<T>()[idx]) == rhs_value;\n+    }\n+}\n+\n+// ColumnReader typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+//\n+// Template type meanings:\n+// T: column type used for interface\n+// Nullable: whether column type is nullable\n+// ST: column type used for internal storage\n+//\n+// For fixed size scalar types(int/float), T should be the same as ST\n+// For var size typse(string), when using dict encoding, ST may be integer\n+//\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T>\n+class TypedColumnReader : public ColumnReader {\n+public:\n+    TypedColumnReader(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnReader<T, Nullable, ST>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    Status get_block(size_t nrows, size_t bid, ColumnBlockHolder* cbh) const {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NjgxOA==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426446818", "createdAt": "2020-05-18T08:17:43Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const RW& rw, const uint32_t rid) {\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < rw._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*rw._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        bool isnull = (*rw._base)[bid]->is_null(idx);\n+        if (isnull) {\n+            return nullptr;\n+        } else {\n+            return &((*rw._base)[bid]->data().template as<ST>()[idx]);\n+        }\n+    } else {\n+        return &((*rw._base)[bid]->data().template as<ST>()[idx]);\n+    }\n+}\n+\n+// Get a cell's hashcode of a typed array\n+template <class T, class ST>\n+inline uint64_t TypedColumnHashcode(const void* rhs, size_t rhs_idx) {\n+    if (std::is_same<T, ST>::value) {\n+        const T* prhs = ((const T*)rhs) + rhs_idx;\n+        return HashUtil::fnv_hash64(prhs, sizeof(T), 0);\n+    } else {\n+        // TODO: support other type's hash\n+        return 0;\n+    }\n+}\n+\n+// Compare equality of a typed array's cell with this column's cell\n+template <class RW, class T, bool Nullable, class ST>\n+bool TypedColumnEquals(const RW& rw, const uint32_t rid, const void* rhs, size_t rhs_idx) {\n+    const T& rhs_value = ((const T*)rhs)[rhs_idx];\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                CHECK(false) << \"only used for key column\";\n+                return false;\n+            } else {\n+                return (pdelta->data().template as<T>()[pos]) == rhs_value;\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < rw._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*rw._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        CHECK(false) << \"only used for key column\";\n+        return false;\n+    } else {\n+        DCHECK(rhs);\n+        return ((*rw._base)[bid]->data().template as<T>()[idx]) == rhs_value;\n+    }\n+}\n+\n+// ColumnReader typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+//\n+// Template type meanings:\n+// T: column type used for interface\n+// Nullable: whether column type is nullable\n+// ST: column type used for internal storage\n+//\n+// For fixed size scalar types(int/float), T should be the same as ST\n+// For var size typse(string), when using dict encoding, ST may be integer\n+//\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T>\n+class TypedColumnReader : public ColumnReader {\n+public:\n+    TypedColumnReader(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnReader<T, Nullable, ST>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    Status get_block(size_t nrows, size_t bid, ColumnBlockHolder* cbh) const {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNjE5Mw=="}, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTIwMTM5OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/typed_column_reader.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMTo1ODoxMlrOGWlgXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODoxOToyMlrOGWsT3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNjM1MA==", "bodyText": "Please give comment for this fast path.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426336350", "createdAt": "2020-05-18T01:58:12Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const RW& rw, const uint32_t rid) {\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < rw._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*rw._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        bool isnull = (*rw._base)[bid]->is_null(idx);\n+        if (isnull) {\n+            return nullptr;\n+        } else {\n+            return &((*rw._base)[bid]->data().template as<ST>()[idx]);\n+        }\n+    } else {\n+        return &((*rw._base)[bid]->data().template as<ST>()[idx]);\n+    }\n+}\n+\n+// Get a cell's hashcode of a typed array\n+template <class T, class ST>\n+inline uint64_t TypedColumnHashcode(const void* rhs, size_t rhs_idx) {\n+    if (std::is_same<T, ST>::value) {\n+        const T* prhs = ((const T*)rhs) + rhs_idx;\n+        return HashUtil::fnv_hash64(prhs, sizeof(T), 0);\n+    } else {\n+        // TODO: support other type's hash\n+        return 0;\n+    }\n+}\n+\n+// Compare equality of a typed array's cell with this column's cell\n+template <class RW, class T, bool Nullable, class ST>\n+bool TypedColumnEquals(const RW& rw, const uint32_t rid, const void* rhs, size_t rhs_idx) {\n+    const T& rhs_value = ((const T*)rhs)[rhs_idx];\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                CHECK(false) << \"only used for key column\";\n+                return false;\n+            } else {\n+                return (pdelta->data().template as<T>()[pos]) == rhs_value;\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < rw._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*rw._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        CHECK(false) << \"only used for key column\";\n+        return false;\n+    } else {\n+        DCHECK(rhs);\n+        return ((*rw._base)[bid]->data().template as<T>()[idx]) == rhs_value;\n+    }\n+}\n+\n+// ColumnReader typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+//\n+// Template type meanings:\n+// T: column type used for interface\n+// Nullable: whether column type is nullable\n+// ST: column type used for internal storage\n+//\n+// For fixed size scalar types(int/float), T should be the same as ST\n+// For var size typse(string), when using dict encoding, ST may be integer\n+//\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T>\n+class TypedColumnReader : public ColumnReader {\n+public:\n+    TypedColumnReader(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnReader<T, Nullable, ST>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    Status get_block(size_t nrows, size_t bid, ColumnBlockHolder* cbh) const {\n+        bool base_only = true;\n+        for (size_t i = 0; i < _deltas.size(); ++i) {\n+            if (_deltas[i]->contains_block(bid)) {\n+                base_only = false;\n+                break;\n+            }\n+        }\n+        auto& block = (*_base)[bid];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NzgzNw==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426447837", "createdAt": "2020-05-18T08:19:22Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const RW& rw, const uint32_t rid) {\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < rw._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*rw._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        bool isnull = (*rw._base)[bid]->is_null(idx);\n+        if (isnull) {\n+            return nullptr;\n+        } else {\n+            return &((*rw._base)[bid]->data().template as<ST>()[idx]);\n+        }\n+    } else {\n+        return &((*rw._base)[bid]->data().template as<ST>()[idx]);\n+    }\n+}\n+\n+// Get a cell's hashcode of a typed array\n+template <class T, class ST>\n+inline uint64_t TypedColumnHashcode(const void* rhs, size_t rhs_idx) {\n+    if (std::is_same<T, ST>::value) {\n+        const T* prhs = ((const T*)rhs) + rhs_idx;\n+        return HashUtil::fnv_hash64(prhs, sizeof(T), 0);\n+    } else {\n+        // TODO: support other type's hash\n+        return 0;\n+    }\n+}\n+\n+// Compare equality of a typed array's cell with this column's cell\n+template <class RW, class T, bool Nullable, class ST>\n+bool TypedColumnEquals(const RW& rw, const uint32_t rid, const void* rhs, size_t rhs_idx) {\n+    const T& rhs_value = ((const T*)rhs)[rhs_idx];\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                CHECK(false) << \"only used for key column\";\n+                return false;\n+            } else {\n+                return (pdelta->data().template as<T>()[pos]) == rhs_value;\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < rw._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*rw._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        CHECK(false) << \"only used for key column\";\n+        return false;\n+    } else {\n+        DCHECK(rhs);\n+        return ((*rw._base)[bid]->data().template as<T>()[idx]) == rhs_value;\n+    }\n+}\n+\n+// ColumnReader typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+//\n+// Template type meanings:\n+// T: column type used for interface\n+// Nullable: whether column type is nullable\n+// ST: column type used for internal storage\n+//\n+// For fixed size scalar types(int/float), T should be the same as ST\n+// For var size typse(string), when using dict encoding, ST may be integer\n+//\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T>\n+class TypedColumnReader : public ColumnReader {\n+public:\n+    TypedColumnReader(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnReader<T, Nullable, ST>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    Status get_block(size_t nrows, size_t bid, ColumnBlockHolder* cbh) const {\n+        bool base_only = true;\n+        for (size_t i = 0; i < _deltas.size(); ++i) {\n+            if (_deltas[i]->contains_block(bid)) {\n+                base_only = false;\n+                break;\n+            }\n+        }\n+        auto& block = (*_base)[bid];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNjM1MA=="}, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTIyOTQxOnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/typed_column_writer.h", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMjoyMzo1OFrOGWlxHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTowNDo1OFrOGXW8iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MDYzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                  vector<ColumnDelta*>&& deltas)\n          \n          \n            \n                                  vector<ColumnDelta*> deltas)", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426340637", "createdAt": "2020-05-18T02:23:58Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/typed_column_writer.h", "diffHunk": "@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/typed_column_reader.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Used to hold temporary nullable update cells in ColumnWriter\n+template <class T>\n+class NullableUpdateType {\n+public:\n+    bool& isnull() { return _isnull; }\n+    T& value() { return _value; }\n+\n+private:\n+    bool _isnull;\n+    T _value;\n+};\n+\n+// Used to hold temporary update cells in ColumnWriter\n+template <class T>\n+class UpdateType {\n+public:\n+    bool& isnull() { return *static_cast<bool*>(0); /*unused*/ }\n+    T& value() { return _value; }\n+\n+private:\n+    T _value;\n+};\n+\n+// ColumnWriter typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T, class UT = T>\n+class TypedColumnWriter : public ColumnWriter {\n+public:\n+    TypedColumnWriter(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NjUzMw==", "bodyText": "why? This is intended for move semantics", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426446533", "createdAt": "2020-05-18T08:17:13Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/typed_column_writer.h", "diffHunk": "@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/typed_column_reader.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Used to hold temporary nullable update cells in ColumnWriter\n+template <class T>\n+class NullableUpdateType {\n+public:\n+    bool& isnull() { return _isnull; }\n+    T& value() { return _value; }\n+\n+private:\n+    bool _isnull;\n+    T _value;\n+};\n+\n+// Used to hold temporary update cells in ColumnWriter\n+template <class T>\n+class UpdateType {\n+public:\n+    bool& isnull() { return *static_cast<bool*>(0); /*unused*/ }\n+    T& value() { return _value; }\n+\n+private:\n+    T _value;\n+};\n+\n+// ColumnWriter typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T, class UT = T>\n+class TypedColumnWriter : public ColumnWriter {\n+public:\n+    TypedColumnWriter(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MDYzNw=="}, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0NjM3Ng==", "bodyText": "Value passing is the same with rvalue reference and const left reference.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r427146376", "createdAt": "2020-05-19T09:04:58Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/typed_column_writer.h", "diffHunk": "@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/typed_column_reader.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Used to hold temporary nullable update cells in ColumnWriter\n+template <class T>\n+class NullableUpdateType {\n+public:\n+    bool& isnull() { return _isnull; }\n+    T& value() { return _value; }\n+\n+private:\n+    bool _isnull;\n+    T _value;\n+};\n+\n+// Used to hold temporary update cells in ColumnWriter\n+template <class T>\n+class UpdateType {\n+public:\n+    bool& isnull() { return *static_cast<bool*>(0); /*unused*/ }\n+    T& value() { return _value; }\n+\n+private:\n+    T _value;\n+};\n+\n+// ColumnWriter typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T, class UT = T>\n+class TypedColumnWriter : public ColumnWriter {\n+public:\n+    TypedColumnWriter(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MDYzNw=="}, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTIzNDQ0OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/typed_column_reader.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMjoyODoxOVrOGWl0Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODoxOTozOFrOGWsUpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MTQyNg==", "bodyText": "more comments for arguments. I'm not very clear about what does rw stands for?", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426341426", "createdAt": "2020-05-18T02:28:19Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const RW& rw, const uint32_t rid) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0ODAzOA==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426448038", "createdAt": "2020-05-18T08:19:38Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const RW& rw, const uint32_t rid) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MTQyNg=="}, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTIzNzg5OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/column_writer.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMjozMDo1NlrOGWl2LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODoyMToyMVrOGWsYxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MTkzMw==", "bodyText": "Why does a writer need a get interface? Better to comment.\nAnd so does equals interface.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426341933", "createdAt": "2020-05-18T02:30:56Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->create_writer(&writer).ok());\n+//   writer->insert(new_rowid, &value);\n+//   writer->update(rowid, &value);\n+//   writer->finalize(new_version);\n+//   // get new column refptr\n+//   // if a COW has been done, column will point to new column object\n+//   // else column will remain the same.\n+//   writer->get_new_column(&column);\n+class ColumnWriter {\n+public:\n+    virtual ~ColumnWriter() {}\n+\n+    // Get cell by rid, caller needs to make sure rid is in valid range\n+    //\n+    // Note: this is the same method as ColumnReader::get\n+    virtual const void* get(const uint32_t rid) const = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0OTA5NQ==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426449095", "createdAt": "2020-05-18T08:21:21Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->create_writer(&writer).ok());\n+//   writer->insert(new_rowid, &value);\n+//   writer->update(rowid, &value);\n+//   writer->finalize(new_version);\n+//   // get new column refptr\n+//   // if a COW has been done, column will point to new column object\n+//   // else column will remain the same.\n+//   writer->get_new_column(&column);\n+class ColumnWriter {\n+public:\n+    virtual ~ColumnWriter() {}\n+\n+    // Get cell by rid, caller needs to make sure rid is in valid range\n+    //\n+    // Note: this is the same method as ColumnReader::get\n+    virtual const void* get(const uint32_t rid) const = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MTkzMw=="}, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTI0MDM2OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/typed_column_reader.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMjozMzoxNlrOGWl3ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODoyMTozMFrOGWsZJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MjMzMA==", "bodyText": "Is it better to define a macro for BLOCK_SIZE and write some inline functions to get block id from row id and row offset in a block.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426342330", "createdAt": "2020-05-18T02:33:16Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const RW& rw, const uint32_t rid) {\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0OTE5MQ==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426449191", "createdAt": "2020-05-18T08:21:30Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const RW& rw, const uint32_t rid) {\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MjMzMA=="}, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTI3MDM5OnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/typed_column_writer.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMjo1NzoyOVrOGWmJnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODowNDowNVrOGWrwdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0NjkxMQ==", "bodyText": "Better to leave a CHECK(false) to make process crash", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426346911", "createdAt": "2020-05-18T02:57:29Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/typed_column_writer.h", "diffHunk": "@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/typed_column_reader.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Used to hold temporary nullable update cells in ColumnWriter\n+template <class T>\n+class NullableUpdateType {\n+public:\n+    bool& isnull() { return _isnull; }\n+    T& value() { return _value; }\n+\n+private:\n+    bool _isnull;\n+    T _value;\n+};\n+\n+// Used to hold temporary update cells in ColumnWriter\n+template <class T>\n+class UpdateType {\n+public:\n+    bool& isnull() { return *static_cast<bool*>(0); /*unused*/ }\n+    T& value() { return _value; }\n+\n+private:\n+    T _value;\n+};\n+\n+// ColumnWriter typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T, class UT = T>\n+class TypedColumnWriter : public ColumnWriter {\n+public:\n+    TypedColumnWriter(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnWriter<T, Nullable, ST, UT>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    uint64_t hashcode(const void* rhs, size_t rhs_idx) const {\n+        return TypedColumnHashcode<T, ST>(rhs, rhs_idx);\n+    }\n+\n+    bool equals(const uint32_t rid, const void* rhs, size_t rhs_idx) const {\n+        return TypedColumnEquals<TypedColumnWriter<T, Nullable, ST, UT>, T, Nullable, ST>(\n+                *this, rid, rhs, rhs_idx);\n+    }\n+\n+    string debug_string() const {\n+        return StringPrintf(\"%s version=%zu(real=%zu) ndelta=%zu insert:%zu update:%zu\",\n+                            _column->debug_string().c_str(), _version, _real_version,\n+                            _deltas.size(), _num_insert, _num_update);\n+    }\n+\n+    Status insert(uint32_t rid, const void* value) {\n+        uint32_t bid = rid >> 16;\n+        if (bid >= _base->size()) {\n+            RETURN_IF_ERROR(add_block());\n+            // add one block should be enough\n+            CHECK(bid < _base->size());\n+        }\n+        auto& block = (*_base)[bid];\n+        uint32_t idx = rid & 0xffff;\n+        DCHECK(idx * sizeof(T) < block->data().bsize());\n+        if (Nullable) {\n+            if (value) {\n+                if (std::is_same<T, ST>::value) {\n+                    block->set_not_null(idx);\n+                    block->data().as<ST>()[idx] = *static_cast<const ST*>(value);\n+                } else {\n+                    // TODO: string support\n+                }\n+            } else {\n+                block->set_null(idx);\n+            }\n+        } else {\n+            DCHECK(value);\n+            if (std::is_same<T, ST>::value) {\n+                block->data().as<ST>()[idx] = *static_cast<const ST*>(value);\n+            } else {\n+                // TODO: string support", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzODc3Mg==", "bodyText": "fixed", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426438772", "createdAt": "2020-05-18T08:04:05Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/typed_column_writer.h", "diffHunk": "@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/typed_column_reader.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Used to hold temporary nullable update cells in ColumnWriter\n+template <class T>\n+class NullableUpdateType {\n+public:\n+    bool& isnull() { return _isnull; }\n+    T& value() { return _value; }\n+\n+private:\n+    bool _isnull;\n+    T _value;\n+};\n+\n+// Used to hold temporary update cells in ColumnWriter\n+template <class T>\n+class UpdateType {\n+public:\n+    bool& isnull() { return *static_cast<bool*>(0); /*unused*/ }\n+    T& value() { return _value; }\n+\n+private:\n+    T _value;\n+};\n+\n+// ColumnWriter typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T, class UT = T>\n+class TypedColumnWriter : public ColumnWriter {\n+public:\n+    TypedColumnWriter(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnWriter<T, Nullable, ST, UT>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    uint64_t hashcode(const void* rhs, size_t rhs_idx) const {\n+        return TypedColumnHashcode<T, ST>(rhs, rhs_idx);\n+    }\n+\n+    bool equals(const uint32_t rid, const void* rhs, size_t rhs_idx) const {\n+        return TypedColumnEquals<TypedColumnWriter<T, Nullable, ST, UT>, T, Nullable, ST>(\n+                *this, rid, rhs, rhs_idx);\n+    }\n+\n+    string debug_string() const {\n+        return StringPrintf(\"%s version=%zu(real=%zu) ndelta=%zu insert:%zu update:%zu\",\n+                            _column->debug_string().c_str(), _version, _real_version,\n+                            _deltas.size(), _num_insert, _num_update);\n+    }\n+\n+    Status insert(uint32_t rid, const void* value) {\n+        uint32_t bid = rid >> 16;\n+        if (bid >= _base->size()) {\n+            RETURN_IF_ERROR(add_block());\n+            // add one block should be enough\n+            CHECK(bid < _base->size());\n+        }\n+        auto& block = (*_base)[bid];\n+        uint32_t idx = rid & 0xffff;\n+        DCHECK(idx * sizeof(T) < block->data().bsize());\n+        if (Nullable) {\n+            if (value) {\n+                if (std::is_same<T, ST>::value) {\n+                    block->set_not_null(idx);\n+                    block->data().as<ST>()[idx] = *static_cast<const ST*>(value);\n+                } else {\n+                    // TODO: string support\n+                }\n+            } else {\n+                block->set_null(idx);\n+            }\n+        } else {\n+            DCHECK(value);\n+            if (std::is_same<T, ST>::value) {\n+                block->data().as<ST>()[idx] = *static_cast<const ST*>(value);\n+            } else {\n+                // TODO: string support", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0NjkxMQ=="}, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTI3ODAxOnYy", "diffSide": "RIGHT", "path": "be/src/olap/memory/typed_column_writer.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMzowNDoyMVrOGWmORA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODowMzozMlrOGWrvMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0ODEwMA==", "bodyText": "why not use unordered_map?", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426348100", "createdAt": "2020-05-18T03:04:21Z", "author": {"login": "imay"}, "path": "be/src/olap/memory/typed_column_writer.h", "diffHunk": "@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/typed_column_reader.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Used to hold temporary nullable update cells in ColumnWriter\n+template <class T>\n+class NullableUpdateType {\n+public:\n+    bool& isnull() { return _isnull; }\n+    T& value() { return _value; }\n+\n+private:\n+    bool _isnull;\n+    T _value;\n+};\n+\n+// Used to hold temporary update cells in ColumnWriter\n+template <class T>\n+class UpdateType {\n+public:\n+    bool& isnull() { return *static_cast<bool*>(0); /*unused*/ }\n+    T& value() { return _value; }\n+\n+private:\n+    T _value;\n+};\n+\n+// ColumnWriter typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T, class UT = T>\n+class TypedColumnWriter : public ColumnWriter {\n+public:\n+    TypedColumnWriter(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnWriter<T, Nullable, ST, UT>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    uint64_t hashcode(const void* rhs, size_t rhs_idx) const {\n+        return TypedColumnHashcode<T, ST>(rhs, rhs_idx);\n+    }\n+\n+    bool equals(const uint32_t rid, const void* rhs, size_t rhs_idx) const {\n+        return TypedColumnEquals<TypedColumnWriter<T, Nullable, ST, UT>, T, Nullable, ST>(\n+                *this, rid, rhs, rhs_idx);\n+    }\n+\n+    string debug_string() const {\n+        return StringPrintf(\"%s version=%zu(real=%zu) ndelta=%zu insert:%zu update:%zu\",\n+                            _column->debug_string().c_str(), _version, _real_version,\n+                            _deltas.size(), _num_insert, _num_update);\n+    }\n+\n+    Status insert(uint32_t rid, const void* value) {\n+        uint32_t bid = rid >> 16;\n+        if (bid >= _base->size()) {\n+            RETURN_IF_ERROR(add_block());\n+            // add one block should be enough\n+            CHECK(bid < _base->size());\n+        }\n+        auto& block = (*_base)[bid];\n+        uint32_t idx = rid & 0xffff;\n+        DCHECK(idx * sizeof(T) < block->data().bsize());\n+        if (Nullable) {\n+            if (value) {\n+                if (std::is_same<T, ST>::value) {\n+                    block->set_not_null(idx);\n+                    block->data().as<ST>()[idx] = *static_cast<const ST*>(value);\n+                } else {\n+                    // TODO: string support\n+                }\n+            } else {\n+                block->set_null(idx);\n+            }\n+        } else {\n+            DCHECK(value);\n+            if (std::is_same<T, ST>::value) {\n+                block->data().as<ST>()[idx] = *static_cast<const ST*>(value);\n+            } else {\n+                // TODO: string support\n+            }\n+        }\n+        _num_insert++;\n+        return Status::OK();\n+    }\n+\n+    Status update(uint32_t rid, const void* value) {\n+        DCHECK_LT(rid, _base->size() * Column::BLOCK_SIZE);\n+        if (Nullable) {\n+            auto& uv = _updates[rid];\n+            if (value) {\n+                uv.isnull() = false;\n+                if (std::is_same<T, ST>::value) {\n+                    uv.value() = *reinterpret_cast<const T*>(value);\n+                } else {\n+                    // TODO: string support\n+                }\n+            } else {\n+                _update_has_null = true;\n+                uv.isnull() = true;\n+                if (std::is_same<T, ST>::value) {\n+                    uv.value() = (T)0;\n+                } else {\n+                    // TODO: string support\n+                }\n+            }\n+        } else {\n+            auto& uv = _updates[rid];\n+            DCHECK(value);\n+            if (std::is_same<T, ST>::value) {\n+                uv.value() = *static_cast<const ST*>(value);\n+            } else {\n+                // TODO: string support\n+            }\n+        }\n+        _num_update++;\n+        return Status::OK();\n+    }\n+\n+    Status finalize(uint64_t version) {\n+        if (_updates.size() == 0) {\n+            // insert(append) only\n+            return Status::OK();\n+        }\n+        // prepare delta\n+        size_t nblock = _base->size();\n+        scoped_refptr<ColumnDelta> delta(new ColumnDelta());\n+        RETURN_IF_ERROR(delta->alloc(nblock, _updates.size(), sizeof(ST), _update_has_null));\n+        DeltaIndex* index = delta->index();\n+        vector<uint32_t>& block_ends = index->block_ends();\n+        Buffer& idxdata = index->data();\n+        Buffer& data = delta->data();\n+        Buffer& nulls = delta->nulls();\n+        uint32_t cidx = 0;\n+        uint32_t curbid = 0;\n+        for (auto& e : _updates) {\n+            uint32_t rid = e.first;\n+            uint32_t bid = rid >> 16;\n+            while (curbid < bid) {\n+                block_ends[curbid] = cidx;\n+                curbid++;\n+            }\n+            idxdata.as<uint16_t>()[cidx] = rid & 0xffff;\n+            if (Nullable) {\n+                bool isnull = e.second.isnull();\n+                if (isnull) {\n+                    nulls.as<bool>()[cidx] = true;\n+                } else {\n+                    data.as<ST>()[cidx] = e.second.value();\n+                }\n+            } else {\n+                data.as<ST>()[cidx] = e.second.value();\n+            }\n+            cidx++;\n+        }\n+        while (curbid < nblock) {\n+            block_ends[curbid] = cidx;\n+            curbid++;\n+        }\n+        _updates.clear();\n+        RETURN_IF_ERROR(add_delta(std::move(delta), version));\n+        return Status::OK();\n+    }\n+\n+    Status get_new_column(scoped_refptr<Column>* ret) {\n+        if (*ret != _column) {\n+            DLOG(INFO) << StringPrintf(\"%s switch new column\", _column->debug_string().c_str());\n+            (*ret).swap(_column);\n+            _column.reset();\n+        }\n+        return Status::OK();\n+    }\n+\n+private:\n+    // Expand base vector, do a copy-on-write\n+    Status expand_base() {\n+        size_t added = std::min((size_t)Column::BASE_CAPACITY_MAX_STEP_SIZE, _base->capacity());\n+        size_t new_base_capacity =\n+                padding(_base->capacity() + added, Column::BASE_CAPACITY_MIN_STEP_SIZE);\n+        // check if version needs expanding too\n+        size_t new_version_capacity = 0;\n+        if (_column->_versions.size() == _column->_versions.capacity()) {\n+            new_version_capacity =\n+                    padding(_column->_versions.capacity() + Column::VERSION_CAPACITY_STEP_SIZE,\n+                            Column::VERSION_CAPACITY_STEP_SIZE);\n+        }\n+        // check pool doesn't need expanding\n+        DCHECK_EQ(_base->size(), _base->capacity());\n+        DCHECK(_base->capacity() < new_base_capacity);\n+        DLOG(INFO) << StringPrintf(\"%s memory=%.1lfM expand base base=%zu version=%zu\",\n+                                   _column->schema().debug_string().c_str(),\n+                                   _column->memory() / 1000000.0, new_base_capacity,\n+                                   new_version_capacity);\n+        scoped_refptr<Column> cow(\n+                new Column(*_column.get(), new_base_capacity, new_version_capacity));\n+        cow.swap(_column);\n+        _base = &(_column->_base);\n+        return Status::OK();\n+    }\n+\n+    // Try to append a new block to this column, if base vector is at it's capacity,\n+    // call expand base.\n+    Status add_block() {\n+        if (_base->size() == _base->capacity()) {\n+            RETURN_IF_ERROR(expand_base());\n+        }\n+        CHECK_LT(_base->size(), _base->capacity());\n+        scoped_refptr<ColumnBlock> block(new ColumnBlock());\n+        RETURN_IF_ERROR(block->alloc(Column::BLOCK_SIZE, sizeof(ST)));\n+        _base->emplace_back(std::move(block));\n+        if (_column->schema().cid() == 1) {\n+            // only log when first column add block\n+            DLOG(INFO) << StringPrintf(\"Column(cid=%u) add ColumnBlock %zu/%zu\",\n+                                       _column->schema().cid(), _base->size(), _base->capacity());\n+        }\n+        return Status::OK();\n+    }\n+\n+    // Expand versions vector, do a copy-on-write\n+    Status expand_versions() {\n+        size_t new_capacity =\n+                padding(_column->_versions.capacity() + Column::VERSION_CAPACITY_STEP_SIZE,\n+                        Column::VERSION_CAPACITY_STEP_SIZE);\n+        DLOG(INFO) << StringPrintf(\"%s memory=%.1lfM expand delta base=%zu version=%zu\",\n+                                   _column->schema().debug_string().c_str(),\n+                                   _column->memory() / 1000000.0, _base->capacity(), new_capacity);\n+        scoped_refptr<Column> cow(new Column(*_column.get(), 0, new_capacity));\n+        cow.swap(_column);\n+        return Status::OK();\n+    }\n+\n+    // Try to add a new delta to versions vector, if versions vector is at it's capcacity,\n+    // call expand versions\n+    Status add_delta(scoped_refptr<ColumnDelta>&& delta, uint64_t version) {\n+        if (_column->_versions.size() == _column->_versions.capacity()) {\n+            expand_versions();\n+        }\n+        DLOG(INFO) << StringPrintf(\"%s add version %zu update: %zu\",\n+                                   _column->debug_string().c_str(), version, delta->size());\n+        CHECK_LT(_column->_versions.size(), _column->_versions.capacity());\n+        _column->_versions.emplace_back();\n+        Column::VersionInfo& vinfo = _column->_versions.back();\n+        vinfo.version = version;\n+        vinfo.delta = delta;\n+        return Status::OK();\n+    }\n+\n+    template <class Reader, class T2, bool Nullable2, class ST2>\n+    friend const void* TypedColumnGet(const Reader& reader, const uint32_t rid);\n+\n+    template <class T2, class ST2>\n+    friend bool TypedColumnHashcode(const void*, size_t);\n+\n+    template <class Reader, class T2, bool Nullable2, class ST2>\n+    friend bool TypedColumnEquals(const Reader&, const uint32_t, const void*, size_t);\n+\n+    // The following members need to be identical to TypedColumnReader\n+    // because they share same reader methods: get/hashcode/equals\n+    scoped_refptr<Column> _column;\n+    vector<scoped_refptr<ColumnBlock>>* _base;\n+    uint64_t _version;\n+    uint64_t _real_version;\n+    vector<ColumnDelta*> _deltas;\n+\n+    size_t _num_insert = 0;\n+    size_t _num_update = 0;\n+    bool _update_has_null = false;\n+    typedef typename std::conditional<Nullable, NullableUpdateType<UT>, UpdateType<UT>>::type\n+            UpdateMapType;\n+    // Temporary stoarage to hold all updated cells' values\n+    // rowid -> updated values\n+    std::map<uint32_t, UpdateMapType> _updates;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzODQ1MA==", "bodyText": "updates will be finalized to delta, and delta_index needs to be in order, std::map has order.", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426438450", "createdAt": "2020-05-18T08:03:32Z", "author": {"login": "decster"}, "path": "be/src/olap/memory/typed_column_writer.h", "diffHunk": "@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/typed_column_reader.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Used to hold temporary nullable update cells in ColumnWriter\n+template <class T>\n+class NullableUpdateType {\n+public:\n+    bool& isnull() { return _isnull; }\n+    T& value() { return _value; }\n+\n+private:\n+    bool _isnull;\n+    T _value;\n+};\n+\n+// Used to hold temporary update cells in ColumnWriter\n+template <class T>\n+class UpdateType {\n+public:\n+    bool& isnull() { return *static_cast<bool*>(0); /*unused*/ }\n+    T& value() { return _value; }\n+\n+private:\n+    T _value;\n+};\n+\n+// ColumnWriter typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T, class UT = T>\n+class TypedColumnWriter : public ColumnWriter {\n+public:\n+    TypedColumnWriter(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnWriter<T, Nullable, ST, UT>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    uint64_t hashcode(const void* rhs, size_t rhs_idx) const {\n+        return TypedColumnHashcode<T, ST>(rhs, rhs_idx);\n+    }\n+\n+    bool equals(const uint32_t rid, const void* rhs, size_t rhs_idx) const {\n+        return TypedColumnEquals<TypedColumnWriter<T, Nullable, ST, UT>, T, Nullable, ST>(\n+                *this, rid, rhs, rhs_idx);\n+    }\n+\n+    string debug_string() const {\n+        return StringPrintf(\"%s version=%zu(real=%zu) ndelta=%zu insert:%zu update:%zu\",\n+                            _column->debug_string().c_str(), _version, _real_version,\n+                            _deltas.size(), _num_insert, _num_update);\n+    }\n+\n+    Status insert(uint32_t rid, const void* value) {\n+        uint32_t bid = rid >> 16;\n+        if (bid >= _base->size()) {\n+            RETURN_IF_ERROR(add_block());\n+            // add one block should be enough\n+            CHECK(bid < _base->size());\n+        }\n+        auto& block = (*_base)[bid];\n+        uint32_t idx = rid & 0xffff;\n+        DCHECK(idx * sizeof(T) < block->data().bsize());\n+        if (Nullable) {\n+            if (value) {\n+                if (std::is_same<T, ST>::value) {\n+                    block->set_not_null(idx);\n+                    block->data().as<ST>()[idx] = *static_cast<const ST*>(value);\n+                } else {\n+                    // TODO: string support\n+                }\n+            } else {\n+                block->set_null(idx);\n+            }\n+        } else {\n+            DCHECK(value);\n+            if (std::is_same<T, ST>::value) {\n+                block->data().as<ST>()[idx] = *static_cast<const ST*>(value);\n+            } else {\n+                // TODO: string support\n+            }\n+        }\n+        _num_insert++;\n+        return Status::OK();\n+    }\n+\n+    Status update(uint32_t rid, const void* value) {\n+        DCHECK_LT(rid, _base->size() * Column::BLOCK_SIZE);\n+        if (Nullable) {\n+            auto& uv = _updates[rid];\n+            if (value) {\n+                uv.isnull() = false;\n+                if (std::is_same<T, ST>::value) {\n+                    uv.value() = *reinterpret_cast<const T*>(value);\n+                } else {\n+                    // TODO: string support\n+                }\n+            } else {\n+                _update_has_null = true;\n+                uv.isnull() = true;\n+                if (std::is_same<T, ST>::value) {\n+                    uv.value() = (T)0;\n+                } else {\n+                    // TODO: string support\n+                }\n+            }\n+        } else {\n+            auto& uv = _updates[rid];\n+            DCHECK(value);\n+            if (std::is_same<T, ST>::value) {\n+                uv.value() = *static_cast<const ST*>(value);\n+            } else {\n+                // TODO: string support\n+            }\n+        }\n+        _num_update++;\n+        return Status::OK();\n+    }\n+\n+    Status finalize(uint64_t version) {\n+        if (_updates.size() == 0) {\n+            // insert(append) only\n+            return Status::OK();\n+        }\n+        // prepare delta\n+        size_t nblock = _base->size();\n+        scoped_refptr<ColumnDelta> delta(new ColumnDelta());\n+        RETURN_IF_ERROR(delta->alloc(nblock, _updates.size(), sizeof(ST), _update_has_null));\n+        DeltaIndex* index = delta->index();\n+        vector<uint32_t>& block_ends = index->block_ends();\n+        Buffer& idxdata = index->data();\n+        Buffer& data = delta->data();\n+        Buffer& nulls = delta->nulls();\n+        uint32_t cidx = 0;\n+        uint32_t curbid = 0;\n+        for (auto& e : _updates) {\n+            uint32_t rid = e.first;\n+            uint32_t bid = rid >> 16;\n+            while (curbid < bid) {\n+                block_ends[curbid] = cidx;\n+                curbid++;\n+            }\n+            idxdata.as<uint16_t>()[cidx] = rid & 0xffff;\n+            if (Nullable) {\n+                bool isnull = e.second.isnull();\n+                if (isnull) {\n+                    nulls.as<bool>()[cidx] = true;\n+                } else {\n+                    data.as<ST>()[cidx] = e.second.value();\n+                }\n+            } else {\n+                data.as<ST>()[cidx] = e.second.value();\n+            }\n+            cidx++;\n+        }\n+        while (curbid < nblock) {\n+            block_ends[curbid] = cidx;\n+            curbid++;\n+        }\n+        _updates.clear();\n+        RETURN_IF_ERROR(add_delta(std::move(delta), version));\n+        return Status::OK();\n+    }\n+\n+    Status get_new_column(scoped_refptr<Column>* ret) {\n+        if (*ret != _column) {\n+            DLOG(INFO) << StringPrintf(\"%s switch new column\", _column->debug_string().c_str());\n+            (*ret).swap(_column);\n+            _column.reset();\n+        }\n+        return Status::OK();\n+    }\n+\n+private:\n+    // Expand base vector, do a copy-on-write\n+    Status expand_base() {\n+        size_t added = std::min((size_t)Column::BASE_CAPACITY_MAX_STEP_SIZE, _base->capacity());\n+        size_t new_base_capacity =\n+                padding(_base->capacity() + added, Column::BASE_CAPACITY_MIN_STEP_SIZE);\n+        // check if version needs expanding too\n+        size_t new_version_capacity = 0;\n+        if (_column->_versions.size() == _column->_versions.capacity()) {\n+            new_version_capacity =\n+                    padding(_column->_versions.capacity() + Column::VERSION_CAPACITY_STEP_SIZE,\n+                            Column::VERSION_CAPACITY_STEP_SIZE);\n+        }\n+        // check pool doesn't need expanding\n+        DCHECK_EQ(_base->size(), _base->capacity());\n+        DCHECK(_base->capacity() < new_base_capacity);\n+        DLOG(INFO) << StringPrintf(\"%s memory=%.1lfM expand base base=%zu version=%zu\",\n+                                   _column->schema().debug_string().c_str(),\n+                                   _column->memory() / 1000000.0, new_base_capacity,\n+                                   new_version_capacity);\n+        scoped_refptr<Column> cow(\n+                new Column(*_column.get(), new_base_capacity, new_version_capacity));\n+        cow.swap(_column);\n+        _base = &(_column->_base);\n+        return Status::OK();\n+    }\n+\n+    // Try to append a new block to this column, if base vector is at it's capacity,\n+    // call expand base.\n+    Status add_block() {\n+        if (_base->size() == _base->capacity()) {\n+            RETURN_IF_ERROR(expand_base());\n+        }\n+        CHECK_LT(_base->size(), _base->capacity());\n+        scoped_refptr<ColumnBlock> block(new ColumnBlock());\n+        RETURN_IF_ERROR(block->alloc(Column::BLOCK_SIZE, sizeof(ST)));\n+        _base->emplace_back(std::move(block));\n+        if (_column->schema().cid() == 1) {\n+            // only log when first column add block\n+            DLOG(INFO) << StringPrintf(\"Column(cid=%u) add ColumnBlock %zu/%zu\",\n+                                       _column->schema().cid(), _base->size(), _base->capacity());\n+        }\n+        return Status::OK();\n+    }\n+\n+    // Expand versions vector, do a copy-on-write\n+    Status expand_versions() {\n+        size_t new_capacity =\n+                padding(_column->_versions.capacity() + Column::VERSION_CAPACITY_STEP_SIZE,\n+                        Column::VERSION_CAPACITY_STEP_SIZE);\n+        DLOG(INFO) << StringPrintf(\"%s memory=%.1lfM expand delta base=%zu version=%zu\",\n+                                   _column->schema().debug_string().c_str(),\n+                                   _column->memory() / 1000000.0, _base->capacity(), new_capacity);\n+        scoped_refptr<Column> cow(new Column(*_column.get(), 0, new_capacity));\n+        cow.swap(_column);\n+        return Status::OK();\n+    }\n+\n+    // Try to add a new delta to versions vector, if versions vector is at it's capcacity,\n+    // call expand versions\n+    Status add_delta(scoped_refptr<ColumnDelta>&& delta, uint64_t version) {\n+        if (_column->_versions.size() == _column->_versions.capacity()) {\n+            expand_versions();\n+        }\n+        DLOG(INFO) << StringPrintf(\"%s add version %zu update: %zu\",\n+                                   _column->debug_string().c_str(), version, delta->size());\n+        CHECK_LT(_column->_versions.size(), _column->_versions.capacity());\n+        _column->_versions.emplace_back();\n+        Column::VersionInfo& vinfo = _column->_versions.back();\n+        vinfo.version = version;\n+        vinfo.delta = delta;\n+        return Status::OK();\n+    }\n+\n+    template <class Reader, class T2, bool Nullable2, class ST2>\n+    friend const void* TypedColumnGet(const Reader& reader, const uint32_t rid);\n+\n+    template <class T2, class ST2>\n+    friend bool TypedColumnHashcode(const void*, size_t);\n+\n+    template <class Reader, class T2, bool Nullable2, class ST2>\n+    friend bool TypedColumnEquals(const Reader&, const uint32_t, const void*, size_t);\n+\n+    // The following members need to be identical to TypedColumnReader\n+    // because they share same reader methods: get/hashcode/equals\n+    scoped_refptr<Column> _column;\n+    vector<scoped_refptr<ColumnBlock>>* _base;\n+    uint64_t _version;\n+    uint64_t _real_version;\n+    vector<ColumnDelta*> _deltas;\n+\n+    size_t _num_insert = 0;\n+    size_t _num_update = 0;\n+    bool _update_has_null = false;\n+    typedef typename std::conditional<Nullable, NullableUpdateType<UT>, UpdateType<UT>>::type\n+            UpdateMapType;\n+    // Temporary stoarage to hold all updated cells' values\n+    // rowid -> updated values\n+    std::map<uint32_t, UpdateMapType> _updates;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0ODEwMA=="}, "originalCommit": {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d"}, "originalPosition": 301}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1546, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}