{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNDE1NTA3", "number": 4005, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTo1MzozOFrOEK9iZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMTo0MDozMFrOEbh0Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTI5NDQ0OnYy", "diffSide": "RIGHT", "path": "be/src/common/config.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTo1MzozOFrOGsTuiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTo1MzozOFrOGsTuiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExMzczOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                CONF_Int32(cache_max_size, \"256\"); \n          \n          \n            \n                CONF_Int32(query_cache_max_size_mb, \"256\"); \n          \n      \n    \n    \n  \n\nsame suggestion for other 2 configs.", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r449113739", "createdAt": "2020-07-02T15:53:38Z", "author": {"login": "morningman"}, "path": "be/src/common/config.h", "diffHunk": "@@ -536,6 +536,15 @@ namespace config {\n     // Whether to continue to start be when load tablet from header failed.\n     CONF_Bool(ignore_load_tablet_failure, \"false\");\n \n+    // Set max cache's size of query results, the unit is M byte\n+    CONF_Int32(cache_max_size, \"256\"); ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd48f2a43421990e51aa628f6e5adfbb330862f3"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTMwNDE3OnYy", "diffSide": "RIGHT", "path": "be/src/util/doris_metrics.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTo1NjowMVrOGsT0uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwMTo0MDo1NVrOGshS_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTMyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                REGISTER_DORIS_METRIC(cache_memory_total);\n          \n          \n            \n                REGISTER_DORIS_METRIC(query_cache_memory_total_mb);", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r449115321", "createdAt": "2020-07-02T15:56:01Z", "author": {"login": "morningman"}, "path": "be/src/util/doris_metrics.cpp", "diffHunk": "@@ -161,6 +158,10 @@ DorisMetrics::DorisMetrics() : _name(\"doris_be\"), _hook_name(\"doris_metrics\"), _\n     REGISTER_DORIS_METRIC(tablet_cumulative_max_compaction_score);\n     REGISTER_DORIS_METRIC(tablet_base_max_compaction_score);\n \n+    REGISTER_DORIS_METRIC(cache_memory_total);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd48f2a43421990e51aa628f6e5adfbb330862f3"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMzNjA2Mg==", "bodyText": "query_cache_memory_total is  byte\uff0cREGISTER_DORIS_METRIC(query_cache_memory_total);", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r449336062", "createdAt": "2020-07-03T01:40:55Z", "author": {"login": "marising"}, "path": "be/src/util/doris_metrics.cpp", "diffHunk": "@@ -161,6 +158,10 @@ DorisMetrics::DorisMetrics() : _name(\"doris_be\"), _hook_name(\"doris_metrics\"), _\n     REGISTER_DORIS_METRIC(tablet_cumulative_max_compaction_score);\n     REGISTER_DORIS_METRIC(tablet_base_max_compaction_score);\n \n+    REGISTER_DORIS_METRIC(cache_memory_total);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTMyMQ=="}, "originalCommit": {"oid": "cd48f2a43421990e51aa628f6e5adfbb330862f3"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNDM1ODgwOnYy", "diffSide": "RIGHT", "path": "be/src/runtime/cache/cache_utils.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQwODo0Njo1OFrOGtAyEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNzozNToxM1rOHG_iPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg1MTkyMg==", "bodyText": "Remove unused code", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r449851922", "createdAt": "2020-07-05T08:46:58Z", "author": {"login": "morningman"}, "path": "be/src/runtime/cache/cache_utils.h", "diffHunk": "@@ -0,0 +1,87 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_RUNTIME_CACHE_UTILS_H\n+#define DORIS_BE_SRC_RUNTIME_CACHE_UTILS_H\n+\n+#include <gutil/integral_types.h>\n+#include <sys/time.h>\n+\n+#include <algorithm>\n+#include <boost/thread.hpp>\n+#include <cassert>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <exception>\n+#include <iostream>\n+#include <list>\n+#include <map>\n+#include <shared_mutex>\n+\n+namespace doris {\n+\n+typedef boost::shared_lock<boost::shared_mutex> CacheReadLock;\n+typedef boost::unique_lock<boost::shared_mutex> CacheWriteLock;\n+\n+//#ifndef PARTITION_CACHE_DEV", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "447413f71db843d1ebeef424647515b70f1107d8"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA5NDQ2Mw==", "bodyText": "This is the macro definition of debug, which I use when debugging", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r477094463", "createdAt": "2020-08-26T07:35:13Z", "author": {"login": "marising"}, "path": "be/src/runtime/cache/cache_utils.h", "diffHunk": "@@ -0,0 +1,87 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_RUNTIME_CACHE_UTILS_H\n+#define DORIS_BE_SRC_RUNTIME_CACHE_UTILS_H\n+\n+#include <gutil/integral_types.h>\n+#include <sys/time.h>\n+\n+#include <algorithm>\n+#include <boost/thread.hpp>\n+#include <cassert>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <exception>\n+#include <iostream>\n+#include <list>\n+#include <map>\n+#include <shared_mutex>\n+\n+namespace doris {\n+\n+typedef boost::shared_lock<boost::shared_mutex> CacheReadLock;\n+typedef boost::unique_lock<boost::shared_mutex> CacheWriteLock;\n+\n+//#ifndef PARTITION_CACHE_DEV", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg1MTkyMg=="}, "originalCommit": {"oid": "447413f71db843d1ebeef424647515b70f1107d8"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDExNzE3OnYy", "diffSide": "RIGHT", "path": "be/src/runtime/cache/result_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMTozMDoyMlrOG7cVqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMTozMDoyMlrOG7cVqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4MzQ2NA==", "bodyText": "maybe 45-47 can also put in check_match function, because param has three params.", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r464983464", "createdAt": "2020-08-04T11:30:22Z", "author": {"login": "wutiangan"}, "path": "be/src/runtime/cache/result_node.cpp", "diffHunk": "@@ -0,0 +1,274 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include \"gen_cpp/internal_service.pb.h\"\n+#include \"runtime/cache/result_node.h\"\n+#include \"runtime/cache/cache_utils.h\"\n+\n+namespace doris {\n+\n+bool compare_partition(const PartitionRowBatch* left_node, const PartitionRowBatch* right_node) {\n+    return left_node->get_partition_key() < right_node->get_partition_key();\n+}\n+\n+//return new batch size,only include the size of PRowBatch\n+void PartitionRowBatch::set_row_batch(const PCacheValue& value) {\n+    if (_cache_value != NULL && !check_newer(value.param())) {\n+        LOG(WARNING) << \"set old version data, cache ver:\" << _cache_value->param().last_version()\n+                     << \",cache time:\" << _cache_value->param().last_version_time()\n+                     << \", setdata ver:\" << value.param().last_version()\n+                     << \",setdata time:\" << value.param().last_version_time();\n+        return;\n+    }\n+    SAFE_DELETE(_cache_value);\n+    _cache_value = new PCacheValue(value);\n+    _data_size += _cache_value->data_size();\n+    _cache_stat.update();\n+    LOG(INFO) << \"finish set row batch, row num:\" << _cache_value->row_size()\n+              << \", data size:\" << _data_size;\n+}\n+\n+bool PartitionRowBatch::is_hit_cache(const PCacheParam& param) {\n+    if (param.partition_key() != _partition_key) {\n+        return false;\n+    }\n+    if (!check_match(param)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDI2MzA1OnYy", "diffSide": "RIGHT", "path": "be/src/runtime/cache/result_cache.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMjoxNDo0OFrOG7dsQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMjoxNDo0OFrOG7dsQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAwNTYzMg==", "bodyText": "Maybe push_back is better", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465005632", "createdAt": "2020-08-04T12:14:48Z", "author": {"login": "wutiangan"}, "path": "be/src/runtime/cache/result_cache.cpp", "diffHunk": "@@ -0,0 +1,257 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include \"gen_cpp/internal_service.pb.h\"\n+#include \"runtime/cache/result_cache.h\"\n+#include \"util/doris_metrics.h\"\n+\n+namespace doris {\n+\n+/**\n+* Remove the tail node of link\n+*/\n+ResultNode* ResultNodeList::pop() {\n+    remove(_head);\n+    return _head;\n+}\n+\n+void ResultNodeList::remove(ResultNode* node) {\n+    if (!node) return;\n+    if (node == _head) _head = node->get_next();\n+    if (node == _tail) _tail = node->get_prev();\n+    node->unlink();\n+    _node_count--;\n+}\n+\n+void ResultNodeList::push(ResultNode* node) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDI5NzgxOnYy", "diffSide": "RIGHT", "path": "be/src/runtime/cache/result_cache.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMjoyNDo0NFrOG7eA-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMTo1NzoyOVrOG73aPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxMDkzOA==", "bodyText": "do you need check the status\uff1f", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465010938", "createdAt": "2020-08-04T12:24:44Z", "author": {"login": "wutiangan"}, "path": "be/src/runtime/cache/result_cache.cpp", "diffHunk": "@@ -0,0 +1,257 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include \"gen_cpp/internal_service.pb.h\"\n+#include \"runtime/cache/result_cache.h\"\n+#include \"util/doris_metrics.h\"\n+\n+namespace doris {\n+\n+/**\n+* Remove the tail node of link\n+*/\n+ResultNode* ResultNodeList::pop() {\n+    remove(_head);\n+    return _head;\n+}\n+\n+void ResultNodeList::remove(ResultNode* node) {\n+    if (!node) return;\n+    if (node == _head) _head = node->get_next();\n+    if (node == _tail) _tail = node->get_prev();\n+    node->unlink();\n+    _node_count--;\n+}\n+\n+void ResultNodeList::push(ResultNode* node) {\n+    if (!node) return;\n+    if (!_head) _head = node;\n+    node->append(_tail);\n+    _tail = node;\n+    _node_count++;\n+}\n+\n+void ResultNodeList::move_tail(ResultNode* node) {\n+    if (!node || node == _tail) return;\n+    if (!_head)\n+        _head = node;\n+    else if (node == _head)\n+        _head = node->get_next();\n+    node->unlink();\n+    node->append(_tail);\n+    _tail = node;\n+}\n+\n+void ResultNodeList::clear() {\n+    LOG(INFO) << \"clear result node list.\";\n+    while (_head) {\n+        ResultNode* tmp_node = _head->get_next();\n+        _head->clear();\n+        SAFE_DELETE(_head);\n+        _head = tmp_node;\n+    }\n+    _node_count = 0;\n+}\n+/**\n+ * Find the node and update partition data\n+ * New node, the node updated in the first partition will move to the tail of the list\n+ */\n+void ResultCache::update(const PUpdateCacheRequest* request, PCacheResponse* response) {\n+    ResultNode* node;\n+    PCacheStatus status;\n+    bool update_first = false;\n+    UniqueId sql_key = request->sql_key();\n+    LOG(INFO) << \"update cache, sql key:\" << sql_key;\n+    \n+    CacheWriteLock write_lock(_cache_mtx);\n+    auto it = _node_map.find(sql_key);\n+    if (it != _node_map.end()) {\n+        node = it->second;\n+        _cache_size -= node->get_data_size();\n+        _partition_count -= node->get_partition_count();\n+        status = node->update_partition(request, update_first);\n+    } else {\n+        node = _node_list.new_node(sql_key);\n+        status = node->update_partition(request, update_first);\n+        _node_list.push(node);\n+        _node_map[sql_key] = node;\n+        _node_count += 1;\n+    }\n+    if (update_first) {\n+        _node_list.move_tail(node);\n+    }\n+    _cache_size += node->get_data_size();\n+    _partition_count += node->get_partition_count();\n+    response->set_status(status);\n+\n+    prune();\n+    update_monitor();\n+}\n+\n+/**\n+ * Fetch cache through sql key, partition key, version and time\n+ */\n+void ResultCache::fetch(const PFetchCacheRequest* request, PFetchCacheResult* result) {\n+    bool hit_first = false;\n+    ResultNodeMap::iterator node_it;\n+    const UniqueId sql_key = request->sql_key();\n+    LOG(INFO) << \"fetch cache, sql key:\" << sql_key;\n+    {\n+        CacheReadLock read_lock(_cache_mtx);    \n+        node_it = _node_map.find(sql_key);\n+        if (node_it == _node_map.end()) {\n+            result->set_status(PCacheStatus::NO_SQL_KEY);\n+            LOG(INFO) << \"no such sql key:\" << sql_key;\n+            return;\n+        }\n+        ResultNode* node = node_it->second;\n+        PartitionRowBatchList part_rowbatch_list;\n+        PCacheStatus status = node->fetch_partition(request, part_rowbatch_list, hit_first);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyNzAwNA==", "bodyText": "It does not need to be checked, the status is sent to the FE to record the log. In addition, under normal circumstances, when getting the list, if there is an exception, the number of the list is 0", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465427004", "createdAt": "2020-08-05T01:57:29Z", "author": {"login": "marising"}, "path": "be/src/runtime/cache/result_cache.cpp", "diffHunk": "@@ -0,0 +1,257 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include \"gen_cpp/internal_service.pb.h\"\n+#include \"runtime/cache/result_cache.h\"\n+#include \"util/doris_metrics.h\"\n+\n+namespace doris {\n+\n+/**\n+* Remove the tail node of link\n+*/\n+ResultNode* ResultNodeList::pop() {\n+    remove(_head);\n+    return _head;\n+}\n+\n+void ResultNodeList::remove(ResultNode* node) {\n+    if (!node) return;\n+    if (node == _head) _head = node->get_next();\n+    if (node == _tail) _tail = node->get_prev();\n+    node->unlink();\n+    _node_count--;\n+}\n+\n+void ResultNodeList::push(ResultNode* node) {\n+    if (!node) return;\n+    if (!_head) _head = node;\n+    node->append(_tail);\n+    _tail = node;\n+    _node_count++;\n+}\n+\n+void ResultNodeList::move_tail(ResultNode* node) {\n+    if (!node || node == _tail) return;\n+    if (!_head)\n+        _head = node;\n+    else if (node == _head)\n+        _head = node->get_next();\n+    node->unlink();\n+    node->append(_tail);\n+    _tail = node;\n+}\n+\n+void ResultNodeList::clear() {\n+    LOG(INFO) << \"clear result node list.\";\n+    while (_head) {\n+        ResultNode* tmp_node = _head->get_next();\n+        _head->clear();\n+        SAFE_DELETE(_head);\n+        _head = tmp_node;\n+    }\n+    _node_count = 0;\n+}\n+/**\n+ * Find the node and update partition data\n+ * New node, the node updated in the first partition will move to the tail of the list\n+ */\n+void ResultCache::update(const PUpdateCacheRequest* request, PCacheResponse* response) {\n+    ResultNode* node;\n+    PCacheStatus status;\n+    bool update_first = false;\n+    UniqueId sql_key = request->sql_key();\n+    LOG(INFO) << \"update cache, sql key:\" << sql_key;\n+    \n+    CacheWriteLock write_lock(_cache_mtx);\n+    auto it = _node_map.find(sql_key);\n+    if (it != _node_map.end()) {\n+        node = it->second;\n+        _cache_size -= node->get_data_size();\n+        _partition_count -= node->get_partition_count();\n+        status = node->update_partition(request, update_first);\n+    } else {\n+        node = _node_list.new_node(sql_key);\n+        status = node->update_partition(request, update_first);\n+        _node_list.push(node);\n+        _node_map[sql_key] = node;\n+        _node_count += 1;\n+    }\n+    if (update_first) {\n+        _node_list.move_tail(node);\n+    }\n+    _cache_size += node->get_data_size();\n+    _partition_count += node->get_partition_count();\n+    response->set_status(status);\n+\n+    prune();\n+    update_monitor();\n+}\n+\n+/**\n+ * Fetch cache through sql key, partition key, version and time\n+ */\n+void ResultCache::fetch(const PFetchCacheRequest* request, PFetchCacheResult* result) {\n+    bool hit_first = false;\n+    ResultNodeMap::iterator node_it;\n+    const UniqueId sql_key = request->sql_key();\n+    LOG(INFO) << \"fetch cache, sql key:\" << sql_key;\n+    {\n+        CacheReadLock read_lock(_cache_mtx);    \n+        node_it = _node_map.find(sql_key);\n+        if (node_it == _node_map.end()) {\n+            result->set_status(PCacheStatus::NO_SQL_KEY);\n+            LOG(INFO) << \"no such sql key:\" << sql_key;\n+            return;\n+        }\n+        ResultNode* node = node_it->second;\n+        PartitionRowBatchList part_rowbatch_list;\n+        PCacheStatus status = node->fetch_partition(request, part_rowbatch_list, hit_first);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxMDkzOA=="}, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDU0NjU4OnYy", "diffSide": "RIGHT", "path": "be/src/runtime/cache/result_node.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMzoyODowMlrOG7gYAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMjozOTowM1rOG74Eaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA0OTYwMw==", "bodyText": "what happened if part_it is equal with partion_list.end()", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465049603", "createdAt": "2020-08-04T13:28:02Z", "author": {"login": "wutiangan"}, "path": "be/src/runtime/cache/result_node.cpp", "diffHunk": "@@ -0,0 +1,274 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include \"gen_cpp/internal_service.pb.h\"\n+#include \"runtime/cache/result_node.h\"\n+#include \"runtime/cache/cache_utils.h\"\n+\n+namespace doris {\n+\n+bool compare_partition(const PartitionRowBatch* left_node, const PartitionRowBatch* right_node) {\n+    return left_node->get_partition_key() < right_node->get_partition_key();\n+}\n+\n+//return new batch size,only include the size of PRowBatch\n+void PartitionRowBatch::set_row_batch(const PCacheValue& value) {\n+    if (_cache_value != NULL && !check_newer(value.param())) {\n+        LOG(WARNING) << \"set old version data, cache ver:\" << _cache_value->param().last_version()\n+                     << \",cache time:\" << _cache_value->param().last_version_time()\n+                     << \", setdata ver:\" << value.param().last_version()\n+                     << \",setdata time:\" << value.param().last_version_time();\n+        return;\n+    }\n+    SAFE_DELETE(_cache_value);\n+    _cache_value = new PCacheValue(value);\n+    _data_size += _cache_value->data_size();\n+    _cache_stat.update();\n+    LOG(INFO) << \"finish set row batch, row num:\" << _cache_value->row_size()\n+              << \", data size:\" << _data_size;\n+}\n+\n+bool PartitionRowBatch::is_hit_cache(const PCacheParam& param) {\n+    if (param.partition_key() != _partition_key) {\n+        return false;\n+    }\n+    if (!check_match(param)) {\n+        return false;\n+    }\n+    _cache_stat.query();\n+    return true;\n+}\n+\n+void PartitionRowBatch::clear() {\n+    LOG(INFO) << \"clear partition rowbatch.\";\n+    SAFE_DELETE(_cache_value);\n+    _partition_key = 0;\n+    _data_size = 0;\n+    _cache_stat.init();\n+}\n+\n+/**\n+ * Update partition cache data, find RowBatch from partition map by partition key,\n+ * the partition rowbatch are stored in the order of partition keys\n+ */\n+PCacheStatus ResultNode::update_partition(const PUpdateCacheRequest* request, bool& update_first) {\n+    update_first = false;\n+    if (_sql_key != request->sql_key()) {\n+        LOG(INFO) << \"no match sql_key \" << request->sql_key().hi() << request->sql_key().lo();\n+        return PCacheStatus::PARAM_ERROR;\n+    }\n+\n+    if (request->value_size() > config::query_cache_max_partition_count) {\n+        LOG(WARNING) << \"too many partitions size:\" << request->value_size();\n+        return PCacheStatus::PARAM_ERROR;\n+    }\n+\n+    //Only one thread per SQL key can update the cache\n+    CacheWriteLock write_lock(_node_mtx);\n+\n+    int64 first_key = kint64max;\n+    if (_partition_list.size() == 0) {\n+        update_first = true;\n+    } else {\n+        first_key = (*(_partition_list.begin()))->get_partition_key();\n+    }\n+    PartitionRowBatch* partition = NULL;\n+    for (int i = 0; i < request->value_size(); i++) {\n+        const PCacheValue& value = request->value(i);\n+        int64 partition_key = value.param().partition_key();\n+        if (!update_first && partition_key <= first_key) {\n+            update_first = true;\n+        }\n+        auto it = _partition_map.find(partition_key);\n+        if (it == _partition_map.end()) {\n+            partition = new PartitionRowBatch(partition_key);\n+            partition->set_row_batch(value);\n+            _partition_map[partition_key] = partition;\n+            _partition_list.push_back(partition);\n+#ifdef PARTITION_CACHE_DEV\n+            LOG(INFO) << \"add index:\" << i << \", pkey:\" << partition->get_partition_key()\n+                      << \", list size:\" << _partition_list.size()\n+                      << \", map size:\" << _partition_map.size();\n+#endif\n+        } else {\n+            partition = it->second;\n+            _data_size -= partition->get_data_size();\n+            partition->set_row_batch(value);\n+#ifdef PARTITION_CACHE_DEV\n+            LOG(INFO) << \"update index:\" << i << \", pkey:\" << partition->get_partition_key()\n+                      << \", list size:\" << _partition_list.size()\n+                      << \", map size:\" << _partition_map.size();\n+#endif\n+        }\n+        _data_size += partition->get_data_size();\n+    }\n+    _partition_list.sort(compare_partition);\n+    LOG(INFO) << \"finish update batches:\" << _partition_list.size();\n+    while (config::query_cache_max_partition_count > 0 &&\n+           _partition_list.size() > config::query_cache_max_partition_count) {\n+        if (prune_first() == 0) {\n+            break;\n+        }\n+    }\n+    return PCacheStatus::CACHE_OK;\n+}\n+\n+/**\n+* Only the range query of the key of the partition is supported, and the separated partition key query is not supported.\n+* Because a query can only be divided into two parts, part1 get data from cache, part2 fetch_data by scan node from BE.\n+* Partion cache : 20191211-20191215\n+* Hit cache parameter : [20191211 - 20191215], [20191212 - 20191214], [20191212 - 20191216],[20191210 - 20191215]\n+* Miss cache parameter: [20191210 - 20191216]\n+*/\n+PCacheStatus ResultNode::fetch_partition(const PFetchCacheRequest* request,\n+                                         PartitionRowBatchList& row_batch_list, bool& hit_first) {\n+    hit_first = false;\n+    if (request->param_size() == 0) {\n+        return PCacheStatus::PARAM_ERROR;\n+    }\n+\n+    CacheReadLock read_lock(_node_mtx);\n+\n+    if (_partition_list.size() == 0) {\n+        return PCacheStatus::NO_PARTITION_KEY;\n+    }\n+    \n+    if (request->param(0).partition_key() > (*_partition_list.rbegin())->get_partition_key() ||\n+        request->param(request->param_size() - 1).partition_key() <\n+                (*_partition_list.begin())->get_partition_key()) {\n+        return PCacheStatus::NO_PARTITION_KEY;\n+    }\n+\n+    bool find = false;\n+    int begin_idx = -1, end_idx = -1, param_idx = 0;\n+    auto begin_it = _partition_list.end();\n+    auto end_it = _partition_list.end();\n+    auto part_it = _partition_list.begin();\n+\n+    PCacheStatus status = PCacheStatus::CACHE_OK;\n+    while (param_idx < request->param_size() && part_it != _partition_list.end()) {\n+#ifdef PARTITION_CACHE_DEV\n+        LOG(INFO) << \"Param index : \" << param_idx\n+                  << \", param part Key : \" << request->param(param_idx).partition_key()\n+                  << \", batch part key : \" << (*part_it)->get_partition_key();\n+#endif\n+        if (!find) {\n+            while (part_it != _partition_list.end() &&\n+                   request->param(param_idx).partition_key() > (*part_it)->get_partition_key()) {\n+                part_it++;\n+            }\n+            while (param_idx < request->param_size() &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzNzgwMw==", "bodyText": "If there is no intersection, we have already judged it before, and we will directly regret it\n   if (request->param(0).partition_key() > (*_partition_list.rbegin())->get_partition_key() ||\n        request->param(request->param_size() - 1).partition_key() <\n                (*_partition_list.begin())->get_partition_key()) {\n        return PCacheStatus::NO_PARTITION_KEY;\n    }", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465437803", "createdAt": "2020-08-05T02:39:03Z", "author": {"login": "marising"}, "path": "be/src/runtime/cache/result_node.cpp", "diffHunk": "@@ -0,0 +1,274 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include \"gen_cpp/internal_service.pb.h\"\n+#include \"runtime/cache/result_node.h\"\n+#include \"runtime/cache/cache_utils.h\"\n+\n+namespace doris {\n+\n+bool compare_partition(const PartitionRowBatch* left_node, const PartitionRowBatch* right_node) {\n+    return left_node->get_partition_key() < right_node->get_partition_key();\n+}\n+\n+//return new batch size,only include the size of PRowBatch\n+void PartitionRowBatch::set_row_batch(const PCacheValue& value) {\n+    if (_cache_value != NULL && !check_newer(value.param())) {\n+        LOG(WARNING) << \"set old version data, cache ver:\" << _cache_value->param().last_version()\n+                     << \",cache time:\" << _cache_value->param().last_version_time()\n+                     << \", setdata ver:\" << value.param().last_version()\n+                     << \",setdata time:\" << value.param().last_version_time();\n+        return;\n+    }\n+    SAFE_DELETE(_cache_value);\n+    _cache_value = new PCacheValue(value);\n+    _data_size += _cache_value->data_size();\n+    _cache_stat.update();\n+    LOG(INFO) << \"finish set row batch, row num:\" << _cache_value->row_size()\n+              << \", data size:\" << _data_size;\n+}\n+\n+bool PartitionRowBatch::is_hit_cache(const PCacheParam& param) {\n+    if (param.partition_key() != _partition_key) {\n+        return false;\n+    }\n+    if (!check_match(param)) {\n+        return false;\n+    }\n+    _cache_stat.query();\n+    return true;\n+}\n+\n+void PartitionRowBatch::clear() {\n+    LOG(INFO) << \"clear partition rowbatch.\";\n+    SAFE_DELETE(_cache_value);\n+    _partition_key = 0;\n+    _data_size = 0;\n+    _cache_stat.init();\n+}\n+\n+/**\n+ * Update partition cache data, find RowBatch from partition map by partition key,\n+ * the partition rowbatch are stored in the order of partition keys\n+ */\n+PCacheStatus ResultNode::update_partition(const PUpdateCacheRequest* request, bool& update_first) {\n+    update_first = false;\n+    if (_sql_key != request->sql_key()) {\n+        LOG(INFO) << \"no match sql_key \" << request->sql_key().hi() << request->sql_key().lo();\n+        return PCacheStatus::PARAM_ERROR;\n+    }\n+\n+    if (request->value_size() > config::query_cache_max_partition_count) {\n+        LOG(WARNING) << \"too many partitions size:\" << request->value_size();\n+        return PCacheStatus::PARAM_ERROR;\n+    }\n+\n+    //Only one thread per SQL key can update the cache\n+    CacheWriteLock write_lock(_node_mtx);\n+\n+    int64 first_key = kint64max;\n+    if (_partition_list.size() == 0) {\n+        update_first = true;\n+    } else {\n+        first_key = (*(_partition_list.begin()))->get_partition_key();\n+    }\n+    PartitionRowBatch* partition = NULL;\n+    for (int i = 0; i < request->value_size(); i++) {\n+        const PCacheValue& value = request->value(i);\n+        int64 partition_key = value.param().partition_key();\n+        if (!update_first && partition_key <= first_key) {\n+            update_first = true;\n+        }\n+        auto it = _partition_map.find(partition_key);\n+        if (it == _partition_map.end()) {\n+            partition = new PartitionRowBatch(partition_key);\n+            partition->set_row_batch(value);\n+            _partition_map[partition_key] = partition;\n+            _partition_list.push_back(partition);\n+#ifdef PARTITION_CACHE_DEV\n+            LOG(INFO) << \"add index:\" << i << \", pkey:\" << partition->get_partition_key()\n+                      << \", list size:\" << _partition_list.size()\n+                      << \", map size:\" << _partition_map.size();\n+#endif\n+        } else {\n+            partition = it->second;\n+            _data_size -= partition->get_data_size();\n+            partition->set_row_batch(value);\n+#ifdef PARTITION_CACHE_DEV\n+            LOG(INFO) << \"update index:\" << i << \", pkey:\" << partition->get_partition_key()\n+                      << \", list size:\" << _partition_list.size()\n+                      << \", map size:\" << _partition_map.size();\n+#endif\n+        }\n+        _data_size += partition->get_data_size();\n+    }\n+    _partition_list.sort(compare_partition);\n+    LOG(INFO) << \"finish update batches:\" << _partition_list.size();\n+    while (config::query_cache_max_partition_count > 0 &&\n+           _partition_list.size() > config::query_cache_max_partition_count) {\n+        if (prune_first() == 0) {\n+            break;\n+        }\n+    }\n+    return PCacheStatus::CACHE_OK;\n+}\n+\n+/**\n+* Only the range query of the key of the partition is supported, and the separated partition key query is not supported.\n+* Because a query can only be divided into two parts, part1 get data from cache, part2 fetch_data by scan node from BE.\n+* Partion cache : 20191211-20191215\n+* Hit cache parameter : [20191211 - 20191215], [20191212 - 20191214], [20191212 - 20191216],[20191210 - 20191215]\n+* Miss cache parameter: [20191210 - 20191216]\n+*/\n+PCacheStatus ResultNode::fetch_partition(const PFetchCacheRequest* request,\n+                                         PartitionRowBatchList& row_batch_list, bool& hit_first) {\n+    hit_first = false;\n+    if (request->param_size() == 0) {\n+        return PCacheStatus::PARAM_ERROR;\n+    }\n+\n+    CacheReadLock read_lock(_node_mtx);\n+\n+    if (_partition_list.size() == 0) {\n+        return PCacheStatus::NO_PARTITION_KEY;\n+    }\n+    \n+    if (request->param(0).partition_key() > (*_partition_list.rbegin())->get_partition_key() ||\n+        request->param(request->param_size() - 1).partition_key() <\n+                (*_partition_list.begin())->get_partition_key()) {\n+        return PCacheStatus::NO_PARTITION_KEY;\n+    }\n+\n+    bool find = false;\n+    int begin_idx = -1, end_idx = -1, param_idx = 0;\n+    auto begin_it = _partition_list.end();\n+    auto end_it = _partition_list.end();\n+    auto part_it = _partition_list.begin();\n+\n+    PCacheStatus status = PCacheStatus::CACHE_OK;\n+    while (param_idx < request->param_size() && part_it != _partition_list.end()) {\n+#ifdef PARTITION_CACHE_DEV\n+        LOG(INFO) << \"Param index : \" << param_idx\n+                  << \", param part Key : \" << request->param(param_idx).partition_key()\n+                  << \", batch part key : \" << (*part_it)->get_partition_key();\n+#endif\n+        if (!find) {\n+            while (part_it != _partition_list.end() &&\n+                   request->param(param_idx).partition_key() > (*part_it)->get_partition_key()) {\n+                part_it++;\n+            }\n+            while (param_idx < request->param_size() &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA0OTYwMw=="}, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDU3ODAwOnYy", "diffSide": "RIGHT", "path": "be/src/runtime/cache/result_cache.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMzozNjoxMFrOG7gr3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMzozNjoxMFrOG7gr3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA1NDY4Ng==", "bodyText": "140 line\uff0c143 line maybe can remove", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465054686", "createdAt": "2020-08-04T13:36:10Z", "author": {"login": "wutiangan"}, "path": "be/src/runtime/cache/result_cache.cpp", "diffHunk": "@@ -0,0 +1,257 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include \"gen_cpp/internal_service.pb.h\"\n+#include \"runtime/cache/result_cache.h\"\n+#include \"util/doris_metrics.h\"\n+\n+namespace doris {\n+\n+/**\n+* Remove the tail node of link\n+*/\n+ResultNode* ResultNodeList::pop() {\n+    remove(_head);\n+    return _head;\n+}\n+\n+void ResultNodeList::remove(ResultNode* node) {\n+    if (!node) return;\n+    if (node == _head) _head = node->get_next();\n+    if (node == _tail) _tail = node->get_prev();\n+    node->unlink();\n+    _node_count--;\n+}\n+\n+void ResultNodeList::push(ResultNode* node) {\n+    if (!node) return;\n+    if (!_head) _head = node;\n+    node->append(_tail);\n+    _tail = node;\n+    _node_count++;\n+}\n+\n+void ResultNodeList::move_tail(ResultNode* node) {\n+    if (!node || node == _tail) return;\n+    if (!_head)\n+        _head = node;\n+    else if (node == _head)\n+        _head = node->get_next();\n+    node->unlink();\n+    node->append(_tail);\n+    _tail = node;\n+}\n+\n+void ResultNodeList::clear() {\n+    LOG(INFO) << \"clear result node list.\";\n+    while (_head) {\n+        ResultNode* tmp_node = _head->get_next();\n+        _head->clear();\n+        SAFE_DELETE(_head);\n+        _head = tmp_node;\n+    }\n+    _node_count = 0;\n+}\n+/**\n+ * Find the node and update partition data\n+ * New node, the node updated in the first partition will move to the tail of the list\n+ */\n+void ResultCache::update(const PUpdateCacheRequest* request, PCacheResponse* response) {\n+    ResultNode* node;\n+    PCacheStatus status;\n+    bool update_first = false;\n+    UniqueId sql_key = request->sql_key();\n+    LOG(INFO) << \"update cache, sql key:\" << sql_key;\n+    \n+    CacheWriteLock write_lock(_cache_mtx);\n+    auto it = _node_map.find(sql_key);\n+    if (it != _node_map.end()) {\n+        node = it->second;\n+        _cache_size -= node->get_data_size();\n+        _partition_count -= node->get_partition_count();\n+        status = node->update_partition(request, update_first);\n+    } else {\n+        node = _node_list.new_node(sql_key);\n+        status = node->update_partition(request, update_first);\n+        _node_list.push(node);\n+        _node_map[sql_key] = node;\n+        _node_count += 1;\n+    }\n+    if (update_first) {\n+        _node_list.move_tail(node);\n+    }\n+    _cache_size += node->get_data_size();\n+    _partition_count += node->get_partition_count();\n+    response->set_status(status);\n+\n+    prune();\n+    update_monitor();\n+}\n+\n+/**\n+ * Fetch cache through sql key, partition key, version and time\n+ */\n+void ResultCache::fetch(const PFetchCacheRequest* request, PFetchCacheResult* result) {\n+    bool hit_first = false;\n+    ResultNodeMap::iterator node_it;\n+    const UniqueId sql_key = request->sql_key();\n+    LOG(INFO) << \"fetch cache, sql key:\" << sql_key;\n+    {\n+        CacheReadLock read_lock(_cache_mtx);    \n+        node_it = _node_map.find(sql_key);\n+        if (node_it == _node_map.end()) {\n+            result->set_status(PCacheStatus::NO_SQL_KEY);\n+            LOG(INFO) << \"no such sql key:\" << sql_key;\n+            return;\n+        }\n+        ResultNode* node = node_it->second;\n+        PartitionRowBatchList part_rowbatch_list;\n+        PCacheStatus status = node->fetch_partition(request, part_rowbatch_list, hit_first);\n+\n+        for (auto part_it = part_rowbatch_list.begin(); part_it != part_rowbatch_list.end(); part_it++) {\n+            PCacheValue* srcValue = (*part_it)->get_value();\n+            if (srcValue != NULL) {\n+                PCacheValue* value = result->add_value();\n+                value->CopyFrom(*srcValue);\n+                LOG(INFO) << \"fetch cache partition key:\" << srcValue->param().partition_key();\n+            } else {\n+                LOG(WARNING) << \"prowbatch of cache is null\";\n+                status = PCacheStatus::EMPTY_DATA;\n+                break;\n+            }\n+        }\n+        result->set_status(status);\n+    }\n+\n+    if (hit_first) {\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDYzMzU4OnYy", "diffSide": "RIGHT", "path": "be/src/runtime/cache/result_node.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMzo0ODo1OVrOG7hNZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoyMzowOVrOG74vOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA2MzI2OQ==", "bodyText": "why not \" _data_size = _cache_value->data_size()\" ?", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465063269", "createdAt": "2020-08-04T13:48:59Z", "author": {"login": "wutiangan"}, "path": "be/src/runtime/cache/result_node.cpp", "diffHunk": "@@ -0,0 +1,274 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include \"gen_cpp/internal_service.pb.h\"\n+#include \"runtime/cache/result_node.h\"\n+#include \"runtime/cache/cache_utils.h\"\n+\n+namespace doris {\n+\n+bool compare_partition(const PartitionRowBatch* left_node, const PartitionRowBatch* right_node) {\n+    return left_node->get_partition_key() < right_node->get_partition_key();\n+}\n+\n+//return new batch size,only include the size of PRowBatch\n+void PartitionRowBatch::set_row_batch(const PCacheValue& value) {\n+    if (_cache_value != NULL && !check_newer(value.param())) {\n+        LOG(WARNING) << \"set old version data, cache ver:\" << _cache_value->param().last_version()\n+                     << \",cache time:\" << _cache_value->param().last_version_time()\n+                     << \", setdata ver:\" << value.param().last_version()\n+                     << \",setdata time:\" << value.param().last_version_time();\n+        return;\n+    }\n+    SAFE_DELETE(_cache_value);\n+    _cache_value = new PCacheValue(value);\n+    _data_size += _cache_value->data_size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0ODc2Mg==", "bodyText": "_data_size contains the data size of all partitions, in order to avoid counting once every time, so each operation increases or decreases the changed value", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465448762", "createdAt": "2020-08-05T03:23:09Z", "author": {"login": "marising"}, "path": "be/src/runtime/cache/result_node.cpp", "diffHunk": "@@ -0,0 +1,274 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include \"gen_cpp/internal_service.pb.h\"\n+#include \"runtime/cache/result_node.h\"\n+#include \"runtime/cache/cache_utils.h\"\n+\n+namespace doris {\n+\n+bool compare_partition(const PartitionRowBatch* left_node, const PartitionRowBatch* right_node) {\n+    return left_node->get_partition_key() < right_node->get_partition_key();\n+}\n+\n+//return new batch size,only include the size of PRowBatch\n+void PartitionRowBatch::set_row_batch(const PCacheValue& value) {\n+    if (_cache_value != NULL && !check_newer(value.param())) {\n+        LOG(WARNING) << \"set old version data, cache ver:\" << _cache_value->param().last_version()\n+                     << \",cache time:\" << _cache_value->param().last_version_time()\n+                     << \", setdata ver:\" << value.param().last_version()\n+                     << \",setdata time:\" << value.param().last_version_time();\n+        return;\n+    }\n+    SAFE_DELETE(_cache_value);\n+    _cache_value = new PCacheValue(value);\n+    _data_size += _cache_value->data_size();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA2MzI2OQ=="}, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDY3NDc0OnYy", "diffSide": "RIGHT", "path": "be/src/common/config.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMzo1ODoxMVrOG7hnRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMzo1ODoxMVrOG7hnRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA2OTg5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                //Cache memory is pruened when reach cache_max_size + cache_elasticity_size\n          \n          \n            \n                //Cache memory is pruned when reach cache_max_size + cache_elasticity_size", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465069895", "createdAt": "2020-08-04T13:58:11Z", "author": {"login": "wutiangan"}, "path": "be/src/common/config.h", "diffHunk": "@@ -546,6 +546,16 @@ namespace config {\n \n     // Soft memory limit as a fraction of hard memory limit.\n     CONF_Double(soft_mem_limit_frac, \"0.9\");\n+    \n+    // Set max cache's size of query results, the unit is M byte\n+    CONF_Int32(query_cache_max_size_mb, \"256\"); \n+\n+    //Cache memory is pruened when reach cache_max_size + cache_elasticity_size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDc0NzAwOnYy", "diffSide": "RIGHT", "path": "be/src/runtime/cache/result_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNDoxMzozN1rOG7iTzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNDoxMzozN1rOG7iTzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA4MTI5NQ==", "bodyText": "'update_first' 's meaning is not clear.  Maybe you can call it  'is_first_key_updated'", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465081295", "createdAt": "2020-08-04T14:13:37Z", "author": {"login": "wutiangan"}, "path": "be/src/runtime/cache/result_node.cpp", "diffHunk": "@@ -0,0 +1,274 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include \"gen_cpp/internal_service.pb.h\"\n+#include \"runtime/cache/result_node.h\"\n+#include \"runtime/cache/cache_utils.h\"\n+\n+namespace doris {\n+\n+bool compare_partition(const PartitionRowBatch* left_node, const PartitionRowBatch* right_node) {\n+    return left_node->get_partition_key() < right_node->get_partition_key();\n+}\n+\n+//return new batch size,only include the size of PRowBatch\n+void PartitionRowBatch::set_row_batch(const PCacheValue& value) {\n+    if (_cache_value != NULL && !check_newer(value.param())) {\n+        LOG(WARNING) << \"set old version data, cache ver:\" << _cache_value->param().last_version()\n+                     << \",cache time:\" << _cache_value->param().last_version_time()\n+                     << \", setdata ver:\" << value.param().last_version()\n+                     << \",setdata time:\" << value.param().last_version_time();\n+        return;\n+    }\n+    SAFE_DELETE(_cache_value);\n+    _cache_value = new PCacheValue(value);\n+    _data_size += _cache_value->data_size();\n+    _cache_stat.update();\n+    LOG(INFO) << \"finish set row batch, row num:\" << _cache_value->row_size()\n+              << \", data size:\" << _data_size;\n+}\n+\n+bool PartitionRowBatch::is_hit_cache(const PCacheParam& param) {\n+    if (param.partition_key() != _partition_key) {\n+        return false;\n+    }\n+    if (!check_match(param)) {\n+        return false;\n+    }\n+    _cache_stat.query();\n+    return true;\n+}\n+\n+void PartitionRowBatch::clear() {\n+    LOG(INFO) << \"clear partition rowbatch.\";\n+    SAFE_DELETE(_cache_value);\n+    _partition_key = 0;\n+    _data_size = 0;\n+    _cache_stat.init();\n+}\n+\n+/**\n+ * Update partition cache data, find RowBatch from partition map by partition key,\n+ * the partition rowbatch are stored in the order of partition keys\n+ */\n+PCacheStatus ResultNode::update_partition(const PUpdateCacheRequest* request, bool& update_first) {\n+    update_first = false;\n+    if (_sql_key != request->sql_key()) {\n+        LOG(INFO) << \"no match sql_key \" << request->sql_key().hi() << request->sql_key().lo();\n+        return PCacheStatus::PARAM_ERROR;\n+    }\n+\n+    if (request->value_size() > config::query_cache_max_partition_count) {\n+        LOG(WARNING) << \"too many partitions size:\" << request->value_size();\n+        return PCacheStatus::PARAM_ERROR;\n+    }\n+\n+    //Only one thread per SQL key can update the cache\n+    CacheWriteLock write_lock(_node_mtx);\n+\n+    int64 first_key = kint64max;\n+    if (_partition_list.size() == 0) {\n+        update_first = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDc3MjkzOnYy", "diffSide": "RIGHT", "path": "be/src/runtime/cache/result_node.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNDoxODo0M1rOG7ijiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoxMzoyNVrOG74mJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA4NTMyMw==", "bodyText": "this function is useless?", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465085323", "createdAt": "2020-08-04T14:18:43Z", "author": {"login": "wutiangan"}, "path": "be/src/runtime/cache/result_node.h", "diffHunk": "@@ -0,0 +1,197 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_RUNTIME_RESULT_NODE_H\n+#define DORIS_BE_SRC_RUNTIME_RESULT_NODE_H\n+\n+#include <sys/time.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <exception>\n+#include <iostream>\n+#include <list>\n+#include <map>\n+#include <string>\n+\n+#include \"common/config.h\"\n+#include \"olap/olap_define.h\"\n+#include \"runtime/cache/cache_utils.h\"\n+#include \"runtime/mem_pool.h\"\n+#include \"runtime/row_batch.h\"\n+#include \"runtime/tuple_row.h\"\n+#include \"util/uid_util.h\"\n+\n+namespace doris {\n+\n+enum PCacheStatus;\n+class PCacheParam;\n+class PCacheValue;\n+class PCacheResponse;\n+class PFetchCacheRequest;\n+class PFetchCacheResult;\n+class PUpdateCacheRequest;\n+class PClearCacheRequest;\n+\n+/**\n+* Cache one partition data, request param must match version and time of cache\n+*/\n+class PartitionRowBatch {\n+public:\n+    PartitionRowBatch(int64 partition_key)\n+            : _partition_key(partition_key), _cache_value(NULL), _data_size(0) {}\n+\n+    ~PartitionRowBatch() {}\n+\n+    void set_row_batch(const PCacheValue& value);\n+    bool is_hit_cache(const PCacheParam& param);\n+    void clear();\n+\n+    int64 get_partition_key() const { return _partition_key; }\n+\n+    PCacheValue* get_value() { return _cache_value; }\n+\n+    size_t get_data_size() { return _data_size; }\n+\n+    const CacheStat* get_stat() const { return &_cache_stat; }\n+\n+private:\n+    bool check_match(const PCacheParam& req_param) {\n+        if (req_param.last_version() > _cache_value->param().last_version()) {\n+            return false;\n+        }\n+        if (req_param.last_version_time() > _cache_value->param().last_version_time()) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    bool check_newer(const PCacheParam& up_param) {\n+        //for init data of sql cache\n+        if (up_param.last_version() == 0 || up_param.last_version_time() == 0) {\n+            return true;\n+        }\n+        if (up_param.last_version_time() > _cache_value->param().last_version_time()) {\n+            return true;\n+        }\n+        if (up_param.last_version() > _cache_value->param().last_version()) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+private:\n+    int64 _partition_key;\n+    PCacheValue* _cache_value;\n+    size_t _data_size;\n+    CacheStat _cache_stat;\n+};\n+\n+typedef std::list<PartitionRowBatch*> PartitionRowBatchList;\n+typedef boost::unordered_map<int64, PartitionRowBatch*> PartitionRowBatchMap;\n+\n+/**\n+* Cache the result of one SQL, include many partition rowsets.\n+* Sql Cache: The partiton ID comes from the partition lastest updated.\n+* Partition Cache: The partition ID comes from the partition scanned by query.\n+* The above two modes use the same cache structure.\n+*/\n+class ResultNode {\n+public:\n+    ResultNode() : _sql_key(0, 0), _prev(NULL), _next(NULL), _data_size(0) {}\n+\n+    ResultNode(const UniqueId& sql_key)\n+            : _sql_key(sql_key), _prev(NULL), _next(NULL), _data_size(0) {}\n+\n+    virtual ~ResultNode() {}\n+\n+    PCacheStatus update_partition(const PUpdateCacheRequest* request, bool& update_first);\n+    PCacheStatus fetch_partition(const PFetchCacheRequest* request,\n+                                 PartitionRowBatchList& rowBatchList, bool& hit_first);\n+\n+    size_t prune_first();\n+    void clear();\n+\n+    bool operator()(const ResultNode* left_node, const ResultNode* right_node) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NjQzOQ==", "bodyText": "yes", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465446439", "createdAt": "2020-08-05T03:13:25Z", "author": {"login": "marising"}, "path": "be/src/runtime/cache/result_node.h", "diffHunk": "@@ -0,0 +1,197 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_RUNTIME_RESULT_NODE_H\n+#define DORIS_BE_SRC_RUNTIME_RESULT_NODE_H\n+\n+#include <sys/time.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <exception>\n+#include <iostream>\n+#include <list>\n+#include <map>\n+#include <string>\n+\n+#include \"common/config.h\"\n+#include \"olap/olap_define.h\"\n+#include \"runtime/cache/cache_utils.h\"\n+#include \"runtime/mem_pool.h\"\n+#include \"runtime/row_batch.h\"\n+#include \"runtime/tuple_row.h\"\n+#include \"util/uid_util.h\"\n+\n+namespace doris {\n+\n+enum PCacheStatus;\n+class PCacheParam;\n+class PCacheValue;\n+class PCacheResponse;\n+class PFetchCacheRequest;\n+class PFetchCacheResult;\n+class PUpdateCacheRequest;\n+class PClearCacheRequest;\n+\n+/**\n+* Cache one partition data, request param must match version and time of cache\n+*/\n+class PartitionRowBatch {\n+public:\n+    PartitionRowBatch(int64 partition_key)\n+            : _partition_key(partition_key), _cache_value(NULL), _data_size(0) {}\n+\n+    ~PartitionRowBatch() {}\n+\n+    void set_row_batch(const PCacheValue& value);\n+    bool is_hit_cache(const PCacheParam& param);\n+    void clear();\n+\n+    int64 get_partition_key() const { return _partition_key; }\n+\n+    PCacheValue* get_value() { return _cache_value; }\n+\n+    size_t get_data_size() { return _data_size; }\n+\n+    const CacheStat* get_stat() const { return &_cache_stat; }\n+\n+private:\n+    bool check_match(const PCacheParam& req_param) {\n+        if (req_param.last_version() > _cache_value->param().last_version()) {\n+            return false;\n+        }\n+        if (req_param.last_version_time() > _cache_value->param().last_version_time()) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    bool check_newer(const PCacheParam& up_param) {\n+        //for init data of sql cache\n+        if (up_param.last_version() == 0 || up_param.last_version_time() == 0) {\n+            return true;\n+        }\n+        if (up_param.last_version_time() > _cache_value->param().last_version_time()) {\n+            return true;\n+        }\n+        if (up_param.last_version() > _cache_value->param().last_version()) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+private:\n+    int64 _partition_key;\n+    PCacheValue* _cache_value;\n+    size_t _data_size;\n+    CacheStat _cache_stat;\n+};\n+\n+typedef std::list<PartitionRowBatch*> PartitionRowBatchList;\n+typedef boost::unordered_map<int64, PartitionRowBatch*> PartitionRowBatchMap;\n+\n+/**\n+* Cache the result of one SQL, include many partition rowsets.\n+* Sql Cache: The partiton ID comes from the partition lastest updated.\n+* Partition Cache: The partition ID comes from the partition scanned by query.\n+* The above two modes use the same cache structure.\n+*/\n+class ResultNode {\n+public:\n+    ResultNode() : _sql_key(0, 0), _prev(NULL), _next(NULL), _data_size(0) {}\n+\n+    ResultNode(const UniqueId& sql_key)\n+            : _sql_key(sql_key), _prev(NULL), _next(NULL), _data_size(0) {}\n+\n+    virtual ~ResultNode() {}\n+\n+    PCacheStatus update_partition(const PUpdateCacheRequest* request, bool& update_first);\n+    PCacheStatus fetch_partition(const PFetchCacheRequest* request,\n+                                 PartitionRowBatchList& rowBatchList, bool& hit_first);\n+\n+    size_t prune_first();\n+    void clear();\n+\n+    bool operator()(const ResultNode* left_node, const ResultNode* right_node) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA4NTMyMw=="}, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDgwMDQ4OnYy", "diffSide": "RIGHT", "path": "be/src/runtime/exec_env_init.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNDoyMzozMFrOG7izjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoxMzoxMVrOG74l7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA4OTQyMA==", "bodyText": "if ExecEnv::_init return failed status, then you will be memory leak.  for examaple 124 line in this file  return error.", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465089420", "createdAt": "2020-08-04T14:23:30Z", "author": {"login": "wutiangan"}, "path": "be/src/runtime/exec_env_init.cpp", "diffHunk": "@@ -208,6 +215,10 @@ void ExecEnv::_init_buffer_pool(int64_t min_page_size,\n }\n \n void ExecEnv::_destory() {\n+    //Only destroy once after init\n+    if (!_is_init) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NjM4Mg==", "bodyText": "If is_init is not judged, the initial initialization fails, and the destroy will be CoreDump later", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465446382", "createdAt": "2020-08-05T03:13:11Z", "author": {"login": "marising"}, "path": "be/src/runtime/exec_env_init.cpp", "diffHunk": "@@ -208,6 +215,10 @@ void ExecEnv::_init_buffer_pool(int64_t min_page_size,\n }\n \n void ExecEnv::_destory() {\n+    //Only destroy once after init\n+    if (!_is_init) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA4OTQyMA=="}, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDgzMDA2OnYy", "diffSide": "RIGHT", "path": "docs/zh-CN/administrator-guide/partition_cache.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNDoyOTozM1rOG7jFWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNDoyOTozM1rOG7jFWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA5Mzk3OA==", "bodyText": "change cache_max_size to query_cache_max_size_mb", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465093978", "createdAt": "2020-08-04T14:29:33Z", "author": {"login": "wutiangan"}, "path": "docs/zh-CN/administrator-guide/partition_cache.md", "diffHunk": "@@ -0,0 +1,205 @@\n+# \u5206\u533a\u7f13\u5b58\n+\n+## \u9700\u6c42\u573a\u666f\n+\u5927\u90e8\u5206\u6570\u636e\u5206\u6790\u573a\u666f\u662f\u5199\u5c11\u8bfb\u591a\uff0c\u6570\u636e\u5199\u5165\u4e00\u6b21\uff0c\u591a\u6b21\u9891\u7e41\u8bfb\u53d6\uff0c\u6bd4\u5982\u4e00\u5f20\u62a5\u8868\u6d89\u53ca\u7684\u7ef4\u5ea6\u548c\u6307\u6807\uff0c\u6570\u636e\u5728\u51cc\u6668\u4e00\u6b21\u6027\u8ba1\u7b97\u597d\uff0c\u4f46\u6bcf\u5929\u6709\u6570\u767e\u751a\u81f3\u6570\u5343\u6b21\u7684\u9875\u9762\u8bbf\u95ee\uff0c\u56e0\u6b64\u975e\u5e38\u9002\u5408\u628a\u7ed3\u679c\u96c6\u7f13\u5b58\u8d77\u6765\u3002\u5728\u6570\u636e\u5206\u6790\u6216BI\u5e94\u7528\u4e2d\uff0c\u5b58\u5728\u4e0b\u9762\u7684\u4e1a\u52a1\u573a\u666f\uff1a\n+* **\u9ad8\u5e76\u53d1\u573a\u666f**\uff0cDoris\u53ef\u4ee5\u8f83\u597d\u7684\u652f\u6301\u9ad8\u5e76\u53d1\uff0c\u4f46\u5355\u53f0\u670d\u52a1\u5668\u65e0\u6cd5\u627f\u8f7d\u592a\u9ad8\u7684QPS\n+* **\u590d\u6742\u56fe\u8868\u7684\u770b\u677f**\uff0c\u590d\u6742\u7684Dashboard\u6216\u8005\u5927\u5c4f\u7c7b\u5e94\u7528\uff0c\u6570\u636e\u6765\u81ea\u591a\u5f20\u8868\uff0c\u6bcf\u4e2a\u9875\u9762\u6709\u6570\u5341\u4e2a\u67e5\u8be2\uff0c\u867d\u7136\u6bcf\u4e2a\u67e5\u8be2\u53ea\u6709\u6570\u5341\u6beb\u79d2\uff0c\u4f46\u662f\u603b\u4f53\u67e5\u8be2\u65f6\u95f4\u4f1a\u5728\u6570\u79d2\n+* **\u8d8b\u52bf\u5206\u6790**\uff0c\u7ed9\u5b9a\u65e5\u671f\u8303\u56f4\u7684\u67e5\u8be2\uff0c\u6307\u6807\u6309\u65e5\u663e\u793a\uff0c\u6bd4\u5982\u67e5\u8be2\u6700\u8fd17\u5929\u5185\u7684\u7528\u6237\u6570\u7684\u8d8b\u52bf\uff0c\u8fd9\u7c7b\u67e5\u8be2\u6570\u636e\u91cf\u5927\uff0c\u67e5\u8be2\u8303\u56f4\u5e7f\uff0c\u67e5\u8be2\u65f6\u95f4\u5f80\u5f80\u9700\u8981\u6570\u5341\u79d2\n+* **\u7528\u6237\u91cd\u590d\u67e5\u8be2**\uff0c\u5982\u679c\u4ea7\u54c1\u6ca1\u6709\u9632\u91cd\u5237\u673a\u5236\uff0c\u7528\u6237\u56e0\u624b\u8bef\u6216\u5176\u4ed6\u539f\u56e0\u91cd\u590d\u5237\u65b0\u9875\u9762\uff0c\u5bfc\u81f4\u63d0\u4ea4\u5927\u91cf\u7684\u91cd\u590d\u7684SQL\n+\n+\u4ee5\u4e0a\u56db\u79cd\u573a\u666f\uff0c\u5728\u5e94\u7528\u5c42\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u628a\u67e5\u8be2\u7ed3\u679c\u653e\u5230Redis\u4e2d\uff0c\u5468\u671f\u6027\u7684\u66f4\u65b0\u7f13\u5b58\u6216\u8005\u7528\u6237\u624b\u5de5\u5237\u65b0\u7f13\u5b58\uff0c\u4f46\u662f\u8fd9\u4e2a\u65b9\u6848\u6709\u5982\u4e0b\u95ee\u9898\uff1a\n+* **\u6570\u636e\u4e0d\u4e00\u81f4**\uff0c\u65e0\u6cd5\u611f\u77e5\u6570\u636e\u7684\u66f4\u65b0\uff0c\u5bfc\u81f4\u7528\u6237\u7ecf\u5e38\u770b\u5230\u65e7\u7684\u6570\u636e\n+* **\u547d\u4e2d\u7387\u4f4e**\uff0c\u7f13\u5b58\u6574\u4e2a\u67e5\u8be2\u7ed3\u679c\uff0c\u5982\u679c\u6570\u636e\u5b9e\u65f6\u5199\u5165\uff0c\u7f13\u5b58\u9891\u7e41\u5931\u6548\uff0c\u547d\u4e2d\u7387\u4f4e\u4e14\u7cfb\u7edf\u8d1f\u8f7d\u8f83\u91cd\n+* **\u989d\u5916\u6210\u672c**\uff0c\u5f15\u5165\u5916\u90e8\u7f13\u5b58\u7ec4\u4ef6\uff0c\u4f1a\u5e26\u6765\u7cfb\u7edf\u590d\u6742\u5ea6\uff0c\u589e\u52a0\u989d\u5916\u6210\u672c\n+\n+## \u89e3\u51b3\u65b9\u6848\n+\u672c\u5206\u533a\u7f13\u5b58\u7b56\u7565\u53ef\u4ee5\u89e3\u51b3\u4e0a\u9762\u7684\u95ee\u9898\uff0c\u4f18\u5148\u4fdd\u8bc1\u6570\u636e\u4e00\u81f4\u6027\uff0c\u5728\u6b64\u57fa\u7840\u4e0a\u7ec6\u5316\u7f13\u5b58\u7c92\u5ea6\uff0c\u63d0\u5347\u547d\u4e2d\u7387\uff0c\u56e0\u6b64\u6709\u5982\u4e0b\u7279\u70b9\uff1a\n+* \u7528\u6237\u65e0\u9700\u62c5\u5fc3\u6570\u636e\u4e00\u81f4\u6027\uff0c\u901a\u8fc7\u7248\u672c\u6765\u63a7\u5236\u7f13\u5b58\u5931\u6548\uff0c\u7f13\u5b58\u7684\u6570\u636e\u548c\u4eceBE\u4e2d\u67e5\u8be2\u7684\u6570\u636e\u662f\u4e00\u81f4\u7684\n+* \u6ca1\u6709\u989d\u5916\u7684\u7ec4\u4ef6\u548c\u6210\u672c\uff0c\u7f13\u5b58\u7ed3\u679c\u5b58\u50a8\u5728BE\u7684\u5185\u5b58\u4e2d\uff0c\u7528\u6237\u53ef\u4ee5\u6839\u636e\u9700\u8981\u8c03\u6574\u7f13\u5b58\u5185\u5b58\u5927\u5c0f\n+* \u5b9e\u73b0\u4e86\u4e24\u79cd\u7f13\u5b58\u7b56\u7565\uff0cSQLCache\u548cPartitionCache\uff0c\u540e\u8005\u7f13\u5b58\u7c92\u5ea6\u66f4\u7ec6\n+* \u7528\u4e00\u81f4\u6027\u54c8\u5e0c\u89e3\u51b3BE\u8282\u70b9\u4e0a\u4e0b\u7ebf\u7684\u95ee\u9898\uff0cBE\u4e2d\u7684\u7f13\u5b58\u7b97\u6cd5\u662f\u6539\u8fdb\u7684LRU\n+\n+## SQLCache\n+SQLCache\u6309SQL\u7684\u7b7e\u540d\u3001\u67e5\u8be2\u7684\u8868\u7684\u5206\u533aID\u3001\u5206\u533a\u6700\u65b0\u7248\u672c\u6765\u5b58\u50a8\u548c\u83b7\u53d6\u7f13\u5b58\u3002\u4e09\u8005\u7ec4\u5408\u786e\u5b9a\u4e00\u4e2a\u7f13\u5b58\u6570\u636e\u96c6\uff0c\u4efb\u4f55\u4e00\u4e2a\u53d8\u5316\u4e86\uff0c\u5982SQL\u6709\u53d8\u5316\uff0c\u5982\u67e5\u8be2\u5b57\u6bb5\u6216\u6761\u4ef6\u4e0d\u4e00\u6837\uff0c\u6216\u6570\u636e\u66f4\u65b0\u540e\u7248\u672c\u53d8\u5316\u4e86\uff0c\u4f1a\u5bfc\u81f4\u547d\u4e2d\u4e0d\u4e86\u7f13\u5b58\u3002\n+\n+\u5982\u679c\u591a\u5f20\u8868Join\uff0c\u4f7f\u7528\u6700\u8fd1\u66f4\u65b0\u7684\u5206\u533aID\u548c\u6700\u65b0\u7684\u7248\u672c\u53f7\uff0c\u5982\u679c\u5176\u4e2d\u4e00\u5f20\u8868\u66f4\u65b0\u4e86\uff0c\u4f1a\u5bfc\u81f4\u5206\u533aID\u6216\u7248\u672c\u53f7\u4e0d\u4e00\u6837\uff0c\u4e5f\u4e00\u6837\u547d\u4e2d\u4e0d\u4e86\u7f13\u5b58\u3002\n+\n+SQLCache\uff0c\u66f4\u9002\u5408T+1\u66f4\u65b0\u7684\u573a\u666f\uff0c\u51cc\u6668\u6570\u636e\u66f4\u65b0\uff0c\u9996\u6b21\u67e5\u8be2\u4eceBE\u4e2d\u83b7\u53d6\u7ed3\u679c\u653e\u5165\u5230\u7f13\u5b58\u4e2d\uff0c\u540e\u7eed\u76f8\u540c\u67e5\u8be2\u4ece\u7f13\u5b58\u4e2d\u83b7\u53d6\u3002\u5b9e\u65f6\u66f4\u65b0\u6570\u636e\u4e5f\u53ef\u4ee5\u4f7f\u7528\uff0c\u4f46\u662f\u53ef\u80fd\u5b58\u5728\u547d\u4e2d\u7387\u4f4e\u7684\u95ee\u9898\uff0c\u53ef\u4ee5\u53c2\u8003\u5982\u4e0bPartitionCache\u3002\n+\n+## PartitionCache\n+\n+### \u8bbe\u8ba1\u539f\u7406\n+1. SQL\u53ef\u4ee5\u5e76\u884c\u62c6\u5206\uff0cQ = Q1 \u222a Q2 ... \u222a Qn\uff0cR= R1 \u222a R2 ... \u222a Rn\uff0cQ\u4e3a\u67e5\u8be2\u8bed\u53e5\uff0cR\u4e3a\u7ed3\u679c\u96c6\n+2. \u62c6\u5206\u4e3a\u53ea\u8bfb\u5206\u533a\u548c\u53ef\u66f4\u65b0\u5206\u533a\uff0c\u53ea\u8bfb\u5206\u533a\u7f13\u5b58\uff0c\u66f4\u65b0\u5206\u533a\u4e0d\u7f13\u5b58\n+\n+\u5982\u4e0a\uff0c\u67e5\u8be2\u6700\u8fd17\u5929\u7684\u6bcf\u5929\u7528\u6237\u6570\uff0c\u5982\u6309\u65e5\u671f\u5206\u533a\uff0c\u6570\u636e\u53ea\u5199\u5f53\u5929\u5206\u533a\uff0c\u5f53\u5929\u4e4b\u5916\u7684\u5176\u4ed6\u5206\u533a\u7684\u6570\u636e\uff0c\u90fd\u662f\u56fa\u5b9a\u4e0d\u53d8\u7684\uff0c\u5728\u76f8\u540c\u7684\u67e5\u8be2SQL\u4e0b\uff0c\u67e5\u8be2\u67d0\u4e2a\u4e0d\u66f4\u65b0\u5206\u533a\u7684\u6307\u6807\u90fd\u662f\u56fa\u5b9a\u7684\u3002\u5982\u4e0b\uff0c\u57282020-03-09\u5f53\u5929\u67e5\u8be2\u524d7\u5929\u7684\u7528\u6237\u6570\uff0c2020-03-03\u81f32020-03-07\u7684\u6570\u636e\u6765\u81ea\u7f13\u5b58\uff0c2020-03-08\u7b2c\u4e00\u6b21\u67e5\u8be2\u6765\u81ea\u5206\u533a\uff0c\u540e\u7eed\u7684\u67e5\u8be2\u6765\u81ea\u7f13\u5b58\uff0c2020-03-09\u56e0\u4e3a\u5f53\u5929\u5728\u4e0d\u505c\u5199\u5165\uff0c\u6240\u4ee5\u6765\u81ea\u5206\u533a\u3002\n+\n+\u56e0\u6b64\uff0c\u67e5\u8be2N\u5929\u7684\u6570\u636e\uff0c\u6570\u636e\u66f4\u65b0\u6700\u8fd1\u7684D\u5929\uff0c\u6bcf\u5929\u53ea\u662f\u65e5\u671f\u8303\u56f4\u4e0d\u4e00\u6837\u76f8\u4f3c\u7684\u67e5\u8be2\uff0c\u53ea\u9700\u8981\u67e5\u8be2D\u4e2a\u5206\u533a\u5373\u53ef\uff0c\u5176\u4ed6\u90e8\u5206\u90fd\u6765\u81ea\u7f13\u5b58\uff0c\u53ef\u4ee5\u6709\u6548\u964d\u4f4e\u96c6\u7fa4\u8d1f\u8f7d\uff0c\u51cf\u5c11\u67e5\u8be2\u65f6\u95f4\u3002\n+\n+```\n+MySQL [(none)]> SELECT eventdate,count(userid) FROM testdb.appevent WHERE eventdate>=\"2020-03-03\" AND eventdate<=\"2020-03-09\" GROUP BY eventdate ORDER BY eventdate;\n++------------+-----------------+\n+| eventdate  | count(`userid`) |\n++------------+-----------------+\n+| 2020-03-03 |              15 |\n+| 2020-03-04 |              20 |\n+| 2020-03-05 |              25 |\n+| 2020-03-06 |              30 |\n+| 2020-03-07 |              35 |\n+| 2020-03-08 |              40 | //\u7b2c\u4e00\u6b21\u6765\u81ea\u5206\u533a\uff0c\u540e\u7eed\u6765\u81ea\u7f13\u5b58\n+| 2020-03-09 |              25 | //\u6765\u81ea\u5206\u533a\n++------------+-----------------+\n+7 rows in set (0.02 sec)\n+```\n+\n+\u5728PartitionCache\u4e2d\uff0c\u7f13\u5b58\u7b2c\u4e00\u7ea7Key\u662f\u53bb\u6389\u4e86\u5206\u533a\u6761\u4ef6\u540e\u7684SQL\u7684128\u4f4dMD5\u7b7e\u540d\uff0c\u4e0b\u9762\u662f\u6539\u5199\u540e\u7684\u5f85\u7b7e\u540d\u7684SQL\uff1a\n+```\n+SELECT eventdate,count(userid) FROM testdb.appevent GROUP BY eventdate ORDER BY eventdate;\n+```\n+\u7f13\u5b58\u7684\u7b2c\u4e8c\u7ea7Key\u662f\u67e5\u8be2\u7ed3\u679c\u96c6\u7684\u5206\u533a\u5b57\u6bb5\u7684\u5185\u5bb9\uff0c\u6bd4\u5982\u4e0a\u9762\u67e5\u8be2\u7ed3\u679c\u7684eventdate\u5217\u7684\u5185\u5bb9\uff0c\u4e8c\u7ea7Key\u7684\u9644\u5c5e\u4fe1\u606f\u662f\u5206\u533a\u7684\u7248\u672c\u53f7\u548c\u7248\u672c\u66f4\u65b0\u65f6\u95f4\u3002\n+\n+\u4e0b\u9762\u6f14\u793a\u4e0a\u9762SQL\u57282020-03-09\u5f53\u5929\u7b2c\u4e00\u6b21\u6267\u884c\u7684\u6d41\u7a0b\uff1a\n+1. \u4ece\u7f13\u5b58\u4e2d\u83b7\u53d6\u6570\u636e\n+```\n++------------+-----------------+\n+| 2020-03-03 |              15 |\n+| 2020-03-04 |              20 |\n+| 2020-03-05 |              25 |\n+| 2020-03-06 |              30 |\n+| 2020-03-07 |              35 |\n++------------+-----------------+\n+```\n+2. \u4eceBE\u4e2d\u83b7\u53d6\u6570\u636e\u7684SQL\u548c\u6570\u636e\n+```\n+SELECT eventdate,count(userid) FROM testdb.appevent WHERE eventdate>=\"2020-03-08\" AND eventdate<=\"2020-03-09\" GROUP BY eventdate ORDER BY eventdate;\n+\n++------------+-----------------+\n+| 2020-03-08 |              40 |\n++------------+-----------------+\n+| 2020-03-09 |              25 | \n++------------+-----------------+\n+```\n+3. \u6700\u540e\u53d1\u9001\u7ed9\u7ec8\u7aef\u7684\u6570\u636e\n+```\n++------------+-----------------+\n+| eventdate  | count(`userid`) |\n++------------+-----------------+\n+| 2020-03-03 |              15 |\n+| 2020-03-04 |              20 |\n+| 2020-03-05 |              25 |\n+| 2020-03-06 |              30 |\n+| 2020-03-07 |              35 |\n+| 2020-03-08 |              40 |\n+| 2020-03-09 |              25 |\n++------------+-----------------+\n+```\n+4. \u53d1\u9001\u7ed9\u7f13\u5b58\u7684\u6570\u636e\n+```\n++------------+-----------------+\n+| 2020-03-08 |              40 |\n++------------+-----------------+\n+```\n+\n+Partition\u7f13\u5b58\uff0c\u9002\u5408\u6309\u65e5\u671f\u5206\u533a\uff0c\u90e8\u5206\u5206\u533a\u5b9e\u65f6\u66f4\u65b0\uff0c\u67e5\u8be2SQL\u8f83\u4e3a\u56fa\u5b9a\u3002\n+\n+\u5206\u533a\u5b57\u6bb5\u4e5f\u53ef\u4ee5\u662f\u5176\u4ed6\u5b57\u6bb5\uff0c\u4f46\u662f\u9700\u8981\u4fdd\u8bc1\u53ea\u6709\u5c11\u91cf\u5206\u533a\u66f4\u65b0\u3002\n+\n+### \u4e00\u4e9b\u9650\u5236\n+* \u53ea\u652f\u6301OlapTable\uff0c\u5176\u4ed6\u5b58\u50a8\u5982MySQL\u7684\u8868\u6ca1\u6709\u7248\u672c\u4fe1\u606f\uff0c\u65e0\u6cd5\u611f\u77e5\u6570\u636e\u662f\u5426\u66f4\u65b0\n+* \u53ea\u652f\u6301\u6309\u5206\u533a\u5b57\u6bb5\u5206\u7ec4\uff0c\u4e0d\u652f\u6301\u6309\u5176\u4ed6\u5b57\u6bb5\u5206\u7ec4\uff0c\u6309\u5176\u4ed6\u5b57\u6bb5\u5206\u7ec4\uff0c\u8be5\u5206\u7ec4\u6570\u636e\u90fd\u6709\u53ef\u80fd\u88ab\u66f4\u65b0\uff0c\u4f1a\u5bfc\u81f4\u7f13\u5b58\u90fd\u5931\u6548\n+* \u53ea\u652f\u6301\u7ed3\u679c\u96c6\u7684\u524d\u534a\u90e8\u5206\u3001\u540e\u534a\u90e8\u5206\u4ee5\u53ca\u5168\u90e8\u547d\u4e2d\u7f13\u5b58\uff0c\u4e0d\u652f\u6301\u7ed3\u679c\u96c6\u88ab\u7f13\u5b58\u6570\u636e\u5206\u5272\u6210\u51e0\u4e2a\u90e8\u5206\n+\n+## \u4f7f\u7528\u65b9\u5f0f\n+### \u5f00\u542fSQLCache\n+fe.conf\u6dfb\u52a0enable_sql_cache=true\n+```\n+vim fe/conf/fe.conf\n+enable_sql_cache=true\n+```\n+\u5728MySQL\u547d\u4ee4\u884c\u4e2d\u8bbe\u7f6e\u53d8\u91cf\n+```\n+MySQL [(none)]> set [global] enable_sql_cache=true;\n+```\n+\u6ce8\uff1aglobal\u662f\u5168\u5c40\u53d8\u91cf\uff0c\u4e0d\u52a0\u6307\u5f53\u524d\u4f1a\u8bdd\u53d8\u91cf\n+\n+### \u5f00\u542fPartitionCache\n+fe.conf\u6dfb\u52a0enable_partition_cache=true\n+```\n+vim fe/conf/fe.conf\n+enable_partition_cache=true\n+```\n+\u5728MySQL\u547d\u4ee4\u884c\u4e2d\u8bbe\u7f6e\u53d8\u91cf\n+```\n+MySQL [(none)]> set [global] enable_partition_cache=true;\n+```\n+\n+\u5982\u679c\u540c\u65f6\u5f00\u542f\u4e86\u4e24\u4e2a\u7f13\u5b58\u7b56\u7565\uff0c\u4e0b\u9762\u7684\u53c2\u6570\uff0c\u9700\u8981\u6ce8\u610f\u4e00\u4e0b:\n+```\n+last_version_interval_second=3600\n+```\n+\u5982\u679c\u5206\u533a\u7684\u6700\u65b0\u7248\u672c\u7684\u65f6\u95f4\u79bb\u73b0\u5728\u7684\u95f4\u9694\uff0c\u5927\u4e8elast_version_interval_second\uff0c\u5219\u4f1a\u4f18\u5148\u628a\u6574\u4e2a\u67e5\u8be2\u7ed3\u679c\u7f13\u5b58\u3002\u5982\u679c\u5c0f\u4e8e\u8fd9\u4e2a\u95f4\u9694\uff0c\u5982\u679c\u7b26\u5408PartitionCache\u7684\u6761\u4ef6\uff0c\u5219\u6309PartitionCache\u6570\u636e\u3002\n+\n+### \u76d1\u63a7\n+FE\u7684\u76d1\u63a7\u9879\uff1a\n+```\n+query_table            //Query\u4e2d\u6709\u8868\u7684\u6570\u91cf\n+query_olap_table       //Query\u4e2d\u6709Olap\u8868\u7684\u6570\u91cf\n+cache_mode_sql         //\u8bc6\u522b\u7f13\u5b58\u6a21\u5f0f\u4e3asql\u7684Query\u6570\u91cf\n+cache_hit_sql          //\u6a21\u5f0f\u4e3asql\u7684Query\u547d\u4e2dCache\u7684\u6570\u91cf\n+query_mode_partition   //\u8bc6\u522b\u7f13\u5b58\u6a21\u5f0f\u4e3aPartition\u7684Query\u6570\u91cf\n+cache_hit_partition\t    //\u901a\u8fc7Partition\u547d\u4e2d\u7684Query\u6570\u91cf\n+partition_all          //Query\u4e2d\u626b\u63cf\u7684\u6240\u6709\u5206\u533a\n+partition_hit          //\u901a\u8fc7Cache\u547d\u4e2d\u7684\u5206\u533a\u6570\u91cf\n+\n+Cache\u547d\u4e2d\u7387     = \uff08cache_hit_sql + cache_hit_partition) / query_olap_table\n+Partition\u547d\u4e2d\u7387 = partition_hit / partition_all\n+```\n+\n+BE\u7684\u76d1\u63a7\u9879\uff1a\n+```\n+cache_memory_total     //Cache\u5185\u5b58\u5927\u5c0f\n+cache_sql_total        //Cache\u7684SQL\u7684\u6570\u91cf\n+cache_partition_total  //Cache\u5206\u533a\u6570\u91cf\n+\n+SQL\u5e73\u5747\u6570\u636e\u5927\u5c0f       = cache_memory_total / cache_sql_total\n+Partition\u5e73\u5747\u6570\u636e\u5927\u5c0f = cache_memory_total / cache_partition_total\n+```\n+\n+\u5176\u4ed6\u76d1\u63a7\uff1a\n+\u53ef\u4ee5\u4eceGrafana\u4e2d\u67e5\u770bBE\u8282\u70b9\u7684CPU\u548c\u5185\u5b58\u6307\u6807\uff0cQuery\u7edf\u8ba1\u4e2d\u7684Query Percentile\u7b49\u6307\u6807\uff0c\u914d\u5408Cache\u53c2\u6570\u7684\u8c03\u6574\u6765\u8fbe\u6210\u4e1a\u52a1\u76ee\u6807\u3002\n+\n+\n+### \u4f18\u5316\u53c2\u6570\n+FE\u7684\u914d\u7f6e\u9879cache_result_max_row_count\uff0c\u67e5\u8be2\u7ed3\u679c\u96c6\u653e\u5165\u7f13\u5b58\u7684\u6700\u5927\u884c\u6570\uff0c\u53ef\u4ee5\u6839\u636e\u5b9e\u9645\u60c5\u51b5\u8c03\u6574\uff0c\u4f46\u5efa\u8bae\u4e0d\u8981\u8bbe\u7f6e\u8fc7\u5927\uff0c\u907f\u514d\u8fc7\u591a\u5360\u7528\u5185\u5b58\uff0c\u8d85\u8fc7\u8fd9\u4e2a\u5927\u5c0f\u7684\u7ed3\u679c\u96c6\u4e0d\u4f1a\u88ab\u7f13\u5b58\u3002\n+```\n+vim fe/conf/fe.conf\n+cache_result_max_row_count=1000\n+```\n+\n+BE\u6700\u5927\u5206\u533a\u6570\u91cfcache_max_partition_count\uff0c\u6307\u6bcf\u4e2aSQL\u5bf9\u5e94\u7684\u6700\u5927\u5206\u533a\u6570\uff0c\u5982\u679c\u662f\u6309\u65e5\u671f\u5206\u533a\uff0c\u80fd\u7f13\u5b582\u5e74\u591a\u7684\u6570\u636e\uff0c\u5047\u5982\u60f3\u4fdd\u7559\u66f4\u957f\u65f6\u95f4\u7684\u7f13\u5b58\uff0c\u8bf7\u628a\u8fd9\u4e2a\u53c2\u6570\u8bbe\u7f6e\u5f97\u66f4\u5927\uff0c\u540c\u65f6\u4fee\u6539cache_result_max_row_count\u7684\u53c2\u6570\u3002\n+```\n+vim be/conf/be.conf\n+cache_max_partition_count=1024\n+```\n+\n+BE\u4e2d\u7f13\u5b58\u5185\u5b58\u8bbe\u7f6e\uff0c\u6709\u4e24\u4e2a\u53c2\u6570cache_max_size\u548ccache_elasticity_size\u4e24\u90e8\u5206\u7ec4\u6210\uff08\u5355\u4f4dMB\uff09\uff0c\u5185\u5b58\u8d85\u8fc7cache_max_size+cache_elasticity_size\u4f1a\u5f00\u59cb\u6e05\u7406\uff0c\u5e76\u628a\u5185\u5b58\u63a7\u5236\u5230cache_max_size\u4ee5\u4e0b\u3002\u53ef\u4ee5\u6839\u636eBE\u8282\u70b9\u6570\u91cf\uff0c\u8282\u70b9\u5185\u5b58\u5927\u5c0f\uff0c\u548c\u7f13\u5b58\u547d\u4e2d\u7387\u6765\u8bbe\u7f6e\u8fd9\u4e24\u4e2a\u53c2\u6570\u3002", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDg0MTMzOnYy", "diffSide": "RIGHT", "path": "docs/zh-CN/administrator-guide/partition_cache.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNDozMTo1MVrOG7jMDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNDozMTo1MVrOG7jMDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA5NTY5Mg==", "bodyText": "the bellow name may be better.\ncache_memory_total__byte\ncache_sql_count\ncache_partition_total_count", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r465095692", "createdAt": "2020-08-04T14:31:51Z", "author": {"login": "wutiangan"}, "path": "docs/zh-CN/administrator-guide/partition_cache.md", "diffHunk": "@@ -0,0 +1,205 @@\n+# \u5206\u533a\u7f13\u5b58\n+\n+## \u9700\u6c42\u573a\u666f\n+\u5927\u90e8\u5206\u6570\u636e\u5206\u6790\u573a\u666f\u662f\u5199\u5c11\u8bfb\u591a\uff0c\u6570\u636e\u5199\u5165\u4e00\u6b21\uff0c\u591a\u6b21\u9891\u7e41\u8bfb\u53d6\uff0c\u6bd4\u5982\u4e00\u5f20\u62a5\u8868\u6d89\u53ca\u7684\u7ef4\u5ea6\u548c\u6307\u6807\uff0c\u6570\u636e\u5728\u51cc\u6668\u4e00\u6b21\u6027\u8ba1\u7b97\u597d\uff0c\u4f46\u6bcf\u5929\u6709\u6570\u767e\u751a\u81f3\u6570\u5343\u6b21\u7684\u9875\u9762\u8bbf\u95ee\uff0c\u56e0\u6b64\u975e\u5e38\u9002\u5408\u628a\u7ed3\u679c\u96c6\u7f13\u5b58\u8d77\u6765\u3002\u5728\u6570\u636e\u5206\u6790\u6216BI\u5e94\u7528\u4e2d\uff0c\u5b58\u5728\u4e0b\u9762\u7684\u4e1a\u52a1\u573a\u666f\uff1a\n+* **\u9ad8\u5e76\u53d1\u573a\u666f**\uff0cDoris\u53ef\u4ee5\u8f83\u597d\u7684\u652f\u6301\u9ad8\u5e76\u53d1\uff0c\u4f46\u5355\u53f0\u670d\u52a1\u5668\u65e0\u6cd5\u627f\u8f7d\u592a\u9ad8\u7684QPS\n+* **\u590d\u6742\u56fe\u8868\u7684\u770b\u677f**\uff0c\u590d\u6742\u7684Dashboard\u6216\u8005\u5927\u5c4f\u7c7b\u5e94\u7528\uff0c\u6570\u636e\u6765\u81ea\u591a\u5f20\u8868\uff0c\u6bcf\u4e2a\u9875\u9762\u6709\u6570\u5341\u4e2a\u67e5\u8be2\uff0c\u867d\u7136\u6bcf\u4e2a\u67e5\u8be2\u53ea\u6709\u6570\u5341\u6beb\u79d2\uff0c\u4f46\u662f\u603b\u4f53\u67e5\u8be2\u65f6\u95f4\u4f1a\u5728\u6570\u79d2\n+* **\u8d8b\u52bf\u5206\u6790**\uff0c\u7ed9\u5b9a\u65e5\u671f\u8303\u56f4\u7684\u67e5\u8be2\uff0c\u6307\u6807\u6309\u65e5\u663e\u793a\uff0c\u6bd4\u5982\u67e5\u8be2\u6700\u8fd17\u5929\u5185\u7684\u7528\u6237\u6570\u7684\u8d8b\u52bf\uff0c\u8fd9\u7c7b\u67e5\u8be2\u6570\u636e\u91cf\u5927\uff0c\u67e5\u8be2\u8303\u56f4\u5e7f\uff0c\u67e5\u8be2\u65f6\u95f4\u5f80\u5f80\u9700\u8981\u6570\u5341\u79d2\n+* **\u7528\u6237\u91cd\u590d\u67e5\u8be2**\uff0c\u5982\u679c\u4ea7\u54c1\u6ca1\u6709\u9632\u91cd\u5237\u673a\u5236\uff0c\u7528\u6237\u56e0\u624b\u8bef\u6216\u5176\u4ed6\u539f\u56e0\u91cd\u590d\u5237\u65b0\u9875\u9762\uff0c\u5bfc\u81f4\u63d0\u4ea4\u5927\u91cf\u7684\u91cd\u590d\u7684SQL\n+\n+\u4ee5\u4e0a\u56db\u79cd\u573a\u666f\uff0c\u5728\u5e94\u7528\u5c42\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u628a\u67e5\u8be2\u7ed3\u679c\u653e\u5230Redis\u4e2d\uff0c\u5468\u671f\u6027\u7684\u66f4\u65b0\u7f13\u5b58\u6216\u8005\u7528\u6237\u624b\u5de5\u5237\u65b0\u7f13\u5b58\uff0c\u4f46\u662f\u8fd9\u4e2a\u65b9\u6848\u6709\u5982\u4e0b\u95ee\u9898\uff1a\n+* **\u6570\u636e\u4e0d\u4e00\u81f4**\uff0c\u65e0\u6cd5\u611f\u77e5\u6570\u636e\u7684\u66f4\u65b0\uff0c\u5bfc\u81f4\u7528\u6237\u7ecf\u5e38\u770b\u5230\u65e7\u7684\u6570\u636e\n+* **\u547d\u4e2d\u7387\u4f4e**\uff0c\u7f13\u5b58\u6574\u4e2a\u67e5\u8be2\u7ed3\u679c\uff0c\u5982\u679c\u6570\u636e\u5b9e\u65f6\u5199\u5165\uff0c\u7f13\u5b58\u9891\u7e41\u5931\u6548\uff0c\u547d\u4e2d\u7387\u4f4e\u4e14\u7cfb\u7edf\u8d1f\u8f7d\u8f83\u91cd\n+* **\u989d\u5916\u6210\u672c**\uff0c\u5f15\u5165\u5916\u90e8\u7f13\u5b58\u7ec4\u4ef6\uff0c\u4f1a\u5e26\u6765\u7cfb\u7edf\u590d\u6742\u5ea6\uff0c\u589e\u52a0\u989d\u5916\u6210\u672c\n+\n+## \u89e3\u51b3\u65b9\u6848\n+\u672c\u5206\u533a\u7f13\u5b58\u7b56\u7565\u53ef\u4ee5\u89e3\u51b3\u4e0a\u9762\u7684\u95ee\u9898\uff0c\u4f18\u5148\u4fdd\u8bc1\u6570\u636e\u4e00\u81f4\u6027\uff0c\u5728\u6b64\u57fa\u7840\u4e0a\u7ec6\u5316\u7f13\u5b58\u7c92\u5ea6\uff0c\u63d0\u5347\u547d\u4e2d\u7387\uff0c\u56e0\u6b64\u6709\u5982\u4e0b\u7279\u70b9\uff1a\n+* \u7528\u6237\u65e0\u9700\u62c5\u5fc3\u6570\u636e\u4e00\u81f4\u6027\uff0c\u901a\u8fc7\u7248\u672c\u6765\u63a7\u5236\u7f13\u5b58\u5931\u6548\uff0c\u7f13\u5b58\u7684\u6570\u636e\u548c\u4eceBE\u4e2d\u67e5\u8be2\u7684\u6570\u636e\u662f\u4e00\u81f4\u7684\n+* \u6ca1\u6709\u989d\u5916\u7684\u7ec4\u4ef6\u548c\u6210\u672c\uff0c\u7f13\u5b58\u7ed3\u679c\u5b58\u50a8\u5728BE\u7684\u5185\u5b58\u4e2d\uff0c\u7528\u6237\u53ef\u4ee5\u6839\u636e\u9700\u8981\u8c03\u6574\u7f13\u5b58\u5185\u5b58\u5927\u5c0f\n+* \u5b9e\u73b0\u4e86\u4e24\u79cd\u7f13\u5b58\u7b56\u7565\uff0cSQLCache\u548cPartitionCache\uff0c\u540e\u8005\u7f13\u5b58\u7c92\u5ea6\u66f4\u7ec6\n+* \u7528\u4e00\u81f4\u6027\u54c8\u5e0c\u89e3\u51b3BE\u8282\u70b9\u4e0a\u4e0b\u7ebf\u7684\u95ee\u9898\uff0cBE\u4e2d\u7684\u7f13\u5b58\u7b97\u6cd5\u662f\u6539\u8fdb\u7684LRU\n+\n+## SQLCache\n+SQLCache\u6309SQL\u7684\u7b7e\u540d\u3001\u67e5\u8be2\u7684\u8868\u7684\u5206\u533aID\u3001\u5206\u533a\u6700\u65b0\u7248\u672c\u6765\u5b58\u50a8\u548c\u83b7\u53d6\u7f13\u5b58\u3002\u4e09\u8005\u7ec4\u5408\u786e\u5b9a\u4e00\u4e2a\u7f13\u5b58\u6570\u636e\u96c6\uff0c\u4efb\u4f55\u4e00\u4e2a\u53d8\u5316\u4e86\uff0c\u5982SQL\u6709\u53d8\u5316\uff0c\u5982\u67e5\u8be2\u5b57\u6bb5\u6216\u6761\u4ef6\u4e0d\u4e00\u6837\uff0c\u6216\u6570\u636e\u66f4\u65b0\u540e\u7248\u672c\u53d8\u5316\u4e86\uff0c\u4f1a\u5bfc\u81f4\u547d\u4e2d\u4e0d\u4e86\u7f13\u5b58\u3002\n+\n+\u5982\u679c\u591a\u5f20\u8868Join\uff0c\u4f7f\u7528\u6700\u8fd1\u66f4\u65b0\u7684\u5206\u533aID\u548c\u6700\u65b0\u7684\u7248\u672c\u53f7\uff0c\u5982\u679c\u5176\u4e2d\u4e00\u5f20\u8868\u66f4\u65b0\u4e86\uff0c\u4f1a\u5bfc\u81f4\u5206\u533aID\u6216\u7248\u672c\u53f7\u4e0d\u4e00\u6837\uff0c\u4e5f\u4e00\u6837\u547d\u4e2d\u4e0d\u4e86\u7f13\u5b58\u3002\n+\n+SQLCache\uff0c\u66f4\u9002\u5408T+1\u66f4\u65b0\u7684\u573a\u666f\uff0c\u51cc\u6668\u6570\u636e\u66f4\u65b0\uff0c\u9996\u6b21\u67e5\u8be2\u4eceBE\u4e2d\u83b7\u53d6\u7ed3\u679c\u653e\u5165\u5230\u7f13\u5b58\u4e2d\uff0c\u540e\u7eed\u76f8\u540c\u67e5\u8be2\u4ece\u7f13\u5b58\u4e2d\u83b7\u53d6\u3002\u5b9e\u65f6\u66f4\u65b0\u6570\u636e\u4e5f\u53ef\u4ee5\u4f7f\u7528\uff0c\u4f46\u662f\u53ef\u80fd\u5b58\u5728\u547d\u4e2d\u7387\u4f4e\u7684\u95ee\u9898\uff0c\u53ef\u4ee5\u53c2\u8003\u5982\u4e0bPartitionCache\u3002\n+\n+## PartitionCache\n+\n+### \u8bbe\u8ba1\u539f\u7406\n+1. SQL\u53ef\u4ee5\u5e76\u884c\u62c6\u5206\uff0cQ = Q1 \u222a Q2 ... \u222a Qn\uff0cR= R1 \u222a R2 ... \u222a Rn\uff0cQ\u4e3a\u67e5\u8be2\u8bed\u53e5\uff0cR\u4e3a\u7ed3\u679c\u96c6\n+2. \u62c6\u5206\u4e3a\u53ea\u8bfb\u5206\u533a\u548c\u53ef\u66f4\u65b0\u5206\u533a\uff0c\u53ea\u8bfb\u5206\u533a\u7f13\u5b58\uff0c\u66f4\u65b0\u5206\u533a\u4e0d\u7f13\u5b58\n+\n+\u5982\u4e0a\uff0c\u67e5\u8be2\u6700\u8fd17\u5929\u7684\u6bcf\u5929\u7528\u6237\u6570\uff0c\u5982\u6309\u65e5\u671f\u5206\u533a\uff0c\u6570\u636e\u53ea\u5199\u5f53\u5929\u5206\u533a\uff0c\u5f53\u5929\u4e4b\u5916\u7684\u5176\u4ed6\u5206\u533a\u7684\u6570\u636e\uff0c\u90fd\u662f\u56fa\u5b9a\u4e0d\u53d8\u7684\uff0c\u5728\u76f8\u540c\u7684\u67e5\u8be2SQL\u4e0b\uff0c\u67e5\u8be2\u67d0\u4e2a\u4e0d\u66f4\u65b0\u5206\u533a\u7684\u6307\u6807\u90fd\u662f\u56fa\u5b9a\u7684\u3002\u5982\u4e0b\uff0c\u57282020-03-09\u5f53\u5929\u67e5\u8be2\u524d7\u5929\u7684\u7528\u6237\u6570\uff0c2020-03-03\u81f32020-03-07\u7684\u6570\u636e\u6765\u81ea\u7f13\u5b58\uff0c2020-03-08\u7b2c\u4e00\u6b21\u67e5\u8be2\u6765\u81ea\u5206\u533a\uff0c\u540e\u7eed\u7684\u67e5\u8be2\u6765\u81ea\u7f13\u5b58\uff0c2020-03-09\u56e0\u4e3a\u5f53\u5929\u5728\u4e0d\u505c\u5199\u5165\uff0c\u6240\u4ee5\u6765\u81ea\u5206\u533a\u3002\n+\n+\u56e0\u6b64\uff0c\u67e5\u8be2N\u5929\u7684\u6570\u636e\uff0c\u6570\u636e\u66f4\u65b0\u6700\u8fd1\u7684D\u5929\uff0c\u6bcf\u5929\u53ea\u662f\u65e5\u671f\u8303\u56f4\u4e0d\u4e00\u6837\u76f8\u4f3c\u7684\u67e5\u8be2\uff0c\u53ea\u9700\u8981\u67e5\u8be2D\u4e2a\u5206\u533a\u5373\u53ef\uff0c\u5176\u4ed6\u90e8\u5206\u90fd\u6765\u81ea\u7f13\u5b58\uff0c\u53ef\u4ee5\u6709\u6548\u964d\u4f4e\u96c6\u7fa4\u8d1f\u8f7d\uff0c\u51cf\u5c11\u67e5\u8be2\u65f6\u95f4\u3002\n+\n+```\n+MySQL [(none)]> SELECT eventdate,count(userid) FROM testdb.appevent WHERE eventdate>=\"2020-03-03\" AND eventdate<=\"2020-03-09\" GROUP BY eventdate ORDER BY eventdate;\n++------------+-----------------+\n+| eventdate  | count(`userid`) |\n++------------+-----------------+\n+| 2020-03-03 |              15 |\n+| 2020-03-04 |              20 |\n+| 2020-03-05 |              25 |\n+| 2020-03-06 |              30 |\n+| 2020-03-07 |              35 |\n+| 2020-03-08 |              40 | //\u7b2c\u4e00\u6b21\u6765\u81ea\u5206\u533a\uff0c\u540e\u7eed\u6765\u81ea\u7f13\u5b58\n+| 2020-03-09 |              25 | //\u6765\u81ea\u5206\u533a\n++------------+-----------------+\n+7 rows in set (0.02 sec)\n+```\n+\n+\u5728PartitionCache\u4e2d\uff0c\u7f13\u5b58\u7b2c\u4e00\u7ea7Key\u662f\u53bb\u6389\u4e86\u5206\u533a\u6761\u4ef6\u540e\u7684SQL\u7684128\u4f4dMD5\u7b7e\u540d\uff0c\u4e0b\u9762\u662f\u6539\u5199\u540e\u7684\u5f85\u7b7e\u540d\u7684SQL\uff1a\n+```\n+SELECT eventdate,count(userid) FROM testdb.appevent GROUP BY eventdate ORDER BY eventdate;\n+```\n+\u7f13\u5b58\u7684\u7b2c\u4e8c\u7ea7Key\u662f\u67e5\u8be2\u7ed3\u679c\u96c6\u7684\u5206\u533a\u5b57\u6bb5\u7684\u5185\u5bb9\uff0c\u6bd4\u5982\u4e0a\u9762\u67e5\u8be2\u7ed3\u679c\u7684eventdate\u5217\u7684\u5185\u5bb9\uff0c\u4e8c\u7ea7Key\u7684\u9644\u5c5e\u4fe1\u606f\u662f\u5206\u533a\u7684\u7248\u672c\u53f7\u548c\u7248\u672c\u66f4\u65b0\u65f6\u95f4\u3002\n+\n+\u4e0b\u9762\u6f14\u793a\u4e0a\u9762SQL\u57282020-03-09\u5f53\u5929\u7b2c\u4e00\u6b21\u6267\u884c\u7684\u6d41\u7a0b\uff1a\n+1. \u4ece\u7f13\u5b58\u4e2d\u83b7\u53d6\u6570\u636e\n+```\n++------------+-----------------+\n+| 2020-03-03 |              15 |\n+| 2020-03-04 |              20 |\n+| 2020-03-05 |              25 |\n+| 2020-03-06 |              30 |\n+| 2020-03-07 |              35 |\n++------------+-----------------+\n+```\n+2. \u4eceBE\u4e2d\u83b7\u53d6\u6570\u636e\u7684SQL\u548c\u6570\u636e\n+```\n+SELECT eventdate,count(userid) FROM testdb.appevent WHERE eventdate>=\"2020-03-08\" AND eventdate<=\"2020-03-09\" GROUP BY eventdate ORDER BY eventdate;\n+\n++------------+-----------------+\n+| 2020-03-08 |              40 |\n++------------+-----------------+\n+| 2020-03-09 |              25 | \n++------------+-----------------+\n+```\n+3. \u6700\u540e\u53d1\u9001\u7ed9\u7ec8\u7aef\u7684\u6570\u636e\n+```\n++------------+-----------------+\n+| eventdate  | count(`userid`) |\n++------------+-----------------+\n+| 2020-03-03 |              15 |\n+| 2020-03-04 |              20 |\n+| 2020-03-05 |              25 |\n+| 2020-03-06 |              30 |\n+| 2020-03-07 |              35 |\n+| 2020-03-08 |              40 |\n+| 2020-03-09 |              25 |\n++------------+-----------------+\n+```\n+4. \u53d1\u9001\u7ed9\u7f13\u5b58\u7684\u6570\u636e\n+```\n++------------+-----------------+\n+| 2020-03-08 |              40 |\n++------------+-----------------+\n+```\n+\n+Partition\u7f13\u5b58\uff0c\u9002\u5408\u6309\u65e5\u671f\u5206\u533a\uff0c\u90e8\u5206\u5206\u533a\u5b9e\u65f6\u66f4\u65b0\uff0c\u67e5\u8be2SQL\u8f83\u4e3a\u56fa\u5b9a\u3002\n+\n+\u5206\u533a\u5b57\u6bb5\u4e5f\u53ef\u4ee5\u662f\u5176\u4ed6\u5b57\u6bb5\uff0c\u4f46\u662f\u9700\u8981\u4fdd\u8bc1\u53ea\u6709\u5c11\u91cf\u5206\u533a\u66f4\u65b0\u3002\n+\n+### \u4e00\u4e9b\u9650\u5236\n+* \u53ea\u652f\u6301OlapTable\uff0c\u5176\u4ed6\u5b58\u50a8\u5982MySQL\u7684\u8868\u6ca1\u6709\u7248\u672c\u4fe1\u606f\uff0c\u65e0\u6cd5\u611f\u77e5\u6570\u636e\u662f\u5426\u66f4\u65b0\n+* \u53ea\u652f\u6301\u6309\u5206\u533a\u5b57\u6bb5\u5206\u7ec4\uff0c\u4e0d\u652f\u6301\u6309\u5176\u4ed6\u5b57\u6bb5\u5206\u7ec4\uff0c\u6309\u5176\u4ed6\u5b57\u6bb5\u5206\u7ec4\uff0c\u8be5\u5206\u7ec4\u6570\u636e\u90fd\u6709\u53ef\u80fd\u88ab\u66f4\u65b0\uff0c\u4f1a\u5bfc\u81f4\u7f13\u5b58\u90fd\u5931\u6548\n+* \u53ea\u652f\u6301\u7ed3\u679c\u96c6\u7684\u524d\u534a\u90e8\u5206\u3001\u540e\u534a\u90e8\u5206\u4ee5\u53ca\u5168\u90e8\u547d\u4e2d\u7f13\u5b58\uff0c\u4e0d\u652f\u6301\u7ed3\u679c\u96c6\u88ab\u7f13\u5b58\u6570\u636e\u5206\u5272\u6210\u51e0\u4e2a\u90e8\u5206\n+\n+## \u4f7f\u7528\u65b9\u5f0f\n+### \u5f00\u542fSQLCache\n+fe.conf\u6dfb\u52a0enable_sql_cache=true\n+```\n+vim fe/conf/fe.conf\n+enable_sql_cache=true\n+```\n+\u5728MySQL\u547d\u4ee4\u884c\u4e2d\u8bbe\u7f6e\u53d8\u91cf\n+```\n+MySQL [(none)]> set [global] enable_sql_cache=true;\n+```\n+\u6ce8\uff1aglobal\u662f\u5168\u5c40\u53d8\u91cf\uff0c\u4e0d\u52a0\u6307\u5f53\u524d\u4f1a\u8bdd\u53d8\u91cf\n+\n+### \u5f00\u542fPartitionCache\n+fe.conf\u6dfb\u52a0enable_partition_cache=true\n+```\n+vim fe/conf/fe.conf\n+enable_partition_cache=true\n+```\n+\u5728MySQL\u547d\u4ee4\u884c\u4e2d\u8bbe\u7f6e\u53d8\u91cf\n+```\n+MySQL [(none)]> set [global] enable_partition_cache=true;\n+```\n+\n+\u5982\u679c\u540c\u65f6\u5f00\u542f\u4e86\u4e24\u4e2a\u7f13\u5b58\u7b56\u7565\uff0c\u4e0b\u9762\u7684\u53c2\u6570\uff0c\u9700\u8981\u6ce8\u610f\u4e00\u4e0b:\n+```\n+last_version_interval_second=3600\n+```\n+\u5982\u679c\u5206\u533a\u7684\u6700\u65b0\u7248\u672c\u7684\u65f6\u95f4\u79bb\u73b0\u5728\u7684\u95f4\u9694\uff0c\u5927\u4e8elast_version_interval_second\uff0c\u5219\u4f1a\u4f18\u5148\u628a\u6574\u4e2a\u67e5\u8be2\u7ed3\u679c\u7f13\u5b58\u3002\u5982\u679c\u5c0f\u4e8e\u8fd9\u4e2a\u95f4\u9694\uff0c\u5982\u679c\u7b26\u5408PartitionCache\u7684\u6761\u4ef6\uff0c\u5219\u6309PartitionCache\u6570\u636e\u3002\n+\n+### \u76d1\u63a7\n+FE\u7684\u76d1\u63a7\u9879\uff1a\n+```\n+query_table            //Query\u4e2d\u6709\u8868\u7684\u6570\u91cf\n+query_olap_table       //Query\u4e2d\u6709Olap\u8868\u7684\u6570\u91cf\n+cache_mode_sql         //\u8bc6\u522b\u7f13\u5b58\u6a21\u5f0f\u4e3asql\u7684Query\u6570\u91cf\n+cache_hit_sql          //\u6a21\u5f0f\u4e3asql\u7684Query\u547d\u4e2dCache\u7684\u6570\u91cf\n+query_mode_partition   //\u8bc6\u522b\u7f13\u5b58\u6a21\u5f0f\u4e3aPartition\u7684Query\u6570\u91cf\n+cache_hit_partition\t    //\u901a\u8fc7Partition\u547d\u4e2d\u7684Query\u6570\u91cf\n+partition_all          //Query\u4e2d\u626b\u63cf\u7684\u6240\u6709\u5206\u533a\n+partition_hit          //\u901a\u8fc7Cache\u547d\u4e2d\u7684\u5206\u533a\u6570\u91cf\n+\n+Cache\u547d\u4e2d\u7387     = \uff08cache_hit_sql + cache_hit_partition) / query_olap_table\n+Partition\u547d\u4e2d\u7387 = partition_hit / partition_all\n+```\n+\n+BE\u7684\u76d1\u63a7\u9879\uff1a\n+```\n+cache_memory_total     //Cache\u5185\u5b58\u5927\u5c0f\n+cache_sql_total        //Cache\u7684SQL\u7684\u6570\u91cf", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311dccb3e579b2993280f345a54ac82fe982a1b1"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTQ0OTE3OnYy", "diffSide": "RIGHT", "path": "be/src/common/config.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwMTo1MDowOVrOHFSJzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwMTo1MDowOVrOHFSJzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMwMjM0OA==", "bodyText": "I do not think  elasticity means what you want?", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r475302348", "createdAt": "2020-08-24T01:50:09Z", "author": {"login": "wuyunfeng"}, "path": "be/src/common/config.h", "diffHunk": "@@ -570,6 +570,16 @@ namespace config {\n \n     // Soft memory limit as a fraction of hard memory limit.\n     CONF_Double(soft_mem_limit_frac, \"0.9\");\n+    \n+    // Set max cache's size of query results, the unit is M byte\n+    CONF_Int32(query_cache_max_size_mb, \"256\"); \n+\n+    // Cache memory is pruned when reach query_cache_max_size_mb + query_cache_elasticity_size_mb\n+    CONF_Int32(query_cache_elasticity_size_mb, \"128\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0015dcaff193e0dfef3270683ba5a546bf974b10"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzAxMDE1OnYy", "diffSide": "LEFT", "path": "fe/fe-core/src/main/java/org/apache/doris/common/Config.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMTo0MDozMFrOHFgnjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMTo0MDozMFrOHFgnjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzOTM0MA==", "bodyText": "This file has been deleted?", "url": "https://github.com/apache/incubator-doris/pull/4005#discussion_r475539340", "createdAt": "2020-08-24T11:40:30Z", "author": {"login": "morningman"}, "path": "fe/fe-core/src/main/java/org/apache/doris/common/Config.java", "diffHunk": "@@ -1,1221 +0,0 @@\n-// Licensed to the Apache Software Foundation (ASF) under one\n-// or more contributor license agreements.  See the NOTICE file\n-// distributed with this work for additional information\n-// regarding copyright ownership.  The ASF licenses this file\n-// to you under the Apache License, Version 2.0 (the\n-// \"License\"); you may not use this file except in compliance\n-// with the License.  You may obtain a copy of the License at\n-//\n-//   http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing,\n-// software distributed under the License is distributed on an\n-// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-// KIND, either express or implied.  See the License for the\n-// specific language governing permissions and limitations\n-// under the License.\n-\n-package org.apache.doris.common;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0015dcaff193e0dfef3270683ba5a546bf974b10"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1353, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}