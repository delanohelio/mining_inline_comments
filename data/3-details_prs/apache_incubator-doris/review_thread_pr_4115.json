{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxOTc2NjQ5", "number": 4115, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozNDo1MlrOERemFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwODoyMjoyOVrOEWICVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzYyNTE5OnYy", "diffSide": "RIGHT", "path": "be/src/util/doris_metrics.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozNDo1MlrOG2Nd2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozNDo1MlrOG2Nd2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5NjkyMA==", "bodyText": "Use 4 space instead of tab", "url": "https://github.com/apache/incubator-doris/pull/4115#discussion_r459496920", "createdAt": "2020-07-23T14:34:52Z", "author": {"login": "morningman"}, "path": "be/src/util/doris_metrics.h", "diffHunk": "@@ -28,163 +28,152 @@\n \n namespace doris {\n \n-class IntGaugeMetricsMap {\n-public:\n-    void set_metric(const std::string& key, int64_t val) {\n-        auto metric = metrics.find(key);\n-        if (metric != metrics.end()) {\n-            metric->second->set_value(val);\n-        }\n-    }\n-\n-    IntGauge* add_metric(const std::string& key, const MetricUnit unit) {\n-        metrics.emplace(key, new IntGauge(unit));\n-        return metrics.find(key)->second.get();\n-    }\n-\n-private:\n-    std::unordered_map<std::string, std::unique_ptr<IntGauge>> metrics;\n-};\n-\n-#define REGISTER_GAUGE_DORIS_METRIC(name, func) \\\n-  DorisMetrics::instance()->metrics()->register_metric(#name, &DorisMetrics::instance()->name); \\\n-  DorisMetrics::instance()->metrics()->register_hook(#name, [&]() { \\\n+#define REGISTER_HOOK_METRIC(name, func) \\\n+  DorisMetrics::instance()->server_entity()->register_metric(&METRIC_##name, &DorisMetrics::instance()->name); \\\n+  DorisMetrics::instance()->server_entity()->register_hook(#name, [&]() { \\\n       DorisMetrics::instance()->name.set_value(func());  \\\n });\n \n+#define DEREGISTER_HOOK_METRIC(name) \\\n+  DorisMetrics::instance()->server_entity()->deregister_metric(&METRIC_##name); \\\n+  DorisMetrics::instance()->server_entity()->deregister_hook(#name);\n+\n class DorisMetrics {\n public:\n-    // counters\n-    METRIC_DEFINE_INT_COUNTER(fragment_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(fragment_request_duration_us, MetricUnit::MICROSECONDS);\n-    METRIC_DEFINE_INT_COUNTER(http_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(http_request_send_bytes, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(query_scan_bytes, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(query_scan_rows, MetricUnit::ROWS);\n-    METRIC_DEFINE_INT_COUNTER(push_requests_success_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(push_requests_fail_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(push_request_duration_us, MetricUnit::MICROSECONDS);\n-    METRIC_DEFINE_INT_COUNTER(push_request_write_bytes, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(push_request_write_rows, MetricUnit::ROWS);\n-    METRIC_DEFINE_INT_COUNTER(create_tablet_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(create_tablet_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(drop_tablet_requests_total, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(report_all_tablets_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_all_tablets_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_tablet_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_tablet_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_disk_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_disk_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_task_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_task_requests_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(schema_change_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(schema_change_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(create_rollup_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(create_rollup_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(storage_migrate_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(delete_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(delete_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(clone_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(clone_requests_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(finish_task_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(finish_task_requests_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_request_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_request_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_deltas_total, MetricUnit::ROWSETS);\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_bytes_total, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_deltas_total, MetricUnit::ROWSETS);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_bytes_total, MetricUnit::BYTES);\n-\n-    METRIC_DEFINE_INT_COUNTER(publish_task_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(publish_task_failed_total, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(meta_write_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(meta_write_request_duration_us, MetricUnit::MICROSECONDS);\n-    METRIC_DEFINE_INT_COUNTER(meta_read_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(meta_read_request_duration_us, MetricUnit::MICROSECONDS);\n+    //METRIC_DEFINE_INT_COUNTER(load_rows_total, MetricUnit::ROWS);\n+    //METRIC_DEFINE_INT_COUNTER(load_bytes_total, MetricUnit::BYTES);\n+\n+    //IntGaugeMetricsMap disks_total_capacity;\n+    //IntGaugeMetricsMap disks_avail_capacity;\n+    //IntGaugeMetricsMap disks_data_used_capacity;\n+    //IntGaugeMetricsMap disks_state;\n+\n+    IntCounter fragment_requests_total;\n+\tIntCounter fragment_request_duration_us;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6408d940d09614e6351f9eb3fcec1b775392c679"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzYyNTg1OnYy", "diffSide": "RIGHT", "path": "be/src/util/doris_metrics.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozNDo1OVrOG2NeRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozNDo1OVrOG2NeRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5NzAyOA==", "bodyText": "Remove the unused code", "url": "https://github.com/apache/incubator-doris/pull/4115#discussion_r459497028", "createdAt": "2020-07-23T14:34:59Z", "author": {"login": "morningman"}, "path": "be/src/util/doris_metrics.h", "diffHunk": "@@ -28,163 +28,152 @@\n \n namespace doris {\n \n-class IntGaugeMetricsMap {\n-public:\n-    void set_metric(const std::string& key, int64_t val) {\n-        auto metric = metrics.find(key);\n-        if (metric != metrics.end()) {\n-            metric->second->set_value(val);\n-        }\n-    }\n-\n-    IntGauge* add_metric(const std::string& key, const MetricUnit unit) {\n-        metrics.emplace(key, new IntGauge(unit));\n-        return metrics.find(key)->second.get();\n-    }\n-\n-private:\n-    std::unordered_map<std::string, std::unique_ptr<IntGauge>> metrics;\n-};\n-\n-#define REGISTER_GAUGE_DORIS_METRIC(name, func) \\\n-  DorisMetrics::instance()->metrics()->register_metric(#name, &DorisMetrics::instance()->name); \\\n-  DorisMetrics::instance()->metrics()->register_hook(#name, [&]() { \\\n+#define REGISTER_HOOK_METRIC(name, func) \\\n+  DorisMetrics::instance()->server_entity()->register_metric(&METRIC_##name, &DorisMetrics::instance()->name); \\\n+  DorisMetrics::instance()->server_entity()->register_hook(#name, [&]() { \\\n       DorisMetrics::instance()->name.set_value(func());  \\\n });\n \n+#define DEREGISTER_HOOK_METRIC(name) \\\n+  DorisMetrics::instance()->server_entity()->deregister_metric(&METRIC_##name); \\\n+  DorisMetrics::instance()->server_entity()->deregister_hook(#name);\n+\n class DorisMetrics {\n public:\n-    // counters\n-    METRIC_DEFINE_INT_COUNTER(fragment_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(fragment_request_duration_us, MetricUnit::MICROSECONDS);\n-    METRIC_DEFINE_INT_COUNTER(http_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(http_request_send_bytes, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(query_scan_bytes, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(query_scan_rows, MetricUnit::ROWS);\n-    METRIC_DEFINE_INT_COUNTER(push_requests_success_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(push_requests_fail_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(push_request_duration_us, MetricUnit::MICROSECONDS);\n-    METRIC_DEFINE_INT_COUNTER(push_request_write_bytes, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(push_request_write_rows, MetricUnit::ROWS);\n-    METRIC_DEFINE_INT_COUNTER(create_tablet_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(create_tablet_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(drop_tablet_requests_total, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(report_all_tablets_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_all_tablets_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_tablet_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_tablet_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_disk_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_disk_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_task_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_task_requests_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(schema_change_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(schema_change_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(create_rollup_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(create_rollup_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(storage_migrate_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(delete_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(delete_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(clone_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(clone_requests_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(finish_task_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(finish_task_requests_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_request_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_request_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_deltas_total, MetricUnit::ROWSETS);\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_bytes_total, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_deltas_total, MetricUnit::ROWSETS);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_bytes_total, MetricUnit::BYTES);\n-\n-    METRIC_DEFINE_INT_COUNTER(publish_task_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(publish_task_failed_total, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(meta_write_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(meta_write_request_duration_us, MetricUnit::MICROSECONDS);\n-    METRIC_DEFINE_INT_COUNTER(meta_read_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(meta_read_request_duration_us, MetricUnit::MICROSECONDS);\n+    //METRIC_DEFINE_INT_COUNTER(load_rows_total, MetricUnit::ROWS);\n+    //METRIC_DEFINE_INT_COUNTER(load_bytes_total, MetricUnit::BYTES);\n+\n+    //IntGaugeMetricsMap disks_total_capacity;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6408d940d09614e6351f9eb3fcec1b775392c679"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNjM1NDg1OnYy", "diffSide": "RIGHT", "path": "be/src/util/metrics.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwODoyMTozMFrOG9RB1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwODoyMTozMFrOG9RB1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg5NTMxOQ==", "bodyText": "may be used DEFINE_METRIC_PROTOTYPE better", "url": "https://github.com/apache/incubator-doris/pull/4115#discussion_r466895319", "createdAt": "2020-08-07T08:21:30Z", "author": {"login": "chaoyli"}, "path": "be/src/util/metrics.h", "diffHunk": "@@ -193,230 +174,163 @@ class CoreLocalCounter : public Metric {\n     void increment(const T& delta) {\n         __sync_fetch_and_add(_value.access(), delta);\n     }\n+\n+    rj::Value to_json_value() const override {\n+        return rj::Value(value());\n+    }\n+\n protected:\n     CoreLocalValue<T> _value;\n };\n \n template<typename T>\n class AtomicCounter : public AtomicMetric<T> {\n public:\n-    AtomicCounter(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~AtomicCounter() { }\n+    AtomicCounter() {}\n+    virtual ~AtomicCounter() {}\n };\n \n template<typename T>\n class AtomicGauge : public AtomicMetric<T> {\n public:\n-    AtomicGauge(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~AtomicGauge() { }\n+    AtomicGauge() : AtomicMetric<T>() {}\n+    virtual ~AtomicGauge() {}\n };\n \n template<typename T>\n class LockCounter : public LockSimpleMetric<T> {\n public:\n-    LockCounter(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~LockCounter() { }\n+    LockCounter() : LockSimpleMetric<T>() {}\n+    virtual ~LockCounter() {}\n };\n \n // This can only used for trival type\n template<typename T>\n class LockGauge : public LockSimpleMetric<T> {\n public:\n-    LockGauge(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~LockGauge() { }\n+    LockGauge() : LockSimpleMetric<T>() {}\n+    virtual ~LockGauge() {}\n };\n \n-// one key-value pair used to\n-struct MetricLabel {\n+using Labels = std::unordered_map<std::string, std::string>;\n+struct MetricPrototype {\n+public:\n+    MetricPrototype(MetricType type_,\n+                    MetricUnit unit_,\n+                    std::string name_,\n+                    std::string description_ = \"\",\n+                    std::string group_name_ = \"\",\n+                    Labels labels_ = Labels(),\n+                    bool is_core_metric_ = false)\n+        : is_core_metric(is_core_metric_),\n+          type(type_),\n+          unit(unit_),\n+          name(std::move(name_)),\n+          description(std::move(description_)),\n+          group_name(std::move(group_name_)),\n+          labels(std::move(labels_)) {}\n+\n+    std::string simple_name() const;\n+    std::string combine_name(const std::string& registry_name) const;\n+\n+    bool is_core_metric;\n+    MetricType type;\n+    MetricUnit unit;\n     std::string name;\n-    std::string value;\n+    std::string description;\n+    std::string group_name;\n+    Labels labels;\n+};\n \n-    MetricLabel() { }\n-    MetricLabel(const std::string& name_, const std::string& value_) :name(name_), value(value_) {\n-    }\n+#define DEFINE_METRIC(name, type, unit, desc, group, labels, core)      \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9d906ec5fadbcfea164828e86b8028a67e9b38c"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNjM1Njk2OnYy", "diffSide": "RIGHT", "path": "be/src/util/metrics.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwODoyMjowNlrOG9RDGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwODoyMjowNlrOG9RDGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg5NTY0MA==", "bodyText": "What's the purpose of MetricPrototype?\nUnder which circumstance, MetricPrototype can be used to split the Metric.", "url": "https://github.com/apache/incubator-doris/pull/4115#discussion_r466895640", "createdAt": "2020-08-07T08:22:06Z", "author": {"login": "chaoyli"}, "path": "be/src/util/metrics.h", "diffHunk": "@@ -193,230 +174,163 @@ class CoreLocalCounter : public Metric {\n     void increment(const T& delta) {\n         __sync_fetch_and_add(_value.access(), delta);\n     }\n+\n+    rj::Value to_json_value() const override {\n+        return rj::Value(value());\n+    }\n+\n protected:\n     CoreLocalValue<T> _value;\n };\n \n template<typename T>\n class AtomicCounter : public AtomicMetric<T> {\n public:\n-    AtomicCounter(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~AtomicCounter() { }\n+    AtomicCounter() {}\n+    virtual ~AtomicCounter() {}\n };\n \n template<typename T>\n class AtomicGauge : public AtomicMetric<T> {\n public:\n-    AtomicGauge(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~AtomicGauge() { }\n+    AtomicGauge() : AtomicMetric<T>() {}\n+    virtual ~AtomicGauge() {}\n };\n \n template<typename T>\n class LockCounter : public LockSimpleMetric<T> {\n public:\n-    LockCounter(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~LockCounter() { }\n+    LockCounter() : LockSimpleMetric<T>() {}\n+    virtual ~LockCounter() {}\n };\n \n // This can only used for trival type\n template<typename T>\n class LockGauge : public LockSimpleMetric<T> {\n public:\n-    LockGauge(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~LockGauge() { }\n+    LockGauge() : LockSimpleMetric<T>() {}\n+    virtual ~LockGauge() {}\n };\n \n-// one key-value pair used to\n-struct MetricLabel {\n+using Labels = std::unordered_map<std::string, std::string>;\n+struct MetricPrototype {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9d906ec5fadbcfea164828e86b8028a67e9b38c"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNjM1Nzk4OnYy", "diffSide": "RIGHT", "path": "be/src/util/metrics.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwODoyMjoyOVrOG9RDwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwOTo0NjoyMFrOG9Tn9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg5NTgxMA==", "bodyText": "MetricMap is better name or not?", "url": "https://github.com/apache/incubator-doris/pull/4115#discussion_r466895810", "createdAt": "2020-08-07T08:22:29Z", "author": {"login": "chaoyli"}, "path": "be/src/util/metrics.h", "diffHunk": "@@ -193,230 +174,163 @@ class CoreLocalCounter : public Metric {\n     void increment(const T& delta) {\n         __sync_fetch_and_add(_value.access(), delta);\n     }\n+\n+    rj::Value to_json_value() const override {\n+        return rj::Value(value());\n+    }\n+\n protected:\n     CoreLocalValue<T> _value;\n };\n \n template<typename T>\n class AtomicCounter : public AtomicMetric<T> {\n public:\n-    AtomicCounter(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~AtomicCounter() { }\n+    AtomicCounter() {}\n+    virtual ~AtomicCounter() {}\n };\n \n template<typename T>\n class AtomicGauge : public AtomicMetric<T> {\n public:\n-    AtomicGauge(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~AtomicGauge() { }\n+    AtomicGauge() : AtomicMetric<T>() {}\n+    virtual ~AtomicGauge() {}\n };\n \n template<typename T>\n class LockCounter : public LockSimpleMetric<T> {\n public:\n-    LockCounter(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~LockCounter() { }\n+    LockCounter() : LockSimpleMetric<T>() {}\n+    virtual ~LockCounter() {}\n };\n \n // This can only used for trival type\n template<typename T>\n class LockGauge : public LockSimpleMetric<T> {\n public:\n-    LockGauge(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~LockGauge() { }\n+    LockGauge() : LockSimpleMetric<T>() {}\n+    virtual ~LockGauge() {}\n };\n \n-// one key-value pair used to\n-struct MetricLabel {\n+using Labels = std::unordered_map<std::string, std::string>;\n+struct MetricPrototype {\n+public:\n+    MetricPrototype(MetricType type_,\n+                    MetricUnit unit_,\n+                    std::string name_,\n+                    std::string description_ = \"\",\n+                    std::string group_name_ = \"\",\n+                    Labels labels_ = Labels(),\n+                    bool is_core_metric_ = false)\n+        : is_core_metric(is_core_metric_),\n+          type(type_),\n+          unit(unit_),\n+          name(std::move(name_)),\n+          description(std::move(description_)),\n+          group_name(std::move(group_name_)),\n+          labels(std::move(labels_)) {}\n+\n+    std::string simple_name() const;\n+    std::string combine_name(const std::string& registry_name) const;\n+\n+    bool is_core_metric;\n+    MetricType type;\n+    MetricUnit unit;\n     std::string name;\n-    std::string value;\n+    std::string description;\n+    std::string group_name;\n+    Labels labels;\n+};\n \n-    MetricLabel() { }\n-    MetricLabel(const std::string& name_, const std::string& value_) :name(name_), value(value_) {\n-    }\n+#define DEFINE_METRIC(name, type, unit, desc, group, labels, core)      \\\n+    ::doris::MetricPrototype METRIC_##name(type, unit, #name, desc, group, labels, core)\n \n-    bool operator==(const MetricLabel& other) const {\n-        return name == other.name && value == other.value;\n-    }\n-    bool operator!=(const MetricLabel& other) const {\n-        return !(*this == other);\n-    }\n-    bool operator<(const MetricLabel& other) const {\n-        auto res = name.compare(other.name);\n-        if (res == 0) {\n-            return value < other.value;\n-        }\n-        return res < 0;\n-    }\n-    int compare(const MetricLabel& other) const {\n-        auto res = name.compare(other.name);\n-        if (res == 0) {\n-            return value.compare(other.value);\n-        }\n-        return res;\n-    }\n-    std::string to_string() const {\n-        return name + \"=\" + value;\n-    }\n-};\n+#define DEFINE_COUNTER_METRIC_2ARG(name, unit)                          \\\n+    DEFINE_METRIC(name, MetricType::COUNTER, unit, \"\", \"\", Labels(), false)\n \n-struct MetricLabels {\n-    static MetricLabels EmptyLabels;\n-    // used std::set to sort MetricLabel so that we can get compare two MetricLabels\n-    std::set<MetricLabel> labels;\n+#define DEFINE_COUNTER_METRIC_3ARG(name, unit, desc)                    \\\n+    DEFINE_METRIC(name, MetricType::COUNTER, unit, desc, \"\", Labels(), false)\n \n-    MetricLabels& add(const std::string& name, const std::string& value) {\n-        labels.emplace(name, value);\n-        return *this;\n-    }\n+#define DEFINE_COUNTER_METRIC_5ARG(name, unit, desc, group, labels)     \\\n+    DEFINE_METRIC(name, MetricType::COUNTER, unit, desc, #group, labels, false)\n \n-    bool operator==(const MetricLabels& other) const {\n-        if (labels.size() != other.labels.size()) {\n-            return false;\n-        }\n-        auto it = labels.begin();\n-        auto other_it = other.labels.begin();\n-        while (it != labels.end()) {\n-            if (*it != *other_it) {\n-                return false;\n-            }\n-            ++it;\n-            ++other_it;\n-        }\n-        return true;\n-    }\n-    bool operator<(const MetricLabels& other) const {\n-        auto it = labels.begin();\n-        auto other_it = other.labels.begin();\n-        while (it != labels.end() && other_it != other.labels.end()) {\n-            auto res = it->compare(*other_it);\n-            if (res < 0) {\n-                return true;\n-            } else if (res > 0) {\n-                return false;\n-            }\n-            ++it;\n-            ++other_it;\n-        }\n-        if (it == labels.end()) {\n-            if (other_it == other.labels.end()) {\n-                return false;\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-    bool empty() const {\n-        return labels.empty();\n+#define DEFINE_GAUGE_METRIC_2ARG(name, unit)                            \\\n+    DEFINE_METRIC(name, MetricType::GAUGE, unit, \"\", \"\", Labels(), false)\n+\n+#define DEFINE_CORE_GAUGE_METRIC_2ARG(name, unit)                       \\\n+    DEFINE_METRIC(name, MetricType::GAUGE, unit, \"\", \"\", Labels(), true)\n+\n+#define DEFINE_GAUGE_METRIC_3ARG(name, unit, desc)                      \\\n+    DEFINE_METRIC(name, MetricType::GAUGE, unit, desc, \"\", Labels(), false)\n+\n+#define METRIC_REGISTER(entity, metric)                                 \\\n+    entity->register_metric(&METRIC_##metric, &metric)\n+\n+#define METRIC_DEREGISTER(entity, metric)                               \\\n+    entity->deregister_metric(&METRIC_##metric)\n+\n+// For 'metrics' in MetricEntity.\n+struct MetricPrototypeHash {\n+    size_t operator()(const MetricPrototype* metric_prototype) const {\n+        return std::hash<std::string>()(metric_prototype->group_name.empty() ? metric_prototype->name : metric_prototype->group_name);\n     }\n+};\n \n-    std::string to_string() const {\n-        std::stringstream ss;\n-        int i = 0;\n-        for (auto& label : labels) {\n-            if (i++ > 0) {\n-                ss << \",\";\n-            }\n-            ss << label.to_string();\n-        }\n-        return ss.str();\n+struct MetricPrototypeEqualTo {\n+    bool operator()(const MetricPrototype* first, const MetricPrototype* second) const {\n+        return first->group_name == second->group_name && first->name == second->name;\n     }\n };\n \n-class MetricCollector;\n+using MetricByType = std::unordered_map<const MetricPrototype*, Metric*, MetricPrototypeHash, MetricPrototypeEqualTo>;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9d906ec5fadbcfea164828e86b8028a67e9b38c"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNzg0Nw==", "bodyText": "MetricMap would be better", "url": "https://github.com/apache/incubator-doris/pull/4115#discussion_r466937847", "createdAt": "2020-08-07T09:46:20Z", "author": {"login": "acelyc111"}, "path": "be/src/util/metrics.h", "diffHunk": "@@ -193,230 +174,163 @@ class CoreLocalCounter : public Metric {\n     void increment(const T& delta) {\n         __sync_fetch_and_add(_value.access(), delta);\n     }\n+\n+    rj::Value to_json_value() const override {\n+        return rj::Value(value());\n+    }\n+\n protected:\n     CoreLocalValue<T> _value;\n };\n \n template<typename T>\n class AtomicCounter : public AtomicMetric<T> {\n public:\n-    AtomicCounter(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~AtomicCounter() { }\n+    AtomicCounter() {}\n+    virtual ~AtomicCounter() {}\n };\n \n template<typename T>\n class AtomicGauge : public AtomicMetric<T> {\n public:\n-    AtomicGauge(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~AtomicGauge() { }\n+    AtomicGauge() : AtomicMetric<T>() {}\n+    virtual ~AtomicGauge() {}\n };\n \n template<typename T>\n class LockCounter : public LockSimpleMetric<T> {\n public:\n-    LockCounter(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~LockCounter() { }\n+    LockCounter() : LockSimpleMetric<T>() {}\n+    virtual ~LockCounter() {}\n };\n \n // This can only used for trival type\n template<typename T>\n class LockGauge : public LockSimpleMetric<T> {\n public:\n-    LockGauge(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~LockGauge() { }\n+    LockGauge() : LockSimpleMetric<T>() {}\n+    virtual ~LockGauge() {}\n };\n \n-// one key-value pair used to\n-struct MetricLabel {\n+using Labels = std::unordered_map<std::string, std::string>;\n+struct MetricPrototype {\n+public:\n+    MetricPrototype(MetricType type_,\n+                    MetricUnit unit_,\n+                    std::string name_,\n+                    std::string description_ = \"\",\n+                    std::string group_name_ = \"\",\n+                    Labels labels_ = Labels(),\n+                    bool is_core_metric_ = false)\n+        : is_core_metric(is_core_metric_),\n+          type(type_),\n+          unit(unit_),\n+          name(std::move(name_)),\n+          description(std::move(description_)),\n+          group_name(std::move(group_name_)),\n+          labels(std::move(labels_)) {}\n+\n+    std::string simple_name() const;\n+    std::string combine_name(const std::string& registry_name) const;\n+\n+    bool is_core_metric;\n+    MetricType type;\n+    MetricUnit unit;\n     std::string name;\n-    std::string value;\n+    std::string description;\n+    std::string group_name;\n+    Labels labels;\n+};\n \n-    MetricLabel() { }\n-    MetricLabel(const std::string& name_, const std::string& value_) :name(name_), value(value_) {\n-    }\n+#define DEFINE_METRIC(name, type, unit, desc, group, labels, core)      \\\n+    ::doris::MetricPrototype METRIC_##name(type, unit, #name, desc, group, labels, core)\n \n-    bool operator==(const MetricLabel& other) const {\n-        return name == other.name && value == other.value;\n-    }\n-    bool operator!=(const MetricLabel& other) const {\n-        return !(*this == other);\n-    }\n-    bool operator<(const MetricLabel& other) const {\n-        auto res = name.compare(other.name);\n-        if (res == 0) {\n-            return value < other.value;\n-        }\n-        return res < 0;\n-    }\n-    int compare(const MetricLabel& other) const {\n-        auto res = name.compare(other.name);\n-        if (res == 0) {\n-            return value.compare(other.value);\n-        }\n-        return res;\n-    }\n-    std::string to_string() const {\n-        return name + \"=\" + value;\n-    }\n-};\n+#define DEFINE_COUNTER_METRIC_2ARG(name, unit)                          \\\n+    DEFINE_METRIC(name, MetricType::COUNTER, unit, \"\", \"\", Labels(), false)\n \n-struct MetricLabels {\n-    static MetricLabels EmptyLabels;\n-    // used std::set to sort MetricLabel so that we can get compare two MetricLabels\n-    std::set<MetricLabel> labels;\n+#define DEFINE_COUNTER_METRIC_3ARG(name, unit, desc)                    \\\n+    DEFINE_METRIC(name, MetricType::COUNTER, unit, desc, \"\", Labels(), false)\n \n-    MetricLabels& add(const std::string& name, const std::string& value) {\n-        labels.emplace(name, value);\n-        return *this;\n-    }\n+#define DEFINE_COUNTER_METRIC_5ARG(name, unit, desc, group, labels)     \\\n+    DEFINE_METRIC(name, MetricType::COUNTER, unit, desc, #group, labels, false)\n \n-    bool operator==(const MetricLabels& other) const {\n-        if (labels.size() != other.labels.size()) {\n-            return false;\n-        }\n-        auto it = labels.begin();\n-        auto other_it = other.labels.begin();\n-        while (it != labels.end()) {\n-            if (*it != *other_it) {\n-                return false;\n-            }\n-            ++it;\n-            ++other_it;\n-        }\n-        return true;\n-    }\n-    bool operator<(const MetricLabels& other) const {\n-        auto it = labels.begin();\n-        auto other_it = other.labels.begin();\n-        while (it != labels.end() && other_it != other.labels.end()) {\n-            auto res = it->compare(*other_it);\n-            if (res < 0) {\n-                return true;\n-            } else if (res > 0) {\n-                return false;\n-            }\n-            ++it;\n-            ++other_it;\n-        }\n-        if (it == labels.end()) {\n-            if (other_it == other.labels.end()) {\n-                return false;\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-    bool empty() const {\n-        return labels.empty();\n+#define DEFINE_GAUGE_METRIC_2ARG(name, unit)                            \\\n+    DEFINE_METRIC(name, MetricType::GAUGE, unit, \"\", \"\", Labels(), false)\n+\n+#define DEFINE_CORE_GAUGE_METRIC_2ARG(name, unit)                       \\\n+    DEFINE_METRIC(name, MetricType::GAUGE, unit, \"\", \"\", Labels(), true)\n+\n+#define DEFINE_GAUGE_METRIC_3ARG(name, unit, desc)                      \\\n+    DEFINE_METRIC(name, MetricType::GAUGE, unit, desc, \"\", Labels(), false)\n+\n+#define METRIC_REGISTER(entity, metric)                                 \\\n+    entity->register_metric(&METRIC_##metric, &metric)\n+\n+#define METRIC_DEREGISTER(entity, metric)                               \\\n+    entity->deregister_metric(&METRIC_##metric)\n+\n+// For 'metrics' in MetricEntity.\n+struct MetricPrototypeHash {\n+    size_t operator()(const MetricPrototype* metric_prototype) const {\n+        return std::hash<std::string>()(metric_prototype->group_name.empty() ? metric_prototype->name : metric_prototype->group_name);\n     }\n+};\n \n-    std::string to_string() const {\n-        std::stringstream ss;\n-        int i = 0;\n-        for (auto& label : labels) {\n-            if (i++ > 0) {\n-                ss << \",\";\n-            }\n-            ss << label.to_string();\n-        }\n-        return ss.str();\n+struct MetricPrototypeEqualTo {\n+    bool operator()(const MetricPrototype* first, const MetricPrototype* second) const {\n+        return first->group_name == second->group_name && first->name == second->name;\n     }\n };\n \n-class MetricCollector;\n+using MetricByType = std::unordered_map<const MetricPrototype*, Metric*, MetricPrototypeHash, MetricPrototypeEqualTo>;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg5NTgxMA=="}, "originalCommit": {"oid": "b9d906ec5fadbcfea164828e86b8028a67e9b38c"}, "originalPosition": 354}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1206, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}