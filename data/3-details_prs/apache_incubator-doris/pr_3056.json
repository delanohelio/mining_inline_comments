{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1MzYzNTEw", "number": 3056, "title": "implement except node", "bodyText": "#2845\nimplement except node,\nsupport  statement like\nselect a from t1 except select b from t2", "createdAt": "2020-03-09T03:10:41Z", "url": "https://github.com/apache/incubator-doris/pull/3056", "merged": true, "mergeCommit": {"oid": "0959abc1dc347c7401c4875aab8b8cfc777d4738"}, "closed": true, "closedAt": "2020-03-17T02:54:41Z", "author": {"login": "yangzhg"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcL1L1wgBqjMxMDkwMzYwMzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcOZpqGgFqTM3NTcwNjIyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "def5aeec712c0231488b9f7dd3ac6db37b9f4ab3", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/def5aeec712c0231488b9f7dd3ac6db37b9f4ab3", "committedDate": "2020-03-09T03:08:56Z", "message": "implement except node"}, "afterCommit": {"oid": "7907e605127c6c4972e0db066055e6e4a4f722f3", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/7907e605127c6c4972e0db066055e6e4a4f722f3", "committedDate": "2020-03-09T03:16:57Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7907e605127c6c4972e0db066055e6e4a4f722f3", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/7907e605127c6c4972e0db066055e6e4a4f722f3", "committedDate": "2020-03-09T03:16:57Z", "message": "implement except node"}, "afterCommit": {"oid": "f8f32a4d3e4dde0daef959f20eecd66fb309804a", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/f8f32a4d3e4dde0daef959f20eecd66fb309804a", "committedDate": "2020-03-10T11:41:50Z", "message": "implement except node"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxOTY0NzUz", "url": "https://github.com/apache/incubator-doris/pull/3056#pullrequestreview-371964753", "createdAt": "2020-03-10T13:47:14Z", "commit": {"oid": "f8f32a4d3e4dde0daef959f20eecd66fb309804a"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzo0NzoxNFrOF0PehA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDowMjo1N1rOF0QKIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMyMzg0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390323844", "createdAt": "2020-03-10T13:47:14Z", "author": {"login": "morningman"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,158 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f32a4d3e4dde0daef959f20eecd66fb309804a"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMzMjU0OA==", "bodyText": "Should it be\n_hash_tbl_iterator == _hash_tbl->end()", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390332548", "createdAt": "2020-03-10T13:59:27Z", "author": {"login": "morningman"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,158 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f32a4d3e4dde0daef959f20eecd66fb309804a"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMzNTAwOQ==", "bodyText": "What this for? Could you add comment to explain this rewrite?", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390335009", "createdAt": "2020-03-10T14:02:57Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/analysis/SetOperationStmt.java", "diffHunk": "@@ -649,6 +648,13 @@ public void analyze(Analyzer parent) throws AnalysisException, UserException {\n             if (isAnalyzed()) {\n                 return;\n             }\n+            if (queryStmt instanceof SelectStmt && ((SelectStmt) queryStmt).fromClause_.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f32a4d3e4dde0daef959f20eecd66fb309804a"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f8f32a4d3e4dde0daef959f20eecd66fb309804a", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/f8f32a4d3e4dde0daef959f20eecd66fb309804a", "committedDate": "2020-03-10T11:41:50Z", "message": "implement except node"}, "afterCommit": {"oid": "5abb4947cf850faa8b653866d86e7901fe07781b", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/5abb4947cf850faa8b653866d86e7901fe07781b", "committedDate": "2020-03-11T01:52:29Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5abb4947cf850faa8b653866d86e7901fe07781b", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/5abb4947cf850faa8b653866d86e7901fe07781b", "committedDate": "2020-03-11T01:52:29Z", "message": "implement except node"}, "afterCommit": {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/cbd649b19d05a2870dc4d3f39d1243061cd764a6", "committedDate": "2020-03-11T02:15:33Z", "message": "implement except node"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNDU3ODUw", "url": "https://github.com/apache/incubator-doris/pull/3056#pullrequestreview-372457850", "createdAt": "2020-03-11T03:39:04Z", "commit": {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzozOTowNFrOF0oQwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzozOTowNFrOF0oQwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyOTkyMQ==", "bodyText": "why do you use  'if (!_hash_tbl_iterator.matched())'?\nmay be you should use ' if (_hash_tbl_iterator.matched())'\nmatched means exceptNode", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390729921", "createdAt": "2020-03-11T03:39:04Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,157 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        if (i != _children.size() - 1) {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6"}, "originalPosition": 155}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNDU5NjQz", "url": "https://github.com/apache/incubator-doris/pull/3056#pullrequestreview-372459643", "createdAt": "2020-03-11T03:46:27Z", "commit": {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo0NjoyN1rOF0oW0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo0NjoyN1rOF0oW0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMTQ3Mw==", "bodyText": "How about if the hash value of hashtable is - 1\uff1f", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390731473", "createdAt": "2020-03-11T03:46:27Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,157 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        if (i != _children.size() - 1) {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    while (_hash_tbl_iterator.has_next()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6"}, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNDYwMjM5", "url": "https://github.com/apache/incubator-doris/pull/3056#pullrequestreview-372460239", "createdAt": "2020-03-11T03:48:51Z", "commit": {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo0ODo1MlrOF0oY8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo0ODo1MlrOF0oY8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMjAxNg==", "bodyText": "If the two hash values are equal, it does not mean that the two values are equal. You need to compare the original values.\nThere may be a problem with the else's logic", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390732016", "createdAt": "2020-03-11T03:48:52Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,157 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        if (i != _children.size() - 1) {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+            previous_hash = _hash_tbl_iterator.get_hash();\n+            if (!_hash_tbl_iterator.matched()) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6"}, "originalPosition": 192}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/cbd649b19d05a2870dc4d3f39d1243061cd764a6", "committedDate": "2020-03-11T02:15:33Z", "message": "implement except node"}, "afterCommit": {"oid": "727b5048355f0092fed2eb8a54efd0e547b90bd3", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/727b5048355f0092fed2eb8a54efd0e547b90bd3", "committedDate": "2020-03-11T08:49:34Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "727b5048355f0092fed2eb8a54efd0e547b90bd3", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/727b5048355f0092fed2eb8a54efd0e547b90bd3", "committedDate": "2020-03-11T08:49:34Z", "message": "implement except node"}, "afterCommit": {"oid": "9ffa4f6ecda7a71667728d2d427b58af18d43f0b", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/9ffa4f6ecda7a71667728d2d427b58af18d43f0b", "committedDate": "2020-03-11T09:41:05Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ffa4f6ecda7a71667728d2d427b58af18d43f0b", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/9ffa4f6ecda7a71667728d2d427b58af18d43f0b", "committedDate": "2020-03-11T09:41:05Z", "message": "implement except node"}, "afterCommit": {"oid": "8382d2c4f6b04213f474753222e29f4d44fa7aa4", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/8382d2c4f6b04213f474753222e29f4d44fa7aa4", "committedDate": "2020-03-11T09:42:59Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8382d2c4f6b04213f474753222e29f4d44fa7aa4", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/8382d2c4f6b04213f474753222e29f4d44fa7aa4", "committedDate": "2020-03-11T09:42:59Z", "message": "implement except node"}, "afterCommit": {"oid": "92ded2b1b77a542900d8af4b7498431ad48d778d", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/92ded2b1b77a542900d8af4b7498431ad48d778d", "committedDate": "2020-03-12T10:19:10Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92ded2b1b77a542900d8af4b7498431ad48d778d", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/92ded2b1b77a542900d8af4b7498431ad48d778d", "committedDate": "2020-03-12T10:19:10Z", "message": "implement except node"}, "afterCommit": {"oid": "25a0421f0d5724a069e6d02cd368c01dea22f9a3", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/25a0421f0d5724a069e6d02cd368c01dea22f9a3", "committedDate": "2020-03-12T10:21:57Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25a0421f0d5724a069e6d02cd368c01dea22f9a3", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/25a0421f0d5724a069e6d02cd368c01dea22f9a3", "committedDate": "2020-03-12T10:21:57Z", "message": "implement except node"}, "afterCommit": {"oid": "3c389d87d741591e0be2195d86ee5d108c6bc6d3", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/3c389d87d741591e0be2195d86ee5d108c6bc6d3", "committedDate": "2020-03-12T12:38:11Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3c389d87d741591e0be2195d86ee5d108c6bc6d3", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/3c389d87d741591e0be2195d86ee5d108c6bc6d3", "committedDate": "2020-03-12T12:38:11Z", "message": "implement except node"}, "afterCommit": {"oid": "0b9b7b13d3b513540873b661af36bb4be3ba22ac", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/0b9b7b13d3b513540873b661af36bb4be3ba22ac", "committedDate": "2020-03-12T12:47:10Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0b9b7b13d3b513540873b661af36bb4be3ba22ac", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/0b9b7b13d3b513540873b661af36bb4be3ba22ac", "committedDate": "2020-03-12T12:47:10Z", "message": "implement except node"}, "afterCommit": {"oid": "0af0965cd0c69396220547174f0f0af29e502d09", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/0af0965cd0c69396220547174f0f0af29e502d09", "committedDate": "2020-03-12T12:48:58Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0af0965cd0c69396220547174f0f0af29e502d09", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/0af0965cd0c69396220547174f0f0af29e502d09", "committedDate": "2020-03-12T12:48:58Z", "message": "implement except node"}, "afterCommit": {"oid": "a29557713b40217ed8b9382836ac478e23a0495c", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/a29557713b40217ed8b9382836ac478e23a0495c", "committedDate": "2020-03-12T12:53:49Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a29557713b40217ed8b9382836ac478e23a0495c", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/a29557713b40217ed8b9382836ac478e23a0495c", "committedDate": "2020-03-12T12:53:49Z", "message": "implement except node"}, "afterCommit": {"oid": "114592c40f47c1444ff2b57b301728d73e401e0c", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/114592c40f47c1444ff2b57b301728d73e401e0c", "committedDate": "2020-03-12T13:09:35Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "114592c40f47c1444ff2b57b301728d73e401e0c", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/114592c40f47c1444ff2b57b301728d73e401e0c", "committedDate": "2020-03-12T13:09:35Z", "message": "implement except node"}, "afterCommit": {"oid": "0c173175e897b39c0b49086986c40e814bb1a8dc", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/0c173175e897b39c0b49086986c40e814bb1a8dc", "committedDate": "2020-03-12T13:11:05Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0c173175e897b39c0b49086986c40e814bb1a8dc", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/0c173175e897b39c0b49086986c40e814bb1a8dc", "committedDate": "2020-03-12T13:11:05Z", "message": "implement except node"}, "afterCommit": {"oid": "fa077db918bc11ac23ae339790ff481d94dc1417", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/fa077db918bc11ac23ae339790ff481d94dc1417", "committedDate": "2020-03-12T13:18:01Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fa077db918bc11ac23ae339790ff481d94dc1417", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/fa077db918bc11ac23ae339790ff481d94dc1417", "committedDate": "2020-03-12T13:18:01Z", "message": "implement except node"}, "afterCommit": {"oid": "1887fba5e89af8f1b3ca691db0ecdfcfbab935e6", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/1887fba5e89af8f1b3ca691db0ecdfcfbab935e6", "committedDate": "2020-03-12T13:21:00Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1887fba5e89af8f1b3ca691db0ecdfcfbab935e6", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/1887fba5e89af8f1b3ca691db0ecdfcfbab935e6", "committedDate": "2020-03-12T13:21:00Z", "message": "implement except node"}, "afterCommit": {"oid": "784e6c40d167844dd7e589d48937456ffa450281", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/784e6c40d167844dd7e589d48937456ffa450281", "committedDate": "2020-03-13T01:55:46Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "784e6c40d167844dd7e589d48937456ffa450281", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/784e6c40d167844dd7e589d48937456ffa450281", "committedDate": "2020-03-13T01:55:46Z", "message": "implement except node"}, "afterCommit": {"oid": "b4a1ef5ce2e568a56596c8df503f0d7b5ce0c4ec", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/b4a1ef5ce2e568a56596c8df503f0d7b5ce0c4ec", "committedDate": "2020-03-13T01:57:41Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b4a1ef5ce2e568a56596c8df503f0d7b5ce0c4ec", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/b4a1ef5ce2e568a56596c8df503f0d7b5ce0c4ec", "committedDate": "2020-03-13T01:57:41Z", "message": "implement except node"}, "afterCommit": {"oid": "cd5988a0258ef181fc737adc103f1c867236e63a", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/cd5988a0258ef181fc737adc103f1c867236e63a", "committedDate": "2020-03-13T01:58:53Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cd5988a0258ef181fc737adc103f1c867236e63a", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/cd5988a0258ef181fc737adc103f1c867236e63a", "committedDate": "2020-03-13T01:58:53Z", "message": "implement except node"}, "afterCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225", "committedDate": "2020-03-13T03:17:29Z", "message": "implement except node"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MDgxMjgx", "url": "https://github.com/apache/incubator-doris/pull/3056#pullrequestreview-374081281", "createdAt": "2020-03-13T06:55:11Z", "commit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MjM0NTU2", "url": "https://github.com/apache/incubator-doris/pull/3056#pullrequestreview-374234556", "createdAt": "2020-03-13T11:40:57Z", "commit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTo0MDo1N1rOF2Apnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTo0MDo1N1rOF2Apnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE3ODA3OQ==", "bodyText": "Remove this line.", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392178079", "createdAt": "2020-03-13T11:40:57Z", "author": {"login": "kangkaisen"}, "path": "be/src/exec/exec_node.cpp", "diffHunk": "@@ -446,9 +446,9 @@ Status ExecNode::create_node(RuntimeState* state, ObjectPool* pool, const TPlanN\n         *node = pool->add(new IntersectNode(pool, tnode, descs));\n         return Status::OK();\n \n-    // case TPlanNodeType::EXCEPT_NODE:\n-    //     *node = pool->add(new ExceptNode(pool, tnode, descs));\n-    //     return Status::OK();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MjQzMTYy", "url": "https://github.com/apache/incubator-doris/pull/3056#pullrequestreview-374243162", "createdAt": "2020-03-13T11:56:42Z", "commit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTo1Njo0MlrOF2BDOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTo1Njo0MlrOF2BDOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NDYzMw==", "bodyText": "This if statement could remove ?", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392184633", "createdAt": "2020-03-13T11:56:42Z", "author": {"login": "kangkaisen"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +41,190 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_timer = ADD_TIMER(runtime_profile(), \"BuildTime\");\n+    _probe_timer = ADD_TIMER(runtime_profile(), \"ProbeTime\");\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_build_tuple_size, true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table, use _child_expr_lists[0] as probe is used for remove duplicted\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[0], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        SCOPED_TIMER(_build_timer);\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        // build hash table and remvoe duplicate items\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert_unique(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // rebuid hash table, for first time will rebuild with the no duplicated _hash_tbl,\n+        if (i > 1) {\n+            SCOPED_TIMER(_build_timer);\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        ScopedTimer<MonotonicStopWatch> probe_timer(_probe_timer);\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    TupleRow* previous_row = nullptr;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (!_hash_tbl_iterator.matched()) {\n+            if (previous_hash != _hash_tbl_iterator.get_hash() ||\n+                !equals(previous_row, _hash_tbl_iterator.get_row())) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+                ++_num_rows_returned;\n+            }\n+        }\n+        previous_hash = _hash_tbl_iterator.get_hash();\n+        previous_row = _hash_tbl_iterator.get_row();\n+        _hash_tbl_iterator.next<false>();\n+\n+        *eos = !_hash_tbl_iterator.has_next() || reached_limit();\n+        if (out_batch->is_full() || out_batch->at_resource_limit() || *eos) {\n+            return Status::OK();\n+        }\n+    }\n+    return Status::OK();\n+}\n+\n+bool ExceptNode::equals(TupleRow* row, TupleRow* other) {\n+    if (row == nullptr && other == nullptr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "originalPosition": 215}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MjQ0Nzg3", "url": "https://github.com/apache/incubator-doris/pull/3056#pullrequestreview-374244787", "createdAt": "2020-03-13T11:59:48Z", "commit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTo1OTo0OFrOF2BIGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTo1OTo0OFrOF2BIGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NTg4MA==", "bodyText": "why continue?", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392185880", "createdAt": "2020-03-13T11:59:48Z", "author": {"login": "kangkaisen"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +41,190 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_timer = ADD_TIMER(runtime_profile(), \"BuildTime\");\n+    _probe_timer = ADD_TIMER(runtime_profile(), \"ProbeTime\");\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_build_tuple_size, true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table, use _child_expr_lists[0] as probe is used for remove duplicted\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[0], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        SCOPED_TIMER(_build_timer);\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        // build hash table and remvoe duplicate items\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert_unique(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // rebuid hash table, for first time will rebuild with the no duplicated _hash_tbl,\n+        if (i > 1) {\n+            SCOPED_TIMER(_build_timer);\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        ScopedTimer<MonotonicStopWatch> probe_timer(_probe_timer);\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    TupleRow* previous_row = nullptr;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (!_hash_tbl_iterator.matched()) {\n+            if (previous_hash != _hash_tbl_iterator.get_hash() ||\n+                !equals(previous_row, _hash_tbl_iterator.get_row())) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+                ++_num_rows_returned;\n+            }\n+        }\n+        previous_hash = _hash_tbl_iterator.get_hash();\n+        previous_row = _hash_tbl_iterator.get_row();\n+        _hash_tbl_iterator.next<false>();\n+\n+        *eos = !_hash_tbl_iterator.has_next() || reached_limit();\n+        if (out_batch->is_full() || out_batch->at_resource_limit() || *eos) {\n+            return Status::OK();\n+        }\n+    }\n+    return Status::OK();\n+}\n+\n+bool ExceptNode::equals(TupleRow* row, TupleRow* other) {\n+    if (row == nullptr && other == nullptr) {\n+        return false;\n+    }\n+    if (row == nullptr || other == nullptr) {\n+        return false;\n+    }\n+    for (int i = 0; i < _child_expr_lists[0].size(); ++i) {\n+        void* val_row = _child_expr_lists[0][i]->get_value(row);\n+        void* val_other = _child_expr_lists[0][i]->get_value(other);\n+        if (val_row == nullptr && val_other == nullptr) {\n+            continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "originalPosition": 225}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225", "committedDate": "2020-03-13T03:17:29Z", "message": "implement except node"}, "afterCommit": {"oid": "10bd38aef60ad500dbaf4234cbea8f031be221fe", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/10bd38aef60ad500dbaf4234cbea8f031be221fe", "committedDate": "2020-03-17T01:48:56Z", "message": "implement except node"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c3e401b9e331f5289cca318fcd7833809160c98", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/9c3e401b9e331f5289cca318fcd7833809160c98", "committedDate": "2020-03-17T02:40:31Z", "message": "implement except node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "10bd38aef60ad500dbaf4234cbea8f031be221fe", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/10bd38aef60ad500dbaf4234cbea8f031be221fe", "committedDate": "2020-03-17T01:48:56Z", "message": "implement except node"}, "afterCommit": {"oid": "9c3e401b9e331f5289cca318fcd7833809160c98", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/9c3e401b9e331f5289cca318fcd7833809160c98", "committedDate": "2020-03-17T02:40:31Z", "message": "implement except node"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NzA2MjI3", "url": "https://github.com/apache/incubator-doris/pull/3056#pullrequestreview-375706227", "createdAt": "2020-03-17T02:54:09Z", "commit": {"oid": "9c3e401b9e331f5289cca318fcd7833809160c98"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3535, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}