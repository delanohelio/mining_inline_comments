{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNzkyODg3", "number": 3294, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwODoyMzoxNFrODwrvPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwODoyMzoxNFrODwrvPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzc0ODQ2OnYy", "diffSide": "RIGHT", "path": "be/src/olap/tablet_manager.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwODoyMzoxNFrOGD0cZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNTo0MToxNlrOGEOEnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY1ODE1MA==", "bodyText": "You can put tablet->delete_expired_inc_rowsets() between the ReadLock and WriteLock.\nThis is bottleneck which consumes much resource.", "url": "https://github.com/apache/incubator-doris/pull/3294#discussion_r406658150", "createdAt": "2020-04-10T08:23:14Z", "author": {"login": "chaoyli"}, "path": "be/src/olap/tablet_manager.cpp", "diffHunk": "@@ -960,28 +960,36 @@ OLAPStatus TabletManager::start_trash_sweep() {\n     {\n         std::vector<int64_t> tablets_to_clean;\n         for (int32 i = 0; i < _tablet_map_lock_shard_size; i++) {\n-            WriteLock rlock(&_tablet_map_lock_array[i]);\n             tablet_map_t& tablet_map = _tablet_map_array[i];\n-            for (auto& item : tablet_map) {\n-                // try to clean empty item\n-                if (item.second.table_arr.empty()) {\n-                    // try to get schema change lock if could get schema change lock, then nobody\n-                    // own the lock could remove the item\n-                    // it will core if schema change thread may hold the lock and this thread will deconstruct lock\n-                    if (item.second.schema_change_lock.trylock() == OLAP_SUCCESS) {\n-                        item.second.schema_change_lock.unlock();\n+            {\n+                ReadLock r_lock(&_tablet_map_lock_array[i]);\n+                for (auto& item : tablet_map) {\n+                    // try to clean empty item\n+                    if (item.second.table_arr.empty()) {\n                         tablets_to_clean.push_back(item.first);\n                     }\n-                }\n-                for (TabletSharedPtr tablet : item.second.table_arr) {\n-                    tablet->delete_expired_inc_rowsets();\n+                    for (TabletSharedPtr tablet : item.second.table_arr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "094ac980c7bdfc50eb3e868525edd23fd994cdf0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc2NTU3NQ==", "bodyText": "Can you give the example code?\nIs it  safe to iterate a map without read lock?", "url": "https://github.com/apache/incubator-doris/pull/3294#discussion_r406765575", "createdAt": "2020-04-10T13:49:26Z", "author": {"login": "liutang123"}, "path": "be/src/olap/tablet_manager.cpp", "diffHunk": "@@ -960,28 +960,36 @@ OLAPStatus TabletManager::start_trash_sweep() {\n     {\n         std::vector<int64_t> tablets_to_clean;\n         for (int32 i = 0; i < _tablet_map_lock_shard_size; i++) {\n-            WriteLock rlock(&_tablet_map_lock_array[i]);\n             tablet_map_t& tablet_map = _tablet_map_array[i];\n-            for (auto& item : tablet_map) {\n-                // try to clean empty item\n-                if (item.second.table_arr.empty()) {\n-                    // try to get schema change lock if could get schema change lock, then nobody\n-                    // own the lock could remove the item\n-                    // it will core if schema change thread may hold the lock and this thread will deconstruct lock\n-                    if (item.second.schema_change_lock.trylock() == OLAP_SUCCESS) {\n-                        item.second.schema_change_lock.unlock();\n+            {\n+                ReadLock r_lock(&_tablet_map_lock_array[i]);\n+                for (auto& item : tablet_map) {\n+                    // try to clean empty item\n+                    if (item.second.table_arr.empty()) {\n                         tablets_to_clean.push_back(item.first);\n                     }\n-                }\n-                for (TabletSharedPtr tablet : item.second.table_arr) {\n-                    tablet->delete_expired_inc_rowsets();\n+                    for (TabletSharedPtr tablet : item.second.table_arr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY1ODE1MA=="}, "originalCommit": {"oid": "094ac980c7bdfc50eb3e868525edd23fd994cdf0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2MTY3MA==", "bodyText": "Currently, there should be only one tablet in tablet_arr.\nOnly in the early Doris version, tablet_arr will appear multiple tablets.\nAnd in tablet->delete_expired_inc_rowsets();, it will hold the meta lock, So no need to be protected by _tablet_map.\nSo you can just by doing:\n\ndo the tablets_to_clean.push_back(item.first); in ReadLock\nUnlock the ReadLock, and iterate the tablets_to_clean to do the tablet->delete_expired_inc_rowsets();\nDo the following tablet_map.erase(tablet_id_to_clean); in WriteLock", "url": "https://github.com/apache/incubator-doris/pull/3294#discussion_r407061670", "createdAt": "2020-04-11T13:04:01Z", "author": {"login": "morningman"}, "path": "be/src/olap/tablet_manager.cpp", "diffHunk": "@@ -960,28 +960,36 @@ OLAPStatus TabletManager::start_trash_sweep() {\n     {\n         std::vector<int64_t> tablets_to_clean;\n         for (int32 i = 0; i < _tablet_map_lock_shard_size; i++) {\n-            WriteLock rlock(&_tablet_map_lock_array[i]);\n             tablet_map_t& tablet_map = _tablet_map_array[i];\n-            for (auto& item : tablet_map) {\n-                // try to clean empty item\n-                if (item.second.table_arr.empty()) {\n-                    // try to get schema change lock if could get schema change lock, then nobody\n-                    // own the lock could remove the item\n-                    // it will core if schema change thread may hold the lock and this thread will deconstruct lock\n-                    if (item.second.schema_change_lock.trylock() == OLAP_SUCCESS) {\n-                        item.second.schema_change_lock.unlock();\n+            {\n+                ReadLock r_lock(&_tablet_map_lock_array[i]);\n+                for (auto& item : tablet_map) {\n+                    // try to clean empty item\n+                    if (item.second.table_arr.empty()) {\n                         tablets_to_clean.push_back(item.first);\n                     }\n-                }\n-                for (TabletSharedPtr tablet : item.second.table_arr) {\n-                    tablet->delete_expired_inc_rowsets();\n+                    for (TabletSharedPtr tablet : item.second.table_arr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY1ODE1MA=="}, "originalCommit": {"oid": "094ac980c7bdfc50eb3e868525edd23fd994cdf0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3ODA0Nw==", "bodyText": "Unlock the ReadLock, and iterate the tablets_to_clean to do the tablet->delete_expired_inc_rowsets();\nWe should invoke delete_expired_inc_rowsets in all tablets but not only in tablets_to_clean. Isn't it?", "url": "https://github.com/apache/incubator-doris/pull/3294#discussion_r407078047", "createdAt": "2020-04-11T15:41:16Z", "author": {"login": "liutang123"}, "path": "be/src/olap/tablet_manager.cpp", "diffHunk": "@@ -960,28 +960,36 @@ OLAPStatus TabletManager::start_trash_sweep() {\n     {\n         std::vector<int64_t> tablets_to_clean;\n         for (int32 i = 0; i < _tablet_map_lock_shard_size; i++) {\n-            WriteLock rlock(&_tablet_map_lock_array[i]);\n             tablet_map_t& tablet_map = _tablet_map_array[i];\n-            for (auto& item : tablet_map) {\n-                // try to clean empty item\n-                if (item.second.table_arr.empty()) {\n-                    // try to get schema change lock if could get schema change lock, then nobody\n-                    // own the lock could remove the item\n-                    // it will core if schema change thread may hold the lock and this thread will deconstruct lock\n-                    if (item.second.schema_change_lock.trylock() == OLAP_SUCCESS) {\n-                        item.second.schema_change_lock.unlock();\n+            {\n+                ReadLock r_lock(&_tablet_map_lock_array[i]);\n+                for (auto& item : tablet_map) {\n+                    // try to clean empty item\n+                    if (item.second.table_arr.empty()) {\n                         tablets_to_clean.push_back(item.first);\n                     }\n-                }\n-                for (TabletSharedPtr tablet : item.second.table_arr) {\n-                    tablet->delete_expired_inc_rowsets();\n+                    for (TabletSharedPtr tablet : item.second.table_arr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY1ODE1MA=="}, "originalCommit": {"oid": "094ac980c7bdfc50eb3e868525edd23fd994cdf0"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1897, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}