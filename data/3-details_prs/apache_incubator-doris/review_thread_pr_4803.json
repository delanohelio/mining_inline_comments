{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwNTQxMDA4", "number": 4803, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxNDo0MzowNFrOE73Ojw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxNDo0NzozMVrOE73QAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjA2Mjg3OnYy", "diffSide": "RIGHT", "path": "gensrc/proto/olap_common.proto", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxNDo0MzowNFrOH3u_lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxNDo0MzowNFrOH3u_lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwMzY2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                required uint64  count = 2;\n          \n          \n            \n                required uint64 count = 2;", "url": "https://github.com/apache/incubator-doris/pull/4803#discussion_r528203668", "createdAt": "2020-11-21T14:43:04Z", "author": {"login": "morningman"}, "path": "gensrc/proto/olap_common.proto", "diffHunk": "@@ -48,3 +48,14 @@ enum CompressKind {\n     COMPRESS_LZ4 = 2;\n }\n \n+message PCounter {\n+    required string item = 1;\n+    required uint64  count = 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03fbc56c62acade492594c47a2a97b876c349b39"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjA2NjU5OnYy", "diffSide": "RIGHT", "path": "be/src/util/topn_counter.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxNDo0NzozMVrOH3vBOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzoxODozMlrOIF8Ueg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNDA5MQ==", "bodyText": "How about using JSON format output?", "url": "https://github.com/apache/incubator-doris/pull/4803#discussion_r528204091", "createdAt": "2020-11-21T14:47:31Z", "author": {"login": "morningman"}, "path": "be/src/util/topn_counter.cpp", "diffHunk": "@@ -0,0 +1,138 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include \"gen_cpp/olap_common.pb.h\"\n+#include \"topn_counter.h\"\n+#include \"slice.h\"\n+\n+namespace doris {\n+\n+void TopNCounter::add_item(const std::string& item, uint64_t incrementCount) {\n+    auto iter = _counter_map->find(item);\n+    if (iter != _counter_map->end()) {\n+        iter->second.add_count(incrementCount);\n+    } else {\n+        _counter_map->insert(std::make_pair(item, Counter(item, incrementCount)));\n+    }\n+    _ordered = false;\n+}\n+\n+void TopNCounter::serialize(std::string* buffer) {\n+    sort_retain(_capacity);\n+    PTopNCounter topn_counter;\n+    topn_counter.set_top_num(_top_num);\n+    topn_counter.set_space_expand_rate(_space_expand_rate);\n+    for(std::vector<Counter>::const_iterator it = _counter_vec->begin(); it != _counter_vec->end(); ++it)\n+    {\n+        PCounter* counter = topn_counter.add_counter();\n+        counter->set_item(it->get_item());\n+        counter->set_count(it->get_count());\n+    }\n+    topn_counter.SerializeToString(buffer);\n+}\n+\n+bool TopNCounter::deserialize(const doris::Slice &src) {\n+    PTopNCounter topn_counter;\n+    if (!topn_counter.ParseFromArray(src.data, src.size)) {\n+        LOG(WARNING) << \"topn counter deserialize failed\";\n+        return false;\n+    }\n+\n+    _space_expand_rate = topn_counter.space_expand_rate();\n+    set_top_num(topn_counter.top_num());\n+    for (int i = 0; i < topn_counter.counter_size(); ++i) {\n+        const PCounter& counter = topn_counter.counter(i);\n+        _counter_map->insert(std::make_pair(counter.item(), Counter(counter.item(), counter.count())));\n+        _counter_vec->emplace_back(counter.item(), counter.count());\n+    }\n+    _ordered = true;\n+    return true;\n+}\n+\n+void TopNCounter::sort_retain(uint32_t capacity) {\n+    _counter_vec->clear();\n+    sort_retain(capacity, _counter_vec);\n+    _ordered = true;\n+}\n+\n+void TopNCounter::sort_retain(uint32_t capacity, std::vector<Counter>* sort_vec) {\n+    for(std::unordered_map<std::string, Counter>::const_iterator it = _counter_map->begin(); it != _counter_map->end(); ++it) {\n+        sort_vec->emplace_back(it->second.get_item(), it->second.get_count());\n+    }\n+\n+    std::sort(sort_vec->begin(), sort_vec->end(), TopNComparator());\n+    if (sort_vec->size() > capacity) {\n+        for (uint32_t i = 0, n = sort_vec->size() - capacity; i < n; ++i) {\n+            auto &counter = sort_vec->back();\n+            _counter_map->erase(counter.get_item());\n+            sort_vec->pop_back();\n+        }\n+    }\n+}\n+\n+// Based on the  parallel version of the Space Saving algorithm as described in:\n+// A parallel space saving algorithm for frequent items and the Hurwitz zeta distribution by Massimo Cafaro, et al.\n+void TopNCounter::merge(doris::TopNCounter &&other) {\n+    if (other._counter_map->size() == 0) {\n+        return;\n+    }\n+\n+    _space_expand_rate = other._space_expand_rate;\n+    set_top_num(other._top_num);\n+    bool this_full = _counter_map->size() >= _capacity;\n+    bool another_full = other._counter_map->size() >= other._capacity;\n+\n+    uint64_t m1 = this_full ? _counter_vec->back().get_count() : 0;\n+    uint64_t m2 = another_full ? other._counter_vec->back().get_count() : 0;\n+   \n+    if (another_full == true) {\n+        for (auto &entry : *(this->_counter_map)) {\n+            entry.second.add_count(m2);\n+        }\n+    }\n+\n+    for (auto &other_entry : *(other._counter_map)) {\n+        auto itr = this->_counter_map->find(other_entry.first);\n+        if (itr != _counter_map->end()) {\n+            itr->second.add_count(other_entry.second.get_count() - m2);\n+        } else {\n+            this->_counter_map->insert(std::make_pair(other_entry.first,\n+                    Counter(other_entry.first,other_entry.second.get_count() + m1)));\n+        }\n+    }\n+    _ordered = false;\n+    sort_retain(_capacity);\n+}\n+\n+void TopNCounter::finalize(std::string& finalize_str) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03fbc56c62acade492594c47a2a97b876c349b39"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEwMjA3NA==", "bodyText": "ok,done", "url": "https://github.com/apache/incubator-doris/pull/4803#discussion_r543102074", "createdAt": "2020-12-15T07:18:32Z", "author": {"login": "Youngwb"}, "path": "be/src/util/topn_counter.cpp", "diffHunk": "@@ -0,0 +1,138 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include \"gen_cpp/olap_common.pb.h\"\n+#include \"topn_counter.h\"\n+#include \"slice.h\"\n+\n+namespace doris {\n+\n+void TopNCounter::add_item(const std::string& item, uint64_t incrementCount) {\n+    auto iter = _counter_map->find(item);\n+    if (iter != _counter_map->end()) {\n+        iter->second.add_count(incrementCount);\n+    } else {\n+        _counter_map->insert(std::make_pair(item, Counter(item, incrementCount)));\n+    }\n+    _ordered = false;\n+}\n+\n+void TopNCounter::serialize(std::string* buffer) {\n+    sort_retain(_capacity);\n+    PTopNCounter topn_counter;\n+    topn_counter.set_top_num(_top_num);\n+    topn_counter.set_space_expand_rate(_space_expand_rate);\n+    for(std::vector<Counter>::const_iterator it = _counter_vec->begin(); it != _counter_vec->end(); ++it)\n+    {\n+        PCounter* counter = topn_counter.add_counter();\n+        counter->set_item(it->get_item());\n+        counter->set_count(it->get_count());\n+    }\n+    topn_counter.SerializeToString(buffer);\n+}\n+\n+bool TopNCounter::deserialize(const doris::Slice &src) {\n+    PTopNCounter topn_counter;\n+    if (!topn_counter.ParseFromArray(src.data, src.size)) {\n+        LOG(WARNING) << \"topn counter deserialize failed\";\n+        return false;\n+    }\n+\n+    _space_expand_rate = topn_counter.space_expand_rate();\n+    set_top_num(topn_counter.top_num());\n+    for (int i = 0; i < topn_counter.counter_size(); ++i) {\n+        const PCounter& counter = topn_counter.counter(i);\n+        _counter_map->insert(std::make_pair(counter.item(), Counter(counter.item(), counter.count())));\n+        _counter_vec->emplace_back(counter.item(), counter.count());\n+    }\n+    _ordered = true;\n+    return true;\n+}\n+\n+void TopNCounter::sort_retain(uint32_t capacity) {\n+    _counter_vec->clear();\n+    sort_retain(capacity, _counter_vec);\n+    _ordered = true;\n+}\n+\n+void TopNCounter::sort_retain(uint32_t capacity, std::vector<Counter>* sort_vec) {\n+    for(std::unordered_map<std::string, Counter>::const_iterator it = _counter_map->begin(); it != _counter_map->end(); ++it) {\n+        sort_vec->emplace_back(it->second.get_item(), it->second.get_count());\n+    }\n+\n+    std::sort(sort_vec->begin(), sort_vec->end(), TopNComparator());\n+    if (sort_vec->size() > capacity) {\n+        for (uint32_t i = 0, n = sort_vec->size() - capacity; i < n; ++i) {\n+            auto &counter = sort_vec->back();\n+            _counter_map->erase(counter.get_item());\n+            sort_vec->pop_back();\n+        }\n+    }\n+}\n+\n+// Based on the  parallel version of the Space Saving algorithm as described in:\n+// A parallel space saving algorithm for frequent items and the Hurwitz zeta distribution by Massimo Cafaro, et al.\n+void TopNCounter::merge(doris::TopNCounter &&other) {\n+    if (other._counter_map->size() == 0) {\n+        return;\n+    }\n+\n+    _space_expand_rate = other._space_expand_rate;\n+    set_top_num(other._top_num);\n+    bool this_full = _counter_map->size() >= _capacity;\n+    bool another_full = other._counter_map->size() >= other._capacity;\n+\n+    uint64_t m1 = this_full ? _counter_vec->back().get_count() : 0;\n+    uint64_t m2 = another_full ? other._counter_vec->back().get_count() : 0;\n+   \n+    if (another_full == true) {\n+        for (auto &entry : *(this->_counter_map)) {\n+            entry.second.add_count(m2);\n+        }\n+    }\n+\n+    for (auto &other_entry : *(other._counter_map)) {\n+        auto itr = this->_counter_map->find(other_entry.first);\n+        if (itr != _counter_map->end()) {\n+            itr->second.add_count(other_entry.second.get_count() - m2);\n+        } else {\n+            this->_counter_map->insert(std::make_pair(other_entry.first,\n+                    Counter(other_entry.first,other_entry.second.get_count() + m1)));\n+        }\n+    }\n+    _ordered = false;\n+    sort_retain(_capacity);\n+}\n+\n+void TopNCounter::finalize(std::string& finalize_str) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNDA5MQ=="}, "originalCommit": {"oid": "03fbc56c62acade492594c47a2a97b876c349b39"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1007, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}