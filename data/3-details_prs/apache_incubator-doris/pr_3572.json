{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2ODMwNDE5", "number": 3572, "title": "[trace] Introduce trace util to BE", "bodyText": "Ref #3566\nIntroduce trace utility from Kudu to BE. This utility has been widely used in Kudu,\nImpala also import this trace utility.\nThis trace util is used for tracing each phases in a thread, and can be dumped to\nstring to see each phases' time cost and diagnose which phase cost more time.\nThis util store a Trace object as a threadlocal variable, we can add trace entries\nwhich record the current file name, line number, user specified symbols and\ntimestamp to this object, and it's able to add some counters to this Trace\nobject. And then, it can be dumped to human readable string.\nThere are some helpful macros defined in trace.h, here is a simple example for\nusage:\n  scoped_refptr<Trace> t1(new Trace);            // New 2 traces\n  scoped_refptr<Trace> t2(new Trace);\n  t1->AddChildTrace(\"child_trace\", t2.get());    // t1 add t2 as a child named \"child_trace\"\n\n  TRACE_TO(t1, \"step $0\", 1);  // Explicitly trace to t1\n  usleep(10);\n  // ... do some work\n  ADOPT_TRACE(t1.get());   // Explicitly adopt to trace to t1\n  TRACE(\"step $0\", 2);     // Implicitly trace to t1\n  {\n    // The time spent in this scope is added to counter t1.scope_time_cost\n    TRACE_COUNTER_SCOPE_LATENCY_US(\"scope_time_cost\");\n    ADOPT_TRACE(t2.get());  // Adopt to trace to t2 for the duration of the current scope\n    TRACE(\"sub start\");     // Implicitly trace to t2\n    usleep(10);\n    // ... do some work\n    TRACE(\"sub before loop\");\n    for (int i = 0; i < 10; ++i) {\n      TRACE_COUNTER_INCREMENT(\"iterate_count\", 1);  // Increase counter t2.iterate_count\n\n      MicrosecondsInt64 start_time = GetMonoTimeMicros();\n      usleep(10);\n      // ... do some work\n      MicrosecondsInt64 end_time = GetMonoTimeMicros();\n      int64_t dur = end_time - start_time;\n      // t2's simple histogram metric with name prefixed with \"lbm_writes\"\n      const char* counter = BUCKETED_COUNTER_NAME(\"lbm_writes\", dur);\n      TRACE_COUNTER_INCREMENT(counter, 1);\n    }\n    TRACE(\"sub after loop\");\n  }\n  TRACE(\"goodbye $0\", \"cruel world\");     // Automatically restore to trace to t1\n  std::cout << t1->DumpToString(Trace::INCLUDE_ALL) << std::endl;\n\noutput looks like:\n0514 02:16:07.988054 (+     0us) trace_test.cpp:76] step 1\n0514 02:16:07.988112 (+    58us) trace_test.cpp:80] step 2\n0514 02:16:07.988863 (+   751us) trace_test.cpp:103] goodbye cruel world\nRelated trace 'child_trace':\n0514 02:16:07.988120 (+     0us) trace_test.cpp:85] sub start\n0514 02:16:07.988188 (+    68us) trace_test.cpp:88] sub before loop\n0514 02:16:07.988850 (+   662us) trace_test.cpp:101] sub after loop\nMetrics: {\"scope_time_cost\":744,\"child_traces\":[[\"child_trace\",{\"iterate_count\":10,\"lbm_writes_lt_1ms\":10}]]}\n\nExclude the original source code, this patch\ndo the following work to adapt to Doris:\n\nRename \"kudu\" namespace to \"doris\"\nUpdate some names to the existing function names in Doris, i.g. strings::internal::SubstituteArg::kNoArg -> strings::internal::SubstituteArg::NoArg\nUse doris::SpinLock instead of kudu::simple_spinlock which hasn't been imported\nUse manual malloc() and free() instead of kudu::Arena which hasn't been imported\nUse manual rapidjson::Writer instead of kudu::JsonWriter which hasn't been imported\nRemove all TRACE_EVENT related unit tests since TRACE_EVENT is not imported this time\nUpdate CMakeLists.txt", "createdAt": "2020-05-12T16:18:08Z", "url": "https://github.com/apache/incubator-doris/pull/3572", "merged": true, "mergeCommit": {"oid": "bb7ae9784597c12fed263edd5241e9678b6d98d8"}, "closed": true, "closedAt": "2020-05-18T03:10:26Z", "author": {"login": "acelyc111"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcg20AMAH2gAyNDE2ODMwNDE5OmUwNjY3OTFlNDc3NjQ2NTNlMTNjMDI3MGRmZTRjMDY0YmVjNDBmYzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchZembAFqTQxMjMyMjYyNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e066791e47764653e13c0270dfe4c064bec40fc1", "author": {"user": {"login": "acelyc111", "name": "Yingchun Lai"}}, "url": "https://github.com/apache/incubator-doris/commit/e066791e47764653e13c0270dfe4c064bec40fc1", "committedDate": "2020-05-13T11:03:20Z", "message": "import original files"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "12d4ca3985fe710ac17ce2cb641d0cfeac810f09", "author": {"user": {"login": "acelyc111", "name": "Yingchun Lai"}}, "url": "https://github.com/apache/incubator-doris/commit/12d4ca3985fe710ac17ce2cb641d0cfeac810f09", "committedDate": "2020-05-12T16:20:16Z", "message": "revert shell"}, "afterCommit": {"oid": "c95885c27f0db8e66d8c6ab02eb81fdb0329566a", "author": {"user": {"login": "acelyc111", "name": "Yingchun Lai"}}, "url": "https://github.com/apache/incubator-doris/commit/c95885c27f0db8e66d8c6ab02eb81fdb0329566a", "committedDate": "2020-05-13T11:41:55Z", "message": "adapt to Doris"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d1ec0e7c37ef833a799801f360fbc91a3047a90b", "author": {"user": {"login": "acelyc111", "name": "Yingchun Lai"}}, "url": "https://github.com/apache/incubator-doris/commit/d1ec0e7c37ef833a799801f360fbc91a3047a90b", "committedDate": "2020-05-13T11:43:39Z", "message": "revert shell"}, "afterCommit": {"oid": "7481d9f1d37300d3b949f7cc6c01f1ecbcc80121", "author": {"user": {"login": "acelyc111", "name": "Yingchun Lai"}}, "url": "https://github.com/apache/incubator-doris/commit/7481d9f1d37300d3b949f7cc6c01f1ecbcc80121", "committedDate": "2020-05-13T11:50:19Z", "message": "adapt to Doris"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "840672391218d6dfe12a82c873404cd4aa57c423", "author": {"user": {"login": "acelyc111", "name": "Yingchun Lai"}}, "url": "https://github.com/apache/incubator-doris/commit/840672391218d6dfe12a82c873404cd4aa57c423", "committedDate": "2020-05-13T12:13:47Z", "message": "adapt to Doris"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "91222406deea0e7b6872107faf0632da72505a1b", "author": {"user": {"login": "acelyc111", "name": "Yingchun Lai"}}, "url": "https://github.com/apache/incubator-doris/commit/91222406deea0e7b6872107faf0632da72505a1b", "committedDate": "2020-05-13T12:11:41Z", "message": "ut revert"}, "afterCommit": {"oid": "840672391218d6dfe12a82c873404cd4aa57c423", "author": {"user": {"login": "acelyc111", "name": "Yingchun Lai"}}, "url": "https://github.com/apache/incubator-doris/commit/840672391218d6dfe12a82c873404cd4aa57c423", "committedDate": "2020-05-13T12:13:47Z", "message": "adapt to Doris"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTYzMjMz", "url": "https://github.com/apache/incubator-doris/pull/3572#pullrequestreview-410563233", "createdAt": "2020-05-13T03:29:02Z", "commit": {"oid": "12d4ca3985fe710ac17ce2cb641d0cfeac810f09"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzoyOTowMlrOGUgNqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNzozNTo0MlrOGVPnNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MjQ4OA==", "bodyText": "You can also change the macro definition.", "url": "https://github.com/apache/incubator-doris/pull/3572#discussion_r424152488", "createdAt": "2020-05-13T03:29:02Z", "author": {"login": "chaoyli"}, "path": "be/src/util/debug/trace_event_memory.h", "diffHunk": "@@ -0,0 +1,28 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#ifndef KUDU_DEBUG_TRACE_EVENT_MEMORY_H\n+#define KUDU_DEBUG_TRACE_EVENT_MEMORY_H", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d4ca3985fe710ac17ce2cb641d0cfeac810f09"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkyNjM2NA==", "bodyText": "It's better to change the indentation to make the code style compatible with the existed code.", "url": "https://github.com/apache/incubator-doris/pull/3572#discussion_r424926364", "createdAt": "2020-05-14T07:30:23Z", "author": {"login": "chaoyli"}, "path": "be/src/util/trace.h", "diffHunk": "@@ -0,0 +1,291 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <iosfwd>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include <rapidjson/writer.h>\n+\n+#include \"gutil/macros.h\"\n+#include \"gutil/strings/stringpiece.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"gutil/ref_counted.h\"\n+#include \"gutil/threading/thread_collision_warner.h\"\n+#include \"gutil/walltime.h\"\n+#include \"util/spinlock.h\"\n+#include \"util/trace_metrics.h\"\n+\n+namespace doris {\n+class Trace;\n+}\n+\n+// Adopt a Trace on the current thread for the duration of the current\n+// scope. The old current Trace is restored when the scope is exited.\n+//\n+// 't' should be a Trace* pointer.\n+#define ADOPT_TRACE(t) doris::ScopedAdoptTrace _adopt_trace(t);\n+\n+// Issue a trace message, if tracing is enabled in the current thread.\n+// See Trace::SubstituteAndTrace for arguments.\n+// Example:\n+//  TRACE(\"Acquired timestamp $0\", timestamp);\n+#define TRACE(format, substitutions...) \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "840672391218d6dfe12a82c873404cd4aa57c423"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkyOTA3Nw==", "bodyText": "I have a question about this.\nIf I start a child thread during my tracing, what about the behavior will be?", "url": "https://github.com/apache/incubator-doris/pull/3572#discussion_r424929077", "createdAt": "2020-05-14T07:35:42Z", "author": {"login": "chaoyli"}, "path": "be/src/util/trace.h", "diffHunk": "@@ -0,0 +1,291 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <iosfwd>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include <rapidjson/writer.h>\n+\n+#include \"gutil/macros.h\"\n+#include \"gutil/strings/stringpiece.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"gutil/ref_counted.h\"\n+#include \"gutil/threading/thread_collision_warner.h\"\n+#include \"gutil/walltime.h\"\n+#include \"util/spinlock.h\"\n+#include \"util/trace_metrics.h\"\n+\n+namespace doris {\n+class Trace;\n+}\n+\n+// Adopt a Trace on the current thread for the duration of the current\n+// scope. The old current Trace is restored when the scope is exited.\n+//\n+// 't' should be a Trace* pointer.\n+#define ADOPT_TRACE(t) doris::ScopedAdoptTrace _adopt_trace(t);\n+\n+// Issue a trace message, if tracing is enabled in the current thread.\n+// See Trace::SubstituteAndTrace for arguments.\n+// Example:\n+//  TRACE(\"Acquired timestamp $0\", timestamp);\n+#define TRACE(format, substitutions...) \\\n+  do { \\\n+    doris::Trace* _trace = doris::Trace::CurrentTrace(); \\\n+    if (_trace) { \\\n+      _trace->SubstituteAndTrace(__FILE__, __LINE__, (format),  \\\n+        ##substitutions); \\\n+    } \\\n+  } while (0)\n+\n+// Like the above, but takes the trace pointer as an explicit argument.\n+#define TRACE_TO(trace, format, substitutions...) \\\n+  (trace)->SubstituteAndTrace(__FILE__, __LINE__, (format), ##substitutions)\n+\n+// Increment a counter associated with the current trace.\n+//\n+// Each trace contains a map of counters which can be used to keep\n+// request-specific statistics. It is significantly faster to increment\n+// a trace counter compared to logging a message. Additionally, having\n+// slightly more structured information makes it easier to aggregate\n+// and show information back to operators.\n+//\n+// NOTE: the 'counter_name' MUST be a string which stays alive forever.\n+// Typically, this is a compile-time constant. If something other than\n+// a constant is required, use TraceMetric::InternName() in order to\n+// create a string which will last for the process lifetime. Of course,\n+// these strings will never be cleaned up, so it's important to use this\n+// judiciously.\n+//\n+// If no trace is active, this does nothing and does not evaluate its\n+// parameters.\n+#define TRACE_COUNTER_INCREMENT(counter_name, val) \\\n+  do { \\\n+    doris::Trace* _trace = doris::Trace::CurrentTrace(); \\\n+    if (_trace) { \\\n+      _trace->metrics()->Increment(counter_name, val); \\\n+    } \\\n+  } while (0)\n+\n+// Increment a counter for the amount of wall time spent in the current\n+// scope. For example:\n+//\n+//  void DoFoo() {\n+//    TRACE_COUNTER_SCOPE_LATENCY_US(\"foo_us\");\n+//    ... do expensive Foo thing\n+//  }\n+//\n+//  will result in a trace metric indicating the number of microseconds spent\n+//  in invocations of DoFoo().\n+#define TRACE_COUNTER_SCOPE_LATENCY_US(counter_name) \\\n+  ::doris::ScopedTraceLatencyCounter _scoped_latency(counter_name)\n+\n+// Construct a constant C string counter name which acts as a sort of\n+// coarse-grained histogram for trace metrics.\n+#define BUCKETED_COUNTER_NAME(prefix, duration_us)      \\\n+  [=]() {                                               \\\n+    if (duration_us >= 100 * 1000) {                    \\\n+      return prefix \"_gt_100_ms\";                       \\\n+    } else if (duration_us >= 10 * 1000) {              \\\n+      return prefix \"_10-100_ms\";                       \\\n+    } else if (duration_us >= 1000) {                   \\\n+      return prefix \"_1-10_ms\";                         \\\n+    } else {                                            \\\n+      return prefix \"_lt_1ms\";                          \\\n+    }                                                   \\\n+  }()\n+\n+namespace doris {\n+\n+struct TraceEntry;\n+\n+// A trace for a request or other process. This supports collecting trace entries\n+// from a number of threads, and later dumping the results to a stream.\n+//\n+// Callers should generally not add trace messages directly using the public\n+// methods of this class. Rather, the TRACE(...) macros defined above should\n+// be used such that file/line numbers are automatically included, etc.\n+//\n+// This class is thread-safe.\n+class Trace : public RefCountedThreadSafe<Trace> {\n+ public:\n+  Trace();\n+\n+  // Logs a message into the trace buffer.\n+  //\n+  // See strings::Substitute for details.\n+  //\n+  // N.B.: the file path passed here is not copied, so should be a static\n+  // constant (eg __FILE__).\n+  void SubstituteAndTrace(const char* filepath, int line_number,\n+                          StringPiece format,\n+                          const strings::internal::SubstituteArg& arg0 =\n+                            strings::internal::SubstituteArg::NoArg,\n+                          const strings::internal::SubstituteArg& arg1 =\n+                            strings::internal::SubstituteArg::NoArg,\n+                          const strings::internal::SubstituteArg& arg2 =\n+                            strings::internal::SubstituteArg::NoArg,\n+                          const strings::internal::SubstituteArg& arg3 =\n+                            strings::internal::SubstituteArg::NoArg,\n+                          const strings::internal::SubstituteArg& arg4 =\n+                            strings::internal::SubstituteArg::NoArg,\n+                          const strings::internal::SubstituteArg& arg5 =\n+                            strings::internal::SubstituteArg::NoArg,\n+                          const strings::internal::SubstituteArg& arg6 =\n+                            strings::internal::SubstituteArg::NoArg,\n+                          const strings::internal::SubstituteArg& arg7 =\n+                            strings::internal::SubstituteArg::NoArg,\n+                          const strings::internal::SubstituteArg& arg8 =\n+                            strings::internal::SubstituteArg::NoArg,\n+                          const strings::internal::SubstituteArg& arg9 =\n+                            strings::internal::SubstituteArg::NoArg);\n+\n+  // Dump the trace buffer to the given output stream.\n+  //\n+  enum {\n+    NO_FLAGS = 0,\n+\n+    // If set, calculate and print the difference between successive trace messages.\n+    INCLUDE_TIME_DELTAS = 1 << 0,\n+    // If set, include a 'Metrics' line showing any attached trace metrics.\n+    INCLUDE_METRICS =     1 << 1,\n+\n+    INCLUDE_ALL = INCLUDE_TIME_DELTAS | INCLUDE_METRICS\n+  };\n+  void Dump(std::ostream* out, int flags) const;\n+\n+  // Dump the trace buffer as a string.\n+  std::string DumpToString(int flags = INCLUDE_ALL) const;\n+\n+  std::string MetricsAsJSON() const;\n+\n+  // Attaches the given trace which will get appended at the end when Dumping.\n+  //\n+  // The 'label' does not necessarily have to be unique, and is used to identify\n+  // the child trace when dumped. The contents of the StringPiece are copied\n+  // into this trace's arena.\n+  void AddChildTrace(StringPiece label, Trace* child_trace);\n+\n+  // Return a copy of the current set of related \"child\" traces.\n+  std::vector<std::pair<StringPiece, scoped_refptr<Trace>>> ChildTraces() const;\n+\n+  // Return the current trace attached to this thread, if there is one.\n+  static Trace* CurrentTrace() {\n+    return threadlocal_trace_;\n+  }\n+\n+  // Simple function to dump the current trace to stderr, if one is\n+  // available. This is meant for usage when debugging in gdb via\n+  // 'call doris::Trace::DumpCurrentTrace();'.\n+  static void DumpCurrentTrace();\n+\n+  TraceMetrics* metrics() {\n+    return &metrics_;\n+  }\n+  const TraceMetrics& metrics() const {\n+    return metrics_;\n+  }\n+\n+ private:\n+  friend class ScopedAdoptTrace;\n+  friend class RefCountedThreadSafe<Trace>;\n+  ~Trace();\n+\n+  // The current trace for this thread. Threads should only set this using\n+  // using ScopedAdoptTrace, which handles reference counting the underlying\n+  // object.\n+  static __thread Trace* threadlocal_trace_;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "840672391218d6dfe12a82c873404cd4aa57c423"}, "originalPosition": 215}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fc2554e6c2aee01980d86b142597050446ab211", "author": {"user": {"login": "acelyc111", "name": "Yingchun Lai"}}, "url": "https://github.com/apache/incubator-doris/commit/9fc2554e6c2aee01980d86b142597050446ab211", "committedDate": "2020-05-14T14:45:22Z", "message": "indentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMzIyNjI1", "url": "https://github.com/apache/incubator-doris/pull/3572#pullrequestreview-412322625", "createdAt": "2020-05-15T03:26:38Z", "commit": {"oid": "9fc2554e6c2aee01980d86b142597050446ab211"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3065, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}