{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzNDgyMTMz", "number": 3034, "title": "implements intersect node", "bodyText": "#2845\nimlement of the intersect node\nnow can support  statement like select a from t  intersect select b from t1 intersect select 1", "createdAt": "2020-03-04T11:02:05Z", "url": "https://github.com/apache/incubator-doris/pull/3034", "merged": true, "mergeCommit": {"oid": "dc07182bd48f8cba6fafbfd491859e94a544abaf"}, "closed": true, "closedAt": "2020-03-09T02:52:56Z", "author": {"login": "yangzhg"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcKU98SgBqjMwOTYwMjQ1NzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcL0z_ZAFqTM3MDg5NDE3MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "78da6934195e4aeb2824c7944019cb0ea13047d1", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/78da6934195e4aeb2824c7944019cb0ea13047d1", "committedDate": "2020-03-04T10:54:04Z", "message": "implements intersect node"}, "afterCommit": {"oid": "6bb225b937bc5c646e66a5756b88688604ef42a0", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/6bb225b937bc5c646e66a5756b88688604ef42a0", "committedDate": "2020-03-04T11:10:51Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6bb225b937bc5c646e66a5756b88688604ef42a0", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/6bb225b937bc5c646e66a5756b88688604ef42a0", "committedDate": "2020-03-04T11:10:51Z", "message": "implements intersect node"}, "afterCommit": {"oid": "28de5b1b605258ae28a7a51ba650b982ab0178c0", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/28de5b1b605258ae28a7a51ba650b982ab0178c0", "committedDate": "2020-03-04T11:13:46Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "28de5b1b605258ae28a7a51ba650b982ab0178c0", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/28de5b1b605258ae28a7a51ba650b982ab0178c0", "committedDate": "2020-03-04T11:13:46Z", "message": "implements intersect node"}, "afterCommit": {"oid": "c5e54241221f5f6a7f359d02ac273a22f59c9154", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/c5e54241221f5f6a7f359d02ac273a22f59c9154", "committedDate": "2020-03-04T11:17:45Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c5e54241221f5f6a7f359d02ac273a22f59c9154", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/c5e54241221f5f6a7f359d02ac273a22f59c9154", "committedDate": "2020-03-04T11:17:45Z", "message": "implements intersect node"}, "afterCommit": {"oid": "ccd67794012aa0d39a18bff851e1c445c6924d57", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/ccd67794012aa0d39a18bff851e1c445c6924d57", "committedDate": "2020-03-04T11:56:50Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ccd67794012aa0d39a18bff851e1c445c6924d57", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/ccd67794012aa0d39a18bff851e1c445c6924d57", "committedDate": "2020-03-04T11:56:50Z", "message": "implements intersect node"}, "afterCommit": {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e", "committedDate": "2020-03-04T12:01:14Z", "message": "implements intersect node"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NzQ5NDI3", "url": "https://github.com/apache/incubator-doris/pull/3034#pullrequestreview-368749427", "createdAt": "2020-03-04T12:50:00Z", "commit": {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjo1MDowMFrOFxr95A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMzoxNzowOFrOFxs1HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY0NDkwMA==", "bodyText": "Move the TODO?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387644900", "createdAt": "2020-03-04T12:50:00Z", "author": {"login": "morningman"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -17,36 +17,23 @@\n \n #include \"exec/intersect_node.h\"\n \n+#include \"exec/hash_table.hpp\"\n #include \"exprs/expr.h\"\n+#include \"runtime/row_batch.h\"\n+#include \"runtime/runtime_state.h\"\n \n namespace doris {\n // TODO(yangzhengguo) implememt this class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY0NzYyMw==", "bodyText": "What's this comment mean?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387647623", "createdAt": "2020-03-04T12:55:30Z", "author": {"login": "morningman"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +43,177 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    // pre-computeselect k4 from t where k4 <4 the tuple index of build tuples in the output row", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1MTY2OQ==", "bodyText": "the _children.size() is 2, so is it possible to enter this else?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387651669", "createdAt": "2020-03-04T13:03:05Z", "author": {"login": "morningman"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +43,177 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    // pre-computeselect k4 from t where k4 <4 the tuple index of build tuples in the output row\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(1)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // build hash table\n+        HashTable* temp_tbl =\n+                new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size, false,\n+                              _find_nulls, id(), mem_tracker(), 1024);\n+        if (i == 1) {\n+            _hash_tbl.reset(temp_tbl);\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+            RETURN_IF_ERROR(child(0)->open(state));\n+\n+            while (true) {\n+                RETURN_IF_CANCELLED(state);\n+                bool eos = true;\n+                RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+                // take ownership of tuple data of build_batch\n+                _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+                RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect, while constructing the hash table.\");\n+                for (int i = 0; i < build_batch.num_rows(); ++i) {\n+                    _hash_tbl->insert(build_batch.get_row(i));\n+                }\n+                VLOG_ROW << \"hash table content: \"\n+                         << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+                build_batch.reset();\n+\n+                if (eos) {\n+                    break;\n+                }\n+            }\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1NzIxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect , while constructing the hash table.\");\n          \n          \n            \n                        RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect , while probing the hash table.\");", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387657215", "createdAt": "2020-03-04T13:13:50Z", "author": {"login": "morningman"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +43,177 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    // pre-computeselect k4 from t where k4 <4 the tuple index of build tuples in the output row\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(1)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // build hash table\n+        HashTable* temp_tbl =\n+                new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size, false,\n+                              _find_nulls, id(), mem_tracker(), 1024);\n+        if (i == 1) {\n+            _hash_tbl.reset(temp_tbl);\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+            RETURN_IF_ERROR(child(0)->open(state));\n+\n+            while (true) {\n+                RETURN_IF_CANCELLED(state);\n+                bool eos = true;\n+                RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+                // take ownership of tuple data of build_batch\n+                _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+                RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect, while constructing the hash table.\");\n+                for (int i = 0; i < build_batch.num_rows(); ++i) {\n+                    _hash_tbl->insert(build_batch.get_row(i));\n+                }\n+                VLOG_ROW << \"hash table content: \"\n+                         << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+                build_batch.reset();\n+\n+                if (eos) {\n+                    break;\n+                }\n+            }\n+        } else {\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (_hash_tbl_iterator.matched()) {\n+                    temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl->close();\n+            _hash_tbl.reset(temp_tbl);\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        while (true) {\n+            RETURN_IF_CANCELLED(state);\n+            bool eos = true;\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect , while constructing the hash table.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1OTAzNg==", "bodyText": "Not used?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387659036", "createdAt": "2020-03-04T13:17:08Z", "author": {"login": "morningman"}, "path": "be/src/exec/intersect_node.h", "diffHunk": "@@ -38,61 +44,36 @@ class IntersectNode : public ExecNode {\n \n     virtual Status init(const TPlanNode& tnode, RuntimeState* state = nullptr);\n     virtual Status prepare(RuntimeState* state);\n-    virtual void codegen(RuntimeState* state);\n     virtual Status open(RuntimeState* state);\n     virtual Status get_next(RuntimeState* state, RowBatch* row_batch, bool* eos);\n     // virtual Status reset(RuntimeState* state);\n     virtual Status close(RuntimeState* state);\n \n private:\n-    /// Tuple id resolved in Prepare() to set tuple_desc_;\n-    const int _tuple_id;\n-\n-    /// Descriptor for tuples this union node constructs.\n-    const TupleDescriptor* _tuple_desc;\n-\n-    /// Index of the first non-passthrough child; i.e. a child that needs materialization.\n-    /// 0 when all children are materialized, '_children.size()' when no children are\n-    /// materialized.\n-    const int _first_materialized_child_idx;\n-\n-    /// Const exprs materialized by this node. These exprs don't refer to any children.\n-    /// Only materialized by the first fragment instance to avoid duplication.\n+    // Const exprs materialized by this node. These exprs don't refer to any children.\n+    // Only materialized by the first fragment instance to avoid duplication.\n     std::vector<std::vector<ExprContext*>> _const_expr_lists;\n \n-    /// Exprs materialized by this node. The i-th result expr list refers to the i-th child.\n+    // Exprs materialized by this node. The i-th result expr list refers to the i-th child.\n     std::vector<std::vector<ExprContext*>> _child_expr_lists;\n \n-    /////////////////////////////////////////\n-    /// BEGIN: Members that must be Reset()\n-\n-    /// Index of current child.\n-    int _child_idx;\n-\n-    /// Current row batch of current child. We reset the pointer to a new RowBatch\n-    /// when switching to a different child.\n-    std::unique_ptr<RowBatch> _child_batch;\n-\n-    /// Index of current row in child_row_batch_.\n-    int _child_row_idx;\n-\n-    typedef void (*IntersectMaterializeBatchFn)(IntersectNode*, RowBatch*, uint8_t**);\n-    /// Vector of pointers to codegen'ed materialize_batch functions. The vector contains one\n-    /// function for each child. The size of the vector should be equal to the number of\n-    /// children. If a child is passthrough, there should be a NULL for that child. If\n-    /// Codegen is disabled, there should be a NULL for every child.\n-    std::vector<IntersectMaterializeBatchFn> _codegend_except_materialize_batch_fns;\n+    boost::scoped_ptr<HashTable> _hash_tbl;\n+    HashTable::Iterator _hash_tbl_iterator;\n+    boost::scoped_ptr<RowBatch> _probe_batch;\n \n-    /// Saved from the last to GetNext() on the current child.\n-    bool _child_eos;\n+    boost::scoped_ptr<MemPool> _build_pool;  // holds everything referenced in _hash_tbl\n \n-    /// Index of current const result expr list.\n-    int _const_expr_list_idx;\n+    // _build_tuple_idx[i] is the tuple index of child(1)'s tuple[i] in the output row\n+    std::vector<int> _build_tuple_idx;\n+    int _build_tuple_size;\n+    int _build_tuple_row_size;\n+    std::vector<bool> _find_nulls;\n \n-    /// Index of the child that needs to be closed on the next GetNext() call. Should be set\n-    /// to -1 if no child needs to be closed.\n-    int _to_close_child_idx;\n+    // for right outer joins, keep track of what's been joined\n+    typedef boost::unordered_set<TupleRow*> TempTupleRowSet;\n+    TempTupleRowSet _temp_rows;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4Njg5ODg5", "url": "https://github.com/apache/incubator-doris/pull/3034#pullrequestreview-368689889", "createdAt": "2020-03-04T11:09:01Z", "commit": {"oid": "78da6934195e4aeb2824c7944019cb0ea13047d1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMTowOTowMVrOFxpGHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMTowOTowMVrOFxpGHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5Nzg1NQ==", "bodyText": "use std::unique_ptr and std::unordered_set instead.", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387597855", "createdAt": "2020-03-04T11:09:01Z", "author": {"login": "chaoyli"}, "path": "be/src/exec/intersect_node.h", "diffHunk": "@@ -20,11 +20,17 @@\n #define  DORIS_BE_SRC_QUERY_EXEC_INTERSECT_NODE_H\n \n #include \"exec/exec_node.h\"\n-#include \"runtime/row_batch.h\"\n-#include \"runtime/runtime_state.h\"\n+\n+#include <boost/unordered_set.hpp>\n+#include <boost/scoped_ptr.hpp>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78da6934195e4aeb2824c7944019cb0ea13047d1"}, "originalPosition": 8}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e", "committedDate": "2020-03-04T12:01:14Z", "message": "implements intersect node"}, "afterCommit": {"oid": "801566ebd3168ef2139df2cf05c7e8c91ad3583f", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/801566ebd3168ef2139df2cf05c7e8c91ad3583f", "committedDate": "2020-03-05T01:55:19Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "801566ebd3168ef2139df2cf05c7e8c91ad3583f", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/801566ebd3168ef2139df2cf05c7e8c91ad3583f", "committedDate": "2020-03-05T01:55:19Z", "message": "implements intersect node"}, "afterCommit": {"oid": "d2ed4b2d64761065251354d07691afee346ac8cb", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/d2ed4b2d64761065251354d07691afee346ac8cb", "committedDate": "2020-03-05T01:57:06Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d2ed4b2d64761065251354d07691afee346ac8cb", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/d2ed4b2d64761065251354d07691afee346ac8cb", "committedDate": "2020-03-05T01:57:06Z", "message": "implements intersect node"}, "afterCommit": {"oid": "2b60dbd7e9bf3577332a7872013da8995da68459", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/2b60dbd7e9bf3577332a7872013da8995da68459", "committedDate": "2020-03-05T02:01:46Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2b60dbd7e9bf3577332a7872013da8995da68459", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/2b60dbd7e9bf3577332a7872013da8995da68459", "committedDate": "2020-03-05T02:01:46Z", "message": "implements intersect node"}, "afterCommit": {"oid": "81028ef6ef59b4c7638810fce3e97a93865bd003", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/81028ef6ef59b4c7638810fce3e97a93865bd003", "committedDate": "2020-03-05T02:13:49Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "81028ef6ef59b4c7638810fce3e97a93865bd003", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/81028ef6ef59b4c7638810fce3e97a93865bd003", "committedDate": "2020-03-05T02:13:49Z", "message": "implements intersect node"}, "afterCommit": {"oid": "4e6832606a099154ab97ce0eb6638411a2ce9394", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/4e6832606a099154ab97ce0eb6638411a2ce9394", "committedDate": "2020-03-05T02:21:25Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e6832606a099154ab97ce0eb6638411a2ce9394", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/4e6832606a099154ab97ce0eb6638411a2ce9394", "committedDate": "2020-03-05T02:21:25Z", "message": "implements intersect node"}, "afterCommit": {"oid": "d7ce5e40e033829dde8f12788b3a115cfac5cfb2", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/d7ce5e40e033829dde8f12788b3a115cfac5cfb2", "committedDate": "2020-03-05T03:04:48Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d7ce5e40e033829dde8f12788b3a115cfac5cfb2", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/d7ce5e40e033829dde8f12788b3a115cfac5cfb2", "committedDate": "2020-03-05T03:04:48Z", "message": "implements intersect node"}, "afterCommit": {"oid": "1a988b39f3cde9261662b03e5bb615b2aab89c69", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/1a988b39f3cde9261662b03e5bb615b2aab89c69", "committedDate": "2020-03-05T03:55:38Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1a988b39f3cde9261662b03e5bb615b2aab89c69", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/1a988b39f3cde9261662b03e5bb615b2aab89c69", "committedDate": "2020-03-05T03:55:38Z", "message": "implements intersect node"}, "afterCommit": {"oid": "43b62c1e08a24c7b0ba9ae52984cfb1748d1fec9", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/43b62c1e08a24c7b0ba9ae52984cfb1748d1fec9", "committedDate": "2020-03-05T03:59:25Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "43b62c1e08a24c7b0ba9ae52984cfb1748d1fec9", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/43b62c1e08a24c7b0ba9ae52984cfb1748d1fec9", "committedDate": "2020-03-05T03:59:25Z", "message": "implements intersect node"}, "afterCommit": {"oid": "f08b227a6147a1e9e0fa01df13d8f77592f94467", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/f08b227a6147a1e9e0fa01df13d8f77592f94467", "committedDate": "2020-03-05T06:04:56Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f08b227a6147a1e9e0fa01df13d8f77592f94467", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/f08b227a6147a1e9e0fa01df13d8f77592f94467", "committedDate": "2020-03-05T06:04:56Z", "message": "implements intersect node"}, "afterCommit": {"oid": "4b321b6f168a3a6db70f341e2a47ad7ee875ef93", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/4b321b6f168a3a6db70f341e2a47ad7ee875ef93", "committedDate": "2020-03-05T06:10:50Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4b321b6f168a3a6db70f341e2a47ad7ee875ef93", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/4b321b6f168a3a6db70f341e2a47ad7ee875ef93", "committedDate": "2020-03-05T06:10:50Z", "message": "implements intersect node"}, "afterCommit": {"oid": "b09c5b3b4e06e42a472358fedef026807a72f890", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/b09c5b3b4e06e42a472358fedef026807a72f890", "committedDate": "2020-03-05T07:30:59Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b09c5b3b4e06e42a472358fedef026807a72f890", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/b09c5b3b4e06e42a472358fedef026807a72f890", "committedDate": "2020-03-05T07:30:59Z", "message": "implements intersect node"}, "afterCommit": {"oid": "62df2d6c12ac0b041f369482aecabe21fd8cc6be", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/62df2d6c12ac0b041f369482aecabe21fd8cc6be", "committedDate": "2020-03-05T07:58:21Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "62df2d6c12ac0b041f369482aecabe21fd8cc6be", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/62df2d6c12ac0b041f369482aecabe21fd8cc6be", "committedDate": "2020-03-05T07:58:21Z", "message": "implements intersect node"}, "afterCommit": {"oid": "0a32f411248c7bc802f4203331748146f26720b7", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/0a32f411248c7bc802f4203331748146f26720b7", "committedDate": "2020-03-05T08:27:16Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a32f411248c7bc802f4203331748146f26720b7", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/0a32f411248c7bc802f4203331748146f26720b7", "committedDate": "2020-03-05T08:27:16Z", "message": "implements intersect node"}, "afterCommit": {"oid": "4d5ef754170c2481ac9bfd03d352d461c3c367b4", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/4d5ef754170c2481ac9bfd03d352d461c3c367b4", "committedDate": "2020-03-05T08:31:11Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4d5ef754170c2481ac9bfd03d352d461c3c367b4", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/4d5ef754170c2481ac9bfd03d352d461c3c367b4", "committedDate": "2020-03-05T08:31:11Z", "message": "implements intersect node"}, "afterCommit": {"oid": "588e3421afe47c8c0bdad520098165a2b30d2767", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/588e3421afe47c8c0bdad520098165a2b30d2767", "committedDate": "2020-03-05T09:43:27Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "588e3421afe47c8c0bdad520098165a2b30d2767", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/588e3421afe47c8c0bdad520098165a2b30d2767", "committedDate": "2020-03-05T09:43:27Z", "message": "implements intersect node"}, "afterCommit": {"oid": "890a10df8fedb10c85ab49e2edb34518f89ae68b", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/890a10df8fedb10c85ab49e2edb34518f89ae68b", "committedDate": "2020-03-05T09:49:18Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "890a10df8fedb10c85ab49e2edb34518f89ae68b", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/890a10df8fedb10c85ab49e2edb34518f89ae68b", "committedDate": "2020-03-05T09:49:18Z", "message": "implements intersect node"}, "afterCommit": {"oid": "3d9ce0d7a19cd42f4d35152553996d12075ae69b", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/3d9ce0d7a19cd42f4d35152553996d12075ae69b", "committedDate": "2020-03-06T01:44:41Z", "message": "implements intersect node"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMTI1ODUy", "url": "https://github.com/apache/incubator-doris/pull/3034#pullrequestreview-370125852", "createdAt": "2020-03-06T07:29:51Z", "commit": {"oid": "3d9ce0d7a19cd42f4d35152553996d12075ae69b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzoyOTo1MlrOFyvVlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzoyOTo1MlrOFyvVlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0ODY5NQ==", "bodyText": "const_expr_list not use? why not delete it?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388748695", "createdAt": "2020-03-06T07:29:52Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -17,36 +17,21 @@\n \n #include \"exec/intersect_node.h\"\n \n+#include \"exec/hash_table.hpp\"\n #include \"exprs/expr.h\"\n+#include \"runtime/row_batch.h\"\n+#include \"runtime/runtime_state.h\"\n \n namespace doris {\n-// TODO(yangzhengguo) implememt this class\n-IntersectNode::IntersectNode(ObjectPool* pool, const TPlanNode& tnode,\n-    const DescriptorTbl& descs)\n-    : ExecNode(pool, tnode, descs),\n-      _tuple_id(tnode.intersect_node.tuple_id),\n-      _tuple_desc(nullptr),\n-      _first_materialized_child_idx(tnode.intersect_node.first_materialized_child_idx),\n-      _child_idx(0),\n-      _child_batch(nullptr),\n-      _child_row_idx(0),\n-      _child_eos(false),\n-      _const_expr_list_idx(0),\n-      _to_close_child_idx(-1) {\n-}\n+IntersectNode::IntersectNode(ObjectPool* pool, const TPlanNode& tnode, const DescriptorTbl& descs)\n+        : ExecNode(pool, tnode, descs) {}\n \n Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n-    // RETURN_IF_ERROR(ExecNode::init(tnode, state));\n     RETURN_IF_ERROR(ExecNode::init(tnode, state));\n     DCHECK(tnode.__isset.intersect_node);\n     DCHECK_EQ(_conjunct_ctxs.size(), 0);\n-    // Create const_expr_ctx_lists_ from thrift exprs.\n-    auto& const_texpr_lists = tnode.intersect_node.const_expr_lists;\n-    for (auto& texprs : const_texpr_lists) {\n-        std::vector<ExprContext*> ctxs;\n-        RETURN_IF_ERROR(Expr::create_expr_trees(_pool, texprs, &ctxs));\n-        _const_expr_lists.push_back(ctxs);\n-    }\n+    DCHECK_GE(_children.size(), 2);\n+    DCHECK_EQ(tnode.intersect_node.const_expr_lists.size(), 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9ce0d7a19cd42f4d35152553996d12075ae69b"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMTMxMjkw", "url": "https://github.com/apache/incubator-doris/pull/3034#pullrequestreview-370131290", "createdAt": "2020-03-06T07:43:48Z", "commit": {"oid": "3d9ce0d7a19cd42f4d35152553996d12075ae69b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzo0Mzo0OFrOFyvnGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzo0Mzo0OFrOFyvnGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1MzE3OA==", "bodyText": "child\uff081\uff09\uff1f", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388753178", "createdAt": "2020-03-06T07:43:48Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(1)->row_desc().tuple_descriptors()[i];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9ce0d7a19cd42f4d35152553996d12075ae69b"}, "originalPosition": 64}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d9ce0d7a19cd42f4d35152553996d12075ae69b", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/3d9ce0d7a19cd42f4d35152553996d12075ae69b", "committedDate": "2020-03-06T01:44:41Z", "message": "implements intersect node"}, "afterCommit": {"oid": "073464879d9d1cde63e99aafddbb3a2644a3425c", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/073464879d9d1cde63e99aafddbb3a2644a3425c", "committedDate": "2020-03-06T07:43:55Z", "message": "implements intersect node"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMTM1ODk1", "url": "https://github.com/apache/incubator-doris/pull/3034#pullrequestreview-370135895", "createdAt": "2020-03-06T07:54:50Z", "commit": {"oid": "3d9ce0d7a19cd42f4d35152553996d12075ae69b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODowNDowMVrOFywBNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODoxNDowMFrOFywO2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1OTg2MQ==", "bodyText": "why use _build_tuple_size? if 100 table intersect, the build_tuple_size = 100?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388759861", "createdAt": "2020-03-06T08:04:01Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "073464879d9d1cde63e99aafddbb3a2644a3425c"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MjAwMQ==", "bodyText": "if i > 0, we can also enter this branch,  child(0) may be wrong?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388762001", "createdAt": "2020-03-06T08:10:16Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),\n+                                          mem_tracker(), 1024));\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "073464879d9d1cde63e99aafddbb3a2644a3425c"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MjU4Mw==", "bodyText": "when i = 0, the first table build  _hash_tbl , but you can't set matched() function.\nwhen i = 1, the _hash_tbl's \" _hash_tbl_iterator.matched() \"is true of false?", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388762583", "createdAt": "2020-03-06T08:11:47Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),\n+                                          mem_tracker(), 1024));\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+            RETURN_IF_ERROR(child(0)->open(state));\n+\n+            while (true) {\n+                RETURN_IF_CANCELLED(state);\n+                bool eos = true;\n+                RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+                // take ownership of tuple data of build_batch\n+                _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+                RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect, while constructing the hash table.\");\n+                for (int j = 0; j < build_batch.num_rows(); ++j) {\n+                    _hash_tbl->insert(build_batch.get_row(j));\n+                }\n+                VLOG_ROW << \"hash table content: \"\n+                         << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+                build_batch.reset();\n+\n+                if (eos) {\n+                    break;\n+                }\n+            }\n+            // using next child to probe\n+            if (i < _children.size() - 1) {\n+                ++i;\n+            } else {\n+                break;\n+            }\n+        } else {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  false, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (_hash_tbl_iterator.matched()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "073464879d9d1cde63e99aafddbb3a2644a3425c"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MzM1Mg==", "bodyText": "do you test the null value? can null  output.", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388763352", "createdAt": "2020-03-06T08:14:00Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),\n+                                          mem_tracker(), 1024));\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+            RETURN_IF_ERROR(child(0)->open(state));\n+\n+            while (true) {\n+                RETURN_IF_CANCELLED(state);\n+                bool eos = true;\n+                RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+                // take ownership of tuple data of build_batch\n+                _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+                RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect, while constructing the hash table.\");\n+                for (int j = 0; j < build_batch.num_rows(); ++j) {\n+                    _hash_tbl->insert(build_batch.get_row(j));\n+                }\n+                VLOG_ROW << \"hash table content: \"\n+                         << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+                build_batch.reset();\n+\n+                if (eos) {\n+                    break;\n+                }\n+            }\n+            // using next child to probe\n+            if (i < _children.size() - 1) {\n+                ++i;\n+            } else {\n+                break;\n+            }\n+        } else {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  false, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (_hash_tbl_iterator.matched()) {\n+                    temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                }\n+                _hash_tbl_iterator.next<false>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "073464879d9d1cde63e99aafddbb3a2644a3425c"}, "originalPosition": 150}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "073464879d9d1cde63e99aafddbb3a2644a3425c", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/073464879d9d1cde63e99aafddbb3a2644a3425c", "committedDate": "2020-03-06T07:43:55Z", "message": "implements intersect node"}, "afterCommit": {"oid": "24e3ab3671a851023ea8a1297f923832d52710b7", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/24e3ab3671a851023ea8a1297f923832d52710b7", "committedDate": "2020-03-06T09:14:32Z", "message": "implements intersect node"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d77312b3aacd6cc7377ecaac5c925a5bb45b454b", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/d77312b3aacd6cc7377ecaac5c925a5bb45b454b", "committedDate": "2020-03-06T09:21:41Z", "message": "implements intersect node"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "24e3ab3671a851023ea8a1297f923832d52710b7", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/24e3ab3671a851023ea8a1297f923832d52710b7", "committedDate": "2020-03-06T09:14:32Z", "message": "implements intersect node"}, "afterCommit": {"oid": "d77312b3aacd6cc7377ecaac5c925a5bb45b454b", "author": {"user": {"login": "yangzhg", "name": "Zhengguo Yang"}}, "url": "https://github.com/apache/incubator-doris/commit/d77312b3aacd6cc7377ecaac5c925a5bb45b454b", "committedDate": "2020-03-06T09:21:41Z", "message": "implements intersect node"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODkzNjY3", "url": "https://github.com/apache/incubator-doris/pull/3034#pullrequestreview-370893667", "createdAt": "2020-03-09T02:48:35Z", "commit": {"oid": "d77312b3aacd6cc7377ecaac5c925a5bb45b454b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODk0MTcx", "url": "https://github.com/apache/incubator-doris/pull/3034#pullrequestreview-370894171", "createdAt": "2020-03-09T02:51:06Z", "commit": {"oid": "d77312b3aacd6cc7377ecaac5c925a5bb45b454b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3502, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}