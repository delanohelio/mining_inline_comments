{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1MzYzNTEw", "number": 3056, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzo0NzoxNFrODmr2lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTo1OTo0OFrODnzsbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODkwOTY1OnYy", "diffSide": "RIGHT", "path": "be/src/exec/except_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzo0NzoxNFrOF0PehA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzo0NzoxNFrOF0PehA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMyMzg0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390323844", "createdAt": "2020-03-10T13:47:14Z", "author": {"login": "morningman"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,158 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f32a4d3e4dde0daef959f20eecd66fb309804a"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODk2NDIwOnYy", "diffSide": "RIGHT", "path": "be/src/exec/except_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzo1OToyN1rOF0QAhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzo1OToyN1rOF0QAhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMzMjU0OA==", "bodyText": "Should it be\n_hash_tbl_iterator == _hash_tbl->end()", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390332548", "createdAt": "2020-03-10T13:59:27Z", "author": {"login": "morningman"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,158 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f32a4d3e4dde0daef959f20eecd66fb309804a"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODk4MDAyOnYy", "diffSide": "RIGHT", "path": "fe/src/main/java/org/apache/doris/analysis/SetOperationStmt.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDowMjo1N1rOF0QKIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDowMjo1N1rOF0QKIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMzNTAwOQ==", "bodyText": "What this for? Could you add comment to explain this rewrite?", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390335009", "createdAt": "2020-03-10T14:02:57Z", "author": {"login": "morningman"}, "path": "fe/src/main/java/org/apache/doris/analysis/SetOperationStmt.java", "diffHunk": "@@ -649,6 +648,13 @@ public void analyze(Analyzer parent) throws AnalysisException, UserException {\n             if (isAnalyzed()) {\n                 return;\n             }\n+            if (queryStmt instanceof SelectStmt && ((SelectStmt) queryStmt).fromClause_.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8f32a4d3e4dde0daef959f20eecd66fb309804a"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTQ2NTc0OnYy", "diffSide": "RIGHT", "path": "be/src/exec/except_node.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzozOTowNFrOF0oQwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNDowMDo0NlrOF0oiyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyOTkyMQ==", "bodyText": "why do you use  'if (!_hash_tbl_iterator.matched())'?\nmay be you should use ' if (_hash_tbl_iterator.matched())'\nmatched means exceptNode", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390729921", "createdAt": "2020-03-11T03:39:04Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,157 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        if (i != _children.size() - 1) {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczNDUzNw==", "bodyText": "a excepte b , use a to build a hash table and use b to probe\nthe result is  element in a and never mached", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390734537", "createdAt": "2020-03-11T04:00:46Z", "author": {"login": "yangzhg"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,157 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        if (i != _children.size() - 1) {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyOTkyMQ=="}, "originalCommit": {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTQ3NTI2OnYy", "diffSide": "RIGHT", "path": "be/src/exec/except_node.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo0NjoyN1rOF0oW0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNDowMjo1MlrOF0okag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMTQ3Mw==", "bodyText": "How about if the hash value of hashtable is - 1\uff1f", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390731473", "createdAt": "2020-03-11T03:46:27Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,157 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        if (i != _children.size() - 1) {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    while (_hash_tbl_iterator.has_next()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczNDk1NA==", "bodyText": "because hash value  is a unsigned int", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390734954", "createdAt": "2020-03-11T04:02:52Z", "author": {"login": "yangzhg"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,157 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        if (i != _children.size() - 1) {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    while (_hash_tbl_iterator.has_next()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMTQ3Mw=="}, "originalCommit": {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTQ3ODk3OnYy", "diffSide": "RIGHT", "path": "be/src/exec/except_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo0ODo1MlrOF0oY8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo0ODo1MlrOF0oY8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMjAxNg==", "bodyText": "If the two hash values are equal, it does not mean that the two values are equal. You need to compare the original values.\nThere may be a problem with the else's logic", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390732016", "createdAt": "2020-03-11T03:48:52Z", "author": {"login": "wutiangan"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,157 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        if (i != _children.size() - 1) {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+            previous_hash = _hash_tbl_iterator.get_hash();\n+            if (!_hash_tbl_iterator.matched()) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDYzMTY3OnYy", "diffSide": "LEFT", "path": "be/src/exec/exec_node.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTo0MDo1N1rOF2Apnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMjo0MzoxMFrOF2CO1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE3ODA3OQ==", "bodyText": "Remove this line.", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392178079", "createdAt": "2020-03-13T11:40:57Z", "author": {"login": "kangkaisen"}, "path": "be/src/exec/exec_node.cpp", "diffHunk": "@@ -446,9 +446,9 @@ Status ExecNode::create_node(RuntimeState* state, ObjectPool* pool, const TPlanN\n         *node = pool->add(new IntersectNode(pool, tnode, descs));\n         return Status::OK();\n \n-    // case TPlanNodeType::EXCEPT_NODE:\n-    //     *node = pool->add(new ExceptNode(pool, tnode, descs));\n-    //     return Status::OK();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIwMzk4OQ==", "bodyText": "comment in wrong place \uff1f", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392203989", "createdAt": "2020-03-13T12:43:10Z", "author": {"login": "yangzhg"}, "path": "be/src/exec/exec_node.cpp", "diffHunk": "@@ -446,9 +446,9 @@ Status ExecNode::create_node(RuntimeState* state, ObjectPool* pool, const TPlanN\n         *node = pool->add(new IntersectNode(pool, tnode, descs));\n         return Status::OK();\n \n-    // case TPlanNodeType::EXCEPT_NODE:\n-    //     *node = pool->add(new ExceptNode(pool, tnode, descs));\n-    //     return Status::OK();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE3ODA3OQ=="}, "originalCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDY3MjU2OnYy", "diffSide": "RIGHT", "path": "be/src/exec/except_node.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTo1Njo0MlrOF2BDOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMzo1OTo0N1rOF2Etog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NDYzMw==", "bodyText": "This if statement could remove ?", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392184633", "createdAt": "2020-03-13T11:56:42Z", "author": {"login": "kangkaisen"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +41,190 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_timer = ADD_TIMER(runtime_profile(), \"BuildTime\");\n+    _probe_timer = ADD_TIMER(runtime_profile(), \"ProbeTime\");\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_build_tuple_size, true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table, use _child_expr_lists[0] as probe is used for remove duplicted\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[0], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        SCOPED_TIMER(_build_timer);\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        // build hash table and remvoe duplicate items\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert_unique(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // rebuid hash table, for first time will rebuild with the no duplicated _hash_tbl,\n+        if (i > 1) {\n+            SCOPED_TIMER(_build_timer);\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        ScopedTimer<MonotonicStopWatch> probe_timer(_probe_timer);\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    TupleRow* previous_row = nullptr;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (!_hash_tbl_iterator.matched()) {\n+            if (previous_hash != _hash_tbl_iterator.get_hash() ||\n+                !equals(previous_row, _hash_tbl_iterator.get_row())) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+                ++_num_rows_returned;\n+            }\n+        }\n+        previous_hash = _hash_tbl_iterator.get_hash();\n+        previous_row = _hash_tbl_iterator.get_row();\n+        _hash_tbl_iterator.next<false>();\n+\n+        *eos = !_hash_tbl_iterator.has_next() || reached_limit();\n+        if (out_batch->is_full() || out_batch->at_resource_limit() || *eos) {\n+            return Status::OK();\n+        }\n+    }\n+    return Status::OK();\n+}\n+\n+bool ExceptNode::equals(TupleRow* row, TupleRow* other) {\n+    if (row == nullptr && other == nullptr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIwNDU3Mg==", "bodyText": "this for a safe guard", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392204572", "createdAt": "2020-03-13T12:44:33Z", "author": {"login": "yangzhg"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +41,190 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_timer = ADD_TIMER(runtime_profile(), \"BuildTime\");\n+    _probe_timer = ADD_TIMER(runtime_profile(), \"ProbeTime\");\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_build_tuple_size, true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table, use _child_expr_lists[0] as probe is used for remove duplicted\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[0], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        SCOPED_TIMER(_build_timer);\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        // build hash table and remvoe duplicate items\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert_unique(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // rebuid hash table, for first time will rebuild with the no duplicated _hash_tbl,\n+        if (i > 1) {\n+            SCOPED_TIMER(_build_timer);\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        ScopedTimer<MonotonicStopWatch> probe_timer(_probe_timer);\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    TupleRow* previous_row = nullptr;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (!_hash_tbl_iterator.matched()) {\n+            if (previous_hash != _hash_tbl_iterator.get_hash() ||\n+                !equals(previous_row, _hash_tbl_iterator.get_row())) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+                ++_num_rows_returned;\n+            }\n+        }\n+        previous_hash = _hash_tbl_iterator.get_hash();\n+        previous_row = _hash_tbl_iterator.get_row();\n+        _hash_tbl_iterator.next<false>();\n+\n+        *eos = !_hash_tbl_iterator.has_next() || reached_limit();\n+        if (out_batch->is_full() || out_batch->at_resource_limit() || *eos) {\n+            return Status::OK();\n+        }\n+    }\n+    return Status::OK();\n+}\n+\n+bool ExceptNode::equals(TupleRow* row, TupleRow* other) {\n+    if (row == nullptr && other == nullptr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NDYzMw=="}, "originalCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIwNjg2Mw==", "bodyText": "I don't see any meaning.", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392206863", "createdAt": "2020-03-13T12:49:22Z", "author": {"login": "kangkaisen"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +41,190 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_timer = ADD_TIMER(runtime_profile(), \"BuildTime\");\n+    _probe_timer = ADD_TIMER(runtime_profile(), \"ProbeTime\");\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_build_tuple_size, true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table, use _child_expr_lists[0] as probe is used for remove duplicted\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[0], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        SCOPED_TIMER(_build_timer);\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        // build hash table and remvoe duplicate items\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert_unique(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // rebuid hash table, for first time will rebuild with the no duplicated _hash_tbl,\n+        if (i > 1) {\n+            SCOPED_TIMER(_build_timer);\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        ScopedTimer<MonotonicStopWatch> probe_timer(_probe_timer);\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    TupleRow* previous_row = nullptr;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (!_hash_tbl_iterator.matched()) {\n+            if (previous_hash != _hash_tbl_iterator.get_hash() ||\n+                !equals(previous_row, _hash_tbl_iterator.get_row())) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+                ++_num_rows_returned;\n+            }\n+        }\n+        previous_hash = _hash_tbl_iterator.get_hash();\n+        previous_row = _hash_tbl_iterator.get_row();\n+        _hash_tbl_iterator.next<false>();\n+\n+        *eos = !_hash_tbl_iterator.has_next() || reached_limit();\n+        if (out_batch->is_full() || out_batch->at_resource_limit() || *eos) {\n+            return Status::OK();\n+        }\n+    }\n+    return Status::OK();\n+}\n+\n+bool ExceptNode::equals(TupleRow* row, TupleRow* other) {\n+    if (row == nullptr && other == nullptr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NDYzMw=="}, "originalCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI0NDY0Mg==", "bodyText": "this for a safe guard\n\nI think kaisen means this if (row == nullptr && other == nullptr) clause is meaningless because you write another if (row == nullptr || other == nullptr) below.", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392244642", "createdAt": "2020-03-13T13:59:47Z", "author": {"login": "morningman"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +41,190 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_timer = ADD_TIMER(runtime_profile(), \"BuildTime\");\n+    _probe_timer = ADD_TIMER(runtime_profile(), \"ProbeTime\");\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_build_tuple_size, true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table, use _child_expr_lists[0] as probe is used for remove duplicted\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[0], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        SCOPED_TIMER(_build_timer);\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        // build hash table and remvoe duplicate items\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert_unique(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // rebuid hash table, for first time will rebuild with the no duplicated _hash_tbl,\n+        if (i > 1) {\n+            SCOPED_TIMER(_build_timer);\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        ScopedTimer<MonotonicStopWatch> probe_timer(_probe_timer);\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    TupleRow* previous_row = nullptr;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (!_hash_tbl_iterator.matched()) {\n+            if (previous_hash != _hash_tbl_iterator.get_hash() ||\n+                !equals(previous_row, _hash_tbl_iterator.get_row())) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+                ++_num_rows_returned;\n+            }\n+        }\n+        previous_hash = _hash_tbl_iterator.get_hash();\n+        previous_row = _hash_tbl_iterator.get_row();\n+        _hash_tbl_iterator.next<false>();\n+\n+        *eos = !_hash_tbl_iterator.has_next() || reached_limit();\n+        if (out_batch->is_full() || out_batch->at_resource_limit() || *eos) {\n+            return Status::OK();\n+        }\n+    }\n+    return Status::OK();\n+}\n+\n+bool ExceptNode::equals(TupleRow* row, TupleRow* other) {\n+    if (row == nullptr && other == nullptr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NDYzMw=="}, "originalCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDY4MDE1OnYy", "diffSide": "RIGHT", "path": "be/src/exec/except_node.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTo1OTo0OFrOF2BIGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMTo1ODoyNVrOF3Lczg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NTg4MA==", "bodyText": "why continue?", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392185880", "createdAt": "2020-03-13T11:59:48Z", "author": {"login": "kangkaisen"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +41,190 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_timer = ADD_TIMER(runtime_profile(), \"BuildTime\");\n+    _probe_timer = ADD_TIMER(runtime_profile(), \"ProbeTime\");\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_build_tuple_size, true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table, use _child_expr_lists[0] as probe is used for remove duplicted\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[0], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        SCOPED_TIMER(_build_timer);\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        // build hash table and remvoe duplicate items\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert_unique(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // rebuid hash table, for first time will rebuild with the no duplicated _hash_tbl,\n+        if (i > 1) {\n+            SCOPED_TIMER(_build_timer);\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        ScopedTimer<MonotonicStopWatch> probe_timer(_probe_timer);\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    TupleRow* previous_row = nullptr;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (!_hash_tbl_iterator.matched()) {\n+            if (previous_hash != _hash_tbl_iterator.get_hash() ||\n+                !equals(previous_row, _hash_tbl_iterator.get_row())) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+                ++_num_rows_returned;\n+            }\n+        }\n+        previous_hash = _hash_tbl_iterator.get_hash();\n+        previous_row = _hash_tbl_iterator.get_row();\n+        _hash_tbl_iterator.next<false>();\n+\n+        *eos = !_hash_tbl_iterator.has_next() || reached_limit();\n+        if (out_batch->is_full() || out_batch->at_resource_limit() || *eos) {\n+            return Status::OK();\n+        }\n+    }\n+    return Status::OK();\n+}\n+\n+bool ExceptNode::equals(TupleRow* row, TupleRow* other) {\n+    if (row == nullptr && other == nullptr) {\n+        return false;\n+    }\n+    if (row == nullptr || other == nullptr) {\n+        return false;\n+    }\n+    for (int i = 0; i < _child_expr_lists[0].size(); ++i) {\n+        void* val_row = _child_expr_lists[0][i]->get_value(row);\n+        void* val_other = _child_expr_lists[0][i]->get_value(other);\n+        if (val_row == nullptr && val_other == nullptr) {\n+            continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIwMzE1NQ==", "bodyText": "for nullable value when is null", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392203155", "createdAt": "2020-03-13T12:41:28Z", "author": {"login": "yangzhg"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +41,190 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_timer = ADD_TIMER(runtime_profile(), \"BuildTime\");\n+    _probe_timer = ADD_TIMER(runtime_profile(), \"ProbeTime\");\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_build_tuple_size, true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table, use _child_expr_lists[0] as probe is used for remove duplicted\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[0], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        SCOPED_TIMER(_build_timer);\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        // build hash table and remvoe duplicate items\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert_unique(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // rebuid hash table, for first time will rebuild with the no duplicated _hash_tbl,\n+        if (i > 1) {\n+            SCOPED_TIMER(_build_timer);\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        ScopedTimer<MonotonicStopWatch> probe_timer(_probe_timer);\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    TupleRow* previous_row = nullptr;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (!_hash_tbl_iterator.matched()) {\n+            if (previous_hash != _hash_tbl_iterator.get_hash() ||\n+                !equals(previous_row, _hash_tbl_iterator.get_row())) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+                ++_num_rows_returned;\n+            }\n+        }\n+        previous_hash = _hash_tbl_iterator.get_hash();\n+        previous_row = _hash_tbl_iterator.get_row();\n+        _hash_tbl_iterator.next<false>();\n+\n+        *eos = !_hash_tbl_iterator.has_next() || reached_limit();\n+        if (out_batch->is_full() || out_batch->at_resource_limit() || *eos) {\n+            return Status::OK();\n+        }\n+    }\n+    return Status::OK();\n+}\n+\n+bool ExceptNode::equals(TupleRow* row, TupleRow* other) {\n+    if (row == nullptr && other == nullptr) {\n+        return false;\n+    }\n+    if (row == nullptr || other == nullptr) {\n+        return false;\n+    }\n+    for (int i = 0; i < _child_expr_lists[0].size(); ++i) {\n+        void* val_row = _child_expr_lists[0][i]->get_value(row);\n+        void* val_other = _child_expr_lists[0][i]->get_value(other);\n+        if (val_row == nullptr && val_other == nullptr) {\n+            continue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NTg4MA=="}, "originalCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIwOTIwNA==", "bodyText": "If _child_expr_lists[0].size is 1. ExceptNode::equals will return true. which is your expectation \uff1f which should be conflicting with else if (val_row == nullptr || val_other == nullptr) { return false;", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392209204", "createdAt": "2020-03-13T12:54:38Z", "author": {"login": "kangkaisen"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +41,190 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_timer = ADD_TIMER(runtime_profile(), \"BuildTime\");\n+    _probe_timer = ADD_TIMER(runtime_profile(), \"ProbeTime\");\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_build_tuple_size, true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table, use _child_expr_lists[0] as probe is used for remove duplicted\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[0], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        SCOPED_TIMER(_build_timer);\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        // build hash table and remvoe duplicate items\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert_unique(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // rebuid hash table, for first time will rebuild with the no duplicated _hash_tbl,\n+        if (i > 1) {\n+            SCOPED_TIMER(_build_timer);\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        ScopedTimer<MonotonicStopWatch> probe_timer(_probe_timer);\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    TupleRow* previous_row = nullptr;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (!_hash_tbl_iterator.matched()) {\n+            if (previous_hash != _hash_tbl_iterator.get_hash() ||\n+                !equals(previous_row, _hash_tbl_iterator.get_row())) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+                ++_num_rows_returned;\n+            }\n+        }\n+        previous_hash = _hash_tbl_iterator.get_hash();\n+        previous_row = _hash_tbl_iterator.get_row();\n+        _hash_tbl_iterator.next<false>();\n+\n+        *eos = !_hash_tbl_iterator.has_next() || reached_limit();\n+        if (out_batch->is_full() || out_batch->at_resource_limit() || *eos) {\n+            return Status::OK();\n+        }\n+    }\n+    return Status::OK();\n+}\n+\n+bool ExceptNode::equals(TupleRow* row, TupleRow* other) {\n+    if (row == nullptr && other == nullptr) {\n+        return false;\n+    }\n+    if (row == nullptr || other == nullptr) {\n+        return false;\n+    }\n+    for (int i = 0; i < _child_expr_lists[0].size(); ++i) {\n+        void* val_row = _child_expr_lists[0][i]->get_value(row);\n+        void* val_other = _child_expr_lists[0][i]->get_value(other);\n+        if (val_row == nullptr && val_other == nullptr) {\n+            continue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NTg4MA=="}, "originalCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQwMzU5OA==", "bodyText": "if table a is\nc1\n---\nnull\n\ntable b is\nc2\n---\nnull\n\nif caluse is\nselect c1 from a except select c2 from b \nwill hit val_row == nullptr && val_other == nullptr\nnull and null is equal", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r393403598", "createdAt": "2020-03-17T01:58:25Z", "author": {"login": "yangzhg"}, "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +41,190 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_timer = ADD_TIMER(runtime_profile(), \"BuildTime\");\n+    _probe_timer = ADD_TIMER(runtime_profile(), \"ProbeTime\");\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_build_tuple_size, true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table, use _child_expr_lists[0] as probe is used for remove duplicted\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[0], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        SCOPED_TIMER(_build_timer);\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        // build hash table and remvoe duplicate items\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert_unique(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // rebuid hash table, for first time will rebuild with the no duplicated _hash_tbl,\n+        if (i > 1) {\n+            SCOPED_TIMER(_build_timer);\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        ScopedTimer<MonotonicStopWatch> probe_timer(_probe_timer);\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    TupleRow* previous_row = nullptr;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (!_hash_tbl_iterator.matched()) {\n+            if (previous_hash != _hash_tbl_iterator.get_hash() ||\n+                !equals(previous_row, _hash_tbl_iterator.get_row())) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+                ++_num_rows_returned;\n+            }\n+        }\n+        previous_hash = _hash_tbl_iterator.get_hash();\n+        previous_row = _hash_tbl_iterator.get_row();\n+        _hash_tbl_iterator.next<false>();\n+\n+        *eos = !_hash_tbl_iterator.has_next() || reached_limit();\n+        if (out_batch->is_full() || out_batch->at_resource_limit() || *eos) {\n+            return Status::OK();\n+        }\n+    }\n+    return Status::OK();\n+}\n+\n+bool ExceptNode::equals(TupleRow* row, TupleRow* other) {\n+    if (row == nullptr && other == nullptr) {\n+        return false;\n+    }\n+    if (row == nullptr || other == nullptr) {\n+        return false;\n+    }\n+    for (int i = 0; i < _child_expr_lists[0].size(); ++i) {\n+        void* val_row = _child_expr_lists[0][i]->get_value(row);\n+        void* val_other = _child_expr_lists[0][i]->get_value(other);\n+        if (val_row == nullptr && val_other == nullptr) {\n+            continue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NTg4MA=="}, "originalCommit": {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225"}, "originalPosition": 225}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2084, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}