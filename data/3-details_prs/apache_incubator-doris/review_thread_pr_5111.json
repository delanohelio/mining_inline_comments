{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQzODQyOTIx", "number": 5111, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQxMDoyMTo1OVrOFJI0Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNlQwNToxNToxOVrOFJN3pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1MTI1OTAyOnYy", "diffSide": "RIGHT", "path": "be/src/exec/olap_scan_node.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQxMDoyMTo1OVrOILbNIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQxMDoyMTo1OVrOILbNIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg1MDk3Ng==", "bodyText": "Is it better to use C++11 promise and future to instead of checking _running_thread == 0? every scanner_thread just need to set its promise value when finish task with lock free, and close OlapScanNode close just need to wait all scanner_thread return future result ?", "url": "https://github.com/apache/incubator-doris/pull/5111#discussion_r548850976", "createdAt": "2020-12-25T10:21:59Z", "author": {"login": "caiconghui"}, "path": "be/src/exec/olap_scan_node.cpp", "diffHunk": "@@ -1250,12 +1250,25 @@ void OlapScanNode::transfer_thread(RuntimeState* state) {\n \n     state->resource_pool()->release_thread_token(true);\n     VLOG(1) << \"TransferThread finish.\";\n-    std::unique_lock<std::mutex> l(_row_batches_lock);\n-    _transfer_done = true;\n+    {\n+        std::unique_lock<std::mutex> l(_row_batches_lock);\n+        _transfer_done = true;\n+    }\n     _row_batch_added_cv.notify_all();\n+\n+    std::unique_lock<std::mutex> l(_scan_batches_lock);\n+    while (_running_thread != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7f052d460a6519278af1d876c46382a46a78ea8"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1MjA4NzQxOnYy", "diffSide": "RIGHT", "path": "be/src/exec/olap_scan_node.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNlQwNToxNToxOVrOILg77w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNlQwNjowOToxNlrOILhLQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODk0NDg3OQ==", "bodyText": "Is it elegant to use sleep to do multithread sync? why not use a cv to wait here, and nofity after _running_thread--?", "url": "https://github.com/apache/incubator-doris/pull/5111#discussion_r548944879", "createdAt": "2020-12-26T05:15:19Z", "author": {"login": "acelyc111"}, "path": "be/src/exec/olap_scan_node.cpp", "diffHunk": "@@ -1250,12 +1250,25 @@ void OlapScanNode::transfer_thread(RuntimeState* state) {\n \n     state->resource_pool()->release_thread_token(true);\n     VLOG(1) << \"TransferThread finish.\";\n-    std::unique_lock<std::mutex> l(_row_batches_lock);\n-    _transfer_done = true;\n+    {\n+        std::unique_lock<std::mutex> l(_row_batches_lock);\n+        _transfer_done = true;\n+    }\n     _row_batch_added_cv.notify_all();\n+\n+    std::unique_lock<std::mutex> l(_scan_batches_lock);\n+    while (_running_thread != 0) {\n+        l.unlock();\n+        SleepFor(MonoDelta::FromMilliseconds(5));\n+        l.lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7f052d460a6519278af1d876c46382a46a78ea8"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODk0ODgwMA==", "bodyText": "I don't want use _scan_batch_added_cv, it's hard to understand the relationship between _scan_batch_added_cv & _running_thread . I'll add a new condition variable.", "url": "https://github.com/apache/incubator-doris/pull/5111#discussion_r548948800", "createdAt": "2020-12-26T06:09:16Z", "author": {"login": "vagetablechicken"}, "path": "be/src/exec/olap_scan_node.cpp", "diffHunk": "@@ -1250,12 +1250,25 @@ void OlapScanNode::transfer_thread(RuntimeState* state) {\n \n     state->resource_pool()->release_thread_token(true);\n     VLOG(1) << \"TransferThread finish.\";\n-    std::unique_lock<std::mutex> l(_row_batches_lock);\n-    _transfer_done = true;\n+    {\n+        std::unique_lock<std::mutex> l(_row_batches_lock);\n+        _transfer_done = true;\n+    }\n     _row_batch_added_cv.notify_all();\n+\n+    std::unique_lock<std::mutex> l(_scan_batches_lock);\n+    while (_running_thread != 0) {\n+        l.unlock();\n+        SleepFor(MonoDelta::FromMilliseconds(5));\n+        l.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODk0NDg3OQ=="}, "originalCommit": {"oid": "f7f052d460a6519278af1d876c46382a46a78ea8"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 827, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}