{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwNDIyOTg3", "number": 2710, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjoxNjozMFrODWhj4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjoyNDoyM1rODWv8Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0OTQ1MTIwOnYy", "diffSide": "RIGHT", "path": "be/src/util/mem_info.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjoxNjozMFrOFbVLIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjoxNjozMFrOFbVLIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwMjc4NA==", "bodyText": "there may be tab", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364202784", "createdAt": "2020-01-08T12:16:30Z", "author": {"login": "imay"}, "path": "be/src/util/mem_info.cpp", "diffHunk": "@@ -59,6 +60,11 @@ void MemInfo::init() {\n         if (result == StringParser::PARSE_SUCCESS) {\n             // Entries in /proc/meminfo are in KB.\n             _s_physical_mem = mem_total_kb * 1024L;\n+\t    int64_t cgroup_mem_limit;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60560dc675c0e62c5e203ad43c91d6530675b27d"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0OTQ1NTY0OnYy", "diffSide": "RIGHT", "path": "be/src/util/cgroup_util.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjoxODozMFrOFbVNyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjoxODozMFrOFbVNyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwMzQ2Ng==", "bodyText": "You can try split in gutil which is easier to use", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364203466", "createdAt": "2020-01-08T12:18:30Z", "author": {"login": "imay"}, "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/filesystem.hpp>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"util/error_util.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using boost::algorithm::is_any_of;\n+using boost::algorithm::split;\n+using boost::algorithm::token_compress_on;\n+using strings::CUnescape;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\":\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60560dc675c0e62c5e203ad43c91d6530675b27d"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0OTQ1NzcyOnYy", "diffSide": "RIGHT", "path": "be/src/util/cgroup_util.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjoxOTozM1rOFbVPGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjoxOTozM1rOFbVPGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwMzgwMw==", "bodyText": "give some comments for this function? What does it do", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364203803", "createdAt": "2020-01-08T12:19:33Z", "author": {"login": "imay"}, "path": "be/src/util/cgroup_util.h", "diffHunk": "@@ -0,0 +1,62 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H\n+#define DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H\n+#include <cstdint>\n+#include <string>\n+#include <utility>\n+\n+#include \"common/status.h\"\n+namespace doris {\n+class CGroupUtil {\n+  public:\n+    // Determines the CGroup memory limit from the current processes' cgroup.\n+    // If the limit is more than INT64_MAX, INT64_MAX is returned (since that is\n+    // effectively unlimited anyway). Does not take into account memory limits\n+    // set on any ancestor CGroups.\n+    static Status find_cgroup_mem_limit(int64_t* bytes);\n+\n+    // Determines the CGroup cpu cores limit from the current processes' cgroup.\n+    static Status find_cgroup_cpu_limit(float* cpu_count);\n+\n+    // Returns a human-readable string with information about CGroups.\n+    static std::string debug_string();\n+\n+    // detect if cgroup is enabled\n+    static bool enable();\n+\n+  private:\n+    static Status find_global_cgroup(const std::string& subsystem, std::string* path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60560dc675c0e62c5e203ad43c91d6530675b27d"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0OTQ3Mzk3OnYy", "diffSide": "RIGHT", "path": "be/src/util/cgroup_util.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjoyNjoxN1rOFbVYcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwMTo1MTo1MFrOFbpArQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwNjE5Mg==", "bodyText": "Is this file written by yourself? If it is not, is it OK to use this license?", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364206192", "createdAt": "2020-01-08T12:26:17Z", "author": {"login": "imay"}, "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60560dc675c0e62c5e203ad43c91d6530675b27d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUyNzc4OQ==", "bodyText": "some functions from impala", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364527789", "createdAt": "2020-01-09T01:51:50Z", "author": {"login": "yangzhg"}, "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwNjE5Mg=="}, "originalCommit": {"oid": "60560dc675c0e62c5e203ad43c91d6530675b27d"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0OTQ3OTAwOnYy", "diffSide": "RIGHT", "path": "be/src/util/cgroup_util.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjoyODoxOFrOFbVbVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwMTo1ODowMFrOFbpFag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwNjkzMw==", "bodyText": "!= 3?", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364206933", "createdAt": "2020-01-08T12:28:18Z", "author": {"login": "imay"}, "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/filesystem.hpp>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"util/error_util.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using boost::algorithm::is_any_of;\n+using boost::algorithm::split;\n+using boost::algorithm::token_compress_on;\n+using strings::CUnescape;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\":\"));\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() > 3) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60560dc675c0e62c5e203ad43c91d6530675b27d"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUyOTAwMg==", "bodyText": "line formate like 4:memory:/user.slice split by :, so size  is 3", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364529002", "createdAt": "2020-01-09T01:58:00Z", "author": {"login": "yangzhg"}, "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/filesystem.hpp>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"util/error_util.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using boost::algorithm::is_any_of;\n+using boost::algorithm::split;\n+using boost::algorithm::token_compress_on;\n+using strings::CUnescape;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\":\"));\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() > 3) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwNjkzMw=="}, "originalCommit": {"oid": "60560dc675c0e62c5e203ad43c91d6530675b27d"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0OTQ4MjYwOnYy", "diffSide": "RIGHT", "path": "be/src/util/cgroup_util.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjozMDowNFrOFbVdog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjozMDowNFrOFbVdog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwNzUyMg==", "bodyText": "better to use FileUtils", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364207522", "createdAt": "2020-01-08T12:30:04Z", "author": {"login": "imay"}, "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/filesystem.hpp>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"util/error_util.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using boost::algorithm::is_any_of;\n+using boost::algorithm::split;\n+using boost::algorithm::token_compress_on;\n+using strings::CUnescape;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\":\"));\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() > 3) {\n+            return Status::InvalidArgument(Substitute(\n+                                               \"Could not parse line from /proc/self/cgroup - had $0 > 3 tokens: '$1'\",\n+                                               fields.size(), line));\n+        }\n+        vector<string> subsystems;\n+        split(subsystems, fields[1], is_any_of(\",\"));\n+        auto it = std::find(subsystems.begin(), subsystems.end(), subsystem);\n+        if (it != subsystems.end()) {\n+            *path = move(fields[2]);\n+            return Status::OK();\n+        }\n+    }\n+}\n+\n+static Status unescape_path(const string& escaped, string* unescaped) {\n+    string err;\n+    if (!CUnescape(escaped, unescaped, &err)) {\n+        return Status::InvalidArgument(Substitute(\"Could not unescape path '$0': $1\", escaped, err));\n+    }\n+    return Status::OK();\n+}\n+\n+static Status read_cgroup_value(const string &limit_file_path, int64_t* val) {\n+    ifstream limit_file(limit_file_path, ios::in);\n+    string line;\n+    getline(limit_file, line);\n+    if (limit_file.fail() || limit_file.bad()) {\n+        return Status::IOError(Substitute(\"Error reading $0: $1\", limit_file_path, get_str_err_msg()));\n+    }\n+    StringParser::ParseResult pr;\n+    // Parse into an an int64_t If it overflows, returning the max value of int64_t is ok because that\n+    // is effectively unlimited.\n+    *val = StringParser::string_to_int<int64_t>(line.c_str(), line.size(), &pr);\n+    if ((pr != StringParser::PARSE_SUCCESS && pr != StringParser::PARSE_OVERFLOW)) {\n+        return Status::InvalidArgument(\n+                   Substitute(\"Failed to parse $0 as int64: '$1'\", limit_file_path, line));\n+    }\n+    return Status::OK();\n+}\n+\n+Status CGroupUtil::find_cgroup_mounts(\n+    const string& subsystem, pair<string, string>* result) {\n+    ifstream mountinfo(\"/proc/self/mountinfo\", ios::in);\n+    string line;\n+    while (true) {\n+        if (mountinfo.fail() || mountinfo.bad()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/mountinfo: $0\", get_str_err_msg()));\n+        } else if (mountinfo.eof()) {\n+            return Status::NotFound(\n+                       Substitute(\"Could not find subsystem $0 in /proc/self/mountinfo\", subsystem));\n+        }\n+        // The relevant lines look like below (see proc manpage for full documentation). The\n+        // first example is running outside of a container, the second example is running\n+        // inside a docker container. Field 3 is the path relative to the root CGroup on\n+        // the host and Field 4 is the mount point from this process's point of view.\n+        // 34 29 0:28 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:15 -\n+        //    cgroup cgroup rw,memory\n+        // 275 271 0:28 /docker/f23eee6f88c2ba99fcce /sys/fs/cgroup/memory\n+        //    ro,nosuid,nodev,noexec,relatime master:15 - cgroup cgroup rw,memory\n+        getline(mountinfo, line);\n+        if (!mountinfo.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\" \"), token_compress_on);\n+        DCHECK_GE(fields.size(), 7);\n+\n+        if (fields[fields.size() - 3] != \"cgroup\") continue;\n+        // This is a cgroup mount. Check if it's the mount we're looking for.\n+        vector<string> cgroup_opts;\n+        split(cgroup_opts, fields[fields.size() - 1], is_any_of(\",\"), token_compress_on);\n+        auto it = std::find(cgroup_opts.begin(), cgroup_opts.end(), subsystem);\n+        if (it == cgroup_opts.end()) continue;\n+        // This is the right mount.\n+        string mount_path, system_path;\n+        RETURN_IF_ERROR(unescape_path(fields[4], &mount_path));\n+        RETURN_IF_ERROR(unescape_path(fields[3], &system_path));\n+        // Strip trailing \"/\" so that both returned paths match in whether they have a\n+        // trailing \"/\".\n+        if (system_path[system_path.size() - 1] == '/') system_path.pop_back();\n+        *result = {mount_path, system_path};\n+        return Status::OK();\n+    }\n+}\n+\n+Status CGroupUtil::find_abs_cgroup_path(const string& subsystem, string* path) {\n+    RETURN_IF_ERROR(find_global_cgroup(subsystem, path));\n+    pair<string, string> paths;\n+    RETURN_IF_ERROR(find_cgroup_mounts(subsystem, &paths));\n+    const string& mount_path = paths.first;\n+    const string& system_path = paths.second;\n+    if (path->compare(0, system_path.size(), system_path) != 0) {\n+        return Status::InvalidArgument(\n+                   Substitute(\"Expected CGroup path '$0' to start with '$1'\",\n+                              *path, system_path));\n+    }\n+    path->replace(0, system_path.size(), mount_path);\n+    return Status::OK();\n+}\n+\n+Status CGroupUtil::find_cgroup_mem_limit(int64_t* bytes) {\n+    if (!enable()) {\n+        *bytes = INT64_MAX;\n+        return Status::InvalidArgument(\"cgroup is not enabled!\");\n+    }\n+    string cgroup_path;\n+    RETURN_IF_ERROR(find_abs_cgroup_path(\"memory\", &cgroup_path));\n+    string limit_file_path = cgroup_path + \"/memory.limit_in_bytes\";\n+    return read_cgroup_value(limit_file_path, bytes);\n+}\n+Status CGroupUtil::find_cgroup_cpu_limit(float* cpu_count) {\n+    if (!enable()) {\n+        *cpu_count = FLT_MAX;\n+        return Status::InvalidArgument(\"cgroup is not enabled!\");\n+    }\n+    int64_t quota;\n+    int64_t period;\n+    string cgroup_path;\n+    if (!find_abs_cgroup_path(\"cpu\", &cgroup_path).ok()) {\n+        RETURN_IF_ERROR(find_abs_cgroup_path(\"cpuacct\", &cgroup_path));\n+    }\n+    string cfs_quota_filename = cgroup_path + \"/cpu.cfs_quota_us\";\n+    RETURN_IF_ERROR(read_cgroup_value(cfs_quota_filename, &quota));\n+    if (quota <= 0) {\n+        *cpu_count = -1;\n+        return Status::OK();\n+    }\n+    string cfs_period_filename = cgroup_path + \"/cfs_period_us\";\n+    RETURN_IF_ERROR(read_cgroup_value(cfs_period_filename, &period));\n+    if (quota <= period) {\n+        *cpu_count = -1;\n+        return Status::InvalidArgument(\"quota <= period\");\n+    }\n+    *cpu_count = float(quota) / float(period);\n+    if (*cpu_count >= FLT_MAX) {\n+        *cpu_count = -1;\n+        return Status::InvalidArgument(\"unknown\");\n+    }\n+    return Status::OK();\n+}\n+\n+std::string CGroupUtil::debug_string() {\n+    if (!enable()) {\n+        return std::string(\"cgroup is not enabled!\");\n+    }\n+    string mem_limit_str;\n+    int64_t mem_limit;\n+    Status status = find_cgroup_mem_limit(&mem_limit);\n+    if (status.ok()) {\n+        mem_limit_str = Substitute(\"$0\", mem_limit);\n+    } else {\n+        mem_limit_str = status.get_error_msg();\n+    }\n+    string cpu_limit_str;\n+    float cpu_limit;\n+    status = find_cgroup_cpu_limit(&cpu_limit);\n+    if (status.ok()) {\n+        if (cpu_limit >0) {\n+            std::stringstream stream;\n+            stream << std::fixed << std::setprecision(1) << cpu_limit;\n+            cpu_limit_str = stream.str();\n+        } else {\n+            cpu_limit_str = \"unlimited\";\n+        }\n+    } else {\n+        cpu_limit_str = status.get_error_msg();\n+    }\n+    return Substitute(\"Process CGroup Info: memory.limit_in_bytes=$0, cpu cfs limits: $1\", mem_limit_str, cpu_limit_str);\n+}\n+\n+bool CGroupUtil::enable() {\n+    return boost::filesystem::exists(\"/proc/cgroups\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60560dc675c0e62c5e203ad43c91d6530675b27d"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0OTQ5NjMwOnYy", "diffSide": "RIGHT", "path": "be/src/util/cgroup_util.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjozNjoxMVrOFbVl2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjozNjoxMVrOFbVl2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwOTYyNw==", "bodyText": "If return error, why do you change the return value?", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364209627", "createdAt": "2020-01-08T12:36:11Z", "author": {"login": "imay"}, "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/filesystem.hpp>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"util/error_util.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using boost::algorithm::is_any_of;\n+using boost::algorithm::split;\n+using boost::algorithm::token_compress_on;\n+using strings::CUnescape;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\":\"));\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() > 3) {\n+            return Status::InvalidArgument(Substitute(\n+                                               \"Could not parse line from /proc/self/cgroup - had $0 > 3 tokens: '$1'\",\n+                                               fields.size(), line));\n+        }\n+        vector<string> subsystems;\n+        split(subsystems, fields[1], is_any_of(\",\"));\n+        auto it = std::find(subsystems.begin(), subsystems.end(), subsystem);\n+        if (it != subsystems.end()) {\n+            *path = move(fields[2]);\n+            return Status::OK();\n+        }\n+    }\n+}\n+\n+static Status unescape_path(const string& escaped, string* unescaped) {\n+    string err;\n+    if (!CUnescape(escaped, unescaped, &err)) {\n+        return Status::InvalidArgument(Substitute(\"Could not unescape path '$0': $1\", escaped, err));\n+    }\n+    return Status::OK();\n+}\n+\n+static Status read_cgroup_value(const string &limit_file_path, int64_t* val) {\n+    ifstream limit_file(limit_file_path, ios::in);\n+    string line;\n+    getline(limit_file, line);\n+    if (limit_file.fail() || limit_file.bad()) {\n+        return Status::IOError(Substitute(\"Error reading $0: $1\", limit_file_path, get_str_err_msg()));\n+    }\n+    StringParser::ParseResult pr;\n+    // Parse into an an int64_t If it overflows, returning the max value of int64_t is ok because that\n+    // is effectively unlimited.\n+    *val = StringParser::string_to_int<int64_t>(line.c_str(), line.size(), &pr);\n+    if ((pr != StringParser::PARSE_SUCCESS && pr != StringParser::PARSE_OVERFLOW)) {\n+        return Status::InvalidArgument(\n+                   Substitute(\"Failed to parse $0 as int64: '$1'\", limit_file_path, line));\n+    }\n+    return Status::OK();\n+}\n+\n+Status CGroupUtil::find_cgroup_mounts(\n+    const string& subsystem, pair<string, string>* result) {\n+    ifstream mountinfo(\"/proc/self/mountinfo\", ios::in);\n+    string line;\n+    while (true) {\n+        if (mountinfo.fail() || mountinfo.bad()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/mountinfo: $0\", get_str_err_msg()));\n+        } else if (mountinfo.eof()) {\n+            return Status::NotFound(\n+                       Substitute(\"Could not find subsystem $0 in /proc/self/mountinfo\", subsystem));\n+        }\n+        // The relevant lines look like below (see proc manpage for full documentation). The\n+        // first example is running outside of a container, the second example is running\n+        // inside a docker container. Field 3 is the path relative to the root CGroup on\n+        // the host and Field 4 is the mount point from this process's point of view.\n+        // 34 29 0:28 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:15 -\n+        //    cgroup cgroup rw,memory\n+        // 275 271 0:28 /docker/f23eee6f88c2ba99fcce /sys/fs/cgroup/memory\n+        //    ro,nosuid,nodev,noexec,relatime master:15 - cgroup cgroup rw,memory\n+        getline(mountinfo, line);\n+        if (!mountinfo.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\" \"), token_compress_on);\n+        DCHECK_GE(fields.size(), 7);\n+\n+        if (fields[fields.size() - 3] != \"cgroup\") continue;\n+        // This is a cgroup mount. Check if it's the mount we're looking for.\n+        vector<string> cgroup_opts;\n+        split(cgroup_opts, fields[fields.size() - 1], is_any_of(\",\"), token_compress_on);\n+        auto it = std::find(cgroup_opts.begin(), cgroup_opts.end(), subsystem);\n+        if (it == cgroup_opts.end()) continue;\n+        // This is the right mount.\n+        string mount_path, system_path;\n+        RETURN_IF_ERROR(unescape_path(fields[4], &mount_path));\n+        RETURN_IF_ERROR(unescape_path(fields[3], &system_path));\n+        // Strip trailing \"/\" so that both returned paths match in whether they have a\n+        // trailing \"/\".\n+        if (system_path[system_path.size() - 1] == '/') system_path.pop_back();\n+        *result = {mount_path, system_path};\n+        return Status::OK();\n+    }\n+}\n+\n+Status CGroupUtil::find_abs_cgroup_path(const string& subsystem, string* path) {\n+    RETURN_IF_ERROR(find_global_cgroup(subsystem, path));\n+    pair<string, string> paths;\n+    RETURN_IF_ERROR(find_cgroup_mounts(subsystem, &paths));\n+    const string& mount_path = paths.first;\n+    const string& system_path = paths.second;\n+    if (path->compare(0, system_path.size(), system_path) != 0) {\n+        return Status::InvalidArgument(\n+                   Substitute(\"Expected CGroup path '$0' to start with '$1'\",\n+                              *path, system_path));\n+    }\n+    path->replace(0, system_path.size(), mount_path);\n+    return Status::OK();\n+}\n+\n+Status CGroupUtil::find_cgroup_mem_limit(int64_t* bytes) {\n+    if (!enable()) {\n+        *bytes = INT64_MAX;\n+        return Status::InvalidArgument(\"cgroup is not enabled!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60560dc675c0e62c5e203ad43c91d6530675b27d"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0OTQ5NzI5OnYy", "diffSide": "RIGHT", "path": "be/src/util/cgroup_util.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjozNjo0M1rOFbVmiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMjozNjo0M1rOFbVmiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwOTgwMQ==", "bodyText": "give some comments for this function.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            static Status read_cgroup_value(const string &limit_file_path, int64_t* val) {\n          \n          \n            \n            static Status read_cgroup_value(const string& limit_file_path, int64_t* val) {", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364209801", "createdAt": "2020-01-08T12:36:43Z", "author": {"login": "imay"}, "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/filesystem.hpp>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"util/error_util.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using boost::algorithm::is_any_of;\n+using boost::algorithm::split;\n+using boost::algorithm::token_compress_on;\n+using strings::CUnescape;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\":\"));\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() > 3) {\n+            return Status::InvalidArgument(Substitute(\n+                                               \"Could not parse line from /proc/self/cgroup - had $0 > 3 tokens: '$1'\",\n+                                               fields.size(), line));\n+        }\n+        vector<string> subsystems;\n+        split(subsystems, fields[1], is_any_of(\",\"));\n+        auto it = std::find(subsystems.begin(), subsystems.end(), subsystem);\n+        if (it != subsystems.end()) {\n+            *path = move(fields[2]);\n+            return Status::OK();\n+        }\n+    }\n+}\n+\n+static Status unescape_path(const string& escaped, string* unescaped) {\n+    string err;\n+    if (!CUnescape(escaped, unescaped, &err)) {\n+        return Status::InvalidArgument(Substitute(\"Could not unescape path '$0': $1\", escaped, err));\n+    }\n+    return Status::OK();\n+}\n+\n+static Status read_cgroup_value(const string &limit_file_path, int64_t* val) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60560dc675c0e62c5e203ad43c91d6530675b27d"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTc4MTU1OnYy", "diffSide": "RIGHT", "path": "be/src/util/cgroup_util.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjowNDoyOVrOFbrqKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjowNDoyOVrOFbrqKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MTE3OA==", "bodyText": "Better to remove this, because we should not assert the input content.", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364571178", "createdAt": "2020-01-09T06:04:29Z", "author": {"login": "imay"}, "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"gutil/strings/split.h\"\n+#include \"util/error_util.h\"\n+#include \"util/file_utils.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using strings::CUnescape;\n+using strings::Split;\n+using strings::SkipWhitespace;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        // so field size will be 3\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) {\n+            continue;\n+        }\n+        vector<string> fields = Split(line, \":\");\n+        DCHECK_GE(fields.size(), 3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4822cd6314dcb212a840ea32b4316815517fe4c9"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTc5NTM4OnYy", "diffSide": "RIGHT", "path": "be/src/util/cgroup_util.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjoxNToxN1rOFbrypA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjoxNToxN1rOFbrypA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MzM0OA==", "bodyText": "No DCHECK", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364573348", "createdAt": "2020-01-09T06:15:17Z", "author": {"login": "imay"}, "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"gutil/strings/split.h\"\n+#include \"util/error_util.h\"\n+#include \"util/file_utils.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using strings::CUnescape;\n+using strings::Split;\n+using strings::SkipWhitespace;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        // so field size will be 3\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) {\n+            continue;\n+        }\n+        vector<string> fields = Split(line, \":\");\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() != 3) {\n+            return Status::InvalidArgument(Substitute(\n+                                               \"Could not parse line from /proc/self/cgroup - had $0 > 3 tokens: '$1'\",\n+                                               fields.size(), line));\n+        }\n+        vector<string> subsystems = Split(fields[1], \",\");\n+        auto it = std::find(subsystems.begin(), subsystems.end(), subsystem);\n+        if (it != subsystems.end()) {\n+            *path = move(fields[2]);\n+            return Status::OK();\n+        }\n+    }\n+}\n+\n+static Status unescape_path(const string& escaped, string* unescaped) {\n+    string err;\n+    if (!CUnescape(escaped, unescaped, &err)) {\n+        return Status::InvalidArgument(Substitute(\"Could not unescape path '$0': $1\", escaped, err));\n+    }\n+    return Status::OK();\n+}\n+\n+static Status read_cgroup_value(const string& limit_file_path, int64_t* val) {\n+    ifstream limit_file(limit_file_path, ios::in);\n+    string line;\n+    getline(limit_file, line);\n+    if (limit_file.fail() || limit_file.bad()) {\n+        return Status::IOError(Substitute(\"Error reading $0: $1\", limit_file_path, get_str_err_msg()));\n+    }\n+    StringParser::ParseResult pr;\n+    // Parse into an an int64_t If it overflows, returning the max value of int64_t is ok because that\n+    // is effectively unlimited.\n+    *val = StringParser::string_to_int<int64_t>(line.c_str(), line.size(), &pr);\n+    if ((pr != StringParser::PARSE_SUCCESS && pr != StringParser::PARSE_OVERFLOW)) {\n+        return Status::InvalidArgument(\n+                   Substitute(\"Failed to parse $0 as int64: '$1'\", limit_file_path, line));\n+    }\n+    return Status::OK();\n+}\n+\n+Status CGroupUtil::find_cgroup_mounts(\n+    const string& subsystem, pair<string, string>* result) {\n+    ifstream mountinfo(\"/proc/self/mountinfo\", ios::in);\n+    string line;\n+    while (true) {\n+        if (mountinfo.fail() || mountinfo.bad()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/mountinfo: $0\", get_str_err_msg()));\n+        } else if (mountinfo.eof()) {\n+            return Status::NotFound(\n+                       Substitute(\"Could not find subsystem $0 in /proc/self/mountinfo\", subsystem));\n+        }\n+        // The relevant lines look like below (see proc manpage for full documentation). The\n+        // first example is running outside of a container, the second example is running\n+        // inside a docker container. Field 3 is the path relative to the root CGroup on\n+        // the host and Field 4 is the mount point from this process's point of view.\n+        // 34 29 0:28 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:15 -\n+        //    cgroup cgroup rw,memory\n+        // 275 271 0:28 /docker/f23eee6f88c2ba99fcce /sys/fs/cgroup/memory\n+        //    ro,nosuid,nodev,noexec,relatime master:15 - cgroup cgroup rw,memory\n+        getline(mountinfo, line);\n+        if (!mountinfo.good()) continue;\n+        vector<string> fields = Split(line, \" \", SkipWhitespace());\n+        DCHECK_GE(fields.size(), 7);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4822cd6314dcb212a840ea32b4316815517fe4c9"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTc5ODc1OnYy", "diffSide": "RIGHT", "path": "be/src/util/cgroup_util.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjoxNzo0NVrOFbr0ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjoxNzo0NVrOFbr0ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3Mzg4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public:\n          \n          \n            \n            public:", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364573882", "createdAt": "2020-01-09T06:17:45Z", "author": {"login": "imay"}, "path": "be/src/util/cgroup_util.h", "diffHunk": "@@ -0,0 +1,63 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H\n+#define DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H\n+#include <cstdint>\n+#include <string>\n+#include <utility>\n+\n+#include \"common/status.h\"\n+namespace doris {\n+class CGroupUtil {\n+  public:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4822cd6314dcb212a840ea32b4316815517fe4c9"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTc5OTM3OnYy", "diffSide": "RIGHT", "path": "be/src/util/cgroup_util.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjoxODowMVrOFbr1EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjoxODowMVrOFbr1EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3Mzk2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #define DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H\n          \n          \n            \n            #pragma once", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364573968", "createdAt": "2020-01-09T06:18:01Z", "author": {"login": "imay"}, "path": "be/src/util/cgroup_util.h", "diffHunk": "@@ -0,0 +1,63 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H\n+#define DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4822cd6314dcb212a840ea32b4316815517fe4c9"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTgwMzE2OnYy", "diffSide": "RIGHT", "path": "be/src/util/mem_info.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjoyMToxMFrOFbr3hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjoyMzoxM1rOFbr5QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3NDU5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        int64_t cgroup_mem_limit;\n          \n          \n            \n                        int64_t cgroup_mem_limit = 0;\n          \n      \n    \n    \n  \n\nbetter to give a default value", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364574598", "createdAt": "2020-01-09T06:21:10Z", "author": {"login": "imay"}, "path": "be/src/util/mem_info.cpp", "diffHunk": "@@ -59,6 +60,11 @@ void MemInfo::init() {\n         if (result == StringParser::PARSE_SUCCESS) {\n             // Entries in /proc/meminfo are in KB.\n             _s_physical_mem = mem_total_kb * 1024L;\n+            int64_t cgroup_mem_limit;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4822cd6314dcb212a840ea32b4316815517fe4c9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3NTA0MQ==", "bodyText": "seems better to move this out of while block.", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364575041", "createdAt": "2020-01-09T06:23:13Z", "author": {"login": "imay"}, "path": "be/src/util/mem_info.cpp", "diffHunk": "@@ -59,6 +60,11 @@ void MemInfo::init() {\n         if (result == StringParser::PARSE_SUCCESS) {\n             // Entries in /proc/meminfo are in KB.\n             _s_physical_mem = mem_total_kb * 1024L;\n+            int64_t cgroup_mem_limit;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3NDU5OA=="}, "originalCommit": {"oid": "4822cd6314dcb212a840ea32b4316815517fe4c9"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTgwNzcxOnYy", "diffSide": "RIGHT", "path": "be/src/util/cgroup_util.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjoyNDoyM1rOFbr6Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjo1MzoxM1rOFbsSPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3NTMxMA==", "bodyText": "Is there any resouce leak if ifstream.close is not called?", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364575310", "createdAt": "2020-01-09T06:24:23Z", "author": {"login": "imay"}, "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"gutil/strings/split.h\"\n+#include \"util/error_util.h\"\n+#include \"util/file_utils.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using strings::CUnescape;\n+using strings::Split;\n+using strings::SkipWhitespace;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        // so field size will be 3\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) {\n+            continue;\n+        }\n+        vector<string> fields = Split(line, \":\");\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() != 3) {\n+            return Status::InvalidArgument(Substitute(\n+                                               \"Could not parse line from /proc/self/cgroup - had $0 > 3 tokens: '$1'\",\n+                                               fields.size(), line));\n+        }\n+        vector<string> subsystems = Split(fields[1], \",\");\n+        auto it = std::find(subsystems.begin(), subsystems.end(), subsystem);\n+        if (it != subsystems.end()) {\n+            *path = move(fields[2]);\n+            return Status::OK();\n+        }\n+    }\n+}\n+\n+static Status unescape_path(const string& escaped, string* unescaped) {\n+    string err;\n+    if (!CUnescape(escaped, unescaped, &err)) {\n+        return Status::InvalidArgument(Substitute(\"Could not unescape path '$0': $1\", escaped, err));\n+    }\n+    return Status::OK();\n+}\n+\n+static Status read_cgroup_value(const string& limit_file_path, int64_t* val) {\n+    ifstream limit_file(limit_file_path, ios::in);\n+    string line;\n+    getline(limit_file, line);\n+    if (limit_file.fail() || limit_file.bad()) {\n+        return Status::IOError(Substitute(\"Error reading $0: $1\", limit_file_path, get_str_err_msg()));\n+    }\n+    StringParser::ParseResult pr;\n+    // Parse into an an int64_t If it overflows, returning the max value of int64_t is ok because that\n+    // is effectively unlimited.\n+    *val = StringParser::string_to_int<int64_t>(line.c_str(), line.size(), &pr);\n+    if ((pr != StringParser::PARSE_SUCCESS && pr != StringParser::PARSE_OVERFLOW)) {\n+        return Status::InvalidArgument(\n+                   Substitute(\"Failed to parse $0 as int64: '$1'\", limit_file_path, line));\n+    }\n+    return Status::OK();\n+}\n+\n+Status CGroupUtil::find_cgroup_mounts(\n+    const string& subsystem, pair<string, string>* result) {\n+    ifstream mountinfo(\"/proc/self/mountinfo\", ios::in);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4822cd6314dcb212a840ea32b4316815517fe4c9"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU4MTQzNw==", "bodyText": "this is done automatically by the ifstream destructor.", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364581437", "createdAt": "2020-01-09T06:53:13Z", "author": {"login": "yangzhg"}, "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"gutil/strings/split.h\"\n+#include \"util/error_util.h\"\n+#include \"util/file_utils.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using strings::CUnescape;\n+using strings::Split;\n+using strings::SkipWhitespace;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        // so field size will be 3\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) {\n+            continue;\n+        }\n+        vector<string> fields = Split(line, \":\");\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() != 3) {\n+            return Status::InvalidArgument(Substitute(\n+                                               \"Could not parse line from /proc/self/cgroup - had $0 > 3 tokens: '$1'\",\n+                                               fields.size(), line));\n+        }\n+        vector<string> subsystems = Split(fields[1], \",\");\n+        auto it = std::find(subsystems.begin(), subsystems.end(), subsystem);\n+        if (it != subsystems.end()) {\n+            *path = move(fields[2]);\n+            return Status::OK();\n+        }\n+    }\n+}\n+\n+static Status unescape_path(const string& escaped, string* unescaped) {\n+    string err;\n+    if (!CUnescape(escaped, unescaped, &err)) {\n+        return Status::InvalidArgument(Substitute(\"Could not unescape path '$0': $1\", escaped, err));\n+    }\n+    return Status::OK();\n+}\n+\n+static Status read_cgroup_value(const string& limit_file_path, int64_t* val) {\n+    ifstream limit_file(limit_file_path, ios::in);\n+    string line;\n+    getline(limit_file, line);\n+    if (limit_file.fail() || limit_file.bad()) {\n+        return Status::IOError(Substitute(\"Error reading $0: $1\", limit_file_path, get_str_err_msg()));\n+    }\n+    StringParser::ParseResult pr;\n+    // Parse into an an int64_t If it overflows, returning the max value of int64_t is ok because that\n+    // is effectively unlimited.\n+    *val = StringParser::string_to_int<int64_t>(line.c_str(), line.size(), &pr);\n+    if ((pr != StringParser::PARSE_SUCCESS && pr != StringParser::PARSE_OVERFLOW)) {\n+        return Status::InvalidArgument(\n+                   Substitute(\"Failed to parse $0 as int64: '$1'\", limit_file_path, line));\n+    }\n+    return Status::OK();\n+}\n+\n+Status CGroupUtil::find_cgroup_mounts(\n+    const string& subsystem, pair<string, string>* result) {\n+    ifstream mountinfo(\"/proc/self/mountinfo\", ios::in);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3NTMxMA=="}, "originalCommit": {"oid": "4822cd6314dcb212a840ea32b4316815517fe4c9"}, "originalPosition": 104}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2317, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}