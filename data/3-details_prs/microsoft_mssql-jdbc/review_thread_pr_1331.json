{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0OTM2MzQx", "number": 1331, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMToyOTo1NlrOD7aUpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0NTozN1rOD9-9QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNjIzODQ2OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMToyOTo1NlrOGTuFsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMToyOTo1NlrOGTuFsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzMTI1MQ==", "bodyText": "Make sure to follow JUnit test name standards.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423331251", "createdAt": "2020-05-11T21:29:56Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNjMzNzcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/DDC.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjowNjo0MlrOGTvFCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjowNjo0MlrOGTvFCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0NzQ2Ng==", "bodyText": "Please use multi-line comments. Apply this to all the changes you made.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423347466", "createdAt": "2020-05-11T22:06:42Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/DDC.java", "diffHunk": "@@ -323,6 +323,28 @@ static final Object convertDoubleToObject(double doubleVal, JDBCType jdbcType, S\n \n         return valueBytes;\n     }\n+    \n+    static final byte[] convertMoneyToBytes(BigDecimal bigDecimalVal, int bLength) {\n+        byte[] valueBytes = new byte[bLength];\n+        \n+        BigInteger bi = bigDecimalVal.unscaledValue();\n+        \n+        if (bLength == 8) {\n+            // money\n+            byte[] longbArray = new byte[bLength];\n+            Util.writeLong(bi.longValue(), longbArray, 0);\n+            // TDS 2.2.5.5.1.4 Fixed-Point Numbers\n+            // Money is represented as a 8 byte signed integer, with one 4-byte integer that represents", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNjM4MDk3OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjoyMzoyOFrOGTvfBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjoyMzoyOFrOGTvfBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDExNg==", "bodyText": "This is assuming insertion order is the same as select order, which is not true. Make sure to have an ID column to be able to order the select result by ID.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423354116", "createdAt": "2020-05-11T22:23:28Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsString extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r\n+\r\n+        try (Connection conn = dsLocal.getConnection()) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyResultSet(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            try (ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destTableName);\r\n+                    SQLServerBulkCopy bcOperation = new SQLServerBulkCopy(conn);) {\r\n+                bcOperation.setDestinationTableName(destTableName2);\r\n+                bcOperation.writeToServer(rs);\r\n+            }\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName2, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    static void validateValuesFromCSV(Statement stmt, String destinationTable, String inputFile) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destinationTable)) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNjM4MjQyOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAE.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjoyNDowNlrOGTvf9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNToyNDo0MFrOGUh2-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA==", "bodyText": "This is assuming insertion order is the same as select order, which is not true. Make sure to have an ID column to be able to order the select result by ID.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423354358", "createdAt": "2020-05-11T22:24:06Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAE.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+public class BulkCopySendTemporalDataTypesAsStringAE extends AESetup {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+    static String filePath = null;\r\n+\r\n+    static String destTableNameAE = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTableAE\"));\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, with AE enabled.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyAE() throws SQLException {\r\n+        beforeEachSetupAE();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(AETestConnectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\", AEInfo)) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord, destTableNameAE);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord, String tableName) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(tableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, tableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    static void validateValuesFromCSV(Statement stmt, String destinationTable, String inputFile) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destinationTable)) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk2MjEwMw==", "bodyText": "This is still not fixed.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423962103", "createdAt": "2020-05-12T18:56:32Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAE.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+public class BulkCopySendTemporalDataTypesAsStringAE extends AESetup {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+    static String filePath = null;\r\n+\r\n+    static String destTableNameAE = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTableAE\"));\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, with AE enabled.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyAE() throws SQLException {\r\n+        beforeEachSetupAE();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(AETestConnectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\", AEInfo)) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord, destTableNameAE);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord, String tableName) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(tableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, tableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    static void validateValuesFromCSV(Statement stmt, String destinationTable, String inputFile) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destinationTable)) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}, "originalCommit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNDM5MQ==", "bodyText": "Why is this not fixed? Doesn't specifying the column names individually guarantee order?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424014391", "createdAt": "2020-05-12T20:30:12Z", "author": {"login": "peterbae"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAE.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+public class BulkCopySendTemporalDataTypesAsStringAE extends AESetup {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+    static String filePath = null;\r\n+\r\n+    static String destTableNameAE = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTableAE\"));\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, with AE enabled.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyAE() throws SQLException {\r\n+        beforeEachSetupAE();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(AETestConnectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\", AEInfo)) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord, destTableNameAE);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord, String tableName) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(tableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, tableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    static void validateValuesFromCSV(Statement stmt, String destinationTable, String inputFile) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destinationTable)) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}, "originalCommit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNTcwMQ==", "bodyText": "oh never mind, you meant the row order. I'll fix that.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424015701", "createdAt": "2020-05-12T20:32:43Z", "author": {"login": "peterbae"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAE.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+public class BulkCopySendTemporalDataTypesAsStringAE extends AESetup {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+    static String filePath = null;\r\n+\r\n+    static String destTableNameAE = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTableAE\"));\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, with AE enabled.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyAE() throws SQLException {\r\n+        beforeEachSetupAE();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(AETestConnectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\", AEInfo)) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord, destTableNameAE);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord, String tableName) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(tableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, tableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    static void validateValuesFromCSV(Statement stmt, String destinationTable, String inputFile) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destinationTable)) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}, "originalCommit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMjUwNQ==", "bodyText": "I have a similar test, you can refer to this PR: #1312", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424022505", "createdAt": "2020-05-12T20:45:33Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAE.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+public class BulkCopySendTemporalDataTypesAsStringAE extends AESetup {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+    static String filePath = null;\r\n+\r\n+    static String destTableNameAE = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTableAE\"));\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, with AE enabled.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyAE() throws SQLException {\r\n+        beforeEachSetupAE();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(AETestConnectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\", AEInfo)) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord, destTableNameAE);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord, String tableName) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(tableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, tableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    static void validateValuesFromCSV(Statement stmt, String destinationTable, String inputFile) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destinationTable)) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}, "originalCommit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTQ1MQ==", "bodyText": "Thanks, done", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424179451", "createdAt": "2020-05-13T05:24:40Z", "author": {"login": "peterbae"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAE.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+public class BulkCopySendTemporalDataTypesAsStringAE extends AESetup {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+    static String filePath = null;\r\n+\r\n+    static String destTableNameAE = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTableAE\"));\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, with AE enabled.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyAE() throws SQLException {\r\n+        beforeEachSetupAE();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(AETestConnectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\", AEInfo)) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord, destTableNameAE);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord, String tableName) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(tableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, tableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    static void validateValuesFromCSV(Statement stmt, String destinationTable, String inputFile) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destinationTable)) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}, "originalCommit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDA5ODg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxODo0NDoyOFrOGUUJMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNToyNDozNlrOGUh26A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1NDczOQ==", "bodyText": "Please make javadoc consistent with other methods.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423954739", "createdAt": "2020-05-12T18:44:28Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java", "diffHunk": "@@ -991,4 +991,19 @@\n      */\n     void setClientKeyPassword(String password);\n \n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTQzMg==", "bodyText": "done", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424179432", "createdAt": "2020-05-13T05:24:36Z", "author": {"login": "peterbae"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java", "diffHunk": "@@ -991,4 +991,19 @@\n      */\n     void setClientKeyPassword(String password);\n \n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1NDczOQ=="}, "originalCommit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDIyNzAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxOToyMDo0OFrOGUVbtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNTozMzozMVrOGUiBbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NTg2MA==", "bodyText": "Shouldn't this be destSSType instead?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423975860", "createdAt": "2020-05-12T19:20:48Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2122,6 +2163,25 @@ else if (null != sourceCryptoMeta) {\n \n                 case microsoft.sql.Types.MONEY:\n                 case microsoft.sql.Types.SMALLMONEY:\n+                    if (null == colValue) {\n+                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);\n+                    } else {\n+                        /*\n+                         * if the precision that user provides is smaller than the precision of the actual value, the\n+                         * driver assumes the precision that user provides is the correct precision, and throws\n+                         * exception\n+                         */\n+                        if (bulkPrecision < Util.getValueLengthBaseOnJavaType(colValue, JavaType.of(colValue), null,\n+                                null, JDBCType.of(bulkJdbcType))) {\n+                            MessageFormat form = new MessageFormat(\n+                                    SQLServerException.getErrString(\"R_valueOutOfRange\"));\n+                            Object[] msgArgs = {SSType.DECIMAL};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTQxMA==", "bodyText": "Sorry, which part of this code should be destSSType?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424179410", "createdAt": "2020-05-13T05:24:31Z", "author": {"login": "peterbae"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2122,6 +2163,25 @@ else if (null != sourceCryptoMeta) {\n \n                 case microsoft.sql.Types.MONEY:\n                 case microsoft.sql.Types.SMALLMONEY:\n+                    if (null == colValue) {\n+                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);\n+                    } else {\n+                        /*\n+                         * if the precision that user provides is smaller than the precision of the actual value, the\n+                         * driver assumes the precision that user provides is the correct precision, and throws\n+                         * exception\n+                         */\n+                        if (bulkPrecision < Util.getValueLengthBaseOnJavaType(colValue, JavaType.of(colValue), null,\n+                                null, JDBCType.of(bulkJdbcType))) {\n+                            MessageFormat form = new MessageFormat(\n+                                    SQLServerException.getErrString(\"R_valueOutOfRange\"));\n+                            Object[] msgArgs = {SSType.DECIMAL};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NTg2MA=="}, "originalCommit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MjEyNw==", "bodyText": "Actually, I understood. Yes, this should be destSSType instead. I've made similar changes to the decimal/numeric case as well because I think it applies there as well, too.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424182127", "createdAt": "2020-05-13T05:33:31Z", "author": {"login": "peterbae"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2122,6 +2163,25 @@ else if (null != sourceCryptoMeta) {\n \n                 case microsoft.sql.Types.MONEY:\n                 case microsoft.sql.Types.SMALLMONEY:\n+                    if (null == colValue) {\n+                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);\n+                    } else {\n+                        /*\n+                         * if the precision that user provides is smaller than the precision of the actual value, the\n+                         * driver assumes the precision that user provides is the correct precision, and throws\n+                         * exception\n+                         */\n+                        if (bulkPrecision < Util.getValueLengthBaseOnJavaType(colValue, JavaType.of(colValue), null,\n+                                null, JDBCType.of(bulkJdbcType))) {\n+                            MessageFormat form = new MessageFormat(\n+                                    SQLServerException.getErrString(\"R_valueOutOfRange\"));\n+                            Object[] msgArgs = {SSType.DECIMAL};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NTg2MA=="}, "originalCommit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDcxMzExOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTo1MToxMVrOGUaQCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNTozMTowMFrOGUh-qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1NDc5Mg==", "bodyText": "I don't get this part of the changes.  So if destSSType is money and srcJdbcType is decimal, the code will write both DSType.MONEYN.byteValue() and TDSType.DECIMALN.byteValue(). Is this expected?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424054792", "createdAt": "2020-05-12T21:51:11Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -919,23 +919,37 @@ private void writeTypeInfo(TDSWriter tdsWriter, int srcJdbcType, int srcScale, i\n \n             case microsoft.sql.Types.MONEY:\n             case microsoft.sql.Types.SMALLMONEY:\n+                tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n+                if (SSType.MONEY == destSSType)\n+                    tdsWriter.writeByte((byte) 8);\n+                else\n+                    tdsWriter.writeByte((byte) 4);\n+                break;\n             case java.sql.Types.NUMERIC:\n             case java.sql.Types.DECIMAL:\n-                if (isBaseType && ((SSType.MONEY == destSSType) || (SSType.SMALLMONEY == destSSType))) {\n-                    tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n-                    if (SSType.MONEY == destSSType)\n-                        tdsWriter.writeByte((byte) 8);\n-                    else\n-                        tdsWriter.writeByte((byte) 4);\n-                } else {\n-                    if (java.sql.Types.DECIMAL == srcJdbcType)\n-                        tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n-                    else\n-                        tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C\n-                    tdsWriter.writeByte((byte) TDSWriter.BIGDECIMAL_MAX_LENGTH); // maximum length\n-                    tdsWriter.writeByte((byte) srcPrecision); // unsigned byte\n-                    tdsWriter.writeByte((byte) srcScale); // unsigned byte\n+                /*\n+                 * SQL Server allows the insertion of decimal and numeric into a money (and smallmoney) column,\n+                 * but Azure DW only accepts money types for money column.\n+                 * To make the code compatible against both SQL Server and Azure DW, always send decimal and\n+                 * numeric as money/smallmoney if the destination column is money/smallmoney\n+                 * and the source is decimal/numeric.\n+                 */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTQxNg==", "bodyText": "No, if destSSType is money and srcJdbcType is decimal, the code will only write TDSType.MONEYN.byteValue() and break out of the switch statement.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424181416", "createdAt": "2020-05-13T05:31:00Z", "author": {"login": "peterbae"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -919,23 +919,37 @@ private void writeTypeInfo(TDSWriter tdsWriter, int srcJdbcType, int srcScale, i\n \n             case microsoft.sql.Types.MONEY:\n             case microsoft.sql.Types.SMALLMONEY:\n+                tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n+                if (SSType.MONEY == destSSType)\n+                    tdsWriter.writeByte((byte) 8);\n+                else\n+                    tdsWriter.writeByte((byte) 4);\n+                break;\n             case java.sql.Types.NUMERIC:\n             case java.sql.Types.DECIMAL:\n-                if (isBaseType && ((SSType.MONEY == destSSType) || (SSType.SMALLMONEY == destSSType))) {\n-                    tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n-                    if (SSType.MONEY == destSSType)\n-                        tdsWriter.writeByte((byte) 8);\n-                    else\n-                        tdsWriter.writeByte((byte) 4);\n-                } else {\n-                    if (java.sql.Types.DECIMAL == srcJdbcType)\n-                        tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n-                    else\n-                        tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C\n-                    tdsWriter.writeByte((byte) TDSWriter.BIGDECIMAL_MAX_LENGTH); // maximum length\n-                    tdsWriter.writeByte((byte) srcPrecision); // unsigned byte\n-                    tdsWriter.writeByte((byte) srcScale); // unsigned byte\n+                /*\n+                 * SQL Server allows the insertion of decimal and numeric into a money (and smallmoney) column,\n+                 * but Azure DW only accepts money types for money column.\n+                 * To make the code compatible against both SQL Server and Azure DW, always send decimal and\n+                 * numeric as money/smallmoney if the destination column is money/smallmoney\n+                 * and the source is decimal/numeric.\n+                 */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1NDc5Mg=="}, "originalCommit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDc3MjE2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjoxMzoxM1rOGUa1PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNDo0Njo1NVrOGUhRaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NDMxNg==", "bodyText": "suggest that we be consistent in how we describe our other sendBlahAsBlah properties, ie \"Determines whether the driver will send...\"", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424064316", "createdAt": "2020-05-12T22:13:13Z", "author": {"login": "lilgreenbird"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "diffHunk": "@@ -264,6 +264,8 @@ static String getResource(String key) {\n             {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n             {\"R_clientKeyPasswordPropertyDescription\",\n                     \"Password for private key if the private key is password protected.\"},\n+            {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\",\n+                    \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2OTgzMg==", "bodyText": "I don't think my new addition here is inconsistent because other descriptive properties don't follow the \"Determines whether...\" starters either. I think the suggestion is good though.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424169832", "createdAt": "2020-05-13T04:46:55Z", "author": {"login": "peterbae"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "diffHunk": "@@ -264,6 +264,8 @@ static String getResource(String key) {\n             {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n             {\"R_clientKeyPasswordPropertyDescription\",\n                     \"Password for private key if the private key is password protected.\"},\n+            {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\",\n+                    \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NDMxNg=="}, "originalCommit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDQwNjczOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODozODo1NFrOGU-rUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMzo1NjoxMlrOGVHf_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MTYwMQ==", "bodyText": "why define all these variables they're only used once below", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424651601", "createdAt": "2020-05-13T18:38:54Z", "author": {"login": "lilgreenbird"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+            if (offsetString.startsWith(\"-\"))\n+                minutesOffset = -minutesOffset;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+            /*\n+             * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+             * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+             * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+             * use a local time zone determined by the minutes offset of the value, since\n+             * the writers for those types expect local calendars.\n+             */\n+            timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                             : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+            calendar = new GregorianCalendar(timeZone, Locale.US);\n+\n+            String timestampString = stringValue.substring(0, lastColon - 4);\n+            int year = Integer.valueOf(timestampString.substring(0, 4));\n+            int month = Integer.valueOf(timestampString.substring(5, 7));\n+            int day = Integer.valueOf(timestampString.substring(8, 10));\n+            int hour = Integer.valueOf(timestampString.substring(11, 13));\n+            int minute = Integer.valueOf(timestampString.substring(14, 16));\n+            int second = Integer.valueOf(timestampString.substring(17, 19));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NjE1OA==", "bodyText": "I think it's easier to see this way.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424796158", "createdAt": "2020-05-13T23:56:12Z", "author": {"login": "peterbae"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+            if (offsetString.startsWith(\"-\"))\n+                minutesOffset = -minutesOffset;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+            /*\n+             * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+             * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+             * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+             * use a local time zone determined by the minutes offset of the value, since\n+             * the writers for those types expect local calendars.\n+             */\n+            timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                             : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+            calendar = new GregorianCalendar(timeZone, Locale.US);\n+\n+            String timestampString = stringValue.substring(0, lastColon - 4);\n+            int year = Integer.valueOf(timestampString.substring(0, 4));\n+            int month = Integer.valueOf(timestampString.substring(5, 7));\n+            int day = Integer.valueOf(timestampString.substring(8, 10));\n+            int hour = Integer.valueOf(timestampString.substring(11, 13));\n+            int minute = Integer.valueOf(timestampString.substring(14, 16));\n+            int second = Integer.valueOf(timestampString.substring(17, 19));\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MTYwMQ=="}, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDQ2NDkxOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODo1NDozMVrOGU_P_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzoyNDo0MVrOGY72gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDk4OQ==", "bodyText": "this test doesn't actually test the datasource settings as updateDataSource hasn't been updated to include the new properties", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424660989", "createdAt": "2020-05-13T18:54:31Z", "author": {"login": "lilgreenbird"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MTcxNw==", "bodyText": "I think it is testing the datasource, because I'm calling setSendTemporalDataTypesAsStringForBulkCopy instead of using updateDataSource. I just checked as well to make sure it is using the datasource with the connection property set to false.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426041717", "createdAt": "2020-05-15T20:53:54Z", "author": {"login": "peterbae"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDk4OQ=="}, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MjgwMQ==", "bodyText": "sorry, you're right you are, as you're calling that explicitly after. But that's not how the other connection properties are handled. And updateDataSource needs to be updated to parse all the connection properties properly", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426192801", "createdAt": "2020-05-16T21:28:20Z", "author": {"login": "lilgreenbird"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDk4OQ=="}, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc5OTYxNg==", "bodyText": "sure, i'll add that to my tests too then.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428799616", "createdAt": "2020-05-21T17:24:41Z", "author": {"login": "peterbae"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDk4OQ=="}, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDQ3ODQwOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODo1ODoxOFrOGU_Y1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMDo1NToxNVrOGWTj3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MzI1NA==", "bodyText": "why not just use @beforeeach?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424663254", "createdAt": "2020-05-13T18:58:18Z", "author": {"login": "lilgreenbird"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MjMzNA==", "bodyText": "Sometimes beforeEach didn't work for me properly, so I just call beforeEachSetup. There shouldn't be any functional differences.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426042334", "createdAt": "2020-05-15T20:55:15Z", "author": {"login": "peterbae"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MzI1NA=="}, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDY2ODIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTo1NToyOFrOGVBRpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMzo1Mjo1OVrOGVHcOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NDE4MQ==", "bodyText": "Need to handle indexoutofbounds here in case the input isn't in the format expected.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424694181", "createdAt": "2020-05-13T19:55:28Z", "author": {"login": "rene-ye"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTE5Mw==", "bodyText": "Thanks, done.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424795193", "createdAt": "2020-05-13T23:52:59Z", "author": {"login": "peterbae"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NDE4MQ=="}, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDY3MzU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTo1NzowOVrOGVBVEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMzo1NjowMFrOGVHfww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NTA1OA==", "bodyText": "Doesn't this break if the user's locale isn't US?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424695058", "createdAt": "2020-05-13T19:57:09Z", "author": {"login": "rene-ye"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+            if (offsetString.startsWith(\"-\"))\n+                minutesOffset = -minutesOffset;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+            /*\n+             * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+             * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+             * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+             * use a local time zone determined by the minutes offset of the value, since\n+             * the writers for those types expect local calendars.\n+             */\n+            timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                             : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+            calendar = new GregorianCalendar(timeZone, Locale.US);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NjA5OQ==", "bodyText": "The locale doesn't matter. It's only used to determine what is the first day of the week (either saturday, sunday or monday) but that function isn't being used here, so I just put US locale (but anything works)", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424796099", "createdAt": "2020-05-13T23:56:00Z", "author": {"login": "peterbae"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+            if (offsetString.startsWith(\"-\"))\n+                minutesOffset = -minutesOffset;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+            /*\n+             * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+             * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+             * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+             * use a local time zone determined by the minutes offset of the value, since\n+             * the writers for those types expect local calendars.\n+             */\n+            timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                             : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+            calendar = new GregorianCalendar(timeZone, Locale.US);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NTA1OA=="}, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDY4OTczOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDowMjowMlrOGVBffw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMzo1ODo0N1rOGVHjHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NzcyNw==", "bodyText": "byte byteType = (java.sql.Types.DECIMAL == srcJdbcType) ? TDSType.DECIMALN.byteValue() : TDSType.NUMERICN.byteValue();\ntdsWriter.writeByte(byteType);\nChange if block to above to shorten the code and make it more clear.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424697727", "createdAt": "2020-05-13T20:02:02Z", "author": {"login": "rene-ye"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -919,23 +919,37 @@ private void writeTypeInfo(TDSWriter tdsWriter, int srcJdbcType, int srcScale, i\n \n             case microsoft.sql.Types.MONEY:\n             case microsoft.sql.Types.SMALLMONEY:\n+                tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n+                if (SSType.MONEY == destSSType)\n+                    tdsWriter.writeByte((byte) 8);\n+                else\n+                    tdsWriter.writeByte((byte) 4);\n+                break;\n             case java.sql.Types.NUMERIC:\n             case java.sql.Types.DECIMAL:\n-                if (isBaseType && ((SSType.MONEY == destSSType) || (SSType.SMALLMONEY == destSSType))) {\n-                    tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n-                    if (SSType.MONEY == destSSType)\n-                        tdsWriter.writeByte((byte) 8);\n-                    else\n-                        tdsWriter.writeByte((byte) 4);\n-                } else {\n-                    if (java.sql.Types.DECIMAL == srcJdbcType)\n-                        tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n-                    else\n-                        tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C\n-                    tdsWriter.writeByte((byte) TDSWriter.BIGDECIMAL_MAX_LENGTH); // maximum length\n-                    tdsWriter.writeByte((byte) srcPrecision); // unsigned byte\n-                    tdsWriter.writeByte((byte) srcScale); // unsigned byte\n+                /*\n+                 * SQL Server allows the insertion of decimal and numeric into a money (and smallmoney) column,\n+                 * but Azure DW only accepts money types for money column.\n+                 * To make the code compatible against both SQL Server and Azure DW, always send decimal and\n+                 * numeric as money/smallmoney if the destination column is money/smallmoney\n+                 * and the source is decimal/numeric.\n+                 */\n+                if (destSSType == SSType.MONEY) {\n+                    tdsWriter.writeByte(TDSType.MONEYN.byteValue());\n+                    tdsWriter.writeByte((byte) 8);\n+                    break;\n+                } else if (destSSType == SSType.SMALLMONEY) {\n+                    tdsWriter.writeByte(TDSType.MONEYN.byteValue());\n+                    tdsWriter.writeByte((byte) 4);\n+                    break;\n                 }\n+                if (java.sql.Types.DECIMAL == srcJdbcType)\n+                    tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n+                else\n+                    tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5Njk1Nw==", "bodyText": "done", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424796957", "createdAt": "2020-05-13T23:58:47Z", "author": {"login": "peterbae"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -919,23 +919,37 @@ private void writeTypeInfo(TDSWriter tdsWriter, int srcJdbcType, int srcScale, i\n \n             case microsoft.sql.Types.MONEY:\n             case microsoft.sql.Types.SMALLMONEY:\n+                tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n+                if (SSType.MONEY == destSSType)\n+                    tdsWriter.writeByte((byte) 8);\n+                else\n+                    tdsWriter.writeByte((byte) 4);\n+                break;\n             case java.sql.Types.NUMERIC:\n             case java.sql.Types.DECIMAL:\n-                if (isBaseType && ((SSType.MONEY == destSSType) || (SSType.SMALLMONEY == destSSType))) {\n-                    tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n-                    if (SSType.MONEY == destSSType)\n-                        tdsWriter.writeByte((byte) 8);\n-                    else\n-                        tdsWriter.writeByte((byte) 4);\n-                } else {\n-                    if (java.sql.Types.DECIMAL == srcJdbcType)\n-                        tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n-                    else\n-                        tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C\n-                    tdsWriter.writeByte((byte) TDSWriter.BIGDECIMAL_MAX_LENGTH); // maximum length\n-                    tdsWriter.writeByte((byte) srcPrecision); // unsigned byte\n-                    tdsWriter.writeByte((byte) srcScale); // unsigned byte\n+                /*\n+                 * SQL Server allows the insertion of decimal and numeric into a money (and smallmoney) column,\n+                 * but Azure DW only accepts money types for money column.\n+                 * To make the code compatible against both SQL Server and Azure DW, always send decimal and\n+                 * numeric as money/smallmoney if the destination column is money/smallmoney\n+                 * and the source is decimal/numeric.\n+                 */\n+                if (destSSType == SSType.MONEY) {\n+                    tdsWriter.writeByte(TDSType.MONEYN.byteValue());\n+                    tdsWriter.writeByte((byte) 8);\n+                    break;\n+                } else if (destSSType == SSType.SMALLMONEY) {\n+                    tdsWriter.writeByte(TDSType.MONEYN.byteValue());\n+                    tdsWriter.writeByte((byte) 4);\n+                    break;\n                 }\n+                if (java.sql.Types.DECIMAL == srcJdbcType)\n+                    tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n+                else\n+                    tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NzcyNw=="}, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjU5OTIzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxODoyMDoyNlrOGWPSMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMTo0MTo1OVrOGWUooQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk3MjI3Mg==", "bodyText": "Please add a comment which contains the format you are parsing.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r425972272", "createdAt": "2020-05-15T18:20:26Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,87 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            try {\n+                String stringValue = (String) value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90fae3649819fe2fab94cd227d2c7ae05711ab14"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1OTkzNw==", "bodyText": "done.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426059937", "createdAt": "2020-05-15T21:41:59Z", "author": {"login": "peterbae"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,87 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            try {\n+                String stringValue = (String) value;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk3MjI3Mg=="}, "originalCommit": {"oid": "90fae3649819fe2fab94cd227d2c7ae05711ab14"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzA5OTQzOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMToyMToyOFrOGWUNUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDo1NjozN1rOGZCltw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1Mjk0Nw==", "bodyText": "The test fails when I switch to:\nfileRecord.addColumnMetadata(7, \"c6\", microsoft.sql.Types.SMALLDATETIME, 0, 0); // with SmallDatetime", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426052947", "createdAt": "2020-05-15T21:21:28Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r\n+\r\n+        try (Connection conn = dsLocal.getConnection()) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"id\", java.sql.Types.INTEGER, 0, 0);\r\n+            fileRecord.addColumnMetadata(2, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(3, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(4, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(5, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(6, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(7, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(8, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(9, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyResultSet(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"id\", java.sql.Types.INTEGER, 0, 0);\r\n+            fileRecord.addColumnMetadata(2, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(3, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(4, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(5, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(6, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(7, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90fae3649819fe2fab94cd227d2c7ae05711ab14"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MTgxNw==", "bodyText": "It's supposed to fail. When performing bulk copy, the users are expected to provide the correct column type. The corresponding column type for smalldatetime is TIMESTAMP, and microsoft.sql.Types.SMALLDATETIME is not a supported column type. If you were to test that scenario without my changes, it will fail as well. The table that outlines which datatypes need to be specified for each datatype for bulk copy is outlined here: https://docs.microsoft.com/en-us/sql/connect/jdbc/using-basic-data-types?view=sql-server-2017", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426061817", "createdAt": "2020-05-15T21:48:02Z", "author": {"login": "peterbae"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r\n+\r\n+        try (Connection conn = dsLocal.getConnection()) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"id\", java.sql.Types.INTEGER, 0, 0);\r\n+            fileRecord.addColumnMetadata(2, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(3, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(4, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(5, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(6, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(7, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(8, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(9, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyResultSet(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"id\", java.sql.Types.INTEGER, 0, 0);\r\n+            fileRecord.addColumnMetadata(2, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(3, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(4, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(5, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(6, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(7, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1Mjk0Nw=="}, "originalCommit": {"oid": "90fae3649819fe2fab94cd227d2c7ae05711ab14"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMDAwNw==", "bodyText": "Understood.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428910007", "createdAt": "2020-05-21T20:56:37Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r\n+\r\n+        try (Connection conn = dsLocal.getConnection()) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"id\", java.sql.Types.INTEGER, 0, 0);\r\n+            fileRecord.addColumnMetadata(2, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(3, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(4, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(5, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(6, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(7, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(8, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(9, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyResultSet(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"id\", java.sql.Types.INTEGER, 0, 0);\r\n+            fileRecord.addColumnMetadata(2, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(3, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(4, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(5, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(6, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(7, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1Mjk0Nw=="}, "originalCommit": {"oid": "90fae3649819fe2fab94cd227d2c7ae05711ab14"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzE1MTc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMTo0NTo0M1rOGWUtSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMTo0NTo0M1rOGWUtSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MTEzMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            calendar = new GregorianCalendar(timeZone, Locale.CHINA);\n          \n          \n            \n                            calendar = new GregorianCalendar(timeZone);", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426061130", "createdAt": "2020-05-15T21:45:43Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,100 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            // expected format: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\n+            try {\n+                String stringValue = (String) value;\n+                int lastColon = stringValue.lastIndexOf(':');\n+\n+                String offsetString = stringValue.substring(lastColon - 3);\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+                /*\n+                 * At this point, offsetString should look like +hh:mm or -hh:mm. Otherwise, the optional offset\n+                 * value has not been provided. Parse accordingly.\n+                 */\n+                String timestampString;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+                if (!offsetString.startsWith(\"+\") && !offsetString.startsWith(\"-\")) {\n+                    minutesOffset = 0;\n+                    timestampString = stringValue;\n+                } else {\n+                    minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                            + Integer.valueOf(offsetString.substring(4, 6));\n+                    timestampString = stringValue.substring(0, lastColon - 4);\n+\n+                    if (offsetString.startsWith(\"-\"))\n+                        minutesOffset = -minutesOffset;\n+                }\n+\n+                /*\n+                 * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+                 * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+                 * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+                 * use a local time zone determined by the minutes offset of the value, since\n+                 * the writers for those types expect local calendars.\n+                 */\n+                timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                                 : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+                calendar = new GregorianCalendar(timeZone, Locale.CHINA);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3341bcbbb335812e5c648860d6831016112aaf5f"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzE2MTY5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMTo1MDo1MVrOGWUzOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMjowNDozOVrOGWVD_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MjY1MA==", "bodyText": "Can you explain this with code comments? Also why do we have to parse for TIME, not for other types?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426062650", "createdAt": "2020-05-15T21:50:51Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2397,8 +2468,20 @@ else if (4 >= bulkScale)\n                             tdsWriter.writeByte((byte) 0x04);\n                         else\n                             tdsWriter.writeByte((byte) 0x05);\n-\n-                        tdsWriter.writeTime((java.sql.Timestamp) colValue, bulkScale);\n+                        if (colValue instanceof String) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3341bcbbb335812e5c648860d6831016112aaf5f"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2Njk0Mg==", "bodyText": "I added comments. Other datatypes are already handled as if the data was string (this is the case for date, datetime and smalldatetime), so there was no need for extra steps. Time was the only datatype (other than DTO) that the code was assuming was coming on the form of a timestamp, so I needed to adjust accordingly.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426066942", "createdAt": "2020-05-15T22:04:39Z", "author": {"login": "peterbae"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2397,8 +2468,20 @@ else if (4 >= bulkScale)\n                             tdsWriter.writeByte((byte) 0x04);\n                         else\n                             tdsWriter.writeByte((byte) 0x05);\n-\n-                        tdsWriter.writeTime((java.sql.Timestamp) colValue, bulkScale);\n+                        if (colValue instanceof String) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MjY1MA=="}, "originalCommit": {"oid": "3341bcbbb335812e5c648860d6831016112aaf5f"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mjk2MjgwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDoyNTo1OVrOGXxUiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDo1ODoxM1rOGYdkUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3ODUwNQ==", "bodyText": "Need to check for connection.getSendTemporalDataTypesAsStringForBulkCopy() here too.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427578505", "createdAt": "2020-05-19T20:25:59Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,100 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzQ0Mg==", "bodyText": "The check is done before this method is called. Checking for String guarantees that that connection property is set to false, and also that the data is coming from a CSV. Near the beginning of writeColumnToTdsWriter method in SQLServerBulkCopy, this line:\n       } else if (null != serverBulkData && connection.getSendTemporalDataTypesAsStringForBulkCopy()) {\nensures that if getSendTemporalDataTypesAsStringForBulkCopy is true then bulkJdbcType will be varchar, which means that if getSendTemporalDataTypesAsStringForBulkCopy is false, we couldn't have come to this line.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428303442", "createdAt": "2020-05-20T20:58:13Z", "author": {"login": "peterbae"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,100 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3ODUwNQ=="}, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mjk2NjQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDoyNzoxMlrOGXxW6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDo1ODo1N1rOGYdl1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3OTExMw==", "bodyText": "Need to check for connection.getSendTemporalDataTypesAsStringForBulkCopy() here too.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427579113", "createdAt": "2020-05-19T20:27:12Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2397,8 +2468,30 @@ else if (4 >= bulkScale)\n                             tdsWriter.writeByte((byte) 0x04);\n                         else\n                             tdsWriter.writeByte((byte) 0x05);\n-\n-                        tdsWriter.writeTime((java.sql.Timestamp) colValue, bulkScale);\n+                        if (colValue instanceof String) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzgyOA==", "bodyText": "Same logic applies here, but these are really good observations / questions.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428303828", "createdAt": "2020-05-20T20:58:57Z", "author": {"login": "peterbae"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2397,8 +2468,30 @@ else if (4 >= bulkScale)\n                             tdsWriter.writeByte((byte) 0x04);\n                         else\n                             tdsWriter.writeByte((byte) 0x05);\n-\n-                        tdsWriter.writeTime((java.sql.Timestamp) colValue, bulkScale);\n+                        if (colValue instanceof String) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3OTExMw=="}, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzIwMTU0OnYy", "diffSide": "RIGHT", "path": "src/test/resources/BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy2.csv", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0MTo1MlrOGXzriw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTowNTo1MlrOGYdytw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNzE2Mw==", "bodyText": "New line here.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427617163", "createdAt": "2020-05-19T21:41:52Z", "author": {"login": "ulvii"}, "path": "src/test/resources/BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy2.csv", "diffHunk": "@@ -0,0 +1,2 @@\n+int,date,datetime,datetime2,time,datetimeoffset,smalldatetime,money,smallmoney\r\n+1,0001-01-01,1753-01-01 00:00:00,0001-01-01 00:00:00,00:00:00,2025-12-10 12:32:10,1900-01-01 06:56:00,100.2523,100.2523", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzk2MA==", "bodyText": "will add.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428303960", "createdAt": "2020-05-20T20:59:11Z", "author": {"login": "peterbae"}, "path": "src/test/resources/BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy2.csv", "diffHunk": "@@ -0,0 +1,2 @@\n+int,date,datetime,datetime2,time,datetimeoffset,smalldatetime,money,smallmoney\r\n+1,0001-01-01,1753-01-01 00:00:00,0001-01-01 00:00:00,00:00:00,2025-12-10 12:32:10,1900-01-01 06:56:00,100.2523,100.2523", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNzE2Mw=="}, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNzEyNw==", "bodyText": "Actually, I don't think we should add a newline here, because it's a CSV file. AFAIK if a CSV file only had 1 column and the file has a newline at the end, I think that would be treated as a NULL value, which might not always be what's being tested (I remember specifically not leaving a newline at the end of CSV files for this reason)", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428307127", "createdAt": "2020-05-20T21:05:52Z", "author": {"login": "peterbae"}, "path": "src/test/resources/BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy2.csv", "diffHunk": "@@ -0,0 +1,2 @@\n+int,date,datetime,datetime2,time,datetimeoffset,smalldatetime,money,smallmoney\r\n+1,0001-01-01,1753-01-01 00:00:00,0001-01-01 00:00:00,00:00:00,2025-12-10 12:32:10,1900-01-01 06:56:00,100.2523,100.2523", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNzE2Mw=="}, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzIwNjI4OnYy", "diffSide": "RIGHT", "path": "src/test/resources/BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy2.csv", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0MzozNFrOGXzuiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTowMjo1MVrOGYdtTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNzkzMQ==", "bodyText": "Why do you need separate file for this test?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427617931", "createdAt": "2020-05-19T21:43:34Z", "author": {"login": "ulvii"}, "path": "src/test/resources/BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy2.csv", "diffHunk": "@@ -0,0 +1,2 @@\n+int,date,datetime,datetime2,time,datetimeoffset,smalldatetime,money,smallmoney\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNTc0MA==", "bodyText": "I wanted to test the cases where the data in CSV doesn't \"exactly\" match the returned data. For example, it's legal to omit the nanosecond part of datetime2 value in the CSV, but the result from the server will have 0000000 (7 digits of nanoseconds) attached to the data. I wanted a separate CSV file to test those cases easily. It's only used in the testSendTemporalDataTypesAsStringForBulkCopyOptional method in my test class.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428305740", "createdAt": "2020-05-20T21:02:51Z", "author": {"login": "peterbae"}, "path": "src/test/resources/BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy2.csv", "diffHunk": "@@ -0,0 +1,2 @@\n+int,date,datetime,datetime2,time,datetimeoffset,smalldatetime,money,smallmoney\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNzkzMQ=="}, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzIxMjE2OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAETest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0NTozOFrOGXzyJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOTozMzozNlrOGZAC0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODg1Mw==", "bodyText": "Please format all the files.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427618853", "createdAt": "2020-05-19T21:45:38Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAETest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjIwMQ==", "bodyText": "This file is formatted. Do you see something that should've been formatted? My formatter doesn't change anything in this file.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428306201", "createdAt": "2020-05-20T21:03:48Z", "author": {"login": "peterbae"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAETest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODg1Mw=="}, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMzMDU3MQ==", "bodyText": "The comments seem to be off.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428330571", "createdAt": "2020-05-20T21:56:06Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAETest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODg1Mw=="}, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2ODMwNQ==", "bodyText": "Which comment for example?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428868305", "createdAt": "2020-05-21T19:33:36Z", "author": {"login": "peterbae"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAETest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODg1Mw=="}, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1087, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}