{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0OTM2MzQx", "number": 1331, "title": "Extended bulk copy support for Azure DW", "bodyText": "Adds new connection property sendTemporalDataTypesAsStringForBulkCopy.\nThis connection property, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and TIME datatypes as their respective types instead of sending them as String.\nAdditionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\nNote that with this connection property set to FALSE, the driver will only accept the default string literal formatof each temporal datatype, for example:\nDATE: YYYY-MM-DD\nDATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\nDATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\nDATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\nSMALLDATETIME:YYYY-MM-DD hh:mm:ss\nTIME: hh:mm:ss[.nnnnnnn]\nI've created two separate test classes for this, one for normal cases and one for AE cases. The AE cases are not supported against Azure DW, but I wanted both normal and AE cases to be run against their respective supported servers without one of them not being run when they should be, therefore two separate test classes.\nI also made a small change to AESetup.java so that it doesn't throw a NPE when I'm trying to debug/run tests locally through eclipse.", "createdAt": "2020-05-07T21:45:02Z", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331", "merged": true, "mergeCommit": {"oid": "f857e2505aec7b413fbd1f5b722862d915b2b2cf"}, "closed": true, "closedAt": "2020-05-22T17:13:22Z", "author": {"login": "peterbae"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABce1njhgH2gAyNDE0OTM2MzQxOjkzODQ5OTIzMGViYzAxOWYxZWJjYzgyMTYwNDNiNWZmODYyZGU1MTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcj05fAgFqTQxNzAzODc5NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "938499230ebc019f1ebcc8216043b5ff862de515", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/938499230ebc019f1ebcc8216043b5ff862de515", "committedDate": "2020-05-07T04:31:59Z", "message": "first commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52ca698c08dc46d51b9f3f50e1bce5bee88aa327", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/52ca698c08dc46d51b9f3f50e1bce5bee88aa327", "committedDate": "2020-05-07T04:32:07Z", "message": "Merge branch 'dev' of https://github.com/Microsoft/mssql-jdbc into bulkCopySupport"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba4ac41a4826306566681d648eb3ea36954a6a0c", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/ba4ac41a4826306566681d648eb3ea36954a6a0c", "committedDate": "2020-05-07T16:50:48Z", "message": "test changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7acedcf44b85a5590f5612d3424b5516dce80c98", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/7acedcf44b85a5590f5612d3424b5516dce80c98", "committedDate": "2020-05-07T19:07:49Z", "message": "more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddfffcc161402ff52ba0206c118ae9fe5ca50286", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/ddfffcc161402ff52ba0206c118ae9fe5ca50286", "committedDate": "2020-05-07T21:30:44Z", "message": "test changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/04c498f39f0f8b3bf69dfc42e619b76d03876a03", "committedDate": "2020-05-07T21:39:19Z", "message": "test changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NTQ1Mjc2", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-409545276", "createdAt": "2020-05-11T21:29:56Z", "commit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMToyOTo1NlrOGTuFsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMToyOTo1NlrOGTuFsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzMTI1MQ==", "bodyText": "Make sure to follow JUnit test name standards.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423331251", "createdAt": "2020-05-11T21:29:56Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NTY1MTYx", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-409565161", "createdAt": "2020-05-11T22:06:42Z", "commit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjowNjo0MlrOGTvFCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjowNjo0MlrOGTvFCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0NzQ2Ng==", "bodyText": "Please use multi-line comments. Apply this to all the changes you made.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423347466", "createdAt": "2020-05-11T22:06:42Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/DDC.java", "diffHunk": "@@ -323,6 +323,28 @@ static final Object convertDoubleToObject(double doubleVal, JDBCType jdbcType, S\n \n         return valueBytes;\n     }\n+    \n+    static final byte[] convertMoneyToBytes(BigDecimal bigDecimalVal, int bLength) {\n+        byte[] valueBytes = new byte[bLength];\n+        \n+        BigInteger bi = bigDecimalVal.unscaledValue();\n+        \n+        if (bLength == 8) {\n+            // money\n+            byte[] longbArray = new byte[bLength];\n+            Util.writeLong(bi.longValue(), longbArray, 0);\n+            // TDS 2.2.5.5.1.4 Fixed-Point Numbers\n+            // Money is represented as a 8 byte signed integer, with one 4-byte integer that represents", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NTczMDc3", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-409573077", "createdAt": "2020-05-11T22:23:28Z", "commit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjoyMzoyOFrOGTvfBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjoyMzoyOFrOGTvfBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDExNg==", "bodyText": "This is assuming insertion order is the same as select order, which is not true. Make sure to have an ID column to be able to order the select result by ID.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423354116", "createdAt": "2020-05-11T22:23:28Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsString extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r\n+\r\n+        try (Connection conn = dsLocal.getConnection()) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyResultSet(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            try (ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destTableName);\r\n+                    SQLServerBulkCopy bcOperation = new SQLServerBulkCopy(conn);) {\r\n+                bcOperation.setDestinationTableName(destTableName2);\r\n+                bcOperation.writeToServer(rs);\r\n+            }\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName2, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    static void validateValuesFromCSV(Statement stmt, String destinationTable, String inputFile) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destinationTable)) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "originalPosition": 176}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NTczMzUw", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-409573350", "createdAt": "2020-05-11T22:24:06Z", "commit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjoyNDowNlrOGTvf9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjoyNDowNlrOGTvf9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA==", "bodyText": "This is assuming insertion order is the same as select order, which is not true. Make sure to have an ID column to be able to order the select result by ID.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423354358", "createdAt": "2020-05-11T22:24:06Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAE.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+public class BulkCopySendTemporalDataTypesAsStringAE extends AESetup {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+    static String filePath = null;\r\n+\r\n+    static String destTableNameAE = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTableAE\"));\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, with AE enabled.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyAE() throws SQLException {\r\n+        beforeEachSetupAE();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(AETestConnectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\", AEInfo)) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord, destTableNameAE);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord, String tableName) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(tableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, tableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    static void validateValuesFromCSV(Statement stmt, String destinationTable, String inputFile) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destinationTable)) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/c167c6abd08a36724137f837b99ee166e7de6265", "committedDate": "2020-05-12T01:01:23Z", "message": "review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwMzI0MTg1", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-410324185", "createdAt": "2020-05-12T18:44:27Z", "commit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxODo0NDoyOFrOGUUJMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxODo0NDoyOFrOGUUJMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1NDczOQ==", "bodyText": "Please make javadoc consistent with other methods.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423954739", "createdAt": "2020-05-12T18:44:28Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java", "diffHunk": "@@ -991,4 +991,19 @@\n      */\n     void setClientKeyPassword(String password);\n \n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwMzUwNDgx", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-410350481", "createdAt": "2020-05-12T19:20:48Z", "commit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxOToyMDo0OFrOGUVbtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxOToyMDo0OFrOGUVbtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NTg2MA==", "bodyText": "Shouldn't this be destSSType instead?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423975860", "createdAt": "2020-05-12T19:20:48Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2122,6 +2163,25 @@ else if (null != sourceCryptoMeta) {\n \n                 case microsoft.sql.Types.MONEY:\n                 case microsoft.sql.Types.SMALLMONEY:\n+                    if (null == colValue) {\n+                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);\n+                    } else {\n+                        /*\n+                         * if the precision that user provides is smaller than the precision of the actual value, the\n+                         * driver assumes the precision that user provides is the correct precision, and throws\n+                         * exception\n+                         */\n+                        if (bulkPrecision < Util.getValueLengthBaseOnJavaType(colValue, JavaType.of(colValue), null,\n+                                null, JDBCType.of(bulkJdbcType))) {\n+                            MessageFormat form = new MessageFormat(\n+                                    SQLServerException.getErrString(\"R_valueOutOfRange\"));\n+                            Object[] msgArgs = {SSType.DECIMAL};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "originalPosition": 221}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNDQ4NzA3", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-410448707", "createdAt": "2020-05-12T21:51:11Z", "commit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTo1MToxMVrOGUaQCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTo1MToxMVrOGUaQCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1NDc5Mg==", "bodyText": "I don't get this part of the changes.  So if destSSType is money and srcJdbcType is decimal, the code will write both DSType.MONEYN.byteValue() and TDSType.DECIMALN.byteValue(). Is this expected?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424054792", "createdAt": "2020-05-12T21:51:11Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -919,23 +919,37 @@ private void writeTypeInfo(TDSWriter tdsWriter, int srcJdbcType, int srcScale, i\n \n             case microsoft.sql.Types.MONEY:\n             case microsoft.sql.Types.SMALLMONEY:\n+                tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n+                if (SSType.MONEY == destSSType)\n+                    tdsWriter.writeByte((byte) 8);\n+                else\n+                    tdsWriter.writeByte((byte) 4);\n+                break;\n             case java.sql.Types.NUMERIC:\n             case java.sql.Types.DECIMAL:\n-                if (isBaseType && ((SSType.MONEY == destSSType) || (SSType.SMALLMONEY == destSSType))) {\n-                    tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n-                    if (SSType.MONEY == destSSType)\n-                        tdsWriter.writeByte((byte) 8);\n-                    else\n-                        tdsWriter.writeByte((byte) 4);\n-                } else {\n-                    if (java.sql.Types.DECIMAL == srcJdbcType)\n-                        tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n-                    else\n-                        tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C\n-                    tdsWriter.writeByte((byte) TDSWriter.BIGDECIMAL_MAX_LENGTH); // maximum length\n-                    tdsWriter.writeByte((byte) srcPrecision); // unsigned byte\n-                    tdsWriter.writeByte((byte) srcScale); // unsigned byte\n+                /*\n+                 * SQL Server allows the insertion of decimal and numeric into a money (and smallmoney) column,\n+                 * but Azure DW only accepts money types for money column.\n+                 * To make the code compatible against both SQL Server and Azure DW, always send decimal and\n+                 * numeric as money/smallmoney if the destination column is money/smallmoney\n+                 * and the source is decimal/numeric.\n+                 */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNDYwMzgx", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-410460381", "createdAt": "2020-05-12T22:13:12Z", "commit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjoxMzoxM1rOGUa1PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjoxMzoxM1rOGUa1PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NDMxNg==", "bodyText": "suggest that we be consistent in how we describe our other sendBlahAsBlah properties, ie \"Determines whether the driver will send...\"", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424064316", "createdAt": "2020-05-12T22:13:13Z", "author": {"login": "lilgreenbird"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "diffHunk": "@@ -264,6 +264,8 @@ static String getResource(String key) {\n             {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n             {\"R_clientKeyPasswordPropertyDescription\",\n                     \"Password for private key if the private key is password protected.\"},\n+            {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\",\n+                    \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c167c6abd08a36724137f837b99ee166e7de6265"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "committedDate": "2020-05-13T05:34:05Z", "message": "comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMTk4MTk0", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-411198194", "createdAt": "2020-05-13T18:38:53Z", "commit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODozODo1NFrOGU-rUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODozODo1NFrOGU-rUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MTYwMQ==", "bodyText": "why define all these variables they're only used once below", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424651601", "createdAt": "2020-05-13T18:38:54Z", "author": {"login": "lilgreenbird"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+            if (offsetString.startsWith(\"-\"))\n+                minutesOffset = -minutesOffset;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+            /*\n+             * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+             * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+             * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+             * use a local time zone determined by the minutes offset of the value, since\n+             * the writers for those types expect local calendars.\n+             */\n+            timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                             : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+            calendar = new GregorianCalendar(timeZone, Locale.US);\n+\n+            String timestampString = stringValue.substring(0, lastColon - 4);\n+            int year = Integer.valueOf(timestampString.substring(0, 4));\n+            int month = Integer.valueOf(timestampString.substring(5, 7));\n+            int day = Integer.valueOf(timestampString.substring(8, 10));\n+            int hour = Integer.valueOf(timestampString.substring(11, 13));\n+            int minute = Integer.valueOf(timestampString.substring(14, 16));\n+            int second = Integer.valueOf(timestampString.substring(17, 19));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjA5Nzcx", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-411209771", "createdAt": "2020-05-13T18:54:31Z", "commit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODo1NDozMVrOGU_P_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODo1NDozMVrOGU_P_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDk4OQ==", "bodyText": "this test doesn't actually test the datasource settings as updateDataSource hasn't been updated to include the new properties", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424660989", "createdAt": "2020-05-13T18:54:31Z", "author": {"login": "lilgreenbird"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjEyNTM3", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-411212537", "createdAt": "2020-05-13T18:58:17Z", "commit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODo1ODoxOFrOGU_Y1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODo1ODoxOFrOGU_Y1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MzI1NA==", "bodyText": "why not just use @beforeeach?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424663254", "createdAt": "2020-05-13T18:58:18Z", "author": {"login": "lilgreenbird"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjUyMTI3", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-411252127", "createdAt": "2020-05-13T19:55:28Z", "commit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTo1NToyOFrOGVBRpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTo1NToyOFrOGVBRpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NDE4MQ==", "bodyText": "Need to handle indexoutofbounds here in case the input isn't in the format expected.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424694181", "createdAt": "2020-05-13T19:55:28Z", "author": {"login": "rene-ye"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjUzMzAw", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-411253300", "createdAt": "2020-05-13T19:57:09Z", "commit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTo1NzowOVrOGVBVEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTo1NzowOVrOGVBVEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NTA1OA==", "bodyText": "Doesn't this break if the user's locale isn't US?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424695058", "createdAt": "2020-05-13T19:57:09Z", "author": {"login": "rene-ye"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+            if (offsetString.startsWith(\"-\"))\n+                minutesOffset = -minutesOffset;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+            /*\n+             * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+             * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+             * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+             * use a local time zone determined by the minutes offset of the value, since\n+             * the writers for those types expect local calendars.\n+             */\n+            timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                             : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+            calendar = new GregorianCalendar(timeZone, Locale.US);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjU2Nzgy", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-411256782", "createdAt": "2020-05-13T20:02:02Z", "commit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDowMjowMlrOGVBffw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDowMjowMlrOGVBffw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NzcyNw==", "bodyText": "byte byteType = (java.sql.Types.DECIMAL == srcJdbcType) ? TDSType.DECIMALN.byteValue() : TDSType.NUMERICN.byteValue();\ntdsWriter.writeByte(byteType);\nChange if block to above to shorten the code and make it more clear.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424697727", "createdAt": "2020-05-13T20:02:02Z", "author": {"login": "rene-ye"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -919,23 +919,37 @@ private void writeTypeInfo(TDSWriter tdsWriter, int srcJdbcType, int srcScale, i\n \n             case microsoft.sql.Types.MONEY:\n             case microsoft.sql.Types.SMALLMONEY:\n+                tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n+                if (SSType.MONEY == destSSType)\n+                    tdsWriter.writeByte((byte) 8);\n+                else\n+                    tdsWriter.writeByte((byte) 4);\n+                break;\n             case java.sql.Types.NUMERIC:\n             case java.sql.Types.DECIMAL:\n-                if (isBaseType && ((SSType.MONEY == destSSType) || (SSType.SMALLMONEY == destSSType))) {\n-                    tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n-                    if (SSType.MONEY == destSSType)\n-                        tdsWriter.writeByte((byte) 8);\n-                    else\n-                        tdsWriter.writeByte((byte) 4);\n-                } else {\n-                    if (java.sql.Types.DECIMAL == srcJdbcType)\n-                        tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n-                    else\n-                        tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C\n-                    tdsWriter.writeByte((byte) TDSWriter.BIGDECIMAL_MAX_LENGTH); // maximum length\n-                    tdsWriter.writeByte((byte) srcPrecision); // unsigned byte\n-                    tdsWriter.writeByte((byte) srcScale); // unsigned byte\n+                /*\n+                 * SQL Server allows the insertion of decimal and numeric into a money (and smallmoney) column,\n+                 * but Azure DW only accepts money types for money column.\n+                 * To make the code compatible against both SQL Server and Azure DW, always send decimal and\n+                 * numeric as money/smallmoney if the destination column is money/smallmoney\n+                 * and the source is decimal/numeric.\n+                 */\n+                if (destSSType == SSType.MONEY) {\n+                    tdsWriter.writeByte(TDSType.MONEYN.byteValue());\n+                    tdsWriter.writeByte((byte) 8);\n+                    break;\n+                } else if (destSSType == SSType.SMALLMONEY) {\n+                    tdsWriter.writeByte(TDSType.MONEYN.byteValue());\n+                    tdsWriter.writeByte((byte) 4);\n+                    break;\n                 }\n+                if (java.sql.Types.DECIMAL == srcJdbcType)\n+                    tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n+                else\n+                    tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4ca3c0f14588634843fdd18d8033e8c71d911f1", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/f4ca3c0f14588634843fdd18d8033e8c71d911f1", "committedDate": "2020-05-13T23:39:29Z", "message": "destSSType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42c013ffbf51db58b1dbc9ab870dbed5f4270dc1", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/42c013ffbf51db58b1dbc9ab870dbed5f4270dc1", "committedDate": "2020-05-13T23:56:32Z", "message": "check for failure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90fae3649819fe2fab94cd227d2c7ae05711ab14", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/90fae3649819fe2fab94cd227d2c7ae05711ab14", "committedDate": "2020-05-13T23:58:40Z", "message": "shorten if statement"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyODY5NjE2", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-412869616", "createdAt": "2020-05-15T18:20:25Z", "commit": {"oid": "90fae3649819fe2fab94cd227d2c7ae05711ab14"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxODoyMDoyNlrOGWPSMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxODoyMDoyNlrOGWPSMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk3MjI3Mg==", "bodyText": "Please add a comment which contains the format you are parsing.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r425972272", "createdAt": "2020-05-15T18:20:26Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,87 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            try {\n+                String stringValue = (String) value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90fae3649819fe2fab94cd227d2c7ae05711ab14"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyOTc1NjAy", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-412975602", "createdAt": "2020-05-15T21:21:27Z", "commit": {"oid": "90fae3649819fe2fab94cd227d2c7ae05711ab14"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMToyMToyOFrOGWUNUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMToyMToyOFrOGWUNUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1Mjk0Nw==", "bodyText": "The test fails when I switch to:\nfileRecord.addColumnMetadata(7, \"c6\", microsoft.sql.Types.SMALLDATETIME, 0, 0); // with SmallDatetime", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426052947", "createdAt": "2020-05-15T21:21:28Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r\n+\r\n+        try (Connection conn = dsLocal.getConnection()) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"id\", java.sql.Types.INTEGER, 0, 0);\r\n+            fileRecord.addColumnMetadata(2, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(3, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(4, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(5, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(6, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(7, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(8, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(9, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyResultSet(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"id\", java.sql.Types.INTEGER, 0, 0);\r\n+            fileRecord.addColumnMetadata(2, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(3, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(4, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(5, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(6, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(7, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90fae3649819fe2fab94cd227d2c7ae05711ab14"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3341bcbbb335812e5c648860d6831016112aaf5f", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/3341bcbbb335812e5c648860d6831016112aaf5f", "committedDate": "2020-05-15T21:41:39Z", "message": "add comment / add test cases"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyOTg1OTY1", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-412985965", "createdAt": "2020-05-15T21:45:43Z", "commit": {"oid": "3341bcbbb335812e5c648860d6831016112aaf5f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMTo0NTo0M1rOGWUtSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMTo0NTo0M1rOGWUtSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MTEzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            calendar = new GregorianCalendar(timeZone, Locale.CHINA);\n          \n          \n            \n                            calendar = new GregorianCalendar(timeZone);", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426061130", "createdAt": "2020-05-15T21:45:43Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,100 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            // expected format: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\n+            try {\n+                String stringValue = (String) value;\n+                int lastColon = stringValue.lastIndexOf(':');\n+\n+                String offsetString = stringValue.substring(lastColon - 3);\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+                /*\n+                 * At this point, offsetString should look like +hh:mm or -hh:mm. Otherwise, the optional offset\n+                 * value has not been provided. Parse accordingly.\n+                 */\n+                String timestampString;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+                if (!offsetString.startsWith(\"+\") && !offsetString.startsWith(\"-\")) {\n+                    minutesOffset = 0;\n+                    timestampString = stringValue;\n+                } else {\n+                    minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                            + Integer.valueOf(offsetString.substring(4, 6));\n+                    timestampString = stringValue.substring(0, lastColon - 4);\n+\n+                    if (offsetString.startsWith(\"-\"))\n+                        minutesOffset = -minutesOffset;\n+                }\n+\n+                /*\n+                 * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+                 * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+                 * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+                 * use a local time zone determined by the minutes offset of the value, since\n+                 * the writers for those types expect local calendars.\n+                 */\n+                timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                                 : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+                calendar = new GregorianCalendar(timeZone, Locale.CHINA);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3341bcbbb335812e5c648860d6831016112aaf5f"}, "originalPosition": 95}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccf8b26fc83c212d84a1b93b03c09bf2e946c907", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/ccf8b26fc83c212d84a1b93b03c09bf2e946c907", "committedDate": "2020-05-15T21:49:53Z", "message": "Update src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n\nCo-authored-by: ulvii <v-ulibra@microsoft.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyOTg3ODMw", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-412987830", "createdAt": "2020-05-15T21:50:50Z", "commit": {"oid": "3341bcbbb335812e5c648860d6831016112aaf5f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMTo1MDo1MVrOGWUzOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMTo1MDo1MVrOGWUzOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MjY1MA==", "bodyText": "Can you explain this with code comments? Also why do we have to parse for TIME, not for other types?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426062650", "createdAt": "2020-05-15T21:50:51Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2397,8 +2468,20 @@ else if (4 >= bulkScale)\n                             tdsWriter.writeByte((byte) 0x04);\n                         else\n                             tdsWriter.writeByte((byte) 0x05);\n-\n-                        tdsWriter.writeTime((java.sql.Timestamp) colValue, bulkScale);\n+                        if (colValue instanceof String) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3341bcbbb335812e5c648860d6831016112aaf5f"}, "originalPosition": 262}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3", "committedDate": "2020-05-15T22:01:30Z", "message": "add comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0Nzk2MzQ3", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-414796347", "createdAt": "2020-05-19T20:25:58Z", "commit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDoyNTo1OVrOGXxUiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDoyNTo1OVrOGXxUiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3ODUwNQ==", "bodyText": "Need to check for connection.getSendTemporalDataTypesAsStringForBulkCopy() here too.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427578505", "createdAt": "2020-05-19T20:25:59Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,100 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0Nzk3MTg4", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-414797188", "createdAt": "2020-05-19T20:27:12Z", "commit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDoyNzoxMlrOGXxW6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDoyNzoxMlrOGXxW6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3OTExMw==", "bodyText": "Need to check for connection.getSendTemporalDataTypesAsStringForBulkCopy() here too.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427579113", "createdAt": "2020-05-19T20:27:12Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2397,8 +2468,30 @@ else if (4 >= bulkScale)\n                             tdsWriter.writeByte((byte) 0x04);\n                         else\n                             tdsWriter.writeByte((byte) 0x05);\n-\n-                        tdsWriter.writeTime((java.sql.Timestamp) colValue, bulkScale);\n+                        if (colValue instanceof String) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 262}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODQ0NDE3", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-414844417", "createdAt": "2020-05-19T21:41:52Z", "commit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0MTo1MlrOGXzriw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0MTo1MlrOGXzriw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNzE2Mw==", "bodyText": "New line here.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427617163", "createdAt": "2020-05-19T21:41:52Z", "author": {"login": "ulvii"}, "path": "src/test/resources/BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy2.csv", "diffHunk": "@@ -0,0 +1,2 @@\n+int,date,datetime,datetime2,time,datetimeoffset,smalldatetime,money,smallmoney\r\n+1,0001-01-01,1753-01-01 00:00:00,0001-01-01 00:00:00,00:00:00,2025-12-10 12:32:10,1900-01-01 06:56:00,100.2523,100.2523", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODQ1MzY4", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-414845368", "createdAt": "2020-05-19T21:43:34Z", "commit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0MzozNFrOGXzuiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0MzozNFrOGXzuiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNzkzMQ==", "bodyText": "Why do you need separate file for this test?", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427617931", "createdAt": "2020-05-19T21:43:34Z", "author": {"login": "ulvii"}, "path": "src/test/resources/BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy2.csv", "diffHunk": "@@ -0,0 +1,2 @@\n+int,date,datetime,datetime2,time,datetimeoffset,smalldatetime,money,smallmoney\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODQ2NDk3", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-414846497", "createdAt": "2020-05-19T21:45:37Z", "commit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0NTozOFrOGXzyJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0NTozOFrOGXzyJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODg1Mw==", "bodyText": "Please format all the files.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427618853", "createdAt": "2020-05-19T21:45:38Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAETest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2e3d031c439318848d39fefcbf497740f1dab8b", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/e2e3d031c439318848d39fefcbf497740f1dab8b", "committedDate": "2020-05-21T19:33:53Z", "message": "update abstractTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b49865f8d5732a7bff83789939bf5edcd8395f5c", "author": {"user": {"login": "peterbae", "name": "Peter Bae"}}, "url": "https://github.com/microsoft/mssql-jdbc/commit/b49865f8d5732a7bff83789939bf5edcd8395f5c", "committedDate": "2020-05-21T21:42:34Z", "message": "test modifications"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTMwOTI0", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-416530924", "createdAt": "2020-05-21T22:17:40Z", "commit": {"oid": "b49865f8d5732a7bff83789939bf5edcd8395f5c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NjY2MDk5", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-416666099", "createdAt": "2020-05-22T06:00:07Z", "commit": {"oid": "b49865f8d5732a7bff83789939bf5edcd8395f5c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MDM4Nzk0", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#pullrequestreview-417038794", "createdAt": "2020-05-22T16:31:18Z", "commit": {"oid": "b49865f8d5732a7bff83789939bf5edcd8395f5c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2542, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}