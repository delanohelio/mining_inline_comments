{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4NTkzNTQx", "number": 1431, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoyMDowNlrOEzZwDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToxNDozN1rOE87K-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMzM0NzM0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoyMDowNlrOHqmiJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoyMDowNlrOHqmiJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMzU3NQ==", "bodyText": "Temporary solution would be to change this line to\nif (StringUtils.isEmpty(input) || \"-1\".equalsIgnoreCase(input)) {\nBut we should ask whether it makes sense to allow users to even input something like -1 at all. -1 is also used as a default value by XAConnection at times.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r514433575", "createdAt": "2020-10-29T17:20:06Z", "author": {"login": "rene-ye"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import java.lang.management.ManagementFactory;\n+import java.text.MessageFormat;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+\n+/**\n+ * Parser created to parse String value from Connection String to equivalent number of bytes for JDBC Driver to work on.\n+ */\n+public class MaxResultBufferParser {\n+\n+    private static final Logger logger = Logger.getLogger(\"com.microsoft.sqlserver.jdbc.MaxResultBufferParser\");\n+    private static final String[] PERCENT_PHRASES = {\"percent\", \"pct\", \"p\"};\n+    private static final String ERROR_MESSAGE = \"maxResultBuffer property is badly formatted: {0}\";\n+\n+    private MaxResultBufferParser() {}\n+\n+    /**\n+     *\n+     * Returns number of bytes for maxResultBuffer property\n+     *\n+     * @param input\n+     *        String value for maxResultProperty provided in Connection String\n+     * @return 'maxResultBuffer' property as number of bytes\n+     * @throws SQLServerException\n+     *         Is Thrown when maxResultProperty's syntax is wrong\n+     */\n+    public static long validateMaxResultBuffer(String input) throws SQLServerException {\n+        String numberString;\n+        long number = -1;\n+\n+        // check for null values and empty String \"\", if so return -1\n+        if (StringUtils.isEmpty(input)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "306f5ad46108200ae942e239cdcdcf2020a2a138"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMzQzMzU5OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/microsoft/sqlserver/testframework/AbstractTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzo0MTowNVrOHqnYbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzo0MTowNVrOHqnYbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ0NzQ3MA==", "bodyText": "This needs a break at the end of the case statement or it'll overflow into the next one.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r514447470", "createdAt": "2020-10-29T17:41:05Z", "author": {"login": "rene-ye"}, "path": "src/test/java/com/microsoft/sqlserver/testframework/AbstractTest.java", "diffHunk": "@@ -355,6 +355,8 @@ protected static ISQLServerDataSource updateDataSource(String connectionString,\n                             break;\n                         case Constants.SEND_TEMPORAL_DATATYPES_AS_STRING_FOR_BULK_COPY:\n                             ds.setSendTemporalDataTypesAsStringForBulkCopy(Boolean.parseBoolean(value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "306f5ad46108200ae942e239cdcdcf2020a2a138"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMzQzNDM3OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/microsoft/sqlserver/testframework/AbstractTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzo0MToxOFrOHqnY7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzo0MToxOFrOHqnY7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ0NzU5OA==", "bodyText": "Add a break to the end of the this so the above bug doesn't happen again.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r514447598", "createdAt": "2020-10-29T17:41:18Z", "author": {"login": "rene-ye"}, "path": "src/test/java/com/microsoft/sqlserver/testframework/AbstractTest.java", "diffHunk": "@@ -355,6 +355,8 @@ protected static ISQLServerDataSource updateDataSource(String connectionString,\n                             break;\n                         case Constants.SEND_TEMPORAL_DATATYPES_AS_STRING_FOR_BULK_COPY:\n                             ds.setSendTemporalDataTypesAsStringForBulkCopy(Boolean.parseBoolean(value));\n+                        case Constants.MAX_RESULT_BUFFER:\n+                            ds.setMaxResultBuffer(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "306f5ad46108200ae942e239cdcdcf2020a2a138"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MzMwNDc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ICounter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjoyODoxOVrOHu_e4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjoyODoxOVrOHu_e4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNjY0MQ==", "bodyText": "Please make this interface package-private.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r519036641", "createdAt": "2020-11-06T22:28:19Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/ICounter.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+/**\n+ * Interface for MaxResultBufferCounter\n+ */\n+public interface ICounter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f2706904fc349b95b40ed652357ad0a5fa2bcbb"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MzMyNDM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjozNzowNVrOHu_p7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjozNzowNVrOHu_p7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzOTQ2OQ==", "bodyText": "Package-private please.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r519039469", "createdAt": "2020-11-06T22:37:05Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -7344,6 +7364,23 @@ final boolean readingResponse() {\n \n     protected ArrayList<byte[]> enclaveCEKs;\n \n+    //Counter reference, so maxResultBuffer property can by acknowledged\n+    private ICounter counter;\n+\n+    public ICounter getCounter() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f2706904fc349b95b40ed652357ad0a5fa2bcbb"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MzMzMzk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjo0MToyMlrOHu_vlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjo0MToyMlrOHu_vlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0MDkxOA==", "bodyText": "package-private", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r519040918", "createdAt": "2020-11-06T22:41:22Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -7344,6 +7364,23 @@ final boolean readingResponse() {\n \n     protected ArrayList<byte[]> enclaveCEKs;\n \n+    //Counter reference, so maxResultBuffer property can by acknowledged\n+    private ICounter counter;\n+\n+    public ICounter getCounter() {\n+        return counter;\n+    }\n+\n+    public void createCounter(ICounter previousCounter, Properties activeConnectionProperties) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f2706904fc349b95b40ed652357ad0a5fa2bcbb"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MzM4MzUxOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/microsoft/sqlserver/jdbc/MaxResultBufferTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMzowNTozNVrOHvAMAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMzowNTozNVrOHvAMAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0ODE5NQ==", "bodyText": "Because connectionString is defined in AbstractTest and is static, this line will change the connection string for all the tests. Please use a local connection string .", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r519048195", "createdAt": "2020-11-06T23:05:35Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/MaxResultBufferTest.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\n+import com.microsoft.sqlserver.testframework.AbstractTest;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.platform.runner.JUnitPlatform;\n+import org.junit.runner.RunWith;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Random;\n+\n+\n+/**\n+ * Class for testing maxResultBuffer property, all tests were performed on default connection settings\n+ * (defaultPacketLength = 8000), only changed were ResponsiveBuffering and MaxResultBuffer\n+ */\n+@RunWith(JUnitPlatform.class)\n+@DisplayName(\"maxResultBuffer Tests\")\n+public class MaxResultBufferTest extends AbstractTest {\n+\n+    @SuppressWarnings(\"SqlResolve\")\n+    private static final String TEST_TABLE_NAME = \"maxResultBufferTestTable\";\n+\n+    /**\n+     * This sets value of maxResultBuffer for each test\n+     */\n+    @BeforeEach\n+    void prepareMaxResultBuffer() {\n+        setMaxResultBuffer(\"10k\");\n+    }\n+\n+    /**\n+     * Create TEST_TABLE with 1 column nchar(precision) with numberOfRows. Let's calculate payload on example:\n+     * numberOfRows = 800 precision = 10\n+     *\n+     * Payload (in Bytes) = 49 (Header plus column metadata) + numberOfRows * (precision * 2 + 1 + 2) (3 extra bytes are\n+     * for column length and end of line character)\n+     *\n+     * So payload generated by this method = 49 + 800 * (10 * 2 + 2 + 1) = 49 + 800 * 23 = 18449\n+     *\n+     * Default packetLength = 8000, so payload is sent in 3 packets\n+     *\n+     * @throws SQLException\n+     *         Signalizes error when creating TEST_TABLE\n+     */\n+    @BeforeAll\n+    static void createAndPopulateNCharTestTable() throws SQLException {\n+        String insertSQL = \"INSERT INTO \" + AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME) + \" VALUES (?)\";\n+        int numberOfRows = 800;\n+        int precision = 10;\n+\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                Statement statement = connection.createStatement();\n+                PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {\n+\n+            // drop Table if exists and then create new one\n+            TestUtils.dropTableIfExists(AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME), statement);\n+            statement.execute(\"CREATE TABLE \" + AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME)\n+                    + \" ( col1 nchar(\" + precision + \"))\");\n+\n+            // insert into Table\n+            for (int i = 0; i < numberOfRows; i++) {\n+                preparedStatement.setString(1, generateRandomString(precision));\n+                preparedStatement.addBatch();\n+            }\n+            preparedStatement.executeBatch();\n+        }\n+    }\n+\n+    @AfterAll\n+    static void teardownTestTable() throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            TestUtils.dropTableIfExists(AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME), statement);\n+        }\n+    }\n+\n+    /**\n+     * This method tests if ResultSets behave correctly when maxResultBuffer is set to 10000, they all should pass\n+     * (assuming default packetLength = 8000 and responsiveBuffering = adaptive)\n+     *\n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    @Test\n+    public void testResultSetLinearWithAdaptiveResponsiveBuffering() throws SQLException {\n+        setResponseBufferingAdaptive(true);\n+\n+        testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);\n+        testResultSet(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n+    }\n+\n+    /**\n+     * This method tests if ResultSets behave correctly when maxResultBuffer is set to 10000, they all should pass\n+     * (assuming default packetLength = 8000 and responsiveBuffering = full)\n+     * \n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    @Test\n+    public void testResultSetLinearWithFullResponsiveBuffering() throws SQLException {\n+        setResponseBufferingAdaptive(false);\n+\n+        testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);\n+        testResultSet(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n+    }\n+\n+    /**\n+     * This method tests if ResultSet behave correctly when maxResultBuffer is set to 10000, it should throw Exception\n+     * (assuming default packetLength = 8000 and responsiveBuffering = full)\n+     */\n+    @Test\n+    public void testResultSetLinearWithFullResponsiveBufferingException() {\n+        setResponseBufferingAdaptive(false);\n+\n+        Assertions.assertThrows(SQLServerException.class,\n+                () -> testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY));\n+    }\n+\n+    /**\n+     * This method tests if when calling multiple PreparedStatements with their own ResultSet, JDBC driver would behave\n+     * appropriately, assuming maxResultBuffer is set to 10000, it should throw Exception (assuming default packetLength\n+     * = 8000 and responsiveBuffering = adaptive)\n+     */\n+    @Test\n+    public void testPreparedStatementMultipleResultSetsWithAdaptiveResponseBuffering() {\n+        setResponseBufferingAdaptive(true);\n+\n+        Assertions.assertThrows(SQLServerException.class, this::testPreparedStatementWithMultipleResultSets);\n+    }\n+\n+    /**\n+     * This method tests if when calling multiple PreparedStatements with their own ResultSet, JDBC driver would behave\n+     * appropriately, assuming maxResultBuffer is set to 10000, it should throw Exception (assuming default packetLength\n+     * = 8000 and responsiveBuffering = full)\n+     */\n+    @Test\n+    public void testPreparedStatementMultipleResultSetsWithFullResponseBuffering() {\n+        setResponseBufferingAdaptive(false);\n+\n+        Assertions.assertThrows(SQLServerException.class, this::testPreparedStatementWithMultipleResultSets);\n+    }\n+\n+    /**\n+     * This method tests if calling multiple Queries in one Statement works properly. When maxResultBuffer is set to\n+     * 10000, it should work properly (assuming default packetLength = 8000 and responsiveBuffering = adaptive)\n+     * \n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    @Test\n+    public void testTwoQueriesInOneStatementWithAdaptiveResponseBuffering() throws SQLException {\n+        setResponseBufferingAdaptive(true);\n+\n+        testTwoQueriesInOneStatement();\n+    }\n+\n+    /**\n+     * This method tests if calling multiple Queries in one Statement works properly. When maxResultBuffer is set to\n+     * 10000, it should throw Exception (assuming default packetLength = 8000 and responsiveBuffering = full)\n+     */\n+    @Test\n+    public void testTwoQueriesInOneStatementWithFullResponseBuffering() {\n+        setResponseBufferingAdaptive(false);\n+\n+        Assertions.assertThrows(SQLServerException.class, this::testTwoQueriesInOneStatement);\n+    }\n+\n+    /**\n+     * This method tests if all packets from ResultSet are correctly retrieved\n+     *\n+     * @param resultSetType\n+     *        Result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n+     *        <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n+     * @param concurrencyMode\n+     *        Concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or\n+     *        <code>ResultSet.CONCUR_UPDATABLE</code>\n+     *\n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    private void testResultSet(int resultSetType, int concurrencyMode) throws SQLException {\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                Statement statement = connection.createStatement(resultSetType, concurrencyMode)) {\n+            statement.execute(\"SELECT * FROM \" + TEST_TABLE_NAME);\n+            try (ResultSet resultSet = statement.getResultSet()) {\n+                while (resultSet.next()) {}\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method tests if Statements are detached properly, when first one hasn't been completely retrieved and second\n+     * one have been executed\n+     *\n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    private void testPreparedStatementWithMultipleResultSets() throws SQLException {\n+        String selectSQL = \"SELECT * FROM \" + TEST_TABLE_NAME;\n+\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                PreparedStatement statement = connection.prepareStatement(selectSQL);\n+                ResultSet resultSet = statement.executeQuery()) {\n+\n+            try (PreparedStatement secondStatement = connection.prepareStatement(selectSQL);\n+                    ResultSet secondResultSet = secondStatement.executeQuery()) {\n+                while (resultSet.next()) {}\n+\n+                try (PreparedStatement thirdStatement = connection.prepareStatement(selectSQL);\n+                        ResultSet thirdResultSet = thirdStatement.executeQuery()) {\n+                    while (thirdResultSet.next()) {}\n+                    while (secondResultSet.next()) {}\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method tests if ResultSet's are retrieved correctly, when more than one Query is executed inside single\n+     * statement\n+     * \n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    private void testTwoQueriesInOneStatement() throws SQLException {\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                Statement statement = connection.createStatement()) {\n+            statement.execute(\"SELECT * FROM \" + TEST_TABLE_NAME + \";SELECT * FROM \" + TEST_TABLE_NAME);\n+\n+            try (ResultSet resultSet = statement.getResultSet()) {\n+                while (resultSet.next()) {}\n+            }\n+\n+            if (statement.getMoreResults()) {\n+                try (ResultSet totallyNewResultSet = statement.getResultSet()) {\n+                    while (totallyNewResultSet.next()) {}\n+                }\n+            }\n+        }\n+    }\n+\n+    private static String generateRandomString(int precision) {\n+        int leftLimit = 33;\n+        int rightLimit = 126;\n+        Random random = new Random();\n+        return random.ints(leftLimit, rightLimit).limit(precision)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString();\n+    }\n+\n+    private static void setResponseBufferingAdaptive(boolean adaptive) {\n+        String value = adaptive ? \"adaptive\" : \"full\";\n+        connectionString = TestUtils.addOrOverrideProperty(connectionString, \"responseBuffering\", value);\n+        AbstractTest.updateDataSource(connectionString, ds);\n+    }\n+\n+    private static void setMaxResultBuffer(String maxResultBuffer) {\n+        connectionString = TestUtils.addOrOverrideProperty(connectionString, \"maxResultBuffer\", maxResultBuffer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f2706904fc349b95b40ed652357ad0a5fa2bcbb"}, "originalPosition": 277}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MzM5NDk1OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/microsoft/sqlserver/jdbc/MaxResultBufferTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMzoxMjowOFrOHvASqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMzoxMjowOFrOHvASqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0OTg5OQ==", "bodyText": "Because connectionString is defined in AbstractTest and is static, this line will change the connection string for all the tests. Please use a local connection string .", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r519049899", "createdAt": "2020-11-06T23:12:08Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/MaxResultBufferTest.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\n+import com.microsoft.sqlserver.testframework.AbstractTest;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.platform.runner.JUnitPlatform;\n+import org.junit.runner.RunWith;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Random;\n+\n+\n+/**\n+ * Class for testing maxResultBuffer property, all tests were performed on default connection settings\n+ * (defaultPacketLength = 8000), only changed were ResponsiveBuffering and MaxResultBuffer\n+ */\n+@RunWith(JUnitPlatform.class)\n+@DisplayName(\"maxResultBuffer Tests\")\n+public class MaxResultBufferTest extends AbstractTest {\n+\n+    @SuppressWarnings(\"SqlResolve\")\n+    private static final String TEST_TABLE_NAME = \"maxResultBufferTestTable\";\n+\n+    /**\n+     * This sets value of maxResultBuffer for each test\n+     */\n+    @BeforeEach\n+    void prepareMaxResultBuffer() {\n+        setMaxResultBuffer(\"10k\");\n+    }\n+\n+    /**\n+     * Create TEST_TABLE with 1 column nchar(precision) with numberOfRows. Let's calculate payload on example:\n+     * numberOfRows = 800 precision = 10\n+     *\n+     * Payload (in Bytes) = 49 (Header plus column metadata) + numberOfRows * (precision * 2 + 1 + 2) (3 extra bytes are\n+     * for column length and end of line character)\n+     *\n+     * So payload generated by this method = 49 + 800 * (10 * 2 + 2 + 1) = 49 + 800 * 23 = 18449\n+     *\n+     * Default packetLength = 8000, so payload is sent in 3 packets\n+     *\n+     * @throws SQLException\n+     *         Signalizes error when creating TEST_TABLE\n+     */\n+    @BeforeAll\n+    static void createAndPopulateNCharTestTable() throws SQLException {\n+        String insertSQL = \"INSERT INTO \" + AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME) + \" VALUES (?)\";\n+        int numberOfRows = 800;\n+        int precision = 10;\n+\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                Statement statement = connection.createStatement();\n+                PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {\n+\n+            // drop Table if exists and then create new one\n+            TestUtils.dropTableIfExists(AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME), statement);\n+            statement.execute(\"CREATE TABLE \" + AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME)\n+                    + \" ( col1 nchar(\" + precision + \"))\");\n+\n+            // insert into Table\n+            for (int i = 0; i < numberOfRows; i++) {\n+                preparedStatement.setString(1, generateRandomString(precision));\n+                preparedStatement.addBatch();\n+            }\n+            preparedStatement.executeBatch();\n+        }\n+    }\n+\n+    @AfterAll\n+    static void teardownTestTable() throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            TestUtils.dropTableIfExists(AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME), statement);\n+        }\n+    }\n+\n+    /**\n+     * This method tests if ResultSets behave correctly when maxResultBuffer is set to 10000, they all should pass\n+     * (assuming default packetLength = 8000 and responsiveBuffering = adaptive)\n+     *\n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    @Test\n+    public void testResultSetLinearWithAdaptiveResponsiveBuffering() throws SQLException {\n+        setResponseBufferingAdaptive(true);\n+\n+        testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);\n+        testResultSet(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n+    }\n+\n+    /**\n+     * This method tests if ResultSets behave correctly when maxResultBuffer is set to 10000, they all should pass\n+     * (assuming default packetLength = 8000 and responsiveBuffering = full)\n+     * \n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    @Test\n+    public void testResultSetLinearWithFullResponsiveBuffering() throws SQLException {\n+        setResponseBufferingAdaptive(false);\n+\n+        testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);\n+        testResultSet(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n+    }\n+\n+    /**\n+     * This method tests if ResultSet behave correctly when maxResultBuffer is set to 10000, it should throw Exception\n+     * (assuming default packetLength = 8000 and responsiveBuffering = full)\n+     */\n+    @Test\n+    public void testResultSetLinearWithFullResponsiveBufferingException() {\n+        setResponseBufferingAdaptive(false);\n+\n+        Assertions.assertThrows(SQLServerException.class,\n+                () -> testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY));\n+    }\n+\n+    /**\n+     * This method tests if when calling multiple PreparedStatements with their own ResultSet, JDBC driver would behave\n+     * appropriately, assuming maxResultBuffer is set to 10000, it should throw Exception (assuming default packetLength\n+     * = 8000 and responsiveBuffering = adaptive)\n+     */\n+    @Test\n+    public void testPreparedStatementMultipleResultSetsWithAdaptiveResponseBuffering() {\n+        setResponseBufferingAdaptive(true);\n+\n+        Assertions.assertThrows(SQLServerException.class, this::testPreparedStatementWithMultipleResultSets);\n+    }\n+\n+    /**\n+     * This method tests if when calling multiple PreparedStatements with their own ResultSet, JDBC driver would behave\n+     * appropriately, assuming maxResultBuffer is set to 10000, it should throw Exception (assuming default packetLength\n+     * = 8000 and responsiveBuffering = full)\n+     */\n+    @Test\n+    public void testPreparedStatementMultipleResultSetsWithFullResponseBuffering() {\n+        setResponseBufferingAdaptive(false);\n+\n+        Assertions.assertThrows(SQLServerException.class, this::testPreparedStatementWithMultipleResultSets);\n+    }\n+\n+    /**\n+     * This method tests if calling multiple Queries in one Statement works properly. When maxResultBuffer is set to\n+     * 10000, it should work properly (assuming default packetLength = 8000 and responsiveBuffering = adaptive)\n+     * \n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    @Test\n+    public void testTwoQueriesInOneStatementWithAdaptiveResponseBuffering() throws SQLException {\n+        setResponseBufferingAdaptive(true);\n+\n+        testTwoQueriesInOneStatement();\n+    }\n+\n+    /**\n+     * This method tests if calling multiple Queries in one Statement works properly. When maxResultBuffer is set to\n+     * 10000, it should throw Exception (assuming default packetLength = 8000 and responsiveBuffering = full)\n+     */\n+    @Test\n+    public void testTwoQueriesInOneStatementWithFullResponseBuffering() {\n+        setResponseBufferingAdaptive(false);\n+\n+        Assertions.assertThrows(SQLServerException.class, this::testTwoQueriesInOneStatement);\n+    }\n+\n+    /**\n+     * This method tests if all packets from ResultSet are correctly retrieved\n+     *\n+     * @param resultSetType\n+     *        Result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n+     *        <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n+     * @param concurrencyMode\n+     *        Concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or\n+     *        <code>ResultSet.CONCUR_UPDATABLE</code>\n+     *\n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    private void testResultSet(int resultSetType, int concurrencyMode) throws SQLException {\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                Statement statement = connection.createStatement(resultSetType, concurrencyMode)) {\n+            statement.execute(\"SELECT * FROM \" + TEST_TABLE_NAME);\n+            try (ResultSet resultSet = statement.getResultSet()) {\n+                while (resultSet.next()) {}\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method tests if Statements are detached properly, when first one hasn't been completely retrieved and second\n+     * one have been executed\n+     *\n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    private void testPreparedStatementWithMultipleResultSets() throws SQLException {\n+        String selectSQL = \"SELECT * FROM \" + TEST_TABLE_NAME;\n+\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                PreparedStatement statement = connection.prepareStatement(selectSQL);\n+                ResultSet resultSet = statement.executeQuery()) {\n+\n+            try (PreparedStatement secondStatement = connection.prepareStatement(selectSQL);\n+                    ResultSet secondResultSet = secondStatement.executeQuery()) {\n+                while (resultSet.next()) {}\n+\n+                try (PreparedStatement thirdStatement = connection.prepareStatement(selectSQL);\n+                        ResultSet thirdResultSet = thirdStatement.executeQuery()) {\n+                    while (thirdResultSet.next()) {}\n+                    while (secondResultSet.next()) {}\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method tests if ResultSet's are retrieved correctly, when more than one Query is executed inside single\n+     * statement\n+     * \n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    private void testTwoQueriesInOneStatement() throws SQLException {\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                Statement statement = connection.createStatement()) {\n+            statement.execute(\"SELECT * FROM \" + TEST_TABLE_NAME + \";SELECT * FROM \" + TEST_TABLE_NAME);\n+\n+            try (ResultSet resultSet = statement.getResultSet()) {\n+                while (resultSet.next()) {}\n+            }\n+\n+            if (statement.getMoreResults()) {\n+                try (ResultSet totallyNewResultSet = statement.getResultSet()) {\n+                    while (totallyNewResultSet.next()) {}\n+                }\n+            }\n+        }\n+    }\n+\n+    private static String generateRandomString(int precision) {\n+        int leftLimit = 33;\n+        int rightLimit = 126;\n+        Random random = new Random();\n+        return random.ints(leftLimit, rightLimit).limit(precision)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString();\n+    }\n+\n+    private static void setResponseBufferingAdaptive(boolean adaptive) {\n+        String value = adaptive ? \"adaptive\" : \"full\";\n+        connectionString = TestUtils.addOrOverrideProperty(connectionString, \"responseBuffering\", value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f2706904fc349b95b40ed652357ad0a5fa2bcbb"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MzQyNTUxOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/microsoft/sqlserver/jdbc/MaxResultBufferTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMzoyOTo1M1rOHvAkpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMzoyOTo1M1rOHvAkpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NDUwMA==", "bodyText": "Please add more test for different possible values of the connection property, both valid and invalid cases.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r519054500", "createdAt": "2020-11-06T23:29:53Z", "author": {"login": "ulvii"}, "path": "src/test/java/com/microsoft/sqlserver/jdbc/MaxResultBufferTest.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f2706904fc349b95b40ed652357ad0a5fa2bcbb"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzE1MjMxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferCounter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowMjoyOVrOH5VCQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowMjoyOVrOH5VCQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3NTUyMQ==", "bodyText": "Please change to :\nif (logger.isLoggable(Level.SEVERE)) {\n    logger.log(Level.SEVERE, \"MaxResultBuffer exceeded: {0}. Property was set to {1}.\",\n            new Object[] {number, maxResultBuffer});\n}", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r529875521", "createdAt": "2020-11-24T21:02:29Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferCounter.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import java.text.MessageFormat;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+\n+/**\n+ * Implementation of ICounter for 'maxResultBuffer' property.\n+ */\n+public class MaxResultBufferCounter implements ICounter {\n+\n+    private final Logger logger = Logger.getLogger(\"com.microsoft.sqlserver.jdbc.MaxResultBufferCounter\");\n+\n+    private long counter = 0;\n+    private final long maxResultBuffer;\n+\n+    public MaxResultBufferCounter(long maxResultBuffer) {\n+        this.maxResultBuffer = maxResultBuffer;\n+    }\n+\n+    public void increaseCounter(long bytes) throws SQLServerException {\n+        if (maxResultBuffer > 0) {\n+            counter += bytes;\n+            checkForMaxResultBufferOverflow(counter);\n+        }\n+    }\n+\n+    public void resetCounter() {\n+        counter = 0;\n+    }\n+\n+    private void checkForMaxResultBufferOverflow(long number) throws SQLServerException {\n+        if (number > maxResultBuffer) {\n+            logger.log(Level.WARNING, \"MaxResultBuffer exceeded: {0}. Property was set to {1}.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2336d33bcc48670b73fd53d376bd10aa7f3b9e"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzE1NzUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowNDowOVrOH5VFXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowNDowOVrOH5VFXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3NjMxOA==", "bodyText": "if (logger.isLoggable(Level.SEVERE)) {\n    logger.log(Level.SEVERE, ERROR_MESSAGE, new Object[] {input});\n}", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r529876318", "createdAt": "2020-11-24T21:04:09Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import java.lang.management.ManagementFactory;\n+import java.text.MessageFormat;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+\n+/**\n+ * Parser created to parse String value from Connection String to equivalent number of bytes for JDBC Driver to work on.\n+ */\n+public class MaxResultBufferParser {\n+\n+    private static final Logger logger = Logger.getLogger(\"com.microsoft.sqlserver.jdbc.MaxResultBufferParser\");\n+    private static final String[] PERCENT_PHRASES = {\"percent\", \"pct\", \"p\"};\n+    private static final String ERROR_MESSAGE = \"MaxResultBuffer property is badly formatted: {0}.\";\n+\n+    private MaxResultBufferParser() {}\n+\n+    /**\n+     *\n+     * Returns number of bytes for maxResultBuffer property\n+     *\n+     * @param input\n+     *        String value for maxResultProperty provided in Connection String\n+     * @return 'maxResultBuffer' property as number of bytes\n+     * @throws SQLServerException\n+     *         Is Thrown when maxResultProperty's syntax is wrong\n+     */\n+    public static long validateMaxResultBuffer(String input) throws SQLServerException {\n+        String numberString;\n+        long number = -1;\n+\n+        // check for null values and empty String \"\", if so return -1 (default value)\n+        if (StringUtils.isEmpty(input) || input.equals(\"-1\")) {\n+            return number;\n+        }\n+\n+        // check if input is number\n+        if (!StringUtils.isEmpty(input) && input.matches(\"-?\\\\d+(\\\\.\\\\d+)?\")) {\n+            try {\n+                number = Long.parseLong(input);\n+            } catch (NumberFormatException e) {\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2336d33bcc48670b73fd53d376bd10aa7f3b9e"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzE2MDA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowNDo1NFrOH5VG3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowNDo1NFrOH5VG3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3NjcwMQ==", "bodyText": "if (logger.isLoggable(Level.SEVERE)) {\n    logger.log(Level.SEVERE, ERROR_MESSAGE, new Object[] {input});\n}", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r529876701", "createdAt": "2020-11-24T21:04:54Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import java.lang.management.ManagementFactory;\n+import java.text.MessageFormat;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+\n+/**\n+ * Parser created to parse String value from Connection String to equivalent number of bytes for JDBC Driver to work on.\n+ */\n+public class MaxResultBufferParser {\n+\n+    private static final Logger logger = Logger.getLogger(\"com.microsoft.sqlserver.jdbc.MaxResultBufferParser\");\n+    private static final String[] PERCENT_PHRASES = {\"percent\", \"pct\", \"p\"};\n+    private static final String ERROR_MESSAGE = \"MaxResultBuffer property is badly formatted: {0}.\";\n+\n+    private MaxResultBufferParser() {}\n+\n+    /**\n+     *\n+     * Returns number of bytes for maxResultBuffer property\n+     *\n+     * @param input\n+     *        String value for maxResultProperty provided in Connection String\n+     * @return 'maxResultBuffer' property as number of bytes\n+     * @throws SQLServerException\n+     *         Is Thrown when maxResultProperty's syntax is wrong\n+     */\n+    public static long validateMaxResultBuffer(String input) throws SQLServerException {\n+        String numberString;\n+        long number = -1;\n+\n+        // check for null values and empty String \"\", if so return -1 (default value)\n+        if (StringUtils.isEmpty(input) || input.equals(\"-1\")) {\n+            return number;\n+        }\n+\n+        // check if input is number\n+        if (!StringUtils.isEmpty(input) && input.matches(\"-?\\\\d+(\\\\.\\\\d+)?\")) {\n+            try {\n+                number = Long.parseLong(input);\n+            } catch (NumberFormatException e) {\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});\n+                throwNewInvalidMaxResultBufferParameterException(e, input);\n+            }\n+            return adjustMemory(number, 1);\n+        } else {\n+            // check PERCENT_PHRASES\n+            for (String percentPhrase : PERCENT_PHRASES) {\n+                if (input.endsWith(percentPhrase)) {\n+                    numberString = input.substring(0, input.length() - percentPhrase.length());\n+                    try {\n+                        number = Long.parseLong(numberString);\n+                    } catch (NumberFormatException e) {\n+                        logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2336d33bcc48670b73fd53d376bd10aa7f3b9e"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzE2MTM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowNToxM1rOH5VHog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowNToxM1rOH5VHog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3Njg5OA==", "bodyText": "if (logger.isLoggable(Level.SEVERE)) {\n    logger.log(Level.SEVERE, ERROR_MESSAGE, new Object[] {input});\n}", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r529876898", "createdAt": "2020-11-24T21:05:13Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import java.lang.management.ManagementFactory;\n+import java.text.MessageFormat;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+\n+/**\n+ * Parser created to parse String value from Connection String to equivalent number of bytes for JDBC Driver to work on.\n+ */\n+public class MaxResultBufferParser {\n+\n+    private static final Logger logger = Logger.getLogger(\"com.microsoft.sqlserver.jdbc.MaxResultBufferParser\");\n+    private static final String[] PERCENT_PHRASES = {\"percent\", \"pct\", \"p\"};\n+    private static final String ERROR_MESSAGE = \"MaxResultBuffer property is badly formatted: {0}.\";\n+\n+    private MaxResultBufferParser() {}\n+\n+    /**\n+     *\n+     * Returns number of bytes for maxResultBuffer property\n+     *\n+     * @param input\n+     *        String value for maxResultProperty provided in Connection String\n+     * @return 'maxResultBuffer' property as number of bytes\n+     * @throws SQLServerException\n+     *         Is Thrown when maxResultProperty's syntax is wrong\n+     */\n+    public static long validateMaxResultBuffer(String input) throws SQLServerException {\n+        String numberString;\n+        long number = -1;\n+\n+        // check for null values and empty String \"\", if so return -1 (default value)\n+        if (StringUtils.isEmpty(input) || input.equals(\"-1\")) {\n+            return number;\n+        }\n+\n+        // check if input is number\n+        if (!StringUtils.isEmpty(input) && input.matches(\"-?\\\\d+(\\\\.\\\\d+)?\")) {\n+            try {\n+                number = Long.parseLong(input);\n+            } catch (NumberFormatException e) {\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});\n+                throwNewInvalidMaxResultBufferParameterException(e, input);\n+            }\n+            return adjustMemory(number, 1);\n+        } else {\n+            // check PERCENT_PHRASES\n+            for (String percentPhrase : PERCENT_PHRASES) {\n+                if (input.endsWith(percentPhrase)) {\n+                    numberString = input.substring(0, input.length() - percentPhrase.length());\n+                    try {\n+                        number = Long.parseLong(numberString);\n+                    } catch (NumberFormatException e) {\n+                        logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});\n+                        throwNewInvalidMaxResultBufferParameterException(e, numberString);\n+                    }\n+                    return adjustMemoryPercentage(number);\n+                }\n+            }\n+\n+            // check if prefix was supplied\n+            long multiplier = getMultiplier(input);\n+            numberString = input.substring(0, input.length() - 1);\n+\n+            try {\n+                number = Long.parseLong(numberString);\n+            } catch (NumberFormatException e) {\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2336d33bcc48670b73fd53d376bd10aa7f3b9e"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzE2MjYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowNTozMVrOH5VIUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowNTozMVrOH5VIUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3NzA3Mg==", "bodyText": "if (logger.isLoggable(Level.SEVERE)) {\n    logger.log(Level.SEVERE, ERROR_MESSAGE, new Object[] {input});\n}", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r529877072", "createdAt": "2020-11-24T21:05:31Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import java.lang.management.ManagementFactory;\n+import java.text.MessageFormat;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+\n+/**\n+ * Parser created to parse String value from Connection String to equivalent number of bytes for JDBC Driver to work on.\n+ */\n+public class MaxResultBufferParser {\n+\n+    private static final Logger logger = Logger.getLogger(\"com.microsoft.sqlserver.jdbc.MaxResultBufferParser\");\n+    private static final String[] PERCENT_PHRASES = {\"percent\", \"pct\", \"p\"};\n+    private static final String ERROR_MESSAGE = \"MaxResultBuffer property is badly formatted: {0}.\";\n+\n+    private MaxResultBufferParser() {}\n+\n+    /**\n+     *\n+     * Returns number of bytes for maxResultBuffer property\n+     *\n+     * @param input\n+     *        String value for maxResultProperty provided in Connection String\n+     * @return 'maxResultBuffer' property as number of bytes\n+     * @throws SQLServerException\n+     *         Is Thrown when maxResultProperty's syntax is wrong\n+     */\n+    public static long validateMaxResultBuffer(String input) throws SQLServerException {\n+        String numberString;\n+        long number = -1;\n+\n+        // check for null values and empty String \"\", if so return -1 (default value)\n+        if (StringUtils.isEmpty(input) || input.equals(\"-1\")) {\n+            return number;\n+        }\n+\n+        // check if input is number\n+        if (!StringUtils.isEmpty(input) && input.matches(\"-?\\\\d+(\\\\.\\\\d+)?\")) {\n+            try {\n+                number = Long.parseLong(input);\n+            } catch (NumberFormatException e) {\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});\n+                throwNewInvalidMaxResultBufferParameterException(e, input);\n+            }\n+            return adjustMemory(number, 1);\n+        } else {\n+            // check PERCENT_PHRASES\n+            for (String percentPhrase : PERCENT_PHRASES) {\n+                if (input.endsWith(percentPhrase)) {\n+                    numberString = input.substring(0, input.length() - percentPhrase.length());\n+                    try {\n+                        number = Long.parseLong(numberString);\n+                    } catch (NumberFormatException e) {\n+                        logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});\n+                        throwNewInvalidMaxResultBufferParameterException(e, numberString);\n+                    }\n+                    return adjustMemoryPercentage(number);\n+                }\n+            }\n+\n+            // check if prefix was supplied\n+            long multiplier = getMultiplier(input);\n+            numberString = input.substring(0, input.length() - 1);\n+\n+            try {\n+                number = Long.parseLong(numberString);\n+            } catch (NumberFormatException e) {\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});\n+                throwNewInvalidMaxResultBufferParameterException(e, numberString);\n+            }\n+            return adjustMemory(number, multiplier);\n+        }\n+    }\n+\n+    private static void checkForNegativeValue(long value) throws SQLServerException {\n+        if (value <= 0) {\n+            Object[] objectToThrow = new Object[] {value};\n+            MessageFormat form = new MessageFormat(\n+                    SQLServerException.getErrString(\"R_maxResultBufferNegativeParameterValue\"));\n+            logger.log(Level.INFO, SQLServerException.getErrString(\"R_maxResultBufferNegativeParameterValue\"),\n+                    objectToThrow);\n+            throw new SQLServerException(form.format(objectToThrow), new Throwable());\n+        }\n+    }\n+\n+    private static long getMultiplier(String input) throws SQLServerException {\n+        long multiplier = 1;\n+        switch (Character.toUpperCase(input.charAt(input.length() - 1))) {\n+            case 'K':\n+                multiplier = 1_000L;\n+                break;\n+            case 'M':\n+                multiplier = 1_000_000L;\n+                break;\n+            case 'G':\n+                multiplier = 1_000_000_000L;\n+                break;\n+            case 'T':\n+                multiplier = 1_000_000_000_000L;\n+                break;\n+            default:\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2336d33bcc48670b73fd53d376bd10aa7f3b9e"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzE5NDgwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToxNDozN1rOH5Va8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToxNDozN1rOH5Va8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MTg0MA==", "bodyText": "R_maxResultBufferPropertyDescription should describe what maxResultBuffer connection property does, please check  R_useFmtOnlyPropertyDescription for reference.  I'd suggest to create another String resource for MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}. and use R_maxResultBufferPropertyDescription for the actual description of the connection property.", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r529881840", "createdAt": "2020-11-24T21:14:37Z", "author": {"login": "ulvii"}, "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "diffHunk": "@@ -652,5 +652,9 @@ static String getResource(String key) {\n             {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n             {\"R_InvalidCSVQuotes\",\n                     \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},};\n-};\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n+            {\"R_maxResultBufferPropertyDescription\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2336d33bcc48670b73fd53d376bd10aa7f3b9e"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1171, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}