{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNDc0Njkx", "number": 912, "title": "BXC-2532/2533 - Migrate access controls", "bodyText": "https://jira.lib.unc.edu/browse/BXC-2532\nhttps://jira.lib.unc.edu/browse/BXC-2533\nSee the Permissions Migration section of https://confluence.lib.unc.edu/display/RAT/Data+Migration+Planning for details.\n\nMigrates patron access controls for all content object types\n\ntransforms non-role assignment settings (like publication status, inheritance flag) into role assignments.\nunit patron access assignments are moved to their child collections\n\n\nMigrates staff access controls\nAllows the canProcess role to be assigned during ingest.", "createdAt": "2020-03-02T16:16:28Z", "url": "https://github.com/UNC-Libraries/box-c/pull/912", "merged": true, "mergeCommit": {"oid": "439575ebe4175de223c6d6df0c3f68c0ac3071f7"}, "closed": true, "closedAt": "2020-03-04T21:11:21Z", "author": {"login": "bbpennel"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcJwFj1gH2gAyMzgyNDc0NjkxOmFkMjhjMDFhYmJiZjZmZjNkZDVkZmRjOGZjZjY0Y2UyM2MyN2U0MDk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKdJuwAH2gAyMzgyNDc0NjkxOmU1ZjQwYTFjM2UzZTAzNGI1ZjZhMDk5ZmQ0YTE0YTg5YTM1ZjNmMDg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ad28c01abbbf6ff3dd5dfdc8fcf64ce23c27e409", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/UNC-Libraries/box-c/commit/ad28c01abbbf6ff3dd5dfdc8fcf64ce23c27e409", "committedDate": "2020-03-02T16:12:55Z", "message": "Add transformation utility for patron acls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26d5bdf18ef0e92fe46ae43ccdd0f0a1058ad65b", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/UNC-Libraries/box-c/commit/26d5bdf18ef0e92fe46ae43ccdd0f0a1058ad65b", "committedDate": "2020-03-02T16:12:55Z", "message": "Perform patron acl transformations as part of content transformation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47fc170cda6aa35d572116bbffe1b480dfb93c98", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/UNC-Libraries/box-c/commit/47fc170cda6aa35d572116bbffe1b480dfb93c98", "committedDate": "2020-03-02T16:12:55Z", "message": "Allow canProcess role through validation of collections"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7da06fc54cfa016c49c4e1cf5437e50958562a7", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/UNC-Libraries/box-c/commit/f7da06fc54cfa016c49c4e1cf5437e50958562a7", "committedDate": "2020-03-02T16:12:55Z", "message": "Add transformation of staff role assignments. Set default patron assignments for collections when no roles are assigned or inherited"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4029172978c2e6ced7aa9738c36b4bdc42f5daa8", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/UNC-Libraries/box-c/commit/4029172978c2e6ced7aa9738c36b4bdc42f5daa8", "committedDate": "2020-03-02T19:03:28Z", "message": "Fix checkstyle errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDIwNjE5", "url": "https://github.com/UNC-Libraries/box-c/pull/912#pullrequestreview-369020619", "createdAt": "2020-03-04T18:32:19Z", "commit": {"oid": "4029172978c2e6ced7aa9738c36b4bdc42f5daa8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODozMjoxOVrOFx4wTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODozMjoxOVrOFx4wTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1NDQxNA==", "bodyText": "missing last parameter. Also, describe what the parameters are.", "url": "https://github.com/UNC-Libraries/box-c/pull/912#discussion_r387854414", "createdAt": "2020-03-04T18:32:19Z", "author": {"login": "bbpennel"}, "path": "migration-util/src/main/java/edu/unc/lib/dcr/migration/content/ACLTransformationHelpers.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Copyright 2008 The University of North Carolina at Chapel Hill\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package edu.unc.lib.dcr.migration.content;\n+\n+import static edu.unc.lib.dl.acl.util.AccessPrincipalConstants.AUTHENTICATED_PRINC;\n+import static edu.unc.lib.dl.acl.util.AccessPrincipalConstants.PUBLIC_PRINC;\n+import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.jena.rdf.model.Model;\n+import org.apache.jena.rdf.model.Property;\n+import org.apache.jena.rdf.model.Resource;\n+import org.apache.jena.rdf.model.Statement;\n+import org.apache.jena.rdf.model.StmtIterator;\n+import org.apache.jena.vocabulary.RDF;\n+import org.apache.solr.common.StringUtils;\n+import org.slf4j.Logger;\n+\n+import edu.unc.lib.dcr.migration.fcrepo3.ContentModelHelper.Bxc3UserRole;\n+import edu.unc.lib.dcr.migration.fcrepo3.ContentModelHelper.CDRProperty;\n+import edu.unc.lib.dl.fcrepo4.PIDs;\n+import edu.unc.lib.dl.fedora.PID;\n+import edu.unc.lib.dl.rdf.Cdr;\n+import edu.unc.lib.dl.rdf.CdrAcl;\n+\n+/**\n+ * Helper methods for transforming content object access control settings\n+ * from bxc3 to box5 expectations\n+ *\n+ * @author bbpennel\n+ */\n+public class ACLTransformationHelpers {\n+\n+    private static final Logger log = getLogger(ACLTransformationHelpers.class);\n+\n+    public final static String BXC3_PUBLIC_GROUP = \"public\";\n+    public final static String BXC3_AUTHENTICATED_GROUP = \"authenticated\";\n+\n+    private static final Map<PID, Model> unitPatronAccessCache = new HashMap<>();\n+\n+    private ACLTransformationHelpers() {\n+    }\n+\n+    /**\n+     * Transforms the bxc3 patron access control settings into bxc5\n+     *\n+     * Patron access settings found on an admin unit will be applied to its children\n+     * collections instead, but only if the children do not have locally defined\n+     * settings for the same groups.\n+     *\n+     * @param bxc3Resc\n+     * @param bxc5Resc\n+     * @param parentPid bxc5 PID of the parent\n+     */\n+    public static void transformPatronAccess(Resource bxc3Resc, Resource bxc5Resc, PID parentPid) {\n+        // For admin units, cache patron access settings so they can be used for children instead\n+        Resource destResc;\n+        if (bxc5Resc.hasProperty(RDF.type, Cdr.AdminUnit)) {\n+            Model unitModel = createDefaultModel();\n+            PID unitPid = PIDs.get(bxc5Resc.getURI());\n+            destResc = unitModel.getResource(unitPid.getRepositoryPath());\n+            unitPatronAccessCache.put(unitPid, unitModel);\n+        } else {\n+            destResc = bxc5Resc;\n+        }\n+\n+        // Migrate existing embargoes\n+        if (bxc3Resc.hasProperty(CDRProperty.embargoUntil.getProperty())) {\n+            destResc.addLiteral(CdrAcl.embargoUntil,\n+                    bxc3Resc.getProperty(CDRProperty.embargoUntil.getProperty()).getString());\n+        }\n+\n+        // Calculate the most restrictive roles assigned to each patron group\n+        Property[] patronRoles = calculatePatronRoles(bxc3Resc);\n+        Property everyoneRole = patronRoles[0];\n+        Property authRole = patronRoles[1];\n+\n+        // assign the patron groups roles if they were specified\n+        if (everyoneRole != null) {\n+            destResc.addLiteral(everyoneRole, PUBLIC_PRINC);\n+        }\n+        if (authRole != null) {\n+            destResc.addLiteral(authRole, AUTHENTICATED_PRINC);\n+        }\n+\n+        // Merge in access settings from parent if present in the cache\n+        mergeParentPatronAcls(parentPid, destResc, everyoneRole, authRole);\n+\n+        // For collections if no roles specified or inherited, default to open permissions\n+        // as they would normally inherit from the root in bxc3.\n+        if (bxc5Resc.hasProperty(RDF.type, Cdr.Collection)) {\n+            if (!(bxc5Resc.hasProperty(CdrAcl.canViewMetadata)\n+                    || bxc5Resc.hasProperty(CdrAcl.canViewAccessCopies)\n+                    || bxc5Resc.hasProperty(CdrAcl.canViewOriginals)\n+                    || bxc5Resc.hasProperty(CdrAcl.none))) {\n+                destResc.addLiteral(CdrAcl.canViewOriginals, PUBLIC_PRINC);\n+                destResc.addLiteral(CdrAcl.canViewOriginals, AUTHENTICATED_PRINC);\n+            }\n+        }\n+    }\n+\n+    private static Property[] calculatePatronRoles(Resource bxc3Resc) {\n+        if (bxc3Resc.hasLiteral(CDRProperty.isPublished.getProperty(), \"no\")\n+                || bxc3Resc.hasLiteral(CDRProperty.allowIndexing.getProperty(), \"no\")) {\n+            return new Property[] { CdrAcl.none, CdrAcl.none };\n+        }\n+\n+        Property everyoneRole = null;\n+        Property authRole = null;\n+\n+        StmtIterator stmtIt = bxc3Resc.listProperties();\n+        while (stmtIt.hasNext()) {\n+            Statement stmt = stmtIt.next();\n+            if (!stmt.getObject().isLiteral()) {\n+                continue;\n+            }\n+\n+            String objectVal = stmt.getObject().asLiteral().getLexicalForm();\n+            if (BXC3_PUBLIC_GROUP.equals(objectVal)) {\n+                everyoneRole = mostRestrictiveRole(everyoneRole, stmt.getPredicate());\n+            } else if (BXC3_AUTHENTICATED_GROUP.equals(objectVal)) {\n+                authRole = mostRestrictiveRole(authRole, stmt.getPredicate());\n+            }\n+        }\n+\n+        boolean inherit = true;\n+        if (bxc3Resc.hasProperty(CDRProperty.inheritPermissions.getProperty())) {\n+            Statement stmt = bxc3Resc.getProperty(CDRProperty.inheritPermissions.getProperty());\n+            inherit = Boolean.parseBoolean(stmt.getString());\n+        }\n+\n+        if (!inherit) {\n+            if (everyoneRole == null) {\n+                everyoneRole = CdrAcl.none;\n+            }\n+            if (authRole == null) {\n+                authRole = everyoneRole;\n+            }\n+        }\n+\n+        return new Property[] { everyoneRole, authRole };\n+    }\n+\n+    private static Property mostRestrictiveRole(Property existingRole, Property bxc3Role) {\n+        // Role can't become more restrictive via role property\n+        if (CdrAcl.canViewMetadata.equals(existingRole) || CdrAcl.none.equals(existingRole)) {\n+            return existingRole;\n+        }\n+\n+        if (!Bxc3UserRole.metadataPatron.equals(bxc3Role)\n+                && !Bxc3UserRole.accessCopiesPatron.equals(bxc3Role)\n+                && !Bxc3UserRole.patron.equals(bxc3Role)) {\n+            return existingRole;\n+        }\n+\n+        if (Bxc3UserRole.metadataPatron.equals(bxc3Role)) {\n+            return CdrAcl.canViewMetadata;\n+        }\n+        if (Bxc3UserRole.accessCopiesPatron.equals(bxc3Role)) {\n+            return CdrAcl.canViewAccessCopies;\n+        }\n+        if (Bxc3UserRole.patron.equals(bxc3Role)) {\n+            if (CdrAcl.canViewAccessCopies.equals(existingRole)) {\n+                return existingRole;\n+            } else {\n+                return CdrAcl.canViewOriginals;\n+            }\n+        }\n+\n+        return existingRole;\n+    }\n+\n+    private static void mergeParentPatronAcls(PID parentPid, Resource destResc, Property everyoneRole,\n+            Property authRole) {\n+        // Merge in access settings from parent if present in the cache\n+        Model parentUnitModel = unitPatronAccessCache.get(parentPid);\n+        if (parentUnitModel != null) {\n+            Resource parentUnitResc = parentUnitModel.getResource(parentPid.getRepositoryPath());\n+            if (!destResc.hasProperty(CdrAcl.embargoUntil) && parentUnitResc.hasProperty(CdrAcl.embargoUntil)) {\n+                destResc.addLiteral(CdrAcl.embargoUntil,\n+                        parentUnitResc.getProperty(CdrAcl.embargoUntil).getLiteral().getString());\n+            }\n+            if (everyoneRole == null) {\n+                StmtIterator it = parentUnitModel.listStatements(parentUnitResc, null, PUBLIC_PRINC);\n+                if (it.hasNext()) {\n+                    Statement roleStmt = it.next();\n+                    destResc.addLiteral(roleStmt.getPredicate(), PUBLIC_PRINC);\n+                    it.close();\n+                }\n+            }\n+            if (authRole == null) {\n+                StmtIterator it = parentUnitModel.listStatements(parentUnitResc, null, AUTHENTICATED_PRINC);\n+                if (it.hasNext()) {\n+                    Statement roleStmt = it.next();\n+                    destResc.addLiteral(roleStmt.getPredicate(), AUTHENTICATED_PRINC);\n+                    it.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Transforms BXC3 staff role assignments to BXC5 staff role assignments\n+     *\n+     * @param bxc3Resc\n+     * @param bxc5Resc\n+     */\n+    public static void transformStaffRoles(Resource bxc3Resc, Resource bxc5Resc) {\n+        Set<String> principalsAssigned = new HashSet<>();\n+        // Order matters here, as a principal can only be assigned a single role, so we\n+        // prioritize the higher permission granting role first.\n+        mapStaffRole(Bxc3UserRole.curator, CdrAcl.canManage, bxc3Resc, bxc5Resc, principalsAssigned);\n+        mapStaffRole(Bxc3UserRole.processor, CdrAcl.canProcess, bxc3Resc, bxc5Resc, principalsAssigned);\n+        mapStaffRole(Bxc3UserRole.metadataEditor, CdrAcl.canDescribe, bxc3Resc, bxc5Resc, principalsAssigned);\n+        mapStaffRole(Bxc3UserRole.ingester, CdrAcl.canIngest, bxc3Resc, bxc5Resc, principalsAssigned);\n+        mapStaffRole(Bxc3UserRole.observer, CdrAcl.canAccess, bxc3Resc, bxc5Resc, principalsAssigned);\n+    }\n+\n+    /**\n+     * Map all values of bxc3 user role to a bxc5 role, unless the principal is invalid\n+     *\n+     * @param bxc3Role\n+     * @param bxc5Role\n+     * @param bxc3Resc\n+     * @param bxc5Resc", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4029172978c2e6ced7aa9738c36b4bdc42f5daa8"}, "originalPosition": 243}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5f40a1c3e3e034b5f6a099fd4a14a89a35f3f08", "author": {"user": {"login": "bbpennel", "name": "Ben Pennell"}}, "url": "https://github.com/UNC-Libraries/box-c/commit/e5f40a1c3e3e034b5f6a099fd4a14a89a35f3f08", "committedDate": "2020-03-04T20:43:12Z", "message": "Update ACLTransformationHelpers.java"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2298, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}