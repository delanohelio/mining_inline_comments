{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0NzEzMDcz", "number": 846, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzo1NzoxNVrOEdPA_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyNDoyNVrOEe7XNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDkwMTc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzo1NzoxNVrOHIRndA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzo1NzoxNVrOHIRndA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQzOTI4NA==", "bodyText": "maybe SimpleBatchJobFactory?", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478439284", "createdAt": "2020-08-27T13:57:15Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.BatchJob;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.UnzipHelper;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.nls.NLS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link UnzipHelper#getSupportedFileExtensions()}.\n+ */\n+public class VirtualFileExtractionJob extends BatchJob {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDkwNDczOnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzo1Nzo1MlrOHIRpTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwODowMTozOVrOHIugjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQzOTc1OA==", "bodyText": "this lambda is waaaay too long", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478439758", "createdAt": "2020-08-27T13:57:52Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.BatchJob;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.UnzipHelper;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.nls.NLS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link UnzipHelper#getSupportedFileExtensions()}.\n+ */\n+public class VirtualFileExtractionJob extends BatchJob {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static UnzipHelper unzipHelper;\n+\n+    VirtualFileExtractionJob(ProcessContext process) {\n+        super(process);\n+    }\n+\n+    @Override\n+    public void execute() throws Exception {\n+        VirtualFile sourceFile = process.require(VirtualFileExtractionJobFactory.SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory =\n+                VirtualFileExtractionJobFactory.DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting =\n+                process.require(VirtualFileExtractionJobFactory.OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            try {\n+                UnzipHelper.unzip(tempFile,\n+                                  null,\n+                                  (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                      VirtualFile targetFile =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODkxMjY1NA==", "bodyText": "Lambda params come from sirius.biz.util.ArchiveHelper.ArchiveExtractCallback#call. Maybe an option would be to instantiate a new instance of an inner class instead of using this lambda?", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478912654", "createdAt": "2020-08-28T08:01:39Z", "author": {"login": "bwiedmann"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.BatchJob;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.UnzipHelper;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.nls.NLS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link UnzipHelper#getSupportedFileExtensions()}.\n+ */\n+public class VirtualFileExtractionJob extends BatchJob {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static UnzipHelper unzipHelper;\n+\n+    VirtualFileExtractionJob(ProcessContext process) {\n+        super(process);\n+    }\n+\n+    @Override\n+    public void execute() throws Exception {\n+        VirtualFile sourceFile = process.require(VirtualFileExtractionJobFactory.SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory =\n+                VirtualFileExtractionJobFactory.DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting =\n+                process.require(VirtualFileExtractionJobFactory.OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            try {\n+                UnzipHelper.unzip(tempFile,\n+                                  null,\n+                                  (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                      VirtualFile targetFile =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQzOTc1OA=="}, "originalCommit": {"oid": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDkwOTQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzo1ODo1NlrOHIRsZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzo1ODo1NlrOHIRsZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ0MDU1MQ==", "bodyText": "i'd output the progrss just as title and also maybe ratelimit this (TaskContext should have a shouldUpdateTitle or the like)", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478440551", "createdAt": "2020-08-27T13:58:56Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.BatchJob;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.UnzipHelper;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.nls.NLS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link UnzipHelper#getSupportedFileExtensions()}.\n+ */\n+public class VirtualFileExtractionJob extends BatchJob {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static UnzipHelper unzipHelper;\n+\n+    VirtualFileExtractionJob(ProcessContext process) {\n+        super(process);\n+    }\n+\n+    @Override\n+    public void execute() throws Exception {\n+        VirtualFile sourceFile = process.require(VirtualFileExtractionJobFactory.SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory =\n+                VirtualFileExtractionJobFactory.DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting =\n+                process.require(VirtualFileExtractionJobFactory.OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            try {\n+                UnzipHelper.unzip(tempFile,\n+                                  null,\n+                                  (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                      VirtualFile targetFile =\n+                                              vfs.resolve(vfs.makePath(targetDirectory.name(), filePath));\n+                                      if (targetFile.exists() && !shouldOverwriteExisting) {\n+                                          process.log(ProcessLog.info()\n+                                                                .withMessage(NLS.fmtr(\n+                                                                        \"VirtualFileExtractionJob.skippingOverwrite\")\n+                                                                                .set(\"targetPath\", targetFile.path())\n+                                                                                .format()));\n+                                          return false;\n+                                      }\n+\n+                                      try {\n+                                          if (targetFile.exists() && shouldOverwriteExisting) {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.extractingFile\")\n+                                                                                    .set(\"filePath\", filePath)\n+                                                                                    .set(\"targetPath\",\n+                                                                                         targetFile.path())\n+                                                                                    .set(\"fileSize\",\n+                                                                                         NLS.formatSize(data.size()))\n+                                                                                    .format()));\n+                                          } else {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.overwritingFile\")\n+                                                                                    .set(\"filePath\", filePath)\n+                                                                                    .set(\"targetPath\",\n+                                                                                         targetFile.path())\n+                                                                                    .set(\"fileSize\",\n+                                                                                         NLS.formatSize(data.size()))\n+                                                                                    .format()));\n+                                          }\n+\n+                                          targetFile.consumeStream(data.openStream(), data.size());\n+                                      } catch (IOException e) {\n+                                          process.handle(e);\n+                                      }\n+\n+                                      process.log(ProcessLog.info()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDkxMzE2OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJobFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzo1OTo0NVrOHIRumQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzo1OTo0NVrOHIRumQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ0MTExMw==", "bodyText": "private", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478441113", "createdAt": "2020-08-27T13:59:45Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJobFactory.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.JobCategory;\n+import sirius.biz.jobs.batch.BatchJob;\n+import sirius.biz.jobs.batch.DefaultBatchProcessFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.util.UnzipHelper;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Register;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Provides a factory for file extraction.\n+ */\n+@Register\n+public class VirtualFileExtractionJobFactory extends DefaultBatchProcessFactory {\n+\n+    public static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDkxNjY4OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJobFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDowMDoyOVrOHIRwyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDowMDoyOVrOHIRwyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ0MTY3Mg==", "bodyText": "s.a. SimpleBatchJobFactory", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478441672", "createdAt": "2020-08-27T14:00:29Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJobFactory.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.JobCategory;\n+import sirius.biz.jobs.batch.BatchJob;\n+import sirius.biz.jobs.batch.DefaultBatchProcessFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.util.UnzipHelper;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Register;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Provides a factory for file extraction.\n+ */\n+@Register\n+public class VirtualFileExtractionJobFactory extends DefaultBatchProcessFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDkyMDYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDowMToyMlrOHIRzLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDowMToyMlrOHIRzLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ0MjI4NA==", "bodyText": "document why this can be null and how to handle this..", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478442284", "createdAt": "2020-08-27T14:01:22Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and unzip archive files like zip, 7z, tar, ...\n+ */\n+public class UnzipHelper {\n+\n+    private UnzipHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file\n+     *\n+     * @param tmpFile           the archive file\n+     * @param filter            will be called for each archive item. {@code unzipItemCallback} will be only called for\n+     *                          this item if this filter unzipItemCallback\n+     *                          returns true\n+     * @param unzipItemCallback will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void unzip(File tmpFile, Function<String, Boolean> filter, UnzipItemCallback unzipItemCallback)\n+            throws IOException {\n+        try {\n+            initSevenZipLib();\n+        } catch (SevenZipNativeInitializationException e) {\n+            throw new IOException(NLS.fmtr(\"XMLImporter.sevenZipInitFailed\").set(\"details\", e.getMessage()).format());\n+        }\n+\n+        try (RandomAccessFile randomAccessFile = new RandomAccessFile(tmpFile, \"r\")) {\n+            RandomAccessFileInStream inputStream = new RandomAccessFileInStream(randomAccessFile);\n+            try (IInArchive archive = SevenZip.openInArchive(null, inputStream)) {\n+                archive.extract(getCompleteArchiveIndices(archive),\n+                                false,\n+                                new MyExtractCallback(archive, filter, unzipItemCallback));\n+            }\n+        }\n+    }\n+\n+    private static void initSevenZipLib() throws SevenZipNativeInitializationException {\n+        if (SevenZip.getUsedPlatform() == null) {\n+            SevenZip.initSevenZipFromPlatformJAR();\n+        }\n+    }\n+\n+    @Nonnull\n+    private static int[] getCompleteArchiveIndices(@Nonnull IInArchive archive) throws SevenZipException {\n+        // could be done as a one-liner with Guava, but this one is about 10x faster\n+        int[] indices = new int[archive.getNumberOfItems()];\n+        for (int i = 0; i < indices.length; i++) {\n+            indices[i] = i;\n+        }\n+        return indices;\n+    }\n+\n+    /**\n+     * Defines a callback interface used during archive extraction.\n+     */\n+    public interface UnzipItemCallback {\n+\n+        /**\n+         * Defines a method called for each item being extracted from an archive.\n+         *\n+         * @param status              the extract result\n+         * @param data                the raw data being exported\n+         * @param fileName            file name as defined in the archive\n+         * @param filesProcessedSoFar amount of files processed in the progress\n+         * @param bytesProcessedSoFar amount of bytes processed in the progress\n+         * @param totalBytes          total amount of bytes processed in the progress\n+         * @return <tt>true</tt> to continue with extraction or <tt>false</tt> to abort\n+         */\n+        boolean call(ExtractOperationResult status,\n+                     @Nullable ByteSource data,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDkzMDE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDowMzo0M1rOHIR5XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDowMzo0M1rOHIR5XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ0Mzg2OA==", "bodyText": "also check TaskContext.isActive every now and then?", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478443868", "createdAt": "2020-08-27T14:03:43Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and unzip archive files like zip, 7z, tar, ...\n+ */\n+public class UnzipHelper {\n+\n+    private UnzipHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file\n+     *\n+     * @param tmpFile           the archive file\n+     * @param filter            will be called for each archive item. {@code unzipItemCallback} will be only called for\n+     *                          this item if this filter unzipItemCallback\n+     *                          returns true\n+     * @param unzipItemCallback will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void unzip(File tmpFile, Function<String, Boolean> filter, UnzipItemCallback unzipItemCallback)\n+            throws IOException {\n+        try {\n+            initSevenZipLib();\n+        } catch (SevenZipNativeInitializationException e) {\n+            throw new IOException(NLS.fmtr(\"XMLImporter.sevenZipInitFailed\").set(\"details\", e.getMessage()).format());\n+        }\n+\n+        try (RandomAccessFile randomAccessFile = new RandomAccessFile(tmpFile, \"r\")) {\n+            RandomAccessFileInStream inputStream = new RandomAccessFileInStream(randomAccessFile);\n+            try (IInArchive archive = SevenZip.openInArchive(null, inputStream)) {\n+                archive.extract(getCompleteArchiveIndices(archive),\n+                                false,\n+                                new MyExtractCallback(archive, filter, unzipItemCallback));\n+            }\n+        }\n+    }\n+\n+    private static void initSevenZipLib() throws SevenZipNativeInitializationException {\n+        if (SevenZip.getUsedPlatform() == null) {\n+            SevenZip.initSevenZipFromPlatformJAR();\n+        }\n+    }\n+\n+    @Nonnull\n+    private static int[] getCompleteArchiveIndices(@Nonnull IInArchive archive) throws SevenZipException {\n+        // could be done as a one-liner with Guava, but this one is about 10x faster\n+        int[] indices = new int[archive.getNumberOfItems()];\n+        for (int i = 0; i < indices.length; i++) {\n+            indices[i] = i;\n+        }\n+        return indices;\n+    }\n+\n+    /**\n+     * Defines a callback interface used during archive extraction.\n+     */\n+    public interface UnzipItemCallback {\n+\n+        /**\n+         * Defines a method called for each item being extracted from an archive.\n+         *\n+         * @param status              the extract result\n+         * @param data                the raw data being exported\n+         * @param fileName            file name as defined in the archive\n+         * @param filesProcessedSoFar amount of files processed in the progress\n+         * @param bytesProcessedSoFar amount of bytes processed in the progress\n+         * @param totalBytes          total amount of bytes processed in the progress\n+         * @return <tt>true</tt> to continue with extraction or <tt>false</tt> to abort\n+         */\n+        boolean call(ExtractOperationResult status,\n+                     @Nullable ByteSource data,\n+                     String fileName,\n+                     long filesProcessedSoFar,\n+                     long bytesProcessedSoFar,\n+                     long totalBytes);\n+    }\n+\n+    private static class MyExtractCallback implements IArchiveExtractCallback {\n+\n+        private final IInArchive inArchive;\n+        private final Function<String, Boolean> filter;\n+        private final UnzipItemCallback unzipItemCallback;\n+        private ByteArrayOutputStream buffer;\n+        private boolean skipExtraction;\n+        private boolean stop;\n+        private String filePath;\n+        private long filesProcessedSoFar;\n+        private long bytesProcessedSoFar;\n+        private long totalBytes;\n+\n+        MyExtractCallback(IInArchive inArchive, Function<String, Boolean> filter, UnzipItemCallback unzipItemCallback) {\n+            this.inArchive = inArchive;\n+            this.filter = filter;\n+            this.unzipItemCallback = unzipItemCallback;\n+        }\n+\n+        @Override\n+        public ISequentialOutStream getStream(int index, ExtractAskMode extractAskMode) throws SevenZipException {\n+            if (stop || extractAskMode != ExtractAskMode.EXTRACT) {\n+                return null;\n+            }\n+\n+            Boolean isFolder = (Boolean) inArchive.getProperty(index, PropID.IS_FOLDER);\n+            filePath = (String) inArchive.getProperty(index, PropID.PATH);\n+            String fileName = Files.getFilenameAndExtension(filePath);\n+            Integer attributes = (Integer) inArchive.getProperty(index, PropID.ATTRIBUTES);\n+\n+            skipExtraction = false;\n+            if (isFolder != null) {\n+                skipExtraction = isFolder;\n+            }\n+            if (attributes != null) {\n+                skipExtraction |= (attributes & PropID.AttributesBitMask.FILE_ATTRIBUTE_HIDDEN) != 0;\n+            }\n+            if (filePath != null) {\n+                skipExtraction |= filePath.startsWith(\"__MACOSX\");\n+                if (filter != null) {\n+                    skipExtraction |= !filter.apply(filePath);\n+                }\n+            }\n+            if (fileName != null) {\n+                // need to filter hidden files (starting with dot), because some tar implementations create\n+                // hidden index files (ending with xml, too)\n+                skipExtraction |= fileName.startsWith(\".\");\n+            }\n+\n+            if (skipExtraction) {\n+                return null;\n+            }\n+\n+            filePath = fixEncodingProblems(filePath, (String) inArchive.getProperty(index, PropID.HOST_OS));\n+\n+            buffer = new ByteArrayOutputStream();\n+            return data -> {\n+                try {\n+                    buffer.write(data);\n+                    return data.length;\n+                } catch (IOException e) {\n+                    throw new SevenZipException(e);\n+                }\n+            };\n+        }\n+\n+        @Nonnull\n+        private String fixEncodingProblems(String filePath, String hostOS) {\n+            String newFilePath = fixWindowsEncoding(filePath, hostOS);\n+            newFilePath = fixOtherStrangeBug(newFilePath);\n+            return newFilePath;\n+        }\n+\n+        @Nonnull\n+        private String fixWindowsEncoding(@Nonnull String filePath, String hostOS) {\n+            byte[] filePathBytes = filePath.getBytes(StandardCharsets.UTF_8);\n+\n+            if (!\"fat\".equalsIgnoreCase(hostOS)) {\n+                // Windows writes FAT as \"Host OS\" in zip files.\n+                // We expect this behaviour only on zip files that were created on Windows.\n+                return filePath;\n+            }\n+            for (int i = 0; i < filePathBytes.length - 1; i++) {\n+                // Windows saves zip entry file paths in IBM437 Codepage,\n+                // the 7z lib interpretates them as Unicode code points and we retrieve them in UTF-8.\n+                //\n+                // This way\n+                // ... special characters in IBM437 (80..bf) become Control Characters (c2 80..9f)\n+                //     or other special characters (c2 a0..bf) in UTF-8\n+                // ... special characters in IBM437 (c0..ff) become other special characters (c3 80..bf) in UTF-8\n+                //\n+                // We cannot safely distinguish whether special characters are an encoding problem or are there in purpose,\n+                // but we can search for UTF-8 control characters (c2 80..9f) that usually aren't present in file names.\n+                boolean hasEncodingProblem = filePathBytes[i] == (byte) 0xc2\n+                                             && filePathBytes[i + 1] >= (byte) 0x80\n+                                             && filePathBytes[i + 1] <= (byte) 0x9f;\n+                // detect \u00df (IBM437 e1) that comes as \u00e1 (UTF-8 c3 a1)\n+                hasEncodingProblem |= filePathBytes[i] == (byte) 0xc3 && filePathBytes[i + 1] == (byte) 0xa1;\n+\n+                if (hasEncodingProblem) {\n+                    try {\n+                        // the string has an encoding error with very very very high probability, repair it...\n+                        return new String(filePath.getBytes(StandardCharsets.ISO_8859_1), \"IBM437\");\n+                    } catch (UnsupportedEncodingException e) {\n+                        Exceptions.ignore(e);\n+                        break;\n+                    }\n+                }\n+            }\n+            return filePath;\n+        }\n+\n+        @Nonnull\n+        @SuppressWarnings(\"squid:S1067\")\n+        @Explain(\"Reducing operators won't increase code visibility\")\n+        private String fixOtherStrangeBug(@Nonnull String filePath) {\n+            byte[] filePathBytes = filePath.getBytes(StandardCharsets.UTF_8);\n+            for (int i = 0; i < filePathBytes.length - 3; i++) {\n+                // The bug interpretates UTF-8 as ISO-8859-1 (which doubles the number of characters)\n+                // and converts them back to UTF-8.\n+                // This way all possible 2-byte UTF-8 bytes (c0..df 80..bf) become 4 bytes: (c3 80..9f c2 80..bf)\n+                if (filePathBytes[i] == (byte) 0xc3\n+                    && filePathBytes[i + 1] >= (byte) 0x80\n+                    && filePathBytes[i + 1] <= (byte) 0x9f\n+                    && filePathBytes[i + 2] == (byte) 0xc2\n+                    && filePathBytes[i + 3] >= (byte) 0x80\n+                    && filePathBytes[i + 3] <= (byte) 0xbf) {\n+                    // the string has an encoding error with very high probability, repair it...\n+                    return new String(filePath.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8);\n+                }\n+            }\n+            return filePath;\n+        }\n+\n+        @Override\n+        public void prepareOperation(ExtractAskMode extractAskMode) throws SevenZipException {\n+            // do nothing\n+        }\n+\n+        @Override\n+        public void setOperationResult(ExtractOperationResult extractOperationResult) throws SevenZipException {\n+            if (stop || skipExtraction) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1"}, "originalPosition": 284}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTMwNzIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToyNTo1MlrOHIVlgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToyNTo1MlrOHIVlgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwNDMyMA==", "bodyText": "IDE missing auto EOF at file end", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478504320", "createdAt": "2020-08-27T15:25:52Z", "author": {"login": "idlira"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.BatchJob;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.UnzipHelper;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.nls.NLS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link UnzipHelper#getSupportedFileExtensions()}.\n+ */\n+public class VirtualFileExtractionJob extends BatchJob {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static UnzipHelper unzipHelper;\n+\n+    VirtualFileExtractionJob(ProcessContext process) {\n+        super(process);\n+    }\n+\n+    @Override\n+    public void execute() throws Exception {\n+        VirtualFile sourceFile = process.require(VirtualFileExtractionJobFactory.SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory =\n+                VirtualFileExtractionJobFactory.DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting =\n+                process.require(VirtualFileExtractionJobFactory.OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            try {\n+                UnzipHelper.unzip(tempFile,\n+                                  null,\n+                                  (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                      VirtualFile targetFile =\n+                                              vfs.resolve(vfs.makePath(targetDirectory.name(), filePath));\n+                                      if (targetFile.exists() && !shouldOverwriteExisting) {\n+                                          process.log(ProcessLog.info()\n+                                                                .withMessage(NLS.fmtr(\n+                                                                        \"VirtualFileExtractionJob.skippingOverwrite\")\n+                                                                                .set(\"targetPath\", targetFile.path())\n+                                                                                .format()));\n+                                          return false;\n+                                      }\n+\n+                                      try {\n+                                          if (targetFile.exists() && shouldOverwriteExisting) {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.extractingFile\")\n+                                                                                    .set(\"filePath\", filePath)\n+                                                                                    .set(\"targetPath\",\n+                                                                                         targetFile.path())\n+                                                                                    .set(\"fileSize\",\n+                                                                                         NLS.formatSize(data.size()))\n+                                                                                    .format()));\n+                                          } else {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.overwritingFile\")\n+                                                                                    .set(\"filePath\", filePath)\n+                                                                                    .set(\"targetPath\",\n+                                                                                         targetFile.path())\n+                                                                                    .set(\"fileSize\",\n+                                                                                         NLS.formatSize(data.size()))\n+                                                                                    .format()));\n+                                          }\n+\n+                                          targetFile.consumeStream(data.openStream(), data.size());\n+                                      } catch (IOException e) {\n+                                          process.handle(e);\n+                                      }\n+\n+                                      process.log(ProcessLog.info()\n+                                                            .withMessage(NLS.fmtr(\"VirtualFileExtractionJob.progress\")\n+                                                                            .set(\"status\", status)\n+                                                                            .set(\"filesProcessedSoFar\",\n+                                                                                 filesProcessedSoFar)\n+                                                                            .set(\"dataProcessedSoFar\",\n+                                                                                 NLS.formatSize(bytesProcessedSoFar))\n+                                                                            .set(\"sizeTotal\",\n+                                                                                 NLS.formatSize(totalBytes))\n+                                                                            .format()));\n+                                      return true;\n+                                  });\n+            } catch (IOException e) {\n+                process.handle(e);\n+            } finally {\n+                Files.delete(tempFile);\n+            }\n+        });\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9a072635ab27d6a26f00bf5dfc813d3f3d9a9d9"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTMxNjIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToyNzozM1rOHIVrPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToyNzozM1rOHIVrPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwNTc4OQ==", "bodyText": "rename to ArchiveHelper?\nsince we handle several archive types and probably want to build archives as well (not only extract)", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478505789", "createdAt": "2020-08-27T15:27:33Z", "author": {"login": "idlira"}, "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and unzip archive files like zip, 7z, tar, ...\n+ */\n+public class UnzipHelper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "072fc712ae060c81a07f6a0f64bd2d8118ec5624"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTMxODg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToyODoxMVrOHIVs-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToyODoxMVrOHIVs-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwNjIzNA==", "bodyText": "rename to extract", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478506234", "createdAt": "2020-08-27T15:28:11Z", "author": {"login": "idlira"}, "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and unzip archive files like zip, 7z, tar, ...\n+ */\n+public class UnzipHelper {\n+\n+    private UnzipHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file\n+     *\n+     * @param tmpFile           the archive file\n+     * @param filter            will be called for each archive item. {@code unzipItemCallback} will be only called for\n+     *                          this item if this filter unzipItemCallback\n+     *                          returns true\n+     * @param unzipItemCallback will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void unzip(File tmpFile, Function<String, Boolean> filter, UnzipItemCallback unzipItemCallback)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "072fc712ae060c81a07f6a0f64bd2d8118ec5624"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTMyMzMxOnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToyOTowOFrOHIVvtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToyOTowOFrOHIVvtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwNjkzMw==", "bodyText": "rename to ArchiveExtractCallback?", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478506933", "createdAt": "2020-08-27T15:29:08Z", "author": {"login": "idlira"}, "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and unzip archive files like zip, 7z, tar, ...\n+ */\n+public class UnzipHelper {\n+\n+    private UnzipHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file\n+     *\n+     * @param tmpFile           the archive file\n+     * @param filter            will be called for each archive item. {@code unzipItemCallback} will be only called for\n+     *                          this item if this filter unzipItemCallback\n+     *                          returns true\n+     * @param unzipItemCallback will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void unzip(File tmpFile, Function<String, Boolean> filter, UnzipItemCallback unzipItemCallback)\n+            throws IOException {\n+        try {\n+            initSevenZipLib();\n+        } catch (SevenZipNativeInitializationException e) {\n+            throw new IOException(NLS.fmtr(\"XMLImporter.sevenZipInitFailed\").set(\"details\", e.getMessage()).format());\n+        }\n+\n+        try (RandomAccessFile randomAccessFile = new RandomAccessFile(tmpFile, \"r\")) {\n+            RandomAccessFileInStream inputStream = new RandomAccessFileInStream(randomAccessFile);\n+            try (IInArchive archive = SevenZip.openInArchive(null, inputStream)) {\n+                archive.extract(getCompleteArchiveIndices(archive),\n+                                false,\n+                                new MyExtractCallback(archive, filter, unzipItemCallback));\n+            }\n+        }\n+    }\n+\n+    private static void initSevenZipLib() throws SevenZipNativeInitializationException {\n+        if (SevenZip.getUsedPlatform() == null) {\n+            SevenZip.initSevenZipFromPlatformJAR();\n+        }\n+    }\n+\n+    @Nonnull\n+    private static int[] getCompleteArchiveIndices(@Nonnull IInArchive archive) throws SevenZipException {\n+        // could be done as a one-liner with Guava, but this one is about 10x faster\n+        int[] indices = new int[archive.getNumberOfItems()];\n+        for (int i = 0; i < indices.length; i++) {\n+            indices[i] = i;\n+        }\n+        return indices;\n+    }\n+\n+    /**\n+     * Defines a callback interface used during archive extraction.\n+     */\n+    public interface UnzipItemCallback {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "072fc712ae060c81a07f6a0f64bd2d8118ec5624"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTMzMjM4OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozMToyMFrOHIV1wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozMToyMFrOHIV1wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwODQ4Mg==", "bodyText": "My is a bit \"ugly\"\nperhaps LocalExtractCallback (if resides as inner class)", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478508482", "createdAt": "2020-08-27T15:31:20Z", "author": {"login": "idlira"}, "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and unzip archive files like zip, 7z, tar, ...\n+ */\n+public class UnzipHelper {\n+\n+    private UnzipHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file\n+     *\n+     * @param tmpFile           the archive file\n+     * @param filter            will be called for each archive item. {@code unzipItemCallback} will be only called for\n+     *                          this item if this filter unzipItemCallback\n+     *                          returns true\n+     * @param unzipItemCallback will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void unzip(File tmpFile, Function<String, Boolean> filter, UnzipItemCallback unzipItemCallback)\n+            throws IOException {\n+        try {\n+            initSevenZipLib();\n+        } catch (SevenZipNativeInitializationException e) {\n+            throw new IOException(NLS.fmtr(\"XMLImporter.sevenZipInitFailed\").set(\"details\", e.getMessage()).format());\n+        }\n+\n+        try (RandomAccessFile randomAccessFile = new RandomAccessFile(tmpFile, \"r\")) {\n+            RandomAccessFileInStream inputStream = new RandomAccessFileInStream(randomAccessFile);\n+            try (IInArchive archive = SevenZip.openInArchive(null, inputStream)) {\n+                archive.extract(getCompleteArchiveIndices(archive),\n+                                false,\n+                                new MyExtractCallback(archive, filter, unzipItemCallback));\n+            }\n+        }\n+    }\n+\n+    private static void initSevenZipLib() throws SevenZipNativeInitializationException {\n+        if (SevenZip.getUsedPlatform() == null) {\n+            SevenZip.initSevenZipFromPlatformJAR();\n+        }\n+    }\n+\n+    @Nonnull\n+    private static int[] getCompleteArchiveIndices(@Nonnull IInArchive archive) throws SevenZipException {\n+        // could be done as a one-liner with Guava, but this one is about 10x faster\n+        int[] indices = new int[archive.getNumberOfItems()];\n+        for (int i = 0; i < indices.length; i++) {\n+            indices[i] = i;\n+        }\n+        return indices;\n+    }\n+\n+    /**\n+     * Defines a callback interface used during archive extraction.\n+     */\n+    public interface UnzipItemCallback {\n+\n+        /**\n+         * Defines a method called for each item being extracted from an archive.\n+         *\n+         * @param status              the extract result\n+         * @param data                the raw data being exported\n+         * @param fileName            file name as defined in the archive\n+         * @param filesProcessedSoFar amount of files processed in the progress\n+         * @param bytesProcessedSoFar amount of bytes processed in the progress\n+         * @param totalBytes          total amount of bytes processed in the progress\n+         * @return <tt>true</tt> to continue with extraction or <tt>false</tt> to abort\n+         */\n+        boolean call(ExtractOperationResult status,\n+                     @Nullable ByteSource data,\n+                     String fileName,\n+                     long filesProcessedSoFar,\n+                     long bytesProcessedSoFar,\n+                     long totalBytes);\n+    }\n+\n+    private static class MyExtractCallback implements IArchiveExtractCallback {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "072fc712ae060c81a07f6a0f64bd2d8118ec5624"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDgzNTMwOnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNjo0NzoyOVrOHJsiKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNTozNzo0OFrOHJ92rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkyODg3Mg==", "bodyText": "Am Besten ne Funktion raus ziehen", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r479928872", "createdAt": "2020-08-31T06:47:29Z", "author": {"login": "qw3ry"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.RateLimit;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload()\n+                  .ifPresent(getArchiveExtractCallback(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> getArchiveExtractCallback(ProcessContext process,\n+                                                           boolean shouldOverwriteExisting,\n+                                                           VirtualFile targetDirectory) {\n+        return fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            if (!TaskContext.get().isActive()) {\n+                Files.delete(tempFile);\n+                return;\n+            }\n+\n+            try {\n+                ArchiveHelper.extract(tempFile,\n+                                      null,\n+                                      (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                          if (!TaskContext.get().isActive()) {\n+                                              return false;\n+                                          }\n+                                          VirtualFile targetFile =\n+                                                  vfs.resolve(vfs.makePath(targetDirectory.path(), filePath));\n+                                          if (targetFile.exists() && !shouldOverwriteExisting) {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.skippingOverwrite\")\n+                                                                                    .set(TARGET_PATH, targetFile.path())\n+                                                                                    .format()));\n+                                              return false;\n+                                          }\n+\n+                                          uploadFile(process, shouldOverwriteExisting, data, filePath, targetFile);\n+                                          updateState(status, filesProcessedSoFar, bytesProcessedSoFar, totalBytes);\n+\n+                                          return true;\n+                                      });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e3b868caa31f5e05f3a09141167dca8815619a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyNjg3Nw==", "bodyText": "Stimme mich hierzu mit @andyHa ab, welche M\u00f6glichkeiten hier Sinn machen. Bspw. w\u00e4re ein Consumer denkbar, der optional beim Entpacken \u00fcbergeben werden kann. Das Callback hat aktuell haupts\u00e4chlich Progress-Funktionalit\u00e4t um dem Aufrufer den Status mitteilen zu k\u00f6nnen. Rausziehen der Stoplogik d\u00fcrfte hingegen eher schwierig werden, da diese aktuell ja auch vom Callback mitgehandled wird.", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r480126877", "createdAt": "2020-08-31T13:21:38Z", "author": {"login": "bwiedmann"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.RateLimit;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload()\n+                  .ifPresent(getArchiveExtractCallback(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> getArchiveExtractCallback(ProcessContext process,\n+                                                           boolean shouldOverwriteExisting,\n+                                                           VirtualFile targetDirectory) {\n+        return fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            if (!TaskContext.get().isActive()) {\n+                Files.delete(tempFile);\n+                return;\n+            }\n+\n+            try {\n+                ArchiveHelper.extract(tempFile,\n+                                      null,\n+                                      (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                          if (!TaskContext.get().isActive()) {\n+                                              return false;\n+                                          }\n+                                          VirtualFile targetFile =\n+                                                  vfs.resolve(vfs.makePath(targetDirectory.path(), filePath));\n+                                          if (targetFile.exists() && !shouldOverwriteExisting) {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.skippingOverwrite\")\n+                                                                                    .set(TARGET_PATH, targetFile.path())\n+                                                                                    .format()));\n+                                              return false;\n+                                          }\n+\n+                                          uploadFile(process, shouldOverwriteExisting, data, filePath, targetFile);\n+                                          updateState(status, filesProcessedSoFar, bytesProcessedSoFar, totalBytes);\n+\n+                                          return true;\n+                                      });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkyODg3Mg=="}, "originalCommit": {"oid": "c3e3b868caa31f5e05f3a09141167dca8815619a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE4MTY5Ng==", "bodyText": "kann man die kilometer lambda net einfach in eine funktion rausziehen und bissle zerlegen?", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r480181696", "createdAt": "2020-08-31T14:48:45Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.RateLimit;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload()\n+                  .ifPresent(getArchiveExtractCallback(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> getArchiveExtractCallback(ProcessContext process,\n+                                                           boolean shouldOverwriteExisting,\n+                                                           VirtualFile targetDirectory) {\n+        return fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            if (!TaskContext.get().isActive()) {\n+                Files.delete(tempFile);\n+                return;\n+            }\n+\n+            try {\n+                ArchiveHelper.extract(tempFile,\n+                                      null,\n+                                      (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                          if (!TaskContext.get().isActive()) {\n+                                              return false;\n+                                          }\n+                                          VirtualFile targetFile =\n+                                                  vfs.resolve(vfs.makePath(targetDirectory.path(), filePath));\n+                                          if (targetFile.exists() && !shouldOverwriteExisting) {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.skippingOverwrite\")\n+                                                                                    .set(TARGET_PATH, targetFile.path())\n+                                                                                    .format()));\n+                                              return false;\n+                                          }\n+\n+                                          uploadFile(process, shouldOverwriteExisting, data, filePath, targetFile);\n+                                          updateState(status, filesProcessedSoFar, bytesProcessedSoFar, totalBytes);\n+\n+                                          return true;\n+                                      });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkyODg3Mg=="}, "originalCommit": {"oid": "c3e3b868caa31f5e05f3a09141167dca8815619a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDIxMjY1Mw==", "bodyText": "Wie besprochen zerlegt und sauber als Predicate durchgereicht.", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r480212653", "createdAt": "2020-08-31T15:37:48Z", "author": {"login": "bwiedmann"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.RateLimit;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload()\n+                  .ifPresent(getArchiveExtractCallback(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> getArchiveExtractCallback(ProcessContext process,\n+                                                           boolean shouldOverwriteExisting,\n+                                                           VirtualFile targetDirectory) {\n+        return fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            if (!TaskContext.get().isActive()) {\n+                Files.delete(tempFile);\n+                return;\n+            }\n+\n+            try {\n+                ArchiveHelper.extract(tempFile,\n+                                      null,\n+                                      (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                          if (!TaskContext.get().isActive()) {\n+                                              return false;\n+                                          }\n+                                          VirtualFile targetFile =\n+                                                  vfs.resolve(vfs.makePath(targetDirectory.path(), filePath));\n+                                          if (targetFile.exists() && !shouldOverwriteExisting) {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.skippingOverwrite\")\n+                                                                                    .set(TARGET_PATH, targetFile.path())\n+                                                                                    .format()));\n+                                              return false;\n+                                          }\n+\n+                                          uploadFile(process, shouldOverwriteExisting, data, filePath, targetFile);\n+                                          updateState(status, filesProcessedSoFar, bytesProcessedSoFar, totalBytes);\n+\n+                                          return true;\n+                                      });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkyODg3Mg=="}, "originalCommit": {"oid": "c3e3b868caa31f5e05f3a09141167dca8815619a"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDg1MjA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNjo1MzozNFrOHJsr6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNjo1MzozNFrOHJsr6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkzMTM2OQ==", "bodyText": "Gerne als extra Klasse. Private inner class ist zwar ganz h\u00fcbsch, aber die Datei wird un\u00fcbersichtlich gro\u00df finde ich", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r479931369", "createdAt": "2020-08-31T06:53:34Z", "author": {"login": "qw3ry"}, "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and extract archive files like zip, 7z, tar, ...\n+ * <p>\n+ * For a list of supported formats have a look at {@link ArchiveFormat#values()}.\n+ */\n+public class ArchiveHelper {\n+\n+    private ArchiveHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file\n+     *\n+     * @param tmpFile                the archive file\n+     * @param filter                 will be called for each archive item. {@code unzipItemCallback} will be only called for this item if this filter unzipItemCallback returns true\n+     * @param archiveExtractCallback will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void extract(File tmpFile,\n+                               Function<String, Boolean> filter,\n+                               ArchiveExtractCallback archiveExtractCallback) throws IOException {\n+        try {\n+            initSevenZipLib();\n+        } catch (SevenZipNativeInitializationException e) {\n+            throw new IOException(NLS.fmtr(\"XMLImporter.sevenZipInitFailed\").set(\"details\", e.getMessage()).format());\n+        }\n+\n+        try (RandomAccessFile randomAccessFile = new RandomAccessFile(tmpFile, \"r\")) {\n+            RandomAccessFileInStream inputStream = new RandomAccessFileInStream(randomAccessFile);\n+            try (IInArchive archive = SevenZip.openInArchive(null, inputStream)) {\n+                archive.extract(getCompleteArchiveIndices(archive),\n+                                false,\n+                                new LocalExtractCallback(archive, filter, archiveExtractCallback));\n+            }\n+        }\n+    }\n+\n+    private static void initSevenZipLib() throws SevenZipNativeInitializationException {\n+        if (SevenZip.getUsedPlatform() == null) {\n+            SevenZip.initSevenZipFromPlatformJAR();\n+        }\n+    }\n+\n+    @Nonnull\n+    private static int[] getCompleteArchiveIndices(@Nonnull IInArchive archive) throws SevenZipException {\n+        // could be done as a one-liner with Guava, but this one is about 10x faster\n+        int[] indices = new int[archive.getNumberOfItems()];\n+        for (int i = 0; i < indices.length; i++) {\n+            indices[i] = i;\n+        }\n+        return indices;\n+    }\n+\n+    /**\n+     * Defines a callback interface used during archive extraction.\n+     */\n+    public interface ArchiveExtractCallback {\n+\n+        /**\n+         * Defines a method called for each item being extracted from an archive.\n+         *\n+         * @param status              the extract result\n+         * @param data                the raw data being exported\n+         * @param fileName            file name as defined in the archive\n+         * @param filesProcessedSoFar amount of files processed in the progress\n+         * @param bytesProcessedSoFar amount of bytes processed in the progress\n+         * @param totalBytes          total amount of bytes processed in the progress\n+         * @return <tt>true</tt> to continue with extraction or <tt>false</tt> to abort\n+         */\n+        boolean call(ExtractOperationResult status,\n+                     @Nullable ByteSource data,\n+                     String fileName,\n+                     long filesProcessedSoFar,\n+                     long bytesProcessedSoFar,\n+                     long totalBytes);\n+    }\n+\n+    private static class LocalExtractCallback implements IArchiveExtractCallback {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e3b868caa31f5e05f3a09141167dca8815619a"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMTE2NTkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwODozMjo0OVrOHJvl7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwODozMjo0OVrOHJvl7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk3ODk5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    TaskContext tc = TaskContext.get();\n          \n          \n            \n                    RateLimit stateUpdateLimiter = tc.shouldUpdateState();\n          \n          \n            \n                    if (stateUpdateLimiter.check()) {\n          \n          \n            \n                        tc.setState(NLS.fmtr(\"VirtualFileExtractionJob.progress\")\n          \n          \n            \n                    TaskContext context = TaskContext.get();\n          \n          \n            \n                    RateLimit stateUpdateLimiter = context.shouldUpdateState();\n          \n          \n            \n                    if (stateUpdateLimiter.check()) {\n          \n          \n            \n                        context.setState(NLS.fmtr(\"VirtualFileExtractionJob.progress\")", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r479978990", "createdAt": "2020-08-31T08:32:49Z", "author": {"login": "sabieber"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.RateLimit;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload()\n+                  .ifPresent(getArchiveExtractCallback(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> getArchiveExtractCallback(ProcessContext process,\n+                                                           boolean shouldOverwriteExisting,\n+                                                           VirtualFile targetDirectory) {\n+        return fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            if (!TaskContext.get().isActive()) {\n+                Files.delete(tempFile);\n+                return;\n+            }\n+\n+            try {\n+                ArchiveHelper.extract(tempFile,\n+                                      null,\n+                                      (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                          if (!TaskContext.get().isActive()) {\n+                                              return false;\n+                                          }\n+                                          VirtualFile targetFile =\n+                                                  vfs.resolve(vfs.makePath(targetDirectory.path(), filePath));\n+                                          if (targetFile.exists() && !shouldOverwriteExisting) {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.skippingOverwrite\")\n+                                                                                    .set(TARGET_PATH, targetFile.path())\n+                                                                                    .format()));\n+                                              return false;\n+                                          }\n+\n+                                          uploadFile(process, shouldOverwriteExisting, data, filePath, targetFile);\n+                                          updateState(status, filesProcessedSoFar, bytesProcessedSoFar, totalBytes);\n+\n+                                          return true;\n+                                      });\n+            } catch (IOException e) {\n+                process.handle(e);\n+            } finally {\n+                Files.delete(tempFile);\n+            }\n+        };\n+    }\n+\n+    private void uploadFile(ProcessContext process,\n+                            boolean shouldOverwriteExisting,\n+                            com.google.common.io.ByteSource data,\n+                            String filePath,\n+                            VirtualFile targetFile) {\n+        try {\n+            if (targetFile.exists() && shouldOverwriteExisting) {\n+                process.log(ProcessLog.info()\n+                                      .withMessage(NLS.fmtr(\"VirtualFileExtractionJob.overwritingFile\")\n+                                                      .set(\"filePath\", filePath)\n+                                                      .set(TARGET_PATH, targetFile.path())\n+                                                      .set(\"fileSize\", NLS.formatSize(data.size()))\n+                                                      .format()));\n+            } else {\n+                process.log(ProcessLog.info()\n+                                      .withMessage(NLS.fmtr(\"VirtualFileExtractionJob.extractingFile\")\n+                                                      .set(\"filePath\", filePath)\n+                                                      .set(TARGET_PATH, targetFile.path())\n+                                                      .set(\"fileSize\", NLS.formatSize(data.size()))\n+                                                      .format()));\n+            }\n+\n+            try (InputStream inputStream = data.openStream()) {\n+                targetFile.consumeStream(inputStream, data.size());\n+            }\n+        } catch (IOException e) {\n+            process.handle(e);\n+        }\n+    }\n+\n+    private void updateState(net.sf.sevenzipjbinding.ExtractOperationResult status,\n+                             long filesProcessedSoFar,\n+                             long bytesProcessedSoFar,\n+                             long totalBytes) {\n+        TaskContext tc = TaskContext.get();\n+        RateLimit stateUpdateLimiter = tc.shouldUpdateState();\n+        if (stateUpdateLimiter.check()) {\n+            tc.setState(NLS.fmtr(\"VirtualFileExtractionJob.progress\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e3b868caa31f5e05f3a09141167dca8815619a"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMTE3MDA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwODozNDowNFrOHJvodA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwODozNDowNFrOHJvodA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk3OTYzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * iterates over the items of an archive file\n          \n          \n            \n                 * Iterates over the items of an archive file.", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r479979636", "createdAt": "2020-08-31T08:34:04Z", "author": {"login": "sabieber"}, "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and extract archive files like zip, 7z, tar, ...\n+ * <p>\n+ * For a list of supported formats have a look at {@link ArchiveFormat#values()}.\n+ */\n+public class ArchiveHelper {\n+\n+    private ArchiveHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e3b868caa31f5e05f3a09141167dca8815619a"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjc4ODg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNTo1ODozNVrOHJ-xUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNTo1ODozNVrOHJ-xUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDIyNzY2NA==", "bodyText": "Rename to just getFilesProcessed?\nis a progress, I guess \"soFar\" is somewhat redundant...", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r480227664", "createdAt": "2020-08-31T15:58:35Z", "author": {"login": "idlira"}, "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "diffHunk": "@@ -103,4 +106,64 @@ private static void initSevenZipLib() throws SevenZipNativeInitializationExcepti\n         return indices;\n     }\n \n+    /**\n+     * Provides a progress of a extraction process.\n+     */\n+    public static class ExtractionProgress {\n+\n+        private final ExtractOperationResult extractOperationResult;\n+        private final ByteSource data;\n+        private final String filePath;\n+        private final long filesProcessedSoFar;\n+        private final long bytesProcessedSoFar;\n+        private final long totalBytes;\n+\n+        /**\n+         * Creates a new instance for progress status updates.\n+         *\n+         * @param extractOperationResult the extraction result of the current file\n+         * @param data                   the data of the extracted file\n+         * @param filePath               the temp file path to the extracted file on disk\n+         * @param filesProcessedSoFar    the number of files processed so far\n+         * @param bytesProcessedSoFar    the number of bytes processed so far\n+         * @param totalBytes             the number of total bytes the archive has\n+         */\n+        public ExtractionProgress(ExtractOperationResult extractOperationResult,\n+                                  ByteSource data,\n+                                  String filePath,\n+                                  long filesProcessedSoFar,\n+                                  long bytesProcessedSoFar,\n+                                  long totalBytes) {\n+            this.extractOperationResult = extractOperationResult;\n+            this.data = data;\n+            this.filePath = filePath;\n+            this.filesProcessedSoFar = filesProcessedSoFar;\n+            this.bytesProcessedSoFar = bytesProcessedSoFar;\n+            this.totalBytes = totalBytes;\n+        }\n+\n+        public ExtractOperationResult getExtractOperationResult() {\n+            return extractOperationResult;\n+        }\n+\n+        public ByteSource getData() {\n+            return data;\n+        }\n+\n+        public String getFilePath() {\n+            return filePath;\n+        }\n+\n+        public long getFilesProcessedSoFar() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b124ae06889225189c4e985c2b9e00fe63b0356"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjc4OTM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNTo1ODo0MVrOHJ-xlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNTo1ODo0MVrOHJ-xlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDIyNzczNQ==", "bodyText": "Rename to just getBytesProcessed?\nis a progress, I guess \"soFar\" is somewhat redundant...", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r480227735", "createdAt": "2020-08-31T15:58:41Z", "author": {"login": "idlira"}, "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "diffHunk": "@@ -103,4 +106,64 @@ private static void initSevenZipLib() throws SevenZipNativeInitializationExcepti\n         return indices;\n     }\n \n+    /**\n+     * Provides a progress of a extraction process.\n+     */\n+    public static class ExtractionProgress {\n+\n+        private final ExtractOperationResult extractOperationResult;\n+        private final ByteSource data;\n+        private final String filePath;\n+        private final long filesProcessedSoFar;\n+        private final long bytesProcessedSoFar;\n+        private final long totalBytes;\n+\n+        /**\n+         * Creates a new instance for progress status updates.\n+         *\n+         * @param extractOperationResult the extraction result of the current file\n+         * @param data                   the data of the extracted file\n+         * @param filePath               the temp file path to the extracted file on disk\n+         * @param filesProcessedSoFar    the number of files processed so far\n+         * @param bytesProcessedSoFar    the number of bytes processed so far\n+         * @param totalBytes             the number of total bytes the archive has\n+         */\n+        public ExtractionProgress(ExtractOperationResult extractOperationResult,\n+                                  ByteSource data,\n+                                  String filePath,\n+                                  long filesProcessedSoFar,\n+                                  long bytesProcessedSoFar,\n+                                  long totalBytes) {\n+            this.extractOperationResult = extractOperationResult;\n+            this.data = data;\n+            this.filePath = filePath;\n+            this.filesProcessedSoFar = filesProcessedSoFar;\n+            this.bytesProcessedSoFar = bytesProcessedSoFar;\n+            this.totalBytes = totalBytes;\n+        }\n+\n+        public ExtractOperationResult getExtractOperationResult() {\n+            return extractOperationResult;\n+        }\n+\n+        public ByteSource getData() {\n+            return data;\n+        }\n+\n+        public String getFilePath() {\n+            return filePath;\n+        }\n+\n+        public long getFilesProcessedSoFar() {\n+            return filesProcessedSoFar;\n+        }\n+\n+        public long getBytesProcessedSoFar() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b124ae06889225189c4e985c2b9e00fe63b0356"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODYzMzM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMDoyMlrOHK4hCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMDoyMlrOHK4hCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3Mzc2OQ==", "bodyText": "no need for static here - @register is above..", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481173769", "createdAt": "2020-09-01T14:20:22Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "349d329a7e66926cda521ebb298cb10c3af0de29"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODYzMzk1OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMDoyOVrOHK4hYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMDoyOVrOHK4hYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3Mzg1Ng==", "bodyText": "s.a.", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481173856", "createdAt": "2020-09-01T14:20:29Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "349d329a7e66926cda521ebb298cb10c3af0de29"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODYzODUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMToyNlrOHK4kNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMToyNlrOHK4kNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NDU4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    sourceFile.tryDownload().ifPresent(handleArchiveExtraction(process, shouldOverwriteExisting, targetDirectory));\n          \n          \n            \n                    sourceFile.tryDownload().ifPresent(handle -> handleArchiveExtraction(process, handle, shouldOverwriteExisting, targetDirectory));", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481174581", "createdAt": "2020-09-01T14:21:26Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(handleArchiveExtraction(process, shouldOverwriteExisting, targetDirectory));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "349d329a7e66926cda521ebb298cb10c3af0de29"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODY0MTIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMTo1NlrOHK4l0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMTo1NlrOHK4l0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NDk5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Consumer<FileHandle> handleArchiveExtraction(ProcessContext process,\n          \n          \n            \n                private void handleArchiveExtraction(ProcessContext process, FileHandle fileHandle,", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481174992", "createdAt": "2020-09-01T14:21:56Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(handleArchiveExtraction(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> handleArchiveExtraction(ProcessContext process,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "349d329a7e66926cda521ebb298cb10c3af0de29"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODY0MTY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMjowNFrOHK4mHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMjowNFrOHK4mHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NTA3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return fileHandle -> {", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481175070", "createdAt": "2020-09-01T14:22:04Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(handleArchiveExtraction(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> handleArchiveExtraction(ProcessContext process,\n+                                                         boolean shouldOverwriteExisting,\n+                                                         VirtualFile targetDirectory) {\n+        return fileHandle -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "349d329a7e66926cda521ebb298cb10c3af0de29"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODY0MjQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMjoxNVrOHK4mlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMjoxNVrOHK4mlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NTE4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    };", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481175189", "createdAt": "2020-09-01T14:22:15Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(handleArchiveExtraction(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> handleArchiveExtraction(ProcessContext process,\n+                                                         boolean shouldOverwriteExisting,\n+                                                         VirtualFile targetDirectory) {\n+        return fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            if (!TaskContext.get().isActive()) {\n+                Files.delete(tempFile);\n+                return;\n+            }\n+\n+            try {\n+                ArchiveHelper.extract(tempFile,\n+                                      null,\n+                                      handleFileInArchive(process, shouldOverwriteExisting, targetDirectory));\n+            } catch (IOException e) {\n+                process.handle(e);\n+            } finally {\n+                Files.delete(tempFile);\n+            }\n+        };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "349d329a7e66926cda521ebb298cb10c3af0de29"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODY0NTE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMjo0N1rOHK4oQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMjo0N1rOHK4oQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NTYxOA==", "bodyText": "bulid closure at call site instead of returning one (s.a.)", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481175618", "createdAt": "2020-09-01T14:22:47Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(handleArchiveExtraction(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> handleArchiveExtraction(ProcessContext process,\n+                                                         boolean shouldOverwriteExisting,\n+                                                         VirtualFile targetDirectory) {\n+        return fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            if (!TaskContext.get().isActive()) {\n+                Files.delete(tempFile);\n+                return;\n+            }\n+\n+            try {\n+                ArchiveHelper.extract(tempFile,\n+                                      null,\n+                                      handleFileInArchive(process, shouldOverwriteExisting, targetDirectory));\n+            } catch (IOException e) {\n+                process.handle(e);\n+            } finally {\n+                Files.delete(tempFile);\n+            }\n+        };\n+    }\n+\n+    @Nonnull\n+    private Predicate<ArchiveHelper.ExtractionProgress> handleFileInArchive(ProcessContext process,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "349d329a7e66926cda521ebb298cb10c3af0de29"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODY1MzMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyNDoyNVrOHK4tNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyNDoyNVrOHK4tNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3Njg4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static void extract(File tmpFile,\n          \n          \n            \n                public static void extract(File archiveFile,", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481176885", "createdAt": "2020-09-01T14:24:25Z", "author": {"login": "andyHa"}, "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and extract archive files like zip, 7z, tar, ...\n+ * <p>\n+ * For a list of supported formats have a look at {@link ArchiveFormat#values()}.\n+ */\n+public class ArchiveHelper {\n+\n+    private ArchiveHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * Iterates over the items of an archive file\n+     *\n+     * @param tmpFile                 the archive file\n+     * @param filter                  will be called for each archive item. {@code unzipItemCallback} will be only called for this item if this filter unzipItemCallback returns true\n+     * @param progressAndStopProvider will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void extract(File tmpFile,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "349d329a7e66926cda521ebb298cb10c3af0de29"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2012, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}