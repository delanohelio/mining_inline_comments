{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNDIxNjQ4", "number": 804, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDoyNTowM1rOEK1olw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMToxNDowNVrOEK2jNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Nzk5OTU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/analytics/scheduler/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDoyNTowM1rOGsG56w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDoyNTowM1rOGsG56w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkwMzY1OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            to forcefully start a scheduler imedietally.\n          \n          \n            \n            to forcefully start a scheduler immediately.", "url": "https://github.com/scireum/sirius-biz/pull/804#discussion_r448903659", "createdAt": "2020-07-02T10:25:03Z", "author": {"login": "sabieber"}, "path": "src/main/java/sirius/biz/analytics/scheduler/README.md", "diffHunk": "@@ -20,4 +20,14 @@ per month and an additional **best effort** one which tries to execute the compu\n day in the current month, so that the relected values are up to date (as long as the system \n isn't overloaded).\n \n+For maintenance and troubleshooting some options are available:\n+* The [AnalyticsCommand](AnalyticsCommand.java) can be used in the [System Console](https://localhost:9000/system/console)\n+by calling **analytics**. This lists all active schedulers, their queue and last execution. It also permits\n+to forcefully start a scheduler imedietally.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c90bc09d0bef7a45d9b47eb35ce0a46de7f051"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODAwMjQwOnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/analytics/scheduler/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDoyNTo1MlrOGsG7kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDoyNTo1MlrOGsG7kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkwNDA4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            report the queue lenghts in whiche the tasks are scheduler and also list which server is charce of executing\n          \n          \n            \n            report the queue lengths in which the tasks are scheduler and also list which server is in charge of executing", "url": "https://github.com/scireum/sirius-biz/pull/804#discussion_r448904082", "createdAt": "2020-07-02T10:25:52Z", "author": {"login": "sabieber"}, "path": "src/main/java/sirius/biz/analytics/scheduler/README.md", "diffHunk": "@@ -20,4 +20,14 @@ per month and an additional **best effort** one which tries to execute the compu\n day in the current month, so that the relected values are up to date (as long as the system \n isn't overloaded).\n \n+For maintenance and troubleshooting some options are available:\n+* The [AnalyticsCommand](AnalyticsCommand.java) can be used in the [System Console](https://localhost:9000/system/console)\n+by calling **analytics**. This lists all active schedulers, their queue and last execution. It also permits\n+to forcefully start a scheduler imedietally.\n+* The Logger **analytics** can be set to FINE (using the **logger**) command to observer when the framework is\n+doing.\n+* The [Cluster State](https://localhost:9000/system/cluster) and the [Load Info](https://localhost:9000/system/load)\n+report the queue lenghts in whiche the tasks are scheduler and also list which server is charce of executing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c90bc09d0bef7a45d9b47eb35ce0a46de7f051"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODAwMzkzOnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/analytics/scheduler/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDoyNjoyMlrOGsG8lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDoyNjoyMlrOGsG8lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkwNDM0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * The Logger **analytics** can be set to FINE (using the **logger**) command to observer when the framework is\n          \n          \n            \n            * The Logger **analytics** can be set to FINE (using the **logger** command) to observe what the framework is", "url": "https://github.com/scireum/sirius-biz/pull/804#discussion_r448904342", "createdAt": "2020-07-02T10:26:22Z", "author": {"login": "sabieber"}, "path": "src/main/java/sirius/biz/analytics/scheduler/README.md", "diffHunk": "@@ -20,4 +20,14 @@ per month and an additional **best effort** one which tries to execute the compu\n day in the current month, so that the relected values are up to date (as long as the system \n isn't overloaded).\n \n+For maintenance and troubleshooting some options are available:\n+* The [AnalyticsCommand](AnalyticsCommand.java) can be used in the [System Console](https://localhost:9000/system/console)\n+by calling **analytics**. This lists all active schedulers, their queue and last execution. It also permits\n+to forcefully start a scheduler imedietally.\n+* The Logger **analytics** can be set to FINE (using the **logger**) command to observer when the framework is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c90bc09d0bef7a45d9b47eb35ce0a46de7f051"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODAxODk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/tenants/mongo/MongoUserAccountImportHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDozMTowMVrOGsHFtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDozMTowMVrOGsHFtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkwNjY3Nw==", "bodyText": "typo: collectExcactLookups", "url": "https://github.com/scireum/sirius-biz/pull/804#discussion_r448906677", "createdAt": "2020-07-02T10:31:01Z", "author": {"login": "sabieber"}, "path": "src/main/java/sirius/biz/tenants/mongo/MongoUserAccountImportHandler.java", "diffHunk": "@@ -60,6 +62,11 @@ protected MongoUserAccountImportHandler(Class<?> clazz, ImporterContext context)\n         super(clazz, context);\n     }\n \n+    @Override\n+    protected void collectExcactLookups(Consumer<List<Mapping>> filterListConsumer) {\n+        super.collectExcactLookups(filterListConsumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c96d6dc03694cb11bb823988b9558e13fc90ff7f"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODAyNzU0OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/analytics/metrics/MetricQuery.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDozMzo0M1rOGsHK4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDozMzo0M1rOGsHK4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkwODAwMA==", "bodyText": "sure?", "url": "https://github.com/scireum/sirius-biz/pull/804#discussion_r448908000", "createdAt": "2020-07-02T10:33:43Z", "author": {"login": "sabieber"}, "path": "src/main/java/sirius/biz/analytics/metrics/MetricQuery.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.analytics.metrics;\n+\n+import sirius.db.mixing.BaseEntity;\n+\n+import javax.annotation.CheckReturnValue;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Provides a fluent API to create and execute queries against the metrics database.\n+ */\n+public class MetricQuery {\n+\n+    /**\n+     * Specifies the maximal number of values returned for daily metrics.\n+     */\n+    public static final int MAX_DAILY_METRICS = 400;\n+\n+    /**\n+     * Specifies the maximal number of values returned for monthly metrics.\n+     */\n+    public static final int MAX_MONTHLY_METRICS = 100;\n+\n+    /**\n+     * Specifies the maximal number of values returned for yearly metrics.\n+     */\n+    public static final int MAX_YEARLY_METRICS = 100;\n+\n+    protected enum Interval {\n+        YEARLY, MONTHLY, DAILY, FACT\n+    }\n+\n+    private final BasicMetrics<?> metrics;\n+    private String metricName;\n+    private String targetType;\n+    private String targetId;\n+    private Interval interval;\n+\n+    protected MetricQuery(BasicMetrics<?> metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    /**\n+     * Queries the yearly metric with the given name.\n+     *\n+     * @param name the metric to query\n+     * @return the query itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public MetricQuery yearly(String name) {\n+        this.metricName = name;\n+        this.interval = Interval.YEARLY;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Queries the monthly metric with the given name.\n+     *\n+     * @param name the metric to query\n+     * @return the query itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public MetricQuery monthly(String name) {\n+        this.metricName = name;\n+        this.interval = Interval.MONTHLY;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Queries the daily metric with the given name.\n+     *\n+     * @param name the metric to query\n+     * @return the query itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public MetricQuery daily(String name) {\n+        this.metricName = name;\n+        this.interval = Interval.DAILY;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Queries the fact with the given name.\n+     *\n+     * @param name the metric to query\n+     * @return the query itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public MetricQuery fact(String name) {\n+        this.metricName = name;\n+        this.interval = Interval.FACT;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Speficies the object to query metrics for.\n+     *\n+     * @param targetType the type of the entity to query metrics for\n+     * @param targetId   the id of the entity to query metrics for\n+     * @return the query itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public MetricQuery of(String targetType, String targetId) {\n+        this.targetType = targetType;\n+        this.targetId = targetId;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies the entity to query metrics for.\n+     *\n+     * @param entity the entity to query metrics for\n+     * @return the query itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public MetricQuery of(BaseEntity<?> entity) {\n+        return of(entity.getTypeName(), entity.getIdAsString());\n+    }\n+\n+    /**\n+     * Specifies that global metrics (not associated to an entity but rather system wide values) should be queried.\n+     *\n+     * @return the query itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public MetricQuery global() {\n+        return of(BasicMetrics.GLOBAL, BasicMetrics.GLOBAL);\n+    }\n+\n+    /**\n+     * Fetches all metrics starting from the <tt>startDate</tt> up until the <tt>untilDate</tt> is reached.\n+     *\n+     * @param startDate the first date to fetch metrics for\n+     * @param untilDate the last date to fetch metrics for\n+     * @return the list of metrics fetched for the given period. Note that there are internal circuit breakers in case\n+     * too many metrics would be requested. In this case a limited list is returned.\n+     */\n+    public List<Integer> values(LocalDate startDate, LocalDate untilDate) {\n+        assertParametersArePresent();\n+        List<Integer> result = new ArrayList<>();\n+        LocalDate date = startDate;\n+        LocalDate endDate = untilDate == null ? LocalDate.now() : untilDate;\n+        AtomicInteger limit = new AtomicInteger(determineLimit(interval));\n+        while (!date.isAfter(endDate) && limit.decrementAndGet() > 0) {\n+            result.add(metrics.executeQuery(interval,\n+                                            targetType,\n+                                            targetId,\n+                                            metricName,\n+                                            date.getYear(),\n+                                            date.getMonthValue(),\n+                                            date.getDayOfMonth()).orElse(0));\n+            date = increment(date, interval);\n+        }\n+\n+        return result;\n+    }\n+\n+    private void assertParametersArePresent() {\n+        if (interval == null) {\n+            throw new IllegalStateException(\"No interval has been chosen for the metric query: \" + this);\n+        }\n+        if (targetType == null) {\n+            throw new IllegalStateException(\"No targetType has been chosen for the metric query: \" + this);\n+        }\n+        if (targetId == null) {\n+            throw new IllegalStateException(\"No targetId has been chosen for the metric query: \" + this);\n+        }\n+    }\n+\n+    /**\n+     * Fetches the requested number of metrics starting from the <tt>startDate</tt>.\n+     *\n+     * @param startDate      the first date to fetch metrics for\n+     * @param numberOfValues the number of metrics to fetch\n+     * @return the list of metrics fetched for the given period. Note that there are internal circuit breakers in case\n+     * too many metrics would be requested. In this case a limited list is returned.\n+     */\n+    public List<Integer> valuesFrom(LocalDate startDate, int numberOfValues) {\n+        assertParametersArePresent();\n+        List<Integer> result = new ArrayList<>();\n+        LocalDate date = startDate;\n+        AtomicInteger limit = new AtomicInteger(Math.min(numberOfValues, determineLimit(interval)));\n+        while (limit.decrementAndGet() > 0) {\n+            result.add(metrics.executeQuery(interval,\n+                                            targetType,\n+                                            targetId,\n+                                            metricName,\n+                                            date.getYear(),\n+                                            date.getMonthValue(),\n+                                            date.getDayOfMonth()).orElse(0));\n+            date = increment(date, interval);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Fetches the requested number of metrics up until the <tt>endDate</tt>.\n+     *\n+     * @param endDate        the last date to fetch metrics for\n+     * @param numberOfValues the number of metrics to fetch (before the given end date)\n+     * @return the list of metrics fetched for the given period (sorted by date ascending).\n+     * Note that there are internal circuit breakers in case too many metrics would be requested.\n+     * In this case a limited list is returned.\n+     */\n+    public List<Integer> valuesUntil(LocalDate endDate, int numberOfValues) {\n+        assertParametersArePresent();\n+        List<Integer> result = new ArrayList<>();\n+        LocalDate date = endDate;\n+        AtomicInteger limit = new AtomicInteger(Math.min(numberOfValues, determineLimit(interval)));\n+        while (limit.decrementAndGet() > 0) {\n+            result.add(0,\n+                       metrics.executeQuery(interval,\n+                                            targetType,\n+                                            targetId,\n+                                            metricName,\n+                                            date.getYear(),\n+                                            date.getMonthValue(),\n+                                            date.getDayOfMonth()).orElse(0));\n+            date = decrement(date, interval);\n+        }\n+\n+        return result;\n+    }\n+\n+    private LocalDate increment(LocalDate date, Interval interval) {\n+        switch (interval) {\n+            case DAILY:\n+                return date.plusDays(1);\n+            case MONTHLY:\n+                return date.plusMonths(1);\n+            case YEARLY:\n+                return date.plusYears(1);\n+            default:\n+                return date.plusYears(999);\n+        }\n+    }\n+\n+    private LocalDate decrement(LocalDate date, Interval interval) {\n+        switch (interval) {\n+            case DAILY:\n+                return LocalDate.now().minusDays(1);\n+            case MONTHLY:\n+                return LocalDate.now().minusMonths(1);\n+            case YEARLY:\n+                return LocalDate.now().minusYears(1);\n+            case FACT:\n+                return date.minusYears(999);\n+            default:\n+                return date.plusYears(999);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41ba792908755682254f42b18489bfe5894f0cad"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODAyODU1OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/analytics/scheduler/BaseEntityBatchEmitter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDozNDowMlrOGsHLew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDozNDowMlrOGsHLew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkwODE1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @param <Q> the query type used to retireve entities being processed by this emitter\n          \n          \n            \n             * @param <Q> the query type used to retrieve entities being processed by this emitter", "url": "https://github.com/scireum/sirius-biz/pull/804#discussion_r448908155", "createdAt": "2020-07-02T10:34:02Z", "author": {"login": "mkeckmkeck"}, "path": "src/main/java/sirius/biz/analytics/scheduler/BaseEntityBatchEmitter.java", "diffHunk": "@@ -27,6 +27,11 @@\n  * <p>\n  * These batches are described using JSON and can be evaluated into an iterator of entities using\n  * {@link #evaluateBatch(JSONObject, Consumer, Consumer)}.\n+ *\n+ * @param <I> the id type of the entities being processed by this emitter\n+ * @param <C> the constraint type to be applied on entities processed by this emitter\n+ * @param <B> the entity type being processed by this emitter\n+ * @param <Q> the query type used to retireve entities being processed by this emitter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68090d4fe46bfa9f2dfbb980d5d3ac5de6ac5486"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODA1OTcyOnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/importer/format/ImportDictionary.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDo0Mzo1MFrOGsHeqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDo0Mzo1MFrOGsHeqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkxMzA2Nw==", "bodyText": "Rename to computedFieldLookups ?", "url": "https://github.com/scireum/sirius-biz/pull/804#discussion_r448913067", "createdAt": "2020-07-02T10:43:50Z", "author": {"login": "mkeckmkeck"}, "path": "src/main/java/sirius/biz/importer/format/ImportDictionary.java", "diffHunk": "@@ -61,7 +60,7 @@\n     private Map<String, FieldDefinition> fields = new LinkedHashMap<>();\n     private Map<String, String> aliases = new LinkedHashMap<>();\n     private List<String> mappingFunction;\n-    private Function<String, FieldDefinition> computedFieldLookup;\n+    private List<Function<String, FieldDefinition>> computedFieldLookup = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16757e434d8513a4f50e9ff8b62bd786c276db32"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODE0OTY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/sirius/biz/importer/BaseImportHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMToxNDowNVrOGsIW_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMToxNDowNVrOGsIW_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkyNzQ4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Resolves an field into a <tt>FieldDefinition</tt>.\n          \n          \n            \n                 * Resolves a field into a <tt>FieldDefinition</tt>.", "url": "https://github.com/scireum/sirius-biz/pull/804#discussion_r448927487", "createdAt": "2020-07-02T11:14:05Z", "author": {"login": "idlira"}, "path": "src/main/java/sirius/biz/importer/BaseImportHandler.java", "diffHunk": "@@ -369,18 +377,48 @@ protected FieldDefinition expandAliases(FieldDefinition field) {\n     @Override\n     public ImportDictionary getExportDictionary() {\n         ImportDictionary exportDictionary = new ImportDictionary();\n-        getExportableMappings().stream()\n-                               .map(descriptor::getProperty)\n-                               .map(property -> property.tryAs(FieldDefinitionSupplier.class)\n-                                                        .map(FieldDefinitionSupplier::get)\n-                                                        .orElse(null))\n-                               .filter(Objects::nonNull)\n-                               .map(this::expandAliases)\n-                               .forEach(exportDictionary::addField);\n+        exportDictionary.withCustomFieldLookup(this::findComputedField);\n+\n+        for (Mapping mapping : getExportableMappings()) {\n+            Property property = descriptor.findProperty(mapping.toString());\n+            if (property != null) {\n+                property.tryAs(FieldDefinitionSupplier.class)\n+                        .map(FieldDefinitionSupplier::get)\n+                        .map(this::expandAliases)\n+                        .ifPresent(exportDictionary::addField);\n+            } else {\n+                exportDictionary.findField(mapping.toString())\n+                                .map(this::expandAliases)\n+                                .ifPresent(exportDictionary::addField);\n+            }\n+        }\n \n         return exportDictionary;\n     }\n \n+    /**\n+     * Resolves an field into a <tt>FieldDefinition</tt>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcb89e44f1069ea38529b15b71d95484904fa5e1"}, "originalPosition": 81}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1948, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}