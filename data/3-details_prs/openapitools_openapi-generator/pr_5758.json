{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1Njg5NDA4", "number": 5758, "title": "New Generator: Scala akka-http server", "bodyText": "This is a basic scala akka-http server implementation.\n#5711\nPR checklist\n\n Read the contribution guidelines.\n If contributing template-only or documentation-only changes which will change sample output, build the project before.\n Run the shell script(s) under ./bin/ (or Windows batch scripts under.\\bin\\windows) to update Petstore samples related to your fix. This is important, as CI jobs will verify all generator outputs of your HEAD commit, and these must match the expectations made by your contribution. You only need to run ./bin/{LANG}-petstore.sh, ./bin/openapi3/{LANG}-petstore.sh if updating the code or mustache templates for a language ({LANG}) (e.g. php, ruby, python, etc).\n File the PR against the correct branch: master, 4.3.x, 5.0.x. Default: master.\n Copy the technical committee to review the pull request if your PR is targeting a particular programming language.\n\n@clasnake, @jimschubert, @shijinkui, @ramzimaalej, @chameleon82", "createdAt": "2020-03-30T14:28:50Z", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758", "merged": true, "mergeCommit": {"oid": "af85fab52b5604e4689028e6eaea464948a11255"}, "closed": true, "closedAt": "2020-04-04T15:16:15Z", "author": {"login": "Bouillie"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcR8_ENgH2gAyMzk1Njg5NDA4OjNiY2E5MTlhNmJjMzBjZGJiMzdhNjVjMmJkMDBhZDRmNjJiNmZlMDk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcUXkDlAFqTM4NzcxMDgzNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3bca919a6bc30cdbb37a65c2bd00ad4f62b6fe09", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/3bca919a6bc30cdbb37a65c2bd00ad4f62b6fe09", "committedDate": "2020-03-28T03:45:59Z", "message": "Scala akka-http server base implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c5230b583e18c0449ed627076aa245166a60756", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/2c5230b583e18c0449ed627076aa245166a60756", "committedDate": "2020-03-28T03:46:13Z", "message": "[scala-akka-http-server] petStore samples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6ee7be6047bb694a5837dfbebb998b71ca81d30", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/c6ee7be6047bb694a5837dfbebb998b71ca81d30", "committedDate": "2020-03-30T12:29:37Z", "message": "Improved the formatting of generated files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e4bf2e0145d416c5bac56dbb934d36440433aa4", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/0e4bf2e0145d416c5bac56dbb934d36440433aa4", "committedDate": "2020-03-30T12:29:57Z", "message": "Updated scala-akka-http server samples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5aa9f94b5dd9ae8ff59150136796855d83b2fe4", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/e5aa9f94b5dd9ae8ff59150136796855d83b2fe4", "committedDate": "2020-03-30T14:05:16Z", "message": "[scala-akka-http-server] the groupId, artifactId and artifactVersion default value are used as intended."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1dcf064ac24d3ba1af8e326776bf89b1a15a6af0", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/1dcf064ac24d3ba1af8e326776bf89b1a15a6af0", "committedDate": "2020-03-30T14:13:34Z", "message": "Fixed the default operation not being correctly generated on parameterless operations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5f6028da3cc4b26ad3ac9cd27cfbbc91dfae665", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/d5f6028da3cc4b26ad3ac9cd27cfbbc91dfae665", "committedDate": "2020-03-30T14:14:07Z", "message": "Added build.sbt.mustache supporting file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1c7a43c453549a2b8955a4461309113996c18dc", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/e1c7a43c453549a2b8955a4461309113996c18dc", "committedDate": "2020-03-30T14:14:53Z", "message": "Updated scala-akka-http server samples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "673357420acfb6a48b1d954623423e7c4c227734", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/673357420acfb6a48b1d954623423e7c4c227734", "committedDate": "2020-03-30T14:36:47Z", "message": "ScalaAkkaHttpServer: Fixed a String.format call to use Locale.ROOT for locale"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c513da61aa3ddfb0896d5a06bc11b7a7ed14a9c", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/1c513da61aa3ddfb0896d5a06bc11b7a7ed14a9c", "committedDate": "2020-03-30T15:32:43Z", "message": "[scala-akka-http-server] Fixed defaultValue being escaped during generation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dde69cb0e5fc31a0b0fa656557477ff193a644f9", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/dde69cb0e5fc31a0b0fa656557477ff193a644f9", "committedDate": "2020-03-30T18:33:43Z", "message": "Added scala-akka-http.md"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f980e7ffd44739a065252ff363f7844283be8a8", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/5f980e7ffd44739a065252ff363f7844283be8a8", "committedDate": "2020-03-31T14:52:35Z", "message": "Replaced all \"\u21d2\" character with \"=>\" to retain compatibility with scala 2.13"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de57a5d6aaf335f3cce75712691ea29262ed8437", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/de57a5d6aaf335f3cce75712691ea29262ed8437", "committedDate": "2020-03-31T14:54:00Z", "message": "[scala-akka-http] Added a config option akkaHttpVersion\nIt's set in the generated build.sbt."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e31ab24ae746f97e34dbc95f140e077f0e70e214", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/e31ab24ae746f97e34dbc95f140e077f0e70e214", "committedDate": "2020-03-31T14:56:53Z", "message": "Updated scala-akka-http server samples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e89e9afea27c506d52d7b211c72cb20ec48c2991", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/e89e9afea27c506d52d7b211c72cb20ec48c2991", "committedDate": "2020-03-31T14:59:10Z", "message": "Merge branch 'master' into scala-akka-http-server"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "759370b5661ad2aaa50cfc3eaf1fa536fe3bc406", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/759370b5661ad2aaa50cfc3eaf1fa536fe3bc406", "committedDate": "2020-03-31T16:19:01Z", "message": "[scala-akka-http] More accurate akkaHttpVersion parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e50337e5d17e6d001110766cb68b864804c7398", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/0e50337e5d17e6d001110766cb68b864804c7398", "committedDate": "2020-03-31T19:19:08Z", "message": "Updated scala-akka-http.md"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1742a3b86dab8e0ddcede66162359677f0b880a", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/a1742a3b86dab8e0ddcede66162359677f0b880a", "committedDate": "2020-04-02T09:00:47Z", "message": "Merge branch 'master' into scala-akka-http-server"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3b769a353f36c6d9102cc3ef37a3c29c32e444f", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/b3b769a353f36c6d9102cc3ef37a3c29c32e444f", "committedDate": "2020-04-03T16:41:39Z", "message": "[scala-akka-http] Changed the akka-http version check to fix the generation of StringDirectives"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95bdbb865237712640de9057bb93cac8bc7a6410", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/95bdbb865237712640de9057bb93cac8bc7a6410", "committedDate": "2020-04-03T16:42:08Z", "message": "Updated scala-akka-http samples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9", "author": {"user": null}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/b86fdba8d36f5dabae309cc62786f9caca5255e9", "committedDate": "2020-04-03T19:22:31Z", "message": "updated scala-akka-http.md"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NzA1ODE1", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#pullrequestreview-387705815", "createdAt": "2020-04-04T14:50:10Z", "commit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNDo1MDoxMFrOGAyYIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNDo1MDoxMFrOGAyYIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ3ODU2Mw==", "bodyText": "I'll rename it to \"scala-akka-http-server\" to follow our generator naming convention.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403478563", "createdAt": "2020-04-04T14:50:10Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NzEwNjY3", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#pullrequestreview-387710667", "createdAt": "2020-04-04T15:49:30Z", "commit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo0OTozMFrOGAywFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo0OTozMFrOGAywFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NDY5Mg==", "bodyText": "We've trying to normalize the naming of vendor extensions. I wonder if you can rename hasDefaultValue to x-has-default-value instead.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403484692", "createdAt": "2020-04-04T15:49:30Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";\n+    }\n+\n+    public String getHelp() {\n+        return \"Generates a scala-akka-http server.\";\n+    }\n+\n+    public ScalaAkkaHttpServerCodegen() {\n+        super();\n+\n+        modifyFeatureSet(features -> features\n+                .includeDocumentationFeatures(DocumentationFeature.Readme)\n+                .wireFormatFeatures(EnumSet.of(WireFormatFeature.JSON, WireFormatFeature.XML, WireFormatFeature.Custom))\n+                .securityFeatures(EnumSet.of(\n+                        SecurityFeature.BasicAuth,\n+                        SecurityFeature.ApiKey,\n+                        SecurityFeature.BearerToken\n+                ))\n+                .excludeGlobalFeatures(\n+                        GlobalFeature.XMLStructureDefinitions,\n+                        GlobalFeature.Callbacks,\n+                        GlobalFeature.LinkObjects,\n+                        GlobalFeature.ParameterStyling\n+                )\n+                .excludeSchemaSupportFeatures(\n+                        SchemaSupportFeature.Polymorphism\n+                )\n+                .excludeParameterFeatures(\n+                        ParameterFeature.Cookie\n+                )\n+        );\n+\n+        outputFolder = \"generated-code\" + File.separator + \"scala-akka-http\";\n+        modelTemplateFiles.put(\"model.mustache\", \".scala\");\n+        apiTemplateFiles.put(\"api.mustache\", \".scala\");\n+        embeddedTemplateDir = templateDir = \"scala-akka-http-server\";\n+\n+        groupId = \"org.openapitools\";\n+        artifactId = \"openapi-scala-akka-http-server\";\n+        artifactVersion = \"1.0.0\";\n+        apiPackage = \"org.openapitools.server.api\";\n+        modelPackage = \"org.openapitools.server.model\";\n+        invokerPackage = \"org.openapitools.server\";\n+        akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+\n+        setReservedWordsLowerCase(\n+                Arrays.asList(\n+                        \"abstract\", \"case\", \"catch\", \"class\", \"def\", \"do\", \"else\", \"extends\",\n+                        \"false\", \"final\", \"finally\", \"for\", \"forSome\", \"if\", \"implicit\",\n+                        \"import\", \"lazy\", \"match\", \"new\", \"null\", \"object\", \"override\", \"package\",\n+                        \"private\", \"protected\", \"return\", \"sealed\", \"super\", \"this\", \"throw\",\n+                        \"trait\", \"try\", \"true\", \"type\", \"val\", \"var\", \"while\", \"with\", \"yield\")\n+        );\n+\n+        cliOptions.add(CliOption.newString(CodegenConstants.INVOKER_PACKAGE, CodegenConstants.INVOKER_PACKAGE_DESC).defaultValue(invokerPackage));\n+        cliOptions.add(CliOption.newString(CodegenConstants.GROUP_ID, CodegenConstants.GROUP_ID_DESC).defaultValue(groupId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_ID, CodegenConstants.ARTIFACT_ID).defaultValue(artifactId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_VERSION, CodegenConstants.ARTIFACT_VERSION_DESC).defaultValue(artifactVersion));\n+        cliOptions.add(CliOption.newString(AKKA_HTTP_VERSION, AKKA_HTTP_VERSION_DESC).defaultValue(akkaHttpVersion));\n+\n+        importMapping.remove(\"Seq\");\n+        importMapping.remove(\"List\");\n+        importMapping.remove(\"Set\");\n+        importMapping.remove(\"Map\");\n+\n+        typeMapping = new HashMap<>();\n+        typeMapping.put(\"array\", \"Seq\");\n+        typeMapping.put(\"set\", \"Set\");\n+        typeMapping.put(\"boolean\", \"Boolean\");\n+        typeMapping.put(\"string\", \"String\");\n+        typeMapping.put(\"int\", \"Int\");\n+        typeMapping.put(\"integer\", \"Int\");\n+        typeMapping.put(\"long\", \"Long\");\n+        typeMapping.put(\"float\", \"Float\");\n+        typeMapping.put(\"byte\", \"Byte\");\n+        typeMapping.put(\"short\", \"Short\");\n+        typeMapping.put(\"char\", \"Char\");\n+        typeMapping.put(\"double\", \"Double\");\n+        typeMapping.put(\"object\", \"Any\");\n+        typeMapping.put(\"file\", \"File\");\n+        typeMapping.put(\"binary\", \"File\");\n+        typeMapping.put(\"number\", \"Double\");\n+\n+        instantiationTypes.put(\"array\", \"ListBuffer\");\n+        instantiationTypes.put(\"map\", \"Map\");\n+\n+        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n+    }\n+\n+    @Override\n+    public void processOpts() {\n+        super.processOpts();\n+\n+        if (additionalProperties.containsKey(CodegenConstants.INVOKER_PACKAGE)) {\n+            invokerPackage = (String) additionalProperties.get(CodegenConstants.INVOKER_PACKAGE);\n+        } else {\n+            additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.GROUP_ID)) {\n+            groupId = (String) additionalProperties.get(CodegenConstants.GROUP_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.GROUP_ID, groupId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_ID)) {\n+            artifactId = (String) additionalProperties.get(CodegenConstants.ARTIFACT_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_ID, artifactId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_VERSION)) {\n+            artifactVersion = (String) additionalProperties.get(CodegenConstants.ARTIFACT_VERSION);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_VERSION, artifactVersion);\n+        }\n+\n+        if (additionalProperties.containsKey(AKKA_HTTP_VERSION)) {\n+            akkaHttpVersion = (String) additionalProperties.get(AKKA_HTTP_VERSION);\n+        } else {\n+            additionalProperties.put(AKKA_HTTP_VERSION, akkaHttpVersion);\n+        }\n+\n+        parseAkkaHttpVersion();\n+\n+        supportingFiles.add(new SupportingFile(\"build.sbt.mustache\", \"\", \"build.sbt\"));\n+        supportingFiles.add(new SupportingFile(\"controller.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"Controller.scala\"));\n+        supportingFiles.add(new SupportingFile(\"helper.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"AkkaHttpHelper.scala\"));\n+        supportingFiles.add(new SupportingFile(\"stringDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"StringDirectives.scala\"));\n+        supportingFiles.add(new SupportingFile(\"multipartDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"MultipartDirectives.scala\"));\n+    }\n+\n+    private static final String IS_10_1_10_PLUS = \"akkaHttp10_1_10_plus\";\n+    private boolean is10_1_10AndAbove = false;\n+\n+    private static final Pattern akkaVersionPattern = Pattern.compile(\"([0-9]+)(\\\\.([0-9]+))?(\\\\.([0-9]+))?(.\\\\+)?\");\n+    private void parseAkkaHttpVersion() {\n+        Matcher matcher = akkaVersionPattern.matcher(akkaHttpVersion);\n+        if (matcher.matches()) {\n+            String majorS = matcher.group(1);\n+            String minorS = matcher.group(3);\n+            String patchS = matcher.group(5);\n+            boolean andAbove = matcher.group(6) != null;\n+            int major = -1, minor = -1, patch = -1;\n+            try {\n+                if (majorS != null) {\n+                    major = Integer.parseInt(majorS);\n+                    if (minorS != null) {\n+                        minor = Integer.parseInt(minorS);\n+                        if (patchS != null) {\n+                            patch = Integer.parseInt(patchS);\n+                        }\n+                    }\n+                }\n+\n+\n+                if (major > 10 || major == -1 && andAbove) {\n+                    is10_1_10AndAbove = true;\n+                } else if (major == 10) {\n+                    if (minor > 1 || minor == -1 && andAbove) {\n+                        is10_1_10AndAbove = true;\n+                    } else if (minor == 1) {\n+                        if (patch >= 10 || patch == -1 && andAbove) {\n+                            is10_1_10AndAbove = true;\n+                        }\n+                    }\n+                }\n+\n+            } catch (NumberFormatException e) {\n+                LOGGER.warn(\"Unable to parse \" + AKKA_HTTP_VERSION + \": \" + akkaHttpVersion + \", fallback to \" + DEFAULT_AKKA_HTTP_VERSION);\n+                akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+                is10_1_10AndAbove = true;\n+            }\n+        }\n+\n+        additionalProperties.put(IS_10_1_10_PLUS, is10_1_10AndAbove);\n+    }\n+\n+    @Override\n+    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, List<Server> servers) {\n+        CodegenOperation codegenOperation = super.fromOperation(path, httpMethod, operation, servers);\n+        addPathMatcher(codegenOperation);\n+        return codegenOperation;\n+    }\n+\n+    @Override\n+    public CodegenParameter fromParameter(Parameter parameter, Set<String> imports) {\n+        CodegenParameter param = super.fromParameter(parameter, imports);\n+        // Removing unhandled types\n+        if(!primitiveParamTypes.contains(param.dataType)) {\n+            param.dataType = \"String\";\n+        }\n+        if (!param.required) {\n+            param.vendorExtensions.put(\"hasDefaultValue\", param.defaultValue != null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "originalPosition": 233}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NzEwNjk4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#pullrequestreview-387710698", "createdAt": "2020-04-04T15:49:57Z", "commit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo0OTo1N1rOGAywQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo0OTo1N1rOGAywQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NDczNw==", "bodyText": "We've trying to normalize the naming of vendor extensions. I wonder if you can rename paths to x-paths instead.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403484737", "createdAt": "2020-04-04T15:49:57Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";\n+    }\n+\n+    public String getHelp() {\n+        return \"Generates a scala-akka-http server.\";\n+    }\n+\n+    public ScalaAkkaHttpServerCodegen() {\n+        super();\n+\n+        modifyFeatureSet(features -> features\n+                .includeDocumentationFeatures(DocumentationFeature.Readme)\n+                .wireFormatFeatures(EnumSet.of(WireFormatFeature.JSON, WireFormatFeature.XML, WireFormatFeature.Custom))\n+                .securityFeatures(EnumSet.of(\n+                        SecurityFeature.BasicAuth,\n+                        SecurityFeature.ApiKey,\n+                        SecurityFeature.BearerToken\n+                ))\n+                .excludeGlobalFeatures(\n+                        GlobalFeature.XMLStructureDefinitions,\n+                        GlobalFeature.Callbacks,\n+                        GlobalFeature.LinkObjects,\n+                        GlobalFeature.ParameterStyling\n+                )\n+                .excludeSchemaSupportFeatures(\n+                        SchemaSupportFeature.Polymorphism\n+                )\n+                .excludeParameterFeatures(\n+                        ParameterFeature.Cookie\n+                )\n+        );\n+\n+        outputFolder = \"generated-code\" + File.separator + \"scala-akka-http\";\n+        modelTemplateFiles.put(\"model.mustache\", \".scala\");\n+        apiTemplateFiles.put(\"api.mustache\", \".scala\");\n+        embeddedTemplateDir = templateDir = \"scala-akka-http-server\";\n+\n+        groupId = \"org.openapitools\";\n+        artifactId = \"openapi-scala-akka-http-server\";\n+        artifactVersion = \"1.0.0\";\n+        apiPackage = \"org.openapitools.server.api\";\n+        modelPackage = \"org.openapitools.server.model\";\n+        invokerPackage = \"org.openapitools.server\";\n+        akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+\n+        setReservedWordsLowerCase(\n+                Arrays.asList(\n+                        \"abstract\", \"case\", \"catch\", \"class\", \"def\", \"do\", \"else\", \"extends\",\n+                        \"false\", \"final\", \"finally\", \"for\", \"forSome\", \"if\", \"implicit\",\n+                        \"import\", \"lazy\", \"match\", \"new\", \"null\", \"object\", \"override\", \"package\",\n+                        \"private\", \"protected\", \"return\", \"sealed\", \"super\", \"this\", \"throw\",\n+                        \"trait\", \"try\", \"true\", \"type\", \"val\", \"var\", \"while\", \"with\", \"yield\")\n+        );\n+\n+        cliOptions.add(CliOption.newString(CodegenConstants.INVOKER_PACKAGE, CodegenConstants.INVOKER_PACKAGE_DESC).defaultValue(invokerPackage));\n+        cliOptions.add(CliOption.newString(CodegenConstants.GROUP_ID, CodegenConstants.GROUP_ID_DESC).defaultValue(groupId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_ID, CodegenConstants.ARTIFACT_ID).defaultValue(artifactId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_VERSION, CodegenConstants.ARTIFACT_VERSION_DESC).defaultValue(artifactVersion));\n+        cliOptions.add(CliOption.newString(AKKA_HTTP_VERSION, AKKA_HTTP_VERSION_DESC).defaultValue(akkaHttpVersion));\n+\n+        importMapping.remove(\"Seq\");\n+        importMapping.remove(\"List\");\n+        importMapping.remove(\"Set\");\n+        importMapping.remove(\"Map\");\n+\n+        typeMapping = new HashMap<>();\n+        typeMapping.put(\"array\", \"Seq\");\n+        typeMapping.put(\"set\", \"Set\");\n+        typeMapping.put(\"boolean\", \"Boolean\");\n+        typeMapping.put(\"string\", \"String\");\n+        typeMapping.put(\"int\", \"Int\");\n+        typeMapping.put(\"integer\", \"Int\");\n+        typeMapping.put(\"long\", \"Long\");\n+        typeMapping.put(\"float\", \"Float\");\n+        typeMapping.put(\"byte\", \"Byte\");\n+        typeMapping.put(\"short\", \"Short\");\n+        typeMapping.put(\"char\", \"Char\");\n+        typeMapping.put(\"double\", \"Double\");\n+        typeMapping.put(\"object\", \"Any\");\n+        typeMapping.put(\"file\", \"File\");\n+        typeMapping.put(\"binary\", \"File\");\n+        typeMapping.put(\"number\", \"Double\");\n+\n+        instantiationTypes.put(\"array\", \"ListBuffer\");\n+        instantiationTypes.put(\"map\", \"Map\");\n+\n+        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n+    }\n+\n+    @Override\n+    public void processOpts() {\n+        super.processOpts();\n+\n+        if (additionalProperties.containsKey(CodegenConstants.INVOKER_PACKAGE)) {\n+            invokerPackage = (String) additionalProperties.get(CodegenConstants.INVOKER_PACKAGE);\n+        } else {\n+            additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.GROUP_ID)) {\n+            groupId = (String) additionalProperties.get(CodegenConstants.GROUP_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.GROUP_ID, groupId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_ID)) {\n+            artifactId = (String) additionalProperties.get(CodegenConstants.ARTIFACT_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_ID, artifactId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_VERSION)) {\n+            artifactVersion = (String) additionalProperties.get(CodegenConstants.ARTIFACT_VERSION);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_VERSION, artifactVersion);\n+        }\n+\n+        if (additionalProperties.containsKey(AKKA_HTTP_VERSION)) {\n+            akkaHttpVersion = (String) additionalProperties.get(AKKA_HTTP_VERSION);\n+        } else {\n+            additionalProperties.put(AKKA_HTTP_VERSION, akkaHttpVersion);\n+        }\n+\n+        parseAkkaHttpVersion();\n+\n+        supportingFiles.add(new SupportingFile(\"build.sbt.mustache\", \"\", \"build.sbt\"));\n+        supportingFiles.add(new SupportingFile(\"controller.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"Controller.scala\"));\n+        supportingFiles.add(new SupportingFile(\"helper.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"AkkaHttpHelper.scala\"));\n+        supportingFiles.add(new SupportingFile(\"stringDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"StringDirectives.scala\"));\n+        supportingFiles.add(new SupportingFile(\"multipartDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"MultipartDirectives.scala\"));\n+    }\n+\n+    private static final String IS_10_1_10_PLUS = \"akkaHttp10_1_10_plus\";\n+    private boolean is10_1_10AndAbove = false;\n+\n+    private static final Pattern akkaVersionPattern = Pattern.compile(\"([0-9]+)(\\\\.([0-9]+))?(\\\\.([0-9]+))?(.\\\\+)?\");\n+    private void parseAkkaHttpVersion() {\n+        Matcher matcher = akkaVersionPattern.matcher(akkaHttpVersion);\n+        if (matcher.matches()) {\n+            String majorS = matcher.group(1);\n+            String minorS = matcher.group(3);\n+            String patchS = matcher.group(5);\n+            boolean andAbove = matcher.group(6) != null;\n+            int major = -1, minor = -1, patch = -1;\n+            try {\n+                if (majorS != null) {\n+                    major = Integer.parseInt(majorS);\n+                    if (minorS != null) {\n+                        minor = Integer.parseInt(minorS);\n+                        if (patchS != null) {\n+                            patch = Integer.parseInt(patchS);\n+                        }\n+                    }\n+                }\n+\n+\n+                if (major > 10 || major == -1 && andAbove) {\n+                    is10_1_10AndAbove = true;\n+                } else if (major == 10) {\n+                    if (minor > 1 || minor == -1 && andAbove) {\n+                        is10_1_10AndAbove = true;\n+                    } else if (minor == 1) {\n+                        if (patch >= 10 || patch == -1 && andAbove) {\n+                            is10_1_10AndAbove = true;\n+                        }\n+                    }\n+                }\n+\n+            } catch (NumberFormatException e) {\n+                LOGGER.warn(\"Unable to parse \" + AKKA_HTTP_VERSION + \": \" + akkaHttpVersion + \", fallback to \" + DEFAULT_AKKA_HTTP_VERSION);\n+                akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+                is10_1_10AndAbove = true;\n+            }\n+        }\n+\n+        additionalProperties.put(IS_10_1_10_PLUS, is10_1_10AndAbove);\n+    }\n+\n+    @Override\n+    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, List<Server> servers) {\n+        CodegenOperation codegenOperation = super.fromOperation(path, httpMethod, operation, servers);\n+        addPathMatcher(codegenOperation);\n+        return codegenOperation;\n+    }\n+\n+    @Override\n+    public CodegenParameter fromParameter(Parameter parameter, Set<String> imports) {\n+        CodegenParameter param = super.fromParameter(parameter, imports);\n+        // Removing unhandled types\n+        if(!primitiveParamTypes.contains(param.dataType)) {\n+            param.dataType = \"String\";\n+        }\n+        if (!param.required) {\n+            param.vendorExtensions.put(\"hasDefaultValue\", param.defaultValue != null);\n+            // Escaping default string values\n+            if (param.defaultValue != null && param.dataType.equals(\"String\")) {\n+                param.defaultValue = String.format(Locale.ROOT, \"\\\"%s\\\"\", param.defaultValue);\n+            }\n+        }\n+        return param;\n+    }\n+\n+\n+\n+    @Override\n+    public Map<String, Object> postProcessOperationsWithModels(Map<String, Object> objs, List<Object> allModels) {\n+        Map<String, Object> baseObjs = super.postProcessOperationsWithModels(objs, allModels);\n+        pathMatcherPatternsPostProcessor(baseObjs);\n+        marshallingPostProcessor(baseObjs);\n+        return baseObjs;\n+    }\n+\n+    private static Set<String> primitiveParamTypes = new HashSet<String>(){{\n+        addAll(Arrays.asList(\n+                \"Int\",\n+                \"Long\",\n+                \"Float\",\n+                \"Double\",\n+                \"Boolean\",\n+                \"String\"\n+        ));\n+    }};\n+\n+    private static Map<String, String> pathTypeToMatcher = new HashMap<String, String>(){{\n+        put(\"Int\", \"IntNumber\");\n+        put(\"Long\", \"LongNumber\");\n+        put(\"Float\",\"FloatNumber\");\n+        put(\"Double\",\"DoubleNumber\");\n+        put(\"Boolean\",\"Boolean\");\n+        put(\"String\", \"Segment\");\n+    }};\n+\n+    protected static void addPathMatcher(CodegenOperation codegenOperation) {\n+        LinkedList<String> allPaths = new LinkedList<>(Arrays.asList(codegenOperation.path.split(\"/\")));\n+        allPaths.removeIf(\"\"::equals);\n+\n+        LinkedList<TextOrMatcher> pathMatchers = new LinkedList<>();\n+        for(String path: allPaths){\n+            TextOrMatcher textOrMatcher = new TextOrMatcher(\"\", true, true);\n+            if(path.startsWith(\"{\") && path.endsWith(\"}\")) {\n+                String parameterName = path.substring(1, path.length()-1);\n+                for(CodegenParameter pathParam: codegenOperation.pathParams){\n+                    if(pathParam.baseName.equals(parameterName)) {\n+                        String matcher = pathTypeToMatcher.get(pathParam.dataType);\n+                        if(matcher == null) {\n+                            LOGGER.warn(\"The path parameter \" + pathParam.baseName +\n+                                    \" with the datatype \" + pathParam.dataType +\n+                                    \" could not be translated to a corresponding path matcher of akka http\" +\n+                                    \" and therefore has been translated to string.\");\n+                            matcher = pathTypeToMatcher.get(\"String\");\n+                        }\n+                        if (pathParam.pattern != null && !pathParam.pattern.isEmpty()) {\n+                            matcher = pathMatcherPatternName(pathParam);\n+                        }\n+                        textOrMatcher.value = matcher;\n+                        textOrMatcher.isText = false;\n+                        pathMatchers.add(textOrMatcher);\n+                    }\n+                }\n+            } else {\n+                textOrMatcher.value = path;\n+                textOrMatcher.isText = true;\n+                pathMatchers.add(textOrMatcher);\n+            }\n+        }\n+        pathMatchers.getLast().hasMore = false;\n+\n+        codegenOperation.vendorExtensions.put(\"paths\", pathMatchers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "originalPosition": 307}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NzEwNzIy", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#pullrequestreview-387710722", "createdAt": "2020-04-04T15:50:22Z", "commit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo1MDoyMlrOGAywWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo1MDoyMlrOGAywWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NDc2MQ==", "bodyText": "We've trying to normalize the naming of vendor extensions. I wonder if you can rename x-isDefault to x-is-default instead.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403484761", "createdAt": "2020-04-04T15:50:22Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";\n+    }\n+\n+    public String getHelp() {\n+        return \"Generates a scala-akka-http server.\";\n+    }\n+\n+    public ScalaAkkaHttpServerCodegen() {\n+        super();\n+\n+        modifyFeatureSet(features -> features\n+                .includeDocumentationFeatures(DocumentationFeature.Readme)\n+                .wireFormatFeatures(EnumSet.of(WireFormatFeature.JSON, WireFormatFeature.XML, WireFormatFeature.Custom))\n+                .securityFeatures(EnumSet.of(\n+                        SecurityFeature.BasicAuth,\n+                        SecurityFeature.ApiKey,\n+                        SecurityFeature.BearerToken\n+                ))\n+                .excludeGlobalFeatures(\n+                        GlobalFeature.XMLStructureDefinitions,\n+                        GlobalFeature.Callbacks,\n+                        GlobalFeature.LinkObjects,\n+                        GlobalFeature.ParameterStyling\n+                )\n+                .excludeSchemaSupportFeatures(\n+                        SchemaSupportFeature.Polymorphism\n+                )\n+                .excludeParameterFeatures(\n+                        ParameterFeature.Cookie\n+                )\n+        );\n+\n+        outputFolder = \"generated-code\" + File.separator + \"scala-akka-http\";\n+        modelTemplateFiles.put(\"model.mustache\", \".scala\");\n+        apiTemplateFiles.put(\"api.mustache\", \".scala\");\n+        embeddedTemplateDir = templateDir = \"scala-akka-http-server\";\n+\n+        groupId = \"org.openapitools\";\n+        artifactId = \"openapi-scala-akka-http-server\";\n+        artifactVersion = \"1.0.0\";\n+        apiPackage = \"org.openapitools.server.api\";\n+        modelPackage = \"org.openapitools.server.model\";\n+        invokerPackage = \"org.openapitools.server\";\n+        akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+\n+        setReservedWordsLowerCase(\n+                Arrays.asList(\n+                        \"abstract\", \"case\", \"catch\", \"class\", \"def\", \"do\", \"else\", \"extends\",\n+                        \"false\", \"final\", \"finally\", \"for\", \"forSome\", \"if\", \"implicit\",\n+                        \"import\", \"lazy\", \"match\", \"new\", \"null\", \"object\", \"override\", \"package\",\n+                        \"private\", \"protected\", \"return\", \"sealed\", \"super\", \"this\", \"throw\",\n+                        \"trait\", \"try\", \"true\", \"type\", \"val\", \"var\", \"while\", \"with\", \"yield\")\n+        );\n+\n+        cliOptions.add(CliOption.newString(CodegenConstants.INVOKER_PACKAGE, CodegenConstants.INVOKER_PACKAGE_DESC).defaultValue(invokerPackage));\n+        cliOptions.add(CliOption.newString(CodegenConstants.GROUP_ID, CodegenConstants.GROUP_ID_DESC).defaultValue(groupId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_ID, CodegenConstants.ARTIFACT_ID).defaultValue(artifactId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_VERSION, CodegenConstants.ARTIFACT_VERSION_DESC).defaultValue(artifactVersion));\n+        cliOptions.add(CliOption.newString(AKKA_HTTP_VERSION, AKKA_HTTP_VERSION_DESC).defaultValue(akkaHttpVersion));\n+\n+        importMapping.remove(\"Seq\");\n+        importMapping.remove(\"List\");\n+        importMapping.remove(\"Set\");\n+        importMapping.remove(\"Map\");\n+\n+        typeMapping = new HashMap<>();\n+        typeMapping.put(\"array\", \"Seq\");\n+        typeMapping.put(\"set\", \"Set\");\n+        typeMapping.put(\"boolean\", \"Boolean\");\n+        typeMapping.put(\"string\", \"String\");\n+        typeMapping.put(\"int\", \"Int\");\n+        typeMapping.put(\"integer\", \"Int\");\n+        typeMapping.put(\"long\", \"Long\");\n+        typeMapping.put(\"float\", \"Float\");\n+        typeMapping.put(\"byte\", \"Byte\");\n+        typeMapping.put(\"short\", \"Short\");\n+        typeMapping.put(\"char\", \"Char\");\n+        typeMapping.put(\"double\", \"Double\");\n+        typeMapping.put(\"object\", \"Any\");\n+        typeMapping.put(\"file\", \"File\");\n+        typeMapping.put(\"binary\", \"File\");\n+        typeMapping.put(\"number\", \"Double\");\n+\n+        instantiationTypes.put(\"array\", \"ListBuffer\");\n+        instantiationTypes.put(\"map\", \"Map\");\n+\n+        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n+    }\n+\n+    @Override\n+    public void processOpts() {\n+        super.processOpts();\n+\n+        if (additionalProperties.containsKey(CodegenConstants.INVOKER_PACKAGE)) {\n+            invokerPackage = (String) additionalProperties.get(CodegenConstants.INVOKER_PACKAGE);\n+        } else {\n+            additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.GROUP_ID)) {\n+            groupId = (String) additionalProperties.get(CodegenConstants.GROUP_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.GROUP_ID, groupId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_ID)) {\n+            artifactId = (String) additionalProperties.get(CodegenConstants.ARTIFACT_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_ID, artifactId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_VERSION)) {\n+            artifactVersion = (String) additionalProperties.get(CodegenConstants.ARTIFACT_VERSION);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_VERSION, artifactVersion);\n+        }\n+\n+        if (additionalProperties.containsKey(AKKA_HTTP_VERSION)) {\n+            akkaHttpVersion = (String) additionalProperties.get(AKKA_HTTP_VERSION);\n+        } else {\n+            additionalProperties.put(AKKA_HTTP_VERSION, akkaHttpVersion);\n+        }\n+\n+        parseAkkaHttpVersion();\n+\n+        supportingFiles.add(new SupportingFile(\"build.sbt.mustache\", \"\", \"build.sbt\"));\n+        supportingFiles.add(new SupportingFile(\"controller.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"Controller.scala\"));\n+        supportingFiles.add(new SupportingFile(\"helper.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"AkkaHttpHelper.scala\"));\n+        supportingFiles.add(new SupportingFile(\"stringDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"StringDirectives.scala\"));\n+        supportingFiles.add(new SupportingFile(\"multipartDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"MultipartDirectives.scala\"));\n+    }\n+\n+    private static final String IS_10_1_10_PLUS = \"akkaHttp10_1_10_plus\";\n+    private boolean is10_1_10AndAbove = false;\n+\n+    private static final Pattern akkaVersionPattern = Pattern.compile(\"([0-9]+)(\\\\.([0-9]+))?(\\\\.([0-9]+))?(.\\\\+)?\");\n+    private void parseAkkaHttpVersion() {\n+        Matcher matcher = akkaVersionPattern.matcher(akkaHttpVersion);\n+        if (matcher.matches()) {\n+            String majorS = matcher.group(1);\n+            String minorS = matcher.group(3);\n+            String patchS = matcher.group(5);\n+            boolean andAbove = matcher.group(6) != null;\n+            int major = -1, minor = -1, patch = -1;\n+            try {\n+                if (majorS != null) {\n+                    major = Integer.parseInt(majorS);\n+                    if (minorS != null) {\n+                        minor = Integer.parseInt(minorS);\n+                        if (patchS != null) {\n+                            patch = Integer.parseInt(patchS);\n+                        }\n+                    }\n+                }\n+\n+\n+                if (major > 10 || major == -1 && andAbove) {\n+                    is10_1_10AndAbove = true;\n+                } else if (major == 10) {\n+                    if (minor > 1 || minor == -1 && andAbove) {\n+                        is10_1_10AndAbove = true;\n+                    } else if (minor == 1) {\n+                        if (patch >= 10 || patch == -1 && andAbove) {\n+                            is10_1_10AndAbove = true;\n+                        }\n+                    }\n+                }\n+\n+            } catch (NumberFormatException e) {\n+                LOGGER.warn(\"Unable to parse \" + AKKA_HTTP_VERSION + \": \" + akkaHttpVersion + \", fallback to \" + DEFAULT_AKKA_HTTP_VERSION);\n+                akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+                is10_1_10AndAbove = true;\n+            }\n+        }\n+\n+        additionalProperties.put(IS_10_1_10_PLUS, is10_1_10AndAbove);\n+    }\n+\n+    @Override\n+    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, List<Server> servers) {\n+        CodegenOperation codegenOperation = super.fromOperation(path, httpMethod, operation, servers);\n+        addPathMatcher(codegenOperation);\n+        return codegenOperation;\n+    }\n+\n+    @Override\n+    public CodegenParameter fromParameter(Parameter parameter, Set<String> imports) {\n+        CodegenParameter param = super.fromParameter(parameter, imports);\n+        // Removing unhandled types\n+        if(!primitiveParamTypes.contains(param.dataType)) {\n+            param.dataType = \"String\";\n+        }\n+        if (!param.required) {\n+            param.vendorExtensions.put(\"hasDefaultValue\", param.defaultValue != null);\n+            // Escaping default string values\n+            if (param.defaultValue != null && param.dataType.equals(\"String\")) {\n+                param.defaultValue = String.format(Locale.ROOT, \"\\\"%s\\\"\", param.defaultValue);\n+            }\n+        }\n+        return param;\n+    }\n+\n+\n+\n+    @Override\n+    public Map<String, Object> postProcessOperationsWithModels(Map<String, Object> objs, List<Object> allModels) {\n+        Map<String, Object> baseObjs = super.postProcessOperationsWithModels(objs, allModels);\n+        pathMatcherPatternsPostProcessor(baseObjs);\n+        marshallingPostProcessor(baseObjs);\n+        return baseObjs;\n+    }\n+\n+    private static Set<String> primitiveParamTypes = new HashSet<String>(){{\n+        addAll(Arrays.asList(\n+                \"Int\",\n+                \"Long\",\n+                \"Float\",\n+                \"Double\",\n+                \"Boolean\",\n+                \"String\"\n+        ));\n+    }};\n+\n+    private static Map<String, String> pathTypeToMatcher = new HashMap<String, String>(){{\n+        put(\"Int\", \"IntNumber\");\n+        put(\"Long\", \"LongNumber\");\n+        put(\"Float\",\"FloatNumber\");\n+        put(\"Double\",\"DoubleNumber\");\n+        put(\"Boolean\",\"Boolean\");\n+        put(\"String\", \"Segment\");\n+    }};\n+\n+    protected static void addPathMatcher(CodegenOperation codegenOperation) {\n+        LinkedList<String> allPaths = new LinkedList<>(Arrays.asList(codegenOperation.path.split(\"/\")));\n+        allPaths.removeIf(\"\"::equals);\n+\n+        LinkedList<TextOrMatcher> pathMatchers = new LinkedList<>();\n+        for(String path: allPaths){\n+            TextOrMatcher textOrMatcher = new TextOrMatcher(\"\", true, true);\n+            if(path.startsWith(\"{\") && path.endsWith(\"}\")) {\n+                String parameterName = path.substring(1, path.length()-1);\n+                for(CodegenParameter pathParam: codegenOperation.pathParams){\n+                    if(pathParam.baseName.equals(parameterName)) {\n+                        String matcher = pathTypeToMatcher.get(pathParam.dataType);\n+                        if(matcher == null) {\n+                            LOGGER.warn(\"The path parameter \" + pathParam.baseName +\n+                                    \" with the datatype \" + pathParam.dataType +\n+                                    \" could not be translated to a corresponding path matcher of akka http\" +\n+                                    \" and therefore has been translated to string.\");\n+                            matcher = pathTypeToMatcher.get(\"String\");\n+                        }\n+                        if (pathParam.pattern != null && !pathParam.pattern.isEmpty()) {\n+                            matcher = pathMatcherPatternName(pathParam);\n+                        }\n+                        textOrMatcher.value = matcher;\n+                        textOrMatcher.isText = false;\n+                        pathMatchers.add(textOrMatcher);\n+                    }\n+                }\n+            } else {\n+                textOrMatcher.value = path;\n+                textOrMatcher.isText = true;\n+                pathMatchers.add(textOrMatcher);\n+            }\n+        }\n+        pathMatchers.getLast().hasMore = false;\n+\n+        codegenOperation.vendorExtensions.put(\"paths\", pathMatchers);\n+    }\n+\n+    public static String PATH_MATCHER_PATTERNS_KEY = \"pathMatcherPatterns\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void pathMatcherPatternsPostProcessor(Map<String, Object> objs) {\n+        if (objs != null) {\n+            HashMap<String, PathMatcherPattern> patternMap = new HashMap<>();\n+            Map<String, Object> operations = (Map<String, Object>) objs.get(\"operations\");\n+            if (operations != null) {\n+                List<CodegenOperation> ops = (List<CodegenOperation>) operations.get(\"operation\");\n+                for (CodegenOperation operation: ops) {\n+                    for (CodegenParameter parameter: operation.pathParams) {\n+                        if (parameter.pattern != null && !parameter.pattern.isEmpty()) {\n+                            String name = pathMatcherPatternName(parameter);\n+                            if (!patternMap.containsKey(name)) {\n+                                patternMap.put(name, new PathMatcherPattern(name, parameter.pattern.substring(1, parameter.pattern.length() - 1)));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            objs.put(PATH_MATCHER_PATTERNS_KEY, new ArrayList<>(patternMap.values()));\n+        }\n+    }\n+\n+    private static String pathMatcherPatternName(CodegenParameter parameter) {\n+        return parameter.paramName + \"Pattern\";\n+    }\n+\n+    // Responsible for setting up Marshallers/Unmarshallers\n+    @SuppressWarnings(\"unchecked\")\n+    public static void marshallingPostProcessor(Map<String, Object> objs) {\n+\n+        if (objs == null) {\n+            return;\n+        }\n+\n+        Set<Marshaller> entityUnmarshallerTypes = new HashSet<>();\n+        Set<Marshaller> entityMarshallerTypes = new HashSet<>();\n+        Set<Marshaller> stringUnmarshallerTypes = new HashSet<>();\n+        boolean hasCookieParams = false;\n+        boolean hasMultipart = false;\n+\n+        Map<String, Object> operations = (Map<String, Object>) objs.get(\"operations\");\n+        if (operations != null) {\n+            List<CodegenOperation> operationList = (List<CodegenOperation>) operations.get(\"operation\");\n+\n+            for (CodegenOperation op : operationList) {\n+                boolean isMultipart = op.isMultipart;\n+                hasMultipart |= isMultipart;\n+                hasCookieParams |= op.getHasCookieParams();\n+                ArrayList<CodegenParameter> fileParams = new ArrayList<>();\n+                ArrayList<CodegenParameter> nonFileParams = new ArrayList<>();\n+                for (CodegenParameter parameter : op.allParams) {\n+                    if (parameter.isBodyParam || parameter.isFormParam) {\n+                        if (parameter.isFile) {\n+                            fileParams.add(parameter.copy());\n+                        } else {\n+                            nonFileParams.add(parameter.copy());\n+                        }\n+                        if (!parameter.isPrimitiveType) {\n+                            if (isMultipart) {\n+                                stringUnmarshallerTypes.add(new Marshaller(parameter));\n+                            } else {\n+                                entityUnmarshallerTypes.add(new Marshaller(parameter));\n+                            }\n+                        }\n+                    }\n+                }\n+                for (int i = 0, size = fileParams.size(); i < size; ++i) {\n+                    fileParams.get(i).hasMore = i < size - 1;\n+                }\n+                for (int i = 0, size = nonFileParams.size(); i < size; ++i) {\n+                    nonFileParams.get(i).hasMore = i < size - 1;\n+                }\n+\n+                HashSet<Marshaller> operationSpecificMarshallers = new HashSet<>();\n+                for (CodegenResponse response : op.responses) {\n+                    if (!response.primitiveType) {\n+                        Marshaller marshaller = new Marshaller(response);\n+                        entityMarshallerTypes.add(marshaller);\n+                        operationSpecificMarshallers.add(marshaller);\n+                    }\n+                    response.vendorExtensions.put(\"isDefault\", response.code.equals(\"0\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "originalPosition": 392}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NzEwODM0", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#pullrequestreview-387710834", "createdAt": "2020-04-04T15:51:46Z", "commit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo1MTo0NlrOGAyw2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo1MTo0NlrOGAyw2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NDg4OQ==", "bodyText": "We're trying to normalize the naming of vendor extensions. I wonder if you can rename the extensions as followings:\n\nspecificMarshallers  to x-specific-marshallers \nfileParams to x-file-params\nnonFileParams to x-non-file-params", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403484889", "createdAt": "2020-04-04T15:51:46Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";\n+    }\n+\n+    public String getHelp() {\n+        return \"Generates a scala-akka-http server.\";\n+    }\n+\n+    public ScalaAkkaHttpServerCodegen() {\n+        super();\n+\n+        modifyFeatureSet(features -> features\n+                .includeDocumentationFeatures(DocumentationFeature.Readme)\n+                .wireFormatFeatures(EnumSet.of(WireFormatFeature.JSON, WireFormatFeature.XML, WireFormatFeature.Custom))\n+                .securityFeatures(EnumSet.of(\n+                        SecurityFeature.BasicAuth,\n+                        SecurityFeature.ApiKey,\n+                        SecurityFeature.BearerToken\n+                ))\n+                .excludeGlobalFeatures(\n+                        GlobalFeature.XMLStructureDefinitions,\n+                        GlobalFeature.Callbacks,\n+                        GlobalFeature.LinkObjects,\n+                        GlobalFeature.ParameterStyling\n+                )\n+                .excludeSchemaSupportFeatures(\n+                        SchemaSupportFeature.Polymorphism\n+                )\n+                .excludeParameterFeatures(\n+                        ParameterFeature.Cookie\n+                )\n+        );\n+\n+        outputFolder = \"generated-code\" + File.separator + \"scala-akka-http\";\n+        modelTemplateFiles.put(\"model.mustache\", \".scala\");\n+        apiTemplateFiles.put(\"api.mustache\", \".scala\");\n+        embeddedTemplateDir = templateDir = \"scala-akka-http-server\";\n+\n+        groupId = \"org.openapitools\";\n+        artifactId = \"openapi-scala-akka-http-server\";\n+        artifactVersion = \"1.0.0\";\n+        apiPackage = \"org.openapitools.server.api\";\n+        modelPackage = \"org.openapitools.server.model\";\n+        invokerPackage = \"org.openapitools.server\";\n+        akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+\n+        setReservedWordsLowerCase(\n+                Arrays.asList(\n+                        \"abstract\", \"case\", \"catch\", \"class\", \"def\", \"do\", \"else\", \"extends\",\n+                        \"false\", \"final\", \"finally\", \"for\", \"forSome\", \"if\", \"implicit\",\n+                        \"import\", \"lazy\", \"match\", \"new\", \"null\", \"object\", \"override\", \"package\",\n+                        \"private\", \"protected\", \"return\", \"sealed\", \"super\", \"this\", \"throw\",\n+                        \"trait\", \"try\", \"true\", \"type\", \"val\", \"var\", \"while\", \"with\", \"yield\")\n+        );\n+\n+        cliOptions.add(CliOption.newString(CodegenConstants.INVOKER_PACKAGE, CodegenConstants.INVOKER_PACKAGE_DESC).defaultValue(invokerPackage));\n+        cliOptions.add(CliOption.newString(CodegenConstants.GROUP_ID, CodegenConstants.GROUP_ID_DESC).defaultValue(groupId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_ID, CodegenConstants.ARTIFACT_ID).defaultValue(artifactId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_VERSION, CodegenConstants.ARTIFACT_VERSION_DESC).defaultValue(artifactVersion));\n+        cliOptions.add(CliOption.newString(AKKA_HTTP_VERSION, AKKA_HTTP_VERSION_DESC).defaultValue(akkaHttpVersion));\n+\n+        importMapping.remove(\"Seq\");\n+        importMapping.remove(\"List\");\n+        importMapping.remove(\"Set\");\n+        importMapping.remove(\"Map\");\n+\n+        typeMapping = new HashMap<>();\n+        typeMapping.put(\"array\", \"Seq\");\n+        typeMapping.put(\"set\", \"Set\");\n+        typeMapping.put(\"boolean\", \"Boolean\");\n+        typeMapping.put(\"string\", \"String\");\n+        typeMapping.put(\"int\", \"Int\");\n+        typeMapping.put(\"integer\", \"Int\");\n+        typeMapping.put(\"long\", \"Long\");\n+        typeMapping.put(\"float\", \"Float\");\n+        typeMapping.put(\"byte\", \"Byte\");\n+        typeMapping.put(\"short\", \"Short\");\n+        typeMapping.put(\"char\", \"Char\");\n+        typeMapping.put(\"double\", \"Double\");\n+        typeMapping.put(\"object\", \"Any\");\n+        typeMapping.put(\"file\", \"File\");\n+        typeMapping.put(\"binary\", \"File\");\n+        typeMapping.put(\"number\", \"Double\");\n+\n+        instantiationTypes.put(\"array\", \"ListBuffer\");\n+        instantiationTypes.put(\"map\", \"Map\");\n+\n+        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n+    }\n+\n+    @Override\n+    public void processOpts() {\n+        super.processOpts();\n+\n+        if (additionalProperties.containsKey(CodegenConstants.INVOKER_PACKAGE)) {\n+            invokerPackage = (String) additionalProperties.get(CodegenConstants.INVOKER_PACKAGE);\n+        } else {\n+            additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.GROUP_ID)) {\n+            groupId = (String) additionalProperties.get(CodegenConstants.GROUP_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.GROUP_ID, groupId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_ID)) {\n+            artifactId = (String) additionalProperties.get(CodegenConstants.ARTIFACT_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_ID, artifactId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_VERSION)) {\n+            artifactVersion = (String) additionalProperties.get(CodegenConstants.ARTIFACT_VERSION);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_VERSION, artifactVersion);\n+        }\n+\n+        if (additionalProperties.containsKey(AKKA_HTTP_VERSION)) {\n+            akkaHttpVersion = (String) additionalProperties.get(AKKA_HTTP_VERSION);\n+        } else {\n+            additionalProperties.put(AKKA_HTTP_VERSION, akkaHttpVersion);\n+        }\n+\n+        parseAkkaHttpVersion();\n+\n+        supportingFiles.add(new SupportingFile(\"build.sbt.mustache\", \"\", \"build.sbt\"));\n+        supportingFiles.add(new SupportingFile(\"controller.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"Controller.scala\"));\n+        supportingFiles.add(new SupportingFile(\"helper.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"AkkaHttpHelper.scala\"));\n+        supportingFiles.add(new SupportingFile(\"stringDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"StringDirectives.scala\"));\n+        supportingFiles.add(new SupportingFile(\"multipartDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"MultipartDirectives.scala\"));\n+    }\n+\n+    private static final String IS_10_1_10_PLUS = \"akkaHttp10_1_10_plus\";\n+    private boolean is10_1_10AndAbove = false;\n+\n+    private static final Pattern akkaVersionPattern = Pattern.compile(\"([0-9]+)(\\\\.([0-9]+))?(\\\\.([0-9]+))?(.\\\\+)?\");\n+    private void parseAkkaHttpVersion() {\n+        Matcher matcher = akkaVersionPattern.matcher(akkaHttpVersion);\n+        if (matcher.matches()) {\n+            String majorS = matcher.group(1);\n+            String minorS = matcher.group(3);\n+            String patchS = matcher.group(5);\n+            boolean andAbove = matcher.group(6) != null;\n+            int major = -1, minor = -1, patch = -1;\n+            try {\n+                if (majorS != null) {\n+                    major = Integer.parseInt(majorS);\n+                    if (minorS != null) {\n+                        minor = Integer.parseInt(minorS);\n+                        if (patchS != null) {\n+                            patch = Integer.parseInt(patchS);\n+                        }\n+                    }\n+                }\n+\n+\n+                if (major > 10 || major == -1 && andAbove) {\n+                    is10_1_10AndAbove = true;\n+                } else if (major == 10) {\n+                    if (minor > 1 || minor == -1 && andAbove) {\n+                        is10_1_10AndAbove = true;\n+                    } else if (minor == 1) {\n+                        if (patch >= 10 || patch == -1 && andAbove) {\n+                            is10_1_10AndAbove = true;\n+                        }\n+                    }\n+                }\n+\n+            } catch (NumberFormatException e) {\n+                LOGGER.warn(\"Unable to parse \" + AKKA_HTTP_VERSION + \": \" + akkaHttpVersion + \", fallback to \" + DEFAULT_AKKA_HTTP_VERSION);\n+                akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+                is10_1_10AndAbove = true;\n+            }\n+        }\n+\n+        additionalProperties.put(IS_10_1_10_PLUS, is10_1_10AndAbove);\n+    }\n+\n+    @Override\n+    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, List<Server> servers) {\n+        CodegenOperation codegenOperation = super.fromOperation(path, httpMethod, operation, servers);\n+        addPathMatcher(codegenOperation);\n+        return codegenOperation;\n+    }\n+\n+    @Override\n+    public CodegenParameter fromParameter(Parameter parameter, Set<String> imports) {\n+        CodegenParameter param = super.fromParameter(parameter, imports);\n+        // Removing unhandled types\n+        if(!primitiveParamTypes.contains(param.dataType)) {\n+            param.dataType = \"String\";\n+        }\n+        if (!param.required) {\n+            param.vendorExtensions.put(\"hasDefaultValue\", param.defaultValue != null);\n+            // Escaping default string values\n+            if (param.defaultValue != null && param.dataType.equals(\"String\")) {\n+                param.defaultValue = String.format(Locale.ROOT, \"\\\"%s\\\"\", param.defaultValue);\n+            }\n+        }\n+        return param;\n+    }\n+\n+\n+\n+    @Override\n+    public Map<String, Object> postProcessOperationsWithModels(Map<String, Object> objs, List<Object> allModels) {\n+        Map<String, Object> baseObjs = super.postProcessOperationsWithModels(objs, allModels);\n+        pathMatcherPatternsPostProcessor(baseObjs);\n+        marshallingPostProcessor(baseObjs);\n+        return baseObjs;\n+    }\n+\n+    private static Set<String> primitiveParamTypes = new HashSet<String>(){{\n+        addAll(Arrays.asList(\n+                \"Int\",\n+                \"Long\",\n+                \"Float\",\n+                \"Double\",\n+                \"Boolean\",\n+                \"String\"\n+        ));\n+    }};\n+\n+    private static Map<String, String> pathTypeToMatcher = new HashMap<String, String>(){{\n+        put(\"Int\", \"IntNumber\");\n+        put(\"Long\", \"LongNumber\");\n+        put(\"Float\",\"FloatNumber\");\n+        put(\"Double\",\"DoubleNumber\");\n+        put(\"Boolean\",\"Boolean\");\n+        put(\"String\", \"Segment\");\n+    }};\n+\n+    protected static void addPathMatcher(CodegenOperation codegenOperation) {\n+        LinkedList<String> allPaths = new LinkedList<>(Arrays.asList(codegenOperation.path.split(\"/\")));\n+        allPaths.removeIf(\"\"::equals);\n+\n+        LinkedList<TextOrMatcher> pathMatchers = new LinkedList<>();\n+        for(String path: allPaths){\n+            TextOrMatcher textOrMatcher = new TextOrMatcher(\"\", true, true);\n+            if(path.startsWith(\"{\") && path.endsWith(\"}\")) {\n+                String parameterName = path.substring(1, path.length()-1);\n+                for(CodegenParameter pathParam: codegenOperation.pathParams){\n+                    if(pathParam.baseName.equals(parameterName)) {\n+                        String matcher = pathTypeToMatcher.get(pathParam.dataType);\n+                        if(matcher == null) {\n+                            LOGGER.warn(\"The path parameter \" + pathParam.baseName +\n+                                    \" with the datatype \" + pathParam.dataType +\n+                                    \" could not be translated to a corresponding path matcher of akka http\" +\n+                                    \" and therefore has been translated to string.\");\n+                            matcher = pathTypeToMatcher.get(\"String\");\n+                        }\n+                        if (pathParam.pattern != null && !pathParam.pattern.isEmpty()) {\n+                            matcher = pathMatcherPatternName(pathParam);\n+                        }\n+                        textOrMatcher.value = matcher;\n+                        textOrMatcher.isText = false;\n+                        pathMatchers.add(textOrMatcher);\n+                    }\n+                }\n+            } else {\n+                textOrMatcher.value = path;\n+                textOrMatcher.isText = true;\n+                pathMatchers.add(textOrMatcher);\n+            }\n+        }\n+        pathMatchers.getLast().hasMore = false;\n+\n+        codegenOperation.vendorExtensions.put(\"paths\", pathMatchers);\n+    }\n+\n+    public static String PATH_MATCHER_PATTERNS_KEY = \"pathMatcherPatterns\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void pathMatcherPatternsPostProcessor(Map<String, Object> objs) {\n+        if (objs != null) {\n+            HashMap<String, PathMatcherPattern> patternMap = new HashMap<>();\n+            Map<String, Object> operations = (Map<String, Object>) objs.get(\"operations\");\n+            if (operations != null) {\n+                List<CodegenOperation> ops = (List<CodegenOperation>) operations.get(\"operation\");\n+                for (CodegenOperation operation: ops) {\n+                    for (CodegenParameter parameter: operation.pathParams) {\n+                        if (parameter.pattern != null && !parameter.pattern.isEmpty()) {\n+                            String name = pathMatcherPatternName(parameter);\n+                            if (!patternMap.containsKey(name)) {\n+                                patternMap.put(name, new PathMatcherPattern(name, parameter.pattern.substring(1, parameter.pattern.length() - 1)));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            objs.put(PATH_MATCHER_PATTERNS_KEY, new ArrayList<>(patternMap.values()));\n+        }\n+    }\n+\n+    private static String pathMatcherPatternName(CodegenParameter parameter) {\n+        return parameter.paramName + \"Pattern\";\n+    }\n+\n+    // Responsible for setting up Marshallers/Unmarshallers\n+    @SuppressWarnings(\"unchecked\")\n+    public static void marshallingPostProcessor(Map<String, Object> objs) {\n+\n+        if (objs == null) {\n+            return;\n+        }\n+\n+        Set<Marshaller> entityUnmarshallerTypes = new HashSet<>();\n+        Set<Marshaller> entityMarshallerTypes = new HashSet<>();\n+        Set<Marshaller> stringUnmarshallerTypes = new HashSet<>();\n+        boolean hasCookieParams = false;\n+        boolean hasMultipart = false;\n+\n+        Map<String, Object> operations = (Map<String, Object>) objs.get(\"operations\");\n+        if (operations != null) {\n+            List<CodegenOperation> operationList = (List<CodegenOperation>) operations.get(\"operation\");\n+\n+            for (CodegenOperation op : operationList) {\n+                boolean isMultipart = op.isMultipart;\n+                hasMultipart |= isMultipart;\n+                hasCookieParams |= op.getHasCookieParams();\n+                ArrayList<CodegenParameter> fileParams = new ArrayList<>();\n+                ArrayList<CodegenParameter> nonFileParams = new ArrayList<>();\n+                for (CodegenParameter parameter : op.allParams) {\n+                    if (parameter.isBodyParam || parameter.isFormParam) {\n+                        if (parameter.isFile) {\n+                            fileParams.add(parameter.copy());\n+                        } else {\n+                            nonFileParams.add(parameter.copy());\n+                        }\n+                        if (!parameter.isPrimitiveType) {\n+                            if (isMultipart) {\n+                                stringUnmarshallerTypes.add(new Marshaller(parameter));\n+                            } else {\n+                                entityUnmarshallerTypes.add(new Marshaller(parameter));\n+                            }\n+                        }\n+                    }\n+                }\n+                for (int i = 0, size = fileParams.size(); i < size; ++i) {\n+                    fileParams.get(i).hasMore = i < size - 1;\n+                }\n+                for (int i = 0, size = nonFileParams.size(); i < size; ++i) {\n+                    nonFileParams.get(i).hasMore = i < size - 1;\n+                }\n+\n+                HashSet<Marshaller> operationSpecificMarshallers = new HashSet<>();\n+                for (CodegenResponse response : op.responses) {\n+                    if (!response.primitiveType) {\n+                        Marshaller marshaller = new Marshaller(response);\n+                        entityMarshallerTypes.add(marshaller);\n+                        operationSpecificMarshallers.add(marshaller);\n+                    }\n+                    response.vendorExtensions.put(\"isDefault\", response.code.equals(\"0\"));\n+                }\n+                op.vendorExtensions.put(\"specificMarshallers\", operationSpecificMarshallers);\n+                op.vendorExtensions.put(\"fileParams\", fileParams);\n+                op.vendorExtensions.put(\"nonFileParams\", nonFileParams);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "originalPosition": 396}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2518, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}