{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NDE2NTcy", "number": 6518, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxOTozMDoxM1rOEEBkMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNjoxNDowMlrOEdzw6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjU1NDA4OnYy", "diffSide": "RIGHT", "path": "samples/openapi3/client/petstore/java/jersey2-java8/src/main/java/org/openapitools/client/model/Pig.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxOTozMDoxM1rOGhZIVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTowOTo0OVrOGh5hFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2NzkyNg==", "bodyText": "So it looks like this sets this.instance = to the deserialized instance of BasquePig where this is a Pig instance? Is that right?\nWhy include the BasquePig instances in this Pig instance vs just returning the instance of BasquePig?\nYou mentioned a use case when a client may want to change the type of an instance from\nBasquePig to DanishPig.\nThat is possible if one knows about the ancestor class Pig, which the client would know because that is the data type that is being deserialized.\nMy understanding is that you want a client to be able to change a model instance class type(BasquePig/DanishPig) given only the deserialized instance and NOT having to know about the ingested data type, is that right?\nCan you describe a more realistic use case than converting pig types?\nWhy do clients need this ability to change model instance types given a model instance only?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6518#discussion_r437667926", "createdAt": "2020-06-09T19:30:13Z", "author": {"login": "spacether"}, "path": "samples/openapi3/client/petstore/java/jersey2-java8/src/main/java/org/openapitools/client/model/Pig.java", "diffHunk": "@@ -60,12 +88,30 @@ public PigDeserializer(Class<?> vc) {\n         @Override\n         public Pig deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n             JsonNode tree = jp.readValueAsTree();\n+            Object deserialized = null;\n+            Pig newPig = new Pig();\n+            Map<String,Object> result2 = tree.traverse(jp.getCodec()).readValueAs(new TypeReference<Map<String, Object>>() {});\n+            String discriminatorValue = (String)result2.get(\"className\");\n+            switch (discriminatorValue) {\n+                case \"BasquePig\":\n+                    deserialized = tree.traverse(jp.getCodec()).readValueAs(BasquePig.class);\n+                    newPig.setActualInstance(deserialized);\n+                    return newPig;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "087382196e36b06c9be43221cee2815dd1e68cba"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0MzMzOQ==", "bodyText": "So it looks like this sets this.instance = to the deserialized instance of BasquePig where this is a Pig instance? Is that right?\n\nYes\n\nWhy include the BasquePig instances in this Pig instance vs just returning the instance of BasquePig?\n\nBecause Pig is an oneOf. Just returning BasqueBig means the client will lose the information that the return type is oneOf and DanishPig is another possibility.\n\nThat is possible if one knows about the ancestor class Pig, which the client would know because that is the data type that is being deserialized.\n\nYou mean DanishPig stores the oneOf schema information (Pig in this case)? What if DanishPig happens to be the oneOf schema node in \"Creature\" or \"Animal\" oneOf schema?\n\nMy understanding is that you want a client to be able to change a model instance class type(BasquePig/DanishPig) given only the deserialized instance and NOT having to know about the ingested data type, is that right?\n\nOne can change the model (DanishPig or BasqueBig) in the client side independent of how \"Pig\" is created - whether it's deserialized from a payload returned by the server or it's created in the client side from scratch.\n\nCan you describe a more realistic use case than converting pig types?\n\n\nThe client calls the petPig and gets a Pig (which happens to be a DanishPig in this example)\nThe client changes the instance from DanishPig to Snake and got an error (which is the expected behaviour according to the spec)\nThe client changes the instance form DanishPig to BasqueBig and got no error\nThe client calls updatePet with the Pig object (originally obtained from getPig) with the underlying instance set to BasqueBig in the above step\nThe server checks the payload (BasqueBig) and accepts it since it conforms to the Pig definition (oneOf)\n\nI would suggest you step back from actual use case as OpenAPI spec is a contract and the implementation should work with respect to the contract. (this is not to say real use cases are bad)", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6518#discussion_r437843339", "createdAt": "2020-06-10T03:45:52Z", "author": {"login": "wing328"}, "path": "samples/openapi3/client/petstore/java/jersey2-java8/src/main/java/org/openapitools/client/model/Pig.java", "diffHunk": "@@ -60,12 +88,30 @@ public PigDeserializer(Class<?> vc) {\n         @Override\n         public Pig deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n             JsonNode tree = jp.readValueAsTree();\n+            Object deserialized = null;\n+            Pig newPig = new Pig();\n+            Map<String,Object> result2 = tree.traverse(jp.getCodec()).readValueAs(new TypeReference<Map<String, Object>>() {});\n+            String discriminatorValue = (String)result2.get(\"className\");\n+            switch (discriminatorValue) {\n+                case \"BasquePig\":\n+                    deserialized = tree.traverse(jp.getCodec()).readValueAs(BasquePig.class);\n+                    newPig.setActualInstance(deserialized);\n+                    return newPig;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2NzkyNg=="}, "originalCommit": {"oid": "087382196e36b06c9be43221cee2815dd1e68cba"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5ODU0OQ==", "bodyText": "I would suggest you step back from actual use case as OpenAPI spec is a contract and the implementation should work with respect to the contract. (this is not to say real use cases are bad)\n\nCan you point to a section of the OAI spec where the \"contract\" would be broken if the SDK returns a BasquePig instead of Pig? The OAI spec is mostly about validation. I don't see wording that states what kind of implementation objects a client is supposed to return or generate.\nIMO, a client should be able to expose all of the following methods. I don't see anything in the spec that would block a client from exposing useful methods to the application code. There isn't a single \"right\" method.\n\nA method that returns the direct oneOf schema, e.g. Pig in this example.\nA method that returns the most concrete schema instance, e.g. BasquePig in this example\nA method that returns the raw JSON node\nAny other method that the SDK developer think is useful to application developers.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6518#discussion_r438198549", "createdAt": "2020-06-10T15:09:49Z", "author": {"login": "sebastien-rosset"}, "path": "samples/openapi3/client/petstore/java/jersey2-java8/src/main/java/org/openapitools/client/model/Pig.java", "diffHunk": "@@ -60,12 +88,30 @@ public PigDeserializer(Class<?> vc) {\n         @Override\n         public Pig deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n             JsonNode tree = jp.readValueAsTree();\n+            Object deserialized = null;\n+            Pig newPig = new Pig();\n+            Map<String,Object> result2 = tree.traverse(jp.getCodec()).readValueAs(new TypeReference<Map<String, Object>>() {});\n+            String discriminatorValue = (String)result2.get(\"className\");\n+            switch (discriminatorValue) {\n+                case \"BasquePig\":\n+                    deserialized = tree.traverse(jp.getCodec()).readValueAs(BasquePig.class);\n+                    newPig.setActualInstance(deserialized);\n+                    return newPig;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2NzkyNg=="}, "originalCommit": {"oid": "087382196e36b06c9be43221cee2815dd1e68cba"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NjkyMjY2OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/resources/Java/libraries/jersey2/model.mustache", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNjoxNDowMlrOHJMcWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNjoxNDowMlrOHJMcWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQwMzA5OA==", "bodyText": "Hello @wing328 ,\nWould you know why this import is required? I'm trying to generate code without the supporting files and it does not compile because of this import", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6518#discussion_r479403098", "createdAt": "2020-08-28T16:14:02Z", "author": {"login": "symphony-youri"}, "path": "modules/openapi-generator/src/main/resources/Java/libraries/jersey2/model.mustache", "diffHunk": "@@ -39,9 +51,16 @@ import javax.validation.Valid;\n {{#performBeanValidation}}\n import org.hibernate.validator.constraints.*;\n {{/performBeanValidation}}\n+import {{invokerPackage}}.JSON;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "087382196e36b06c9be43221cee2815dd1e68cba"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3403, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}