{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4NTI2Nzk4", "number": 4906, "reviewThreads": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxODowNzozMlrODWoBOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTo0NzowOFrODzPAbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MDUwOTM5OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxODowNzozM1rOFbfSyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwMzozNTo0MFrOFbqKBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM2ODU4Ng==", "bodyText": "It would be good to add function comments and essentially copy the text from the PR to help understand what this is doing.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r364368586", "createdAt": "2020-01-08T18:07:33Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,49 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47477c0cf1949657b464ec4f7fd7c11bfeae1016"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU0NjU2NQ==", "bodyText": "Added a document comment describing what this function is doing", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r364546565", "createdAt": "2020-01-09T03:35:40Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,49 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM2ODU4Ng=="}, "originalCommit": {"oid": "47477c0cf1949657b464ec4f7fd7c11bfeae1016"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTk0NTgzOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "isResolved": true, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNTowMDoyNFrOFhT9yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToyMDo0OVrOFveC1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw==", "bodyText": "@spacether question... Could you include a test for the operation response model as well?\nThis test is great for direct Schema reference, but we often have issue with $ref processing to those schemas.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370474443", "createdAt": "2020-01-24T05:00:24Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "diffHunk": "@@ -548,14 +539,31 @@ public void testFreeFormObjects() {\n     public void testBearerAuth() {\n         final OpenAPI openAPI = TestUtils.parseSpec(\"src/test/resources/3_0/pingBearerAuth.yaml\");\n         JavaClientCodegen codegen = new JavaClientCodegen();\n-        \n+\n         List<CodegenSecurity> security = codegen.fromSecurity(openAPI.getComponents().getSecuritySchemes());\n         Assert.assertEquals(security.size(), 1);\n         Assert.assertEquals(security.get(0).isBasic, Boolean.TRUE);\n         Assert.assertEquals(security.get(0).isBasicBasic, Boolean.FALSE);\n         Assert.assertEquals(security.get(0).isBasicBearer, Boolean.TRUE);\n     }\n \n+    @Test\n+    public void testComposedSchemaOneOfDiscriminatorMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwMDA1Ng==", "bodyText": "I have added tests of:\n\ninline oneOf schemas\ninline oneOf schemas with inline oneOf schemas\n$ref oneOf schemas that include the discriminator in self (non-composed schema)\n$ref oneOf schemas that include the discriminator with oneOf $ref\n$ref oneOf schemas that include the discriminator with anyOf $ref\n$ref oneOf schemas that include the discriminator with allOf $ref\n$ref oneOf child model where the discriminator is in a composed schema grandparent (requires recursive functionality)", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370900056", "createdAt": "2020-01-25T00:57:08Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "diffHunk": "@@ -548,14 +539,31 @@ public void testFreeFormObjects() {\n     public void testBearerAuth() {\n         final OpenAPI openAPI = TestUtils.parseSpec(\"src/test/resources/3_0/pingBearerAuth.yaml\");\n         JavaClientCodegen codegen = new JavaClientCodegen();\n-        \n+\n         List<CodegenSecurity> security = codegen.fromSecurity(openAPI.getComponents().getSecuritySchemes());\n         Assert.assertEquals(security.size(), 1);\n         Assert.assertEquals(security.get(0).isBasic, Boolean.TRUE);\n         Assert.assertEquals(security.get(0).isBasicBasic, Boolean.FALSE);\n         Assert.assertEquals(security.get(0).isBasicBearer, Boolean.TRUE);\n     }\n \n+    @Test\n+    public void testComposedSchemaOneOfDiscriminatorMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4ODQxMQ==", "bodyText": "@jimschubert what tests do you want on Endpoint responses?\nOur inlinemodelresolver code does not extract inline schemas for composed models in the request body or the response per https://github.com/OpenAPITools/openapi-generator/blob/master/modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java#L257.\nChecking that the dataType is the referenced model name does not seem like a test that proves anything here as that is standard generator behavior.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r373188411", "createdAt": "2020-01-30T20:55:09Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "diffHunk": "@@ -548,14 +539,31 @@ public void testFreeFormObjects() {\n     public void testBearerAuth() {\n         final OpenAPI openAPI = TestUtils.parseSpec(\"src/test/resources/3_0/pingBearerAuth.yaml\");\n         JavaClientCodegen codegen = new JavaClientCodegen();\n-        \n+\n         List<CodegenSecurity> security = codegen.fromSecurity(openAPI.getComponents().getSecuritySchemes());\n         Assert.assertEquals(security.size(), 1);\n         Assert.assertEquals(security.get(0).isBasic, Boolean.TRUE);\n         Assert.assertEquals(security.get(0).isBasicBasic, Boolean.FALSE);\n         Assert.assertEquals(security.get(0).isBasicBearer, Boolean.TRUE);\n     }\n \n+    @Test\n+    public void testComposedSchemaOneOfDiscriminatorMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MjMwNw==", "bodyText": "@spacether I'm sorry, but I don't follow your question, or why you've linked to InlineModelResolver when I'd asked about $ref.  Responses are processed similarly to all other models (see: \n  \n    \n      openapi-generator/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java\n    \n    \n         Line 2001\n      in\n      e45a1d0\n    \n    \n    \n    \n\n        \n          \n           String ref = ModelUtils.getSimpleRef(interfaceSchema.get$ref()); \n        \n    \n  \n\n). However, composed models have special rules around  how structure is defined in the presence of absence of discriminator and explicitly defines that inline models are ignored when using discriminator in most (all? I'd have to look again) cases. I'm confused because you appear to only be supporting discriminator based Schemas, and the spec says to drop inline models in those cases.\nJust for clarification so I understand what part of the spec is being done in the PR (it would help me in the review), can you describe your intended behaviors with respect to the three composed schemas, each with and without discriminator, and what you consider to be the outputs?  In reading your comments in Slack and in the PR, it's seems like you're only targeting inheritance (which is fine) and making some assumptions about the spec (which is fine as long as it's clearly explained to the user). I can't tell from the code or comments if this is intentional or not. That is, is the goal a short-term implementation path without breaking existing code?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374472307", "createdAt": "2020-02-04T04:45:37Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "diffHunk": "@@ -548,14 +539,31 @@ public void testFreeFormObjects() {\n     public void testBearerAuth() {\n         final OpenAPI openAPI = TestUtils.parseSpec(\"src/test/resources/3_0/pingBearerAuth.yaml\");\n         JavaClientCodegen codegen = new JavaClientCodegen();\n-        \n+\n         List<CodegenSecurity> security = codegen.fromSecurity(openAPI.getComponents().getSecuritySchemes());\n         Assert.assertEquals(security.size(), 1);\n         Assert.assertEquals(security.get(0).isBasic, Boolean.TRUE);\n         Assert.assertEquals(security.get(0).isBasicBasic, Boolean.FALSE);\n         Assert.assertEquals(security.get(0).isBasicBearer, Boolean.TRUE);\n     }\n \n+    @Test\n+    public void testComposedSchemaOneOfDiscriminatorMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NTU1MQ==", "bodyText": "Didn't I address your ref issue?\nYou asked 'Could you include a test for the operation response model' which I interpret as an endpoint operation response model. Can you describe what you want tested there? I don't know.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374475551", "createdAt": "2020-02-04T05:03:46Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "diffHunk": "@@ -548,14 +539,31 @@ public void testFreeFormObjects() {\n     public void testBearerAuth() {\n         final OpenAPI openAPI = TestUtils.parseSpec(\"src/test/resources/3_0/pingBearerAuth.yaml\");\n         JavaClientCodegen codegen = new JavaClientCodegen();\n-        \n+\n         List<CodegenSecurity> security = codegen.fromSecurity(openAPI.getComponents().getSecuritySchemes());\n         Assert.assertEquals(security.size(), 1);\n         Assert.assertEquals(security.get(0).isBasic, Boolean.TRUE);\n         Assert.assertEquals(security.get(0).isBasicBasic, Boolean.FALSE);\n         Assert.assertEquals(security.get(0).isBasicBearer, Boolean.TRUE);\n     }\n \n+    @Test\n+    public void testComposedSchemaOneOfDiscriminatorMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3Njg0OQ==", "bodyText": "The test cases show the behavior that I intend.\nThis PR is filling the discriminator map when we have enough info to do so. It only fills it if the discriminator exists. For composed schemas with no discriminator it does nothing.\nCan you please let us know where the spec says to 'drop inline models in those cases'. Can you clarify what that phrase means? I don't understand it.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374476849", "createdAt": "2020-02-04T05:10:31Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "diffHunk": "@@ -548,14 +539,31 @@ public void testFreeFormObjects() {\n     public void testBearerAuth() {\n         final OpenAPI openAPI = TestUtils.parseSpec(\"src/test/resources/3_0/pingBearerAuth.yaml\");\n         JavaClientCodegen codegen = new JavaClientCodegen();\n-        \n+\n         List<CodegenSecurity> security = codegen.fromSecurity(openAPI.getComponents().getSecuritySchemes());\n         Assert.assertEquals(security.size(), 1);\n         Assert.assertEquals(security.get(0).isBasic, Boolean.TRUE);\n         Assert.assertEquals(security.get(0).isBasicBasic, Boolean.FALSE);\n         Assert.assertEquals(security.get(0).isBasicBearer, Boolean.TRUE);\n     }\n \n+    @Test\n+    public void testComposedSchemaOneOfDiscriminatorMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNzAzNg==", "bodyText": "Maybe I've missed the test cases that include the negative cases when these don't have discriminator, and that's lead to some confusion? Let me look at it again later, and if I have time I'll write any additional cases for it.\nThe code is bailing when there's no $ref on line 2220 (the continue with comment starting \"for schemas with no ref\"), but that comment provides the wrong reason for bailing on inline schemas.. it's not that we can't get a model name but that it's defined that way in the spec.\nAs you mentioned in another comment, there are times when we find a similar schema and convert to a ref to that schema. I don't think that's correct or intuitive behavior, and I think has lead to some confusion for me (as a reviewer) and for you (as it makes it impossible to match a few cases in the spec).\nSpecifically, the spec at https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#discriminator-object says:\n\nWhen using the discriminator, inline schemas will not be considered.\n\nIt doesn't say \"inline models with discriminator may automagically point to an existing $ref\".\nIn other words, when we're processing discriminator of composed models, we shouldn't be traversing and properties of something defined as an inline object. But, because we try to normalize/flatten these models before this path... we can't match the spec here.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374637036", "createdAt": "2020-02-04T12:18:15Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "diffHunk": "@@ -548,14 +539,31 @@ public void testFreeFormObjects() {\n     public void testBearerAuth() {\n         final OpenAPI openAPI = TestUtils.parseSpec(\"src/test/resources/3_0/pingBearerAuth.yaml\");\n         JavaClientCodegen codegen = new JavaClientCodegen();\n-        \n+\n         List<CodegenSecurity> security = codegen.fromSecurity(openAPI.getComponents().getSecuritySchemes());\n         Assert.assertEquals(security.size(), 1);\n         Assert.assertEquals(security.get(0).isBasic, Boolean.TRUE);\n         Assert.assertEquals(security.get(0).isBasicBasic, Boolean.FALSE);\n         Assert.assertEquals(security.get(0).isBasicBearer, Boolean.TRUE);\n     }\n \n+    @Test\n+    public void testComposedSchemaOneOfDiscriminatorMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1OTkwNQ==", "bodyText": "Maybe I've missed the test cases that include the negative cases when these don't have discriminator\n\nThis code path is only used when a discriminator exists, so it does not make sense to add tests which lack a discriminator\nThe function addComposedMappedModels has been updated to now throw an exception if a null ref is seen. We also have a test of it.\nIn my opinion we should handle fixing the inline model resolver for composed schemas in a separate PR as that is scope creep. The scope here is defining the discriminator map.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374859905", "createdAt": "2020-02-04T18:56:36Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "diffHunk": "@@ -548,14 +539,31 @@ public void testFreeFormObjects() {\n     public void testBearerAuth() {\n         final OpenAPI openAPI = TestUtils.parseSpec(\"src/test/resources/3_0/pingBearerAuth.yaml\");\n         JavaClientCodegen codegen = new JavaClientCodegen();\n-        \n+\n         List<CodegenSecurity> security = codegen.fromSecurity(openAPI.getComponents().getSecuritySchemes());\n         Assert.assertEquals(security.size(), 1);\n         Assert.assertEquals(security.get(0).isBasic, Boolean.TRUE);\n         Assert.assertEquals(security.get(0).isBasicBasic, Boolean.FALSE);\n         Assert.assertEquals(security.get(0).isBasicBearer, Boolean.TRUE);\n     }\n \n+    @Test\n+    public void testComposedSchemaOneOfDiscriminatorMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3MjU0MQ==", "bodyText": "@jimschubert please let me know if your concerns have been addressed.\nA separate ticket has been made for the stack overflow work here\nA separate ticket has been filed to fix the inline model resolver here", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r375972541", "createdAt": "2020-02-06T17:21:13Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "diffHunk": "@@ -548,14 +539,31 @@ public void testFreeFormObjects() {\n     public void testBearerAuth() {\n         final OpenAPI openAPI = TestUtils.parseSpec(\"src/test/resources/3_0/pingBearerAuth.yaml\");\n         JavaClientCodegen codegen = new JavaClientCodegen();\n-        \n+\n         List<CodegenSecurity> security = codegen.fromSecurity(openAPI.getComponents().getSecuritySchemes());\n         Assert.assertEquals(security.size(), 1);\n         Assert.assertEquals(security.get(0).isBasic, Boolean.TRUE);\n         Assert.assertEquals(security.get(0).isBasicBasic, Boolean.FALSE);\n         Assert.assertEquals(security.get(0).isBasicBearer, Boolean.TRUE);\n     }\n \n+    @Test\n+    public void testComposedSchemaOneOfDiscriminatorMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxOTYzNg==", "bodyText": "Please see our added tests above in testComposedSchemaAllOfDiscriminatorMap", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r385319636", "createdAt": "2020-02-27T19:20:49Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "diffHunk": "@@ -548,14 +539,31 @@ public void testFreeFormObjects() {\n     public void testBearerAuth() {\n         final OpenAPI openAPI = TestUtils.parseSpec(\"src/test/resources/3_0/pingBearerAuth.yaml\");\n         JavaClientCodegen codegen = new JavaClientCodegen();\n-        \n+\n         List<CodegenSecurity> security = codegen.fromSecurity(openAPI.getComponents().getSecuritySchemes());\n         Assert.assertEquals(security.size(), 1);\n         Assert.assertEquals(security.get(0).isBasic, Boolean.TRUE);\n         Assert.assertEquals(security.get(0).isBasicBasic, Boolean.FALSE);\n         Assert.assertEquals(security.get(0).isBasicBearer, Boolean.TRUE);\n     }\n \n+    @Test\n+    public void testComposedSchemaOneOfDiscriminatorMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTk0OTAzOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNTowMzo0MVrOFhT_vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzozMzo1MFrOFjIepg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA==", "bodyText": "This will fail, as these schemas may also be defined inline rather than as a $ref.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370474940", "createdAt": "2020-01-24T05:03:41Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5OTc1OQ==", "bodyText": "Should I use ModelUtils.getReferencedSchema or ModelUtils.unaliasSchema here?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370899759", "createdAt": "2020-01-25T00:55:04Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAzODQ5NA==", "bodyText": "Changed to using ModelUtils.getReferencedSchema on the next line.\n@jimschubert because inlineModelResolver is invoked, won't inline Schemas always have $refs to the extracted inline schema?\n\nper https://github.com/OpenAPITools/openapi-generator/blob/master/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java#L915\n\nIf so, then it looks like using String modelName = ModelUtils.getSimpleRef(sc.get$ref()); will always work here.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r371038494", "createdAt": "2020-01-26T23:57:43Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA1NzQxNg==", "bodyText": "I'm not sure what you're referring to, but you won't always have a $ref here.\nIf you're referring to flatten in InlineModelResolver, I don't think that's doing what you think it's doing. Please review \n  \n    \n      openapi-generator/modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java\n    \n    \n         Line 330\n      in\n      ea55968\n    \n    \n    \n    \n\n        \n          \n           private void flattenComposedChildren(OpenAPI openAPI, String key, List<Schema> children) {", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r371057416", "createdAt": "2020-01-27T03:44:58Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA1OTI0MQ==", "bodyText": "To explain further, in case it's not clear... You'll input have a $ref if you have a Schema defined (like #/components/Schemas/Dog. It's perfectly valid to have a spec with only inline models, and also to have something like allOf, anyOf, or oneOf which define inline models for those compositions. Although there not common, they'll fail here.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r371059241", "createdAt": "2020-01-27T04:05:36Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA3MTMzMA==", "bodyText": "Hmm, I am having trouble understanding your example.\nInline OneOf: we have a schema which has a oneOf schema with an inline definition and using $ref works because the InlineModelResolver extracted the inline schema to a new base level schema and set the  $ref to it.\n\nAre you saying that when defining oneOf schemas I need to use a mix of inline and $ref to hit this null $ref use case?\nCan you provide a full example schema which has a oneOf definition in it where the oneOf schema will have a null $ref value?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r371071330", "createdAt": "2020-01-27T05:50:43Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkwOTkzOA==", "bodyText": "Are you saying that we can have a model with two levels of inline oneOf definition?\nIf so we are guaranteed that the first level is extracted to its own model per my explanation above. I will add that as a test case.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r371909938", "createdAt": "2020-01-28T16:24:14Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMjg2MA==", "bodyText": "@jimschubert we now have a test with inline oneOf schemas with inline oneOf schemas which results in null refs. We now continue through and skip any schemas with no ref because it is impossible to build a discriminator map with them.\nFor now I am resolving this convo because I think that addresses your concern.\nIf it doesn't please let me know and I'll be happy to make more changes.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r372022860", "createdAt": "2020-01-28T19:54:45Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MzM5OA==", "bodyText": "Yes, I think that addresses the concern. Sorry, I saw your question about providing an example, but I couldn't find the question when I came back to it (probably because of your additional commit).", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r372383398", "createdAt": "2020-01-29T13:33:50Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTk1MzExOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNTowODozNVrOFhUCWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwMToyNDoxNFrOFhuI0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NTYwOQ==", "bodyText": "Looks like this would fail if allOf is null (like if the ComposedModel is oneOf)?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370475609", "createdAt": "2020-01-24T05:08:35Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());\n+                Schema refSchema = ModelUtils.getSchema(this.openAPI, modelName);\n+                Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+                if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                    discriminator.getMappedModels().add(new MappedModel(modelName, toModelName(modelName)));\n+                    continue;\n+                }\n+                Boolean mapped = false;\n+                if (ModelUtils.isComposedSchema(refSchema)) {\n+                    ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+                    for  (Schema allOf: composedSchema.getAllOf()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwMzI0OQ==", "bodyText": "allOf/oneOf/anyOf access is now gated by null checks", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370903249", "createdAt": "2020-01-25T01:24:14Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());\n+                Schema refSchema = ModelUtils.getSchema(this.openAPI, modelName);\n+                Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+                if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                    discriminator.getMappedModels().add(new MappedModel(modelName, toModelName(modelName)));\n+                    continue;\n+                }\n+                Boolean mapped = false;\n+                if (ModelUtils.isComposedSchema(refSchema)) {\n+                    ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+                    for  (Schema allOf: composedSchema.getAllOf()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NTYwOQ=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTk1NjA5OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNToxMTo0MFrOFhUEEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQyMzo0NjowNVrOFhtQTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NjA1MQ==", "bodyText": "What about removing the mapped flag used as control flow and move the error message up? I think the logic around mapped is hard to follow, and could easily get messed up later.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370476051", "createdAt": "2020-01-24T05:11:40Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());\n+                Schema refSchema = ModelUtils.getSchema(this.openAPI, modelName);\n+                Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+                if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                    discriminator.getMappedModels().add(new MappedModel(modelName, toModelName(modelName)));\n+                    continue;\n+                }\n+                Boolean mapped = false;\n+                if (ModelUtils.isComposedSchema(refSchema)) {\n+                    ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+                    for  (Schema allOf: composedSchema.getAllOf()) {\n+                        String allmodelName = ModelUtils.getSimpleRef(allOf.get$ref());\n+                        refSchema = ModelUtils.getSchema(this.openAPI, allmodelName);\n+                        discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+                        if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                            discriminator.getMappedModels().add(new MappedModel(modelName, toModelName(modelName)));\n+                            mapped = true;\n+                            break;\n+                        }\n+                    }\n+                    if (mapped) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4ODc4Mg==", "bodyText": "Removed the mapped variable and instead we now use a mappedModel variable.\nIf mappedModel == null, then we raise an error.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370888782", "createdAt": "2020-01-24T23:46:05Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());\n+                Schema refSchema = ModelUtils.getSchema(this.openAPI, modelName);\n+                Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+                if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                    discriminator.getMappedModels().add(new MappedModel(modelName, toModelName(modelName)));\n+                    continue;\n+                }\n+                Boolean mapped = false;\n+                if (ModelUtils.isComposedSchema(refSchema)) {\n+                    ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+                    for  (Schema allOf: composedSchema.getAllOf()) {\n+                        String allmodelName = ModelUtils.getSimpleRef(allOf.get$ref());\n+                        refSchema = ModelUtils.getSchema(this.openAPI, allmodelName);\n+                        discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+                        if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                            discriminator.getMappedModels().add(new MappedModel(modelName, toModelName(modelName)));\n+                            mapped = true;\n+                            break;\n+                        }\n+                    }\n+                    if (mapped) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NjA1MQ=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MjY2OTgyOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwMDo1ODowOVrOFht8zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNDozMDo1NFrOGKWEdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwMDE3NQ==", "bodyText": "This is needed if a schema omits allOf but includes anyOf or oneOf", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370900175", "createdAt": "2020-01-25T00:58:09Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2109,20 +2196,26 @@ protected void addProperties(Map<String, Schema> properties, List<String> requir\n         if (schema instanceof ComposedSchema) {\n             ComposedSchema composedSchema = (ComposedSchema) schema;\n \n-            for (Schema component : composedSchema.getAllOf()) {\n-                addProperties(properties, required, component);\n+            if (composedSchema.getAllOf() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09f7275560afe0e12df830dd3074405c36c9fe8c"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzMDUzNw==", "bodyText": "If it's oneOf/anyOf, getAllOf should return null or empty list, right?\nWe didn't include the null check before and I don't recall issues related to this in particular but it could be an edge case we've not encountered yet.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r404930537", "createdAt": "2020-04-07T16:06:49Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2109,20 +2196,26 @@ protected void addProperties(Map<String, Schema> properties, List<String> requir\n         if (schema instanceof ComposedSchema) {\n             ComposedSchema composedSchema = (ComposedSchema) schema;\n \n-            for (Schema component : composedSchema.getAllOf()) {\n-                addProperties(properties, required, component);\n+            if (composedSchema.getAllOf() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwMDE3NQ=="}, "originalCommit": {"oid": "09f7275560afe0e12df830dd3074405c36c9fe8c"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5NzQ3MQ==", "bodyText": "My new test cases include oneOf/anyOf with no allOf, and when that happens composedSchema.getAllOf() == null", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413497471", "createdAt": "2020-04-23T04:20:37Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2109,20 +2196,26 @@ protected void addProperties(Map<String, Schema> properties, List<String> requir\n         if (schema instanceof ComposedSchema) {\n             ComposedSchema composedSchema = (ComposedSchema) schema;\n \n-            for (Schema component : composedSchema.getAllOf()) {\n-                addProperties(properties, required, component);\n+            if (composedSchema.getAllOf() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwMDE3NQ=="}, "originalCommit": {"oid": "09f7275560afe0e12df830dd3074405c36c9fe8c"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUwMDUzMw==", "bodyText": "\ud83d\udc4c", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413500533", "createdAt": "2020-04-23T04:30:54Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2109,20 +2196,26 @@ protected void addProperties(Map<String, Schema> properties, List<String> requir\n         if (schema instanceof ComposedSchema) {\n             ComposedSchema composedSchema = (ComposedSchema) schema;\n \n-            for (Schema component : composedSchema.getAllOf()) {\n-                addProperties(properties, required, component);\n+            if (composedSchema.getAllOf() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwMDE3NQ=="}, "originalCommit": {"oid": "09f7275560afe0e12df830dd3074405c36c9fe8c"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTc4NDk1OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMzo1Njo0NFrOFlHbeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxODo1Mjo0MVrOFlfgbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2MzM1NA==", "bodyText": "I don't understand this error. allOf without a discriminator means composition, while allOf with a discriminator means inheritance. As a user I'd find this error very confusing.  From the spec:\n\nThe OpenAPI Specification allows combining and extending model definitions using the allOf property of JSON Schema, in effect offering model composition. allOf takes an array of object definitions that are validated independently but together compose a single object.\nWhile composition offers model extensibility, it does not imply a hierarchy between the models. To support polymorphism, the OpenAPI Specification adds the discriminator field. When used, the discriminator will be the name of the property that decides which schema definition validates the structure of the model. As such, the discriminator field MUST be a required field.\n\nWhen a discriminator exists, inline schemas won't be honored (only $ref). From the spec:\n\nWhen using the discriminator, inline schemas will not be considered.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374463354", "createdAt": "2020-02-04T03:56:44Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    continue;\n+                }\n+                Boolean discFound = discriminatorFound(sc, discPropName);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (discFound == false) {\n+                    LOGGER.error(\"schema {} is lacking the required string discriminator {}\", modelName, discPropName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3OTcxNQ==", "bodyText": "For context, this function is only run when a discriminator exists.\nWe are only looping through oneOf and anyOf schema lists here, so we will only see those errors if:\n\na discriminator was specified in the composed schema\noneOf and or anyOf schemas are defined in the composed schema\none of those oneOf or anyOf schemas is missing the required discriminator\n\nI only included the inline processing code because our inline resolver extracts inline schemas into new models.\nCould you let me know what you want me to change?\nDo you want me to throw an error when an inline schema is used resulting in a null ref?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374479715", "createdAt": "2020-02-04T05:24:14Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    continue;\n+                }\n+                Boolean discFound = discriminatorFound(sc, discPropName);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (discFound == false) {\n+                    LOGGER.error(\"schema {} is lacking the required string discriminator {}\", modelName, discPropName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2MzM1NA=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyNzcxNA==", "bodyText": "Ah I see. I think a comment at this point in code could go a long way. Maybe rewording the error as well?\nI still have some concerns because the spec allows for moving the discriminator property out to the top level model, but that's probably an edge case that we don't need to account for immediately.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374627714", "createdAt": "2020-02-04T11:55:49Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    continue;\n+                }\n+                Boolean discFound = discriminatorFound(sc, discPropName);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (discFound == false) {\n+                    LOGGER.error(\"schema {} is lacking the required string discriminator {}\", modelName, discPropName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2MzM1NA=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0Mjc5OQ==", "bodyText": "Re: the reword recommendation...\nConsider a huge spec document with 1000 $refs and heavy use of composition. If there are types such as BrandedTool which requires a manufacturer property and HandmadeTool which does not: the spec author may easily mistype Hammer where they meant BrandedHammer leading to a message:\n\nschema Hammer is lacking the required string discriminator manufacturer\n\nWrapping these properties in single quotes would make this stand out as model and property names. Ideally the message would read something like:\n\n'BrandedTool' defines discriminator 'manufacturer', but the referenced schema 'Hammer' is missing this property.\n\nThis is probably something we'll want to add a validator for later as well.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374642799", "createdAt": "2020-02-04T12:31:26Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    continue;\n+                }\n+                Boolean discFound = discriminatorFound(sc, discPropName);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (discFound == false) {\n+                    LOGGER.error(\"schema {} is lacking the required string discriminator {}\", modelName, discPropName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2MzM1NA=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NzgzNg==", "bodyText": "The error message has been changed to the suggested message", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374857836", "createdAt": "2020-02-04T18:52:41Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    continue;\n+                }\n+                Boolean discFound = discriminatorFound(sc, discPropName);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (discFound == false) {\n+                    LOGGER.error(\"schema {} is lacking the required string discriminator {}\", modelName, discPropName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2MzM1NA=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTc5MzIzOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNDowMjo0N1rOFlHgBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxODo1NzoxMlrOFlfpvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NDUxNg==", "bodyText": "This isn't correct to throw an error for missing discriminator. Notice use of MAY in the spec and not MUST:\nIn OAS 3.0, a response payload MAY be described to be exactly one of any number of types:\nMyResponseType:\n  oneOf:\n  - $ref: '#/components/schemas/Cat'\n  - $ref: '#/components/schemas/Dog'\n  - $ref: '#/components/schemas/Lizard'\n\nwhich means the payload MUST, by validation, match exactly one of the schemas described by Cat, Dog, or Lizard. In this case, a discriminator MAY act as a \"hint\" to shortcut validation and selection of the matching schema which may be a costly operation, depending on the complexity of the schema.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374464516", "createdAt": "2020-02-04T04:02:47Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3ODkwOA==", "bodyText": "So I think you may misunderstand when this code is invoked.\nIf there is no discriminator in the composed schema, this function is not run.\nPer here: https://github.com/spacether/openapi-generator/blob/issue_4904_fix_composed_schema_discriminator_map/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java#L2234\nwe return early if there is no discriminator.\nIf we do have a discriminator then we check for discriminator presence because it is required per the spec here: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#discriminatorObject\nAnd we invoke our code path here: https://github.com/spacether/openapi-generator/blob/issue_4904_fix_composed_schema_discriminator_map/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java#L2255", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374478908", "createdAt": "2020-02-04T05:20:32Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NDUxNg=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4NjAxOA==", "bodyText": "Please let me know if I can mark this as resolved.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374486018", "createdAt": "2020-02-04T05:54:33Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NDUxNg=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyNTE2MA==", "bodyText": "I think a comment that this path is intended to be taken only when a schema had a discriminator would be helpful.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374625160", "createdAt": "2020-02-04T11:49:33Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NDUxNg=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2MDIyMw==", "bodyText": "A comment has been added to the javadoc for this function This function is only used for composed schemas which have a discriminator", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374860223", "createdAt": "2020-02-04T18:57:12Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NDUxNg=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTgwNjA3OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNDoxMzoxM1rOFlHnrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNzoyMTo0NlrOFmjkCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NjQ3OQ==", "bodyText": "We should actively disallow infinite loops, as circular references are allowed in the spec.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374466479", "createdAt": "2020-02-04T04:13:13Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2160,16 +2250,23 @@ protected CodegenDiscriminator createDiscriminator(String schemaName, Schema sch\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n+            if (ModelUtils.isComposedSchema(schema)) {\n+                // if all oneOf/amyOf schemas contain the discriminator, then use it when mapping\n+                addComposedMappedModels(discriminator, (ComposedSchema) schema, discPropName);\n+            } else {\n+                // we have child models that include a parent with allOf: parent and the parent does NOT have composed schema\n+                // If the parent has composed schema we go an infinite loop parent->child-> parent in getAllParentsName and addProperties", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3OTkyMg==", "bodyText": "Right now infinite loops cause a stack overflow or some similar failure and don't result in a client being generated.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374479922", "createdAt": "2020-02-04T05:25:19Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2160,16 +2250,23 @@ protected CodegenDiscriminator createDiscriminator(String schemaName, Schema sch\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n+            if (ModelUtils.isComposedSchema(schema)) {\n+                // if all oneOf/amyOf schemas contain the discriminator, then use it when mapping\n+                addComposedMappedModels(discriminator, (ComposedSchema) schema, discPropName);\n+            } else {\n+                // we have child models that include a parent with allOf: parent and the parent does NOT have composed schema\n+                // If the parent has composed schema we go an infinite loop parent->child-> parent in getAllParentsName and addProperties", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NjQ3OQ=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0NTA0Ng==", "bodyText": "This code is not only used in our CLI and plugins. We need to prevent intentional stack overflow. Maybe including a depth count and terminating at something ridiculous like 20?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374645046", "createdAt": "2020-02-04T12:36:40Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2160,16 +2250,23 @@ protected CodegenDiscriminator createDiscriminator(String schemaName, Schema sch\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n+            if (ModelUtils.isComposedSchema(schema)) {\n+                // if all oneOf/amyOf schemas contain the discriminator, then use it when mapping\n+                addComposedMappedModels(discriminator, (ComposedSchema) schema, discPropName);\n+            } else {\n+                // we have child models that include a parent with allOf: parent and the parent does NOT have composed schema\n+                // If the parent has composed schema we go an infinite loop parent->child-> parent in getAllParentsName and addProperties", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NjQ3OQ=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2MTUyMQ==", "bodyText": "So none of my cases cover infinite loops. That is a separate issue from this PR and fixing the discriminator map.\nHow about we fix that in a separate PR? Especially since that infinite recursion fix will touch more call sites than my code here.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374861521", "createdAt": "2020-02-04T18:59:35Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2160,16 +2250,23 @@ protected CodegenDiscriminator createDiscriminator(String schemaName, Schema sch\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n+            if (ModelUtils.isComposedSchema(schema)) {\n+                // if all oneOf/amyOf schemas contain the discriminator, then use it when mapping\n+                addComposedMappedModels(discriminator, (ComposedSchema) schema, discPropName);\n+            } else {\n+                // we have child models that include a parent with allOf: parent and the parent does NOT have composed schema\n+                // If the parent has composed schema we go an infinite loop parent->child-> parent in getAllParentsName and addProperties", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NjQ3OQ=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3Mjg3NQ==", "bodyText": "@jimschubert please let me know if your concerns have been addressed.\nA separate ticket has been made for the stack overflow work here", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r375972875", "createdAt": "2020-02-06T17:21:46Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2160,16 +2250,23 @@ protected CodegenDiscriminator createDiscriminator(String schemaName, Schema sch\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n+            if (ModelUtils.isComposedSchema(schema)) {\n+                // if all oneOf/amyOf schemas contain the discriminator, then use it when mapping\n+                addComposedMappedModels(discriminator, (ComposedSchema) schema, discPropName);\n+            } else {\n+                // we have child models that include a parent with allOf: parent and the parent does NOT have composed schema\n+                // If the parent has composed schema we go an infinite loop parent->child-> parent in getAllParentsName and addProperties", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NjQ3OQ=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTg0OTc3OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNDo1MDo1OFrOFlICSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQxNzowMTowMFrOFqUUyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzI4OQ==", "bodyText": "From https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#discriminator-object\n\nWhen using the discriminator, inline schemas will not be considered.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374473289", "createdAt": "2020-02-04T04:50:58Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4NDMzOA==", "bodyText": "So our defaultcodegen extracts these inline schemas into separate schemas with the inline model resolver.\nI'm not sure how the generator will be able to tell that this was an inline schema because when I am processing these schemas, they are no longer inline. They have $refs.\nDo we have a boolean flag that indicates that a schema came from inline definition?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374484338", "createdAt": "2020-02-04T05:46:50Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzI4OQ=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzMDk1Mg==", "bodyText": "Hm. So InlineModelResolver is trying to be smart about it and find a similar looking model, then using that... We'll need to change that to be spec compliant for composed schemas.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374630952", "createdAt": "2020-02-04T12:03:49Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzI4OQ=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1ODc4NQ==", "bodyText": "The function has been updated to now throw an exception if a null ref is seen.\nWe also have a test of it. In my opinion we should handle fixing the inline model resolver for composed schemas in a separate PR as that is scope creep. The scope here is defining the discriminator map.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374858785", "createdAt": "2020-02-04T18:54:28Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzI4OQ=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3Njk4MA==", "bodyText": "@jimschubert please let me know if your concerns have been addressed.\nA separate ticket has been filed to fix the inline model resolver here", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r375976980", "createdAt": "2020-02-06T17:29:44Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzI4OQ=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkxNzUxMw==", "bodyText": "I have one more concern. I'll post it in PR comment rather than review comment.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r379917513", "createdAt": "2020-02-16T17:01:00Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzI4OQ=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTg1MTEwOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNDo1MjoxMlrOFlIDJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxMTo1ODo0M1rOFlRiKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzUxMA==", "bodyText": "This should imply common inheritance between Apple and Banana.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374473510", "createdAt": "2020-02-04T04:52:12Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:\n+        propertyName: fruitType\n+    FruitInlineInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+          properties:\n+            seeds:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+        - type: object\n+          required:\n+            - length\n+          properties:\n+            length:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+      discriminator:\n+        propertyName: fruitType\n+    FruitReqDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleReqDisc'\n+        - $ref: '#/components/schemas/BananaReqDisc'\n+      discriminator:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4MTU1Mg==", "bodyText": "I don't understand what you mean here. Can you be more specific?\nIsn't this discriminator saying when we get data for FruitReqDisc it will be either an AppleReqDisc or a BananaReqDisc model, defined by the property fruitType.\nfruitType can have the values:\n\nAppleReqDisc\nBananaReqDisc", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374481552", "createdAt": "2020-02-04T05:33:10Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:\n+        propertyName: fruitType\n+    FruitInlineInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+          properties:\n+            seeds:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+        - type: object\n+          required:\n+            - length\n+          properties:\n+            length:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+      discriminator:\n+        propertyName: fruitType\n+    FruitReqDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleReqDisc'\n+        - $ref: '#/components/schemas/BananaReqDisc'\n+      discriminator:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzUxMA=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyODkwNw==", "bodyText": "Yeah, you're right. I misread it as an allOf.\nJust keeping you on your toes \ud83e\udd2a", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374628907", "createdAt": "2020-02-04T11:58:43Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:\n+        propertyName: fruitType\n+    FruitInlineInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+          properties:\n+            seeds:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+        - type: object\n+          required:\n+            - length\n+          properties:\n+            length:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+      discriminator:\n+        propertyName: fruitType\n+    FruitReqDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleReqDisc'\n+        - $ref: '#/components/schemas/BananaReqDisc'\n+      discriminator:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzUxMA=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTg1Mzc0OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNDo1NDozMFrOFlIErQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxMjozMzozOFrOFlScHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzkwMQ==", "bodyText": "These inline models should be ignored per spec", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374473901", "createdAt": "2020-02-04T04:54:30Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:\n+        propertyName: fruitType\n+    FruitInlineInlineDisc:\n+      oneOf:\n+        - type: object", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4NDcyMg==", "bodyText": "These ones I can detect because the inline model resolver does not extract them and we see the null $refs", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374484722", "createdAt": "2020-02-04T05:48:29Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:\n+        propertyName: fruitType\n+    FruitInlineInlineDisc:\n+      oneOf:\n+        - type: object", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzkwMQ=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0Mzc0MQ==", "bodyText": "As commented elsewhere, that's something we'll need to change to be spec compliant but not related to your PR.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374643741", "createdAt": "2020-02-04T12:33:38Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:\n+        propertyName: fruitType\n+    FruitInlineInlineDisc:\n+      oneOf:\n+        - type: object", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzkwMQ=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTg1NjQwOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNDo1Njo1NFrOFlIGVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNTozNDoyNVrOFlIjWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NDMyNQ==", "bodyText": "allOf without discriminator should be composition (Parent has a FruitType, rather than Parent is a FruitType).", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374474325", "createdAt": "2020-02-04T04:56:54Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:\n+        propertyName: fruitType\n+    FruitInlineInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+          properties:\n+            seeds:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+        - type: object\n+          required:\n+            - length\n+          properties:\n+            length:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+      discriminator:\n+        propertyName: fruitType\n+    FruitReqDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleReqDisc'\n+        - $ref: '#/components/schemas/BananaReqDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    AppleReqDisc:\n+      type: object\n+      required:\n+        - seeds\n+        - fruitType\n+      properties:\n+        seeds:\n+          type: integer\n+        fruitType:\n+          type: string\n+    BananaReqDisc:\n+      type: object\n+      required:\n+        - length\n+        - fruitType\n+      properties:\n+        length:\n+          type: integer\n+        fruitType:\n+          type: string\n+    FruitAllOfDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleAllOfDisc'\n+        - $ref: '#/components/schemas/BananaAllOfDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    AppleAllOfDisc:\n+      type: object\n+      required:\n+        - seeds\n+      properties:\n+        seeds:\n+          type: integer\n+      allOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    BananaAllOfDisc:\n+      type: object\n+      required:\n+        - length\n+      properties:\n+        length:\n+          type: integer\n+      allOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    FruitAnyOfDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleAnyOfDisc'\n+        - $ref: '#/components/schemas/BananaAnyOfDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    AppleAnyOfDisc:\n+      type: object\n+      required:\n+        - seeds\n+      properties:\n+        seeds:\n+          type: integer\n+      anyOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    BananaAnyOfDisc:\n+      type: object\n+      required:\n+        - length\n+      properties:\n+        length:\n+          type: integer\n+      anyOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    FruitOneOfDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleOneOfDisc'\n+        - $ref: '#/components/schemas/BananaOneOfDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    AppleOneOfDisc:\n+      type: object\n+      required:\n+        - seeds\n+      properties:\n+        seeds:\n+          type: integer\n+      oneOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    BananaOneOfDisc:\n+      type: object\n+      required:\n+        - length\n+      properties:\n+        length:\n+          type: integer\n+      oneOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    FruitGrandparentDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleGrandparentDisc'\n+        - $ref: '#/components/schemas/BananaGrandparentDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    Parent:\n+      type: object\n+      allOf:\n+        # the FruitType schema is a grandparent of AppleGrandparentDisc + BananaGrandparentDisc", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4MTc1NQ==", "bodyText": "Definitely, I agree.\nOur code does not populate the discriminator map for this Parent model because the function addComposedMappedModels only populates a map if oneOf or anyOf schemas are defined in the composed schema. Parent has no oneOf/anyOf so Parent will not have a discriminator map.\nWhen we recursively look for a discriminator in ancestors we are just looking for discriminator presence. So the FruitGrandparentDisc will have a discriminator map because the required discriminator was present in AppleGrandparentDisc + BananaGrandparentDisc and we had to travel back to their grandparent to find the discriminator.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374481755", "createdAt": "2020-02-04T05:34:25Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:\n+        propertyName: fruitType\n+    FruitInlineInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+          properties:\n+            seeds:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+        - type: object\n+          required:\n+            - length\n+          properties:\n+            length:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+      discriminator:\n+        propertyName: fruitType\n+    FruitReqDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleReqDisc'\n+        - $ref: '#/components/schemas/BananaReqDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    AppleReqDisc:\n+      type: object\n+      required:\n+        - seeds\n+        - fruitType\n+      properties:\n+        seeds:\n+          type: integer\n+        fruitType:\n+          type: string\n+    BananaReqDisc:\n+      type: object\n+      required:\n+        - length\n+        - fruitType\n+      properties:\n+        length:\n+          type: integer\n+        fruitType:\n+          type: string\n+    FruitAllOfDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleAllOfDisc'\n+        - $ref: '#/components/schemas/BananaAllOfDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    AppleAllOfDisc:\n+      type: object\n+      required:\n+        - seeds\n+      properties:\n+        seeds:\n+          type: integer\n+      allOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    BananaAllOfDisc:\n+      type: object\n+      required:\n+        - length\n+      properties:\n+        length:\n+          type: integer\n+      allOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    FruitAnyOfDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleAnyOfDisc'\n+        - $ref: '#/components/schemas/BananaAnyOfDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    AppleAnyOfDisc:\n+      type: object\n+      required:\n+        - seeds\n+      properties:\n+        seeds:\n+          type: integer\n+      anyOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    BananaAnyOfDisc:\n+      type: object\n+      required:\n+        - length\n+      properties:\n+        length:\n+          type: integer\n+      anyOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    FruitOneOfDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleOneOfDisc'\n+        - $ref: '#/components/schemas/BananaOneOfDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    AppleOneOfDisc:\n+      type: object\n+      required:\n+        - seeds\n+      properties:\n+        seeds:\n+          type: integer\n+      oneOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    BananaOneOfDisc:\n+      type: object\n+      required:\n+        - length\n+      properties:\n+        length:\n+          type: integer\n+      oneOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    FruitGrandparentDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleGrandparentDisc'\n+        - $ref: '#/components/schemas/BananaGrandparentDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    Parent:\n+      type: object\n+      allOf:\n+        # the FruitType schema is a grandparent of AppleGrandparentDisc + BananaGrandparentDisc", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NDMyNQ=="}, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzM0MjM3OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjo0MjoyNFrOFntQ7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQxODozMDoyNlrOFqUrOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4MDM5OA==", "bodyText": "Should we include anyOf here?\nI don't thinks so. If one includes a discriminator with anyof then the discriminator must be used and the functionality is the same as oneof. Also because one is including the class name, it is not possible to match multiple schemas in that use case.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r377180398", "createdAt": "2020-02-10T16:42:24Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,104 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(String composedSchemaName, CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53200bf33907c12cba6b769cef105fe76669399d"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMzI1Ng==", "bodyText": "Yes we should per:\nhttps://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#discriminatorObject\nWhen used in conjunction with the anyOf construct, the use of the discriminator can avoid ambiguity where multiple schemas may satisfy a single payload.\n\nSo the spec wants us to allow anyOf to allow a discriminator map so it may act like oneOf", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r379923256", "createdAt": "2020-02-16T18:30:26Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,104 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(String composedSchemaName, CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4MDM5OA=="}, "originalCommit": {"oid": "53200bf33907c12cba6b769cef105fe76669399d"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTUyNTk0OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwMzoxMDo0NlrOFqXgmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxODoxODozOFrOFryQhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2OTY4OQ==", "bodyText": "Small typo: amyOf", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r379969689", "createdAt": "2020-02-17T03:10:46Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2160,16 +2252,23 @@ protected CodegenDiscriminator createDiscriminator(String schemaName, Schema sch\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n+            if (ModelUtils.isComposedSchema(schema)) {\n+                // if all oneOf/amyOf schemas contain the discriminator, then use it when mapping", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53200bf33907c12cba6b769cef105fe76669399d"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ1NjUxOA==", "bodyText": "This has been fixed", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r381456518", "createdAt": "2020-02-19T18:18:38Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2160,16 +2252,23 @@ protected CodegenDiscriminator createDiscriminator(String schemaName, Schema sch\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n+            if (ModelUtils.isComposedSchema(schema)) {\n+                // if all oneOf/amyOf schemas contain the discriminator, then use it when mapping", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2OTY4OQ=="}, "originalCommit": {"oid": "53200bf33907c12cba6b769cef105fe76669399d"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjM1MDA5OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToxOTo1MlrOFveA4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToxOTo1MlrOFveA4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxOTEzOQ==", "bodyText": "We are adding more models to our discriminator map here than we have in the past.\nShould we add those models into the models import where this is called in fromModel?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r385319139", "createdAt": "2020-02-27T19:19:52Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2267,35 +2284,242 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Recursively look in Schema sc for the discriminator and return it\n+     * If we return it from allOf, oneOf, or anyOf, then do not include the\n+     * discriminator map from that location because it is not relevant at our\n+     * Schema sc location\n+     * @param sc The Schema that may contain the discriminator\n+     */\n+    private Discriminator recursiveGetDiscriminator(Schema sc) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        Discriminator foundDisc = refSchema.getDiscriminator();\n+        if (foundDisc != null) {\n+            return foundDisc;\n+        }\n+        Discriminator disc = new Discriminator();\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    foundDisc = recursiveGetDiscriminator(allOf);\n+                    if (foundDisc != null) {\n+                        disc.setPropertyName(foundDisc.getPropertyName());\n+                        return disc;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    foundDisc = recursiveGetDiscriminator(oneOf);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    return disc;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    foundDisc = recursiveGetDiscriminator(anyOf);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    return disc;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * a list if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @return the list of oneOf and anyOf schema names that need to be added to the discriminator map\n+     */\n+    protected List<String> getOneOfAnyOfSchemaNames(String composedSchemaName, String discPropName, ComposedSchema c) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        Set<String> descendentSchemas = new HashSet<>();\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    throw new RuntimeException(\"Invalid inline schema defined in oneOf/anyOf in '\" + composedSchemaName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the oneOf/anyOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                }\n+                Boolean discFound = discriminatorFound(sc, discPropName);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (discFound == false) {\n+                    throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced schema '\" + modelName + \"' is missing this property\");\n+                }\n+                descendentSchemas.add(modelName);\n+            }\n+        }\n+        List<String> modelNames = new ArrayList<>(descendentSchemas);\n+        Collections.sort(modelNames);\n+        return modelNames;\n+    }\n+\n+    protected List<String> getDescendentSchemaNames(String thisSchemaName) {\n+        ArrayList<String> queue = new ArrayList<String>();\n+        Set<String> descendentSchemas = new HashSet<>();\n+        Map<String, Schema> schemas = ModelUtils.getSchemas(this.openAPI);\n+        String currentSchemaName = thisSchemaName;\n+        while (true) {\n+            for (String childName : schemas.keySet()) {\n+                if (childName == thisSchemaName) {\n+                    continue;\n+                }\n+                Schema child = schemas.get(childName);\n+                if (ModelUtils.isComposedSchema(child)) {\n+                    ComposedSchema composedChild = (ComposedSchema) child;\n+                    List<Schema> parents = composedChild.getAllOf();\n+                    if (parents != null) {\n+                        for  (Schema parent: parents) {\n+                            String ref = parent.get$ref();\n+                            if (ref == null) {\n+                                // for schemas with no ref, it is not possible to build the discriminator map\n+                                // because ref is how we get the model name\n+                                // we only hit this use case for a schema with inline composed schemas, and one of those\n+                                // schemas also has inline composed schemas\n+                                throw new RuntimeException(\"Invalid inline schema defined in allOf in '\" + childName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the allOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                            }\n+                            String parentName = ModelUtils.getSimpleRef(ref);\n+                            if (parentName.equals(currentSchemaName)) {\n+                                if (queue.contains(childName) || descendentSchemas.contains(childName)) {\n+                                    throw new RuntimeException(\"Stack overflow hit when looking for \"+thisSchemaName+\" an infinite loop starting and ending at \"+childName+\" was seen\");\n+                                }\n+                                queue.add(childName);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            if (queue.size() == 0) {\n+                break;\n+            }\n+            currentSchemaName = queue.remove(queue.size()-1);\n+            descendentSchemas.add(currentSchemaName);\n+        }\n+        List<String> modelNames = new ArrayList<>(descendentSchemas);\n+        Collections.sort(modelNames);\n+        return modelNames;\n+    }\n+\n     protected CodegenDiscriminator createDiscriminator(String schemaName, Schema schema) {\n-        if (schema.getDiscriminator() == null) {\n+        Discriminator sourceDiscriminator = recursiveGetDiscriminator(schema);\n+        if (sourceDiscriminator == null) {\n             return null;\n         }\n         CodegenDiscriminator discriminator = new CodegenDiscriminator();\n-        discriminator.setPropertyName(toVarName(schema.getDiscriminator().getPropertyName()));\n-        discriminator.setPropertyBaseName(schema.getDiscriminator().getPropertyName());\n+        String discPropName = sourceDiscriminator.getPropertyName();\n+        discriminator.setPropertyName(toVarName(discPropName));\n+        discriminator.setPropertyBaseName(sourceDiscriminator.getPropertyName());\n         discriminator.setPropertyGetter(toGetter(discriminator.getPropertyName()));\n         // FIXME: for now, we assume that the discriminator property is String\n         discriminator.setPropertyType(typeMapping.get(\"string\"));\n-        discriminator.setMapping(schema.getDiscriminator().getMapping());\n-        if (schema.getDiscriminator().getMapping() != null && !schema.getDiscriminator().getMapping().isEmpty()) {\n-            for (Entry<String, String> e : schema.getDiscriminator().getMapping().entrySet()) {\n+        discriminator.setMapping(sourceDiscriminator.getMapping());\n+        if (sourceDiscriminator.getMapping() != null && !sourceDiscriminator.getMapping().isEmpty()) {\n+            for (Entry<String, String> e : sourceDiscriminator.getMapping().entrySet()) {\n                 String nameOrRef = e.getValue();\n                 String name = nameOrRef.indexOf('/') >= 0 ? ModelUtils.getSimpleRef(nameOrRef) : nameOrRef;\n                 String modelName = toModelName(name);\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n-                    }\n+            // for schemas that allOf inherit from this schema, add those descendents to this discriminator map\n+            List<String> allOfDescendents = getDescendentSchemaNames(schemaName);\n+            for (String allOfDescendent: allOfDescendents) {\n+                discriminator.getMappedModels().add(new MappedModel(allOfDescendent, toModelName(allOfDescendent)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjQxOTkzOnYy", "diffSide": "LEFT", "path": "samples/client/petstore/csharp/OpenAPIClient/src/Org.OpenAPITools/Model/Animal.cs", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOTo0MTowOFrOFvetSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMVQxNjoxNjowNFrOFwO63g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzMDUwNA==", "bodyText": "Why did this go away?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r385330504", "createdAt": "2020-02-27T19:41:08Z", "author": {"login": "spacether"}, "path": "samples/client/petstore/csharp/OpenAPIClient/src/Org.OpenAPITools/Model/Animal.cs", "diffHunk": "@@ -32,7 +32,6 @@ namespace Org.OpenAPITools.Model\n     [JsonConverter(typeof(JsonSubtypes), \"ClassName\")]\n     [JsonSubtypes.KnownSubType(typeof(Dog), \"Dog\")]\n     [JsonSubtypes.KnownSubType(typeof(Cat), \"Cat\")]\n-    [JsonSubtypes.KnownSubType(typeof(BigCat), \"BigCat\")]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjExMDIyOA==", "bodyText": "The discriminators are now moved from base type (Animal) to intermediate types (Cat). I'll look at it and see if I can understand why that is.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r386110228", "createdAt": "2020-03-01T13:56:36Z", "author": {"login": "jimschubert"}, "path": "samples/client/petstore/csharp/OpenAPIClient/src/Org.OpenAPITools/Model/Animal.cs", "diffHunk": "@@ -32,7 +32,6 @@ namespace Org.OpenAPITools.Model\n     [JsonConverter(typeof(JsonSubtypes), \"ClassName\")]\n     [JsonSubtypes.KnownSubType(typeof(Dog), \"Dog\")]\n     [JsonSubtypes.KnownSubType(typeof(Cat), \"Cat\")]\n-    [JsonSubtypes.KnownSubType(typeof(BigCat), \"BigCat\")]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzMDUwNA=="}, "originalCommit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjExNzk4MA==", "bodyText": "I spent a little time looking and didn't see anything immediately. I'll ping core team to see if someone else can review more in-depth.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r386117980", "createdAt": "2020-03-01T15:41:03Z", "author": {"login": "jimschubert"}, "path": "samples/client/petstore/csharp/OpenAPIClient/src/Org.OpenAPITools/Model/Animal.cs", "diffHunk": "@@ -32,7 +32,6 @@ namespace Org.OpenAPITools.Model\n     [JsonConverter(typeof(JsonSubtypes), \"ClassName\")]\n     [JsonSubtypes.KnownSubType(typeof(Dog), \"Dog\")]\n     [JsonSubtypes.KnownSubType(typeof(Cat), \"Cat\")]\n-    [JsonSubtypes.KnownSubType(typeof(BigCat), \"BigCat\")]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzMDUwNA=="}, "originalCommit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEyMDQxNA==", "bodyText": "I am pretty sure that this changed because assignment of children depends upon the absence of the discriminator object. I still need to fix that. This template and many others iterates over children.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r386120414", "createdAt": "2020-03-01T16:16:04Z", "author": {"login": "spacether"}, "path": "samples/client/petstore/csharp/OpenAPIClient/src/Org.OpenAPITools/Model/Animal.cs", "diffHunk": "@@ -32,7 +32,6 @@ namespace Org.OpenAPITools.Model\n     [JsonConverter(typeof(JsonSubtypes), \"ClassName\")]\n     [JsonSubtypes.KnownSubType(typeof(Dog), \"Dog\")]\n     [JsonSubtypes.KnownSubType(typeof(Cat), \"Cat\")]\n-    [JsonSubtypes.KnownSubType(typeof(BigCat), \"BigCat\")]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzMDUwNA=="}, "originalCommit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MTYzOTI1OnYy", "diffSide": "RIGHT", "path": "samples/client/petstore/csharp-netcore/OpenAPIClientCore/src/Org.OpenAPITools/Model/Cat.cs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMVQxMzo1MDoxMFrOFwORQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzo1OToyMlrOFzCE2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEwOTc2Mg==", "bodyText": "Duplicated?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r386109762", "createdAt": "2020-03-01T13:50:10Z", "author": {"login": "jimschubert"}, "path": "samples/client/petstore/csharp-netcore/OpenAPIClientCore/src/Org.OpenAPITools/Model/Cat.cs", "diffHunk": "@@ -30,6 +31,9 @@ namespace Org.OpenAPITools.Model\n     /// Cat\n     /// </summary>\n     [DataContract]\n+    [JsonConverter(typeof(JsonSubtypes), \"ClassName\")]\n+    [JsonSubtypes.KnownSubType(typeof(BigCat), \"BigCat\")]\n+    [JsonSubtypes.KnownSubType(typeof(BigCat), \"BigCat\")]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1NTcwNw==", "bodyText": "This is duplicated because the mustache file has:\n    {{#children}}\n    [JsonSubtypes.KnownSubType(typeof({{classname}}), \"{{^vendorExtensions.x-discriminator-value}}{{name}}{{/vendorExtensions.x-discriminator-value}}{{#vendorExtensions.x-discriminator-value}}{{{vendorExtensions.x-discriminator-value}}}{{/vendorExtensions.x-discriminator-value}}\")]\n    {{/children}}\n    {{#mappedModels}}\n    [JsonSubtypes.KnownSubType(typeof({{{modelName}}}), \"{{{mappingName}}}\")]\n    {{/mappedModels}}\n\nMy update moves all mapping information into mappedModels including children.\nMy plan is to delete the children mustache tag.\nI am not sure if it also includes #vendorExtensions.x-discriminator-value.\nI will add a TODO bullet point to verify that x-discriminator-value still works", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r389055707", "createdAt": "2020-03-06T17:59:22Z", "author": {"login": "spacether"}, "path": "samples/client/petstore/csharp-netcore/OpenAPIClientCore/src/Org.OpenAPITools/Model/Cat.cs", "diffHunk": "@@ -30,6 +31,9 @@ namespace Org.OpenAPITools.Model\n     /// Cat\n     /// </summary>\n     [DataContract]\n+    [JsonConverter(typeof(JsonSubtypes), \"ClassName\")]\n+    [JsonSubtypes.KnownSubType(typeof(BigCat), \"BigCat\")]\n+    [JsonSubtypes.KnownSubType(typeof(BigCat), \"BigCat\")]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEwOTc2Mg=="}, "originalCommit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTI2MTU2OnYy", "diffSide": "RIGHT", "path": "docs/generators/ada-server.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNToyOToxNFrOF_GJcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxODo1ODo1NVrOGEDA5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcwNTMzMA==", "bodyText": "Typo: disciminator", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401705330", "createdAt": "2020-04-01T15:29:14Z", "author": {"login": "sebastien-rosset"}, "path": "docs/generators/ada-server.md", "diffHunk": "@@ -6,6 +6,7 @@ sidebar_label: ada-server\n | Option | Description | Values | Default |\n | ------ | ----------- | ------ | ------- |\n |allowUnicodeIdentifiers|boolean, toggles whether unicode identifiers are allowed in names or not, default is false| |false|\n+|discriminatorExplicitMappingVerbose|Every model that has a discriminator explicitly defines the disciminator in itself, the mapping in that discriminator includes any descendent schemas that allOf inherit from self, any oneOf schemas, any anyOf schemas, any x-discriminator-values, and the spec's defined discriminator mapping schemas. When true, we validate that oneOf and anyOf schemas contain the required discriminator and we throw an error if it's missing. When true model templates should not loop over {{#children}} when defining the discriminator mapping| |false|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg5NjA0OQ==", "bodyText": "The typo has been fixed", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r406896049", "createdAt": "2020-04-10T18:56:52Z", "author": {"login": "spacether"}, "path": "docs/generators/ada-server.md", "diffHunk": "@@ -6,6 +6,7 @@ sidebar_label: ada-server\n | Option | Description | Values | Default |\n | ------ | ----------- | ------ | ------- |\n |allowUnicodeIdentifiers|boolean, toggles whether unicode identifiers are allowed in names or not, default is false| |false|\n+|discriminatorExplicitMappingVerbose|Every model that has a discriminator explicitly defines the disciminator in itself, the mapping in that discriminator includes any descendent schemas that allOf inherit from self, any oneOf schemas, any anyOf schemas, any x-discriminator-values, and the spec's defined discriminator mapping schemas. When true, we validate that oneOf and anyOf schemas contain the required discriminator and we throw an error if it's missing. When true model templates should not loop over {{#children}} when defining the discriminator mapping| |false|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcwNTMzMA=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg5Njg2OQ==", "bodyText": "Every model that has a discriminator explicitly defines the disciminator in itself", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r406896869", "createdAt": "2020-04-10T18:58:55Z", "author": {"login": "sebastien-rosset"}, "path": "docs/generators/ada-server.md", "diffHunk": "@@ -6,6 +6,7 @@ sidebar_label: ada-server\n | Option | Description | Values | Default |\n | ------ | ----------- | ------ | ------- |\n |allowUnicodeIdentifiers|boolean, toggles whether unicode identifiers are allowed in names or not, default is false| |false|\n+|discriminatorExplicitMappingVerbose|Every model that has a discriminator explicitly defines the disciminator in itself, the mapping in that discriminator includes any descendent schemas that allOf inherit from self, any oneOf schemas, any anyOf schemas, any x-discriminator-values, and the spec's defined discriminator mapping schemas. When true, we validate that oneOf and anyOf schemas contain the required discriminator and we throw an error if it's missing. When true model templates should not loop over {{#children}} when defining the discriminator mapping| |false|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcwNTMzMA=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTMwMjk1OnYy", "diffSide": "RIGHT", "path": "docs/generators/ada-server.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTozODo0MlrOF_GlGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzozNTo0NFrOGEA74w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxMjQwOA==", "bodyText": "Proposed rephrasing of the flag documentation. I made some statements which may not be accurate, but hopefully with a bit of back-and-forth we can improve the doc.\n=== BEGIN\nThis flag is used by OpenAPITools codegen to influence the processing of the discriminator attribute in OpenAPI documents. This flag has no impact if the OAS document does not use the discriminator attribute. The default value of this flag is set in each language-specific code generator (e.g. Python, Java, go...).\nWhen this flag is set to true:\n\nThe mapping in the discriminator includes any descendent schemas that allOf inherit from self, any oneOf schemas, any anyOf schemas, any x-discriminator-values, and the discriminator mapping schemas in the OAS document.\nCodegen validates that oneOf and anyOf schemas contain the required discriminator and throws an error if the discriminator is missing.\n\nWhen this flag is set to false:\n\nThe mapping in the discriminator includes descendent schemas that allOf inherit from self and the discriminator mapping schemas in the OAS document.\n\nNote to developers supporting a language generator in OpenAPITools: to fully support the discriminator attribute as defined in the OAS specification 3.x, language generators should set this flag to true by default; however this requires updating the mustache templates to generate a language-specific discriminator lookup function that iterates over the XXXX tag.\n=== END\nDo you agree that eventually, all language generators that aim to fully support OAS 3.x should set this flag by default? Or do you see a reason they should not? If, maybe we should rename discriminatorExplicitMappingVerbose to discriminatorFullOpenAPISupport or something that indicates it should be the default value? For example, the default value could be \"legacy\", and for python-experimental and go-experimental the value is something like \"enabled\", just to nudge developers to support the new value.\n\nWhen true model templates should not loop over {{#children}} when defining the discriminator mapping\n\nIt would be good to explain what the mustache templates should loop over, if not {{#children}}; Both for when the flag is set to true and when the flag is set to false. BTW, yesterday I was thinking about opening a PR to document the CodegenModel.children field, because it's not very obvious what is the meaning. It could be containment, it could be class inheritance.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401712408", "createdAt": "2020-04-01T15:38:42Z", "author": {"login": "sebastien-rosset"}, "path": "docs/generators/ada-server.md", "diffHunk": "@@ -6,6 +6,7 @@ sidebar_label: ada-server\n | Option | Description | Values | Default |\n | ------ | ----------- | ------ | ------- |\n |allowUnicodeIdentifiers|boolean, toggles whether unicode identifiers are allowed in names or not, default is false| |false|\n+|discriminatorExplicitMappingVerbose|Every model that has a discriminator explicitly defines the disciminator in itself, the mapping in that discriminator includes any descendent schemas that allOf inherit from self, any oneOf schemas, any anyOf schemas, any x-discriminator-values, and the spec's defined discriminator mapping schemas. When true, we validate that oneOf and anyOf schemas contain the required discriminator and we throw an error if it's missing. When true model templates should not loop over {{#children}} when defining the discriminator mapping| |false|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2MjgxOQ==", "bodyText": "Yes, I think that eventually all v3 generators will want to turn on this flag by default. It makes discriminator handling easier and it adds validation checking of the discriminator which is a significant feature addition and will help users.\nThis description has been updated per your feedback. We now state what tag to iterate over and what tags not to iterate over. Yup the children name is unclear, it is used for class inheritance so we can loop over the child classes and grab their names. We don't have that information in our composed schemas because they are children that allOf include the self schema/class.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r406862819", "createdAt": "2020-04-10T17:35:44Z", "author": {"login": "spacether"}, "path": "docs/generators/ada-server.md", "diffHunk": "@@ -6,6 +6,7 @@ sidebar_label: ada-server\n | Option | Description | Values | Default |\n | ------ | ----------- | ------ | ------- |\n |allowUnicodeIdentifiers|boolean, toggles whether unicode identifiers are allowed in names or not, default is false| |false|\n+|discriminatorExplicitMappingVerbose|Every model that has a discriminator explicitly defines the disciminator in itself, the mapping in that discriminator includes any descendent schemas that allOf inherit from self, any oneOf schemas, any anyOf schemas, any x-discriminator-values, and the spec's defined discriminator mapping schemas. When true, we validate that oneOf and anyOf schemas contain the required discriminator and we throw an error if it's missing. When true model templates should not loop over {{#children}} when defining the discriminator mapping| |false|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxMjQwOA=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjAxMzMwOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "isResolved": true, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxODozNjozNVrOF_Nk7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNDozMzo0OVrOGKWIMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg==", "bodyText": "I have a OAS document where this code is invoked and getMappingName() return null. This happens because this.mappingName is null. Should we test for getMappingName() being null and returning a RuntimeException with a message that helps troubleshoot (including the value of this.modelName)? Or should compareTo return != 0 when mappingName is null?\nAlso, is it done on purpose that the implementation of compareTo is different from the equals implementation logic?\nOr should the null value be caught earlier, such as when the MappedModel constructor is invoked?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401827052", "createdAt": "2020-04-01T18:36:35Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1NjM1MA==", "bodyText": "Update: I found one reason why the value is null. I can submit a PR. Do you want me to submit a PR to your branch?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401856350", "createdAt": "2020-04-01T19:27:48Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY0OTY3Mw==", "bodyText": "Yes, please submit a PR to my branch. I saw that you threw the error at assignment mappingName which is preferable to throwing the error later.\nThe only null that I saw was in a test. Why would it be null?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r403649673", "createdAt": "2020-04-05T05:02:04Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY1NTM1Ng==", "bodyText": "github is not allowing me to open a PR against your fork. I have this fix in my branch, I will ask William to merge after you. This happens for example when there is at least one vendor extension but not the discriminator extension. Also, since I don't think mappingName should be null, it would be good to catch early to make it easier to troubleshoot issues.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r403655356", "createdAt": "2020-04-05T06:18:27Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4MDY4Nw==", "bodyText": "This PR now works for the use case where there is at least one vendor extension but not the discriminator extension. Let's handle the null issue in your PR. I'd prefer not to have this very large PR grow in any more scope.\nI purposefully implemented of compareTo is differently than the equals implementation logic because compareTo is used for sorting. When discriminatorExplicitMappingVerbose ==True, we use this to have deterministic alphabetical sorting of the mappedModels.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r406880687", "createdAt": "2020-04-10T18:18:55Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4Mjg0Mg==", "bodyText": "@sebastien-rosset can you include me in the review process of your later PR?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r406882842", "createdAt": "2020-04-10T18:24:02Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzNDkyMg==", "bodyText": "So it looks like I have more time to work on this now. Given that, I included your suggested exception raising in the MappedModel instantiation if the mappingName is null.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r407234922", "createdAt": "2020-04-12T18:23:40Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMTg1Mg==", "bodyText": "@spacether this is a potential NPE. You're protected in the constructor, but not in the property setter. This method should have a null check, something like this:\npublic int compareTo(MappedModel other) {\n    if (null == getMappingName()) return 1;\n    return getMappingName().compareTo(other.getMappingName());", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410711852", "createdAt": "2020-04-18T15:25:21Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzY3Mw==", "bodyText": "Why not protect the setter also?\nWhy would null be a valid value for a mappingName?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410713673", "createdAt": "2020-04-18T15:40:51Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwODE3Nw==", "bodyText": "@spacether it doesn't look like it should be an acceptable value in code, but this type is public with a getter/setter so it should cover all places where an NPE might be possible. It's not really common, and probably frowned upon to throw an exception in a property setter.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410808177", "createdAt": "2020-04-19T04:00:12Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUwMTQ5MQ==", "bodyText": "I removed the exception raising.\nThis now returns int results for null and null to string comparisons.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413501491", "createdAt": "2020-04-23T04:33:49Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjIyMDc4OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTozNToyMVrOF_PnqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQwNjoxODo0MlrOGA9K1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MDUyMA==", "bodyText": "The \"setMappingName\" function is not used anywhere. Does it make sense to remove it? I find it complicates troubleshooting and code maintenance when unused methods are added. This is because the code maintainer has to consider multiple ways the data can change.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401860520", "createdAt": "2020-04-01T19:35:21Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY0OTcyOQ==", "bodyText": "How about we table that for a later PR? I don't want to remove a public interface if I don't have to.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r403649729", "createdAt": "2020-04-05T05:03:08Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MDUyMA=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY1NTM4MQ==", "bodyText": "ok", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r403655381", "createdAt": "2020-04-05T06:18:42Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MDUyMA=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjIyMzc5OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTozNjoyMlrOF_PppA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQwNTowNjoxOFrOGA81jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MTAyOA==", "bodyText": "It would be helpful to add documentation.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401861028", "createdAt": "2020-04-01T19:36:22Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -1111,6 +1120,14 @@ public void setEnsureUniqueParams(Boolean ensureUniqueParams) {\n         this.ensureUniqueParams = ensureUniqueParams;\n     }\n \n+    public Boolean getDiscriminatorExplicitMappingVerbose() {\n+        return discriminatorExplicitMappingVerbose;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY0OTkzMg==", "bodyText": "We already have documentation in the discriminatorExplicitMappingVerbose flag documentation.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r403649932", "createdAt": "2020-04-05T05:06:18Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -1111,6 +1120,14 @@ public void setEnsureUniqueParams(Boolean ensureUniqueParams) {\n         this.ensureUniqueParams = ensureUniqueParams;\n     }\n \n+    public Boolean getDiscriminatorExplicitMappingVerbose() {\n+        return discriminatorExplicitMappingVerbose;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MTAyOA=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjI3NjgzOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTo1MToxMVrOF_QKPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQwNTowNzo0M1rOGA819w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2OTM3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            String xDiscriminatorValue = (String) vendorExtensions.get(\"x-discriminator-value\");\n          \n          \n            \n                           if (xDiscriminatorValue != null) {\n          \n          \n            \n                               mm = new MappedModel(xDiscriminatorValue, toModelName(currentSchemaName));\n          \n          \n            \n                               descendentSchemas.add(mm);\n          \n          \n            \n                           }", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401869375", "createdAt": "2020-04-01T19:51:11Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2338,36 +2381,314 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n-    protected CodegenDiscriminator createDiscriminator(String schemaName, Schema schema) {\n-        if (schema.getDiscriminator() == null) {\n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * and return a CodegenProperty with the dataType and required params set\n+     * the returned CodegenProperty may not be required and it may not be of type string\n+     * @param composedSchemaName The name of the sc Schema\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private CodegenProperty discriminatorFound(String composedSchemaName, Schema sc, String discPropName, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        if (refSchema.getProperties() != null && refSchema.getProperties().get(discPropName) != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            CodegenProperty cp = new CodegenProperty();\n+            cp.setDatatype(discSchema.getType());\n+            cp.setRequired(false);\n+            if (refSchema.getRequired() != null && refSchema.getRequired().contains(discPropName)) {\n+                cp.setRequired(true);\n+            }\n+            return cp;\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    CodegenProperty cp = discriminatorFound(composedSchemaName, allOf, discPropName, openAPI);\n+                    if (cp != null) {\n+                        return cp;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(oneOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, oneOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced OneOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the OneOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior OneOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(anyOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, anyOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced AnyOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the AnyOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior AnyOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Recursively look in Schema sc for the discriminator and return it\n+     * Schema sc location\n+     * OpenAPI openAPI the spec where we are searching for the discriminator\n+     * @param sc The Schema that may contain the discriminator\n+     */\n+    private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        Discriminator foundDisc = refSchema.getDiscriminator();\n+        if (foundDisc != null) {\n+            return foundDisc;\n+        }\n+        if (!this.getDiscriminatorExplicitMappingVerbose()) {\n+            return null;\n+        }\n+        Discriminator disc = new Discriminator();\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    foundDisc = recursiveGetDiscriminator(allOf, openAPI);\n+                    if (foundDisc != null) {\n+                        disc.setPropertyName(foundDisc.getPropertyName());\n+                        disc.setMapping(foundDisc.getMapping());\n+                        return disc;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    foundDisc = recursiveGetDiscriminator(oneOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    foundDisc = recursiveGetDiscriminator(anyOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * a list if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param openAPI The OpenAPI spec that we are using\n+     * @return the list of oneOf and anyOf MappedModel that need to be added to the discriminator map\n+     */\n+    protected List<MappedModel> getOneOfAnyOfDescendants(String composedSchemaName, String discPropName, ComposedSchema c, OpenAPI openAPI) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        List<MappedModel> descendentSchemas = new ArrayList();\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    // Note: if it is only inline one level, then the inline model resolver will move it into its own\n+                    // schema and make it a $ref schema in the oneOf/anyOf location\n+                    throw new RuntimeException(\"Invalid inline schema defined in oneOf/anyOf in '\" + composedSchemaName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the oneOf/anyOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                }\n+                CodegenProperty df = discriminatorFound(composedSchemaName, sc, discPropName, openAPI);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (df == null || !\"string\".equals(df.dataType) || df.required != true) {\n+                    String msgSuffix = \"\";\n+                    if (df == null) {\n+                        msgSuffix += discPropName+\" is missing from the schema, define it as required and type string\";\n+                    } else {\n+                        if (!\"string\".equals(df.dataType)) {\n+                            msgSuffix += \"invalid type for \"+discPropName+\", set it to string\";\n+                        }\n+                        if (df.required != true) {\n+                            String spacer = \"\";\n+                            if (msgSuffix.length() != 0) {\n+                                spacer = \". \";\n+                            }\n+                            msgSuffix += spacer+\"invalid optional definition of \"+discPropName+\", include it in required\";\n+                        }\n+                    }\n+                    throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced schema '\" + modelName + \"' is incorrect. \"+msgSuffix);\n+                }\n+                MappedModel mm = new MappedModel(modelName, toModelName(modelName));\n+                descendentSchemas.add(mm);\n+                Schema cs = ModelUtils.getSchema(openAPI, modelName);\n+                Map<String, Object> vendorExtensions = cs.getExtensions();\n+                if (vendorExtensions != null && !vendorExtensions.isEmpty()) {\n+                    String xDiscriminatorValue = (String) vendorExtensions.get(\"x-discriminator-value\");\n+                    mm = new MappedModel(xDiscriminatorValue, toModelName(modelName));\n+                    descendentSchemas.add(mm);\n+                }\n+\n+            }\n+        }\n+        return descendentSchemas;\n+    }\n+\n+    protected List<MappedModel> getAllOfDescendants(String thisSchemaName, OpenAPI openAPI) {\n+        ArrayList<String> queue = new ArrayList();;\n+        List<MappedModel> descendentSchemas = new ArrayList();\n+        Map<String, Schema> schemas = ModelUtils.getSchemas(openAPI);\n+        String currentSchemaName = thisSchemaName;\n+        while (true) {\n+            for (String childName : schemas.keySet()) {\n+                if (childName == thisSchemaName) {\n+                    continue;\n+                }\n+                Schema child = schemas.get(childName);\n+                if (ModelUtils.isComposedSchema(child)) {\n+                    ComposedSchema composedChild = (ComposedSchema) child;\n+                    List<Schema> parents = composedChild.getAllOf();\n+                    if (parents != null) {\n+                        for  (Schema parent: parents) {\n+                            String ref = parent.get$ref();\n+                            if (ref == null) {\n+                                // for schemas with no ref, it is not possible to build the discriminator map\n+                                // because ref is how we get the model name\n+                                // we only hit this use case for a schema with inline composed schemas, and one of those\n+                                // schemas also has inline composed schemas\n+                                throw new RuntimeException(\"Invalid inline schema defined in allOf in '\" + childName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the allOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                            }\n+                            String parentName = ModelUtils.getSimpleRef(ref);\n+                            if (parentName.equals(currentSchemaName)) {\n+                                if (queue.contains(childName) || descendentSchemas.contains(childName)) {\n+                                    throw new RuntimeException(\"Stack overflow hit when looking for \"+thisSchemaName+\" an infinite loop starting and ending at \"+childName+\" was seen\");\n+                                }\n+                                queue.add(childName);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            if (queue.size() == 0) {\n+                break;\n+            }\n+            currentSchemaName = queue.remove(0);\n+            MappedModel mm = new MappedModel(currentSchemaName, toModelName(currentSchemaName));\n+            descendentSchemas.add(mm);\n+            Schema cs = schemas.get(currentSchemaName);\n+            Map<String, Object> vendorExtensions = cs.getExtensions();\n+            if (vendorExtensions != null && !vendorExtensions.isEmpty()) {\n+                String xDiscriminatorValue = (String) vendorExtensions.get(\"x-discriminator-value\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY1MDAzOQ==", "bodyText": "This was already updated to the simpler:\nif (vendorExtensions != null && !vendorExtensions.isEmpty() && vendorExtensions.containsKey(\"x-discriminator-value\")) {", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r403650039", "createdAt": "2020-04-05T05:07:43Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2338,36 +2381,314 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n-    protected CodegenDiscriminator createDiscriminator(String schemaName, Schema schema) {\n-        if (schema.getDiscriminator() == null) {\n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * and return a CodegenProperty with the dataType and required params set\n+     * the returned CodegenProperty may not be required and it may not be of type string\n+     * @param composedSchemaName The name of the sc Schema\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private CodegenProperty discriminatorFound(String composedSchemaName, Schema sc, String discPropName, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        if (refSchema.getProperties() != null && refSchema.getProperties().get(discPropName) != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            CodegenProperty cp = new CodegenProperty();\n+            cp.setDatatype(discSchema.getType());\n+            cp.setRequired(false);\n+            if (refSchema.getRequired() != null && refSchema.getRequired().contains(discPropName)) {\n+                cp.setRequired(true);\n+            }\n+            return cp;\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    CodegenProperty cp = discriminatorFound(composedSchemaName, allOf, discPropName, openAPI);\n+                    if (cp != null) {\n+                        return cp;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(oneOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, oneOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced OneOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the OneOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior OneOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(anyOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, anyOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced AnyOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the AnyOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior AnyOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Recursively look in Schema sc for the discriminator and return it\n+     * Schema sc location\n+     * OpenAPI openAPI the spec where we are searching for the discriminator\n+     * @param sc The Schema that may contain the discriminator\n+     */\n+    private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        Discriminator foundDisc = refSchema.getDiscriminator();\n+        if (foundDisc != null) {\n+            return foundDisc;\n+        }\n+        if (!this.getDiscriminatorExplicitMappingVerbose()) {\n+            return null;\n+        }\n+        Discriminator disc = new Discriminator();\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    foundDisc = recursiveGetDiscriminator(allOf, openAPI);\n+                    if (foundDisc != null) {\n+                        disc.setPropertyName(foundDisc.getPropertyName());\n+                        disc.setMapping(foundDisc.getMapping());\n+                        return disc;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    foundDisc = recursiveGetDiscriminator(oneOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    foundDisc = recursiveGetDiscriminator(anyOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * a list if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param openAPI The OpenAPI spec that we are using\n+     * @return the list of oneOf and anyOf MappedModel that need to be added to the discriminator map\n+     */\n+    protected List<MappedModel> getOneOfAnyOfDescendants(String composedSchemaName, String discPropName, ComposedSchema c, OpenAPI openAPI) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        List<MappedModel> descendentSchemas = new ArrayList();\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    // Note: if it is only inline one level, then the inline model resolver will move it into its own\n+                    // schema and make it a $ref schema in the oneOf/anyOf location\n+                    throw new RuntimeException(\"Invalid inline schema defined in oneOf/anyOf in '\" + composedSchemaName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the oneOf/anyOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                }\n+                CodegenProperty df = discriminatorFound(composedSchemaName, sc, discPropName, openAPI);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (df == null || !\"string\".equals(df.dataType) || df.required != true) {\n+                    String msgSuffix = \"\";\n+                    if (df == null) {\n+                        msgSuffix += discPropName+\" is missing from the schema, define it as required and type string\";\n+                    } else {\n+                        if (!\"string\".equals(df.dataType)) {\n+                            msgSuffix += \"invalid type for \"+discPropName+\", set it to string\";\n+                        }\n+                        if (df.required != true) {\n+                            String spacer = \"\";\n+                            if (msgSuffix.length() != 0) {\n+                                spacer = \". \";\n+                            }\n+                            msgSuffix += spacer+\"invalid optional definition of \"+discPropName+\", include it in required\";\n+                        }\n+                    }\n+                    throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced schema '\" + modelName + \"' is incorrect. \"+msgSuffix);\n+                }\n+                MappedModel mm = new MappedModel(modelName, toModelName(modelName));\n+                descendentSchemas.add(mm);\n+                Schema cs = ModelUtils.getSchema(openAPI, modelName);\n+                Map<String, Object> vendorExtensions = cs.getExtensions();\n+                if (vendorExtensions != null && !vendorExtensions.isEmpty()) {\n+                    String xDiscriminatorValue = (String) vendorExtensions.get(\"x-discriminator-value\");\n+                    mm = new MappedModel(xDiscriminatorValue, toModelName(modelName));\n+                    descendentSchemas.add(mm);\n+                }\n+\n+            }\n+        }\n+        return descendentSchemas;\n+    }\n+\n+    protected List<MappedModel> getAllOfDescendants(String thisSchemaName, OpenAPI openAPI) {\n+        ArrayList<String> queue = new ArrayList();;\n+        List<MappedModel> descendentSchemas = new ArrayList();\n+        Map<String, Schema> schemas = ModelUtils.getSchemas(openAPI);\n+        String currentSchemaName = thisSchemaName;\n+        while (true) {\n+            for (String childName : schemas.keySet()) {\n+                if (childName == thisSchemaName) {\n+                    continue;\n+                }\n+                Schema child = schemas.get(childName);\n+                if (ModelUtils.isComposedSchema(child)) {\n+                    ComposedSchema composedChild = (ComposedSchema) child;\n+                    List<Schema> parents = composedChild.getAllOf();\n+                    if (parents != null) {\n+                        for  (Schema parent: parents) {\n+                            String ref = parent.get$ref();\n+                            if (ref == null) {\n+                                // for schemas with no ref, it is not possible to build the discriminator map\n+                                // because ref is how we get the model name\n+                                // we only hit this use case for a schema with inline composed schemas, and one of those\n+                                // schemas also has inline composed schemas\n+                                throw new RuntimeException(\"Invalid inline schema defined in allOf in '\" + childName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the allOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                            }\n+                            String parentName = ModelUtils.getSimpleRef(ref);\n+                            if (parentName.equals(currentSchemaName)) {\n+                                if (queue.contains(childName) || descendentSchemas.contains(childName)) {\n+                                    throw new RuntimeException(\"Stack overflow hit when looking for \"+thisSchemaName+\" an infinite loop starting and ending at \"+childName+\" was seen\");\n+                                }\n+                                queue.add(childName);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            if (queue.size() == 0) {\n+                break;\n+            }\n+            currentSchemaName = queue.remove(0);\n+            MappedModel mm = new MappedModel(currentSchemaName, toModelName(currentSchemaName));\n+            descendentSchemas.add(mm);\n+            Schema cs = schemas.get(currentSchemaName);\n+            Map<String, Object> vendorExtensions = cs.getExtensions();\n+            if (vendorExtensions != null && !vendorExtensions.isEmpty()) {\n+                String xDiscriminatorValue = (String) vendorExtensions.get(\"x-discriminator-value\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2OTM3NQ=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 424}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTQ5MTcwOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDo0ODoxNFrOF_u5RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzo1Nzo1MVrOGEBgQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MjkzMw==", "bodyText": "It would be useful to document how the mappedModels field is populated.\nOne way to think about it when reading the code is \"oh this must be the explicit discriminator mappings as written in the OpenAPI document\", without any transformation.\nBut since codegen typically transforms the data, mappedModels could include mappings that have been resolved by codegen through a recursive discovery process.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r402372933", "createdAt": "2020-04-02T14:48:14Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -7,7 +7,18 @@\n import java.util.Objects;\n import java.util.Set;\n \n+/**\n+ * This class encapsulates the OpenAPI discriminator construct, as specified at\n+ * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#discriminatorObject.\n+ *\n+ * When request bodies or response payloads may be one of a number of different schemas,\n+ * a discriminator object can be used to aid in serialization, deserialization, and validation.\n+ * The discriminator is a specific object in a schema which is used to inform the consumer of\n+ * the specification of an alternative schema based on the value associated with it.\n+ */\n public class CodegenDiscriminator {\n+    // The name of the property in the payload that will hold the discriminator value.\n+    // This is the propertyName as specified in the OpenAPI discriminator object.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ff63c1e606b563dbe559b2bc191de62659a7ff"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3MjEzMQ==", "bodyText": "This comment has been added:\n    // mappedModels is populated differently if discriminatorExplicitMappingVerbose is\n    // True or False. When:\n    //\n    // discriminatorExplicitMappingVerbose == False, this contains:\n    // - the name to schema map info in the discriminator mapping entry in your openapi spec OR\n    // - child schemas that allOf inherit self schema\n    //\n    // discriminatorExplicitMappingVerbose == True, this contains:\n    // - the name to schema map info in the discriminator mapping entry in your openapi spec AND\n    // - x-discriminator-value mappings in child oneOf + anyOf schemas + descendant schemas that allOf inherit self schema AND\n    // - descendant schemas that allOf inherit self schema AND\n    // - child oneOf + anyOf schemas\n    //\n    // see the method createDiscriminator in DefaultCodegen.java", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r406872131", "createdAt": "2020-04-10T17:57:51Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -7,7 +7,18 @@\n import java.util.Objects;\n import java.util.Set;\n \n+/**\n+ * This class encapsulates the OpenAPI discriminator construct, as specified at\n+ * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#discriminatorObject.\n+ *\n+ * When request bodies or response payloads may be one of a number of different schemas,\n+ * a discriminator object can be used to aid in serialization, deserialization, and validation.\n+ * The discriminator is a specific object in a schema which is used to inform the consumer of\n+ * the specification of an alternative schema based on the value associated with it.\n+ */\n public class CodegenDiscriminator {\n+    // The name of the property in the payload that will hold the discriminator value.\n+    // This is the propertyName as specified in the OpenAPI discriminator object.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MjkzMw=="}, "originalCommit": {"oid": "75ff63c1e606b563dbe559b2bc191de62659a7ff"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjcxMDk4OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNjowMDo1MVrOGCKuHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxODoxMjowMVrOGCQD0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyNTk4MQ==", "bodyText": "Not all languages use \"string\". What about using df.isString to check if it's a string instead?\nSame for line 2568.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r404925981", "createdAt": "2020-04-07T16:00:51Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2341,36 +2384,314 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n-    protected CodegenDiscriminator createDiscriminator(String schemaName, Schema schema) {\n-        if (schema.getDiscriminator() == null) {\n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * and return a CodegenProperty with the dataType and required params set\n+     * the returned CodegenProperty may not be required and it may not be of type string\n+     * @param composedSchemaName The name of the sc Schema\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private CodegenProperty discriminatorFound(String composedSchemaName, Schema sc, String discPropName, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        if (refSchema.getProperties() != null && refSchema.getProperties().get(discPropName) != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            CodegenProperty cp = new CodegenProperty();\n+            cp.setDatatype(discSchema.getType());\n+            cp.setRequired(false);\n+            if (refSchema.getRequired() != null && refSchema.getRequired().contains(discPropName)) {\n+                cp.setRequired(true);\n+            }\n+            return cp;\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    CodegenProperty cp = discriminatorFound(composedSchemaName, allOf, discPropName, openAPI);\n+                    if (cp != null) {\n+                        return cp;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(oneOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, oneOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced OneOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the OneOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior OneOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(anyOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, anyOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced AnyOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the AnyOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior AnyOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Recursively look in Schema sc for the discriminator and return it\n+     * Schema sc location\n+     * OpenAPI openAPI the spec where we are searching for the discriminator\n+     * @param sc The Schema that may contain the discriminator\n+     */\n+    private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        Discriminator foundDisc = refSchema.getDiscriminator();\n+        if (foundDisc != null) {\n+            return foundDisc;\n+        }\n+        if (!this.getDiscriminatorExplicitMappingVerbose()) {\n+            return null;\n+        }\n+        Discriminator disc = new Discriminator();\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    foundDisc = recursiveGetDiscriminator(allOf, openAPI);\n+                    if (foundDisc != null) {\n+                        disc.setPropertyName(foundDisc.getPropertyName());\n+                        disc.setMapping(foundDisc.getMapping());\n+                        return disc;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    foundDisc = recursiveGetDiscriminator(oneOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    foundDisc = recursiveGetDiscriminator(anyOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * a list if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param openAPI The OpenAPI spec that we are using\n+     * @return the list of oneOf and anyOf MappedModel that need to be added to the discriminator map\n+     */\n+    protected List<MappedModel> getOneOfAnyOfDescendants(String composedSchemaName, String discPropName, ComposedSchema c, OpenAPI openAPI) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        List<MappedModel> descendentSchemas = new ArrayList();\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    // Note: if it is only inline one level, then the inline model resolver will move it into its own\n+                    // schema and make it a $ref schema in the oneOf/anyOf location\n+                    throw new RuntimeException(\"Invalid inline schema defined in oneOf/anyOf in '\" + composedSchemaName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the oneOf/anyOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                }\n+                CodegenProperty df = discriminatorFound(composedSchemaName, sc, discPropName, openAPI);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (df == null || !\"string\".equals(df.dataType) || df.required != true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7f1bce202ff72ab096548cc20094cdeda9afae8"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAxMzQ1OA==", "bodyText": "Switched to using df.isString", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r405013458", "createdAt": "2020-04-07T18:12:01Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2341,36 +2384,314 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n-    protected CodegenDiscriminator createDiscriminator(String schemaName, Schema schema) {\n-        if (schema.getDiscriminator() == null) {\n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * and return a CodegenProperty with the dataType and required params set\n+     * the returned CodegenProperty may not be required and it may not be of type string\n+     * @param composedSchemaName The name of the sc Schema\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private CodegenProperty discriminatorFound(String composedSchemaName, Schema sc, String discPropName, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        if (refSchema.getProperties() != null && refSchema.getProperties().get(discPropName) != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            CodegenProperty cp = new CodegenProperty();\n+            cp.setDatatype(discSchema.getType());\n+            cp.setRequired(false);\n+            if (refSchema.getRequired() != null && refSchema.getRequired().contains(discPropName)) {\n+                cp.setRequired(true);\n+            }\n+            return cp;\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    CodegenProperty cp = discriminatorFound(composedSchemaName, allOf, discPropName, openAPI);\n+                    if (cp != null) {\n+                        return cp;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(oneOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, oneOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced OneOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the OneOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior OneOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(anyOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, anyOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced AnyOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the AnyOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior AnyOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Recursively look in Schema sc for the discriminator and return it\n+     * Schema sc location\n+     * OpenAPI openAPI the spec where we are searching for the discriminator\n+     * @param sc The Schema that may contain the discriminator\n+     */\n+    private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        Discriminator foundDisc = refSchema.getDiscriminator();\n+        if (foundDisc != null) {\n+            return foundDisc;\n+        }\n+        if (!this.getDiscriminatorExplicitMappingVerbose()) {\n+            return null;\n+        }\n+        Discriminator disc = new Discriminator();\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    foundDisc = recursiveGetDiscriminator(allOf, openAPI);\n+                    if (foundDisc != null) {\n+                        disc.setPropertyName(foundDisc.getPropertyName());\n+                        disc.setMapping(foundDisc.getMapping());\n+                        return disc;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    foundDisc = recursiveGetDiscriminator(oneOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    foundDisc = recursiveGetDiscriminator(anyOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * a list if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param openAPI The OpenAPI spec that we are using\n+     * @return the list of oneOf and anyOf MappedModel that need to be added to the discriminator map\n+     */\n+    protected List<MappedModel> getOneOfAnyOfDescendants(String composedSchemaName, String discPropName, ComposedSchema c, OpenAPI openAPI) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        List<MappedModel> descendentSchemas = new ArrayList();\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    // Note: if it is only inline one level, then the inline model resolver will move it into its own\n+                    // schema and make it a $ref schema in the oneOf/anyOf location\n+                    throw new RuntimeException(\"Invalid inline schema defined in oneOf/anyOf in '\" + composedSchemaName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the oneOf/anyOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                }\n+                CodegenProperty df = discriminatorFound(composedSchemaName, sc, discPropName, openAPI);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (df == null || !\"string\".equals(df.dataType) || df.required != true) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyNTk4MQ=="}, "originalCommit": {"oid": "c7f1bce202ff72ab096548cc20094cdeda9afae8"}, "originalPosition": 321}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MDQ3OTI0OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator-cli/src/main/java/org/openapitools/codegen/cmd/Generate.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNToyNzowM1rOGHr3yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjozNjoyNlrOGKY5EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjAxMQ==", "bodyText": "This option needs clarification since it's currently doing a lot.\n\nCan we remove the \"verbose\" since that's not really relevant to the user?\nThe term mapping would indicate to users who are familiar with our options that this would take a string in the format key=value, which is not the case.\nThe option is triggering OpenAPI 3.x logic, but doesn't indicate that clearly here.\n\nMight I recommend changing this to something more like:\n@Option(name = {\"--legacy-discriminators\"}, title = \"Support legacy logic for evaluating discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)\nprivate Boolean legacyDiscriminators;\n\nThis value would need to default to true until the new logic becomes default (I don't recall if it's now default or not).\nThe value would then have to be applied to CodegenConfigurator, which is not done in Generate.java here. The same default would have to be done in the Maven and Gradle plugins, with a task to add the feature option to those. We also have a new SBT plugin (pending first release) where this would have to be added.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410712011", "createdAt": "2020-04-18T15:27:03Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator-cli/src/main/java/org/openapitools/codegen/cmd/Generate.java", "diffHunk": "@@ -240,6 +240,9 @@\n     @Option(name = {\"--generate-alias-as-model\"}, title = \"generate alias (array, map) as model\", description = CodegenConstants.GENERATE_ALIAS_AS_MODEL_DESC)\n     private Boolean generateAliasAsModel;\n \n+    @Option(name = {\"--discriminator-explicit-mapping-verbose\"}, title = \"explicitly define a discriminator on all models which have one, add verbose mapping to that discriminator, validate discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczNTUxNg==", "bodyText": "This option needs clarification since it's currently doing a lot.\n\nCan we remove the \"verbose\" since that's not really relevant to the user?\nThe term mapping would indicate to users who are familiar with our options that this would take a string in the format key=value, which is not the case.\nThe option is triggering OpenAPI 3.x logic, but doesn't indicate that clearly here.\n\nMight I recommend changing this to something more like:\n@Option(name = {\"--legacy-discriminators\"}, title = \"Support legacy logic for evaluating discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)\nprivate Boolean legacyDiscriminators;\n\nThis value would need to default to true until the new logic becomes default (I don't recall if it's now default or not).\nThe value would then have to be applied to CodegenConfigurator, which is not done in Generate.java here. The same default would have to be done in the Maven and Gradle plugins, with a task to add the feature option to those. We also have a new SBT plugin (pending first release) where this would have to be added.\n\nI think the name should be even more explicit. Without this PR, the existing OAS v3 is buggy. It's not just that it would be legacy, it is not fully compliant with the OAS oneOf/allOf/anyOf spec. At least that's my assessment for python, python-experimental, go, go-experimental, powershell and all java clients. Until a language generator enables this parameter, it should not claim support for anyOf/allOf/oneOf, or maybe it should only claim partial support.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410735516", "createdAt": "2020-04-18T18:48:01Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator-cli/src/main/java/org/openapitools/codegen/cmd/Generate.java", "diffHunk": "@@ -240,6 +240,9 @@\n     @Option(name = {\"--generate-alias-as-model\"}, title = \"generate alias (array, map) as model\", description = CodegenConstants.GENERATE_ALIAS_AS_MODEL_DESC)\n     private Boolean generateAliasAsModel;\n \n+    @Option(name = {\"--discriminator-explicit-mapping-verbose\"}, title = \"explicitly define a discriminator on all models which have one, add verbose mapping to that discriminator, validate discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjAxMQ=="}, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0NjYzMw==", "bodyText": "@sebastien-rosset allowing the user to continue using the same previous behavior (legacy), means we don't break people who have written customization to overcome any limitations.\nMaybe \"legacy discriminator behavior\"? As it is now, I don't think we could meet this with such a confusing option.\nConsider for instance someone with a 2.0 spec shouldn't assume that setting this value to true gets them 3.0 behavior. As it is now, that's what it sounds like. A 3.0 spec shouldn't change generated output drastically. I agree this makes the logic more correct, but again people are about to extend generators as well as templates. Any user who has specified vendor extensions or written a custom generator would be blocked from updates because of this change, and such a user inspections options wouldn't understand this is the option to change.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410746633", "createdAt": "2020-04-18T20:29:29Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator-cli/src/main/java/org/openapitools/codegen/cmd/Generate.java", "diffHunk": "@@ -240,6 +240,9 @@\n     @Option(name = {\"--generate-alias-as-model\"}, title = \"generate alias (array, map) as model\", description = CodegenConstants.GENERATE_ALIAS_AS_MODEL_DESC)\n     private Boolean generateAliasAsModel;\n \n+    @Option(name = {\"--discriminator-explicit-mapping-verbose\"}, title = \"explicitly define a discriminator on all models which have one, add verbose mapping to that discriminator, validate discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjAxMQ=="}, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1MjI4Nw==", "bodyText": "@sebastien-rosset allowing the user to continue using the same previous behavior (legacy), means we don't break people who have written customization to overcome any limitations.\nMaybe \"legacy discriminator behavior\"? As it is now, I don't think we could meet this with such a confusing option.\n\nI agree the current option name could be improved.\n\nConsider for instance someone with a 2.0 spec shouldn't assume that setting this value to true gets them 3.0 behavior. As it is now, that's what it sounds like. A 3.0 spec shouldn't change generated output drastically. I agree this makes the logic more correct, but again people are about to extend generators as well as templates. Any user who has specified vendor extensions or written a custom generator would be blocked from updates because of this change, and such a user inspections options wouldn't understand this is the option to change.\n\nSure, but don't you think at some point all language generators should enable the new behavior by default (as implemented in this PR)? The tool should support all OAS 3.x features by default. Otherwise, somebody who is downloading OpenAPITools for the first time and compiles a OAS v3 spec that contains oneOf/allOf/anyOf.\nIf there needs to be a differentiation between 2.x and 3.x maybe that could be done selectively based on the version?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410752287", "createdAt": "2020-04-18T21:19:50Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator-cli/src/main/java/org/openapitools/codegen/cmd/Generate.java", "diffHunk": "@@ -240,6 +240,9 @@\n     @Option(name = {\"--generate-alias-as-model\"}, title = \"generate alias (array, map) as model\", description = CodegenConstants.GENERATE_ALIAS_AS_MODEL_DESC)\n     private Boolean generateAliasAsModel;\n \n+    @Option(name = {\"--discriminator-explicit-mapping-verbose\"}, title = \"explicitly define a discriminator on all models which have one, add verbose mapping to that discriminator, validate discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjAxMQ=="}, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc2ODk0MA==", "bodyText": "Yes, but unfortunately you can't really have non-breaking behavior for 3.0 (bug fix, spec support) and potentially break the behavior for 2.0 at the same time. We have to play it safer, especially since feature requests indicate more people are on 2.0 specs still, and we don't have telemetry to know differently. If we can do these simultaneously, then there's no need to a user-facing option.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410768940", "createdAt": "2020-04-18T23:20:28Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator-cli/src/main/java/org/openapitools/codegen/cmd/Generate.java", "diffHunk": "@@ -240,6 +240,9 @@\n     @Option(name = {\"--generate-alias-as-model\"}, title = \"generate alias (array, map) as model\", description = CodegenConstants.GENERATE_ALIAS_AS_MODEL_DESC)\n     private Boolean generateAliasAsModel;\n \n+    @Option(name = {\"--discriminator-explicit-mapping-verbose\"}, title = \"explicitly define a discriminator on all models which have one, add verbose mapping to that discriminator, validate discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjAxMQ=="}, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0Njc2OQ==", "bodyText": "This has been changed to legacyDiscriminatorBehavior", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413546769", "createdAt": "2020-04-23T06:36:26Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator-cli/src/main/java/org/openapitools/codegen/cmd/Generate.java", "diffHunk": "@@ -240,6 +240,9 @@\n     @Option(name = {\"--generate-alias-as-model\"}, title = \"generate alias (array, map) as model\", description = CodegenConstants.GENERATE_ALIAS_AS_MODEL_DESC)\n     private Boolean generateAliasAsModel;\n \n+    @Option(name = {\"--discriminator-explicit-mapping-verbose\"}, title = \"explicitly define a discriminator on all models which have one, add verbose mapping to that discriminator, validate discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjAxMQ=="}, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MDQ4MTk3OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNToyOToyN1rOGHr5FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjozNjo1MlrOGKY58Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjM0MA==", "bodyText": "This is a confusing use of configuration. It's created in Generate.java as a CLI option, but then pulled from additionalProperties here. We should stick to one or the other (not both).\nI think it makes sense to add it to WorkflowSettings because we're defining the workflow for geneation.\nLet me know if you'd like help and I can contribute that directly to your branch.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410712340", "createdAt": "2020-04-18T15:29:27Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -306,6 +309,11 @@ public void processOpts() {\n             this.setRemoveEnumValuePrefix(Boolean.valueOf(additionalProperties\n                     .get(CodegenConstants.REMOVE_ENUM_VALUE_PREFIX).toString()));\n         }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0Njk5Mw==", "bodyText": "This has been changed to legacyDiscriminatorBehavior\nI will update to the suggested integration", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413546993", "createdAt": "2020-04-23T06:36:52Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -306,6 +309,11 @@ public void processOpts() {\n             this.setRemoveEnumValuePrefix(Boolean.valueOf(additionalProperties\n                     .get(CodegenConstants.REMOVE_ENUM_VALUE_PREFIX).toString()));\n         }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjM0MA=="}, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MDQ5MjAzOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTozOToyN1rOGHr90w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjozNzo0OFrOGKY7sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzU1NQ==", "bodyText": "This option needs better definition. If it's a CLI option (in Generate.java), it should be hooked up to CodegenConfigurator and applied as a way to configure this generation.\nCliOptions is a place to define generator-specific (*Codegen types) logic, and not \"global\" workflows.\nFor instance, the option in Generate.java will show via cli help generate while the option here would show via cli config-help -g generator_name. The latter is intended only for those configurations which don't apply to all generators.\nA good rule for these:  only define things in CliOptions if they are template customizable, put others via CodegenConfigurator and extend via additionalProperties.  I open to clarify and clean this all up by 5.0.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410713555", "createdAt": "2020-04-18T15:39:27Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -1423,6 +1440,9 @@ public DefaultCodegen() {\n         // option to change the order of form/body parameter\n         cliOptions.add(CliOption.newBoolean(CodegenConstants.PREPEND_FORM_OR_BODY_PARAMETERS,\n                 CodegenConstants.PREPEND_FORM_OR_BODY_PARAMETERS_DESC).defaultValue(Boolean.FALSE.toString()));\n+        cliOptions.add(CliOption.newBoolean(CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0NzQ0Mg==", "bodyText": "This has been changed to LEGACY_DISCRIMINATOR_BEHAVIOR\nI will update to the suggested integration", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413547442", "createdAt": "2020-04-23T06:37:48Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -1423,6 +1440,9 @@ public DefaultCodegen() {\n         // option to change the order of form/body parameter\n         cliOptions.add(CliOption.newBoolean(CodegenConstants.PREPEND_FORM_OR_BODY_PARAMETERS,\n                 CodegenConstants.PREPEND_FORM_OR_BODY_PARAMETERS_DESC).defaultValue(Boolean.FALSE.toString()));\n+        cliOptions.add(CliOption.newBoolean(CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzU1NQ=="}, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MDQ5Mzk4OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTo0MjowOFrOGHr-1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNDoxODoxMlrOGKV10Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzgxMw==", "bodyText": "This should not be protected. If you're doing this for testing, please remove the modifier and treat this as package-private. By adding protected, you're telling users that we expect them to customize this and modify the method. That would be a maintenance nightmare for us if we don't even know how the tool's properties are applied.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410713813", "createdAt": "2020-04-18T15:42:08Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "diffHunk": "@@ -156,7 +156,7 @@ private Boolean getGeneratorPropertyDefaultSwitch(final String key, final Boolea\n         return defaultValue;\n     }\n \n-    private void configureGeneratorProperties() {\n+    protected void configureGeneratorProperties() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5Njc4NQ==", "bodyText": "This update is needed for tests, changed it to package private", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413496785", "createdAt": "2020-04-23T04:18:12Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "diffHunk": "@@ -156,7 +156,7 @@ private Boolean getGeneratorPropertyDefaultSwitch(final String key, final Boolea\n         return defaultValue;\n     }\n \n-    private void configureGeneratorProperties() {\n+    protected void configureGeneratorProperties() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzgxMw=="}, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MDQ5NDA2OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTo0MjoyMVrOGHr-4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNDoxODo0NlrOGKV2cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzgyNQ==", "bodyText": "Same. This should not be protected. If you're doing this for testing, please remove the modifier and treat this as package-private.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410713825", "createdAt": "2020-04-18T15:42:21Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "diffHunk": "@@ -394,7 +394,7 @@ private void generateModel(List<File> files, Map<String, Object> models, String\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private void generateModels(List<File> files, List<Object> allModels, List<String> unusedModels) {\n+    protected void generateModels(List<File> files, List<Object> allModels, List<String> unusedModels) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5Njk0NA==", "bodyText": "This update is needed for tests, changed it to package private", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413496944", "createdAt": "2020-04-23T04:18:46Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "diffHunk": "@@ -394,7 +394,7 @@ private void generateModel(List<File> files, Map<String, Object> models, String\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private void generateModels(List<File> files, List<Object> allModels, List<String> unusedModels) {\n+    protected void generateModels(List<File> files, List<Object> allModels, List<String> unusedModels) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzgyNQ=="}, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MDQ5ODI1OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/GoClientExperimentalCodegen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTo0Njo0NFrOGHsA5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTo0Njo0NFrOGHsA5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxNDM0MQ==", "bodyText": "This isn't an appropriate place for this option. If someone were to extend this generator and modify the value (maybe they don't support this explicitly mapping in their templates), you're potentially overwriting their value.\nPlease move this to the constructor here and elsewhere. This would also allow our tooling to understand the defaults for the generator. Putting a default here, it's not known until execution time (via a \"real\" generate). See hideGenerationTimestamp in this constructor.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410714341", "createdAt": "2020-04-18T15:46:44Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/GoClientExperimentalCodegen.java", "diffHunk": "@@ -77,6 +77,7 @@ public String getHelp() {\n \n     @Override\n     public void processOpts() {\n+        this.setDiscriminatorExplicitMappingVerbose(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MDQ5ODM2OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/PythonClientExperimentalCodegen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTo0NzowOFrOGHsA-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTo0NzowOFrOGHsA-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxNDM2Mw==", "bodyText": "Please move default option to constructor.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410714363", "createdAt": "2020-04-18T15:47:08Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/PythonClientExperimentalCodegen.java", "diffHunk": "@@ -111,6 +111,8 @@ public PythonClientExperimentalCodegen() {\n \n     @Override\n     public void processOpts() {\n+        this.setDiscriminatorExplicitMappingVerbose(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4059, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}