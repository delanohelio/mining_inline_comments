{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwMzM5Njkz", "number": 7250, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwNDoxNzowMVrOEbRv6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwNDoxNzowMVrOEbRv6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDM3ODAyOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/StringUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwNDoxNzowMVrOHFJ8iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwMTo0OTowNFrOHFSIyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE2Nzg4MA==", "bodyText": "I don't think we can do this. Word escaping is going to be very generator-specific, and this static cache will break functionality for any application where openapi-generator is \"long-lived\" (IDE plugins, our online generator, and other long-running services holding oag in memory).\nI think we need to improve our model and the logic around it instead.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7250#discussion_r475167880", "createdAt": "2020-08-23T04:17:01Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/StringUtils.java", "diffHunk": "@@ -31,7 +34,11 @@\n     private static Cache<Pair<String, Boolean>, String> camelizedWordsCache;\n \n     // A cache of underscored words, used to optimize the performance of the underscore() method.\n-    private static Cache<String, String> underscoreWords;\n+    private static Cache<String, String> underscoreWordsCache;\n+\n+    // A cache of escaped words, used to optimize the performance of the escape() method.\n+    private static Cache<EscapedNameOptions, String> escapedWordsCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9b47c18d211a2131d609277677d2a3aa136e66d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIyNjIzNA==", "bodyText": "thanks. What if the cache lifecycle is tied to the lifecycle of the generator, similar to the other caches? Would this work for the cases you mention?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7250#discussion_r475226234", "createdAt": "2020-08-23T14:29:08Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/StringUtils.java", "diffHunk": "@@ -31,7 +34,11 @@\n     private static Cache<Pair<String, Boolean>, String> camelizedWordsCache;\n \n     // A cache of underscored words, used to optimize the performance of the underscore() method.\n-    private static Cache<String, String> underscoreWords;\n+    private static Cache<String, String> underscoreWordsCache;\n+\n+    // A cache of escaped words, used to optimize the performance of the escape() method.\n+    private static Cache<EscapedNameOptions, String> escapedWordsCache;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE2Nzg4MA=="}, "originalCommit": {"oid": "d9b47c18d211a2131d609277677d2a3aa136e66d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMwMjA5MQ==", "bodyText": "I'm looking at the method again and I'm trying to think of scenarios where there would be conflicts across threads if all the parameters are the same, and I can't think of any. I think you're probably fine with your current implementation for memoizing the escape function. I thought I had noticed something when I commented yesterday that prevented this function from being pure, and I'm not seeing it today.\nBut because you asked about a tying to the generation, if we ever wanted to have per-run caching we could do something like the following (for something like a CodegenModel cache for $ref!):\nWe could create a context object with unique ID as a hash key (an entity in DDD-land), and use this as the Cache key or as a component of the type defining the cache key.\nFor instance:\nId\npackage org.openapitools.codegen.context;\n\nimport java.util.Objects;\nimport java.util.UUID;\n\npublic final class Id {\n    private final UUID value;\n\n    public Id() {\n        this.value = UUID.randomUUID();\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(getValue());\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Id id = (Id) o;\n        return getValue().equals(id.getValue());\n    }\n\n    public UUID getValue() {\n        return value;\n    }\n}\n\nInvocationContext\npackage org.openapitools.codegen.context;\n\nimport java.util.Objects;\nimport java.util.UUID;\n\npublic final class InvocationContext {\n    private final Id id;\n\n    public InvocationContext() {\n        this.id = new Id();\n    }\n\n    public UUID getIdentifier() {\n        return this.id.getValue();\n    }\n\n    @Override\n    public int hashCode() {\n        // InvocationContext is an entity and should only maintain id in hashcode.\n        return Objects.hash(id);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        InvocationContext that = (InvocationContext) o;\n\n        // InvocationContext is an entity and should only maintain id in equals.\n        return id.equals(that.id);\n    }\n}\n\nAnd then update GlobalSettings to provide this per-run specific identifiable object:\npublic class GlobalSettings {\n    private static ThreadLocal<InvocationContext> context = new InheritableThreadLocal<InvocationContext>() {\n        @Override\n        protected InvocationContext initialValue() {\n            return new InvocationContext();\n        }\n    };\n    private static ThreadLocal<Properties> properties = new InheritableThreadLocal<Properties>() {\n        @Override\n        protected Properties initialValue() {\n            return (Properties) System.getProperties().clone();\n        }\n    };\n\n    public static String getProperty(String key, String defaultValue) {\n        return properties.get().getProperty(key, defaultValue);\n    }\n\n    public static String getProperty(String key) {\n        return properties.get().getProperty(key);\n    }\n\n    public static void setProperty(String key, String value) {\n        properties.get().setProperty(key, value);\n    }\n\n    public static void clearProperty(String key) {\n        properties.get().remove(key);\n    }\n\n    public static InvocationContext getContext() {\n        return context.get();\n    }\n\n    public static void reset() {\n        properties.remove();\n        context.remove();\n    }\n}\n\nThen, you'd just need to work out how you'd want to work with this in your cache. For your escape function, for example, you could change EscapedNameOptions to accept a UUID which is added to equals and hashcode, and then construct it with the invocation context's identifier. So,\nEscapedNameOptions ns = new EscapedNameOptions(\n    GlobalSettings.getContext().getIdentifier(),\n    name, replacementMap.keySet(), charactersToAllow, appendToReplacement);\n\nin Thread1 would be different than the same in Thread2.\nI could see us using this for a really simple ref lookup like this as the key and CodegenModel as the value:\npackage org.openapitools.codegen.context;\n\nimport java.util.Objects;\nimport java.util.UUID;\n\npublic final class ContextualRef {\n    private final UUID invocationId;\n    private final String ref;\n\n    public ContextualRef(UUID invocationId, String ref) {\n        if (ref == null) throw new IllegalArgumentException(\"ref can't be null\");\n        this.invocationId = invocationId;\n        // normalize/validate ref?\n        this.ref = ref;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(invocationId, ref);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        ContextualRef that = (ContextualRef) o;\n        return invocationId.equals(that.invocationId) &&\n                ref.equals(that.ref);\n    }\n}", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7250#discussion_r475302091", "createdAt": "2020-08-24T01:49:04Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/StringUtils.java", "diffHunk": "@@ -31,7 +34,11 @@\n     private static Cache<Pair<String, Boolean>, String> camelizedWordsCache;\n \n     // A cache of underscored words, used to optimize the performance of the underscore() method.\n-    private static Cache<String, String> underscoreWords;\n+    private static Cache<String, String> underscoreWordsCache;\n+\n+    // A cache of escaped words, used to optimize the performance of the escape() method.\n+    private static Cache<EscapedNameOptions, String> escapedWordsCache;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE2Nzg4MA=="}, "originalCommit": {"oid": "d9b47c18d211a2131d609277677d2a3aa136e66d"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4199, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}