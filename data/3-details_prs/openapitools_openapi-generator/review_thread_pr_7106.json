{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYxNTA2NDQx", "number": 7106, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjo0MTowOFrOEUZfTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjo0MTowOFrOEUZfTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5ODI0NTkxOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNjo0MTowOFrOG6mTmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMzoyMDozN1rOG6oldg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5ODIwMg==", "bodyText": "So I have some questions about how our code works here. Can you help answer them?\n\nThis copies the property from the inline schema into the extracted schema that we put into openapi component schemas, right?\nSo it sets the discriminator on this schema:\n\n      - type: object\n        discriminator: party_type\n        required:\n          - party_type\n        properties:\n          party_type:\n            readOnly: true\n            $ref: '#/definitions/PartyType'\n          tax_id_number:\n            type: string\n\nWhich is extracted and used to create the schema with the key Party_allOf, correct?\n2. Is only one Party_allOf class made for each composed schema or is each inline schema extracted out into its own Party_allOf1, Party_allOf2 etc?\n3. How about adding a javadoc to this method so one can understand this by reading the doc in the future?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7106#discussion_r464098202", "createdAt": "2020-08-02T16:41:08Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java", "diffHunk": "@@ -627,6 +653,30 @@ private Schema modelFromProperty(OpenAPI openAPI, Schema object, String path) {\n         model.setXml(xml);\n         model.setRequired(object.getRequired());\n         model.setNullable(object.getNullable());\n+        model.setDiscriminator(object.getDiscriminator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3770a2b7b4d05ab454f82bb8112a4eea70697f37"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzNTU0Mg==", "bodyText": "Party_allOf will be created once, then any properties it references will be flattened. Later, we \"lookup\" the transient Party_allOf by serializing and deserializing the structure as the key of a map, and the value as a name. This is how we basically deduplicate those dynamic structures and associate them all with a generated name. See structureMapper in this PR which I've updated to have determinate property order. As it was, Jackson would probably serialize in the same way maybe 99% of the time, but without explicitly sorting it'll follow the same rules as JSON where map properties are technically unordered.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7106#discussion_r464135542", "createdAt": "2020-08-02T23:20:37Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java", "diffHunk": "@@ -627,6 +653,30 @@ private Schema modelFromProperty(OpenAPI openAPI, Schema object, String path) {\n         model.setXml(xml);\n         model.setRequired(object.getRequired());\n         model.setNullable(object.getNullable());\n+        model.setDiscriminator(object.getDiscriminator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5ODIwMg=="}, "originalCommit": {"oid": "3770a2b7b4d05ab454f82bb8112a4eea70697f37"}, "originalPosition": 71}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4252, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}