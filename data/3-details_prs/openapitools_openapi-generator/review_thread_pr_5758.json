{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1Njg5NDA4", "number": 5758, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNDo1MDoxMFrODusnQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo1MTo0NlrODus6mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjkyMDMyOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNDo1MDoxMFrOGAyYIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNDo1MDoxMFrOGAyYIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ3ODU2Mw==", "bodyText": "I'll rename it to \"scala-akka-http-server\" to follow our generator naming convention.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403478563", "createdAt": "2020-04-04T14:50:10Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjk2ODMzOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo0OTozMFrOGAywFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo0OTozMFrOGAywFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NDY5Mg==", "bodyText": "We've trying to normalize the naming of vendor extensions. I wonder if you can rename hasDefaultValue to x-has-default-value instead.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403484692", "createdAt": "2020-04-04T15:49:30Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";\n+    }\n+\n+    public String getHelp() {\n+        return \"Generates a scala-akka-http server.\";\n+    }\n+\n+    public ScalaAkkaHttpServerCodegen() {\n+        super();\n+\n+        modifyFeatureSet(features -> features\n+                .includeDocumentationFeatures(DocumentationFeature.Readme)\n+                .wireFormatFeatures(EnumSet.of(WireFormatFeature.JSON, WireFormatFeature.XML, WireFormatFeature.Custom))\n+                .securityFeatures(EnumSet.of(\n+                        SecurityFeature.BasicAuth,\n+                        SecurityFeature.ApiKey,\n+                        SecurityFeature.BearerToken\n+                ))\n+                .excludeGlobalFeatures(\n+                        GlobalFeature.XMLStructureDefinitions,\n+                        GlobalFeature.Callbacks,\n+                        GlobalFeature.LinkObjects,\n+                        GlobalFeature.ParameterStyling\n+                )\n+                .excludeSchemaSupportFeatures(\n+                        SchemaSupportFeature.Polymorphism\n+                )\n+                .excludeParameterFeatures(\n+                        ParameterFeature.Cookie\n+                )\n+        );\n+\n+        outputFolder = \"generated-code\" + File.separator + \"scala-akka-http\";\n+        modelTemplateFiles.put(\"model.mustache\", \".scala\");\n+        apiTemplateFiles.put(\"api.mustache\", \".scala\");\n+        embeddedTemplateDir = templateDir = \"scala-akka-http-server\";\n+\n+        groupId = \"org.openapitools\";\n+        artifactId = \"openapi-scala-akka-http-server\";\n+        artifactVersion = \"1.0.0\";\n+        apiPackage = \"org.openapitools.server.api\";\n+        modelPackage = \"org.openapitools.server.model\";\n+        invokerPackage = \"org.openapitools.server\";\n+        akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+\n+        setReservedWordsLowerCase(\n+                Arrays.asList(\n+                        \"abstract\", \"case\", \"catch\", \"class\", \"def\", \"do\", \"else\", \"extends\",\n+                        \"false\", \"final\", \"finally\", \"for\", \"forSome\", \"if\", \"implicit\",\n+                        \"import\", \"lazy\", \"match\", \"new\", \"null\", \"object\", \"override\", \"package\",\n+                        \"private\", \"protected\", \"return\", \"sealed\", \"super\", \"this\", \"throw\",\n+                        \"trait\", \"try\", \"true\", \"type\", \"val\", \"var\", \"while\", \"with\", \"yield\")\n+        );\n+\n+        cliOptions.add(CliOption.newString(CodegenConstants.INVOKER_PACKAGE, CodegenConstants.INVOKER_PACKAGE_DESC).defaultValue(invokerPackage));\n+        cliOptions.add(CliOption.newString(CodegenConstants.GROUP_ID, CodegenConstants.GROUP_ID_DESC).defaultValue(groupId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_ID, CodegenConstants.ARTIFACT_ID).defaultValue(artifactId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_VERSION, CodegenConstants.ARTIFACT_VERSION_DESC).defaultValue(artifactVersion));\n+        cliOptions.add(CliOption.newString(AKKA_HTTP_VERSION, AKKA_HTTP_VERSION_DESC).defaultValue(akkaHttpVersion));\n+\n+        importMapping.remove(\"Seq\");\n+        importMapping.remove(\"List\");\n+        importMapping.remove(\"Set\");\n+        importMapping.remove(\"Map\");\n+\n+        typeMapping = new HashMap<>();\n+        typeMapping.put(\"array\", \"Seq\");\n+        typeMapping.put(\"set\", \"Set\");\n+        typeMapping.put(\"boolean\", \"Boolean\");\n+        typeMapping.put(\"string\", \"String\");\n+        typeMapping.put(\"int\", \"Int\");\n+        typeMapping.put(\"integer\", \"Int\");\n+        typeMapping.put(\"long\", \"Long\");\n+        typeMapping.put(\"float\", \"Float\");\n+        typeMapping.put(\"byte\", \"Byte\");\n+        typeMapping.put(\"short\", \"Short\");\n+        typeMapping.put(\"char\", \"Char\");\n+        typeMapping.put(\"double\", \"Double\");\n+        typeMapping.put(\"object\", \"Any\");\n+        typeMapping.put(\"file\", \"File\");\n+        typeMapping.put(\"binary\", \"File\");\n+        typeMapping.put(\"number\", \"Double\");\n+\n+        instantiationTypes.put(\"array\", \"ListBuffer\");\n+        instantiationTypes.put(\"map\", \"Map\");\n+\n+        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n+    }\n+\n+    @Override\n+    public void processOpts() {\n+        super.processOpts();\n+\n+        if (additionalProperties.containsKey(CodegenConstants.INVOKER_PACKAGE)) {\n+            invokerPackage = (String) additionalProperties.get(CodegenConstants.INVOKER_PACKAGE);\n+        } else {\n+            additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.GROUP_ID)) {\n+            groupId = (String) additionalProperties.get(CodegenConstants.GROUP_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.GROUP_ID, groupId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_ID)) {\n+            artifactId = (String) additionalProperties.get(CodegenConstants.ARTIFACT_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_ID, artifactId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_VERSION)) {\n+            artifactVersion = (String) additionalProperties.get(CodegenConstants.ARTIFACT_VERSION);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_VERSION, artifactVersion);\n+        }\n+\n+        if (additionalProperties.containsKey(AKKA_HTTP_VERSION)) {\n+            akkaHttpVersion = (String) additionalProperties.get(AKKA_HTTP_VERSION);\n+        } else {\n+            additionalProperties.put(AKKA_HTTP_VERSION, akkaHttpVersion);\n+        }\n+\n+        parseAkkaHttpVersion();\n+\n+        supportingFiles.add(new SupportingFile(\"build.sbt.mustache\", \"\", \"build.sbt\"));\n+        supportingFiles.add(new SupportingFile(\"controller.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"Controller.scala\"));\n+        supportingFiles.add(new SupportingFile(\"helper.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"AkkaHttpHelper.scala\"));\n+        supportingFiles.add(new SupportingFile(\"stringDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"StringDirectives.scala\"));\n+        supportingFiles.add(new SupportingFile(\"multipartDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"MultipartDirectives.scala\"));\n+    }\n+\n+    private static final String IS_10_1_10_PLUS = \"akkaHttp10_1_10_plus\";\n+    private boolean is10_1_10AndAbove = false;\n+\n+    private static final Pattern akkaVersionPattern = Pattern.compile(\"([0-9]+)(\\\\.([0-9]+))?(\\\\.([0-9]+))?(.\\\\+)?\");\n+    private void parseAkkaHttpVersion() {\n+        Matcher matcher = akkaVersionPattern.matcher(akkaHttpVersion);\n+        if (matcher.matches()) {\n+            String majorS = matcher.group(1);\n+            String minorS = matcher.group(3);\n+            String patchS = matcher.group(5);\n+            boolean andAbove = matcher.group(6) != null;\n+            int major = -1, minor = -1, patch = -1;\n+            try {\n+                if (majorS != null) {\n+                    major = Integer.parseInt(majorS);\n+                    if (minorS != null) {\n+                        minor = Integer.parseInt(minorS);\n+                        if (patchS != null) {\n+                            patch = Integer.parseInt(patchS);\n+                        }\n+                    }\n+                }\n+\n+\n+                if (major > 10 || major == -1 && andAbove) {\n+                    is10_1_10AndAbove = true;\n+                } else if (major == 10) {\n+                    if (minor > 1 || minor == -1 && andAbove) {\n+                        is10_1_10AndAbove = true;\n+                    } else if (minor == 1) {\n+                        if (patch >= 10 || patch == -1 && andAbove) {\n+                            is10_1_10AndAbove = true;\n+                        }\n+                    }\n+                }\n+\n+            } catch (NumberFormatException e) {\n+                LOGGER.warn(\"Unable to parse \" + AKKA_HTTP_VERSION + \": \" + akkaHttpVersion + \", fallback to \" + DEFAULT_AKKA_HTTP_VERSION);\n+                akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+                is10_1_10AndAbove = true;\n+            }\n+        }\n+\n+        additionalProperties.put(IS_10_1_10_PLUS, is10_1_10AndAbove);\n+    }\n+\n+    @Override\n+    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, List<Server> servers) {\n+        CodegenOperation codegenOperation = super.fromOperation(path, httpMethod, operation, servers);\n+        addPathMatcher(codegenOperation);\n+        return codegenOperation;\n+    }\n+\n+    @Override\n+    public CodegenParameter fromParameter(Parameter parameter, Set<String> imports) {\n+        CodegenParameter param = super.fromParameter(parameter, imports);\n+        // Removing unhandled types\n+        if(!primitiveParamTypes.contains(param.dataType)) {\n+            param.dataType = \"String\";\n+        }\n+        if (!param.required) {\n+            param.vendorExtensions.put(\"hasDefaultValue\", param.defaultValue != null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjk2ODcwOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo0OTo1N1rOGAywQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo0OTo1N1rOGAywQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NDczNw==", "bodyText": "We've trying to normalize the naming of vendor extensions. I wonder if you can rename paths to x-paths instead.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403484737", "createdAt": "2020-04-04T15:49:57Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";\n+    }\n+\n+    public String getHelp() {\n+        return \"Generates a scala-akka-http server.\";\n+    }\n+\n+    public ScalaAkkaHttpServerCodegen() {\n+        super();\n+\n+        modifyFeatureSet(features -> features\n+                .includeDocumentationFeatures(DocumentationFeature.Readme)\n+                .wireFormatFeatures(EnumSet.of(WireFormatFeature.JSON, WireFormatFeature.XML, WireFormatFeature.Custom))\n+                .securityFeatures(EnumSet.of(\n+                        SecurityFeature.BasicAuth,\n+                        SecurityFeature.ApiKey,\n+                        SecurityFeature.BearerToken\n+                ))\n+                .excludeGlobalFeatures(\n+                        GlobalFeature.XMLStructureDefinitions,\n+                        GlobalFeature.Callbacks,\n+                        GlobalFeature.LinkObjects,\n+                        GlobalFeature.ParameterStyling\n+                )\n+                .excludeSchemaSupportFeatures(\n+                        SchemaSupportFeature.Polymorphism\n+                )\n+                .excludeParameterFeatures(\n+                        ParameterFeature.Cookie\n+                )\n+        );\n+\n+        outputFolder = \"generated-code\" + File.separator + \"scala-akka-http\";\n+        modelTemplateFiles.put(\"model.mustache\", \".scala\");\n+        apiTemplateFiles.put(\"api.mustache\", \".scala\");\n+        embeddedTemplateDir = templateDir = \"scala-akka-http-server\";\n+\n+        groupId = \"org.openapitools\";\n+        artifactId = \"openapi-scala-akka-http-server\";\n+        artifactVersion = \"1.0.0\";\n+        apiPackage = \"org.openapitools.server.api\";\n+        modelPackage = \"org.openapitools.server.model\";\n+        invokerPackage = \"org.openapitools.server\";\n+        akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+\n+        setReservedWordsLowerCase(\n+                Arrays.asList(\n+                        \"abstract\", \"case\", \"catch\", \"class\", \"def\", \"do\", \"else\", \"extends\",\n+                        \"false\", \"final\", \"finally\", \"for\", \"forSome\", \"if\", \"implicit\",\n+                        \"import\", \"lazy\", \"match\", \"new\", \"null\", \"object\", \"override\", \"package\",\n+                        \"private\", \"protected\", \"return\", \"sealed\", \"super\", \"this\", \"throw\",\n+                        \"trait\", \"try\", \"true\", \"type\", \"val\", \"var\", \"while\", \"with\", \"yield\")\n+        );\n+\n+        cliOptions.add(CliOption.newString(CodegenConstants.INVOKER_PACKAGE, CodegenConstants.INVOKER_PACKAGE_DESC).defaultValue(invokerPackage));\n+        cliOptions.add(CliOption.newString(CodegenConstants.GROUP_ID, CodegenConstants.GROUP_ID_DESC).defaultValue(groupId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_ID, CodegenConstants.ARTIFACT_ID).defaultValue(artifactId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_VERSION, CodegenConstants.ARTIFACT_VERSION_DESC).defaultValue(artifactVersion));\n+        cliOptions.add(CliOption.newString(AKKA_HTTP_VERSION, AKKA_HTTP_VERSION_DESC).defaultValue(akkaHttpVersion));\n+\n+        importMapping.remove(\"Seq\");\n+        importMapping.remove(\"List\");\n+        importMapping.remove(\"Set\");\n+        importMapping.remove(\"Map\");\n+\n+        typeMapping = new HashMap<>();\n+        typeMapping.put(\"array\", \"Seq\");\n+        typeMapping.put(\"set\", \"Set\");\n+        typeMapping.put(\"boolean\", \"Boolean\");\n+        typeMapping.put(\"string\", \"String\");\n+        typeMapping.put(\"int\", \"Int\");\n+        typeMapping.put(\"integer\", \"Int\");\n+        typeMapping.put(\"long\", \"Long\");\n+        typeMapping.put(\"float\", \"Float\");\n+        typeMapping.put(\"byte\", \"Byte\");\n+        typeMapping.put(\"short\", \"Short\");\n+        typeMapping.put(\"char\", \"Char\");\n+        typeMapping.put(\"double\", \"Double\");\n+        typeMapping.put(\"object\", \"Any\");\n+        typeMapping.put(\"file\", \"File\");\n+        typeMapping.put(\"binary\", \"File\");\n+        typeMapping.put(\"number\", \"Double\");\n+\n+        instantiationTypes.put(\"array\", \"ListBuffer\");\n+        instantiationTypes.put(\"map\", \"Map\");\n+\n+        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n+    }\n+\n+    @Override\n+    public void processOpts() {\n+        super.processOpts();\n+\n+        if (additionalProperties.containsKey(CodegenConstants.INVOKER_PACKAGE)) {\n+            invokerPackage = (String) additionalProperties.get(CodegenConstants.INVOKER_PACKAGE);\n+        } else {\n+            additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.GROUP_ID)) {\n+            groupId = (String) additionalProperties.get(CodegenConstants.GROUP_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.GROUP_ID, groupId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_ID)) {\n+            artifactId = (String) additionalProperties.get(CodegenConstants.ARTIFACT_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_ID, artifactId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_VERSION)) {\n+            artifactVersion = (String) additionalProperties.get(CodegenConstants.ARTIFACT_VERSION);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_VERSION, artifactVersion);\n+        }\n+\n+        if (additionalProperties.containsKey(AKKA_HTTP_VERSION)) {\n+            akkaHttpVersion = (String) additionalProperties.get(AKKA_HTTP_VERSION);\n+        } else {\n+            additionalProperties.put(AKKA_HTTP_VERSION, akkaHttpVersion);\n+        }\n+\n+        parseAkkaHttpVersion();\n+\n+        supportingFiles.add(new SupportingFile(\"build.sbt.mustache\", \"\", \"build.sbt\"));\n+        supportingFiles.add(new SupportingFile(\"controller.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"Controller.scala\"));\n+        supportingFiles.add(new SupportingFile(\"helper.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"AkkaHttpHelper.scala\"));\n+        supportingFiles.add(new SupportingFile(\"stringDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"StringDirectives.scala\"));\n+        supportingFiles.add(new SupportingFile(\"multipartDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"MultipartDirectives.scala\"));\n+    }\n+\n+    private static final String IS_10_1_10_PLUS = \"akkaHttp10_1_10_plus\";\n+    private boolean is10_1_10AndAbove = false;\n+\n+    private static final Pattern akkaVersionPattern = Pattern.compile(\"([0-9]+)(\\\\.([0-9]+))?(\\\\.([0-9]+))?(.\\\\+)?\");\n+    private void parseAkkaHttpVersion() {\n+        Matcher matcher = akkaVersionPattern.matcher(akkaHttpVersion);\n+        if (matcher.matches()) {\n+            String majorS = matcher.group(1);\n+            String minorS = matcher.group(3);\n+            String patchS = matcher.group(5);\n+            boolean andAbove = matcher.group(6) != null;\n+            int major = -1, minor = -1, patch = -1;\n+            try {\n+                if (majorS != null) {\n+                    major = Integer.parseInt(majorS);\n+                    if (minorS != null) {\n+                        minor = Integer.parseInt(minorS);\n+                        if (patchS != null) {\n+                            patch = Integer.parseInt(patchS);\n+                        }\n+                    }\n+                }\n+\n+\n+                if (major > 10 || major == -1 && andAbove) {\n+                    is10_1_10AndAbove = true;\n+                } else if (major == 10) {\n+                    if (minor > 1 || minor == -1 && andAbove) {\n+                        is10_1_10AndAbove = true;\n+                    } else if (minor == 1) {\n+                        if (patch >= 10 || patch == -1 && andAbove) {\n+                            is10_1_10AndAbove = true;\n+                        }\n+                    }\n+                }\n+\n+            } catch (NumberFormatException e) {\n+                LOGGER.warn(\"Unable to parse \" + AKKA_HTTP_VERSION + \": \" + akkaHttpVersion + \", fallback to \" + DEFAULT_AKKA_HTTP_VERSION);\n+                akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+                is10_1_10AndAbove = true;\n+            }\n+        }\n+\n+        additionalProperties.put(IS_10_1_10_PLUS, is10_1_10AndAbove);\n+    }\n+\n+    @Override\n+    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, List<Server> servers) {\n+        CodegenOperation codegenOperation = super.fromOperation(path, httpMethod, operation, servers);\n+        addPathMatcher(codegenOperation);\n+        return codegenOperation;\n+    }\n+\n+    @Override\n+    public CodegenParameter fromParameter(Parameter parameter, Set<String> imports) {\n+        CodegenParameter param = super.fromParameter(parameter, imports);\n+        // Removing unhandled types\n+        if(!primitiveParamTypes.contains(param.dataType)) {\n+            param.dataType = \"String\";\n+        }\n+        if (!param.required) {\n+            param.vendorExtensions.put(\"hasDefaultValue\", param.defaultValue != null);\n+            // Escaping default string values\n+            if (param.defaultValue != null && param.dataType.equals(\"String\")) {\n+                param.defaultValue = String.format(Locale.ROOT, \"\\\"%s\\\"\", param.defaultValue);\n+            }\n+        }\n+        return param;\n+    }\n+\n+\n+\n+    @Override\n+    public Map<String, Object> postProcessOperationsWithModels(Map<String, Object> objs, List<Object> allModels) {\n+        Map<String, Object> baseObjs = super.postProcessOperationsWithModels(objs, allModels);\n+        pathMatcherPatternsPostProcessor(baseObjs);\n+        marshallingPostProcessor(baseObjs);\n+        return baseObjs;\n+    }\n+\n+    private static Set<String> primitiveParamTypes = new HashSet<String>(){{\n+        addAll(Arrays.asList(\n+                \"Int\",\n+                \"Long\",\n+                \"Float\",\n+                \"Double\",\n+                \"Boolean\",\n+                \"String\"\n+        ));\n+    }};\n+\n+    private static Map<String, String> pathTypeToMatcher = new HashMap<String, String>(){{\n+        put(\"Int\", \"IntNumber\");\n+        put(\"Long\", \"LongNumber\");\n+        put(\"Float\",\"FloatNumber\");\n+        put(\"Double\",\"DoubleNumber\");\n+        put(\"Boolean\",\"Boolean\");\n+        put(\"String\", \"Segment\");\n+    }};\n+\n+    protected static void addPathMatcher(CodegenOperation codegenOperation) {\n+        LinkedList<String> allPaths = new LinkedList<>(Arrays.asList(codegenOperation.path.split(\"/\")));\n+        allPaths.removeIf(\"\"::equals);\n+\n+        LinkedList<TextOrMatcher> pathMatchers = new LinkedList<>();\n+        for(String path: allPaths){\n+            TextOrMatcher textOrMatcher = new TextOrMatcher(\"\", true, true);\n+            if(path.startsWith(\"{\") && path.endsWith(\"}\")) {\n+                String parameterName = path.substring(1, path.length()-1);\n+                for(CodegenParameter pathParam: codegenOperation.pathParams){\n+                    if(pathParam.baseName.equals(parameterName)) {\n+                        String matcher = pathTypeToMatcher.get(pathParam.dataType);\n+                        if(matcher == null) {\n+                            LOGGER.warn(\"The path parameter \" + pathParam.baseName +\n+                                    \" with the datatype \" + pathParam.dataType +\n+                                    \" could not be translated to a corresponding path matcher of akka http\" +\n+                                    \" and therefore has been translated to string.\");\n+                            matcher = pathTypeToMatcher.get(\"String\");\n+                        }\n+                        if (pathParam.pattern != null && !pathParam.pattern.isEmpty()) {\n+                            matcher = pathMatcherPatternName(pathParam);\n+                        }\n+                        textOrMatcher.value = matcher;\n+                        textOrMatcher.isText = false;\n+                        pathMatchers.add(textOrMatcher);\n+                    }\n+                }\n+            } else {\n+                textOrMatcher.value = path;\n+                textOrMatcher.isText = true;\n+                pathMatchers.add(textOrMatcher);\n+            }\n+        }\n+        pathMatchers.getLast().hasMore = false;\n+\n+        codegenOperation.vendorExtensions.put(\"paths\", pathMatchers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjk2ODg4OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo1MDoyMlrOGAywWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo1MDoyMlrOGAywWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NDc2MQ==", "bodyText": "We've trying to normalize the naming of vendor extensions. I wonder if you can rename x-isDefault to x-is-default instead.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403484761", "createdAt": "2020-04-04T15:50:22Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";\n+    }\n+\n+    public String getHelp() {\n+        return \"Generates a scala-akka-http server.\";\n+    }\n+\n+    public ScalaAkkaHttpServerCodegen() {\n+        super();\n+\n+        modifyFeatureSet(features -> features\n+                .includeDocumentationFeatures(DocumentationFeature.Readme)\n+                .wireFormatFeatures(EnumSet.of(WireFormatFeature.JSON, WireFormatFeature.XML, WireFormatFeature.Custom))\n+                .securityFeatures(EnumSet.of(\n+                        SecurityFeature.BasicAuth,\n+                        SecurityFeature.ApiKey,\n+                        SecurityFeature.BearerToken\n+                ))\n+                .excludeGlobalFeatures(\n+                        GlobalFeature.XMLStructureDefinitions,\n+                        GlobalFeature.Callbacks,\n+                        GlobalFeature.LinkObjects,\n+                        GlobalFeature.ParameterStyling\n+                )\n+                .excludeSchemaSupportFeatures(\n+                        SchemaSupportFeature.Polymorphism\n+                )\n+                .excludeParameterFeatures(\n+                        ParameterFeature.Cookie\n+                )\n+        );\n+\n+        outputFolder = \"generated-code\" + File.separator + \"scala-akka-http\";\n+        modelTemplateFiles.put(\"model.mustache\", \".scala\");\n+        apiTemplateFiles.put(\"api.mustache\", \".scala\");\n+        embeddedTemplateDir = templateDir = \"scala-akka-http-server\";\n+\n+        groupId = \"org.openapitools\";\n+        artifactId = \"openapi-scala-akka-http-server\";\n+        artifactVersion = \"1.0.0\";\n+        apiPackage = \"org.openapitools.server.api\";\n+        modelPackage = \"org.openapitools.server.model\";\n+        invokerPackage = \"org.openapitools.server\";\n+        akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+\n+        setReservedWordsLowerCase(\n+                Arrays.asList(\n+                        \"abstract\", \"case\", \"catch\", \"class\", \"def\", \"do\", \"else\", \"extends\",\n+                        \"false\", \"final\", \"finally\", \"for\", \"forSome\", \"if\", \"implicit\",\n+                        \"import\", \"lazy\", \"match\", \"new\", \"null\", \"object\", \"override\", \"package\",\n+                        \"private\", \"protected\", \"return\", \"sealed\", \"super\", \"this\", \"throw\",\n+                        \"trait\", \"try\", \"true\", \"type\", \"val\", \"var\", \"while\", \"with\", \"yield\")\n+        );\n+\n+        cliOptions.add(CliOption.newString(CodegenConstants.INVOKER_PACKAGE, CodegenConstants.INVOKER_PACKAGE_DESC).defaultValue(invokerPackage));\n+        cliOptions.add(CliOption.newString(CodegenConstants.GROUP_ID, CodegenConstants.GROUP_ID_DESC).defaultValue(groupId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_ID, CodegenConstants.ARTIFACT_ID).defaultValue(artifactId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_VERSION, CodegenConstants.ARTIFACT_VERSION_DESC).defaultValue(artifactVersion));\n+        cliOptions.add(CliOption.newString(AKKA_HTTP_VERSION, AKKA_HTTP_VERSION_DESC).defaultValue(akkaHttpVersion));\n+\n+        importMapping.remove(\"Seq\");\n+        importMapping.remove(\"List\");\n+        importMapping.remove(\"Set\");\n+        importMapping.remove(\"Map\");\n+\n+        typeMapping = new HashMap<>();\n+        typeMapping.put(\"array\", \"Seq\");\n+        typeMapping.put(\"set\", \"Set\");\n+        typeMapping.put(\"boolean\", \"Boolean\");\n+        typeMapping.put(\"string\", \"String\");\n+        typeMapping.put(\"int\", \"Int\");\n+        typeMapping.put(\"integer\", \"Int\");\n+        typeMapping.put(\"long\", \"Long\");\n+        typeMapping.put(\"float\", \"Float\");\n+        typeMapping.put(\"byte\", \"Byte\");\n+        typeMapping.put(\"short\", \"Short\");\n+        typeMapping.put(\"char\", \"Char\");\n+        typeMapping.put(\"double\", \"Double\");\n+        typeMapping.put(\"object\", \"Any\");\n+        typeMapping.put(\"file\", \"File\");\n+        typeMapping.put(\"binary\", \"File\");\n+        typeMapping.put(\"number\", \"Double\");\n+\n+        instantiationTypes.put(\"array\", \"ListBuffer\");\n+        instantiationTypes.put(\"map\", \"Map\");\n+\n+        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n+    }\n+\n+    @Override\n+    public void processOpts() {\n+        super.processOpts();\n+\n+        if (additionalProperties.containsKey(CodegenConstants.INVOKER_PACKAGE)) {\n+            invokerPackage = (String) additionalProperties.get(CodegenConstants.INVOKER_PACKAGE);\n+        } else {\n+            additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.GROUP_ID)) {\n+            groupId = (String) additionalProperties.get(CodegenConstants.GROUP_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.GROUP_ID, groupId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_ID)) {\n+            artifactId = (String) additionalProperties.get(CodegenConstants.ARTIFACT_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_ID, artifactId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_VERSION)) {\n+            artifactVersion = (String) additionalProperties.get(CodegenConstants.ARTIFACT_VERSION);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_VERSION, artifactVersion);\n+        }\n+\n+        if (additionalProperties.containsKey(AKKA_HTTP_VERSION)) {\n+            akkaHttpVersion = (String) additionalProperties.get(AKKA_HTTP_VERSION);\n+        } else {\n+            additionalProperties.put(AKKA_HTTP_VERSION, akkaHttpVersion);\n+        }\n+\n+        parseAkkaHttpVersion();\n+\n+        supportingFiles.add(new SupportingFile(\"build.sbt.mustache\", \"\", \"build.sbt\"));\n+        supportingFiles.add(new SupportingFile(\"controller.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"Controller.scala\"));\n+        supportingFiles.add(new SupportingFile(\"helper.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"AkkaHttpHelper.scala\"));\n+        supportingFiles.add(new SupportingFile(\"stringDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"StringDirectives.scala\"));\n+        supportingFiles.add(new SupportingFile(\"multipartDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"MultipartDirectives.scala\"));\n+    }\n+\n+    private static final String IS_10_1_10_PLUS = \"akkaHttp10_1_10_plus\";\n+    private boolean is10_1_10AndAbove = false;\n+\n+    private static final Pattern akkaVersionPattern = Pattern.compile(\"([0-9]+)(\\\\.([0-9]+))?(\\\\.([0-9]+))?(.\\\\+)?\");\n+    private void parseAkkaHttpVersion() {\n+        Matcher matcher = akkaVersionPattern.matcher(akkaHttpVersion);\n+        if (matcher.matches()) {\n+            String majorS = matcher.group(1);\n+            String minorS = matcher.group(3);\n+            String patchS = matcher.group(5);\n+            boolean andAbove = matcher.group(6) != null;\n+            int major = -1, minor = -1, patch = -1;\n+            try {\n+                if (majorS != null) {\n+                    major = Integer.parseInt(majorS);\n+                    if (minorS != null) {\n+                        minor = Integer.parseInt(minorS);\n+                        if (patchS != null) {\n+                            patch = Integer.parseInt(patchS);\n+                        }\n+                    }\n+                }\n+\n+\n+                if (major > 10 || major == -1 && andAbove) {\n+                    is10_1_10AndAbove = true;\n+                } else if (major == 10) {\n+                    if (minor > 1 || minor == -1 && andAbove) {\n+                        is10_1_10AndAbove = true;\n+                    } else if (minor == 1) {\n+                        if (patch >= 10 || patch == -1 && andAbove) {\n+                            is10_1_10AndAbove = true;\n+                        }\n+                    }\n+                }\n+\n+            } catch (NumberFormatException e) {\n+                LOGGER.warn(\"Unable to parse \" + AKKA_HTTP_VERSION + \": \" + akkaHttpVersion + \", fallback to \" + DEFAULT_AKKA_HTTP_VERSION);\n+                akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+                is10_1_10AndAbove = true;\n+            }\n+        }\n+\n+        additionalProperties.put(IS_10_1_10_PLUS, is10_1_10AndAbove);\n+    }\n+\n+    @Override\n+    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, List<Server> servers) {\n+        CodegenOperation codegenOperation = super.fromOperation(path, httpMethod, operation, servers);\n+        addPathMatcher(codegenOperation);\n+        return codegenOperation;\n+    }\n+\n+    @Override\n+    public CodegenParameter fromParameter(Parameter parameter, Set<String> imports) {\n+        CodegenParameter param = super.fromParameter(parameter, imports);\n+        // Removing unhandled types\n+        if(!primitiveParamTypes.contains(param.dataType)) {\n+            param.dataType = \"String\";\n+        }\n+        if (!param.required) {\n+            param.vendorExtensions.put(\"hasDefaultValue\", param.defaultValue != null);\n+            // Escaping default string values\n+            if (param.defaultValue != null && param.dataType.equals(\"String\")) {\n+                param.defaultValue = String.format(Locale.ROOT, \"\\\"%s\\\"\", param.defaultValue);\n+            }\n+        }\n+        return param;\n+    }\n+\n+\n+\n+    @Override\n+    public Map<String, Object> postProcessOperationsWithModels(Map<String, Object> objs, List<Object> allModels) {\n+        Map<String, Object> baseObjs = super.postProcessOperationsWithModels(objs, allModels);\n+        pathMatcherPatternsPostProcessor(baseObjs);\n+        marshallingPostProcessor(baseObjs);\n+        return baseObjs;\n+    }\n+\n+    private static Set<String> primitiveParamTypes = new HashSet<String>(){{\n+        addAll(Arrays.asList(\n+                \"Int\",\n+                \"Long\",\n+                \"Float\",\n+                \"Double\",\n+                \"Boolean\",\n+                \"String\"\n+        ));\n+    }};\n+\n+    private static Map<String, String> pathTypeToMatcher = new HashMap<String, String>(){{\n+        put(\"Int\", \"IntNumber\");\n+        put(\"Long\", \"LongNumber\");\n+        put(\"Float\",\"FloatNumber\");\n+        put(\"Double\",\"DoubleNumber\");\n+        put(\"Boolean\",\"Boolean\");\n+        put(\"String\", \"Segment\");\n+    }};\n+\n+    protected static void addPathMatcher(CodegenOperation codegenOperation) {\n+        LinkedList<String> allPaths = new LinkedList<>(Arrays.asList(codegenOperation.path.split(\"/\")));\n+        allPaths.removeIf(\"\"::equals);\n+\n+        LinkedList<TextOrMatcher> pathMatchers = new LinkedList<>();\n+        for(String path: allPaths){\n+            TextOrMatcher textOrMatcher = new TextOrMatcher(\"\", true, true);\n+            if(path.startsWith(\"{\") && path.endsWith(\"}\")) {\n+                String parameterName = path.substring(1, path.length()-1);\n+                for(CodegenParameter pathParam: codegenOperation.pathParams){\n+                    if(pathParam.baseName.equals(parameterName)) {\n+                        String matcher = pathTypeToMatcher.get(pathParam.dataType);\n+                        if(matcher == null) {\n+                            LOGGER.warn(\"The path parameter \" + pathParam.baseName +\n+                                    \" with the datatype \" + pathParam.dataType +\n+                                    \" could not be translated to a corresponding path matcher of akka http\" +\n+                                    \" and therefore has been translated to string.\");\n+                            matcher = pathTypeToMatcher.get(\"String\");\n+                        }\n+                        if (pathParam.pattern != null && !pathParam.pattern.isEmpty()) {\n+                            matcher = pathMatcherPatternName(pathParam);\n+                        }\n+                        textOrMatcher.value = matcher;\n+                        textOrMatcher.isText = false;\n+                        pathMatchers.add(textOrMatcher);\n+                    }\n+                }\n+            } else {\n+                textOrMatcher.value = path;\n+                textOrMatcher.isText = true;\n+                pathMatchers.add(textOrMatcher);\n+            }\n+        }\n+        pathMatchers.getLast().hasMore = false;\n+\n+        codegenOperation.vendorExtensions.put(\"paths\", pathMatchers);\n+    }\n+\n+    public static String PATH_MATCHER_PATTERNS_KEY = \"pathMatcherPatterns\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void pathMatcherPatternsPostProcessor(Map<String, Object> objs) {\n+        if (objs != null) {\n+            HashMap<String, PathMatcherPattern> patternMap = new HashMap<>();\n+            Map<String, Object> operations = (Map<String, Object>) objs.get(\"operations\");\n+            if (operations != null) {\n+                List<CodegenOperation> ops = (List<CodegenOperation>) operations.get(\"operation\");\n+                for (CodegenOperation operation: ops) {\n+                    for (CodegenParameter parameter: operation.pathParams) {\n+                        if (parameter.pattern != null && !parameter.pattern.isEmpty()) {\n+                            String name = pathMatcherPatternName(parameter);\n+                            if (!patternMap.containsKey(name)) {\n+                                patternMap.put(name, new PathMatcherPattern(name, parameter.pattern.substring(1, parameter.pattern.length() - 1)));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            objs.put(PATH_MATCHER_PATTERNS_KEY, new ArrayList<>(patternMap.values()));\n+        }\n+    }\n+\n+    private static String pathMatcherPatternName(CodegenParameter parameter) {\n+        return parameter.paramName + \"Pattern\";\n+    }\n+\n+    // Responsible for setting up Marshallers/Unmarshallers\n+    @SuppressWarnings(\"unchecked\")\n+    public static void marshallingPostProcessor(Map<String, Object> objs) {\n+\n+        if (objs == null) {\n+            return;\n+        }\n+\n+        Set<Marshaller> entityUnmarshallerTypes = new HashSet<>();\n+        Set<Marshaller> entityMarshallerTypes = new HashSet<>();\n+        Set<Marshaller> stringUnmarshallerTypes = new HashSet<>();\n+        boolean hasCookieParams = false;\n+        boolean hasMultipart = false;\n+\n+        Map<String, Object> operations = (Map<String, Object>) objs.get(\"operations\");\n+        if (operations != null) {\n+            List<CodegenOperation> operationList = (List<CodegenOperation>) operations.get(\"operation\");\n+\n+            for (CodegenOperation op : operationList) {\n+                boolean isMultipart = op.isMultipart;\n+                hasMultipart |= isMultipart;\n+                hasCookieParams |= op.getHasCookieParams();\n+                ArrayList<CodegenParameter> fileParams = new ArrayList<>();\n+                ArrayList<CodegenParameter> nonFileParams = new ArrayList<>();\n+                for (CodegenParameter parameter : op.allParams) {\n+                    if (parameter.isBodyParam || parameter.isFormParam) {\n+                        if (parameter.isFile) {\n+                            fileParams.add(parameter.copy());\n+                        } else {\n+                            nonFileParams.add(parameter.copy());\n+                        }\n+                        if (!parameter.isPrimitiveType) {\n+                            if (isMultipart) {\n+                                stringUnmarshallerTypes.add(new Marshaller(parameter));\n+                            } else {\n+                                entityUnmarshallerTypes.add(new Marshaller(parameter));\n+                            }\n+                        }\n+                    }\n+                }\n+                for (int i = 0, size = fileParams.size(); i < size; ++i) {\n+                    fileParams.get(i).hasMore = i < size - 1;\n+                }\n+                for (int i = 0, size = nonFileParams.size(); i < size; ++i) {\n+                    nonFileParams.get(i).hasMore = i < size - 1;\n+                }\n+\n+                HashSet<Marshaller> operationSpecificMarshallers = new HashSet<>();\n+                for (CodegenResponse response : op.responses) {\n+                    if (!response.primitiveType) {\n+                        Marshaller marshaller = new Marshaller(response);\n+                        entityMarshallerTypes.add(marshaller);\n+                        operationSpecificMarshallers.add(marshaller);\n+                    }\n+                    response.vendorExtensions.put(\"isDefault\", response.code.equals(\"0\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "originalPosition": 392}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjk2OTg1OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo1MTo0NlrOGAyw2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNTo1MTo0NlrOGAyw2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NDg4OQ==", "bodyText": "We're trying to normalize the naming of vendor extensions. I wonder if you can rename the extensions as followings:\n\nspecificMarshallers  to x-specific-marshallers \nfileParams to x-file-params\nnonFileParams to x-non-file-params", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403484889", "createdAt": "2020-04-04T15:51:46Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";\n+    }\n+\n+    public String getHelp() {\n+        return \"Generates a scala-akka-http server.\";\n+    }\n+\n+    public ScalaAkkaHttpServerCodegen() {\n+        super();\n+\n+        modifyFeatureSet(features -> features\n+                .includeDocumentationFeatures(DocumentationFeature.Readme)\n+                .wireFormatFeatures(EnumSet.of(WireFormatFeature.JSON, WireFormatFeature.XML, WireFormatFeature.Custom))\n+                .securityFeatures(EnumSet.of(\n+                        SecurityFeature.BasicAuth,\n+                        SecurityFeature.ApiKey,\n+                        SecurityFeature.BearerToken\n+                ))\n+                .excludeGlobalFeatures(\n+                        GlobalFeature.XMLStructureDefinitions,\n+                        GlobalFeature.Callbacks,\n+                        GlobalFeature.LinkObjects,\n+                        GlobalFeature.ParameterStyling\n+                )\n+                .excludeSchemaSupportFeatures(\n+                        SchemaSupportFeature.Polymorphism\n+                )\n+                .excludeParameterFeatures(\n+                        ParameterFeature.Cookie\n+                )\n+        );\n+\n+        outputFolder = \"generated-code\" + File.separator + \"scala-akka-http\";\n+        modelTemplateFiles.put(\"model.mustache\", \".scala\");\n+        apiTemplateFiles.put(\"api.mustache\", \".scala\");\n+        embeddedTemplateDir = templateDir = \"scala-akka-http-server\";\n+\n+        groupId = \"org.openapitools\";\n+        artifactId = \"openapi-scala-akka-http-server\";\n+        artifactVersion = \"1.0.0\";\n+        apiPackage = \"org.openapitools.server.api\";\n+        modelPackage = \"org.openapitools.server.model\";\n+        invokerPackage = \"org.openapitools.server\";\n+        akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+\n+        setReservedWordsLowerCase(\n+                Arrays.asList(\n+                        \"abstract\", \"case\", \"catch\", \"class\", \"def\", \"do\", \"else\", \"extends\",\n+                        \"false\", \"final\", \"finally\", \"for\", \"forSome\", \"if\", \"implicit\",\n+                        \"import\", \"lazy\", \"match\", \"new\", \"null\", \"object\", \"override\", \"package\",\n+                        \"private\", \"protected\", \"return\", \"sealed\", \"super\", \"this\", \"throw\",\n+                        \"trait\", \"try\", \"true\", \"type\", \"val\", \"var\", \"while\", \"with\", \"yield\")\n+        );\n+\n+        cliOptions.add(CliOption.newString(CodegenConstants.INVOKER_PACKAGE, CodegenConstants.INVOKER_PACKAGE_DESC).defaultValue(invokerPackage));\n+        cliOptions.add(CliOption.newString(CodegenConstants.GROUP_ID, CodegenConstants.GROUP_ID_DESC).defaultValue(groupId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_ID, CodegenConstants.ARTIFACT_ID).defaultValue(artifactId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_VERSION, CodegenConstants.ARTIFACT_VERSION_DESC).defaultValue(artifactVersion));\n+        cliOptions.add(CliOption.newString(AKKA_HTTP_VERSION, AKKA_HTTP_VERSION_DESC).defaultValue(akkaHttpVersion));\n+\n+        importMapping.remove(\"Seq\");\n+        importMapping.remove(\"List\");\n+        importMapping.remove(\"Set\");\n+        importMapping.remove(\"Map\");\n+\n+        typeMapping = new HashMap<>();\n+        typeMapping.put(\"array\", \"Seq\");\n+        typeMapping.put(\"set\", \"Set\");\n+        typeMapping.put(\"boolean\", \"Boolean\");\n+        typeMapping.put(\"string\", \"String\");\n+        typeMapping.put(\"int\", \"Int\");\n+        typeMapping.put(\"integer\", \"Int\");\n+        typeMapping.put(\"long\", \"Long\");\n+        typeMapping.put(\"float\", \"Float\");\n+        typeMapping.put(\"byte\", \"Byte\");\n+        typeMapping.put(\"short\", \"Short\");\n+        typeMapping.put(\"char\", \"Char\");\n+        typeMapping.put(\"double\", \"Double\");\n+        typeMapping.put(\"object\", \"Any\");\n+        typeMapping.put(\"file\", \"File\");\n+        typeMapping.put(\"binary\", \"File\");\n+        typeMapping.put(\"number\", \"Double\");\n+\n+        instantiationTypes.put(\"array\", \"ListBuffer\");\n+        instantiationTypes.put(\"map\", \"Map\");\n+\n+        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n+    }\n+\n+    @Override\n+    public void processOpts() {\n+        super.processOpts();\n+\n+        if (additionalProperties.containsKey(CodegenConstants.INVOKER_PACKAGE)) {\n+            invokerPackage = (String) additionalProperties.get(CodegenConstants.INVOKER_PACKAGE);\n+        } else {\n+            additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.GROUP_ID)) {\n+            groupId = (String) additionalProperties.get(CodegenConstants.GROUP_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.GROUP_ID, groupId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_ID)) {\n+            artifactId = (String) additionalProperties.get(CodegenConstants.ARTIFACT_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_ID, artifactId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_VERSION)) {\n+            artifactVersion = (String) additionalProperties.get(CodegenConstants.ARTIFACT_VERSION);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_VERSION, artifactVersion);\n+        }\n+\n+        if (additionalProperties.containsKey(AKKA_HTTP_VERSION)) {\n+            akkaHttpVersion = (String) additionalProperties.get(AKKA_HTTP_VERSION);\n+        } else {\n+            additionalProperties.put(AKKA_HTTP_VERSION, akkaHttpVersion);\n+        }\n+\n+        parseAkkaHttpVersion();\n+\n+        supportingFiles.add(new SupportingFile(\"build.sbt.mustache\", \"\", \"build.sbt\"));\n+        supportingFiles.add(new SupportingFile(\"controller.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"Controller.scala\"));\n+        supportingFiles.add(new SupportingFile(\"helper.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"AkkaHttpHelper.scala\"));\n+        supportingFiles.add(new SupportingFile(\"stringDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"StringDirectives.scala\"));\n+        supportingFiles.add(new SupportingFile(\"multipartDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"MultipartDirectives.scala\"));\n+    }\n+\n+    private static final String IS_10_1_10_PLUS = \"akkaHttp10_1_10_plus\";\n+    private boolean is10_1_10AndAbove = false;\n+\n+    private static final Pattern akkaVersionPattern = Pattern.compile(\"([0-9]+)(\\\\.([0-9]+))?(\\\\.([0-9]+))?(.\\\\+)?\");\n+    private void parseAkkaHttpVersion() {\n+        Matcher matcher = akkaVersionPattern.matcher(akkaHttpVersion);\n+        if (matcher.matches()) {\n+            String majorS = matcher.group(1);\n+            String minorS = matcher.group(3);\n+            String patchS = matcher.group(5);\n+            boolean andAbove = matcher.group(6) != null;\n+            int major = -1, minor = -1, patch = -1;\n+            try {\n+                if (majorS != null) {\n+                    major = Integer.parseInt(majorS);\n+                    if (minorS != null) {\n+                        minor = Integer.parseInt(minorS);\n+                        if (patchS != null) {\n+                            patch = Integer.parseInt(patchS);\n+                        }\n+                    }\n+                }\n+\n+\n+                if (major > 10 || major == -1 && andAbove) {\n+                    is10_1_10AndAbove = true;\n+                } else if (major == 10) {\n+                    if (minor > 1 || minor == -1 && andAbove) {\n+                        is10_1_10AndAbove = true;\n+                    } else if (minor == 1) {\n+                        if (patch >= 10 || patch == -1 && andAbove) {\n+                            is10_1_10AndAbove = true;\n+                        }\n+                    }\n+                }\n+\n+            } catch (NumberFormatException e) {\n+                LOGGER.warn(\"Unable to parse \" + AKKA_HTTP_VERSION + \": \" + akkaHttpVersion + \", fallback to \" + DEFAULT_AKKA_HTTP_VERSION);\n+                akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+                is10_1_10AndAbove = true;\n+            }\n+        }\n+\n+        additionalProperties.put(IS_10_1_10_PLUS, is10_1_10AndAbove);\n+    }\n+\n+    @Override\n+    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, List<Server> servers) {\n+        CodegenOperation codegenOperation = super.fromOperation(path, httpMethod, operation, servers);\n+        addPathMatcher(codegenOperation);\n+        return codegenOperation;\n+    }\n+\n+    @Override\n+    public CodegenParameter fromParameter(Parameter parameter, Set<String> imports) {\n+        CodegenParameter param = super.fromParameter(parameter, imports);\n+        // Removing unhandled types\n+        if(!primitiveParamTypes.contains(param.dataType)) {\n+            param.dataType = \"String\";\n+        }\n+        if (!param.required) {\n+            param.vendorExtensions.put(\"hasDefaultValue\", param.defaultValue != null);\n+            // Escaping default string values\n+            if (param.defaultValue != null && param.dataType.equals(\"String\")) {\n+                param.defaultValue = String.format(Locale.ROOT, \"\\\"%s\\\"\", param.defaultValue);\n+            }\n+        }\n+        return param;\n+    }\n+\n+\n+\n+    @Override\n+    public Map<String, Object> postProcessOperationsWithModels(Map<String, Object> objs, List<Object> allModels) {\n+        Map<String, Object> baseObjs = super.postProcessOperationsWithModels(objs, allModels);\n+        pathMatcherPatternsPostProcessor(baseObjs);\n+        marshallingPostProcessor(baseObjs);\n+        return baseObjs;\n+    }\n+\n+    private static Set<String> primitiveParamTypes = new HashSet<String>(){{\n+        addAll(Arrays.asList(\n+                \"Int\",\n+                \"Long\",\n+                \"Float\",\n+                \"Double\",\n+                \"Boolean\",\n+                \"String\"\n+        ));\n+    }};\n+\n+    private static Map<String, String> pathTypeToMatcher = new HashMap<String, String>(){{\n+        put(\"Int\", \"IntNumber\");\n+        put(\"Long\", \"LongNumber\");\n+        put(\"Float\",\"FloatNumber\");\n+        put(\"Double\",\"DoubleNumber\");\n+        put(\"Boolean\",\"Boolean\");\n+        put(\"String\", \"Segment\");\n+    }};\n+\n+    protected static void addPathMatcher(CodegenOperation codegenOperation) {\n+        LinkedList<String> allPaths = new LinkedList<>(Arrays.asList(codegenOperation.path.split(\"/\")));\n+        allPaths.removeIf(\"\"::equals);\n+\n+        LinkedList<TextOrMatcher> pathMatchers = new LinkedList<>();\n+        for(String path: allPaths){\n+            TextOrMatcher textOrMatcher = new TextOrMatcher(\"\", true, true);\n+            if(path.startsWith(\"{\") && path.endsWith(\"}\")) {\n+                String parameterName = path.substring(1, path.length()-1);\n+                for(CodegenParameter pathParam: codegenOperation.pathParams){\n+                    if(pathParam.baseName.equals(parameterName)) {\n+                        String matcher = pathTypeToMatcher.get(pathParam.dataType);\n+                        if(matcher == null) {\n+                            LOGGER.warn(\"The path parameter \" + pathParam.baseName +\n+                                    \" with the datatype \" + pathParam.dataType +\n+                                    \" could not be translated to a corresponding path matcher of akka http\" +\n+                                    \" and therefore has been translated to string.\");\n+                            matcher = pathTypeToMatcher.get(\"String\");\n+                        }\n+                        if (pathParam.pattern != null && !pathParam.pattern.isEmpty()) {\n+                            matcher = pathMatcherPatternName(pathParam);\n+                        }\n+                        textOrMatcher.value = matcher;\n+                        textOrMatcher.isText = false;\n+                        pathMatchers.add(textOrMatcher);\n+                    }\n+                }\n+            } else {\n+                textOrMatcher.value = path;\n+                textOrMatcher.isText = true;\n+                pathMatchers.add(textOrMatcher);\n+            }\n+        }\n+        pathMatchers.getLast().hasMore = false;\n+\n+        codegenOperation.vendorExtensions.put(\"paths\", pathMatchers);\n+    }\n+\n+    public static String PATH_MATCHER_PATTERNS_KEY = \"pathMatcherPatterns\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void pathMatcherPatternsPostProcessor(Map<String, Object> objs) {\n+        if (objs != null) {\n+            HashMap<String, PathMatcherPattern> patternMap = new HashMap<>();\n+            Map<String, Object> operations = (Map<String, Object>) objs.get(\"operations\");\n+            if (operations != null) {\n+                List<CodegenOperation> ops = (List<CodegenOperation>) operations.get(\"operation\");\n+                for (CodegenOperation operation: ops) {\n+                    for (CodegenParameter parameter: operation.pathParams) {\n+                        if (parameter.pattern != null && !parameter.pattern.isEmpty()) {\n+                            String name = pathMatcherPatternName(parameter);\n+                            if (!patternMap.containsKey(name)) {\n+                                patternMap.put(name, new PathMatcherPattern(name, parameter.pattern.substring(1, parameter.pattern.length() - 1)));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            objs.put(PATH_MATCHER_PATTERNS_KEY, new ArrayList<>(patternMap.values()));\n+        }\n+    }\n+\n+    private static String pathMatcherPatternName(CodegenParameter parameter) {\n+        return parameter.paramName + \"Pattern\";\n+    }\n+\n+    // Responsible for setting up Marshallers/Unmarshallers\n+    @SuppressWarnings(\"unchecked\")\n+    public static void marshallingPostProcessor(Map<String, Object> objs) {\n+\n+        if (objs == null) {\n+            return;\n+        }\n+\n+        Set<Marshaller> entityUnmarshallerTypes = new HashSet<>();\n+        Set<Marshaller> entityMarshallerTypes = new HashSet<>();\n+        Set<Marshaller> stringUnmarshallerTypes = new HashSet<>();\n+        boolean hasCookieParams = false;\n+        boolean hasMultipart = false;\n+\n+        Map<String, Object> operations = (Map<String, Object>) objs.get(\"operations\");\n+        if (operations != null) {\n+            List<CodegenOperation> operationList = (List<CodegenOperation>) operations.get(\"operation\");\n+\n+            for (CodegenOperation op : operationList) {\n+                boolean isMultipart = op.isMultipart;\n+                hasMultipart |= isMultipart;\n+                hasCookieParams |= op.getHasCookieParams();\n+                ArrayList<CodegenParameter> fileParams = new ArrayList<>();\n+                ArrayList<CodegenParameter> nonFileParams = new ArrayList<>();\n+                for (CodegenParameter parameter : op.allParams) {\n+                    if (parameter.isBodyParam || parameter.isFormParam) {\n+                        if (parameter.isFile) {\n+                            fileParams.add(parameter.copy());\n+                        } else {\n+                            nonFileParams.add(parameter.copy());\n+                        }\n+                        if (!parameter.isPrimitiveType) {\n+                            if (isMultipart) {\n+                                stringUnmarshallerTypes.add(new Marshaller(parameter));\n+                            } else {\n+                                entityUnmarshallerTypes.add(new Marshaller(parameter));\n+                            }\n+                        }\n+                    }\n+                }\n+                for (int i = 0, size = fileParams.size(); i < size; ++i) {\n+                    fileParams.get(i).hasMore = i < size - 1;\n+                }\n+                for (int i = 0, size = nonFileParams.size(); i < size; ++i) {\n+                    nonFileParams.get(i).hasMore = i < size - 1;\n+                }\n+\n+                HashSet<Marshaller> operationSpecificMarshallers = new HashSet<>();\n+                for (CodegenResponse response : op.responses) {\n+                    if (!response.primitiveType) {\n+                        Marshaller marshaller = new Marshaller(response);\n+                        entityMarshallerTypes.add(marshaller);\n+                        operationSpecificMarshallers.add(marshaller);\n+                    }\n+                    response.vendorExtensions.put(\"isDefault\", response.code.equals(\"0\"));\n+                }\n+                op.vendorExtensions.put(\"specificMarshallers\", operationSpecificMarshallers);\n+                op.vendorExtensions.put(\"fileParams\", fileParams);\n+                op.vendorExtensions.put(\"nonFileParams\", nonFileParams);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9"}, "originalPosition": 396}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3617, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}