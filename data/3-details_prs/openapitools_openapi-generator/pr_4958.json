{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxMjkyOTM4", "number": 4958, "title": "[Python] Support for HTTP signature", "bodyText": "This is adding a new \"HTTP signature\" security schemes (https://datatracker.ietf.org/doc/draft-cavage-http-signatures/)? HTTP signatures is still a IETF draft, and hopefully it will become an official RFC this year. On one hand one may argue it shouldn\u2019t be added because it\u2019s still a draft, but on the other hand it is already being used by multiple products, so there may be benefits to support it. It is possible multiple organizations are independently adding the same security scheme.\nIdeally one way to address the problem would be to make it possible to add new security schemes (such as HTTP signature) without being required to fork the OpenAPITools repo. But given the current code structure, it\u2019s not clear to me how this could be achieved. Adding new security schemes involves surgery in multiple locations (Java codegen, templates, mustache tags).\nI raised this point in Slack before opening the PR.\nThis PR depends on #4993 and #4992.\n\nPR checklist\n\n Read the contribution guidelines.\n If contributing template-only or documentation-only changes which will change sample output, build the project before.\n Run the shell script(s) under ./bin/ (or Windows batch scripts under.\\bin\\windows) to update Petstore samples related to your fix. This is important, as CI jobs will verify all generator outputs of your HEAD commit, and these must match the expectations made by your contribution. You only need to run ./bin/{LANG}-petstore.sh, ./bin/openapi3/{LANG}-petstore.sh if updating the code or mustache templates for a language ({LANG}) (e.g. php, ruby, python, etc).\n File the PR against the correct branch: master, 4.3.x, 5.0.x. Default: master.\n Copy the technical committee to review the pull request if your PR is targeting a particular programming language.", "createdAt": "2020-01-10T06:14:28Z", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958", "merged": true, "mergeCommit": {"oid": "4f350bc01cb3aaadf71122ee9d4f1b975e1f2295"}, "closed": true, "closedAt": "2020-01-27T02:17:27Z", "author": {"login": "sebastien-rosset"}, "timelineItems": {"totalCount": 212, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9B1xigH2gAyMzYxMjkyOTM4OjIxMzdjYzE3N2RmOTlmY2U3NTZiMzY1YmJiYmJkOGEyNTljMTZmOWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb-MejaAH2gAyMzYxMjkyOTM4OjRkYjFiMjE4ZWRiNTcwNGQ3MzhlZTM2NTllZTYzYzFkNDM5ZWI0OWU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2137cc177df99fce756b365bbbbbd8a259c16f9a", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/2137cc177df99fce756b365bbbbbd8a259c16f9a", "committedDate": "2020-01-23T03:32:57Z", "message": "http signature unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e532a67039ef2946e1c7d30d348a5495cd472447", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/e532a67039ef2946e1c7d30d348a5495cd472447", "committedDate": "2020-01-23T04:36:24Z", "message": "Fix PEP8 format issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d89594ca9d258b0ee8521cd92326ec1df68bb45", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/7d89594ca9d258b0ee8521cd92326ec1df68bb45", "committedDate": "2020-01-23T17:38:03Z", "message": "Merge remote-tracking branch 'origin' into http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bb0df5601625da1bc2d2373fe42df7d11eb3e58", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/1bb0df5601625da1bc2d2373fe42df7d11eb3e58", "committedDate": "2020-01-23T17:38:42Z", "message": "Merge branch 'http-signature' into python-http-signature"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDg5MjAx", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-347489201", "createdAt": "2020-01-23T17:47:09Z", "commit": {"oid": "1bb0df5601625da1bc2d2373fe42df7d11eb3e58"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNzo0NzoxMFrOFhHG8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNzo0NzoxMFrOFhHG8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2Mzc5Mw==", "bodyText": "Why should we remove this exception?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r370263793", "createdAt": "2020-01-23T17:47:10Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -3646,8 +3646,6 @@ public boolean isDataTypeFile(String dataType) {\n                     // As of January 2020, the \"signature\" scheme has not been registered with IANA yet.\n                     // This scheme may have to be changed when it is officially registered with IANA.\n                     cs.isHttpSignature = true;\n-                } else {\n-                    throw new RuntimeException(\"Unsupported security scheme: \" + securityScheme.getScheme());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bb0df5601625da1bc2d2373fe42df7d11eb3e58"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDkyMjAw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-347492200", "createdAt": "2020-01-23T17:52:13Z", "commit": {"oid": "1bb0df5601625da1bc2d2373fe42df7d11eb3e58"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNzo1MjoxNFrOFhHQNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNzo1MjoxNFrOFhHQNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2NjE2NQ==", "bodyText": "Optionally, why not spreading out each requirement to a separate line?\nThen we don't need to use append statement.\nREQUIRES = [\n    \"urllib3 >= 1.15\",\n    ...\n{{#asyncio}}\n    \"aiohttp >= 3.0.0\"\n{{/asyncio}}\n]", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r370266165", "createdAt": "2020-01-23T17:52:14Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/setup.mustache", "diffHunk": "@@ -23,6 +23,10 @@ REQUIRES.append(\"aiohttp >= 3.0.0\")\n {{#tornado}}\n REQUIRES.append(\"tornado>=4.2,<5\")\n {{/tornado}}\n+{{#hasHttpSignatureMethods}}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bb0df5601625da1bc2d2373fe42df7d11eb3e58"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39a6d014972ecd6b5448ebf8cc8cc9cdaa027cbd", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/39a6d014972ecd6b5448ebf8cc8cc9cdaa027cbd", "committedDate": "2020-01-23T17:57:54Z", "message": "spread out each requirement to a separate line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15a5c09d6eb6575b99542c96dd2809d21cfe2950", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/15a5c09d6eb6575b99542c96dd2809d21cfe2950", "committedDate": "2020-01-23T20:43:29Z", "message": "run samples scripts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bcb9581391df785a102315a8cbc71d48a89a0cf", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/3bcb9581391df785a102315a8cbc71d48a89a0cf", "committedDate": "2020-01-24T02:54:52Z", "message": "Merge remote-tracking branch 'origin' into python-http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7184320d07c9cdb1d3810c1b284256f4ad7d66a6", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/7184320d07c9cdb1d3810c1b284256f4ad7d66a6", "committedDate": "2020-01-24T05:15:36Z", "message": "run sample scripts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45f2cfdde52e336038ff24b24dfbeebaea0a0a09", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/45f2cfdde52e336038ff24b24dfbeebaea0a0a09", "committedDate": "2020-01-26T18:21:44Z", "message": "sync from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4db1b218edb5704d738ee3659ee63c1d439eb49e", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/4db1b218edb5704d738ee3659ee63c1d439eb49e", "committedDate": "2020-01-26T18:30:28Z", "message": "remove encoding of '+' character"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c1967eff0cfe4f2099120ae0f39ff77d04f2ec1", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/7c1967eff0cfe4f2099120ae0f39ff77d04f2ec1", "committedDate": "2020-01-16T01:00:30Z", "message": "Code reformatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2db7093daa4b298eaafd57f6cc72d5d5dbcf8d99", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/2db7093daa4b298eaafd57f6cc72d5d5dbcf8d99", "committedDate": "2020-01-16T03:44:46Z", "message": "Merge remote-tracking branch 'origin' into python-http-signature"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTk3MDU5", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343597059", "createdAt": "2020-01-15T23:47:47Z", "commit": {"oid": "21c478fe7e19b6641b964b615ffb32cad66441c1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzo0Nzo0N1rOFeKDVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMTowMTowMVrOFeLLPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NjI5NA==", "bodyText": "Can you update the samples?\nThis is outdated", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367166294", "createdAt": "2020-01-15T23:47:47Z", "author": {"login": "spacether"}, "path": "samples/client/petstore/python-experimental/petstore_api/api_client.py", "diffHunk": "@@ -62,6 +62,10 @@ class ApiClient(object):\n     PRIMITIVE_TYPES = (\n         (float, bool, six.binary_type, six.text_type) + six.integer_types\n     )\n+    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21c478fe7e19b6641b964b615ffb32cad66441c1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NjY1OQ==", "bodyText": "Can you move this to processOpts? It looks like that is where we are conditionally adding supporting files.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367166659", "createdAt": "2020-01-15T23:49:16Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/PythonClientExperimentalCodegen.java", "diffHunk": "@@ -82,6 +84,12 @@ public PythonClientExperimentalCodegen() {\n \n         apiTemplateFiles.remove(\"api.mustache\");\n         apiTemplateFiles.put(\"python-experimental/api.mustache\", \".py\");\n+        Map<String, SecurityScheme> securitySchemeMap = openAPI != null ?\n+           (openAPI.getComponents() != null ? openAPI.getComponents().getSecuritySchemes() : null) : null;\n+        List<CodegenSecurity> authMethods = fromSecurity(securitySchemeMap);\n+        if (ProcessUtils.hasHttpSignatureMethods(authMethods)) {\n+            apiTemplateFiles.put(\"python-experimental/signing.mustache\", \".py\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21c478fe7e19b6641b964b615ffb32cad66441c1"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE3MzIzNA==", "bodyText": "Great job creating that module! Can you mark this as resolved?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367173234", "createdAt": "2020-01-16T00:14:57Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -57,6 +64,10 @@ class ApiClient(object):\n     PRIMITIVE_TYPES = (\n         (float, bool, six.binary_type, six.text_type) + six.integer_types\n     )\n+    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNTExMw=="}, "originalCommit": {"oid": "fac1af1347e914bd8ffe84317cdf177176142475"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4MDMwNw==", "bodyText": "Can we use our constants here?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367180307", "createdAt": "2020-01-16T00:42:49Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,221 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+\n+SCHEME_HS2019 = 'hs2019'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+def get_http_signature_headers(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Create a cryptographic message signature for the HTTP request and add the signed headers.\n+    \n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+    if method is None:\n+        raise Exception(\"HTTP method must be set\")\n+    if resource_path is None:\n+        raise Exception(\"Resource path must be set\")\n+\n+    signed_headers_dict, request_headers_dict = get_signed_header_info(configuration,\n+        resource_path, method, headers, body, query_params)\n+\n+    header_items = [\"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+    string_to_sign = \"\\n\".join(header_items)\n+\n+    digest, digest_prefix = get_message_digest(configuration, string_to_sign.encode())\n+    b64_signed_msg = sign_digest(configuration, digest)\n+\n+    request_headers_dict['Authorization'] = get_authorization_header(configuration,\n+        signed_headers_dict, b64_signed_msg)\n+\n+    return request_headers_dict\n+\n+def load_private_key(configuration):\n+    \"\"\"Load the private key used to sign HTTP requests.\n+        The private key is used to sign HTTP requests as defined in\n+        https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+    \"\"\"\n+    if configuration.private_key is not None:\n+        return\n+    with open(configuration.private_key_path, \"rb\") as f:\n+        # Decode PEM file and determine key type from PEM header.\n+        # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+        keys = pem.parse(f.read())\n+        if len(keys) != 1:\n+            raise Exception(\"File must contain exactly one private key\")\n+        key = keys[0].as_text()\n+        if key.startswith(\"-----BEGIN RSA PRIVATE KEY-----\"):\n+            configuration.private_key = RSA.importKey(key)\n+        elif key.startswith(\"-----BEGIN EC PRIVATE KEY-----\"):\n+            configuration.private_key = ECC.importKey(key)\n+        else:\n+            raise Exception(\"Unsupported key\")\n+\n+def get_signed_header_info(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A tuple containing two dict objects:\n+        The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+        The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+\n+    if body is None:\n+        body = ''\n+    else:\n+        body = json.dumps(body)\n+\n+    # Build the '(request-target)' HTTP signature parameter.\n+    target_host = urlparse(configuration.host).netloc\n+    target_path = urlparse(configuration.host).path\n+    request_target = method.lower() + \" \" + target_path + resource_path\n+    if query_params:\n+        raw_query = urlencode(query_params).replace('+', '%20')\n+        request_target += \"?\" + raw_query\n+\n+    # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+    now = datetime.datetime.now()\n+    stamp = mktime(now.timetuple())\n+    cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+    created = now.strftime(\"%s\")\n+    if configuration.signature_max_validity is not None:\n+        expires = (now + configuration.signature_max_validity).strftime(\"%s\")\n+\n+    signed_headers_dict = {}\n+    request_headers_dict = {}\n+    for hdr_key in configuration.signed_headers_dict:\n+        hdr_key = hdr_key.lower()\n+        if hdr_key == HEADER_REQUEST_TARGET:\n+            value = request_target\n+        elif hdr_key == HEADER_CREATED:\n+            value = created\n+        elif hdr_key == HEADER_EXPIRES:\n+            value = expires\n+        elif hdr_key == HEADER_DATE:\n+            value = cdate\n+            request_headers_dict['Date'] = '{0}'.format(cdate)\n+        elif hdr_key == HEADER_DIGEST:\n+            request_body = body.encode()\n+            body_digest, digest_prefix = get_message_digest(configuration, request_body)\n+            b64_body_digest = b64encode(body_digest.digest())\n+            value = digest_prefix + b64_body_digest.decode('ascii')\n+            request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+        elif hdr_key == HEADER_HOST:\n+            value = target_host\n+            request_headers_dict['Host'] = '{0}'.format(target_host)\n+        else:\n+            value = headers[hdr_key]\n+        signed_headers_dict[hdr_key] = value\n+\n+    # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+    if len(configuration.signed_headers_dict) == 0:\n+        signed_headers_dict[HEADER_CREATED] = created\n+\n+    return signed_header_dict, request_headers_dict\n+\n+def get_message_digest(configuration, data):\n+    \"\"\"\n+    Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+    :param data: The string representation of the date to be hashed with a cryptographic hash.\n+    :return: A tuple of (digest, prefix).\n+        The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+        The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+        'Digest' header as specified in RFC 3230.\n+    \"\"\"\n+    if configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21c478fe7e19b6641b964b615ffb32cad66441c1"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4MDQ3Mw==", "bodyText": "Can we use our constants here?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367180473", "createdAt": "2020-01-16T00:43:27Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,221 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+\n+SCHEME_HS2019 = 'hs2019'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+def get_http_signature_headers(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Create a cryptographic message signature for the HTTP request and add the signed headers.\n+    \n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+    if method is None:\n+        raise Exception(\"HTTP method must be set\")\n+    if resource_path is None:\n+        raise Exception(\"Resource path must be set\")\n+\n+    signed_headers_dict, request_headers_dict = get_signed_header_info(configuration,\n+        resource_path, method, headers, body, query_params)\n+\n+    header_items = [\"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+    string_to_sign = \"\\n\".join(header_items)\n+\n+    digest, digest_prefix = get_message_digest(configuration, string_to_sign.encode())\n+    b64_signed_msg = sign_digest(configuration, digest)\n+\n+    request_headers_dict['Authorization'] = get_authorization_header(configuration,\n+        signed_headers_dict, b64_signed_msg)\n+\n+    return request_headers_dict\n+\n+def load_private_key(configuration):\n+    \"\"\"Load the private key used to sign HTTP requests.\n+        The private key is used to sign HTTP requests as defined in\n+        https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+    \"\"\"\n+    if configuration.private_key is not None:\n+        return\n+    with open(configuration.private_key_path, \"rb\") as f:\n+        # Decode PEM file and determine key type from PEM header.\n+        # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+        keys = pem.parse(f.read())\n+        if len(keys) != 1:\n+            raise Exception(\"File must contain exactly one private key\")\n+        key = keys[0].as_text()\n+        if key.startswith(\"-----BEGIN RSA PRIVATE KEY-----\"):\n+            configuration.private_key = RSA.importKey(key)\n+        elif key.startswith(\"-----BEGIN EC PRIVATE KEY-----\"):\n+            configuration.private_key = ECC.importKey(key)\n+        else:\n+            raise Exception(\"Unsupported key\")\n+\n+def get_signed_header_info(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A tuple containing two dict objects:\n+        The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+        The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+\n+    if body is None:\n+        body = ''\n+    else:\n+        body = json.dumps(body)\n+\n+    # Build the '(request-target)' HTTP signature parameter.\n+    target_host = urlparse(configuration.host).netloc\n+    target_path = urlparse(configuration.host).path\n+    request_target = method.lower() + \" \" + target_path + resource_path\n+    if query_params:\n+        raw_query = urlencode(query_params).replace('+', '%20')\n+        request_target += \"?\" + raw_query\n+\n+    # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+    now = datetime.datetime.now()\n+    stamp = mktime(now.timetuple())\n+    cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+    created = now.strftime(\"%s\")\n+    if configuration.signature_max_validity is not None:\n+        expires = (now + configuration.signature_max_validity).strftime(\"%s\")\n+\n+    signed_headers_dict = {}\n+    request_headers_dict = {}\n+    for hdr_key in configuration.signed_headers_dict:\n+        hdr_key = hdr_key.lower()\n+        if hdr_key == HEADER_REQUEST_TARGET:\n+            value = request_target\n+        elif hdr_key == HEADER_CREATED:\n+            value = created\n+        elif hdr_key == HEADER_EXPIRES:\n+            value = expires\n+        elif hdr_key == HEADER_DATE:\n+            value = cdate\n+            request_headers_dict['Date'] = '{0}'.format(cdate)\n+        elif hdr_key == HEADER_DIGEST:\n+            request_body = body.encode()\n+            body_digest, digest_prefix = get_message_digest(configuration, request_body)\n+            b64_body_digest = b64encode(body_digest.digest())\n+            value = digest_prefix + b64_body_digest.decode('ascii')\n+            request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+        elif hdr_key == HEADER_HOST:\n+            value = target_host\n+            request_headers_dict['Host'] = '{0}'.format(target_host)\n+        else:\n+            value = headers[hdr_key]\n+        signed_headers_dict[hdr_key] = value\n+\n+    # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+    if len(configuration.signed_headers_dict) == 0:\n+        signed_headers_dict[HEADER_CREATED] = created\n+\n+    return signed_header_dict, request_headers_dict\n+\n+def get_message_digest(configuration, data):\n+    \"\"\"\n+    Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+    :param data: The string representation of the date to be hashed with a cryptographic hash.\n+    :return: A tuple of (digest, prefix).\n+        The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+        The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+        'Digest' header as specified in RFC 3230.\n+    \"\"\"\n+    if configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+        digest = SHA512.new()\n+        prefix = \"SHA-512=\"\n+    elif configuration.signing_scheme in [\"rsa-sha256\"]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21c478fe7e19b6641b964b615ffb32cad66441c1"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4NDIyNQ==", "bodyText": "Can we delete this line?\nLine 211 sets headers_value for us.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367184225", "createdAt": "2020-01-16T00:58:52Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,221 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+\n+SCHEME_HS2019 = 'hs2019'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+def get_http_signature_headers(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Create a cryptographic message signature for the HTTP request and add the signed headers.\n+    \n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+    if method is None:\n+        raise Exception(\"HTTP method must be set\")\n+    if resource_path is None:\n+        raise Exception(\"Resource path must be set\")\n+\n+    signed_headers_dict, request_headers_dict = get_signed_header_info(configuration,\n+        resource_path, method, headers, body, query_params)\n+\n+    header_items = [\"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+    string_to_sign = \"\\n\".join(header_items)\n+\n+    digest, digest_prefix = get_message_digest(configuration, string_to_sign.encode())\n+    b64_signed_msg = sign_digest(configuration, digest)\n+\n+    request_headers_dict['Authorization'] = get_authorization_header(configuration,\n+        signed_headers_dict, b64_signed_msg)\n+\n+    return request_headers_dict\n+\n+def load_private_key(configuration):\n+    \"\"\"Load the private key used to sign HTTP requests.\n+        The private key is used to sign HTTP requests as defined in\n+        https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+    \"\"\"\n+    if configuration.private_key is not None:\n+        return\n+    with open(configuration.private_key_path, \"rb\") as f:\n+        # Decode PEM file and determine key type from PEM header.\n+        # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+        keys = pem.parse(f.read())\n+        if len(keys) != 1:\n+            raise Exception(\"File must contain exactly one private key\")\n+        key = keys[0].as_text()\n+        if key.startswith(\"-----BEGIN RSA PRIVATE KEY-----\"):\n+            configuration.private_key = RSA.importKey(key)\n+        elif key.startswith(\"-----BEGIN EC PRIVATE KEY-----\"):\n+            configuration.private_key = ECC.importKey(key)\n+        else:\n+            raise Exception(\"Unsupported key\")\n+\n+def get_signed_header_info(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A tuple containing two dict objects:\n+        The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+        The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+\n+    if body is None:\n+        body = ''\n+    else:\n+        body = json.dumps(body)\n+\n+    # Build the '(request-target)' HTTP signature parameter.\n+    target_host = urlparse(configuration.host).netloc\n+    target_path = urlparse(configuration.host).path\n+    request_target = method.lower() + \" \" + target_path + resource_path\n+    if query_params:\n+        raw_query = urlencode(query_params).replace('+', '%20')\n+        request_target += \"?\" + raw_query\n+\n+    # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+    now = datetime.datetime.now()\n+    stamp = mktime(now.timetuple())\n+    cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+    created = now.strftime(\"%s\")\n+    if configuration.signature_max_validity is not None:\n+        expires = (now + configuration.signature_max_validity).strftime(\"%s\")\n+\n+    signed_headers_dict = {}\n+    request_headers_dict = {}\n+    for hdr_key in configuration.signed_headers_dict:\n+        hdr_key = hdr_key.lower()\n+        if hdr_key == HEADER_REQUEST_TARGET:\n+            value = request_target\n+        elif hdr_key == HEADER_CREATED:\n+            value = created\n+        elif hdr_key == HEADER_EXPIRES:\n+            value = expires\n+        elif hdr_key == HEADER_DATE:\n+            value = cdate\n+            request_headers_dict['Date'] = '{0}'.format(cdate)\n+        elif hdr_key == HEADER_DIGEST:\n+            request_body = body.encode()\n+            body_digest, digest_prefix = get_message_digest(configuration, request_body)\n+            b64_body_digest = b64encode(body_digest.digest())\n+            value = digest_prefix + b64_body_digest.decode('ascii')\n+            request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+        elif hdr_key == HEADER_HOST:\n+            value = target_host\n+            request_headers_dict['Host'] = '{0}'.format(target_host)\n+        else:\n+            value = headers[hdr_key]\n+        signed_headers_dict[hdr_key] = value\n+\n+    # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+    if len(configuration.signed_headers_dict) == 0:\n+        signed_headers_dict[HEADER_CREATED] = created\n+\n+    return signed_header_dict, request_headers_dict\n+\n+def get_message_digest(configuration, data):\n+    \"\"\"\n+    Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+    :param data: The string representation of the date to be hashed with a cryptographic hash.\n+    :return: A tuple of (digest, prefix).\n+        The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+        The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+        'Digest' header as specified in RFC 3230.\n+    \"\"\"\n+    if configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+        digest = SHA512.new()\n+        prefix = \"SHA-512=\"\n+    elif configuration.signing_scheme in [\"rsa-sha256\"]:\n+        digest = SHA256.new()\n+        prefix = \"SHA-256=\"\n+    else:\n+        raise Exception(\n+            \"Unsupported signing algorithm: {0}\".format(configuration.signing_scheme))\n+    digest.update(data)\n+    return digest, prefix\n+\n+def sign_digest(configuration, digest):\n+    \"\"\"\n+    Signs a message digest with a private key specified in the configuration.\n+\n+    :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+    :return: A base-64 string representing the cryptographic signature of the input digest.\n+    \"\"\"\n+    load_private_key(configuration)\n+    privkey = self.private_key\n+    if isinstance(privkey, RSA.RsaKey):\n+        if configuration.signing_algorithm == ALGORITHM_RSASSA_PSS:\n+            # RSASSA-PSS in Section 8.1 of RFC8017.\n+            signature = pss.new(privkey).sign(digest)\n+        elif configuration.signing_algorithm == ALGORITHM_RSASSA_PKCS1v15:\n+            # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+            signature = PKCS1_v1_5.new(privkey).sign(digest)\n+        else:\n+            raise Exception(\"Unsupported signature algorithm: {0}\".format(configuration.signing_algorithm))\n+    elif isinstance(privkey, ECC.EccKey):\n+        if configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:\n+            signature = DSS.new(privkey, configuration.signing_algorithm).sign(digest)\n+        else:\n+            raise Exception(\"Unsupported signature algorithm: {0}\".format(configuration.signing_algorithm))\n+    else:\n+        raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+    return b64encode(signature)\n+\n+def get_authorization_header(configuration, signed_headers, signed_msg):\n+    \"\"\"\n+    Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n+    \n+    :param signed_headers : A list of strings. Each value is the name of a HTTP header that\n+        must be included in the HTTP signature calculation.\n+    :param signed_msg: A base-64 encoded string representation of the signature.\n+    :return: The string value of the 'Authorization' header, representing the signature\n+        of the HTTP request.\n+    \"\"\"\n+\n+    headers_value = \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21c478fe7e19b6641b964b615ffb32cad66441c1"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4NDcwMg==", "bodyText": "We have no self here. Should this be privkey = signing_info.private_key?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367184702", "createdAt": "2020-01-16T01:01:01Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,221 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+\n+SCHEME_HS2019 = 'hs2019'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+def get_http_signature_headers(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Create a cryptographic message signature for the HTTP request and add the signed headers.\n+    \n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+    if method is None:\n+        raise Exception(\"HTTP method must be set\")\n+    if resource_path is None:\n+        raise Exception(\"Resource path must be set\")\n+\n+    signed_headers_dict, request_headers_dict = get_signed_header_info(configuration,\n+        resource_path, method, headers, body, query_params)\n+\n+    header_items = [\"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+    string_to_sign = \"\\n\".join(header_items)\n+\n+    digest, digest_prefix = get_message_digest(configuration, string_to_sign.encode())\n+    b64_signed_msg = sign_digest(configuration, digest)\n+\n+    request_headers_dict['Authorization'] = get_authorization_header(configuration,\n+        signed_headers_dict, b64_signed_msg)\n+\n+    return request_headers_dict\n+\n+def load_private_key(configuration):\n+    \"\"\"Load the private key used to sign HTTP requests.\n+        The private key is used to sign HTTP requests as defined in\n+        https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+    \"\"\"\n+    if configuration.private_key is not None:\n+        return\n+    with open(configuration.private_key_path, \"rb\") as f:\n+        # Decode PEM file and determine key type from PEM header.\n+        # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+        keys = pem.parse(f.read())\n+        if len(keys) != 1:\n+            raise Exception(\"File must contain exactly one private key\")\n+        key = keys[0].as_text()\n+        if key.startswith(\"-----BEGIN RSA PRIVATE KEY-----\"):\n+            configuration.private_key = RSA.importKey(key)\n+        elif key.startswith(\"-----BEGIN EC PRIVATE KEY-----\"):\n+            configuration.private_key = ECC.importKey(key)\n+        else:\n+            raise Exception(\"Unsupported key\")\n+\n+def get_signed_header_info(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A tuple containing two dict objects:\n+        The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+        The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+\n+    if body is None:\n+        body = ''\n+    else:\n+        body = json.dumps(body)\n+\n+    # Build the '(request-target)' HTTP signature parameter.\n+    target_host = urlparse(configuration.host).netloc\n+    target_path = urlparse(configuration.host).path\n+    request_target = method.lower() + \" \" + target_path + resource_path\n+    if query_params:\n+        raw_query = urlencode(query_params).replace('+', '%20')\n+        request_target += \"?\" + raw_query\n+\n+    # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+    now = datetime.datetime.now()\n+    stamp = mktime(now.timetuple())\n+    cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+    created = now.strftime(\"%s\")\n+    if configuration.signature_max_validity is not None:\n+        expires = (now + configuration.signature_max_validity).strftime(\"%s\")\n+\n+    signed_headers_dict = {}\n+    request_headers_dict = {}\n+    for hdr_key in configuration.signed_headers_dict:\n+        hdr_key = hdr_key.lower()\n+        if hdr_key == HEADER_REQUEST_TARGET:\n+            value = request_target\n+        elif hdr_key == HEADER_CREATED:\n+            value = created\n+        elif hdr_key == HEADER_EXPIRES:\n+            value = expires\n+        elif hdr_key == HEADER_DATE:\n+            value = cdate\n+            request_headers_dict['Date'] = '{0}'.format(cdate)\n+        elif hdr_key == HEADER_DIGEST:\n+            request_body = body.encode()\n+            body_digest, digest_prefix = get_message_digest(configuration, request_body)\n+            b64_body_digest = b64encode(body_digest.digest())\n+            value = digest_prefix + b64_body_digest.decode('ascii')\n+            request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+        elif hdr_key == HEADER_HOST:\n+            value = target_host\n+            request_headers_dict['Host'] = '{0}'.format(target_host)\n+        else:\n+            value = headers[hdr_key]\n+        signed_headers_dict[hdr_key] = value\n+\n+    # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+    if len(configuration.signed_headers_dict) == 0:\n+        signed_headers_dict[HEADER_CREATED] = created\n+\n+    return signed_header_dict, request_headers_dict\n+\n+def get_message_digest(configuration, data):\n+    \"\"\"\n+    Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+    :param data: The string representation of the date to be hashed with a cryptographic hash.\n+    :return: A tuple of (digest, prefix).\n+        The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+        The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+        'Digest' header as specified in RFC 3230.\n+    \"\"\"\n+    if configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+        digest = SHA512.new()\n+        prefix = \"SHA-512=\"\n+    elif configuration.signing_scheme in [\"rsa-sha256\"]:\n+        digest = SHA256.new()\n+        prefix = \"SHA-256=\"\n+    else:\n+        raise Exception(\n+            \"Unsupported signing algorithm: {0}\".format(configuration.signing_scheme))\n+    digest.update(data)\n+    return digest, prefix\n+\n+def sign_digest(configuration, digest):\n+    \"\"\"\n+    Signs a message digest with a private key specified in the configuration.\n+\n+    :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+    :return: A base-64 string representing the cryptographic signature of the input digest.\n+    \"\"\"\n+    load_private_key(configuration)\n+    privkey = self.private_key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21c478fe7e19b6641b964b615ffb32cad66441c1"}, "originalPosition": 177}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de9124c071ad7793d5eaeacd1df7224b408e2762", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/de9124c071ad7793d5eaeacd1df7224b408e2762", "committedDate": "2020-01-16T04:27:51Z", "message": "externalize http signature configuration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNjY4NDgw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343668480", "createdAt": "2020-01-16T04:32:54Z", "commit": {"oid": "de9124c071ad7793d5eaeacd1df7224b408e2762"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNDozMjo1NFrOFeNujA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNDozMjo1NFrOFeNujA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNjUwOA==", "bodyText": "Can you move this class to signing.py?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367226508", "createdAt": "2020-01-16T04:32:54Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -478,3 +426,75 @@ class Configuration(object):\n             url = url.replace(\"{\" + variable_name + \"}\", used_value)\n \n         return url\n+\n+class HttpSigningConfiguration(object):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de9124c071ad7793d5eaeacd1df7224b408e2762"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNjY4NjU3", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343668657", "createdAt": "2020-01-16T04:33:36Z", "commit": {"oid": "de9124c071ad7793d5eaeacd1df7224b408e2762"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNDozMzozNlrOFeNvJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNDozMzozNlrOFeNvJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNjY2MA==", "bodyText": "Can you update this to {{{packageName}}}.signing.HttpSigningConfiguration?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367226660", "createdAt": "2020-01-16T04:33:36Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -65,22 +41,23 @@ class Configuration(object):\n     sign the HTTP requests with the RSA-SSA-PSS signature algorithm, and set the expiration time\n     of the signature to 5 minutes after the signature has been created.\n       conf = {{{packageName}}}.Configuration(\n-        key_id='my-key-id',\n-        private_key_path='rsa.pem',\n-        signing_scheme=signing.SCHEME_HS2019,\n-        signing_algorithm=signing.ALGORITHM_RSASSA_PSS,\n-        signed_headers=[signing.HEADER_REQUEST_TARGET, signing.HEADER_CREATED,\n-                        signing.HEADER_EXPIRES, signing.HEADER_HOST, signing.HEADER_DATE,\n-                        signing.HEADER_DIGEST, 'Content-Type']\n-        signature_max_validity=timedelta(minutes=5),\n+        signing_info = {{{packageName}}}.HttpSigningConfiguration(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de9124c071ad7793d5eaeacd1df7224b408e2762"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNjY5MjE4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343669218", "createdAt": "2020-01-16T04:35:58Z", "commit": {"oid": "de9124c071ad7793d5eaeacd1df7224b408e2762"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNDozNTo1OFrOFeNxIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNDozNTo1OFrOFeNxIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNzE3MA==", "bodyText": "Can you change get_http_signature_headers so you pass in signing_info rather than configuration?\nThe functions only use signing_info, not any other of the configuration properties.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367227170", "createdAt": "2020-01-16T04:35:58Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -10,21 +10,29 @@ from Crypto.Hash import SHA256, SHA512\n from base64 import b64encode\n from email.utils import formatdate\n \n+from {{packageName}}.configuration import Configuration\n+\n HEADER_REQUEST_TARGET = '(request-target)'\n HEADER_CREATED = '(created)'\n HEADER_EXPIRES = '(expires)'\n HEADER_HOST = 'host'\n HEADER_DATE = 'date'\n HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n \n SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n \n ALGORITHM_RSASSA_PSS = 'PSS'\n ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n \n ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n-ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n \n def get_http_signature_headers(configuration, resource_path, method, headers, body, query_params):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de9124c071ad7793d5eaeacd1df7224b408e2762"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNjY5NTM3", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343669537", "createdAt": "2020-01-16T04:37:34Z", "commit": {"oid": "de9124c071ad7793d5eaeacd1df7224b408e2762"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNDozNzozNFrOFeNyRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNDozNzozNFrOFeNyRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNzQ2Mg==", "bodyText": "Can you update this to {{{packageName}}}.signing.HttpSigningConfiguration?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367227462", "createdAt": "2020-01-16T04:37:34Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -26,32 +26,8 @@ class Configuration(object):\n     :param api_key_prefix: Dict to store API prefix (e.g. Bearer)\n     :param username: Username for HTTP basic authentication\n     :param password: Password for HTTP basic authentication\n-    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n-        An 'Authorization' header is calculated by creating a hash of select headers,\n-        and optionally the body of the HTTP request, then signing the hash value using\n-        a private key which is available to the client.\n-    :param private_key_path: The path of the file containing a private key,\n-        when signing HTTP requests.\n-    :param signing_scheme: The signature scheme, when signing HTTP requests.\n-        Supported value is hs2019.\n-    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n-        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n-    :param signature_max_validity: The signature max validity,\n-        expressed as a datetime.timedelta value.\n-    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n-        that must be included in the HTTP signature calculation.\n-        The two special signature headers '(request-target)' and '(created)' SHOULD be\n-        included in SignedHeaders.\n-        The '(created)' header expresses when the signature was created.\n-        The '(request-target)' header is a concatenation of the lowercased :method, an\n-        ASCII space, and the :path pseudo-headers.\n-        When signed_headers is not specified, the client defaults to a single value,\n-        '(created)', in the list of HTTP headers.\n-        When SignedHeaders contains the 'Digest' value, the client performs the\n-        following operations:\n-        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n-        2. Set the 'Digest' header in the request body.\n-        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_info: Configuration parameters for HTTP signature.\n+        Must be an instance of {{{packageName}}}.HttpSigningConfiguration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de9124c071ad7793d5eaeacd1df7224b408e2762"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00fd981031522973d6375e6f831c9cdc0262b305", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/00fd981031522973d6375e6f831c9cdc0262b305", "committedDate": "2020-01-16T05:47:58Z", "message": "address PR review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09b9515f4d9654b10e3d767b5df53c2e8d3e4033", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/09b9515f4d9654b10e3d767b5df53c2e8d3e4033", "committedDate": "2020-01-16T05:58:40Z", "message": "address PR review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e4f43c64c5fd0e2ac0280dd2e200c999199ed28", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/0e4f43c64c5fd0e2ac0280dd2e200c999199ed28", "committedDate": "2020-01-16T06:00:21Z", "message": "run samples scripts"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNjg4OTQw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343688940", "createdAt": "2020-01-16T06:04:25Z", "commit": {"oid": "0e4f43c64c5fd0e2ac0280dd2e200c999199ed28"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNjowNDoyNlrOFeO0Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNjowNDoyNlrOFeO0Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0NDI5MA==", "bodyText": "Which of these params are required?\nIf they are required please set them as positional arguments with no None default value", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367244290", "createdAt": "2020-01-16T06:04:26Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,307 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    \"\"\"\n+    def __init__(self, key_id=None, private_key_path=None, signing_scheme=None,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e4f43c64c5fd0e2ac0280dd2e200c999199ed28"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNjg5MzMx", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343689331", "createdAt": "2020-01-16T06:06:02Z", "commit": {"oid": "0e4f43c64c5fd0e2ac0280dd2e200c999199ed28"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNjowNjowMlrOFeO1SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNjowNjowMlrOFeO1SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0NDYxNw==", "bodyText": "If signed headers is optional/can be set to None then please move these checks behind the if statement:\nif signed_headers is not None:\nWe are getting a CI error from tying to run len(signed_headers) when signed_headers = None", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367244617", "createdAt": "2020-01-16T06:06:02Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,307 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    \"\"\"\n+    def __init__(self, key_id=None, private_key_path=None, signing_scheme=None,\n+                 signing_algorithm=None, signature_max_validity=None, signed_headers=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        if self.signature_max_validity is None and \\\n+                signed_headers is not None and '(expires)' in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e4f43c64c5fd0e2ac0280dd2e200c999199ed28"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNjkwMzA0", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343690304", "createdAt": "2020-01-16T06:09:48Z", "commit": {"oid": "0e4f43c64c5fd0e2ac0280dd2e200c999199ed28"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNjowOTo0OVrOFeO5bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNjowOTo0OVrOFeO5bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0NTY3OA==", "bodyText": "Aren't resource_path and method required?\nIf so please make them positional arguments without setting them to None by default.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367245678", "createdAt": "2020-01-16T06:09:49Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -517,19 +522,34 @@ class ApiClient(object):\n         else:\n             return content_types[0]\n \n-    def update_params_for_auth(self, headers, querys, auth_settings):\n+    def update_params_for_auth(self, headers, querys, auth_settings,\n+                               resource_path=None, method=None, body=None):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e4f43c64c5fd0e2ac0280dd2e200c999199ed28"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2da37a26e77cbbaa576d0794777db2e78ab6f1b", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/c2da37a26e77cbbaa576d0794777db2e78ab6f1b", "committedDate": "2020-01-16T06:37:42Z", "message": "Address PR review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "581e4336132c90058fa77e2f7240109cd6527a47", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/581e4336132c90058fa77e2f7240109cd6527a47", "committedDate": "2020-01-16T06:40:33Z", "message": "Move 'private_key' field to signing module"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f60e2e9dbf90f1e55242513b3d99bb2bd4f74f5", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/5f60e2e9dbf90f1e55242513b3d99bb2bd4f74f5", "committedDate": "2020-01-16T06:45:44Z", "message": "Move 'private_key' field to signing module"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69d394d9bdf7bd55fffe8b631ac6f6e0449f999c", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/69d394d9bdf7bd55fffe8b631ac6f6e0449f999c", "committedDate": "2020-01-16T06:48:48Z", "message": "code cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ee3c0e31a2b2bea40e8cae53dc8d774779d1a9f", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/3ee3c0e31a2b2bea40e8cae53dc8d774779d1a9f", "committedDate": "2020-01-16T07:01:51Z", "message": "remove use of strftime('%s'), which is non portable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7787a7b5b0084b75be56ce1e84449b00b00c6002", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/7787a7b5b0084b75be56ce1e84449b00b00c6002", "committedDate": "2020-01-16T07:12:50Z", "message": "code cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b69dc7961692e5ec464607c3c8513a1513bec6a", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/8b69dc7961692e5ec464607c3c8513a1513bec6a", "committedDate": "2020-01-16T07:24:18Z", "message": "code cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f67523cb0c4e85d662caeac4ec0df2be1b4a642c", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/f67523cb0c4e85d662caeac4ec0df2be1b4a642c", "committedDate": "2020-01-16T07:36:40Z", "message": "code cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d169c6ef853d9fe72bb24092a25ca26ab74a1582", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/d169c6ef853d9fe72bb24092a25ca26ab74a1582", "committedDate": "2020-01-16T07:37:51Z", "message": "run sample scripts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/4148453c1a72f4ee6da15f00c7f934469a69f5a3", "committedDate": "2020-01-16T14:28:36Z", "message": "sync from mater"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "755335c2726d1e754e09e237b98c9e3082e969ed", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/755335c2726d1e754e09e237b98c9e3082e969ed", "committedDate": "2020-01-16T14:31:02Z", "message": "Merge remote-tracking branch 'origin' into http-signature"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDMxODY4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344031868", "createdAt": "2020-01-16T16:10:19Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNjoxMDoyMFrOFee8lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNjoxMDoyMFrOFee8lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwODYyOQ==", "bodyText": "This is not assigning a value.\nCan you change it to add the entry to the dict only if self.signing_info is not None?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367508629", "createdAt": "2020-01-16T16:10:20Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -318,6 +361,15 @@ class Configuration(object):\n                 'value': 'Bearer ' + self.access_token\n             }\n   {{/isBasicBearer}}\n+  {{#isHttpSignature}}\n+            '{{name}}':", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDM3MDMy", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344037032", "createdAt": "2020-01-16T16:16:55Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNjoxNjo1NVrOFefLxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNjoxNjo1NVrOFefLxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxMjUxNw==", "bodyText": "How about removing this for loop and changing it to\nheaders.update(auth_headerd)?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367512517", "createdAt": "2020-01-16T16:16:55Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -517,19 +521,37 @@ class ApiClient(object):\n         else:\n             return content_types[0]\n \n-    def update_params_for_auth(self, headers, querys, auth_settings):\n+    def update_params_for_auth(self, headers, querys, auth_settings,\n+                               resource_path, method, body):\n         \"\"\"Updates header and query params based on authentication setting.\n \n         :param headers: Header parameters dict to be updated.\n         :param querys: Query parameters tuple list to be updated.\n         :param auth_settings: Authentication setting identifiers list.\n+        :resource_path: A string representation of the HTTP request resource path.\n+        :method: A string representation of the HTTP request method.\n+        :body: A string representation of the body of the HTTP request.\n         \"\"\"\n         if not auth_settings:\n             return\n \n         for auth in auth_settings:\n             auth_setting = self.configuration.auth_settings().get(auth)\n             if auth_setting:\n+{{#hasHttpSignatureMethods}}\n+                if auth_setting['type'] == 'http-signature':\n+                    # The HTTP signature scheme requires multiple HTTP headers\n+                    # that are calculated dynamically.\n+                    signing_info = self.configuration.signing_info\n+                    if signing_info is None:\n+                        raise Exception(\"HTTP signature configuration is missing\")\n+                    auth_headers = signing_info.get_http_signature_headers(\n+                                        self.configuration.host, resource_path,\n+                                        method, headers, body, querys)\n+                    for key, value in auth_headers.items():", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDQ2MDk0", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344046094", "createdAt": "2020-01-16T16:28:23Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNjoyODoyM1rOFefnFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNjoyODoyM1rOFefnFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxOTUwOQ==", "bodyText": "If these are required, can you change them to positional arguments?\nCan we remove the signing_scheme default value? Why set it when three options are accepted for it? List default values are a dangerous practice in python because they are mutable so let's change signed_headers to be positional or use a tuple for its default value.\nWhich of these parameters are optional?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367519509", "createdAt": "2020-01-16T16:28:23Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDU2MDMw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344056030", "createdAt": "2020-01-16T16:41:10Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNjo0MToxMFrOFegFMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNjo0MToxMFrOFegFMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUyNzIxOQ==", "bodyText": "Would the private key change between api calls?\nHow about moving this in to the __init__ method.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367527219", "createdAt": "2020-01-16T16:41:10Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        # The '(created)' value MUST be a Unix timestamp integer value.\n+        # Subsecond precision is not supported.\n+        created = self.get_unix_time(int(now))\n+        if self.signature_max_validity is not None:\n+            expires = self.get_unix_time(now + self.signature_max_validity)\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == HEADER_REQUEST_TARGET:\n+                value = request_target\n+            elif hdr_key == HEADER_CREATED:\n+                value = '{0}'.format(created)\n+            elif hdr_key == HEADER_EXPIRES:\n+                value = '{0}'.format(expires)\n+            elif hdr_key == HEADER_DATE:\n+                value = cdate\n+                request_headers_dict[HEADER_DATE] = '{0}'.format(cdate)\n+            elif hdr_key == HEADER_DIGEST:\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict[HEADER_DIGEST] = '{0}{1}'.format(\n+                    digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == HEADER_HOST:\n+                value = target_host\n+                request_headers_dict[HEADER_HOST] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+            The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+            The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+            'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.signing_scheme in [SCHEME_RSA_SHA512, SCHEME_HS2019]:\n+            digest = SHA512.new()\n+            prefix = 'SHA-512='\n+        elif self.signing_scheme in [SCHEME_RSA_SHA256]:\n+            digest = SHA256.new()\n+            prefix = 'SHA-256='\n+        else:\n+            raise Exception(\"Unsupported signing algorithm: {0}\".format(self.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the signing_info.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.load_private_key()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 271}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDc0MDYx", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344074061", "createdAt": "2020-01-16T17:05:51Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowNTo1MlrOFeg7pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowNTo1MlrOFeg7pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MTE1Nw==", "bodyText": "Now changes depending upon what time zone the machine is in running this code.\nCan you add a constant time_zone which defaults to UTC in this class's __init__ method?\nThat way our user can specify what timezone now is calculated in.\nCan you update now an unix time zero to use that self.time_zone timezone?\nSee an example of timezone usage here: https://medium.com/@chaoren/datetime-to-unix-time-epoch-in-python-2-3-ecba6493e8b", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367541157", "createdAt": "2020-01-16T17:05:52Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 205}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDc3Njc3", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344077677", "createdAt": "2020-01-16T17:11:11Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxMToxMVrOFehGtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxMToxMVrOFehGtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0Mzk4OA==", "bodyText": "Can change this method's name to add a a _ or __ prefix so we can tell that it is not our publicly used method?\nSee\n\nhttp://python.robasworld.com/private-member-name-mangling/\nhttps://softwareengineering.stackexchange.com/questions/229804/usage-of-while-declaring-any-variables-or-class-member-in-python", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367543988", "createdAt": "2020-01-16T17:11:11Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDc3NzY5", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344077769", "createdAt": "2020-01-16T17:11:20Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxMToyMVrOFehG-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxMToyMVrOFehG-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDA1OA==", "bodyText": "Can change this method's name to add a a _ or __ prefix so we can tell that it is not our publicly used method?\nSee\n\nhttp://python.robasworld.com/private-member-name-mangling/\nhttps://softwareengineering.stackexchange.com/questions/229804/usage-of-while-declaring-any-variables-or-class-member-in-python", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367544058", "createdAt": "2020-01-16T17:11:21Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 171}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDc4MDE5", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344078019", "createdAt": "2020-01-16T17:11:44Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxMTo0NVrOFehH2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxMTo0NVrOFehH2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDI4MQ==", "bodyText": "Can change this method's name to add a a _ or __ prefix so we can tell that it is not our publicly used method?\nSee\n\nhttp://python.robasworld.com/private-member-name-mangling/\nhttps://softwareengineering.stackexchange.com/questions/229804/usage-of-while-declaring-any-variables-or-class-member-in-python", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367544281", "createdAt": "2020-01-16T17:11:45Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        # The '(created)' value MUST be a Unix timestamp integer value.\n+        # Subsecond precision is not supported.\n+        created = self.get_unix_time(int(now))\n+        if self.signature_max_validity is not None:\n+            expires = self.get_unix_time(now + self.signature_max_validity)\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == HEADER_REQUEST_TARGET:\n+                value = request_target\n+            elif hdr_key == HEADER_CREATED:\n+                value = '{0}'.format(created)\n+            elif hdr_key == HEADER_EXPIRES:\n+                value = '{0}'.format(expires)\n+            elif hdr_key == HEADER_DATE:\n+                value = cdate\n+                request_headers_dict[HEADER_DATE] = '{0}'.format(cdate)\n+            elif hdr_key == HEADER_DIGEST:\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict[HEADER_DIGEST] = '{0}{1}'.format(\n+                    digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == HEADER_HOST:\n+                value = target_host\n+                request_headers_dict[HEADER_HOST] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_message_digest(self, data):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 243}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDc4MTEw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344078110", "createdAt": "2020-01-16T17:11:53Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxMTo1NFrOFehIKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxMTo1NFrOFehIKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDM2MQ==", "bodyText": "Can change this method's name to add a a _ or __ prefix so we can tell that it is not our publicly used method?\nSee\n\nhttp://python.robasworld.com/private-member-name-mangling/\nhttps://softwareengineering.stackexchange.com/questions/229804/usage-of-while-declaring-any-variables-or-class-member-in-python", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367544361", "createdAt": "2020-01-16T17:11:54Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        # The '(created)' value MUST be a Unix timestamp integer value.\n+        # Subsecond precision is not supported.\n+        created = self.get_unix_time(int(now))\n+        if self.signature_max_validity is not None:\n+            expires = self.get_unix_time(now + self.signature_max_validity)\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == HEADER_REQUEST_TARGET:\n+                value = request_target\n+            elif hdr_key == HEADER_CREATED:\n+                value = '{0}'.format(created)\n+            elif hdr_key == HEADER_EXPIRES:\n+                value = '{0}'.format(expires)\n+            elif hdr_key == HEADER_DATE:\n+                value = cdate\n+                request_headers_dict[HEADER_DATE] = '{0}'.format(cdate)\n+            elif hdr_key == HEADER_DIGEST:\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict[HEADER_DIGEST] = '{0}{1}'.format(\n+                    digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == HEADER_HOST:\n+                value = target_host\n+                request_headers_dict[HEADER_HOST] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+            The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+            The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+            'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.signing_scheme in [SCHEME_RSA_SHA512, SCHEME_HS2019]:\n+            digest = SHA512.new()\n+            prefix = 'SHA-512='\n+        elif self.signing_scheme in [SCHEME_RSA_SHA256]:\n+            digest = SHA256.new()\n+            prefix = 'SHA-256='\n+        else:\n+            raise Exception(\"Unsupported signing algorithm: {0}\".format(self.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 264}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDc4Njcw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344078670", "createdAt": "2020-01-16T17:12:46Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxMjo0NlrOFehJyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxMjo0NlrOFehJyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDc3OA==", "bodyText": "Can change this method's name to add a a _ or __ prefix so we can tell that it is not our publicly used method?\nSee\n\nhttp://python.robasworld.com/private-member-name-mangling/\nhttps://softwareengineering.stackexchange.com/questions/229804/usage-of-while-declaring-any-variables-or-class-member-in-python", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367544778", "createdAt": "2020-01-16T17:12:46Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        # The '(created)' value MUST be a Unix timestamp integer value.\n+        # Subsecond precision is not supported.\n+        created = self.get_unix_time(int(now))\n+        if self.signature_max_validity is not None:\n+            expires = self.get_unix_time(now + self.signature_max_validity)\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == HEADER_REQUEST_TARGET:\n+                value = request_target\n+            elif hdr_key == HEADER_CREATED:\n+                value = '{0}'.format(created)\n+            elif hdr_key == HEADER_EXPIRES:\n+                value = '{0}'.format(expires)\n+            elif hdr_key == HEADER_DATE:\n+                value = cdate\n+                request_headers_dict[HEADER_DATE] = '{0}'.format(cdate)\n+            elif hdr_key == HEADER_DIGEST:\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict[HEADER_DIGEST] = '{0}{1}'.format(\n+                    digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == HEADER_HOST:\n+                value = target_host\n+                request_headers_dict[HEADER_HOST] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+            The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+            The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+            'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.signing_scheme in [SCHEME_RSA_SHA512, SCHEME_HS2019]:\n+            digest = SHA512.new()\n+            prefix = 'SHA-512='\n+        elif self.signing_scheme in [SCHEME_RSA_SHA256]:\n+            digest = SHA256.new()\n+            prefix = 'SHA-256='\n+        else:\n+            raise Exception(\"Unsupported signing algorithm: {0}\".format(self.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the signing_info.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.load_private_key()\n+        sig_alg = self.signing_algorithm\n+        if isinstance(self.private_key, RSA.RsaKey):\n+            if sig_alg is None or sig_alg == ALGORITHM_RSASSA_PSS:\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(self.private_key).sign(digest)\n+            elif sig_alg == ALGORITHM_RSASSA_PKCS1v15:\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(self.private_key).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(sig_alg))\n+        elif isinstance(self.private_key, ECC.EccKey):\n+            if sig_alg is None:\n+                sig_alg = ALGORITHM_ECDSA_MODE_FIPS_186_3\n+            if sig_alg in ECDSA_KEY_SIGNING_ALGORITHMS:\n+                signature = DSS.new(self.private_key, sig_alg).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(sig_alg))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(self.private_key)))\n+        return b64encode(signature)\n+\n+    def get_authorization_header(self, signed_headers, signed_msg):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 293}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDc5NjEz", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344079613", "createdAt": "2020-01-16T17:14:20Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxNDoyMFrOFehM4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxNDoyMFrOFehM4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NTU2OQ==", "bodyText": "Can change this method's name to add a a _ or __ prefix so we can tell that it is not our publicly used method?\nSee\n\nhttp://python.robasworld.com/private-member-name-mangling/\nhttps://softwareengineering.stackexchange.com/questions/229804/usage-of-while-declaring-any-variables-or-class-member-in-python", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367545569", "createdAt": "2020-01-16T17:14:20Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 177}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDgyOTA0", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344082904", "createdAt": "2020-01-16T17:19:23Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxOToyNFrOFehWtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxOToyNFrOFehWtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0ODA4Nw==", "bodyText": "Is host unchanging?\nIf so, why not pass it in or pass in our configuration instance to this class's __init__ method?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367548087", "createdAt": "2020-01-16T17:19:24Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDkwNDcy", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344090472", "createdAt": "2020-01-16T17:31:41Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzozMTo0MlrOFehtbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzozMTo0MlrOFehtbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1MzkwMg==", "bodyText": "If we only add the signing_info instance to the auth_setting dict if self.signing_info is not None in configuration.py, then how about we delete this if statement and exception raising?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367553902", "createdAt": "2020-01-16T17:31:42Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -517,19 +521,37 @@ class ApiClient(object):\n         else:\n             return content_types[0]\n \n-    def update_params_for_auth(self, headers, querys, auth_settings):\n+    def update_params_for_auth(self, headers, querys, auth_settings,\n+                               resource_path, method, body):\n         \"\"\"Updates header and query params based on authentication setting.\n \n         :param headers: Header parameters dict to be updated.\n         :param querys: Query parameters tuple list to be updated.\n         :param auth_settings: Authentication setting identifiers list.\n+        :resource_path: A string representation of the HTTP request resource path.\n+        :method: A string representation of the HTTP request method.\n+        :body: A string representation of the body of the HTTP request.\n         \"\"\"\n         if not auth_settings:\n             return\n \n         for auth in auth_settings:\n             auth_setting = self.configuration.auth_settings().get(auth)\n             if auth_setting:\n+{{#hasHttpSignatureMethods}}\n+                if auth_setting['type'] == 'http-signature':\n+                    # The HTTP signature scheme requires multiple HTTP headers\n+                    # that are calculated dynamically.\n+                    signing_info = self.configuration.signing_info\n+                    if signing_info is None:\n+                        raise Exception(\"HTTP signature configuration is missing\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDkyOTc0", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344092974", "createdAt": "2020-01-16T17:35:49Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzozNTo0OVrOFeh0ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzozNTo0OVrOFeh0ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NTc3OQ==", "bodyText": "Is this a specific if statement that can be included in the below if/elif case handling?\nHow about\n\nchanging this if statement to if auth_setting['in'] == 'header' and auth_setting['type'] == 'http-signature':\ndeleting the continue line from the bottom of this if block\nchange if auth_setting['in'] == 'cookie': to elif auth_setting['in'] == 'cookie':", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367555779", "createdAt": "2020-01-16T17:35:49Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -517,19 +521,37 @@ class ApiClient(object):\n         else:\n             return content_types[0]\n \n-    def update_params_for_auth(self, headers, querys, auth_settings):\n+    def update_params_for_auth(self, headers, querys, auth_settings,\n+                               resource_path, method, body):\n         \"\"\"Updates header and query params based on authentication setting.\n \n         :param headers: Header parameters dict to be updated.\n         :param querys: Query parameters tuple list to be updated.\n         :param auth_settings: Authentication setting identifiers list.\n+        :resource_path: A string representation of the HTTP request resource path.\n+        :method: A string representation of the HTTP request method.\n+        :body: A string representation of the body of the HTTP request.\n         \"\"\"\n         if not auth_settings:\n             return\n \n         for auth in auth_settings:\n             auth_setting = self.configuration.auth_settings().get(auth)\n             if auth_setting:\n+{{#hasHttpSignatureMethods}}\n+                if auth_setting['type'] == 'http-signature':", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDkzNTI4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344093528", "createdAt": "2020-01-16T17:36:48Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzozNjo0OFrOFeh2ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzozNjo0OFrOFeh2ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NjE5Ng==", "bodyText": "Can you add type here? It is string, right?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367556196", "createdAt": "2020-01-16T17:36:48Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDkzODk3", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344093897", "createdAt": "2020-01-16T17:37:27Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzozNzoyN1rOFeh3ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzozNzoyN1rOFeh3ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NjUxNQ==", "bodyText": "Can you add type here? The string path", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367556515", "createdAt": "2020-01-16T17:37:27Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDk0ODAz", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344094803", "createdAt": "2020-01-16T17:38:58Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzozODo1OFrOFeh6QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzozODo1OFrOFeh6QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NzE4NQ==", "bodyText": "Can you add type here?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367557185", "createdAt": "2020-01-16T17:38:58Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDk1Mzgw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344095380", "createdAt": "2020-01-16T17:39:56Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzozOTo1N1rOFeh75Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzozOTo1N1rOFeh75Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NzYwNQ==", "bodyText": "Can you update this to list the three accepted values here?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367557605", "createdAt": "2020-01-16T17:39:57Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDk1OTIw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344095920", "createdAt": "2020-01-16T17:40:51Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo0MDo1MlrOFeh9hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo0MDo1MlrOFeh9hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1ODAyMw==", "bodyText": "Optionally remove this. Our context is python and we know that this is a constructor.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367558023", "createdAt": "2020-01-16T17:40:52Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDk2NDU0", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344096454", "createdAt": "2020-01-16T17:41:47Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo0MTo0OFrOFeh_Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo0MTo0OFrOFeh_Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1ODQxNA==", "bodyText": "Can you include your clearer description here?\n           For RSA keys, supported values are PKCS1v15, PSS.\n           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367558414", "createdAt": "2020-01-16T17:41:48Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDk4OTQx", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344098941", "createdAt": "2020-01-16T17:46:01Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo0NjowMVrOFeiGfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo0NjowMVrOFeiGfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MDMxNw==", "bodyText": "Can you have all the docstring info on these parameters in the top of the class or here in the __init__ dosctring but not both?\nPython std practice is to put it in one of those places but not both. So if you want to keep it in the class can you delete these comments describing these params?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367560317", "createdAt": "2020-01-16T17:46:01Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MTAyMzE2", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344102316", "createdAt": "2020-01-16T17:51:43Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo1MTo0M1rOFeiQ5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo1MTo0M1rOFeiQ5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2Mjk4MQ==", "bodyText": "Optionally change this to elif self.signing_scheme == SCHEME_RSA_SHA256:", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367562981", "createdAt": "2020-01-16T17:51:43Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        # The '(created)' value MUST be a Unix timestamp integer value.\n+        # Subsecond precision is not supported.\n+        created = self.get_unix_time(int(now))\n+        if self.signature_max_validity is not None:\n+            expires = self.get_unix_time(now + self.signature_max_validity)\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == HEADER_REQUEST_TARGET:\n+                value = request_target\n+            elif hdr_key == HEADER_CREATED:\n+                value = '{0}'.format(created)\n+            elif hdr_key == HEADER_EXPIRES:\n+                value = '{0}'.format(expires)\n+            elif hdr_key == HEADER_DATE:\n+                value = cdate\n+                request_headers_dict[HEADER_DATE] = '{0}'.format(cdate)\n+            elif hdr_key == HEADER_DIGEST:\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict[HEADER_DIGEST] = '{0}{1}'.format(\n+                    digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == HEADER_HOST:\n+                value = target_host\n+                request_headers_dict[HEADER_HOST] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+            The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+            The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+            'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.signing_scheme in [SCHEME_RSA_SHA512, SCHEME_HS2019]:\n+            digest = SHA512.new()\n+            prefix = 'SHA-512='\n+        elif self.signing_scheme in [SCHEME_RSA_SHA256]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 256}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MTAyOTU5", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344102959", "createdAt": "2020-01-16T17:52:42Z", "commit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo1Mjo0M1rOFeiSwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo1Mjo0M1rOFeiSwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MzQ1OA==", "bodyText": "Optionally change this to if self.signing_scheme in {SCHEME_RSA_SHA512, SCHEME_HS2019}:\nSet inclusion is quicker than list inclusion.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367563458", "createdAt": "2020-01-16T17:52:43Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        # The '(created)' value MUST be a Unix timestamp integer value.\n+        # Subsecond precision is not supported.\n+        created = self.get_unix_time(int(now))\n+        if self.signature_max_validity is not None:\n+            expires = self.get_unix_time(now + self.signature_max_validity)\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == HEADER_REQUEST_TARGET:\n+                value = request_target\n+            elif hdr_key == HEADER_CREATED:\n+                value = '{0}'.format(created)\n+            elif hdr_key == HEADER_EXPIRES:\n+                value = '{0}'.format(expires)\n+            elif hdr_key == HEADER_DATE:\n+                value = cdate\n+                request_headers_dict[HEADER_DATE] = '{0}'.format(cdate)\n+            elif hdr_key == HEADER_DIGEST:\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict[HEADER_DIGEST] = '{0}{1}'.format(\n+                    digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == HEADER_HOST:\n+                value = target_host\n+                request_headers_dict[HEADER_HOST] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+            The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+            The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+            'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.signing_scheme in [SCHEME_RSA_SHA512, SCHEME_HS2019]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3"}, "originalPosition": 253}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06d25b932f678576baee23807e0d469541a706fa", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/06d25b932f678576baee23807e0d469541a706fa", "committedDate": "2020-01-16T20:28:48Z", "message": "Address PR review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bf286fb797700ab91735adae9c3989b16d819a7", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/1bf286fb797700ab91735adae9c3989b16d819a7", "committedDate": "2020-01-17T00:17:31Z", "message": "Add http-signature security scheme"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "517019545f2258920644e558937b2ab8c28b0794", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/517019545f2258920644e558937b2ab8c28b0794", "committedDate": "2020-01-17T00:56:48Z", "message": "Run sample scripts for go"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MzE0MDkz", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344314093", "createdAt": "2020-01-17T01:10:45Z", "commit": {"oid": "06d25b932f678576baee23807e0d469541a706fa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMToxMDo0NVrOFesTWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMToxMDo0NVrOFesTWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNzQ1MA==", "bodyText": "Can you remove this import?\nHttpSigningConfiguration now exists inside this module", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367727450", "createdAt": "2020-01-17T01:10:45Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,315 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06d25b932f678576baee23807e0d469541a706fa"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de10ae09c4bd5751a125a6194f281511375df07f", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/de10ae09c4bd5751a125a6194f281511375df07f", "committedDate": "2020-01-17T01:16:22Z", "message": "Fix issue uncovered in integration branch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MzE2Mzk2", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344316396", "createdAt": "2020-01-17T01:19:01Z", "commit": {"oid": "06d25b932f678576baee23807e0d469541a706fa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMToxOTowMlrOFesalg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMToxOTowMlrOFesalg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyOTMwMg==", "bodyText": "Should this class be changed from Configuration to HttpSigningConfiguration?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367729302", "createdAt": "2020-01-17T01:19:02Z", "author": {"login": "spacether"}, "path": "samples/client/petstore/python-experimental/tests/test_pet_api.py", "diffHunk": "@@ -175,6 +175,36 @@ def test_separate_default_config_instances(self):\n         pet_api2.api_client.configuration.host = 'someotherhost'\n         self.assertNotEqual(pet_api.api_client.configuration.host, pet_api2.api_client.configuration.host)\n \n+    def test_http_signature(self):\n+        config = Configuration(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06d25b932f678576baee23807e0d469541a706fa"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01766941fe8033cfbcdefa1c434c0d4f456cedd7", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/01766941fe8033cfbcdefa1c434c0d4f456cedd7", "committedDate": "2020-01-17T01:20:55Z", "message": "Fix issue uncovered in integration branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "155f55497cf3a17b0838a2df85dc64d5011a3d77", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/155f55497cf3a17b0838a2df85dc64d5011a3d77", "committedDate": "2020-01-17T01:23:20Z", "message": "Fix issue uncovered in integration branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0426487ff224c8eabd2a94172bc980de462a3ff4", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/0426487ff224c8eabd2a94172bc980de462a3ff4", "committedDate": "2020-01-17T01:26:51Z", "message": "Fix issue uncovered in integration branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cfefa0a8d8a5a6d8c68ea50bd435e326220b8e0", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/6cfefa0a8d8a5a6d8c68ea50bd435e326220b8e0", "committedDate": "2020-01-17T01:31:44Z", "message": "Run samples scripts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8866584ae40fe339427aa0cef514c66fdda8722", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/c8866584ae40fe339427aa0cef514c66fdda8722", "committedDate": "2020-01-17T01:55:43Z", "message": "move http signature tests to separate file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7a01ec4c3771ea2642f1ee59b08aa499bf211f5", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/c7a01ec4c3771ea2642f1ee59b08aa499bf211f5", "committedDate": "2020-01-17T02:00:59Z", "message": "move http signature tests to separate file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ceda7840f23075be72f351256fd7b84dc984728", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/3ceda7840f23075be72f351256fd7b84dc984728", "committedDate": "2020-01-17T02:52:18Z", "message": "unit tests for HTTP signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "707d40bfa7d6599b2a2f7a9abe38696e8182653a", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/707d40bfa7d6599b2a2f7a9abe38696e8182653a", "committedDate": "2020-01-17T04:48:21Z", "message": "continue implementation of unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef59c0ca45c721b5163126895a01032faa930bda", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/ef59c0ca45c721b5163126895a01032faa930bda", "committedDate": "2020-01-17T04:49:27Z", "message": "add http_signature_test to security scheme"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0Mzg3MTMw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344387130", "createdAt": "2020-01-17T06:41:47Z", "commit": {"oid": "707d40bfa7d6599b2a2f7a9abe38696e8182653a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNjo0MTo0N1rOFewCkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNjo1Mzo0OFrOFewNTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc4ODY4OA==", "bodyText": "Can you delete this note line and the comment line below it?\nThey are not needed", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367788688", "createdAt": "2020-01-17T06:41:47Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -533,7 +541,19 @@ class ApiClient(object):\n                 if auth_setting['in'] == 'cookie':\n                     headers['Cookie'] = auth_setting['value']\n                 elif auth_setting['in'] == 'header':\n-                    headers[auth_setting['key']] = auth_setting['value']\n+                    if auth_setting['type'] != 'http-signature':\n+                        headers[auth_setting['key']] = auth_setting['value']\n+{{#hasHttpSignatureMethods}}\n+                    else:\n+                        # The HTTP signature scheme requires multiple HTTP headers\n+                        # that are calculated dynamically.\n+                        signing_info = self.configuration.signing_info\n+                        # NOTE: no need to raise an exception because this entry only exists", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "707d40bfa7d6599b2a2f7a9abe38696e8182653a"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5MTQzNg==", "bodyText": "How does this check results from the mock _pool?\nCan we verify that the signed data is eqal to a specific value?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367791436", "createdAt": "2020-01-17T06:53:48Z", "author": {"login": "spacether"}, "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,164 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+import json\n+import os\n+import unittest\n+import shutil\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# Test RSA private key as published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        self._tc.assertEqual(r[0], args)\n+        self._tc.assertEqual(r[1], kwargs)\n+        return urllib3.HTTPResponse(status=200, body=b'test')\n+\n+\n+class PetApiTests(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.setUpModels()\n+        self.setUpFiles()\n+\n+    def tearDown(self):\n+        if os.path.exists(self.rsa_key_path):\n+            os.unlink(self.rsa_key_path)\n+\n+    def setUpModels(self):\n+        self.category = petstore_api.Category()\n+        self.category.id = id_gen()\n+        self.category.name = \"dog\"\n+        self.tag = petstore_api.Tag()\n+        self.tag.id = id_gen()\n+        self.tag.name = \"python-pet-tag\"\n+        self.pet = petstore_api.Pet(name=\"hello kity\", photo_urls=[\"http://foo.bar.com/1\", \"http://foo.bar.com/2\"])\n+        self.pet.id = id_gen()\n+        self.pet.status = \"sold\"\n+        self.pet.category = self.category\n+        self.pet.tags = [self.tag]\n+\n+    def setUpFiles(self):\n+        self.test_file_dir = os.path.join(os.path.dirname(__file__), \"..\", \"testfiles\")\n+        self.test_file_dir = os.path.realpath(self.test_file_dir)\n+        if not os.path.exists(self.test_file_dir):\n+            os.mkdir(self.test_file_dir)\n+        self.rsa_key_path = os.path.join(self.test_file_dir, 'rsa.pem')\n+\n+    def test_http_signature(self):\n+        with open(self.rsa_key_path, 'w') as f:\n+          f.write(RSA_TEST_PRIVATE_KEY)\n+\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+                signing.HEADER_HOST,\n+                signing.HEADER_DATE,\n+                signing.HEADER_DIGEST,\n+                'Content-Type'\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://localhost/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Bearer ',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=TimeoutWithEqual(total=5))\n+        mock_pool.expect_request('POST', 'http://localhost/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Bearer ',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=TimeoutWithEqual(connect=1, read=2))\n+\n+        pet_api.add_pet(self.pet, _request_timeout=5)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "707d40bfa7d6599b2a2f7a9abe38696e8182653a"}, "originalPosition": 161}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9dacccaa763a35c9c856e4173e952b6b654a915e", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/9dacccaa763a35c9c856e4173e952b6b654a915e", "committedDate": "2020-01-17T08:04:24Z", "message": "add unit tests for http signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5355566335a2c4afb6c2b9296026ec1a04a9db60", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/5355566335a2c4afb6c2b9296026ec1a04a9db60", "committedDate": "2020-01-17T08:15:33Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f7cbb1ec75ddd1f18ca4b67ff8fa28678306679", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/0f7cbb1ec75ddd1f18ca4b67ff8fa28678306679", "committedDate": "2020-01-17T16:19:31Z", "message": "Merge branch 'master' into http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8dea28d02889b1648bfdc353244610e436dde6d", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/f8dea28d02889b1648bfdc353244610e436dde6d", "committedDate": "2020-01-17T16:21:11Z", "message": "remove http signature from petapi"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d33f6b694b170cd4c8382d098702bdd09599ae0e", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/d33f6b694b170cd4c8382d098702bdd09599ae0e", "committedDate": "2020-01-17T16:21:35Z", "message": "Merge remote-tracking branch 'origin' into python-http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd", "committedDate": "2020-01-17T16:21:51Z", "message": "Merge branch 'http-signature' into python-http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21e35f0cfeabef0d5cf51043872ea96bd418406d", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/21e35f0cfeabef0d5cf51043872ea96bd418406d", "committedDate": "2020-01-17T16:23:29Z", "message": "Add separate OAS file with support for HTTP signature"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NzAyNTg4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344702588", "createdAt": "2020-01-17T16:40:15Z", "commit": {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo0MDoxNlrOFe-wdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo0MDoxNlrOFe-wdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyOTgxNA==", "bodyText": "Why is this file in this update?\nCan we switch go to use the new spec in the go-experimental PR?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368029814", "createdAt": "2020-01-17T16:40:16Z", "author": {"login": "spacether"}, "path": "samples/openapi3/client/petstore/go-experimental/go-petstore/api/openapi.yaml", "diffHunk": "@@ -54,7 +54,7 @@ paths:\n       requestBody:\n         $ref: '#/components/requestBodies/Pet'\n       responses:\n-        405:\n+        \"405\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NzA3NjM5", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344707639", "createdAt": "2020-01-17T16:48:08Z", "commit": {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo0ODowOFrOFe-_uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo0ODowOFrOFe-_uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMzcyMw==", "bodyText": "Silly question but:\nCan you verify that this key is was generated only for this testing?\nOptionally, how about:\n\ngenerate the rsa key on the fly with:\n\nfrom os import chmod\nfrom Crypto.PublicKey import RSA\n\nkey = RSA.generate(2048)\nwith open(\"/tmp/private.key\", 'wb') as content_file:\n    chmod(\"/tmp/private.key\", 0600)\n    content_file.write(key.exportKey('PEM'))\npubkey = key.publickey()\nwith open(\"/tmp/public.key\", 'wb') as content_file:\n    content_file.write(pubkey.exportKey('OpenSSH'))\n\nper https://stackoverflow.com/questions/2466401/how-to-generate-ssh-key-pairs-with-python\n\ngenerating the rsa key on the fly by invoking ssh-keygen\nor moving this data to a file in a testfiles folder like we do for other file assets https://github.com/OpenAPITools/openapi-generator/tree/master/samples/client/petstore/python-experimental/testfiles", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368033723", "createdAt": "2020-01-17T16:48:08Z", "author": {"login": "spacether"}, "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,370 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.PublicKey import RSA\n+from Crypto.PublicKey import ECC\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# Test RSA private key as published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NzA5MjYw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344709260", "createdAt": "2020-01-17T16:50:45Z", "commit": {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1MDo0NVrOFe_EiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1MDo0NVrOFe_EiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNDk1Mw==", "bodyText": "Can you decode the request using the key to show that you get back the unencrypted data to verify that this is working?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368034953", "createdAt": "2020-01-17T16:50:45Z", "author": {"login": "spacether"}, "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,370 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.PublicKey import RSA\n+from Crypto.PublicKey import ECC\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# Test RSA private key as published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        # r[0] is the expected HTTP method, URL.\n+        # args is the actual HTTP method, URL.\n+        self._tc.assertEqual(r[0], args)\n+        # r[1] is a dict that contains the expected body, headers\n+        # kwargs is a dict that contains the actual body, headers\n+        for k, expected in r[1].items():\n+            self._tc.assertIn(k, kwargs)\n+            actual = kwargs[k]\n+            if k == 'body':\n+                self._tc.assertEqual(expected, actual)\n+            elif k == 'headers':\n+                for expected_header_name, expected_header_value in expected.items():\n+                    self._tc.assertIn(expected_header_name, actual)\n+                    actual_header_value = actual[expected_header_name]\n+                    pattern = re.compile(expected_header_value)\n+                    m = pattern.match(actual_header_value)\n+                    self._tc.assertTrue(m, msg=\"Expected:\\n{0}\\nActual:\\n{1}\".format(\n+                                        expected_header_value,actual_header_value))\n+            elif k == 'timeout':\n+                self._tc.assertEqual(expected, actual)\n+        return urllib3.HTTPResponse(status=200, body=b'test')\n+\n+\n+class PetApiTests(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.setUpModels()\n+        self.setUpFiles()\n+\n+\n+    def setUpModels(self):\n+        self.category = petstore_api.Category()\n+        self.category.id = id_gen()\n+        self.category.name = \"dog\"\n+        self.tag = petstore_api.Tag()\n+        self.tag.id = id_gen()\n+        self.tag.name = \"python-pet-tag\"\n+        self.pet = petstore_api.Pet(name=\"hello kity\", photo_urls=[\"http://foo.bar.com/1\", \"http://foo.bar.com/2\"])\n+        self.pet.id = id_gen()\n+        self.pet.status = \"sold\"\n+        self.pet.category = self.category\n+        self.pet.tags = [self.tag]\n+\n+    def setUpFiles(self):\n+        self.test_file_dir = os.path.join(os.path.dirname(__file__), \"..\", \"testfiles\")\n+        self.test_file_dir = os.path.realpath(self.test_file_dir)\n+        if not os.path.exists(self.test_file_dir):\n+            os.mkdir(self.test_file_dir)\n+\n+        self.rsa_key_path = os.path.join(self.test_file_dir, 'rsa.pem')\n+        self.rsa4096_key_path = os.path.join(self.test_file_dir, 'rsa4096.pem')\n+        self.ec_p521_key_path = os.path.join(self.test_file_dir, 'ecP521.pem')\n+\n+        if not os.path.exists(self.rsa_key_path):\n+            with open(self.rsa_key_path, 'w') as f:\n+                f.write(RSA_TEST_PRIVATE_KEY)\n+\n+        if not os.path.exists(self.rsa4096_key_path):\n+            key = RSA.generate(4096)\n+            private_key = key.export_key()\n+            with open(self.rsa4096_key_path, \"wb\") as f:\n+                f.write(private_key)\n+\n+        if not os.path.exists(self.ec_p521_key_path):\n+            key = ECC.generate(curve='P-521')\n+            private_key = key.export_key(format='PEM')\n+            with open(self.ec_p521_key_path, \"wt\") as f:\n+                f.write(private_key)\n+\n+    def test_valid_http_signature(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+                signing.HEADER_HOST,\n+                signing.HEADER_DATE,\n+                signing.HEADER_DIGEST,\n+                'Content-Type'\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\) host date digest content-type\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_with_defaults(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd"}, "originalPosition": 220}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NzA5NDgy", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344709482", "createdAt": "2020-01-17T16:51:04Z", "commit": {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1MTowNVrOFe_FVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1MTowNVrOFe_FVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNTE1Nw==", "bodyText": "Can you decode the request using the key to show that you get back the unencrypted data to verify that this is working?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368035157", "createdAt": "2020-01-17T16:51:05Z", "author": {"login": "spacether"}, "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,370 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.PublicKey import RSA\n+from Crypto.PublicKey import ECC\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# Test RSA private key as published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        # r[0] is the expected HTTP method, URL.\n+        # args is the actual HTTP method, URL.\n+        self._tc.assertEqual(r[0], args)\n+        # r[1] is a dict that contains the expected body, headers\n+        # kwargs is a dict that contains the actual body, headers\n+        for k, expected in r[1].items():\n+            self._tc.assertIn(k, kwargs)\n+            actual = kwargs[k]\n+            if k == 'body':\n+                self._tc.assertEqual(expected, actual)\n+            elif k == 'headers':\n+                for expected_header_name, expected_header_value in expected.items():\n+                    self._tc.assertIn(expected_header_name, actual)\n+                    actual_header_value = actual[expected_header_name]\n+                    pattern = re.compile(expected_header_value)\n+                    m = pattern.match(actual_header_value)\n+                    self._tc.assertTrue(m, msg=\"Expected:\\n{0}\\nActual:\\n{1}\".format(\n+                                        expected_header_value,actual_header_value))\n+            elif k == 'timeout':\n+                self._tc.assertEqual(expected, actual)\n+        return urllib3.HTTPResponse(status=200, body=b'test')\n+\n+\n+class PetApiTests(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.setUpModels()\n+        self.setUpFiles()\n+\n+\n+    def setUpModels(self):\n+        self.category = petstore_api.Category()\n+        self.category.id = id_gen()\n+        self.category.name = \"dog\"\n+        self.tag = petstore_api.Tag()\n+        self.tag.id = id_gen()\n+        self.tag.name = \"python-pet-tag\"\n+        self.pet = petstore_api.Pet(name=\"hello kity\", photo_urls=[\"http://foo.bar.com/1\", \"http://foo.bar.com/2\"])\n+        self.pet.id = id_gen()\n+        self.pet.status = \"sold\"\n+        self.pet.category = self.category\n+        self.pet.tags = [self.tag]\n+\n+    def setUpFiles(self):\n+        self.test_file_dir = os.path.join(os.path.dirname(__file__), \"..\", \"testfiles\")\n+        self.test_file_dir = os.path.realpath(self.test_file_dir)\n+        if not os.path.exists(self.test_file_dir):\n+            os.mkdir(self.test_file_dir)\n+\n+        self.rsa_key_path = os.path.join(self.test_file_dir, 'rsa.pem')\n+        self.rsa4096_key_path = os.path.join(self.test_file_dir, 'rsa4096.pem')\n+        self.ec_p521_key_path = os.path.join(self.test_file_dir, 'ecP521.pem')\n+\n+        if not os.path.exists(self.rsa_key_path):\n+            with open(self.rsa_key_path, 'w') as f:\n+                f.write(RSA_TEST_PRIVATE_KEY)\n+\n+        if not os.path.exists(self.rsa4096_key_path):\n+            key = RSA.generate(4096)\n+            private_key = key.export_key()\n+            with open(self.rsa4096_key_path, \"wb\") as f:\n+                f.write(private_key)\n+\n+        if not os.path.exists(self.ec_p521_key_path):\n+            key = ECC.generate(curve='P-521')\n+            private_key = key.export_key(format='PEM')\n+            with open(self.ec_p521_key_path, \"wt\") as f:\n+                f.write(private_key)\n+\n+    def test_valid_http_signature(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+                signing.HEADER_HOST,\n+                signing.HEADER_DATE,\n+                signing.HEADER_DIGEST,\n+                'Content-Type'\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\) host date digest content-type\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_with_defaults(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_rsassa_pkcs1v15(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd"}, "originalPosition": 253}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NzA5NTU0", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344709554", "createdAt": "2020-01-17T16:51:11Z", "commit": {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1MToxMVrOFe_Fnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1MToxMVrOFe_Fnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNTIzMQ==", "bodyText": "Can you decode the request using the key to show that you get back the unencrypted data to verify that this is working?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368035231", "createdAt": "2020-01-17T16:51:11Z", "author": {"login": "spacether"}, "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,370 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.PublicKey import RSA\n+from Crypto.PublicKey import ECC\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# Test RSA private key as published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        # r[0] is the expected HTTP method, URL.\n+        # args is the actual HTTP method, URL.\n+        self._tc.assertEqual(r[0], args)\n+        # r[1] is a dict that contains the expected body, headers\n+        # kwargs is a dict that contains the actual body, headers\n+        for k, expected in r[1].items():\n+            self._tc.assertIn(k, kwargs)\n+            actual = kwargs[k]\n+            if k == 'body':\n+                self._tc.assertEqual(expected, actual)\n+            elif k == 'headers':\n+                for expected_header_name, expected_header_value in expected.items():\n+                    self._tc.assertIn(expected_header_name, actual)\n+                    actual_header_value = actual[expected_header_name]\n+                    pattern = re.compile(expected_header_value)\n+                    m = pattern.match(actual_header_value)\n+                    self._tc.assertTrue(m, msg=\"Expected:\\n{0}\\nActual:\\n{1}\".format(\n+                                        expected_header_value,actual_header_value))\n+            elif k == 'timeout':\n+                self._tc.assertEqual(expected, actual)\n+        return urllib3.HTTPResponse(status=200, body=b'test')\n+\n+\n+class PetApiTests(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.setUpModels()\n+        self.setUpFiles()\n+\n+\n+    def setUpModels(self):\n+        self.category = petstore_api.Category()\n+        self.category.id = id_gen()\n+        self.category.name = \"dog\"\n+        self.tag = petstore_api.Tag()\n+        self.tag.id = id_gen()\n+        self.tag.name = \"python-pet-tag\"\n+        self.pet = petstore_api.Pet(name=\"hello kity\", photo_urls=[\"http://foo.bar.com/1\", \"http://foo.bar.com/2\"])\n+        self.pet.id = id_gen()\n+        self.pet.status = \"sold\"\n+        self.pet.category = self.category\n+        self.pet.tags = [self.tag]\n+\n+    def setUpFiles(self):\n+        self.test_file_dir = os.path.join(os.path.dirname(__file__), \"..\", \"testfiles\")\n+        self.test_file_dir = os.path.realpath(self.test_file_dir)\n+        if not os.path.exists(self.test_file_dir):\n+            os.mkdir(self.test_file_dir)\n+\n+        self.rsa_key_path = os.path.join(self.test_file_dir, 'rsa.pem')\n+        self.rsa4096_key_path = os.path.join(self.test_file_dir, 'rsa4096.pem')\n+        self.ec_p521_key_path = os.path.join(self.test_file_dir, 'ecP521.pem')\n+\n+        if not os.path.exists(self.rsa_key_path):\n+            with open(self.rsa_key_path, 'w') as f:\n+                f.write(RSA_TEST_PRIVATE_KEY)\n+\n+        if not os.path.exists(self.rsa4096_key_path):\n+            key = RSA.generate(4096)\n+            private_key = key.export_key()\n+            with open(self.rsa4096_key_path, \"wb\") as f:\n+                f.write(private_key)\n+\n+        if not os.path.exists(self.ec_p521_key_path):\n+            key = ECC.generate(curve='P-521')\n+            private_key = key.export_key(format='PEM')\n+            with open(self.ec_p521_key_path, \"wt\") as f:\n+                f.write(private_key)\n+\n+    def test_valid_http_signature(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+                signing.HEADER_HOST,\n+                signing.HEADER_DATE,\n+                signing.HEADER_DIGEST,\n+                'Content-Type'\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\) host date digest content-type\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_with_defaults(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_rsassa_pkcs1v15(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_rsassa_pss(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PSS,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd"}, "originalPosition": 277}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NzA5NjQx", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344709641", "createdAt": "2020-01-17T16:51:20Z", "commit": {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1MToyMVrOFe_F5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1MToyMVrOFe_F5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNTMwMw==", "bodyText": "Can you decode the request using the key to show that you get back the unencrypted data to verify that this is working?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368035303", "createdAt": "2020-01-17T16:51:21Z", "author": {"login": "spacether"}, "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,370 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.PublicKey import RSA\n+from Crypto.PublicKey import ECC\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# Test RSA private key as published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        # r[0] is the expected HTTP method, URL.\n+        # args is the actual HTTP method, URL.\n+        self._tc.assertEqual(r[0], args)\n+        # r[1] is a dict that contains the expected body, headers\n+        # kwargs is a dict that contains the actual body, headers\n+        for k, expected in r[1].items():\n+            self._tc.assertIn(k, kwargs)\n+            actual = kwargs[k]\n+            if k == 'body':\n+                self._tc.assertEqual(expected, actual)\n+            elif k == 'headers':\n+                for expected_header_name, expected_header_value in expected.items():\n+                    self._tc.assertIn(expected_header_name, actual)\n+                    actual_header_value = actual[expected_header_name]\n+                    pattern = re.compile(expected_header_value)\n+                    m = pattern.match(actual_header_value)\n+                    self._tc.assertTrue(m, msg=\"Expected:\\n{0}\\nActual:\\n{1}\".format(\n+                                        expected_header_value,actual_header_value))\n+            elif k == 'timeout':\n+                self._tc.assertEqual(expected, actual)\n+        return urllib3.HTTPResponse(status=200, body=b'test')\n+\n+\n+class PetApiTests(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.setUpModels()\n+        self.setUpFiles()\n+\n+\n+    def setUpModels(self):\n+        self.category = petstore_api.Category()\n+        self.category.id = id_gen()\n+        self.category.name = \"dog\"\n+        self.tag = petstore_api.Tag()\n+        self.tag.id = id_gen()\n+        self.tag.name = \"python-pet-tag\"\n+        self.pet = petstore_api.Pet(name=\"hello kity\", photo_urls=[\"http://foo.bar.com/1\", \"http://foo.bar.com/2\"])\n+        self.pet.id = id_gen()\n+        self.pet.status = \"sold\"\n+        self.pet.category = self.category\n+        self.pet.tags = [self.tag]\n+\n+    def setUpFiles(self):\n+        self.test_file_dir = os.path.join(os.path.dirname(__file__), \"..\", \"testfiles\")\n+        self.test_file_dir = os.path.realpath(self.test_file_dir)\n+        if not os.path.exists(self.test_file_dir):\n+            os.mkdir(self.test_file_dir)\n+\n+        self.rsa_key_path = os.path.join(self.test_file_dir, 'rsa.pem')\n+        self.rsa4096_key_path = os.path.join(self.test_file_dir, 'rsa4096.pem')\n+        self.ec_p521_key_path = os.path.join(self.test_file_dir, 'ecP521.pem')\n+\n+        if not os.path.exists(self.rsa_key_path):\n+            with open(self.rsa_key_path, 'w') as f:\n+                f.write(RSA_TEST_PRIVATE_KEY)\n+\n+        if not os.path.exists(self.rsa4096_key_path):\n+            key = RSA.generate(4096)\n+            private_key = key.export_key()\n+            with open(self.rsa4096_key_path, \"wb\") as f:\n+                f.write(private_key)\n+\n+        if not os.path.exists(self.ec_p521_key_path):\n+            key = ECC.generate(curve='P-521')\n+            private_key = key.export_key(format='PEM')\n+            with open(self.ec_p521_key_path, \"wt\") as f:\n+                f.write(private_key)\n+\n+    def test_valid_http_signature(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+                signing.HEADER_HOST,\n+                signing.HEADER_DATE,\n+                signing.HEADER_DIGEST,\n+                'Content-Type'\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\) host date digest content-type\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_with_defaults(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_rsassa_pkcs1v15(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_rsassa_pss(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PSS,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_ec_p521(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.ec_p521_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd"}, "originalPosition": 318}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ab9cf91a9a51c3eb352c60bdfae58e588b057f9", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/6ab9cf91a9a51c3eb352c60bdfae58e588b057f9", "committedDate": "2020-01-17T17:08:23Z", "message": "Merge branch 'http-signature' into python-http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fb5c6e014aed227288914aeae611532e96a0657", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/7fb5c6e014aed227288914aeae611532e96a0657", "committedDate": "2020-01-17T19:30:15Z", "message": "Add support for private key passphrase. Add more unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f4d6c679db62d5650f0c657cb2c93b839bbbd74", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/5f4d6c679db62d5650f0c657cb2c93b839bbbd74", "committedDate": "2020-01-17T22:14:17Z", "message": "Add unit test to validate the signature against the public key"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daf060e87fcd77bc819f5f8226b00b65e50cb48e", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/daf060e87fcd77bc819f5f8226b00b65e50cb48e", "committedDate": "2020-01-17T22:31:48Z", "message": "remove http signature from petstore-with-fake-endpoints-models-for-testing.yaml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "790c093a3f092ba4a559d0a4ab526f76be51f55c", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/790c093a3f092ba4a559d0a4ab526f76be51f55c", "committedDate": "2020-01-17T22:32:25Z", "message": "Merge branch 'http-signature' into python-http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f9f6be473576d69427ad56b7eb75440ce5774a0", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/9f9f6be473576d69427ad56b7eb75440ce5774a0", "committedDate": "2020-01-17T23:21:00Z", "message": "fix unit test issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4651cf51247ae9e3ac163c49f6a15f6eb0d7de5", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/c4651cf51247ae9e3ac163c49f6a15f6eb0d7de5", "committedDate": "2020-01-18T00:22:53Z", "message": "run scripts in bin directory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57e43fd0e4ccc970cf9036a1b6bd875570de985e", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/57e43fd0e4ccc970cf9036a1b6bd875570de985e", "committedDate": "2020-01-19T03:41:43Z", "message": "Merge remote-tracking branch 'origin' into python-http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b1aef6b13b8a6f52ced21b610351bbd916d330a", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/1b1aef6b13b8a6f52ced21b610351bbd916d330a", "committedDate": "2020-01-19T03:43:46Z", "message": "Merge remote-tracking branch 'origin' into http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f7e6eb7c49780c553bac29d55a8a7c6c0041a54", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/4f7e6eb7c49780c553bac29d55a8a7c6c0041a54", "committedDate": "2020-01-19T15:50:23Z", "message": "Merge remote-tracking branch 'origin' into http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9f2bff355bc7dfb24229d193c84c984ef87fe14", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/b9f2bff355bc7dfb24229d193c84c984ef87fe14", "committedDate": "2020-01-19T15:50:39Z", "message": "Merge remote-tracking branch 'origin' into python-http-signature"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTIzMzE4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-344923318", "createdAt": "2020-01-18T03:53:04Z", "commit": {"oid": "c4651cf51247ae9e3ac163c49f6a15f6eb0d7de5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMzo1MzowNVrOFfJYeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMzo1Mzo1MFrOFfJYog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMzg5OA==", "bodyText": "How about using variable names that convey the info in your comments?\nhttp_method_url_expected = r[0]\nEtc", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368203898", "createdAt": "2020-01-18T03:53:05Z", "author": {"login": "spacether"}, "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,486 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import base64\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.Hash import SHA256, SHA512\n+from Crypto.PublicKey import ECC, RSA\n+from Crypto.Signature import pkcs1_15, pss, DSS\n+from six.moves.urllib.parse import urlencode, urlparse\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# This test RSA private key below is published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def set_signing_config(self, signing_cfg):\n+        self.signing_cfg = signing_cfg\n+        self._tc.assertIsNotNone(self.signing_cfg)\n+        self.pubkey = self.signing_cfg.get_public_key()\n+        self._tc.assertIsNotNone(self.pubkey)\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        # r[0] is the expected HTTP method, URL.\n+        # args is the actual HTTP method, URL.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4651cf51247ae9e3ac163c49f6a15f6eb0d7de5"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMzkzOA==", "bodyText": "How about using variable names that convey the info in your comments?\nkwargs could be named body_headers_actual", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368203938", "createdAt": "2020-01-18T03:53:50Z", "author": {"login": "spacether"}, "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,486 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import base64\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.Hash import SHA256, SHA512\n+from Crypto.PublicKey import ECC, RSA\n+from Crypto.Signature import pkcs1_15, pss, DSS\n+from six.moves.urllib.parse import urlencode, urlparse\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# This test RSA private key below is published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def set_signing_config(self, signing_cfg):\n+        self.signing_cfg = signing_cfg\n+        self._tc.assertIsNotNone(self.signing_cfg)\n+        self.pubkey = self.signing_cfg.get_public_key()\n+        self._tc.assertIsNotNone(self.pubkey)\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        # r[0] is the expected HTTP method, URL.\n+        # args is the actual HTTP method, URL.\n+        self._tc.assertEqual(r[0], args)\n+        # r[1] is a dict that contains the expected body, headers\n+        # kwargs is a dict that contains the actual body, headers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4651cf51247ae9e3ac163c49f6a15f6eb0d7de5"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MDE3MzU4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-345017358", "createdAt": "2020-01-19T18:14:21Z", "commit": {"oid": "b9f2bff355bc7dfb24229d193c84c984ef87fe14"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b93f5477a717786d51bcecb96e19ea2a2c5b51d", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/7b93f5477a717786d51bcecb96e19ea2a2c5b51d", "committedDate": "2020-01-19T23:31:32Z", "message": "Refact unit test with better variable names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "066237f18938f8e797a57fd30c189e02e5c99146", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/066237f18938f8e797a57fd30c189e02e5c99146", "committedDate": "2020-01-20T05:00:59Z", "message": "Merge remote-tracking branch 'origin' into http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34f126fb65077ecf2d23d12907158471c37fc93c", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/34f126fb65077ecf2d23d12907158471c37fc93c", "committedDate": "2020-01-20T05:13:01Z", "message": "do not throw exception if security scheme is unrecognized"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b3a54b277601c0c43474b99449ec8046704b800", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/7b3a54b277601c0c43474b99449ec8046704b800", "committedDate": "2020-01-21T22:53:39Z", "message": "change URL of apache license to use https"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85d13235beabd8401146259692da782a27189e81", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/85d13235beabd8401146259692da782a27189e81", "committedDate": "2020-01-22T01:05:15Z", "message": "sync from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6abf380a8a22badc4dae54c2ea7a07dc4b7ebe3d", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/6abf380a8a22badc4dae54c2ea7a07dc4b7ebe3d", "committedDate": "2020-01-22T01:06:03Z", "message": "sync from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8b0dc65e1be4d84b628891988a4096a7e4d469a", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/d8b0dc65e1be4d84b628891988a4096a7e4d469a", "committedDate": "2020-01-22T01:06:16Z", "message": "Merge remote-tracking branch 'origin' into http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d6516ee92457b26162778a23030f7d5c22aa6ac", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/2d6516ee92457b26162778a23030f7d5c22aa6ac", "committedDate": "2020-01-22T18:14:01Z", "message": "fix usage of escape character in python regex. Fix generated python documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a14c50611555a8fc3903bd742e8197dfc5b927d9", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/a14c50611555a8fc3903bd742e8197dfc5b927d9", "committedDate": "2020-01-22T23:28:58Z", "message": "write HTTP signed headers in user-specified order. Fix PEP8 formatting issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2b0c8420cfe0748ba6ad6469f590454ecf441e7", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/a2b0c8420cfe0748ba6ad6469f590454ecf441e7", "committedDate": "2020-01-22T23:36:56Z", "message": "write HTTP signed headers in user-specified order. Fix PEP8 formatting issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "846b9ba82e7ef1672d07c11424be833244af6903", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/846b9ba82e7ef1672d07c11424be833244af6903", "committedDate": "2019-12-29T16:05:14Z", "message": "start implementation of HTTP signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64733bd797fd627c39fb28df9db4e54418e31833", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/64733bd797fd627c39fb28df9db4e54418e31833", "committedDate": "2020-01-02T19:28:50Z", "message": "add api key parameters for http message signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b151f2006ecbe621697596afba486238f3e81188", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/b151f2006ecbe621697596afba486238f3e81188", "committedDate": "2020-01-06T04:16:40Z", "message": "HTTP signature authentication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cdc6ab20459e153a55874e4a83f2041799b5a18", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/1cdc6ab20459e153a55874e4a83f2041799b5a18", "committedDate": "2020-01-06T17:18:46Z", "message": "start implementation of HTTP signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2fdefa28a8f5268848e2396530730b2d8f29283", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/c2fdefa28a8f5268848e2396530730b2d8f29283", "committedDate": "2020-01-06T17:18:47Z", "message": "add api key parameters for http message signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32a364767e08ab4683fba5290878fcd1143aec5f", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/32a364767e08ab4683fba5290878fcd1143aec5f", "committedDate": "2020-01-06T17:21:16Z", "message": "HTTP signature authentication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d000e438a7551f85cbbee0fe0ce48ea152127ec", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/2d000e438a7551f85cbbee0fe0ce48ea152127ec", "committedDate": "2020-01-06T17:22:31Z", "message": "sync from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ef838b6d77eb820d1102acd66d564674a58c610", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/1ef838b6d77eb820d1102acd66d564674a58c610", "committedDate": "2020-01-06T17:31:23Z", "message": "HTTP signature authentication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3246c1d705475613a5650f5b5ae2ab71dfc13a4c", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/3246c1d705475613a5650f5b5ae2ab71dfc13a4c", "committedDate": "2020-01-06T17:31:24Z", "message": "start implementation of HTTP signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b33ef8a7f0b245301aa417772d3b85d65fa73cb", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/4b33ef8a7f0b245301aa417772d3b85d65fa73cb", "committedDate": "2020-01-06T17:38:17Z", "message": "fix merge issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52aecf8a53e27f89778f2b2690fe5f415760d87f", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/52aecf8a53e27f89778f2b2690fe5f415760d87f", "committedDate": "2020-01-13T20:10:41Z", "message": "Merge remote-tracking branch 'origin' into python-http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d63a3acc498f486259c387582a57ae3e90b812e", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/2d63a3acc498f486259c387582a57ae3e90b812e", "committedDate": "2020-01-13T21:13:39Z", "message": "Address formatting issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "409ac382294bb62f9318cfb9044eb47c162889ca", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/409ac382294bb62f9318cfb9044eb47c162889ca", "committedDate": "2020-01-13T21:14:25Z", "message": "Address formatting issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bf6f1a5a8fa121d1ec65121860f29f26bd59cee", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/2bf6f1a5a8fa121d1ec65121860f29f26bd59cee", "committedDate": "2020-01-13T21:36:02Z", "message": "move python-experimental-openapiv3-sample to a separate PR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d626293577ccd08a5b10b617498e30c8602f6eee", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/d626293577ccd08a5b10b617498e30c8602f6eee", "committedDate": "2020-01-13T21:56:13Z", "message": "Add support for HTTP signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9eca52c65f9ba6c2c7ab0a96aa0e3c64c4600874", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/9eca52c65f9ba6c2c7ab0a96aa0e3c64c4600874", "committedDate": "2020-01-13T22:02:50Z", "message": "Add code comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a59f75979a851cbbdd1a8c818bf70adb28c691d3", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/a59f75979a851cbbdd1a8c818bf70adb28c691d3", "committedDate": "2020-01-13T22:08:20Z", "message": "Add code comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6e3b0cc37871ba9ffd4ae705fc09c590f84a10d", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/b6e3b0cc37871ba9ffd4ae705fc09c590f84a10d", "committedDate": "2020-01-13T22:13:16Z", "message": "merge from http-signature branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16c1891061fbe31be743de8688400e3dd5f67d19", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/16c1891061fbe31be743de8688400e3dd5f67d19", "committedDate": "2020-01-13T22:13:24Z", "message": "Fix formatting issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1a181c177f2986d9528324527edef6a0b6f26cd", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/a1a181c177f2986d9528324527edef6a0b6f26cd", "committedDate": "2020-01-13T22:22:04Z", "message": "Fix formatting issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f1c4cfe031e5686858d30a19481949836df330a", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/7f1c4cfe031e5686858d30a19481949836df330a", "committedDate": "2020-01-13T22:29:07Z", "message": "Fix formatting issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e6395fa4ec299a16e18ff895763177a21e3eb1b", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/9e6395fa4ec299a16e18ff895763177a21e3eb1b", "committedDate": "2020-01-14T00:24:03Z", "message": "add code comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5616dd246173a3acb6f55a4660f8f8c1d033224", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/e5616dd246173a3acb6f55a4660f8f8c1d033224", "committedDate": "2020-01-14T00:31:51Z", "message": "add code comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8175a07b8a1cf25a365f094ed09c24cca844fdc", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/d8175a07b8a1cf25a365f094ed09c24cca844fdc", "committedDate": "2020-01-14T16:25:31Z", "message": "Merge remote-tracking branch 'origin' into http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b86216b8088c6fad1263a28356091a78f1c5056", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/1b86216b8088c6fad1263a28356091a78f1c5056", "committedDate": "2020-01-14T16:27:52Z", "message": "Merge remote-tracking branch 'origin' into python-http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fdb7ef5a7803225b17d0289600d277a2272c67e", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/9fdb7ef5a7803225b17d0289600d277a2272c67e", "committedDate": "2020-01-14T17:36:23Z", "message": "fix python formatting issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae56f20eb8da4ea79206c9cd59f1c230179af5c4", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/ae56f20eb8da4ea79206c9cd59f1c230179af5c4", "committedDate": "2020-01-14T17:39:29Z", "message": "Make PKCS1v15 string constant consistent between Python and Golang"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4c23b82cf8736781e31b7c90c395e54459e5331", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/c4c23b82cf8736781e31b7c90c395e54459e5331", "committedDate": "2020-01-14T18:27:25Z", "message": "fix python formatting issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8948135e982e8dfb5d0acaaf770502452b7f0300", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/8948135e982e8dfb5d0acaaf770502452b7f0300", "committedDate": "2020-01-14T18:54:26Z", "message": "Add code comments in generated Python. Start adding unit tests for HTTP signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "176f1305cc6d368fbfe610e857aa4c92ed76068e", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/176f1305cc6d368fbfe610e857aa4c92ed76068e", "committedDate": "2020-01-14T19:46:24Z", "message": "compliance with HTTP signature draft 12"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "committedDate": "2020-01-14T20:00:45Z", "message": "compliance with HTTP signature draft 12"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODE0ODU0", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342814854", "createdAt": "2020-01-14T20:23:27Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDoyMzoyN1rOFdksow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDoyMzoyN1rOFdksow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NDI3NQ==", "bodyText": "Can you include the types of the list? Should it be list of str?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366554275", "createdAt": "2020-01-14T20:23:27Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODE1MzA4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342815308", "createdAt": "2020-01-14T20:24:19Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDoyNDoxOVrOFdkuKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDoyNDoxOVrOFdkuKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NDY2Ng==", "bodyText": "Should this be type bytes or string? (In Python2.7 byes creates strings)", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366554666", "createdAt": "2020-01-14T20:24:19Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODE1NzMy", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342815732", "createdAt": "2020-01-14T20:25:07Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDoyNTowN1rOFdkvaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDoyNTowN1rOFdkvaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NDk4Nw==", "bodyText": "What type is this? Int? Can you add the type here", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366554987", "createdAt": "2020-01-14T20:25:07Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.\n+        :param created_ts: The time when the signature was created, as a UNIX timestamp.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODE2Mzg0", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342816384", "createdAt": "2020-01-14T20:26:24Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDoyNjoyNFrOFdkxTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDoyNjoyNFrOFdkxTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NTQ3MQ==", "bodyText": "How about for i, k in enumerate(signed_headers):?\nThen you don't need to create i, and we never use _ (value so no need to include it in iteration)", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366555471", "createdAt": "2020-01-14T20:26:24Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.\n+        :param created_ts: The time when the signature was created, as a UNIX timestamp.\n         :return: instance of digest object \n         \"\"\"\n \n+        i = 0\n+        headers_value = \"\"\n+        is_created_set = False\n+        for key, _ in signed_headers.items():", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODE3NzM3", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342817737", "createdAt": "2020-01-14T20:29:01Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDoyOTowMVrOFdk1iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDoyOTowMVrOFdk1iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NjU1Mg==", "bodyText": "Can you describe the return type?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366556552", "createdAt": "2020-01-14T20:29:01Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.\n+        :param created_ts: The time when the signature was created, as a UNIX timestamp.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODIwMDQz", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342820043", "createdAt": "2020-01-14T20:33:28Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDozMzoyOVrOFdk8aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDozMzoyOVrOFdk8aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1ODMxMw==", "bodyText": "Why do we have 3 lines defining auth_str?\nWhy not just use this?\nauth_str = \"Signature keyId=\\\"{0}\\\",algorithm=\\\"{1}\\\"\".format(self.configuration.key_id, self.configuration.signing_scheme)", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366558313", "createdAt": "2020-01-14T20:33:29Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.\n+        :param created_ts: The time when the signature was created, as a UNIX timestamp.\n         :return: instance of digest object \n         \"\"\"\n \n+        i = 0\n+        headers_value = \"\"\n+        is_created_set = False\n+        for key, _ in signed_headers.items():\n+            key = key.lower()\n+            if i > 0:\n+                headers_value = headers_value + \" \"\n+            headers_value = headers_value + key\n+            if key == '(created)':\n+                is_created_set = True\n+            i += 1\n+\n         auth_str = \"\"\n         auth_str = auth_str + \"Signature\"\n \n         auth_str = auth_str + \" \" + \"keyId=\\\"\" + self.configuration.key_id + \"\\\",\" + \"algorithm=\\\"\" +\n-            self.configuration.signing_scheme + \"\\\",\" + \"headers=\\\"(request-target)\"\n+            self.configuration.signing_scheme + \"\\\",\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODIyNDY3", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342822467", "createdAt": "2020-01-14T20:37:47Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDozNzo0N1rOFdlDUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDozNzo0N1rOFdlDUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MDA4Mw==", "bodyText": "Can you move this line higher than the if i > 0?\nIt is confusing because this lower line is run in the i==0 use case.\nWhat about using this?\n            headers_value += key\n            if i > 0:\n                headers_value += \" \"", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366560083", "createdAt": "2020-01-14T20:37:47Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.\n+        :param created_ts: The time when the signature was created, as a UNIX timestamp.\n         :return: instance of digest object \n         \"\"\"\n \n+        i = 0\n+        headers_value = \"\"\n+        is_created_set = False\n+        for key, _ in signed_headers.items():\n+            key = key.lower()\n+            if i > 0:\n+                headers_value = headers_value + \" \"\n+            headers_value = headers_value + key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODIzMTYy", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342823162", "createdAt": "2020-01-14T20:39:06Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDozOTowNlrOFdlFeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDozOTowNlrOFdlFeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MDYzMw==", "bodyText": "Why not combine the next 3 lines and use \"blah..\".format(args) ?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366560633", "createdAt": "2020-01-14T20:39:06Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.\n+        :param created_ts: The time when the signature was created, as a UNIX timestamp.\n         :return: instance of digest object \n         \"\"\"\n \n+        i = 0\n+        headers_value = \"\"\n+        is_created_set = False\n+        for key, _ in signed_headers.items():\n+            key = key.lower()\n+            if i > 0:\n+                headers_value = headers_value + \" \"\n+            headers_value = headers_value + key\n+            if key == '(created)':\n+                is_created_set = True\n+            i += 1\n+\n         auth_str = \"\"\n         auth_str = auth_str + \"Signature\"\n \n         auth_str = auth_str + \" \" + \"keyId=\\\"\" + self.configuration.key_id + \"\\\",\" + \"algorithm=\\\"\" +\n-            self.configuration.signing_scheme + \"\\\",\" + \"headers=\\\"(request-target)\"\n+            self.configuration.signing_scheme + \"\\\",\"\n+        if is_created_set:\n+            auth_str = auth_str + \"created={0},\".format(created_ts)\n+        auth_str = auth_str + \"headers=\\\"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODI1MjU1", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342825255", "createdAt": "2020-01-14T20:42:48Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo0Mjo0OVrOFdlMDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo0Mjo0OVrOFdlMDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MjMxNw==", "bodyText": "Can you move tis import to the top?\nPer pep8 imports should be at the top of the file https://www.python.org/dev/peps/pep-0008/#imports", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366562317", "createdAt": "2020-01-14T20:42:49Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODI2Mjk4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342826298", "createdAt": "2020-01-14T20:44:44Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo0NDo0NVrOFdlPRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo0NDo0NVrOFdlPRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MzE0Mg==", "bodyText": "Can you add spaces around the equal sign on this line and the next line after the variable assignment?\ncdate = blah\ncreated = blah", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366563142", "createdAt": "2020-01-14T20:44:45Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate=formatdate(timeval=stamp, localtime=False, usegmt=True)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODI3MjYz", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342827263", "createdAt": "2020-01-14T20:46:28Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo0NjoyOVrOFdlSBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo0NjoyOVrOFdlSBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2Mzg0NA==", "bodyText": "Can you add type descriptions to these params?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366563844", "createdAt": "2020-01-14T20:46:29Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODI4Nzg3", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342828787", "createdAt": "2020-01-14T20:49:14Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo0OToxNVrOFdlWmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo0OToxNVrOFdlWmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NTAxNg==", "bodyText": "Can you add type descriptions to these params?\nb64encode(signature) does not return type bytes in python2.7, it returns type string", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366565016", "createdAt": "2020-01-14T20:49:15Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate=formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created=now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = self.get_str_to_sign(signed_headers)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)\n+\n+        return signed_header_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The message to be hashed with a cryptographic hash.\n+        :return: The message digest encoded as a byte string. \n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: digest of the HTTP message.\n+        :return: the HTTP message signature encoded as a byte string.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 161}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODMzMjc1", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342833275", "createdAt": "2020-01-14T20:57:29Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo1NzoyOVrOFdlj8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo1NzoyOVrOFdlj8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2ODQzNA==", "bodyText": "Can you turn these into a constant at the top of this module?\nSomething like:\nECDSA_KEY_SIGNING_ALGORITHMS =  {'fips-186-3', 'deterministic-rfc6979'}\nSet inclusion should be quicker than list inclusion and these values are unchanging across multiple function calls", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366568434", "createdAt": "2020-01-14T20:57:29Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate=formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created=now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = self.get_str_to_sign(signed_headers)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)\n+\n+        return signed_header_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The message to be hashed with a cryptographic hash.\n+        :return: The message digest encoded as a byte string. \n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: digest of the HTTP message.\n+        :return: the HTTP message signature encoded as a byte string.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ['fips-186-3', 'deterministic-rfc6979']:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 175}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODMzNzQ1", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342833745", "createdAt": "2020-01-14T20:58:22Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo1ODoyMlrOFdllTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo1ODoyMlrOFdllTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2ODc4Mg==", "bodyText": "Can you add types to these parameter descriptions?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366568782", "createdAt": "2020-01-14T20:58:22Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate=formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created=now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = self.get_str_to_sign(signed_headers)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)\n+\n+        return signed_header_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The message to be hashed with a cryptographic hash.\n+        :return: The message digest encoded as a byte string. \n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: digest of the HTTP message.\n+        :return: the HTTP message signature encoded as a byte string.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ['fips-186-3', 'deterministic-rfc6979']:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_str_to_sign(self, signed_headers):\n+        \"\"\"\n+        Generate and return a string value representing the HTTP request to be signed.\n+\n+        :param signed_headers: The HTTP Headers to be signed.\n+        :return: instance of digest object ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 188}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODM0MTMw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342834130", "createdAt": "2020-01-14T20:59:03Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo1OTowNFrOFdlmYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMDo1OTowNFrOFdlmYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2OTA1Ng==", "bodyText": "How about for i, (key, value) in enumerate(signed_headers.items()):?\nThen you don't need to create i and increment it", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366569056", "createdAt": "2020-01-14T20:59:04Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate=formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created=now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = self.get_str_to_sign(signed_headers)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)\n+\n+        return signed_header_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The message to be hashed with a cryptographic hash.\n+        :return: The message digest encoded as a byte string. \n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: digest of the HTTP message.\n+        :return: the HTTP message signature encoded as a byte string.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ['fips-186-3', 'deterministic-rfc6979']:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_str_to_sign(self, signed_headers):\n+        \"\"\"\n+        Generate and return a string value representing the HTTP request to be signed.\n+\n+        :param signed_headers: The HTTP Headers to be signed.\n+        :return: instance of digest object \n+        \"\"\"\n+        ss = \"\"\n+        i = 0\n+        for key, value in signed_headers.items():", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 192}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODM1MjA5", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342835209", "createdAt": "2020-01-14T21:00:57Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMTowMDo1N1rOFdlp2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMTowMDo1N1rOFdlp2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2OTk0Nw==", "bodyText": "Similar comment to what I say below:\nCan you move this line higher than the if i > 0?\nIt is confusing because this lower line is run in the i==0 use case.\nWhat about using this?\n            ss += \"{0}: {1}\".format(key.lower(), value)\n            if i > 0:\n                ss += \"\\n\"", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366569947", "createdAt": "2020-01-14T21:00:57Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate=formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created=now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = self.get_str_to_sign(signed_headers)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)\n+\n+        return signed_header_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The message to be hashed with a cryptographic hash.\n+        :return: The message digest encoded as a byte string. \n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: digest of the HTTP message.\n+        :return: the HTTP message signature encoded as a byte string.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ['fips-186-3', 'deterministic-rfc6979']:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_str_to_sign(self, signed_headers):\n+        \"\"\"\n+        Generate and return a string value representing the HTTP request to be signed.\n+\n+        :param signed_headers: The HTTP Headers to be signed.\n+        :return: instance of digest object \n+        \"\"\"\n+        ss = \"\"\n+        i = 0\n+        for key, value in signed_headers.items():\n+            if i > 0:\n+                ss = ss + \"\\n\"\n+            ss = ss + key.lower() + \": \" + value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 195}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODM2NDk1", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342836495", "createdAt": "2020-01-14T21:03:23Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMTowMzoyNFrOFdltig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMTowMzoyNFrOFdltig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MDg5MA==", "bodyText": "Do these values already exist as constants in your imported crypto libraries?\nWhy not use those constants rather than strings?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366570890", "createdAt": "2020-01-14T21:03:24Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -26,11 +30,54 @@ class Configuration(object):\n     :param api_key_prefix: Dict to store API prefix (e.g. Bearer)\n     :param username: Username for HTTP basic authentication\n     :param password: Password for HTTP basic authentication\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODM2ODkw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342836890", "createdAt": "2020-01-14T21:04:07Z", "commit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMTowNDowN1rOFdluqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMTowNDowN1rOFdluqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MTE3Nw==", "bodyText": "Does this value already exist as a constant in your imported crypto libraries?\nWhy not use that constant rather than a string here?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366571177", "createdAt": "2020-01-14T21:04:07Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -26,11 +30,54 @@ class Configuration(object):\n     :param api_key_prefix: Dict to store API prefix (e.g. Bearer)\n     :param username: Username for HTTP basic authentication\n     :param password: Password for HTTP basic authentication\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4cc4df417e09266a11b2e69f570b3ffad57fe77", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/e4cc4df417e09266a11b2e69f570b3ffad57fe77", "committedDate": "2020-01-14T21:24:55Z", "message": "working on review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5811b0d370a8fe0eb58593c00b2ed792fe2f2c8", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/e5811b0d370a8fe0eb58593c00b2ed792fe2f2c8", "committedDate": "2020-01-14T21:29:08Z", "message": "working on review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "916416d441d910c80fbfb570a966fa5cdf536a28", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/916416d441d910c80fbfb570a966fa5cdf536a28", "committedDate": "2020-01-14T21:36:57Z", "message": "working on review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7db2a6222fbc0b0eba586fda470f6ab337b461b1", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/7db2a6222fbc0b0eba586fda470f6ab337b461b1", "committedDate": "2020-01-14T21:51:00Z", "message": "working on review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fac1af1347e914bd8ffe84317cdf177176142475", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/fac1af1347e914bd8ffe84317cdf177176142475", "committedDate": "2020-01-14T22:04:15Z", "message": "working on review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODgzNDA5", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342883409", "createdAt": "2020-01-14T22:31:42Z", "commit": {"oid": "fac1af1347e914bd8ffe84317cdf177176142475"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjozMTo0MlrOFdn9aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjozMTo0MlrOFdn9aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwNzcyMw==", "bodyText": "How about refactoring lines 586 to 631 into a function called get_signed_header_info?\nAll of that code is only focused on generating those two dictionaries\nLike so:\nsigned_headers, signed_headers_dict = get_signed_header_info(body, self.configuration, method)\nThat would shorten our get_http_signature_headers and help make it more understandable.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366607723", "createdAt": "2020-01-14T22:31:42Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +566,159 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fac1af1347e914bd8ffe84317cdf177176142475"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODg0Njgx", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342884681", "createdAt": "2020-01-14T22:34:32Z", "commit": {"oid": "fac1af1347e914bd8ffe84317cdf177176142475"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjozNDozMlrOFdoBgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjozNDozMlrOFdoBgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwODc2OA==", "bodyText": "How about we change to this?\nsigned_header_dict['Authorization'] = self.get_authorization_header(\n   signed_headers, b64_signed_msg, created)\n\nThat was we can delete the line above this too\nIt looks like we don't need the string interpolation here because our assigned value is already a string.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366608768", "createdAt": "2020-01-14T22:34:32Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +566,159 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fac1af1347e914bd8ffe84317cdf177176142475"}, "originalPosition": 148}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODg2ODI4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342886828", "createdAt": "2020-01-14T22:39:13Z", "commit": {"oid": "fac1af1347e914bd8ffe84317cdf177176142475"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjozOToxNFrOFdoIaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjozOToxNFrOFdoIaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMDUzNw==", "bodyText": "This returns a tuple of (digest, prefix) can you describe both returned params and types in this docstring?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366610537", "createdAt": "2020-01-14T22:39:14Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +566,159 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)\n+\n+        return signed_header_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: The hashing object that contains the cryptographic digest of the HTTP request. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fac1af1347e914bd8ffe84317cdf177176142475"}, "originalPosition": 157}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODkyNTI2", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-342892526", "createdAt": "2020-01-14T22:51:55Z", "commit": {"oid": "fac1af1347e914bd8ffe84317cdf177176142475"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjo1MTo1NlrOFdoaSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjo1MTo1NlrOFdoaSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNTExMw==", "bodyText": "Just a general question, not necessary to do:\nWhat do you think about moving these constants and\n\nget_http_signature_headers\nget_message_digest\nsign_digest\nget_authorization_header\nload_private_key\n\ninto a package called signing.py?\nThat way our users could use something like:\nfrom petstore_api import signing\n\n# Configure API client with HTTP signature authentication:\nconf = petstore_api.Configuration(\n  key_id='my-key-id',\n  private_key_path='rsa.pem',\n  signing_scheme=signing.scheme_hs2019,\n  signing_algorithm=signing.algorithm_PSS,\n  signed_headers=['(request-target)', '(created)', 'host', 'date', 'Content-Type', 'Digest']\n)\n\nThese constants and functions seem much more related to signing than the api_client\nWhat do you think?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366615113", "createdAt": "2020-01-14T22:51:56Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -57,6 +64,10 @@ class ApiClient(object):\n     PRIMITIVE_TYPES = (\n         (float, bool, six.binary_type, six.text_type) + six.integer_types\n     )\n+    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fac1af1347e914bd8ffe84317cdf177176142475"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e053076ac2902b65b7ccd2a5b639f9aee1138d10", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/e053076ac2902b65b7ccd2a5b639f9aee1138d10", "committedDate": "2020-01-14T23:02:53Z", "message": "working on review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ef4815e9ebd978993822739da31a783cae19f19", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/2ef4815e9ebd978993822739da31a783cae19f19", "committedDate": "2020-01-15T01:44:05Z", "message": "working on review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3e3c7206593da1c1747c31e0b1a25e6e7fbcce2", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/a3e3c7206593da1c1747c31e0b1a25e6e7fbcce2", "committedDate": "2020-01-15T01:46:48Z", "message": "working on review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b56e38f0c4f82d5c28b358786747bf3a9e11b12e", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/b56e38f0c4f82d5c28b358786747bf3a9e11b12e", "committedDate": "2020-01-15T02:36:23Z", "message": "working on review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acfb44dadb6f50989d1c7175faf7014152609ecc", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/acfb44dadb6f50989d1c7175faf7014152609ecc", "committedDate": "2020-01-15T06:55:13Z", "message": "Merge remote-tracking branch 'origin' into http-signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d81bb715f34f082ceca0f623eddf9844f2e0b7b", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/9d81bb715f34f082ceca0f623eddf9844f2e0b7b", "committedDate": "2020-01-15T14:18:05Z", "message": "fix python formatting issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4c153085d122ab88923457911c8d9411573c317", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/c4c153085d122ab88923457911c8d9411573c317", "committedDate": "2020-01-15T17:30:47Z", "message": "fix trailing white space"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDAzNTI0", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343403524", "createdAt": "2020-01-15T17:45:35Z", "commit": {"oid": "c4c153085d122ab88923457911c8d9411573c317"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo0NTozNVrOFeA5Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo0NTozNVrOFeA5Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxNjI2Ng==", "bodyText": "Could we move lines 647 to 650 (body value checking and assignment) into get_signed_header_info?\nbody is only used in that function so handling the values and mutating it is more associated with that code.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367016266", "createdAt": "2020-01-15T17:45:35Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c153085d122ab88923457911c8d9411573c317"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDA1Nzcx", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343405771", "createdAt": "2020-01-15T17:49:08Z", "commit": {"oid": "c4c153085d122ab88923457911c8d9411573c317"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo0OTowOFrOFeBANw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo0OTowOFrOFeBANw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxODAzOQ==", "bodyText": "Can we remove the created input argument from get_authorization_headers?\nIt is already accessible with created = signed_headers_dict['(created)'] which we can use inside get_authorization_headers.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367018039", "createdAt": "2020-01-15T17:49:08Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers_dict.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict['Authorization'] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg, created)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c153085d122ab88923457911c8d9411573c317"}, "originalPosition": 168}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7a654e46b3750b57ad195ee0dc3033293720f06", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/c7a654e46b3750b57ad195ee0dc3033293720f06", "committedDate": "2020-01-15T17:49:26Z", "message": "address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDA3Nzk1", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343407795", "createdAt": "2020-01-15T17:52:27Z", "commit": {"oid": "c4c153085d122ab88923457911c8d9411573c317"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo1MjoyOFrOFeBGVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo1MjoyOFrOFeBGVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxOTYwNg==", "bodyText": "how about rather than using a boolean here we just use a variable which stores the created_ts?\nWe don't need to pass in created_ts because it already exists in our signed_headers dict.\nHere, we could do:\ncreated_ts = signed_headers.get('(created)')", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367019606", "createdAt": "2020-01-15T17:52:28Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers_dict.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict['Authorization'] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg, created)\n+\n+        return request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+          The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+          The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+          'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n+        \"\"\"\n+        Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n+        \n+        :param signed_headers : A list of strings. Each value is the name of a HTTP header that\n+           must be included in the HTTP signature calculation.\n+        :param signed_msg: A base-64 encoded string representation of the signature.\n+        :param created_ts: The string representation of the time when the signature was created,\n+           as a UNIX timestamp value.\n+        :return: The string value of the 'Authorization' header, representing the signature\n+           of the HTTP request.\n+        \"\"\"\n+\n+        headers_value = \"\"\n+        is_created_set = False", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c153085d122ab88923457911c8d9411573c317"}, "originalPosition": 235}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDA4NTE3", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343408517", "createdAt": "2020-01-15T17:53:40Z", "commit": {"oid": "c4c153085d122ab88923457911c8d9411573c317"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo1Mzo0MVrOFeBIpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo1Mzo0MVrOFeBIpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMDE5Ng==", "bodyText": "how about changing this to if created_ts is not None:?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367020196", "createdAt": "2020-01-15T17:53:41Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers_dict.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict['Authorization'] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg, created)\n+\n+        return request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+          The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+          The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+          'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n+        \"\"\"\n+        Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n+        \n+        :param signed_headers : A list of strings. Each value is the name of a HTTP header that\n+           must be included in the HTTP signature calculation.\n+        :param signed_msg: A base-64 encoded string representation of the signature.\n+        :param created_ts: The string representation of the time when the signature was created,\n+           as a UNIX timestamp value.\n+        :return: The string value of the 'Authorization' header, representing the signature\n+           of the HTTP request.\n+        \"\"\"\n+\n+        headers_value = \"\"\n+        is_created_set = False\n+        for i, key in enumerate(signed_headers)\n+            key = key.lower()\n+            headers_value += key\n+            if i > 0:\n+                headers_value += \" \"\n+            if key == '(created)':\n+                is_created_set = True\n+\n+        auth_str = \"Signature keyId=\\\"{0}\\\",algorithm=\\\"{1}\\\",\"\n+            .format(self.configuration.key_id, self.configuration.signing_scheme)\n+        if is_created_set:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c153085d122ab88923457911c8d9411573c317"}, "originalPosition": 246}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b9d272ec7cff74b1fcb3c4d52e02a2e0d562cca", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/9b9d272ec7cff74b1fcb3c4d52e02a2e0d562cca", "committedDate": "2020-01-15T17:56:17Z", "message": "address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDEwMjg5", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343410289", "createdAt": "2020-01-15T17:56:30Z", "commit": {"oid": "c4c153085d122ab88923457911c8d9411573c317"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo1NjozMFrOFeBN9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo1NjozMFrOFeBN9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMTU1OQ==", "bodyText": "How about we delete this if statement?\nIf we use the above  created_ts = signed_headers.get('(created)') then we don't need this if statement.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367021559", "createdAt": "2020-01-15T17:56:30Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers_dict.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict['Authorization'] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg, created)\n+\n+        return request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+          The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+          The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+          'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n+        \"\"\"\n+        Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n+        \n+        :param signed_headers : A list of strings. Each value is the name of a HTTP header that\n+           must be included in the HTTP signature calculation.\n+        :param signed_msg: A base-64 encoded string representation of the signature.\n+        :param created_ts: The string representation of the time when the signature was created,\n+           as a UNIX timestamp value.\n+        :return: The string value of the 'Authorization' header, representing the signature\n+           of the HTTP request.\n+        \"\"\"\n+\n+        headers_value = \"\"\n+        is_created_set = False\n+        for i, key in enumerate(signed_headers)\n+            key = key.lower()\n+            headers_value += key\n+            if i > 0:\n+                headers_value += \" \"\n+            if key == '(created)':", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c153085d122ab88923457911c8d9411573c317"}, "originalPosition": 241}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c4c2fa6675e4fc397c92369ec47098d096ef5a1", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/9c4c2fa6675e4fc397c92369ec47098d096ef5a1", "committedDate": "2020-01-15T17:58:45Z", "message": "address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDEzMjAw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343413200", "createdAt": "2020-01-15T18:01:22Z", "commit": {"oid": "9b9d272ec7cff74b1fcb3c4d52e02a2e0d562cca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODowMToyMlrOFeBWuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODowMToyMlrOFeBWuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMzgwMA==", "bodyText": "Optionally how about changing this for loop into:\nlower_keys = [k.lower() for k in signed_headers]\nheaders_value = \" \".join(lower_keys)\n\nThat will save us two lines", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367023800", "createdAt": "2020-01-15T18:01:22Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,179 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers_dict.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict['Authorization'] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+          The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+          The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+          'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_authorization_header(self, signed_headers, signed_msg):\n+        \"\"\"\n+        Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n+        \n+        :param signed_headers : A list of strings. Each value is the name of a HTTP header that\n+           must be included in the HTTP signature calculation.\n+        :param signed_msg: A base-64 encoded string representation of the signature.\n+        :return: The string value of the 'Authorization' header, representing the signature\n+           of the HTTP request.\n+        \"\"\"\n+\n+        headers_value = \"\"\n+        is_created_set = False\n+        for i, key in enumerate(signed_headers)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b9d272ec7cff74b1fcb3c4d52e02a2e0d562cca"}, "originalPosition": 235}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDE1MjAx", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343415201", "createdAt": "2020-01-15T18:04:55Z", "commit": {"oid": "9b9d272ec7cff74b1fcb3c4d52e02a2e0d562cca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODowNDo1NVrOFeBc1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODowNDo1NVrOFeBc1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNTM2Nw==", "bodyText": "How about changing this to something like?\nheader_items = [\"{0}: {1}\".format(k.lower(), v) for k, v in signed_headers_dict.items()]\nstring_to_sign = \"\\n\".join(header_items)\n\nThat saves us 3 lines", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367025367", "createdAt": "2020-01-15T18:04:55Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,179 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers_dict.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b9d272ec7cff74b1fcb3c4d52e02a2e0d562cca"}, "originalPosition": 163}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08557f48118f9972e4493dc73437cae66ac37dc8", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/08557f48118f9972e4493dc73437cae66ac37dc8", "committedDate": "2020-01-15T18:24:42Z", "message": "Add suppport for '(expires)' signature parameter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2eb626406ec9c8e539807b089987099f985a0269", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/2eb626406ec9c8e539807b089987099f985a0269", "committedDate": "2020-01-15T18:28:20Z", "message": "address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDMwMjUy", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343430252", "createdAt": "2020-01-15T18:30:04Z", "commit": {"oid": "08557f48118f9972e4493dc73437cae66ac37dc8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODozMDowNFrOFeCKsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODozMDowNFrOFeCKsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzNzEwNw==", "bodyText": "Can you also add the condition self.signature_max_validity is None into this if statement?\nThen you can delete the inner if statement and just raise the exception.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367037107", "createdAt": "2020-01-15T18:30:04Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -121,6 +126,17 @@ class Configuration(object):\n            For RSA keys, supported values are PKCS1v15, PSS.\n            For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n         \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        if signed_headers is not None and '(expires)' in signed_headers:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08557f48118f9972e4493dc73437cae66ac37dc8"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDMxNTM4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343431538", "createdAt": "2020-01-15T18:32:12Z", "commit": {"oid": "08557f48118f9972e4493dc73437cae66ac37dc8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODozMjoxM1rOFeCOoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODozMjoxM1rOFeCOoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzODExMw==", "bodyText": "Would it be simpler to require that a set is passed in for signed_headers?\nThen we can remove this if statement.\nDo the signed_headers need to be in a specific order?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367038113", "createdAt": "2020-01-15T18:32:13Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -121,6 +126,17 @@ class Configuration(object):\n            For RSA keys, supported values are PKCS1v15, PSS.\n            For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n         \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        if signed_headers is not None and '(expires)' in signed_headers:\n+            if self.signature_max_validity is None:\n+                raise Exception(\"Signature max validity must be set when '(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08557f48118f9972e4493dc73437cae66ac37dc8"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "976b55b93009c6cdcdd71b8aa28597ff3cbe98a4", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/976b55b93009c6cdcdd71b8aa28597ff3cbe98a4", "committedDate": "2020-01-15T18:52:19Z", "message": "address PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05e60696f69f17e354062d7d1ab6534ce076d357", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/05e60696f69f17e354062d7d1ab6534ce076d357", "committedDate": "2020-01-15T19:20:48Z", "message": "Fix python formatting issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc5539122eb8aee30cc376119e2de463baf5b81e", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/dc5539122eb8aee30cc376119e2de463baf5b81e", "committedDate": "2020-01-15T19:23:40Z", "message": "Fix python formatting issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDYyODI5", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343462829", "createdAt": "2020-01-15T19:24:55Z", "commit": {"oid": "05e60696f69f17e354062d7d1ab6534ce076d357"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOToyNDo1NVrOFeDstQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOToyNDo1NVrOFeDstQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2MjE5Nw==", "bodyText": "If we create the signing.py module, it would also be helpful if we could move this function (load_private_key) into it\nThat way all of our signing code would be in one place\nAgain we would need to conditionally include the from petstore_api import signing import up top", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367062197", "createdAt": "2020-01-15T19:24:55Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -301,6 +400,29 @@ class Configuration(object):\n {{/isOAuth}}\n {{/authMethods}}\n         }\n+{{#hasHttpSignatureMethods}}\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+           The private key is used to sign HTTP requests as defined in\n+           https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, \"rb\") as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith(\"-----BEGIN RSA PRIVATE KEY-----\"):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith(\"-----BEGIN EC PRIVATE KEY-----\"):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+{{/hasHttpSignatureMethods}}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05e60696f69f17e354062d7d1ab6534ce076d357"}, "originalPosition": 191}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "959178a63fbe713196a6703e2774c6a8d5cfd2c4", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/959178a63fbe713196a6703e2774c6a8d5cfd2c4", "committedDate": "2020-01-15T19:37:34Z", "message": "Starting to move code to dedicated file for HTTP signatures"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDc3ODc0", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343477874", "createdAt": "2020-01-15T19:49:51Z", "commit": {"oid": "959178a63fbe713196a6703e2774c6a8d5cfd2c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTo0OTo1MlrOFeEZ2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTo0OTo1MlrOFeEZ2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3Mzc1Mw==", "bodyText": "Why not pass in configuration here?\nThen you can delete the parent class and make these all functions.\nThe other functions would also need to accept a configuration input argument", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367073753", "createdAt": "2020-01-15T19:49:52Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,204 @@\n+{{#hasHttpSignatureMethods}}\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+class HttpSignatureHandler(object):\n+    \"\"\"OpenAPI HTTP signature handler to generate and verify HTTP signatures.\n+\n+    NOTE: This class is auto generated by OpenAPI Generator.\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param configuration: .Configuration object for this client\n+    \"\"\"\n+\n+    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+    def __init__(self, configuration=None):\n+        if configuration is None:\n+            raise Exception(\"Configuration must be specified\")\n+        self.configuration = configuration\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+        if self.configuration.signature_max_validity is not None:\n+            expires = (now + self.configuration.signature_max_validity).strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == '(expires)':\n+                value = expires\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "959178a63fbe713196a6703e2774c6a8d5cfd2c4"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDc4NDQ3", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343478447", "createdAt": "2020-01-15T19:50:51Z", "commit": {"oid": "959178a63fbe713196a6703e2774c6a8d5cfd2c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTo1MDo1MVrOFeEbpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTo1MDo1MVrOFeEbpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3NDIxMw==", "bodyText": "How about deleting this class?\nWe only use it to store the configuration object which could be passed in to get_http_signature_headers.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367074213", "createdAt": "2020-01-15T19:50:51Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,204 @@\n+{{#hasHttpSignatureMethods}}\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+class HttpSignatureHandler(object):\n+    \"\"\"OpenAPI HTTP signature handler to generate and verify HTTP signatures.\n+\n+    NOTE: This class is auto generated by OpenAPI Generator.\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param configuration: .Configuration object for this client\n+    \"\"\"\n+\n+    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+    def __init__(self, configuration=None):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "959178a63fbe713196a6703e2774c6a8d5cfd2c4"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDgwNDQ0", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343480444", "createdAt": "2020-01-15T19:54:08Z", "commit": {"oid": "959178a63fbe713196a6703e2774c6a8d5cfd2c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTo1NDowOVrOFeEhrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTo1NDowOVrOFeEhrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3NTc1Nw==", "bodyText": "How about setting these parameters as module constants?\nhow about naming them with prefixes like SCHEME_ and ALGORITHM_\nThat way our users could use magic string constants like so, and not have to worry about typing quotes:\nfrom petstore_api import signing\n\n# Configure API client with HTTP signature authentication:\nconf = petstore_api.Configuration(\n  key_id='my-key-id',\n  private_key_path='rsa.pem',\n  signing_scheme=signing.SCHEME_HS2019,\n  signing_algorithm=signing.ALGORITHM_PSS,\n  signed_headers=['(request-target)', '(created)', 'host', 'date', 'Content-Type', 'Digest']\n)", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367075757", "createdAt": "2020-01-15T19:54:09Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,204 @@\n+{{#hasHttpSignatureMethods}}\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+class HttpSignatureHandler(object):\n+    \"\"\"OpenAPI HTTP signature handler to generate and verify HTTP signatures.\n+\n+    NOTE: This class is auto generated by OpenAPI Generator.\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param configuration: .Configuration object for this client\n+    \"\"\"\n+\n+    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "959178a63fbe713196a6703e2774c6a8d5cfd2c4"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDg2MjEz", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343486213", "createdAt": "2020-01-15T20:03:50Z", "commit": {"oid": "959178a63fbe713196a6703e2774c6a8d5cfd2c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDowMzo1MFrOFeEyyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDowMzo1MFrOFeEyyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4MDEzNg==", "bodyText": "This module should only be included if this signature method is used.\nSo we can enable/disable the inclusion of this module in the Java code.\nBecause the Java will handle it, can you delete this hasHttpSignatureMethods mustache tag?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367080136", "createdAt": "2020-01-15T20:03:50Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,204 @@\n+{{#hasHttpSignatureMethods}}\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+class HttpSignatureHandler(object):\n+    \"\"\"OpenAPI HTTP signature handler to generate and verify HTTP signatures.\n+\n+    NOTE: This class is auto generated by OpenAPI Generator.\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param configuration: .Configuration object for this client\n+    \"\"\"\n+\n+    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+    def __init__(self, configuration=None):\n+        if configuration is None:\n+            raise Exception(\"Configuration must be specified\")\n+        self.configuration = configuration\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+        if self.configuration.signature_max_validity is not None:\n+            expires = (now + self.configuration.signature_max_validity).strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == '(expires)':\n+                value = expires\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        header_items = [\"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict['Authorization'] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+          The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+          The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+          'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_authorization_header(self, signed_headers, signed_msg):\n+        \"\"\"\n+        Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n+        \n+        :param signed_headers : A list of strings. Each value is the name of a HTTP header that\n+           must be included in the HTTP signature calculation.\n+        :param signed_msg: A base-64 encoded string representation of the signature.\n+        :return: The string value of the 'Authorization' header, representing the signature\n+           of the HTTP request.\n+        \"\"\"\n+\n+        headers_value = \"\"\n+        created_ts = signed_headers.get('(created)')\n+        expires_ts = signed_headers.get('(expires)')\n+        lower_keys = [k.lower() for k in signed_headers]\n+        headers_value = \" \".join(lower_keys)\n+\n+        auth_str = \"Signature keyId=\\\"{0}\\\",algorithm=\\\"{1}\\\",\"\n+            .format(self.configuration.key_id, self.configuration.signing_scheme)\n+        if created_ts is not None:\n+            auth_str = auth_str + \"created={0},\".format(created_ts)\n+        if expires_ts is not None:\n+            auth_str = auth_str + \"expires={0},\".format(expires_ts)\n+        auth_str = auth_str + \"headers=\\\"{0}\\\",signature=\\\"{1}\\\"\"\n+            .format(headers_value, signed_msg.decode('ascii'))\n+        return auth_str\n+{{/hasHttpSignatureMethods}}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "959178a63fbe713196a6703e2774c6a8d5cfd2c4"}, "originalPosition": 204}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTAyMDcz", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343502073", "createdAt": "2020-01-15T20:32:10Z", "commit": {"oid": "959178a63fbe713196a6703e2774c6a8d5cfd2c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozMjoxMFrOFeFiig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozMjoxMFrOFeFiig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MjM2Mg==", "bodyText": "It may be time to separate these into separate dict inputs with None defaults.\nWe are up to 11 non-self arguments.\n@sebastien-rosset what do you think?\nHow about something like:\n__init__(self, host=\"{{{basePath}}}\", api_key_info=None, basic_auth_info=None, signing_info=None)\n\napi_key_info:\n\nkey\nprefix\n\n\nbasic_auth_info\n\nusername\npassword\n\n\nsigning_info\n\nkey_id\nprivate_key_path\nscheme\nalgorithm\nmax_validity\nheaders", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367092362", "createdAt": "2020-01-15T20:32:10Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -26,11 +30,59 @@ class Configuration(object):\n     :param api_key_prefix: Dict to store API prefix (e.g. Bearer)\n     :param username: Username for HTTP basic authentication\n     :param password: Password for HTTP basic authentication\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+\n+    :Example:\n+\n+    Configure API client with HTTP basic authentication:\n+      conf = {{{packageName}}}.Configuration(\n+          username='the-user',\n+          password='the-password',\n+      )\n+\n+    Configure API client with HTTP signature authentication. Use the 'hs2019' signature scheme,\n+    sign the HTTP requests with the RSA-SSA-PSS signature algorithm, and set the expiration time\n+    of the signature to 5 minutes after the signature has been created.\n+      conf = {{{packageName}}}.Configuration(\n+        key_id='my-key-id',\n+        private_key_path='rsa.pem',\n+        signing_scheme='hs2019',\n+        signing_algorithm='PSS',\n+        signed_headers=['(request-target)', '(created)', 'host', 'date', 'Content-Type', 'Digest']\n+        signature_max_validity=timedelta(minutes=5),\n+      )\n     \"\"\"\n \n     def __init__(self, host=\"{{{basePath}}}\",\n                  api_key=None, api_key_prefix=None,\n-                 username=\"\", password=\"\"):\n+                 username=\"\", password=\"\",\n+                 key_id=None, private_key_path=None, signing_scheme=None,\n+                 signing_algorithm=None, signature_max_validity=None, signed_headers=None):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "959178a63fbe713196a6703e2774c6a8d5cfd2c4"}, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "277e48978c58712538cec73939bae8efc9fca4f1", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/277e48978c58712538cec73939bae8efc9fca4f1", "committedDate": "2020-01-15T20:44:44Z", "message": "Continue to refactor code to dedicated file for HTTP signatures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fb18e2e0c33a60fc6b760f2e202d0bce1a50dd3", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/7fb18e2e0c33a60fc6b760f2e202d0bce1a50dd3", "committedDate": "2020-01-15T20:57:00Z", "message": "Continue to refactor code to dedicated file for HTTP signatures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "071316439675ee55efb3682ecd2e7d666a52cd94", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/071316439675ee55efb3682ecd2e7d666a52cd94", "committedDate": "2020-01-15T21:17:42Z", "message": "Continue to refactor code to dedicated file for HTTP signatures"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTM1NTM5", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343535539", "createdAt": "2020-01-15T21:32:34Z", "commit": {"oid": "071316439675ee55efb3682ecd2e7d666a52cd94"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMTozMjozNVrOFeHHPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMTozMjozNVrOFeHHPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExODE0MQ==", "bodyText": "Per my debugging in InteliJ fullAuthmethods doesn't exist yet.\nthis.OpenAPI (the spec does)\nHow about using this?\n        Map<String, SecurityScheme> securitySchemeMap = openAPI.getComponents() != null ? openAPI.getComponents().getSecuritySchemes() : null;\n        List<CodegenSecurity> authMethods = fromSecurity(securitySchemeMap);\n        if (hasHttpSignatureMethods(authMethods)) {\n            supportingFiles.add(new SupportingFile(\"python-experimental/signing.mustache\", packagePath(), \"signing.py\"));\n        }", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367118141", "createdAt": "2020-01-15T21:32:35Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/PythonClientExperimentalCodegen.java", "diffHunk": "@@ -82,6 +82,9 @@ public PythonClientExperimentalCodegen() {\n \n         apiTemplateFiles.remove(\"api.mustache\");\n         apiTemplateFiles.put(\"python-experimental/api.mustache\", \".py\");\n+        if (hasHttpSignatureMethods(this.fullAuthMethods)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "071316439675ee55efb3682ecd2e7d666a52cd94"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTM4MjM5", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343538239", "createdAt": "2020-01-15T21:37:22Z", "commit": {"oid": "277e48978c58712538cec73939bae8efc9fca4f1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMTozNzoyM1rOFeHPAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMTozNzoyM1rOFeHPAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMDEyOQ==", "bodyText": "Can you change this to:\nfrom {{packageName}} import signing \nand move it down in between the rest and Configuration imports?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367120129", "createdAt": "2020-01-15T21:37:23Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -13,6 +13,9 @@ from six.moves.urllib.parse import quote\n {{#tornado}}\n import tornado.gen\n {{/tornado}}\n+{{#hasHttpSignatureMethods}}\n+import signing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "277e48978c58712538cec73939bae8efc9fca4f1"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "719146d165cb10b8ad9b32a82c34e929c41ed6d3", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/719146d165cb10b8ad9b32a82c34e929c41ed6d3", "committedDate": "2020-01-15T22:03:10Z", "message": "Continue to refactor code to dedicated file for HTTP signatures"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTUzOTcy", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#pullrequestreview-343553972", "createdAt": "2020-01-15T22:05:45Z", "commit": {"oid": "719146d165cb10b8ad9b32a82c34e929c41ed6d3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMjowNTo0NVrOFeH9ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMjowNTo0NVrOFeH9ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzMjAwNA==", "bodyText": "How about making this public boolean and move this into DefaultCodegen?\nThen you can invoke it with config.hasHttpSignatureMethods(blah..)", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367132004", "createdAt": "2020-01-15T22:05:45Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "diffHunk": "@@ -1332,6 +1335,19 @@ private boolean hasBearerMethods(List<CodegenSecurity> authMethods) {\n         return false;\n     }\n \n+    // hasHttpSignatureMethods returns true if the specified OAS model has\n+    // HTTP signature methods.\n+    // The HTTP signature scheme is defined in https://datatracker.ietf.org/doc/draft-cavage-http-signatures/\n+    private boolean hasHttpSignatureMethods(List<CodegenSecurity> authMethods) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "719146d165cb10b8ad9b32a82c34e929c41ed6d3"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31519820f6e0a8a06805d6a84a9dfaa17eb122eb", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/31519820f6e0a8a06805d6a84a9dfaa17eb122eb", "committedDate": "2020-01-15T23:13:21Z", "message": "move method to ProcessUtils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fd84329220997e6a77c82d5bc56c3036fa5f1c8", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/6fd84329220997e6a77c82d5bc56c3036fa5f1c8", "committedDate": "2020-01-15T23:13:46Z", "message": "conditionally build signing.py"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb124210a23ff595c191e0230c6b35ab86476aa5", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/bb124210a23ff595c191e0230c6b35ab86476aa5", "committedDate": "2020-01-15T23:16:12Z", "message": "move method to ProcessUtils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21c478fe7e19b6641b964b615ffb32cad66441c1", "author": {"user": {"login": "sebastien-rosset", "name": "Sebastien Rosset"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/21c478fe7e19b6641b964b615ffb32cad66441c1", "committedDate": "2020-01-15T23:17:35Z", "message": "Merge branch 'http-signature' of github.com:CiscoM31/openapi-generator into python-http-signature"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1941, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}