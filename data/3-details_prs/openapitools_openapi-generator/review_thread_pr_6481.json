{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0OTMzNjky", "number": 6481, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMDowMDozM1rOEA1NOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMDowMDozM1rOEA1NOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MzA3MTk0OnYy", "diffSide": "RIGHT", "path": "samples/client/petstore/rust/reqwest/fileResponseTest/src/apis/default_api.rs", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMDowMDozNFrOGcWkcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxODoxODoyN1rOGc6diw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4MzA4OA==", "bodyText": "hey \ud83d\ude4b\u200d\u2642\ufe0f  great attempt on this issue, but this isn't complete yet.\nThe openapi spec allows for defining a schema for every possible response status: eg\n\"responses\": {\n    \"200\": {},\n    \"202\": {},\n    \"400\": {},\n    \"default\": {}\n}\nso instead of just checking for a success status, you'll need to match over the response status.\nand deserialize based on the defined schema for that status as well as the fallback(default) schema.\nI imagine this means that the return type of methods would become an enum,\npub enum OperationIdResponse {\n    Status200(Status200Schema),\n    Status202(Status202Schema),\n    Status400(Status400Schema),\n    Unspecified(DefaultSchema)\n}\n\n// .. snip\nmatch response.status().as_u16() {\n    200 => Ok(OperationIdResponse::Status200(response.json().await?))\n    202 => Ok(OperationIdResponse::Status202(response.json().await?))\n    400 => Ok(OperationIdResponse::Status400(response.json().await?))\n    _ => Ok(OperationIdResponse::Unspecified(response.json().await?))\n}\n// .. snip", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6481#discussion_r432383088", "createdAt": "2020-05-29T10:00:34Z", "author": {"login": "seunlanlege"}, "path": "samples/client/petstore/rust/reqwest/fileResponseTest/src/apis/default_api.rs", "diffHunk": "@@ -47,7 +47,16 @@ impl DefaultApi for DefaultApiClient {\n         }\n \n         let req = req_builder.build()?;\n-        Ok(client.execute(req)?.error_for_status()?.json()?)\n+        let mut resp = client.execute(req)?;\n+        if resp.status().is_success() {\n+            Ok(resp.json()?)\n+        } else {\n+            let status = resp.status();\n+            let content = resp.text()?;\n+            let entity: Option<serde_json::Value> = serde_json::from_str(&content).ok();\n+            let error = crate::apis::ResponseErrorContent { status, content, entity };\n+            Err(Error::ResponseError(error))\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "948d653806c6593cca5a96c59b6f53efdca255ee"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyMTQ3Ng==", "bodyText": "Hi @seunlanlege,\nThanks for your comment. I know this is just a first attempt which is incomplete.\nI had the same idea of an enum as response, but I don't like it. I think we should not return Ok when the return status is not ok\u2026", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6481#discussion_r432421476", "createdAt": "2020-05-29T11:26:02Z", "author": {"login": "bcourtine"}, "path": "samples/client/petstore/rust/reqwest/fileResponseTest/src/apis/default_api.rs", "diffHunk": "@@ -47,7 +47,16 @@ impl DefaultApi for DefaultApiClient {\n         }\n \n         let req = req_builder.build()?;\n-        Ok(client.execute(req)?.error_for_status()?.json()?)\n+        let mut resp = client.execute(req)?;\n+        if resp.status().is_success() {\n+            Ok(resp.json()?)\n+        } else {\n+            let status = resp.status();\n+            let content = resp.text()?;\n+            let entity: Option<serde_json::Value> = serde_json::from_str(&content).ok();\n+            let error = crate::apis::ResponseErrorContent { status, content, entity };\n+            Err(Error::ResponseError(error))\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4MzA4OA=="}, "originalCommit": {"oid": "948d653806c6593cca5a96c59b6f53efdca255ee"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyNjI0Mw==", "bodyText": "I am working on something like:\n#[derive(Debug, Clone)]\npub struct ResponseErrorContent<T> {\n    pub status: reqwest::StatusCode,\n    pub content: String,\n    pub entity: Option<T>,\n}\n\n#[derive(Debug)]\npub enum Error<T> {\n    Reqwest(reqwest::Error),\n    Serde(serde_json::Error),\n    Io(std::io::Error),\n    ResponseError(ResponseErrorContent<T>),\n}\nwhere T could be an enum of error types corresponding to error codes.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6481#discussion_r432426243", "createdAt": "2020-05-29T11:37:03Z", "author": {"login": "bcourtine"}, "path": "samples/client/petstore/rust/reqwest/fileResponseTest/src/apis/default_api.rs", "diffHunk": "@@ -47,7 +47,16 @@ impl DefaultApi for DefaultApiClient {\n         }\n \n         let req = req_builder.build()?;\n-        Ok(client.execute(req)?.error_for_status()?.json()?)\n+        let mut resp = client.execute(req)?;\n+        if resp.status().is_success() {\n+            Ok(resp.json()?)\n+        } else {\n+            let status = resp.status();\n+            let content = resp.text()?;\n+            let entity: Option<serde_json::Value> = serde_json::from_str(&content).ok();\n+            let error = crate::apis::ResponseErrorContent { status, content, entity };\n+            Err(Error::ResponseError(error))\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4MzA4OA=="}, "originalCommit": {"oid": "948d653806c6593cca5a96c59b6f53efdca255ee"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQzMzQxMg==", "bodyText": "also bear in mind that there could be more than one success response in the 2xx range, So success types would potentially be an enum", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6481#discussion_r432433412", "createdAt": "2020-05-29T11:53:58Z", "author": {"login": "seunlanlege"}, "path": "samples/client/petstore/rust/reqwest/fileResponseTest/src/apis/default_api.rs", "diffHunk": "@@ -47,7 +47,16 @@ impl DefaultApi for DefaultApiClient {\n         }\n \n         let req = req_builder.build()?;\n-        Ok(client.execute(req)?.error_for_status()?.json()?)\n+        let mut resp = client.execute(req)?;\n+        if resp.status().is_success() {\n+            Ok(resp.json()?)\n+        } else {\n+            let status = resp.status();\n+            let content = resp.text()?;\n+            let entity: Option<serde_json::Value> = serde_json::from_str(&content).ok();\n+            let error = crate::apis::ResponseErrorContent { status, content, entity };\n+            Err(Error::ResponseError(error))\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4MzA4OA=="}, "originalCommit": {"oid": "948d653806c6593cca5a96c59b6f53efdca255ee"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ1MTY3OA==", "bodyText": "With an enum, multiple success codes can be handled, but this case is not frequent. So I don't know if it is worth complicating the generated code for this.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6481#discussion_r432451678", "createdAt": "2020-05-29T12:32:54Z", "author": {"login": "bcourtine"}, "path": "samples/client/petstore/rust/reqwest/fileResponseTest/src/apis/default_api.rs", "diffHunk": "@@ -47,7 +47,16 @@ impl DefaultApi for DefaultApiClient {\n         }\n \n         let req = req_builder.build()?;\n-        Ok(client.execute(req)?.error_for_status()?.json()?)\n+        let mut resp = client.execute(req)?;\n+        if resp.status().is_success() {\n+            Ok(resp.json()?)\n+        } else {\n+            let status = resp.status();\n+            let content = resp.text()?;\n+            let entity: Option<serde_json::Value> = serde_json::from_str(&content).ok();\n+            let error = crate::apis::ResponseErrorContent { status, content, entity };\n+            Err(Error::ResponseError(error))\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4MzA4OA=="}, "originalCommit": {"oid": "948d653806c6593cca5a96c59b6f53efdca255ee"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3MTE0Nw==", "bodyText": "multiple success codes can be handled, but this case is not frequent.\n\nunfortunately it's actually very common \ud83d\ude05\njira/sendgrid's openapi specifications have multiple 2xx success schemas", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6481#discussion_r432971147", "createdAt": "2020-05-31T18:18:27Z", "author": {"login": "seunlanlege"}, "path": "samples/client/petstore/rust/reqwest/fileResponseTest/src/apis/default_api.rs", "diffHunk": "@@ -47,7 +47,16 @@ impl DefaultApi for DefaultApiClient {\n         }\n \n         let req = req_builder.build()?;\n-        Ok(client.execute(req)?.error_for_status()?.json()?)\n+        let mut resp = client.execute(req)?;\n+        if resp.status().is_success() {\n+            Ok(resp.json()?)\n+        } else {\n+            let status = resp.status();\n+            let content = resp.text()?;\n+            let entity: Option<serde_json::Value> = serde_json::from_str(&content).ok();\n+            let error = crate::apis::ResponseErrorContent { status, content, entity };\n+            Err(Error::ResponseError(error))\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4MzA4OA=="}, "originalCommit": {"oid": "948d653806c6593cca5a96c59b6f53efdca255ee"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3383, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}