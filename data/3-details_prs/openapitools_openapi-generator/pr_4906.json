{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4NTI2Nzk4", "number": 4906, "title": "[CORE] Fixes composed schema discriminator map", "bodyText": "This PR improves how we define and handle discriminators.\nWe have added a feature flag legacyDiscriminatorBehavior\nWhen it is set to false we:\n\ndefine the CodegenDiscriminator on all models that have a discriminator, including the ones that allOf inherit it from an ancestor\nfill in the discriminator MappedModels map with data from data from 6 sources (see them described below)\nvalidate the discriminator presence: validate that oneOf or anyOf models contain the required discriminator. If they do not contain it helpful errors are thrown.\n\nI am doing this for the the below reasons:\nNot all codegen models use extend to make composed models.\nOn generators that don't do that, they could lack the inherited discriminator.\nPython experimental is an example where we don't use class inheritance to allOf inherit parent classes/models.\nIn that generator, discriminator is defined in each codegenModel, so we should not rely on java's composed schema inheritance solution to set a granparent's discriminator on a child model and a grandchild model that allOf inherit their ancestors.\nWe also need to do this if we want the values of the CodegenDiscriminator MappedModels to differ from grandparent to parent to child. When we include the below 1-6 sources of MappedModels, the MappedModels map will differ depending upon which model you are looking at (grandparent/parent/child)\nMy solution is to have the code set the discriminator on each model that contains a discriminator.\nPrior to this PR models that inherit a discriminator do not contain a discriminator.\nThen on that CodegenDiscriminator add the following to MappedModels:\n\nany mappings from the current or inherited schema Discriminator Mapping\nany x-discriminator-value mappings in:\n\nchild models that allOf inherit from the the current schema\noneOf models in the current schema\nanyOf models in the current schema\n\n\nany child models that allOf inherit from the the current schema\nany descendent models that allOf inherit from the above child models\noneOf models in the current schema\nanyOf models in the current schema\n\nWhy Feature Flag This?\n\nSome generators (javascript, probably others) implement discriminators differently and do not work if we set the flag to True. Cordoning this off behind the feature flag allows us to fix them later.\nThis is a really big change\nI want to support legacy users who bring their old mustache files but use the latest generator code\nEven though I could get all tests to pass, that does not mean that all models are being tested\n\nWhen the flag is true, Java models Cat and Dog now have discriminators with empty maps. I do not know if that is okay.\n\n\n\nBackground Context:\nWhen using oneOf or anyOf models with a discriminator in a parent composed schema, the discriminator map does not include the child oneOf models.\nThis is because our existing java code was only covering the use case where there are descedant schemas which allOf inherit from the current schemas. It was not aware of and handling cases where the current schema is composed and there are oneOf any anyOf schemas that should be added to the discriminator MappedModels.\nBelow is an example spec where the oneOf models should be in FruitRequiredDesc's discriminator map:\n    FruitType:\n      properties:\n        fruitType:\n          type: string\n      required:\n      - fruitType\n    FruitRequiredDesc:\n      oneOf:\n        - $ref: '#/components/schemas/AppleRequiredDesc'\n        - $ref: '#/components/schemas/BananaRequiredDesc'\n      discriminator:\n        propertyName: fruitType\n    AppleRequiredDesc:\n      type: object\n      required:\n        - seeds\n      properties:\n        seeds:\n          type: integer\n      allOf:\n        - $ref: '#/components/schemas/FruitType'\n    BananaRequiredDesc:\n      type: object\n      required:\n        - length\n      properties:\n        length:\n          type: integer\n      allOf:\n        - $ref: '#/components/schemas/FruitType'\n\nTest Verification\n\nMany tests have been added, see the PR\n\nRelated Issues\nIf merged, this will close out #4904\n\n Read the contribution guidelines.\n If contributing template-only or documentation-only changes which will change sample output, build the project before.\n Run the shell script(s) under ./bin/ (or Windows batch scripts under.\\bin\\windows) to update Petstore samples related to your fix. This is important, as CI jobs will verify all generator outputs of your HEAD commit, and these must match the expectations made by your contribution. You only need to run ./bin/{LANG}-petstore.sh, ./bin/openapi3/{LANG}-petstore.sh if updating the code or mustache templates for a language ({LANG}) (e.g. php, ruby, python, etc).\n File the PR against the correct branch: master, 4.3.x, 5.0.x. Default: master.\n Copy the technical committee to review the pull request if your PR is targeting a particular programming language.\n\nCore Team:\n@wing328 (2015/07)\n@jimschubert (2016/05)\n@cbornet (2016/05)\n@ackintosh (2018/02)\n@jmini (2018/04)\n@etherealjoy (2019/06)", "createdAt": "2020-01-01T23:40:01Z", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906", "merged": true, "mergeCommit": {"oid": "8e8471c1fd6a25b032dcf3ba43968777d59b7322"}, "closed": true, "closedAt": "2020-04-24T16:01:03Z", "author": {"login": "spacether"}, "timelineItems": {"totalCount": 47, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4ZXGogFqTM0MDA0NTg0Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcaufVHAH2gAyMzU4NTI2Nzk4OmY4Yzk1ZDg4NjVlMGE0YTdhMmUzZGMxYjIwYTNjOTA5ZjAyMDVjYTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwMDQ1ODQy", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#pullrequestreview-340045842", "createdAt": "2020-01-08T18:07:32Z", "commit": {"oid": "47477c0cf1949657b464ec4f7fd7c11bfeae1016"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxODowNzozM1rOFbfSyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxODowNzozM1rOFbfSyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM2ODU4Ng==", "bodyText": "It would be good to add function comments and essentially copy the text from the PR to help understand what this is doing.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r364368586", "createdAt": "2020-01-08T18:07:33Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,49 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47477c0cf1949657b464ec4f7fd7c11bfeae1016"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NzUxNjMw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#pullrequestreview-347751630", "createdAt": "2020-01-24T05:00:24Z", "commit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNTowMDoyNFrOFhT9yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNToxMTo0MFrOFhUEEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw==", "bodyText": "@spacether question... Could you include a test for the operation response model as well?\nThis test is great for direct Schema reference, but we often have issue with $ref processing to those schemas.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370474443", "createdAt": "2020-01-24T05:00:24Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "diffHunk": "@@ -548,14 +539,31 @@ public void testFreeFormObjects() {\n     public void testBearerAuth() {\n         final OpenAPI openAPI = TestUtils.parseSpec(\"src/test/resources/3_0/pingBearerAuth.yaml\");\n         JavaClientCodegen codegen = new JavaClientCodegen();\n-        \n+\n         List<CodegenSecurity> security = codegen.fromSecurity(openAPI.getComponents().getSecuritySchemes());\n         Assert.assertEquals(security.size(), 1);\n         Assert.assertEquals(security.get(0).isBasic, Boolean.TRUE);\n         Assert.assertEquals(security.get(0).isBasicBasic, Boolean.FALSE);\n         Assert.assertEquals(security.get(0).isBasicBearer, Boolean.TRUE);\n     }\n \n+    @Test\n+    public void testComposedSchemaOneOfDiscriminatorMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA==", "bodyText": "This will fail, as these schemas may also be defined inline rather than as a $ref.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370474940", "createdAt": "2020-01-24T05:03:41Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NTYwOQ==", "bodyText": "Looks like this would fail if allOf is null (like if the ComposedModel is oneOf)?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370475609", "createdAt": "2020-01-24T05:08:35Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());\n+                Schema refSchema = ModelUtils.getSchema(this.openAPI, modelName);\n+                Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+                if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                    discriminator.getMappedModels().add(new MappedModel(modelName, toModelName(modelName)));\n+                    continue;\n+                }\n+                Boolean mapped = false;\n+                if (ModelUtils.isComposedSchema(refSchema)) {\n+                    ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+                    for  (Schema allOf: composedSchema.getAllOf()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NjA1MQ==", "bodyText": "What about removing the mapped flag used as control flow and move the error message up? I think the logic around mapped is hard to follow, and could easily get messed up later.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370476051", "createdAt": "2020-01-24T05:11:40Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());\n+                Schema refSchema = ModelUtils.getSchema(this.openAPI, modelName);\n+                Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+                if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                    discriminator.getMappedModels().add(new MappedModel(modelName, toModelName(modelName)));\n+                    continue;\n+                }\n+                Boolean mapped = false;\n+                if (ModelUtils.isComposedSchema(refSchema)) {\n+                    ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+                    for  (Schema allOf: composedSchema.getAllOf()) {\n+                        String allmodelName = ModelUtils.getSimpleRef(allOf.get$ref());\n+                        refSchema = ModelUtils.getSchema(this.openAPI, allmodelName);\n+                        discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+                        if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                            discriminator.getMappedModels().add(new MappedModel(modelName, toModelName(modelName)));\n+                            mapped = true;\n+                            break;\n+                        }\n+                    }\n+                    if (mapped) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4Mjk2NTg1", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#pullrequestreview-348296585", "createdAt": "2020-01-25T00:58:09Z", "commit": {"oid": "09f7275560afe0e12df830dd3074405c36c9fe8c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwMDo1ODowOVrOFht8zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwMDo1ODowOVrOFht8zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwMDE3NQ==", "bodyText": "This is needed if a schema omits allOf but includes anyOf or oneOf", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370900175", "createdAt": "2020-01-25T00:58:09Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2109,20 +2196,26 @@ protected void addProperties(Map<String, Schema> properties, List<String> requir\n         if (schema instanceof ComposedSchema) {\n             ComposedSchema composedSchema = (ComposedSchema) schema;\n \n-            for (Schema component : composedSchema.getAllOf()) {\n-                addProperties(properties, required, component);\n+            if (composedSchema.getAllOf() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09f7275560afe0e12df830dd3074405c36c9fe8c"}, "originalPosition": 133}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "53d4715cc93b671b616ab44efb1ae638a0f246ad", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/53d4715cc93b671b616ab44efb1ae638a0f246ad", "committedDate": "2020-01-25T21:23:37Z", "message": "Adds inline example model"}, "afterCommit": {"oid": "ddb672aaa908b95d35293d287bd4a50092a265ff", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/ddb672aaa908b95d35293d287bd4a50092a265ff", "committedDate": "2020-01-25T21:25:43Z", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7fb52f62ab27a471556220b04b6618b3667256c4", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/7fb52f62ab27a471556220b04b6618b3667256c4", "committedDate": "2020-01-29T18:01:25Z", "message": "Adds recursive search of dscriminator when examining a schema"}, "afterCommit": {"oid": "814b8a776a0159ded6444f52b0dc91517c86d289", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/814b8a776a0159ded6444f52b0dc91517c86d289", "committedDate": "2020-02-04T03:27:05Z", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap\n\nUses inlineModelResolver on openapi spec\n\nAdds ParseFlattenSpec\n\nReferts DefaultCodegenTest.java\n\nAdds null ref handling in addComposedMappedModels, adds test case\n\nAdds recursive search of dscriminator when examining a schema"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "814b8a776a0159ded6444f52b0dc91517c86d289", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/814b8a776a0159ded6444f52b0dc91517c86d289", "committedDate": "2020-02-04T03:27:05Z", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap\n\nUses inlineModelResolver on openapi spec\n\nAdds ParseFlattenSpec\n\nReferts DefaultCodegenTest.java\n\nAdds null ref handling in addComposedMappedModels, adds test case\n\nAdds recursive search of dscriminator when examining a schema"}, "afterCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4", "committedDate": "2020-02-04T03:30:22Z", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap\n\nUses inlineModelResolver on openapi spec\n\nAdds ParseFlattenSpec\n\nReferts DefaultCodegenTest.java\n\nAdds null ref handling in addComposedMappedModels, adds test case\n\nAdds recursive search of dscriminator when examining a schema"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNzExMzYw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#pullrequestreview-352711360", "createdAt": "2020-02-04T03:56:43Z", "commit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMzo1Njo0NFrOFlHbeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNDo1Njo1NFrOFlIGVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2MzM1NA==", "bodyText": "I don't understand this error. allOf without a discriminator means composition, while allOf with a discriminator means inheritance. As a user I'd find this error very confusing.  From the spec:\n\nThe OpenAPI Specification allows combining and extending model definitions using the allOf property of JSON Schema, in effect offering model composition. allOf takes an array of object definitions that are validated independently but together compose a single object.\nWhile composition offers model extensibility, it does not imply a hierarchy between the models. To support polymorphism, the OpenAPI Specification adds the discriminator field. When used, the discriminator will be the name of the property that decides which schema definition validates the structure of the model. As such, the discriminator field MUST be a required field.\n\nWhen a discriminator exists, inline schemas won't be honored (only $ref). From the spec:\n\nWhen using the discriminator, inline schemas will not be considered.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374463354", "createdAt": "2020-02-04T03:56:44Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    continue;\n+                }\n+                Boolean discFound = discriminatorFound(sc, discPropName);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (discFound == false) {\n+                    LOGGER.error(\"schema {} is lacking the required string discriminator {}\", modelName, discPropName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NDUxNg==", "bodyText": "This isn't correct to throw an error for missing discriminator. Notice use of MAY in the spec and not MUST:\nIn OAS 3.0, a response payload MAY be described to be exactly one of any number of types:\nMyResponseType:\n  oneOf:\n  - $ref: '#/components/schemas/Cat'\n  - $ref: '#/components/schemas/Dog'\n  - $ref: '#/components/schemas/Lizard'\n\nwhich means the payload MUST, by validation, match exactly one of the schemas described by Cat, Dog, or Lizard. In this case, a discriminator MAY act as a \"hint\" to shortcut validation and selection of the matching schema which may be a costly operation, depending on the complexity of the schema.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374464516", "createdAt": "2020-02-04T04:02:47Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NjQ3OQ==", "bodyText": "We should actively disallow infinite loops, as circular references are allowed in the spec.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374466479", "createdAt": "2020-02-04T04:13:13Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2160,16 +2250,23 @@ protected CodegenDiscriminator createDiscriminator(String schemaName, Schema sch\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n+            if (ModelUtils.isComposedSchema(schema)) {\n+                // if all oneOf/amyOf schemas contain the discriminator, then use it when mapping\n+                addComposedMappedModels(discriminator, (ComposedSchema) schema, discPropName);\n+            } else {\n+                // we have child models that include a parent with allOf: parent and the parent does NOT have composed schema\n+                // If the parent has composed schema we go an infinite loop parent->child-> parent in getAllParentsName and addProperties", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MjMwNw==", "bodyText": "@spacether I'm sorry, but I don't follow your question, or why you've linked to InlineModelResolver when I'd asked about $ref.  Responses are processed similarly to all other models (see: \n  \n    \n      openapi-generator/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java\n    \n    \n         Line 2001\n      in\n      e45a1d0\n    \n    \n    \n    \n\n        \n          \n           String ref = ModelUtils.getSimpleRef(interfaceSchema.get$ref()); \n        \n    \n  \n\n). However, composed models have special rules around  how structure is defined in the presence of absence of discriminator and explicitly defines that inline models are ignored when using discriminator in most (all? I'd have to look again) cases. I'm confused because you appear to only be supporting discriminator based Schemas, and the spec says to drop inline models in those cases.\nJust for clarification so I understand what part of the spec is being done in the PR (it would help me in the review), can you describe your intended behaviors with respect to the three composed schemas, each with and without discriminator, and what you consider to be the outputs?  In reading your comments in Slack and in the PR, it's seems like you're only targeting inheritance (which is fine) and making some assumptions about the spec (which is fine as long as it's clearly explained to the user). I can't tell from the code or comments if this is intentional or not. That is, is the goal a short-term implementation path without breaking existing code?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374472307", "createdAt": "2020-02-04T04:45:37Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "diffHunk": "@@ -548,14 +539,31 @@ public void testFreeFormObjects() {\n     public void testBearerAuth() {\n         final OpenAPI openAPI = TestUtils.parseSpec(\"src/test/resources/3_0/pingBearerAuth.yaml\");\n         JavaClientCodegen codegen = new JavaClientCodegen();\n-        \n+\n         List<CodegenSecurity> security = codegen.fromSecurity(openAPI.getComponents().getSecuritySchemes());\n         Assert.assertEquals(security.size(), 1);\n         Assert.assertEquals(security.get(0).isBasic, Boolean.TRUE);\n         Assert.assertEquals(security.get(0).isBasicBasic, Boolean.FALSE);\n         Assert.assertEquals(security.get(0).isBasicBearer, Boolean.TRUE);\n     }\n \n+    @Test\n+    public void testComposedSchemaOneOfDiscriminatorMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, "originalCommit": {"oid": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzI4OQ==", "bodyText": "From https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#discriminator-object\n\nWhen using the discriminator, inline schemas will not be considered.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374473289", "createdAt": "2020-02-04T04:50:58Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzUxMA==", "bodyText": "This should imply common inheritance between Apple and Banana.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374473510", "createdAt": "2020-02-04T04:52:12Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:\n+        propertyName: fruitType\n+    FruitInlineInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+          properties:\n+            seeds:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+        - type: object\n+          required:\n+            - length\n+          properties:\n+            length:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+      discriminator:\n+        propertyName: fruitType\n+    FruitReqDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleReqDisc'\n+        - $ref: '#/components/schemas/BananaReqDisc'\n+      discriminator:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MzkwMQ==", "bodyText": "These inline models should be ignored per spec", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374473901", "createdAt": "2020-02-04T04:54:30Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:\n+        propertyName: fruitType\n+    FruitInlineInlineDisc:\n+      oneOf:\n+        - type: object", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NDMyNQ==", "bodyText": "allOf without discriminator should be composition (Parent has a FruitType, rather than Parent is a FruitType).", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374474325", "createdAt": "2020-02-04T04:56:54Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/test/resources/3_0/oneoOfDiscriminator.yaml", "diffHunk": "@@ -0,0 +1,201 @@\n+openapi: 3.0.1\n+info:\n+   title: fruity\n+   version: 0.0.1\n+paths:\n+   /:\n+      get:\n+         responses:\n+            '200':\n+               description: desc\n+               content:\n+                  application/json:\n+                     schema:\n+                        $ref: '#/components/schemas/FruitAllOfDisc'\n+components:\n+   schemas:\n+    FruitType:\n+      properties:\n+        fruitType:\n+          type: string\n+      required:\n+      - fruitType\n+    FruitInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+            - fruitType\n+          properties:\n+            seeds:\n+              type: integer\n+            fruitType:\n+              type: string\n+        - type: object\n+          required:\n+            - length\n+            - fruitType\n+          properties:\n+            length:\n+              type: integer\n+            fruitType:\n+              type: string\n+      discriminator:\n+        propertyName: fruitType\n+    FruitInlineInlineDisc:\n+      oneOf:\n+        - type: object\n+          required:\n+            - seeds\n+          properties:\n+            seeds:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+        - type: object\n+          required:\n+            - length\n+          properties:\n+            length:\n+              type: integer\n+          oneOf:\n+            - type: object\n+              properties:\n+                fruitType:\n+                  type: string\n+              required:\n+              - fruitType\n+      discriminator:\n+        propertyName: fruitType\n+    FruitReqDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleReqDisc'\n+        - $ref: '#/components/schemas/BananaReqDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    AppleReqDisc:\n+      type: object\n+      required:\n+        - seeds\n+        - fruitType\n+      properties:\n+        seeds:\n+          type: integer\n+        fruitType:\n+          type: string\n+    BananaReqDisc:\n+      type: object\n+      required:\n+        - length\n+        - fruitType\n+      properties:\n+        length:\n+          type: integer\n+        fruitType:\n+          type: string\n+    FruitAllOfDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleAllOfDisc'\n+        - $ref: '#/components/schemas/BananaAllOfDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    AppleAllOfDisc:\n+      type: object\n+      required:\n+        - seeds\n+      properties:\n+        seeds:\n+          type: integer\n+      allOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    BananaAllOfDisc:\n+      type: object\n+      required:\n+        - length\n+      properties:\n+        length:\n+          type: integer\n+      allOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    FruitAnyOfDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleAnyOfDisc'\n+        - $ref: '#/components/schemas/BananaAnyOfDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    AppleAnyOfDisc:\n+      type: object\n+      required:\n+        - seeds\n+      properties:\n+        seeds:\n+          type: integer\n+      anyOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    BananaAnyOfDisc:\n+      type: object\n+      required:\n+        - length\n+      properties:\n+        length:\n+          type: integer\n+      anyOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    FruitOneOfDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleOneOfDisc'\n+        - $ref: '#/components/schemas/BananaOneOfDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    AppleOneOfDisc:\n+      type: object\n+      required:\n+        - seeds\n+      properties:\n+        seeds:\n+          type: integer\n+      oneOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    BananaOneOfDisc:\n+      type: object\n+      required:\n+        - length\n+      properties:\n+        length:\n+          type: integer\n+      oneOf:\n+        - $ref: '#/components/schemas/FruitType'\n+    FruitGrandparentDisc:\n+      oneOf:\n+        - $ref: '#/components/schemas/AppleGrandparentDisc'\n+        - $ref: '#/components/schemas/BananaGrandparentDisc'\n+      discriminator:\n+        propertyName: fruitType\n+    Parent:\n+      type: object\n+      allOf:\n+        # the FruitType schema is a grandparent of AppleGrandparentDisc + BananaGrandparentDisc", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4"}, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MDkwMTY0", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#pullrequestreview-356090164", "createdAt": "2020-02-10T16:42:24Z", "commit": {"oid": "53200bf33907c12cba6b769cef105fe76669399d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjo0MjoyNFrOFntQ7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjo0MjoyNFrOFntQ7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4MDM5OA==", "bodyText": "Should we include anyOf here?\nI don't thinks so. If one includes a discriminator with anyof then the discriminator must be used and the functionality is the same as oneof. Also because one is including the class name, it is not possible to match multiple schemas in that use case.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r377180398", "createdAt": "2020-02-10T16:42:24Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,104 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(String composedSchemaName, CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53200bf33907c12cba6b769cef105fe76669399d"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NDY4OTY1", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#pullrequestreview-359468965", "createdAt": "2020-02-17T03:10:46Z", "commit": {"oid": "53200bf33907c12cba6b769cef105fe76669399d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwMzoxMDo0NlrOFqXgmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwMzoxMDo0NlrOFqXgmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2OTY4OQ==", "bodyText": "Small typo: amyOf", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r379969689", "createdAt": "2020-02-17T03:10:46Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2160,16 +2252,23 @@ protected CodegenDiscriminator createDiscriminator(String schemaName, Schema sch\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n+            if (ModelUtils.isComposedSchema(schema)) {\n+                // if all oneOf/amyOf schemas contain the discriminator, then use it when mapping", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53200bf33907c12cba6b769cef105fe76669399d"}, "originalPosition": 127}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d56c48d8facc5fc52f0fedc9580c9a52bfb41c19", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/d56c48d8facc5fc52f0fedc9580c9a52bfb41c19", "committedDate": "2020-02-18T08:02:22Z", "message": "Updates a commnet"}, "afterCommit": {"oid": "2cd595973b8ba21af0b0690f2ba4be8ee5ac8e4c", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/2cd595973b8ba21af0b0690f2ba4be8ee5ac8e4c", "committedDate": "2020-02-19T18:16:09Z", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1OTMxMjY4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#pullrequestreview-365931268", "createdAt": "2020-02-27T19:19:52Z", "commit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToxOTo1MlrOFveA4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToxOTo1MlrOFveA4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxOTEzOQ==", "bodyText": "We are adding more models to our discriminator map here than we have in the past.\nShould we add those models into the models import where this is called in fromModel?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r385319139", "createdAt": "2020-02-27T19:19:52Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2267,35 +2284,242 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Recursively look in Schema sc for the discriminator and return it\n+     * If we return it from allOf, oneOf, or anyOf, then do not include the\n+     * discriminator map from that location because it is not relevant at our\n+     * Schema sc location\n+     * @param sc The Schema that may contain the discriminator\n+     */\n+    private Discriminator recursiveGetDiscriminator(Schema sc) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        Discriminator foundDisc = refSchema.getDiscriminator();\n+        if (foundDisc != null) {\n+            return foundDisc;\n+        }\n+        Discriminator disc = new Discriminator();\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    foundDisc = recursiveGetDiscriminator(allOf);\n+                    if (foundDisc != null) {\n+                        disc.setPropertyName(foundDisc.getPropertyName());\n+                        return disc;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    foundDisc = recursiveGetDiscriminator(oneOf);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    return disc;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    foundDisc = recursiveGetDiscriminator(anyOf);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    return disc;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * a list if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @return the list of oneOf and anyOf schema names that need to be added to the discriminator map\n+     */\n+    protected List<String> getOneOfAnyOfSchemaNames(String composedSchemaName, String discPropName, ComposedSchema c) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        Set<String> descendentSchemas = new HashSet<>();\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    throw new RuntimeException(\"Invalid inline schema defined in oneOf/anyOf in '\" + composedSchemaName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the oneOf/anyOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                }\n+                Boolean discFound = discriminatorFound(sc, discPropName);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (discFound == false) {\n+                    throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced schema '\" + modelName + \"' is missing this property\");\n+                }\n+                descendentSchemas.add(modelName);\n+            }\n+        }\n+        List<String> modelNames = new ArrayList<>(descendentSchemas);\n+        Collections.sort(modelNames);\n+        return modelNames;\n+    }\n+\n+    protected List<String> getDescendentSchemaNames(String thisSchemaName) {\n+        ArrayList<String> queue = new ArrayList<String>();\n+        Set<String> descendentSchemas = new HashSet<>();\n+        Map<String, Schema> schemas = ModelUtils.getSchemas(this.openAPI);\n+        String currentSchemaName = thisSchemaName;\n+        while (true) {\n+            for (String childName : schemas.keySet()) {\n+                if (childName == thisSchemaName) {\n+                    continue;\n+                }\n+                Schema child = schemas.get(childName);\n+                if (ModelUtils.isComposedSchema(child)) {\n+                    ComposedSchema composedChild = (ComposedSchema) child;\n+                    List<Schema> parents = composedChild.getAllOf();\n+                    if (parents != null) {\n+                        for  (Schema parent: parents) {\n+                            String ref = parent.get$ref();\n+                            if (ref == null) {\n+                                // for schemas with no ref, it is not possible to build the discriminator map\n+                                // because ref is how we get the model name\n+                                // we only hit this use case for a schema with inline composed schemas, and one of those\n+                                // schemas also has inline composed schemas\n+                                throw new RuntimeException(\"Invalid inline schema defined in allOf in '\" + childName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the allOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                            }\n+                            String parentName = ModelUtils.getSimpleRef(ref);\n+                            if (parentName.equals(currentSchemaName)) {\n+                                if (queue.contains(childName) || descendentSchemas.contains(childName)) {\n+                                    throw new RuntimeException(\"Stack overflow hit when looking for \"+thisSchemaName+\" an infinite loop starting and ending at \"+childName+\" was seen\");\n+                                }\n+                                queue.add(childName);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            if (queue.size() == 0) {\n+                break;\n+            }\n+            currentSchemaName = queue.remove(queue.size()-1);\n+            descendentSchemas.add(currentSchemaName);\n+        }\n+        List<String> modelNames = new ArrayList<>(descendentSchemas);\n+        Collections.sort(modelNames);\n+        return modelNames;\n+    }\n+\n     protected CodegenDiscriminator createDiscriminator(String schemaName, Schema schema) {\n-        if (schema.getDiscriminator() == null) {\n+        Discriminator sourceDiscriminator = recursiveGetDiscriminator(schema);\n+        if (sourceDiscriminator == null) {\n             return null;\n         }\n         CodegenDiscriminator discriminator = new CodegenDiscriminator();\n-        discriminator.setPropertyName(toVarName(schema.getDiscriminator().getPropertyName()));\n-        discriminator.setPropertyBaseName(schema.getDiscriminator().getPropertyName());\n+        String discPropName = sourceDiscriminator.getPropertyName();\n+        discriminator.setPropertyName(toVarName(discPropName));\n+        discriminator.setPropertyBaseName(sourceDiscriminator.getPropertyName());\n         discriminator.setPropertyGetter(toGetter(discriminator.getPropertyName()));\n         // FIXME: for now, we assume that the discriminator property is String\n         discriminator.setPropertyType(typeMapping.get(\"string\"));\n-        discriminator.setMapping(schema.getDiscriminator().getMapping());\n-        if (schema.getDiscriminator().getMapping() != null && !schema.getDiscriminator().getMapping().isEmpty()) {\n-            for (Entry<String, String> e : schema.getDiscriminator().getMapping().entrySet()) {\n+        discriminator.setMapping(sourceDiscriminator.getMapping());\n+        if (sourceDiscriminator.getMapping() != null && !sourceDiscriminator.getMapping().isEmpty()) {\n+            for (Entry<String, String> e : sourceDiscriminator.getMapping().entrySet()) {\n                 String nameOrRef = e.getValue();\n                 String name = nameOrRef.indexOf('/') >= 0 ? ModelUtils.getSimpleRef(nameOrRef) : nameOrRef;\n                 String modelName = toModelName(name);\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n-                    }\n+            // for schemas that allOf inherit from this schema, add those descendents to this discriminator map\n+            List<String> allOfDescendents = getDescendentSchemaNames(schemaName);\n+            for (String allOfDescendent: allOfDescendents) {\n+                discriminator.getMappedModels().add(new MappedModel(allOfDescendent, toModelName(allOfDescendent)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "originalPosition": 285}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1OTQ1NTU4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#pullrequestreview-365945558", "createdAt": "2020-02-27T19:41:08Z", "commit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOTo0MTowOFrOFvetSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOTo0MTowOFrOFvetSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzMDUwNA==", "bodyText": "Why did this go away?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r385330504", "createdAt": "2020-02-27T19:41:08Z", "author": {"login": "spacether"}, "path": "samples/client/petstore/csharp/OpenAPIClient/src/Org.OpenAPITools/Model/Animal.cs", "diffHunk": "@@ -32,7 +32,6 @@ namespace Org.OpenAPITools.Model\n     [JsonConverter(typeof(JsonSubtypes), \"ClassName\")]\n     [JsonSubtypes.KnownSubType(typeof(Dog), \"Dog\")]\n     [JsonSubtypes.KnownSubType(typeof(Cat), \"Cat\")]\n-    [JsonSubtypes.KnownSubType(typeof(BigCat), \"BigCat\")]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2ODYwNTM4", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#pullrequestreview-366860538", "createdAt": "2020-03-01T13:50:10Z", "commit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMVQxMzo1MDoxMFrOFwORQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMVQxMzo1NjozNlrOFwOTFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEwOTc2Mg==", "bodyText": "Duplicated?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r386109762", "createdAt": "2020-03-01T13:50:10Z", "author": {"login": "jimschubert"}, "path": "samples/client/petstore/csharp-netcore/OpenAPIClientCore/src/Org.OpenAPITools/Model/Cat.cs", "diffHunk": "@@ -30,6 +31,9 @@ namespace Org.OpenAPITools.Model\n     /// Cat\n     /// </summary>\n     [DataContract]\n+    [JsonConverter(typeof(JsonSubtypes), \"ClassName\")]\n+    [JsonSubtypes.KnownSubType(typeof(BigCat), \"BigCat\")]\n+    [JsonSubtypes.KnownSubType(typeof(BigCat), \"BigCat\")]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjExMDIyOA==", "bodyText": "The discriminators are now moved from base type (Animal) to intermediate types (Cat). I'll look at it and see if I can understand why that is.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r386110228", "createdAt": "2020-03-01T13:56:36Z", "author": {"login": "jimschubert"}, "path": "samples/client/petstore/csharp/OpenAPIClient/src/Org.OpenAPITools/Model/Animal.cs", "diffHunk": "@@ -32,7 +32,6 @@ namespace Org.OpenAPITools.Model\n     [JsonConverter(typeof(JsonSubtypes), \"ClassName\")]\n     [JsonSubtypes.KnownSubType(typeof(Dog), \"Dog\")]\n     [JsonSubtypes.KnownSubType(typeof(Cat), \"Cat\")]\n-    [JsonSubtypes.KnownSubType(typeof(BigCat), \"BigCat\")]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzMDUwNA=="}, "originalCommit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/9b7be7dfbb0549ef31e34d6e55f192a8f970b435", "committedDate": "2020-02-27T18:30:07Z", "message": "Runs ensure-up-to-date"}, "afterCommit": {"oid": "8b36c9750d07354e2cfeee53b9c2ab53187d5dbf", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/8b36c9750d07354e2cfeee53b9c2ab53187d5dbf", "committedDate": "2020-03-02T17:32:45Z", "message": "Runs ensure-up-to-date"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d2ca089b75b0ca82219dad557e7a5ca4a2c26f20", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/d2ca089b75b0ca82219dad557e7a5ca4a2c26f20", "committedDate": "2020-03-02T17:39:33Z", "message": "Merge pull request #1 from jimschubert/spacether-4904-contrib\n\nSpacether 4904 contrib"}, "afterCommit": {"oid": "19bbac94742c09111817327bbe49b64180ce69e3", "author": {"user": {"login": "jimschubert", "name": "Jim Schubert"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/19bbac94742c09111817327bbe49b64180ce69e3", "committedDate": "2020-03-01T15:17:49Z", "message": "[core] Additional oneOf/allOf testing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "90b9849d066d7b6353b129dcea3c3997cff24b1d", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/90b9849d066d7b6353b129dcea3c3997cff24b1d", "committedDate": "2020-03-02T17:53:53Z", "message": "Reverts accidental wide scale replacements of parseFlattenSpec"}, "afterCommit": {"oid": "19bbac94742c09111817327bbe49b64180ce69e3", "author": {"user": {"login": "jimschubert", "name": "Jim Schubert"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/19bbac94742c09111817327bbe49b64180ce69e3", "committedDate": "2020-03-01T15:17:49Z", "message": "[core] Additional oneOf/allOf testing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6500150ccdbdcb6b64e0ba9bc9f3cbc66450e5f6", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/6500150ccdbdcb6b64e0ba9bc9f3cbc66450e5f6", "committedDate": "2020-03-02T18:21:01Z", "message": "Moves all oneOf/anyOf java tests to one file"}, "afterCommit": {"oid": "19bbac94742c09111817327bbe49b64180ce69e3", "author": {"user": {"login": "jimschubert", "name": "Jim Schubert"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/19bbac94742c09111817327bbe49b64180ce69e3", "committedDate": "2020-03-01T15:17:49Z", "message": "[core] Additional oneOf/allOf testing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ac2c5c0deeaca03f6db3cc9a8ec412c76d66c61", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/8ac2c5c0deeaca03f6db3cc9a8ec412c76d66c61", "committedDate": "2020-03-06T20:23:31Z", "message": "Removes csharp-netcore child iteration in discriminator"}, "afterCommit": {"oid": "b74ee76959b0b018e404e379ee2e1728dff4c515", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/b74ee76959b0b018e404e379ee2e1728dff4c515", "committedDate": "2020-03-07T04:30:52Z", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b74ee76959b0b018e404e379ee2e1728dff4c515", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/b74ee76959b0b018e404e379ee2e1728dff4c515", "committedDate": "2020-03-07T04:30:52Z", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap"}, "afterCommit": {"oid": "01aaf89159c906e8ce86802b91564e7650054ef3", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/01aaf89159c906e8ce86802b91564e7650054ef3", "committedDate": "2020-03-07T04:32:51Z", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25a2e2ce8a23b63f3eca86b704c5596e1bfc99f9", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/25a2e2ce8a23b63f3eca86b704c5596e1bfc99f9", "committedDate": "2020-03-13T19:43:18Z", "message": "Adds back recursive getAllOfDescendants functionality, handles the case where a descendent is composed and has properties, don't add its children to the ancestor's discriminator map"}, "afterCommit": {"oid": "9320957e403e86470de7be64c5624049c736ffb0", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/9320957e403e86470de7be64c5624049c736ffb0", "committedDate": "2020-03-17T02:17:37Z", "message": "Adds back recursive getAllOfDescendants functionality, handles the case where a descendent is composed and has properties, don't add its children to the ancestor's discriminator map"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4ee9efbc1c3ec8f445382c72253eb47fa5534c61", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/4ee9efbc1c3ec8f445382c72253eb47fa5534c61", "committedDate": "2020-03-19T20:25:44Z", "message": "Updates discriminator mapping to preserve legacy ordering"}, "afterCommit": {"oid": "9daca2de5438d2f46d6753069ec102b26a439e31", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/9daca2de5438d2f46d6753069ec102b26a439e31", "committedDate": "2020-03-19T20:35:27Z", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9daca2de5438d2f46d6753069ec102b26a439e31", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/9daca2de5438d2f46d6753069ec102b26a439e31", "committedDate": "2020-03-19T20:35:27Z", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap"}, "afterCommit": {"oid": "0d31ce2f90deb738e1daf592ebb95512d985c784", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/0d31ce2f90deb738e1daf592ebb95512d985c784", "committedDate": "2020-03-19T20:44:55Z", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d6f5f0cfb110bc23ec16adb32bf052f05b7c01c5", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/d6f5f0cfb110bc23ec16adb32bf052f05b7c01c5", "committedDate": "2020-03-23T02:01:12Z", "message": "Changes expected string in testLoginUser in openapi3 sample"}, "afterCommit": {"oid": "71c60e067ef0bc2d06493a185fd832cc32374c79", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/71c60e067ef0bc2d06493a185fd832cc32374c79", "committedDate": "2020-03-26T16:38:13Z", "message": "Changes expected string in testLoginUser in openapi3 sample"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "71c60e067ef0bc2d06493a185fd832cc32374c79", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/71c60e067ef0bc2d06493a185fd832cc32374c79", "committedDate": "2020-03-26T16:38:13Z", "message": "Changes expected string in testLoginUser in openapi3 sample"}, "afterCommit": {"oid": "662eaffea7f95660f1cc13c4f3512e0397dd5be3", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/662eaffea7f95660f1cc13c4f3512e0397dd5be3", "committedDate": "2020-03-26T16:41:33Z", "message": "Runs ensure up to date"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "64f986ed34e800ae8912fe59dda1a88b31b85446", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/64f986ed34e800ae8912fe59dda1a88b31b85446", "committedDate": "2020-04-01T22:24:54Z", "message": "Adds updates from Sebastien Rosset"}, "afterCommit": {"oid": "035436f960c508d9b73fa2acaebec3f6e0ea7195", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/035436f960c508d9b73fa2acaebec3f6e0ea7195", "committedDate": "2020-04-01T22:28:02Z", "message": "Adds updates from Sebastien Rosset"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1Njk5NzYw", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#pullrequestreview-385699760", "createdAt": "2020-04-01T15:29:14Z", "commit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNToyOToxNFrOF_GJcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDo0ODoxNFrOF_u5RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcwNTMzMA==", "bodyText": "Typo: disciminator", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401705330", "createdAt": "2020-04-01T15:29:14Z", "author": {"login": "sebastien-rosset"}, "path": "docs/generators/ada-server.md", "diffHunk": "@@ -6,6 +6,7 @@ sidebar_label: ada-server\n | Option | Description | Values | Default |\n | ------ | ----------- | ------ | ------- |\n |allowUnicodeIdentifiers|boolean, toggles whether unicode identifiers are allowed in names or not, default is false| |false|\n+|discriminatorExplicitMappingVerbose|Every model that has a discriminator explicitly defines the disciminator in itself, the mapping in that discriminator includes any descendent schemas that allOf inherit from self, any oneOf schemas, any anyOf schemas, any x-discriminator-values, and the spec's defined discriminator mapping schemas. When true, we validate that oneOf and anyOf schemas contain the required discriminator and we throw an error if it's missing. When true model templates should not loop over {{#children}} when defining the discriminator mapping| |false|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxMjQwOA==", "bodyText": "Proposed rephrasing of the flag documentation. I made some statements which may not be accurate, but hopefully with a bit of back-and-forth we can improve the doc.\n=== BEGIN\nThis flag is used by OpenAPITools codegen to influence the processing of the discriminator attribute in OpenAPI documents. This flag has no impact if the OAS document does not use the discriminator attribute. The default value of this flag is set in each language-specific code generator (e.g. Python, Java, go...).\nWhen this flag is set to true:\n\nThe mapping in the discriminator includes any descendent schemas that allOf inherit from self, any oneOf schemas, any anyOf schemas, any x-discriminator-values, and the discriminator mapping schemas in the OAS document.\nCodegen validates that oneOf and anyOf schemas contain the required discriminator and throws an error if the discriminator is missing.\n\nWhen this flag is set to false:\n\nThe mapping in the discriminator includes descendent schemas that allOf inherit from self and the discriminator mapping schemas in the OAS document.\n\nNote to developers supporting a language generator in OpenAPITools: to fully support the discriminator attribute as defined in the OAS specification 3.x, language generators should set this flag to true by default; however this requires updating the mustache templates to generate a language-specific discriminator lookup function that iterates over the XXXX tag.\n=== END\nDo you agree that eventually, all language generators that aim to fully support OAS 3.x should set this flag by default? Or do you see a reason they should not? If, maybe we should rename discriminatorExplicitMappingVerbose to discriminatorFullOpenAPISupport or something that indicates it should be the default value? For example, the default value could be \"legacy\", and for python-experimental and go-experimental the value is something like \"enabled\", just to nudge developers to support the new value.\n\nWhen true model templates should not loop over {{#children}} when defining the discriminator mapping\n\nIt would be good to explain what the mustache templates should loop over, if not {{#children}}; Both for when the flag is set to true and when the flag is set to false. BTW, yesterday I was thinking about opening a PR to document the CodegenModel.children field, because it's not very obvious what is the meaning. It could be containment, it could be class inheritance.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401712408", "createdAt": "2020-04-01T15:38:42Z", "author": {"login": "sebastien-rosset"}, "path": "docs/generators/ada-server.md", "diffHunk": "@@ -6,6 +6,7 @@ sidebar_label: ada-server\n | Option | Description | Values | Default |\n | ------ | ----------- | ------ | ------- |\n |allowUnicodeIdentifiers|boolean, toggles whether unicode identifiers are allowed in names or not, default is false| |false|\n+|discriminatorExplicitMappingVerbose|Every model that has a discriminator explicitly defines the disciminator in itself, the mapping in that discriminator includes any descendent schemas that allOf inherit from self, any oneOf schemas, any anyOf schemas, any x-discriminator-values, and the spec's defined discriminator mapping schemas. When true, we validate that oneOf and anyOf schemas contain the required discriminator and we throw an error if it's missing. When true model templates should not loop over {{#children}} when defining the discriminator mapping| |false|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg==", "bodyText": "I have a OAS document where this code is invoked and getMappingName() return null. This happens because this.mappingName is null. Should we test for getMappingName() being null and returning a RuntimeException with a message that helps troubleshoot (including the value of this.modelName)? Or should compareTo return != 0 when mappingName is null?\nAlso, is it done on purpose that the implementation of compareTo is different from the equals implementation logic?\nOr should the null value be caught earlier, such as when the MappedModel constructor is invoked?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401827052", "createdAt": "2020-04-01T18:36:35Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1NjM1MA==", "bodyText": "Update: I found one reason why the value is null. I can submit a PR. Do you want me to submit a PR to your branch?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401856350", "createdAt": "2020-04-01T19:27:48Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MDUyMA==", "bodyText": "The \"setMappingName\" function is not used anywhere. Does it make sense to remove it? I find it complicates troubleshooting and code maintenance when unused methods are added. This is because the code maintainer has to consider multiple ways the data can change.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401860520", "createdAt": "2020-04-01T19:35:21Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MTAyOA==", "bodyText": "It would be helpful to add documentation.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401861028", "createdAt": "2020-04-01T19:36:22Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -1111,6 +1120,14 @@ public void setEnsureUniqueParams(Boolean ensureUniqueParams) {\n         this.ensureUniqueParams = ensureUniqueParams;\n     }\n \n+    public Boolean getDiscriminatorExplicitMappingVerbose() {\n+        return discriminatorExplicitMappingVerbose;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2OTM3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            String xDiscriminatorValue = (String) vendorExtensions.get(\"x-discriminator-value\");\n          \n          \n            \n                           if (xDiscriminatorValue != null) {\n          \n          \n            \n                               mm = new MappedModel(xDiscriminatorValue, toModelName(currentSchemaName));\n          \n          \n            \n                               descendentSchemas.add(mm);\n          \n          \n            \n                           }", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401869375", "createdAt": "2020-04-01T19:51:11Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2338,36 +2381,314 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n-    protected CodegenDiscriminator createDiscriminator(String schemaName, Schema schema) {\n-        if (schema.getDiscriminator() == null) {\n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * and return a CodegenProperty with the dataType and required params set\n+     * the returned CodegenProperty may not be required and it may not be of type string\n+     * @param composedSchemaName The name of the sc Schema\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private CodegenProperty discriminatorFound(String composedSchemaName, Schema sc, String discPropName, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        if (refSchema.getProperties() != null && refSchema.getProperties().get(discPropName) != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            CodegenProperty cp = new CodegenProperty();\n+            cp.setDatatype(discSchema.getType());\n+            cp.setRequired(false);\n+            if (refSchema.getRequired() != null && refSchema.getRequired().contains(discPropName)) {\n+                cp.setRequired(true);\n+            }\n+            return cp;\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    CodegenProperty cp = discriminatorFound(composedSchemaName, allOf, discPropName, openAPI);\n+                    if (cp != null) {\n+                        return cp;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(oneOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, oneOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced OneOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the OneOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior OneOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(anyOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, anyOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced AnyOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the AnyOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior AnyOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Recursively look in Schema sc for the discriminator and return it\n+     * Schema sc location\n+     * OpenAPI openAPI the spec where we are searching for the discriminator\n+     * @param sc The Schema that may contain the discriminator\n+     */\n+    private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        Discriminator foundDisc = refSchema.getDiscriminator();\n+        if (foundDisc != null) {\n+            return foundDisc;\n+        }\n+        if (!this.getDiscriminatorExplicitMappingVerbose()) {\n+            return null;\n+        }\n+        Discriminator disc = new Discriminator();\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    foundDisc = recursiveGetDiscriminator(allOf, openAPI);\n+                    if (foundDisc != null) {\n+                        disc.setPropertyName(foundDisc.getPropertyName());\n+                        disc.setMapping(foundDisc.getMapping());\n+                        return disc;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    foundDisc = recursiveGetDiscriminator(oneOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    foundDisc = recursiveGetDiscriminator(anyOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * a list if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param openAPI The OpenAPI spec that we are using\n+     * @return the list of oneOf and anyOf MappedModel that need to be added to the discriminator map\n+     */\n+    protected List<MappedModel> getOneOfAnyOfDescendants(String composedSchemaName, String discPropName, ComposedSchema c, OpenAPI openAPI) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        List<MappedModel> descendentSchemas = new ArrayList();\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    // Note: if it is only inline one level, then the inline model resolver will move it into its own\n+                    // schema and make it a $ref schema in the oneOf/anyOf location\n+                    throw new RuntimeException(\"Invalid inline schema defined in oneOf/anyOf in '\" + composedSchemaName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the oneOf/anyOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                }\n+                CodegenProperty df = discriminatorFound(composedSchemaName, sc, discPropName, openAPI);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (df == null || !\"string\".equals(df.dataType) || df.required != true) {\n+                    String msgSuffix = \"\";\n+                    if (df == null) {\n+                        msgSuffix += discPropName+\" is missing from the schema, define it as required and type string\";\n+                    } else {\n+                        if (!\"string\".equals(df.dataType)) {\n+                            msgSuffix += \"invalid type for \"+discPropName+\", set it to string\";\n+                        }\n+                        if (df.required != true) {\n+                            String spacer = \"\";\n+                            if (msgSuffix.length() != 0) {\n+                                spacer = \". \";\n+                            }\n+                            msgSuffix += spacer+\"invalid optional definition of \"+discPropName+\", include it in required\";\n+                        }\n+                    }\n+                    throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced schema '\" + modelName + \"' is incorrect. \"+msgSuffix);\n+                }\n+                MappedModel mm = new MappedModel(modelName, toModelName(modelName));\n+                descendentSchemas.add(mm);\n+                Schema cs = ModelUtils.getSchema(openAPI, modelName);\n+                Map<String, Object> vendorExtensions = cs.getExtensions();\n+                if (vendorExtensions != null && !vendorExtensions.isEmpty()) {\n+                    String xDiscriminatorValue = (String) vendorExtensions.get(\"x-discriminator-value\");\n+                    mm = new MappedModel(xDiscriminatorValue, toModelName(modelName));\n+                    descendentSchemas.add(mm);\n+                }\n+\n+            }\n+        }\n+        return descendentSchemas;\n+    }\n+\n+    protected List<MappedModel> getAllOfDescendants(String thisSchemaName, OpenAPI openAPI) {\n+        ArrayList<String> queue = new ArrayList();;\n+        List<MappedModel> descendentSchemas = new ArrayList();\n+        Map<String, Schema> schemas = ModelUtils.getSchemas(openAPI);\n+        String currentSchemaName = thisSchemaName;\n+        while (true) {\n+            for (String childName : schemas.keySet()) {\n+                if (childName == thisSchemaName) {\n+                    continue;\n+                }\n+                Schema child = schemas.get(childName);\n+                if (ModelUtils.isComposedSchema(child)) {\n+                    ComposedSchema composedChild = (ComposedSchema) child;\n+                    List<Schema> parents = composedChild.getAllOf();\n+                    if (parents != null) {\n+                        for  (Schema parent: parents) {\n+                            String ref = parent.get$ref();\n+                            if (ref == null) {\n+                                // for schemas with no ref, it is not possible to build the discriminator map\n+                                // because ref is how we get the model name\n+                                // we only hit this use case for a schema with inline composed schemas, and one of those\n+                                // schemas also has inline composed schemas\n+                                throw new RuntimeException(\"Invalid inline schema defined in allOf in '\" + childName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the allOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                            }\n+                            String parentName = ModelUtils.getSimpleRef(ref);\n+                            if (parentName.equals(currentSchemaName)) {\n+                                if (queue.contains(childName) || descendentSchemas.contains(childName)) {\n+                                    throw new RuntimeException(\"Stack overflow hit when looking for \"+thisSchemaName+\" an infinite loop starting and ending at \"+childName+\" was seen\");\n+                                }\n+                                queue.add(childName);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            if (queue.size() == 0) {\n+                break;\n+            }\n+            currentSchemaName = queue.remove(0);\n+            MappedModel mm = new MappedModel(currentSchemaName, toModelName(currentSchemaName));\n+            descendentSchemas.add(mm);\n+            Schema cs = schemas.get(currentSchemaName);\n+            Map<String, Object> vendorExtensions = cs.getExtensions();\n+            if (vendorExtensions != null && !vendorExtensions.isEmpty()) {\n+                String xDiscriminatorValue = (String) vendorExtensions.get(\"x-discriminator-value\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcd45406ec048643f6e1b90de843ec5ecbde9895"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MjkzMw==", "bodyText": "It would be useful to document how the mappedModels field is populated.\nOne way to think about it when reading the code is \"oh this must be the explicit discriminator mappings as written in the OpenAPI document\", without any transformation.\nBut since codegen typically transforms the data, mappedModels could include mappings that have been resolved by codegen through a recursive discovery process.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r402372933", "createdAt": "2020-04-02T14:48:14Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -7,7 +7,18 @@\n import java.util.Objects;\n import java.util.Set;\n \n+/**\n+ * This class encapsulates the OpenAPI discriminator construct, as specified at\n+ * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#discriminatorObject.\n+ *\n+ * When request bodies or response payloads may be one of a number of different schemas,\n+ * a discriminator object can be used to aid in serialization, deserialization, and validation.\n+ * The discriminator is a specific object in a schema which is used to inform the consumer of\n+ * the specification of an alternative schema based on the value associated with it.\n+ */\n public class CodegenDiscriminator {\n+    // The name of the property in the payload that will hold the discriminator value.\n+    // This is the propertyName as specified in the OpenAPI discriminator object.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ff63c1e606b563dbe559b2bc191de62659a7ff"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MjYzOTM3", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#pullrequestreview-389263937", "createdAt": "2020-04-07T16:00:51Z", "commit": {"oid": "c7f1bce202ff72ab096548cc20094cdeda9afae8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNjowMDo1MVrOGCKuHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNjowMDo1MVrOGCKuHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyNTk4MQ==", "bodyText": "Not all languages use \"string\". What about using df.isString to check if it's a string instead?\nSame for line 2568.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r404925981", "createdAt": "2020-04-07T16:00:51Z", "author": {"login": "wing328"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2341,36 +2384,314 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n-    protected CodegenDiscriminator createDiscriminator(String schemaName, Schema schema) {\n-        if (schema.getDiscriminator() == null) {\n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * and return a CodegenProperty with the dataType and required params set\n+     * the returned CodegenProperty may not be required and it may not be of type string\n+     * @param composedSchemaName The name of the sc Schema\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private CodegenProperty discriminatorFound(String composedSchemaName, Schema sc, String discPropName, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        if (refSchema.getProperties() != null && refSchema.getProperties().get(discPropName) != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            CodegenProperty cp = new CodegenProperty();\n+            cp.setDatatype(discSchema.getType());\n+            cp.setRequired(false);\n+            if (refSchema.getRequired() != null && refSchema.getRequired().contains(discPropName)) {\n+                cp.setRequired(true);\n+            }\n+            return cp;\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    CodegenProperty cp = discriminatorFound(composedSchemaName, allOf, discPropName, openAPI);\n+                    if (cp != null) {\n+                        return cp;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(oneOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, oneOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced OneOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the OneOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior OneOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(anyOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, anyOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced AnyOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the AnyOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior AnyOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Recursively look in Schema sc for the discriminator and return it\n+     * Schema sc location\n+     * OpenAPI openAPI the spec where we are searching for the discriminator\n+     * @param sc The Schema that may contain the discriminator\n+     */\n+    private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        Discriminator foundDisc = refSchema.getDiscriminator();\n+        if (foundDisc != null) {\n+            return foundDisc;\n+        }\n+        if (!this.getDiscriminatorExplicitMappingVerbose()) {\n+            return null;\n+        }\n+        Discriminator disc = new Discriminator();\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    foundDisc = recursiveGetDiscriminator(allOf, openAPI);\n+                    if (foundDisc != null) {\n+                        disc.setPropertyName(foundDisc.getPropertyName());\n+                        disc.setMapping(foundDisc.getMapping());\n+                        return disc;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    foundDisc = recursiveGetDiscriminator(oneOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    foundDisc = recursiveGetDiscriminator(anyOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * a list if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param openAPI The OpenAPI spec that we are using\n+     * @return the list of oneOf and anyOf MappedModel that need to be added to the discriminator map\n+     */\n+    protected List<MappedModel> getOneOfAnyOfDescendants(String composedSchemaName, String discPropName, ComposedSchema c, OpenAPI openAPI) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        List<MappedModel> descendentSchemas = new ArrayList();\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    // Note: if it is only inline one level, then the inline model resolver will move it into its own\n+                    // schema and make it a $ref schema in the oneOf/anyOf location\n+                    throw new RuntimeException(\"Invalid inline schema defined in oneOf/anyOf in '\" + composedSchemaName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the oneOf/anyOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                }\n+                CodegenProperty df = discriminatorFound(composedSchemaName, sc, discPropName, openAPI);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (df == null || !\"string\".equals(df.dataType) || df.required != true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7f1bce202ff72ab096548cc20094cdeda9afae8"}, "originalPosition": 321}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTIzNDQ3", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#pullrequestreview-395923447", "createdAt": "2020-04-18T15:27:03Z", "commit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNToyNzowM1rOGHr3yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTo0NzowOFrOGHsA-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjAxMQ==", "bodyText": "This option needs clarification since it's currently doing a lot.\n\nCan we remove the \"verbose\" since that's not really relevant to the user?\nThe term mapping would indicate to users who are familiar with our options that this would take a string in the format key=value, which is not the case.\nThe option is triggering OpenAPI 3.x logic, but doesn't indicate that clearly here.\n\nMight I recommend changing this to something more like:\n@Option(name = {\"--legacy-discriminators\"}, title = \"Support legacy logic for evaluating discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)\nprivate Boolean legacyDiscriminators;\n\nThis value would need to default to true until the new logic becomes default (I don't recall if it's now default or not).\nThe value would then have to be applied to CodegenConfigurator, which is not done in Generate.java here. The same default would have to be done in the Maven and Gradle plugins, with a task to add the feature option to those. We also have a new SBT plugin (pending first release) where this would have to be added.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410712011", "createdAt": "2020-04-18T15:27:03Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator-cli/src/main/java/org/openapitools/codegen/cmd/Generate.java", "diffHunk": "@@ -240,6 +240,9 @@\n     @Option(name = {\"--generate-alias-as-model\"}, title = \"generate alias (array, map) as model\", description = CodegenConstants.GENERATE_ALIAS_AS_MODEL_DESC)\n     private Boolean generateAliasAsModel;\n \n+    @Option(name = {\"--discriminator-explicit-mapping-verbose\"}, title = \"explicitly define a discriminator on all models which have one, add verbose mapping to that discriminator, validate discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjM0MA==", "bodyText": "This is a confusing use of configuration. It's created in Generate.java as a CLI option, but then pulled from additionalProperties here. We should stick to one or the other (not both).\nI think it makes sense to add it to WorkflowSettings because we're defining the workflow for geneation.\nLet me know if you'd like help and I can contribute that directly to your branch.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410712340", "createdAt": "2020-04-18T15:29:27Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -306,6 +309,11 @@ public void processOpts() {\n             this.setRemoveEnumValuePrefix(Boolean.valueOf(additionalProperties\n                     .get(CodegenConstants.REMOVE_ENUM_VALUE_PREFIX).toString()));\n         }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzU1NQ==", "bodyText": "This option needs better definition. If it's a CLI option (in Generate.java), it should be hooked up to CodegenConfigurator and applied as a way to configure this generation.\nCliOptions is a place to define generator-specific (*Codegen types) logic, and not \"global\" workflows.\nFor instance, the option in Generate.java will show via cli help generate while the option here would show via cli config-help -g generator_name. The latter is intended only for those configurations which don't apply to all generators.\nA good rule for these:  only define things in CliOptions if they are template customizable, put others via CodegenConfigurator and extend via additionalProperties.  I open to clarify and clean this all up by 5.0.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410713555", "createdAt": "2020-04-18T15:39:27Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -1423,6 +1440,9 @@ public DefaultCodegen() {\n         // option to change the order of form/body parameter\n         cliOptions.add(CliOption.newBoolean(CodegenConstants.PREPEND_FORM_OR_BODY_PARAMETERS,\n                 CodegenConstants.PREPEND_FORM_OR_BODY_PARAMETERS_DESC).defaultValue(Boolean.FALSE.toString()));\n+        cliOptions.add(CliOption.newBoolean(CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzgxMw==", "bodyText": "This should not be protected. If you're doing this for testing, please remove the modifier and treat this as package-private. By adding protected, you're telling users that we expect them to customize this and modify the method. That would be a maintenance nightmare for us if we don't even know how the tool's properties are applied.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410713813", "createdAt": "2020-04-18T15:42:08Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "diffHunk": "@@ -156,7 +156,7 @@ private Boolean getGeneratorPropertyDefaultSwitch(final String key, final Boolea\n         return defaultValue;\n     }\n \n-    private void configureGeneratorProperties() {\n+    protected void configureGeneratorProperties() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzgyNQ==", "bodyText": "Same. This should not be protected. If you're doing this for testing, please remove the modifier and treat this as package-private.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410713825", "createdAt": "2020-04-18T15:42:21Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "diffHunk": "@@ -394,7 +394,7 @@ private void generateModel(List<File> files, Map<String, Object> models, String\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private void generateModels(List<File> files, List<Object> allModels, List<String> unusedModels) {\n+    protected void generateModels(List<File> files, List<Object> allModels, List<String> unusedModels) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxNDM0MQ==", "bodyText": "This isn't an appropriate place for this option. If someone were to extend this generator and modify the value (maybe they don't support this explicitly mapping in their templates), you're potentially overwriting their value.\nPlease move this to the constructor here and elsewhere. This would also allow our tooling to understand the defaults for the generator. Putting a default here, it's not known until execution time (via a \"real\" generate). See hideGenerationTimestamp in this constructor.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410714341", "createdAt": "2020-04-18T15:46:44Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/GoClientExperimentalCodegen.java", "diffHunk": "@@ -77,6 +77,7 @@ public String getHelp() {\n \n     @Override\n     public void processOpts() {\n+        this.setDiscriminatorExplicitMappingVerbose(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxNDM2Mw==", "bodyText": "Please move default option to constructor.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410714363", "createdAt": "2020-04-18T15:47:08Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/PythonClientExperimentalCodegen.java", "diffHunk": "@@ -111,6 +111,8 @@ public PythonClientExperimentalCodegen() {\n \n     @Override\n     public void processOpts() {\n+        this.setDiscriminatorExplicitMappingVerbose(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29bc8e65542eaad84f277957c14028a7fe44de84"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7a5ccaaeb971ddce9badd8c497c1becda9aa93f", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/a7a5ccaaeb971ddce9badd8c497c1becda9aa93f", "committedDate": "2020-04-23T04:48:58Z", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb6c4bd20deb5c7bf7bc53647ff070a224dbc835", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/cb6c4bd20deb5c7bf7bc53647ff070a224dbc835", "committedDate": "2020-04-23T04:48:59Z", "message": "Requires that discriminators be required properties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53ba1fa0e6a259406cfbfb91dea7b672f7b9bfb3", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/53ba1fa0e6a259406cfbfb91dea7b672f7b9bfb3", "committedDate": "2020-04-23T04:48:59Z", "message": "Strengthens discriminaotr validation, adds better error messages, adds schema oneof samples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23c5c3882486eacbf51b8a0db71ec8b9391dd015", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/23c5c3882486eacbf51b8a0db71ec8b9391dd015", "committedDate": "2020-04-23T04:48:59Z", "message": "Adds oneOf and anyOf invalidDiscriminator tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3b6522282c59d036f1b83fdc9e59e89cd1a5187", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/e3b6522282c59d036f1b83fdc9e59e89cd1a5187", "committedDate": "2020-04-23T04:49:00Z", "message": "Updates incorrect addOneOfInterfaceModel invocation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b85b2d55d5233bed6cb19364dfe8356dee7787f", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/7b85b2d55d5233bed6cb19364dfe8356dee7787f", "committedDate": "2020-04-23T04:49:00Z", "message": "Runs ensure-up-to-date"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53ab46b6f11a11c39b6dbac7f87ffeb6ef333f93", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/53ab46b6f11a11c39b6dbac7f87ffeb6ef333f93", "committedDate": "2020-04-23T04:49:00Z", "message": "Adds updates from Sebastien Rosset"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7242b940046082a5de6736417c02dc00677b5d2a", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/7242b940046082a5de6736417c02dc00677b5d2a", "committedDate": "2020-04-23T04:49:00Z", "message": "Removes newlines"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddefbea34453b47de69a474b2d87670f06792baf", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/ddefbea34453b47de69a474b2d87670f06792baf", "committedDate": "2020-04-23T04:49:01Z", "message": "Uses df.isString"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "831c99a892a785adb148b6c2192b13e74759faf6", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/831c99a892a785adb148b6c2192b13e74759faf6", "committedDate": "2020-04-23T04:49:01Z", "message": "Fixes tests be correctly setting df.isString"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ab57c86f9a888a6921846f8efbaf818ee4afb40", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/6ab57c86f9a888a6921846f8efbaf818ee4afb40", "committedDate": "2020-04-23T04:53:35Z", "message": "Updates discriminatorExplicitMappingVerbose description per PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "607f638301fec5019b64e38d2e2faab46cdf75e6", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/607f638301fec5019b64e38d2e2faab46cdf75e6", "committedDate": "2020-04-23T04:53:35Z", "message": "Adds description of how mappedModels is populated"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc23d3e2b4a78c68b6a54a80b584cb79235663ba", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/bc23d3e2b4a78c68b6a54a80b584cb79235663ba", "committedDate": "2020-04-23T04:53:35Z", "message": "Adds the suggestion exception raising when a MappedModel mappingName is null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "052bccc86b7ff84f7c7b255befae6938fcbb1b77", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/052bccc86b7ff84f7c7b255befae6938fcbb1b77", "committedDate": "2020-04-23T04:57:58Z", "message": "Actually resolves merge conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89c8025dc75af769225802840209ead5a7277a5d", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/89c8025dc75af769225802840209ead5a7277a5d", "committedDate": "2020-04-23T04:57:59Z", "message": "Switches two methods to package private because they are needed for testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "936c0b1a3b4fa675791190a3dcab594e3e1c6ad6", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/936c0b1a3b4fa675791190a3dcab594e3e1c6ad6", "committedDate": "2020-04-23T04:57:59Z", "message": "Allow nulls in MappedModel.getMappingName"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f001fa6033078212f46091ff8c276d3d957b8754", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/f001fa6033078212f46091ff8c276d3d957b8754", "committedDate": "2020-04-23T04:32:42Z", "message": "Allow nulls in MappedModel.getMappingName"}, "afterCommit": {"oid": "936c0b1a3b4fa675791190a3dcab594e3e1c6ad6", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/936c0b1a3b4fa675791190a3dcab594e3e1c6ad6", "committedDate": "2020-04-23T04:57:59Z", "message": "Allow nulls in MappedModel.getMappingName"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b2563f0a56368748f08add1d281b830d1026982", "author": {"user": {"login": "spacether", "name": "Justin Black"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/5b2563f0a56368748f08add1d281b830d1026982", "committedDate": "2020-04-23T06:27:35Z", "message": "Updates CLI flag name to legacyDiscriminatorBehavior, default=true"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8c95d8865e0a4a7a2e3dc1b20a3c909f0205ca6", "author": {"user": {"login": "wing328", "name": "William Cheng"}}, "url": "https://github.com/OpenAPITools/openapi-generator/commit/f8c95d8865e0a4a7a2e3dc1b20a3c909f0205ca6", "committedDate": "2020-04-24T09:57:58Z", "message": "Merge branch 'master' into issue_4904_fix_composed_schema_discriminator_map"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2033, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}