{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwMDQ5NTQ5", "number": 5192, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQyMDo0OTowN1rODcfNbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQyMDo0OTowN1rODcfNbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMTk4MDYxOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/OnceLogger.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQyMDo0OTowN1rOFkjdAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxODo1MTo1N1rOFk8DVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg3MzkyMg==", "bodyText": "maybe a single operation if you want to avoid races?\nmessageCountCache.asMap().merge(msg, 1, count -> count + 1)\nor an atomic counter if you want to avoid locking except on the initial mapping?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5192#discussion_r373873922", "createdAt": "2020-02-02T20:49:07Z", "author": {"login": "ben-manes"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/OnceLogger.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package org.openapitools.codegen.utils;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import org.openapitools.codegen.config.GlobalSettings;\n+import org.slf4j.Logger;\n+import org.slf4j.Marker;\n+import org.slf4j.MarkerFactory;\n+import org.slf4j.ext.LoggerWrapper;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Provides calling code a way to log important messages only once, regardless of how many times the invocation has occurred.\n+ * This can be used, for instance, to log a warning like \"One or more schemas aren't declared\" without logging that message\n+ * for every time the schema is mentioned in a document.\n+ *\n+ * This implementation currently only supports single-argument string literal log methods (e.g. {@link Logger#debug(String)}).\n+ */\n+@SuppressWarnings(\"FieldCanBeLocal\")\n+public class OnceLogger extends LoggerWrapper {\n+    /**\n+     * Allow advanced users to modify cache size of the OnceLogger (more for performance tuning in hosted environments)\n+     */\n+    private static final String CACHE_SIZE_PROPERTY = \"org.openapitools.codegen.utils.oncelogger.cachesize\";\n+\n+    /**\n+     * Allow advanced users to disable the OnceLogger (more for performance tuning in hosted environments).\n+     * This is really only useful or necessary if this implementation causes issues.\n+     */\n+    private static final String ENABLE_ONCE_LOGGER_PROPERTY = \"org.openapitools.codegen.utils.oncelogger.enabled\";\n+\n+    /**\n+     * Allow advanced users to modify cache expiration of the OnceLogger (more for performance tuning in hosted environments)\n+     */\n+    private static final String EXPIRY_PROPERTY = \"org.openapitools.codegen.utils.oncelogger.expiry\";\n+\n+    /**\n+     * The fully qualified class name of the <b>logger instance</b>,\n+     * typically the logger class, logger bridge or a logger wrapper.\n+     */\n+    private static final String FQCN = OnceLogger.class.getName();\n+\n+    /**\n+     * Gets the marker instance. This can be used by supported log implementations to filter/manage logs coming from\n+     * this implementation differently than others (i.e. make them stand out since they're to be logged once).\n+     */\n+    private static final Marker MARKER = MarkerFactory.getMarker(\"ONCE\");\n+\n+    /**\n+     * The allowed size of the cache.\n+     */\n+    private static int maxCacheSize = Integer.parseInt(GlobalSettings.getProperty(CACHE_SIZE_PROPERTY, \"200\"));\n+\n+    /**\n+     * The millis to expire a cached log message.\n+     */\n+    private static int expireMillis = Integer.parseInt(GlobalSettings.getProperty(EXPIRY_PROPERTY, \"2000\"));\n+\n+    /**\n+     * The number of allowed repetitions.\n+     */\n+    private static int maxRepetitions = 1;\n+\n+    /**\n+     * Internal message cache for logger decorated with the onceler.\n+     */\n+    private static Cache<String, Integer> messageCountCache;\n+\n+    OnceLogger(Logger logger) {\n+        this(logger, FQCN);\n+    }\n+\n+    OnceLogger(Logger logger, String fqcn) {\n+        super(logger, fqcn);\n+    }\n+\n+    static {\n+        messageCountCache = Caffeine.newBuilder()\n+                .maximumSize(maxCacheSize)\n+                .expireAfterWrite(expireMillis, TimeUnit.MILLISECONDS)\n+                .build();\n+    }\n+\n+    public static Logger once(Logger logger) {\n+        try {\n+            if (Boolean.parseBoolean(GlobalSettings.getProperty(ENABLE_ONCE_LOGGER_PROPERTY, \"true\"))) {\n+                return new OnceLogger(logger);\n+            }\n+        } catch (Exception ex) {\n+            logger.warn(\"Unable to wrap logger instance in OnceLogger. Falling back to non-decorated implementation, which may be noisy.\");\n+        }\n+        return logger;\n+    }\n+\n+    /**\n+     * Delegate to the appropriate method of the underlying logger.\n+     *\n+     * @param msg\n+     */\n+    @Override\n+    public void trace(String msg) {\n+        if (!isTraceEnabled() || !isTraceEnabled(MARKER)) return;\n+\n+        if (shouldLog(msg)) super.trace(MARKER, msg);\n+    }\n+\n+    private boolean shouldLog(final String msg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7355379f16ba955f5db9444917994964105f1a1e"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkwNTczNg==", "bodyText": "Thanks for the quick and helpful review, Ben! I decided to go the AtomicInteger route because it's not critical functionality for this method and doesn't need repeated locking, I'm just trying to remove noise for users.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5192#discussion_r373905736", "createdAt": "2020-02-03T02:58:45Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/OnceLogger.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package org.openapitools.codegen.utils;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import org.openapitools.codegen.config.GlobalSettings;\n+import org.slf4j.Logger;\n+import org.slf4j.Marker;\n+import org.slf4j.MarkerFactory;\n+import org.slf4j.ext.LoggerWrapper;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Provides calling code a way to log important messages only once, regardless of how many times the invocation has occurred.\n+ * This can be used, for instance, to log a warning like \"One or more schemas aren't declared\" without logging that message\n+ * for every time the schema is mentioned in a document.\n+ *\n+ * This implementation currently only supports single-argument string literal log methods (e.g. {@link Logger#debug(String)}).\n+ */\n+@SuppressWarnings(\"FieldCanBeLocal\")\n+public class OnceLogger extends LoggerWrapper {\n+    /**\n+     * Allow advanced users to modify cache size of the OnceLogger (more for performance tuning in hosted environments)\n+     */\n+    private static final String CACHE_SIZE_PROPERTY = \"org.openapitools.codegen.utils.oncelogger.cachesize\";\n+\n+    /**\n+     * Allow advanced users to disable the OnceLogger (more for performance tuning in hosted environments).\n+     * This is really only useful or necessary if this implementation causes issues.\n+     */\n+    private static final String ENABLE_ONCE_LOGGER_PROPERTY = \"org.openapitools.codegen.utils.oncelogger.enabled\";\n+\n+    /**\n+     * Allow advanced users to modify cache expiration of the OnceLogger (more for performance tuning in hosted environments)\n+     */\n+    private static final String EXPIRY_PROPERTY = \"org.openapitools.codegen.utils.oncelogger.expiry\";\n+\n+    /**\n+     * The fully qualified class name of the <b>logger instance</b>,\n+     * typically the logger class, logger bridge or a logger wrapper.\n+     */\n+    private static final String FQCN = OnceLogger.class.getName();\n+\n+    /**\n+     * Gets the marker instance. This can be used by supported log implementations to filter/manage logs coming from\n+     * this implementation differently than others (i.e. make them stand out since they're to be logged once).\n+     */\n+    private static final Marker MARKER = MarkerFactory.getMarker(\"ONCE\");\n+\n+    /**\n+     * The allowed size of the cache.\n+     */\n+    private static int maxCacheSize = Integer.parseInt(GlobalSettings.getProperty(CACHE_SIZE_PROPERTY, \"200\"));\n+\n+    /**\n+     * The millis to expire a cached log message.\n+     */\n+    private static int expireMillis = Integer.parseInt(GlobalSettings.getProperty(EXPIRY_PROPERTY, \"2000\"));\n+\n+    /**\n+     * The number of allowed repetitions.\n+     */\n+    private static int maxRepetitions = 1;\n+\n+    /**\n+     * Internal message cache for logger decorated with the onceler.\n+     */\n+    private static Cache<String, Integer> messageCountCache;\n+\n+    OnceLogger(Logger logger) {\n+        this(logger, FQCN);\n+    }\n+\n+    OnceLogger(Logger logger, String fqcn) {\n+        super(logger, fqcn);\n+    }\n+\n+    static {\n+        messageCountCache = Caffeine.newBuilder()\n+                .maximumSize(maxCacheSize)\n+                .expireAfterWrite(expireMillis, TimeUnit.MILLISECONDS)\n+                .build();\n+    }\n+\n+    public static Logger once(Logger logger) {\n+        try {\n+            if (Boolean.parseBoolean(GlobalSettings.getProperty(ENABLE_ONCE_LOGGER_PROPERTY, \"true\"))) {\n+                return new OnceLogger(logger);\n+            }\n+        } catch (Exception ex) {\n+            logger.warn(\"Unable to wrap logger instance in OnceLogger. Falling back to non-decorated implementation, which may be noisy.\");\n+        }\n+        return logger;\n+    }\n+\n+    /**\n+     * Delegate to the appropriate method of the underlying logger.\n+     *\n+     * @param msg\n+     */\n+    @Override\n+    public void trace(String msg) {\n+        if (!isTraceEnabled() || !isTraceEnabled(MARKER)) return;\n+\n+        if (shouldLog(msg)) super.trace(MARKER, msg);\n+    }\n+\n+    private boolean shouldLog(final String msg) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg3MzkyMg=="}, "originalCommit": {"oid": "7355379f16ba955f5db9444917994964105f1a1e"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNTQ1MQ==", "bodyText": "I think that's best choice, too!\nHowever, it no longer writes into the map on every shouldLog call, causing the expireAfterWrite to evict based on the entry's creation time (as no updates). The old behavior was to reset the expiration each time the method was called, so it requires no occurrences for the expiration duration in order to evict. That could be done now using expireAfterAccess to reset on every read or write, which is fine as this is the sole usage.\nI suspect you don't want to suppress an ongoing error for good once the threshold is reached, as that makes it appear to be over, and simply want to debounce over a time interval. This new expiration behavior might be more correct, but I'm unsure. You probably want to think a bit about exactly what expiration behavior you want and maybe write a quick test to verify that.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5192#discussion_r373915451", "createdAt": "2020-02-03T04:09:42Z", "author": {"login": "ben-manes"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/OnceLogger.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package org.openapitools.codegen.utils;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import org.openapitools.codegen.config.GlobalSettings;\n+import org.slf4j.Logger;\n+import org.slf4j.Marker;\n+import org.slf4j.MarkerFactory;\n+import org.slf4j.ext.LoggerWrapper;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Provides calling code a way to log important messages only once, regardless of how many times the invocation has occurred.\n+ * This can be used, for instance, to log a warning like \"One or more schemas aren't declared\" without logging that message\n+ * for every time the schema is mentioned in a document.\n+ *\n+ * This implementation currently only supports single-argument string literal log methods (e.g. {@link Logger#debug(String)}).\n+ */\n+@SuppressWarnings(\"FieldCanBeLocal\")\n+public class OnceLogger extends LoggerWrapper {\n+    /**\n+     * Allow advanced users to modify cache size of the OnceLogger (more for performance tuning in hosted environments)\n+     */\n+    private static final String CACHE_SIZE_PROPERTY = \"org.openapitools.codegen.utils.oncelogger.cachesize\";\n+\n+    /**\n+     * Allow advanced users to disable the OnceLogger (more for performance tuning in hosted environments).\n+     * This is really only useful or necessary if this implementation causes issues.\n+     */\n+    private static final String ENABLE_ONCE_LOGGER_PROPERTY = \"org.openapitools.codegen.utils.oncelogger.enabled\";\n+\n+    /**\n+     * Allow advanced users to modify cache expiration of the OnceLogger (more for performance tuning in hosted environments)\n+     */\n+    private static final String EXPIRY_PROPERTY = \"org.openapitools.codegen.utils.oncelogger.expiry\";\n+\n+    /**\n+     * The fully qualified class name of the <b>logger instance</b>,\n+     * typically the logger class, logger bridge or a logger wrapper.\n+     */\n+    private static final String FQCN = OnceLogger.class.getName();\n+\n+    /**\n+     * Gets the marker instance. This can be used by supported log implementations to filter/manage logs coming from\n+     * this implementation differently than others (i.e. make them stand out since they're to be logged once).\n+     */\n+    private static final Marker MARKER = MarkerFactory.getMarker(\"ONCE\");\n+\n+    /**\n+     * The allowed size of the cache.\n+     */\n+    private static int maxCacheSize = Integer.parseInt(GlobalSettings.getProperty(CACHE_SIZE_PROPERTY, \"200\"));\n+\n+    /**\n+     * The millis to expire a cached log message.\n+     */\n+    private static int expireMillis = Integer.parseInt(GlobalSettings.getProperty(EXPIRY_PROPERTY, \"2000\"));\n+\n+    /**\n+     * The number of allowed repetitions.\n+     */\n+    private static int maxRepetitions = 1;\n+\n+    /**\n+     * Internal message cache for logger decorated with the onceler.\n+     */\n+    private static Cache<String, Integer> messageCountCache;\n+\n+    OnceLogger(Logger logger) {\n+        this(logger, FQCN);\n+    }\n+\n+    OnceLogger(Logger logger, String fqcn) {\n+        super(logger, fqcn);\n+    }\n+\n+    static {\n+        messageCountCache = Caffeine.newBuilder()\n+                .maximumSize(maxCacheSize)\n+                .expireAfterWrite(expireMillis, TimeUnit.MILLISECONDS)\n+                .build();\n+    }\n+\n+    public static Logger once(Logger logger) {\n+        try {\n+            if (Boolean.parseBoolean(GlobalSettings.getProperty(ENABLE_ONCE_LOGGER_PROPERTY, \"true\"))) {\n+                return new OnceLogger(logger);\n+            }\n+        } catch (Exception ex) {\n+            logger.warn(\"Unable to wrap logger instance in OnceLogger. Falling back to non-decorated implementation, which may be noisy.\");\n+        }\n+        return logger;\n+    }\n+\n+    /**\n+     * Delegate to the appropriate method of the underlying logger.\n+     *\n+     * @param msg\n+     */\n+    @Override\n+    public void trace(String msg) {\n+        if (!isTraceEnabled() || !isTraceEnabled(MARKER)) return;\n+\n+        if (shouldLog(msg)) super.trace(MARKER, msg);\n+    }\n+\n+    private boolean shouldLog(final String msg) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg3MzkyMg=="}, "originalCommit": {"oid": "7355379f16ba955f5db9444917994964105f1a1e"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI3Njk0OQ==", "bodyText": "You're correct that my intent was to debounce over a time internal. I think I mistakenly took expireAfterWrite to mean initial writes only, but looking at it after your comment I see that understanding wouldn't have made sense if I'd looked at the method a little more closely.\nI'll definitely need to add a comment about intention on the cache member, and write a handful of tests. I'll have to think about usage for errors and other levels a little more. The way I wrote this, it'll require that someone explicitly decorates a Logger instance and I may just throw an error if it's used to log error messages, or just skip the cache evaluation for that method.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5192#discussion_r374276949", "createdAt": "2020-02-03T18:51:57Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/OnceLogger.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package org.openapitools.codegen.utils;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import org.openapitools.codegen.config.GlobalSettings;\n+import org.slf4j.Logger;\n+import org.slf4j.Marker;\n+import org.slf4j.MarkerFactory;\n+import org.slf4j.ext.LoggerWrapper;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Provides calling code a way to log important messages only once, regardless of how many times the invocation has occurred.\n+ * This can be used, for instance, to log a warning like \"One or more schemas aren't declared\" without logging that message\n+ * for every time the schema is mentioned in a document.\n+ *\n+ * This implementation currently only supports single-argument string literal log methods (e.g. {@link Logger#debug(String)}).\n+ */\n+@SuppressWarnings(\"FieldCanBeLocal\")\n+public class OnceLogger extends LoggerWrapper {\n+    /**\n+     * Allow advanced users to modify cache size of the OnceLogger (more for performance tuning in hosted environments)\n+     */\n+    private static final String CACHE_SIZE_PROPERTY = \"org.openapitools.codegen.utils.oncelogger.cachesize\";\n+\n+    /**\n+     * Allow advanced users to disable the OnceLogger (more for performance tuning in hosted environments).\n+     * This is really only useful or necessary if this implementation causes issues.\n+     */\n+    private static final String ENABLE_ONCE_LOGGER_PROPERTY = \"org.openapitools.codegen.utils.oncelogger.enabled\";\n+\n+    /**\n+     * Allow advanced users to modify cache expiration of the OnceLogger (more for performance tuning in hosted environments)\n+     */\n+    private static final String EXPIRY_PROPERTY = \"org.openapitools.codegen.utils.oncelogger.expiry\";\n+\n+    /**\n+     * The fully qualified class name of the <b>logger instance</b>,\n+     * typically the logger class, logger bridge or a logger wrapper.\n+     */\n+    private static final String FQCN = OnceLogger.class.getName();\n+\n+    /**\n+     * Gets the marker instance. This can be used by supported log implementations to filter/manage logs coming from\n+     * this implementation differently than others (i.e. make them stand out since they're to be logged once).\n+     */\n+    private static final Marker MARKER = MarkerFactory.getMarker(\"ONCE\");\n+\n+    /**\n+     * The allowed size of the cache.\n+     */\n+    private static int maxCacheSize = Integer.parseInt(GlobalSettings.getProperty(CACHE_SIZE_PROPERTY, \"200\"));\n+\n+    /**\n+     * The millis to expire a cached log message.\n+     */\n+    private static int expireMillis = Integer.parseInt(GlobalSettings.getProperty(EXPIRY_PROPERTY, \"2000\"));\n+\n+    /**\n+     * The number of allowed repetitions.\n+     */\n+    private static int maxRepetitions = 1;\n+\n+    /**\n+     * Internal message cache for logger decorated with the onceler.\n+     */\n+    private static Cache<String, Integer> messageCountCache;\n+\n+    OnceLogger(Logger logger) {\n+        this(logger, FQCN);\n+    }\n+\n+    OnceLogger(Logger logger, String fqcn) {\n+        super(logger, fqcn);\n+    }\n+\n+    static {\n+        messageCountCache = Caffeine.newBuilder()\n+                .maximumSize(maxCacheSize)\n+                .expireAfterWrite(expireMillis, TimeUnit.MILLISECONDS)\n+                .build();\n+    }\n+\n+    public static Logger once(Logger logger) {\n+        try {\n+            if (Boolean.parseBoolean(GlobalSettings.getProperty(ENABLE_ONCE_LOGGER_PROPERTY, \"true\"))) {\n+                return new OnceLogger(logger);\n+            }\n+        } catch (Exception ex) {\n+            logger.warn(\"Unable to wrap logger instance in OnceLogger. Falling back to non-decorated implementation, which may be noisy.\");\n+        }\n+        return logger;\n+    }\n+\n+    /**\n+     * Delegate to the appropriate method of the underlying logger.\n+     *\n+     * @param msg\n+     */\n+    @Override\n+    public void trace(String msg) {\n+        if (!isTraceEnabled() || !isTraceEnabled(MARKER)) return;\n+\n+        if (shouldLog(msg)) super.trace(MARKER, msg);\n+    }\n+\n+    private boolean shouldLog(final String msg) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg3MzkyMg=="}, "originalCommit": {"oid": "7355379f16ba955f5db9444917994964105f1a1e"}, "originalPosition": 108}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3904, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}