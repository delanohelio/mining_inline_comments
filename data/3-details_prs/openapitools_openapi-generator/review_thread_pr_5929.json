{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMTcwNzQ4", "number": 5929, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMDowNToyMlrOD3jzEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMjoxOTo0NVrOECYdNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTg0Nzg2OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/resources/csharp-netcore/ApiClient.mustache", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMDowNToyMlrOGN4DWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMzo0ODo0MFrOGW3_uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwMzAzMw==", "bodyText": "The inability to customize the retry strategy is a concern, and I think a design that injects the retry strategy via IConfiguration would be better.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5929#discussion_r417203033", "createdAt": "2020-04-29T10:05:22Z", "author": {"login": "shibayan"}, "path": "modules/openapi-generator/src/main/resources/csharp-netcore/ApiClient.mustache", "diffHunk": "@@ -408,7 +410,26 @@ namespace {{packageName}}.Client\n \n             InterceptRequest(req);\n \n-            var response = client.Execute<T>(req);\n+            IRestResponse<T> response;\n+            if (configuration.RetryStatusCodes != null)\t\n+            {\n+                Random jitterer = new Random();\n+                var policy = Policy\n+                    .HandleResult<IRestResponse<T>>(resp => (configuration.RetryStatusCodes.Contains(resp.StatusCode)))\n+                    .WaitAndRetry(configuration.MaxRetries, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))\n+                                                          + TimeSpan.FromMilliseconds(jitterer.Next(0, 1000))\n+                     );\n+                var policyResult = policy.ExecuteAndCapture(() => client.Execute<T>(req));\n+                response = (policyResult.Outcome == OutcomeType.Successful) ? policyResult.Result : new RestResponse<T>\n+                {\n+                    Request = req,\n+                    ErrorException = policyResult.FinalException\n+                };\n+            }\n+            else\n+            {\n+                response = client.Execute<T>(req);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc271e706048c7bcac69f6a989fb7fafec2fc639"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc0NjE4MQ==", "bodyText": "@shibayan agree with you, thought of implementing that way itself, but the return type being a generic type IRestReponse< T > is what making it difficult to implement it via configuration.\nOr least i couldn't think of a solution to implement that in a easier way. Any inputs along that lines will be helpful.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5929#discussion_r417746181", "createdAt": "2020-04-30T04:27:13Z", "author": {"login": "Ramanth"}, "path": "modules/openapi-generator/src/main/resources/csharp-netcore/ApiClient.mustache", "diffHunk": "@@ -408,7 +410,26 @@ namespace {{packageName}}.Client\n \n             InterceptRequest(req);\n \n-            var response = client.Execute<T>(req);\n+            IRestResponse<T> response;\n+            if (configuration.RetryStatusCodes != null)\t\n+            {\n+                Random jitterer = new Random();\n+                var policy = Policy\n+                    .HandleResult<IRestResponse<T>>(resp => (configuration.RetryStatusCodes.Contains(resp.StatusCode)))\n+                    .WaitAndRetry(configuration.MaxRetries, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))\n+                                                          + TimeSpan.FromMilliseconds(jitterer.Next(0, 1000))\n+                     );\n+                var policyResult = policy.ExecuteAndCapture(() => client.Execute<T>(req));\n+                response = (policyResult.Outcome == OutcomeType.Successful) ? policyResult.Result : new RestResponse<T>\n+                {\n+                    Request = req,\n+                    ErrorException = policyResult.FinalException\n+                };\n+            }\n+            else\n+            {\n+                response = client.Execute<T>(req);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwMzAzMw=="}, "originalCommit": {"oid": "bc271e706048c7bcac69f6a989fb7fafec2fc639"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNTAzOQ==", "bodyText": "@shibayan  Figured out a way to have the retry policy through configuration. As a workaround found that the RestSharp's ExecAsync< T > can be seperated in two steps ExecAsync and then Deserialize< T > which makes ExecAsync free from having generic type and thus i can define the retry policy free from generic and so able to inject through configuration..\nPlease take a look at it once...", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5929#discussion_r424335039", "createdAt": "2020-05-13T10:27:58Z", "author": {"login": "Ramanth"}, "path": "modules/openapi-generator/src/main/resources/csharp-netcore/ApiClient.mustache", "diffHunk": "@@ -408,7 +410,26 @@ namespace {{packageName}}.Client\n \n             InterceptRequest(req);\n \n-            var response = client.Execute<T>(req);\n+            IRestResponse<T> response;\n+            if (configuration.RetryStatusCodes != null)\t\n+            {\n+                Random jitterer = new Random();\n+                var policy = Policy\n+                    .HandleResult<IRestResponse<T>>(resp => (configuration.RetryStatusCodes.Contains(resp.StatusCode)))\n+                    .WaitAndRetry(configuration.MaxRetries, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))\n+                                                          + TimeSpan.FromMilliseconds(jitterer.Next(0, 1000))\n+                     );\n+                var policyResult = policy.ExecuteAndCapture(() => client.Execute<T>(req));\n+                response = (policyResult.Outcome == OutcomeType.Successful) ? policyResult.Result : new RestResponse<T>\n+                {\n+                    Request = req,\n+                    ErrorException = policyResult.FinalException\n+                };\n+            }\n+            else\n+            {\n+                response = client.Execute<T>(req);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwMzAzMw=="}, "originalCommit": {"oid": "bc271e706048c7bcac69f6a989fb7fafec2fc639"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYzOTI5MQ==", "bodyText": "@shibayan can you take a look again when you get time.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5929#discussion_r426639291", "createdAt": "2020-05-18T13:48:40Z", "author": {"login": "Ramanth"}, "path": "modules/openapi-generator/src/main/resources/csharp-netcore/ApiClient.mustache", "diffHunk": "@@ -408,7 +410,26 @@ namespace {{packageName}}.Client\n \n             InterceptRequest(req);\n \n-            var response = client.Execute<T>(req);\n+            IRestResponse<T> response;\n+            if (configuration.RetryStatusCodes != null)\t\n+            {\n+                Random jitterer = new Random();\n+                var policy = Policy\n+                    .HandleResult<IRestResponse<T>>(resp => (configuration.RetryStatusCodes.Contains(resp.StatusCode)))\n+                    .WaitAndRetry(configuration.MaxRetries, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))\n+                                                          + TimeSpan.FromMilliseconds(jitterer.Next(0, 1000))\n+                     );\n+                var policyResult = policy.ExecuteAndCapture(() => client.Execute<T>(req));\n+                response = (policyResult.Outcome == OutcomeType.Successful) ? policyResult.Result : new RestResponse<T>\n+                {\n+                    Request = req,\n+                    ErrorException = policyResult.FinalException\n+                };\n+            }\n+            else\n+            {\n+                response = client.Execute<T>(req);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwMzAzMw=="}, "originalCommit": {"oid": "bc271e706048c7bcac69f6a989fb7fafec2fc639"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwOTMzMDk0OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/resources/csharp-netcore/Configuration.mustache", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMjoxODoxMFrOGezg_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMjoxODoxMFrOGezg_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NDQ5Mw==", "bodyText": "This configuration object is meant to be framework agnostic.\nBy adding RestSharp and Polly here, this breaks our contract of allowing users to build without RestSharp as a dependency and now adds Polly into the mix.\nIf the decision here is to tightly couple Polly with the RestSharp implementation of ApiClient, please modify only the ApiClient (preferably via constructor or thread-safe property injection).", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5929#discussion_r434954493", "createdAt": "2020-06-04T02:18:10Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/resources/csharp-netcore/Configuration.mustache", "diffHunk": "@@ -10,6 +10,10 @@ using System.IO;\n using System.Linq;\n using System.Security.Cryptography.X509Certificates;\n using System.Text;\n+using System.Net;\n+using Polly;\n+using Polly.Retry;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "943388665c2e53e49bf8032938ac9b3fafea66b0"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwOTMzMzAyOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/resources/csharp-netcore/IReadableConfiguration.mustache", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMjoxOTo0NVrOGeziVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMjoxOTo0NVrOGeziVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NDgzNw==", "bodyText": "We can't mix non-System types into this interface.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5929#discussion_r434954837", "createdAt": "2020-06-04T02:19:45Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/resources/csharp-netcore/IReadableConfiguration.mustache", "diffHunk": "@@ -2,7 +2,11 @@\n \n using System;\n using System.Collections.Generic;\n+using System.Net;\n using System.Security.Cryptography.X509Certificates;\n+using Polly;\n+using Polly.Retry;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "943388665c2e53e49bf8032938ac9b3fafea66b0"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3545, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}