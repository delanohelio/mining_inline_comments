{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3ODU3NDk5", "number": 5809, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNjozODo1N1rODutJJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwMDowMTowNlrOD7CdyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMzAwNzExOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNjozODo1N1rOGAzDFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNzowMDo1OVrOGAzMYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4OTU1OA==", "bodyText": "Where are we using this? I can't find a call site.\nIf we aren't using it, why include it?\nOur users can already iterate through discriminator MappedModels.\nIf we want to provide an easier way to do this, why not put it in the CodegenDiscriminator class instead?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r403489558", "createdAt": "2020-04-04T16:38:57Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenModel.java", "diffHunk": "@@ -203,6 +211,63 @@ public void setDiscriminator(CodegenDiscriminator discriminator) {\n         this.discriminator = discriminator;\n     }\n \n+    /**\n+     * Returns a list of allowed discriminator mapping values for this schema object.\n+     * \n+     * The list of all possible schema discriminator mapping values is obtained\n+     * from explicit discriminator mapping values in the OpenAPI document, and from\n+     * inherited discriminators through oneOf, allOf, anyOf.\n+     * For example, a discriminator may be defined in a 'Pet' schema as shown below.\n+     * The Dog and Cat schemas inherit the discriminator through the allOf reference.\n+     * In the 'Pet' schema, the supported discriminator mapping values for the\n+     * 'objectType' properties are 'Dog' and 'Cat'.\n+     * The allowed discriminator mapping value for the Dog schema is 'Dog'.\n+     * The allowed discriminator mapping value for the Cat schema is 'Dog'.\n+     * \n+     * Pet:\n+     *   type: object\n+     *   discriminator:\n+     *     propertyName: objectType\n+     *   required:\n+     *     - objectType\n+     *   properties:\n+     *     objectType:\n+     *     type: string\n+     * Dog:\n+     *   allOf:\n+     *   - $ref: '#/components/schemas/Pet'\n+     *   - type: object\n+     *     properties:\n+     *       p1:\n+     *         type: string\n+     * Cat:\n+     *   allOf:\n+     *   - $ref: '#/components/schemas/Pet'\n+     *   - type: object\n+     *     properties:\n+     *       p2:\n+     *         type: string\n+     * \n+     * @return the list of allowed discriminator mapping values.\n+     */\n+    public List<String> getAllowedDiscriminatorMappingValues() {\n+        List<String> mappingValues = new ArrayList<String>();\n+        for (CodegenDiscriminator.MappedModel mm : discriminator.getMappedModels()) {\n+            if (name.equals(mm.getModelName())) {\n+                mappingValues.add(mm.getMappingName());\n+            }\n+        }     \n+        return mappingValues;   \n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34c4c09ef49cea7519e3cf7c1e7af8619560d706"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ5MTkzNg==", "bodyText": "I am planning to remove it, after your PR has been merged. I accidentally cherry picked some commits I didn't want to merge", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r403491936", "createdAt": "2020-04-04T17:00:59Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenModel.java", "diffHunk": "@@ -203,6 +211,63 @@ public void setDiscriminator(CodegenDiscriminator discriminator) {\n         this.discriminator = discriminator;\n     }\n \n+    /**\n+     * Returns a list of allowed discriminator mapping values for this schema object.\n+     * \n+     * The list of all possible schema discriminator mapping values is obtained\n+     * from explicit discriminator mapping values in the OpenAPI document, and from\n+     * inherited discriminators through oneOf, allOf, anyOf.\n+     * For example, a discriminator may be defined in a 'Pet' schema as shown below.\n+     * The Dog and Cat schemas inherit the discriminator through the allOf reference.\n+     * In the 'Pet' schema, the supported discriminator mapping values for the\n+     * 'objectType' properties are 'Dog' and 'Cat'.\n+     * The allowed discriminator mapping value for the Dog schema is 'Dog'.\n+     * The allowed discriminator mapping value for the Cat schema is 'Dog'.\n+     * \n+     * Pet:\n+     *   type: object\n+     *   discriminator:\n+     *     propertyName: objectType\n+     *   required:\n+     *     - objectType\n+     *   properties:\n+     *     objectType:\n+     *     type: string\n+     * Dog:\n+     *   allOf:\n+     *   - $ref: '#/components/schemas/Pet'\n+     *   - type: object\n+     *     properties:\n+     *       p1:\n+     *         type: string\n+     * Cat:\n+     *   allOf:\n+     *   - $ref: '#/components/schemas/Pet'\n+     *   - type: object\n+     *     properties:\n+     *       p2:\n+     *         type: string\n+     * \n+     * @return the list of allowed discriminator mapping values.\n+     */\n+    public List<String> getAllowedDiscriminatorMappingValues() {\n+        List<String> mappingValues = new ArrayList<String>();\n+        for (CodegenDiscriminator.MappedModel mm : discriminator.getMappedModels()) {\n+            if (name.equals(mm.getModelName())) {\n+                mappingValues.add(mm.getMappingName());\n+            }\n+        }     \n+        return mappingValues;   \n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4OTU1OA=="}, "originalCommit": {"oid": "34c4c09ef49cea7519e3cf7c1e7af8619560d706"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MDQ1MzkxOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator-cli/src/main/java/org/openapitools/codegen/cmd/Generate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTowMjoyNVrOGHrrhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjo0Nzo1NFrOGLgXLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwODg3MQ==", "bodyText": "This option needs clarification since it's currently doing a lot.\n\nCan we remove the \"verbose\" since that's not really relevant to the user?\nThe term mapping would indicate to users who are familiar with our options that this would take a string in the format key=value, which is not the case.\nThe option is triggering OpenAPI 3.x logic, but doesn't indicate that clearly here.\n\nMight I recommend changing this to something more like:\n@Option(name = {\"--legacy-discriminators\"}, title = \"Support legacy logic for evaluating discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)\nprivate Boolean legacyDiscriminators;\n\nThis value would need to default to true until the new logic becomes default (I don't recall if it's now default or not).\nThe value would then have to be applied to CodegenConfigurator, which is not done in Generate.java here. The same default would have to be done in the Maven and Gradle plugins, with a task to add the feature option to those. We also have a new SBT plugin (pending first release) where this would have to be added.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r410708871", "createdAt": "2020-04-18T15:02:25Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator-cli/src/main/java/org/openapitools/codegen/cmd/Generate.java", "diffHunk": "@@ -240,6 +240,9 @@\n     @Option(name = {\"--generate-alias-as-model\"}, title = \"generate alias (array, map) as model\", description = CodegenConstants.GENERATE_ALIAS_AS_MODEL_DESC)\n     private Boolean generateAliasAsModel;\n \n+    @Option(name = {\"--discriminator-explicit-mapping-verbose\"}, title = \"explicitly define a discriminator on all models which have one, add verbose mapping to that discriminator, validate discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01f7e5b077978f8c1d6ebc1a3a917ab14adbfa89"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxNzc0MQ==", "bodyText": "This was mistakenly commented in the wrong PR. I am marking it resolved.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414717741", "createdAt": "2020-04-24T16:47:54Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator-cli/src/main/java/org/openapitools/codegen/cmd/Generate.java", "diffHunk": "@@ -240,6 +240,9 @@\n     @Option(name = {\"--generate-alias-as-model\"}, title = \"generate alias (array, map) as model\", description = CodegenConstants.GENERATE_ALIAS_AS_MODEL_DESC)\n     private Boolean generateAliasAsModel;\n \n+    @Option(name = {\"--discriminator-explicit-mapping-verbose\"}, title = \"explicitly define a discriminator on all models which have one, add verbose mapping to that discriminator, validate discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwODg3MQ=="}, "originalCommit": {"oid": "01f7e5b077978f8c1d6ebc1a3a917ab14adbfa89"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MDQ1NjA4OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTowMzo1NFrOGHrskQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTowMzo1NFrOGHrskQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwOTEzNw==", "bodyText": "Potential NPE. You protect in the constructor, but not in the property setter.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r410709137", "createdAt": "2020-04-18T15:03:54Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -63,15 +90,36 @@ public void setMappedModels(Set<MappedModel> mappedModels) {\n         this.mappedModels = mappedModels;\n     }\n \n-    public static class MappedModel {\n+    /**\n+     * An object to hold discriminator mappings between payload values and schema names or\n+     * references.\n+     *\n+     * In the OpenAPI document, the discriminator \"mapping\" attribute is optional.\n+     * In scenarios where the value of the discriminator field does not match the schema name\n+     * or implicit mapping is not possible, an optional mapping definition MAY be used.\n+     * In OpenAPITools codegen, the MappedModel is the union of all the discriminator mappings,\n+     * both explicitly defined in the OpenAPI document and inherited from oneOf/allOf/anyOf.\n+     */\n+    public static class MappedModel implements Comparable<MappedModel>{\n+        // The value of the discriminator property in the payload.\n         private String mappingName;\n+        // The OAS schema name. It is obtained from the OAS document, and the string value\n+        // is converted to a sanitized, internal representation within codegen.\n         private String modelName;\n \n         public MappedModel(String mappingName, String modelName) {\n+            if (mappingName == null) {\n+                throw new RuntimeException(\"Discriminator mapping name cannot be null for model '\" + modelName + \"'\");\n+            }\n             this.mappingName = mappingName;\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01f7e5b077978f8c1d6ebc1a3a917ab14adbfa89"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MDQ1NzYzOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTowNToyMFrOGHrtSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTowNToyMFrOGHrtSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwOTMyMQ==", "bodyText": "This should not be marked as protected as it reduces maintainability. If necessary for tests, please remove private to make it package private.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r410709321", "createdAt": "2020-04-18T15:05:20Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "diffHunk": "@@ -156,7 +156,7 @@ private Boolean getGeneratorPropertyDefaultSwitch(final String key, final Boolea\n         return defaultValue;\n     }\n \n-    private void configureGeneratorProperties() {\n+    protected void configureGeneratorProperties() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01f7e5b077978f8c1d6ebc1a3a917ab14adbfa89"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MDQ1ODM5OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTowNjozMFrOGHrtsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTowNjozMFrOGHrtsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwOTQyNg==", "bodyText": "This should not be marked protected.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r410709426", "createdAt": "2020-04-18T15:06:30Z", "author": {"login": "jimschubert"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "diffHunk": "@@ -394,7 +394,7 @@ private void generateModel(List<File> files, Map<String, Object> models, String\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private void generateModels(List<File> files, List<Object> allModels, List<String> unusedModels) {\n+    protected void generateModels(List<File> files, List<Object> allModels, List<String> unusedModels) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01f7e5b077978f8c1d6ebc1a3a917ab14adbfa89"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODIwNDQyOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "isResolved": true, "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzoyMzowMlrOGLhrLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDo1Nzo1OFrOGLo-2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTI0NA==", "bodyText": "@sebastien-rosset @wing328 @jimschubert what should we allow here, valid objects and empty state values?\nNull only? Null and empty dict?\nIs this a language specific decision? If so we should separate it off as a separate method.\n\nFor example for python values like empty dict {} and None are valid empty values here.\nFor golang the zero value of a map is nil.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414739244", "createdAt": "2020-04-24T17:23:02Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2526,36 +2526,60 @@ private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n             if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n                 // All oneOf definitions must contain the discriminator\n                 Integer hasDiscriminatorCnt = 0;\n+                Integer hasNullTypeCnt = 0;\n                 Set<String> discriminatorsPropNames = new HashSet<>();\n                 for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (ModelUtils.isNullType(oneOf)) {\n+                        // The null type does not have a discriminator. Skip.\n+                        hasNullTypeCnt++;\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0NDY1Mg==", "bodyText": "The \"null type\" (supported in OAS >=3.1) is when the OAS schema is:\ntype: 'null'\nIt means the value in the payload must be null. This can typically be list as one child of \"oneOf\". In OAS >= 3.1 the \"nullable\" attribute is being deprecated, which means in the future it won't be possible to have something like this:\ntype: object\nnullable: true", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414744652", "createdAt": "2020-04-24T17:31:39Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2526,36 +2526,60 @@ private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n             if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n                 // All oneOf definitions must contain the discriminator\n                 Integer hasDiscriminatorCnt = 0;\n+                Integer hasNullTypeCnt = 0;\n                 Set<String> discriminatorsPropNames = new HashSet<>();\n                 for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (ModelUtils.isNullType(oneOf)) {\n+                        // The null type does not have a discriminator. Skip.\n+                        hasNullTypeCnt++;\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTI0NA=="}, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc2MjE4Ng==", "bodyText": "So I am not asking if it is in the specification. I understand that it is. I am asking if we should also allow an empty object payload here as synonymous with null because that is a python zeto state like null/None.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414762186", "createdAt": "2020-04-24T18:00:37Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2526,36 +2526,60 @@ private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n             if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n                 // All oneOf definitions must contain the discriminator\n                 Integer hasDiscriminatorCnt = 0;\n+                Integer hasNullTypeCnt = 0;\n                 Set<String> discriminatorsPropNames = new HashSet<>();\n                 for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (ModelUtils.isNullType(oneOf)) {\n+                        // The null type does not have a discriminator. Skip.\n+                        hasNullTypeCnt++;\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTI0NA=="}, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc2OTQzNw==", "bodyText": "The change is to specifically cover the following scenario:\noneOf:\n  - type: null\n  - $ref: abc   # possibly a list of inline types or references to types.\nWithout this PR, the count of oneOf children was not be equal to the number of discriminators. That's because the \"null\" value does not have a discriminator. As a result, the disc.setPropertyName() was not set, which is incorrect.\n\nI am asking if we should also allow an empty object payload\n\nCan you give how this would be modeled in the OAS document? Here we are parsing OAS schemas, not payloads.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414769437", "createdAt": "2020-04-24T18:12:49Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2526,36 +2526,60 @@ private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n             if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n                 // All oneOf definitions must contain the discriminator\n                 Integer hasDiscriminatorCnt = 0;\n+                Integer hasNullTypeCnt = 0;\n                 Set<String> discriminatorsPropNames = new HashSet<>();\n                 for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (ModelUtils.isNullType(oneOf)) {\n+                        // The null type does not have a discriminator. Skip.\n+                        hasNullTypeCnt++;\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTI0NA=="}, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5MTIyNg==", "bodyText": "We are describing payloads here. An empty object represents an empty dict. Should this definition be valid?\nComposedSchema:\nOneOf\n- type: null\n- type: object\n- $ref: AnyType\n- $ref: Pet\ndiscriminator:\n  PropertyName: petType\n\nAnyType:\n  description: I allow any type including null", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414791226", "createdAt": "2020-04-24T18:50:16Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2526,36 +2526,60 @@ private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n             if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n                 // All oneOf definitions must contain the discriminator\n                 Integer hasDiscriminatorCnt = 0;\n+                Integer hasNullTypeCnt = 0;\n                 Set<String> discriminatorsPropNames = new HashSet<>();\n                 for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (ModelUtils.isNullType(oneOf)) {\n+                        // The null type does not have a discriminator. Skip.\n+                        hasNullTypeCnt++;\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTI0NA=="}, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5NTgxMA==", "bodyText": "I think that AnyType should not be allowed because list/int/float/str/bytes/date/datetime primitives are different data types than an intended dict/pojo.\nMy preference is to allow null and empty object but log a warning to the user that this definition is not compliant with the v3 specification but we allow it.\nThese feel like bleeding edge decisions that we are making.\nNote: type: \"null\" will be in the upcoming 3.1.0 spec definition", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414795810", "createdAt": "2020-04-24T18:58:18Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2526,36 +2526,60 @@ private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n             if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n                 // All oneOf definitions must contain the discriminator\n                 Integer hasDiscriminatorCnt = 0;\n+                Integer hasNullTypeCnt = 0;\n                 Set<String> discriminatorsPropNames = new HashSet<>();\n                 for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (ModelUtils.isNullType(oneOf)) {\n+                        // The null type does not have a discriminator. Skip.\n+                        hasNullTypeCnt++;\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTI0NA=="}, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyMjUzNA==", "bodyText": "Thanks for the clarification. Here is one statement in the OAS 3.1 spec:\n\nWhen using the discriminator, inline schemas will not be considered.\n\nThe way I interpret is that if there is a mix of oneOf children, some through a $ref, others inline, then at runtime:\n\nFor the inline schemas, use JSON schema validation to determine if the payload matches the schema. Don't use the discriminator.\nFor $ref schemas, don't use JSON schema validation, and instead use the discriminator.\n\nSo if my understand is correct, the schema you have provided is a valid OAS schema. HOWEVER, at runtime it will fail validation in many situations, because of the presence of \"AnyType\". It will fail when the payload is \"null\", object and Pet (because these payloads are also \"Any Type\", which means the payload matches TWO oneOf child schemas. It would work if the payload is a primitive type or an array. So it would be much better to write the OAS spec differently.\nI'd rather address these use cases in separate PRs. IMO, we would ideally add validation rules to the --validate option.\nIn the OAS 3.0.3 spec:\n\nWhen used, the discriminator will be the name of the property that decides which schema definition validates the structure of the model. As such, the discriminator field MUST be a required field.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414822534", "createdAt": "2020-04-24T19:48:03Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2526,36 +2526,60 @@ private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n             if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n                 // All oneOf definitions must contain the discriminator\n                 Integer hasDiscriminatorCnt = 0;\n+                Integer hasNullTypeCnt = 0;\n                 Set<String> discriminatorsPropNames = new HashSet<>();\n                 for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (ModelUtils.isNullType(oneOf)) {\n+                        // The null type does not have a discriminator. Skip.\n+                        hasNullTypeCnt++;\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTI0NA=="}, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDc4Nw==", "bodyText": "Our users could just as easily write a spec that looks like this:\nAnimal:\noneOf:\n- $ref: NullType\n- $ref: Pet\ndiscriminator:\n  propertyName: animalType\n\nNullType:\ntype: \"null\"\n\nShould we handle that referenced null case? I think that we should.\nYou are proposing accepting nulls in a payload when a strict interpretation of the spec would require the presence of a pojo with a discriminator.propertyName at not null. So I feel like we're in uncharted territory here.\nIn your comment you mention that it would fail because it would double match null on AnyType and type: None. That wasn't the point that I was trying to make. The questions that I am trying to get your answers on are:\n\nShould AnyType be allowed in oneOf generally?\n\nMy vote is no. If they have this in the oneOf then it has to be the only entry. Also then they can't have any allOf definition. Which is equivalent to just using the AnyType directly.\n\n\nShould empty object type: object be allowed in oneOf?\n\nI think that we should allow type: \"null\" in oneOf with a discriminator but I do not think that that behavior is defined in the draft 3.1.0 spec yet.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414834787", "createdAt": "2020-04-24T20:11:13Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2526,36 +2526,60 @@ private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n             if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n                 // All oneOf definitions must contain the discriminator\n                 Integer hasDiscriminatorCnt = 0;\n+                Integer hasNullTypeCnt = 0;\n                 Set<String> discriminatorsPropNames = new HashSet<>();\n                 for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (ModelUtils.isNullType(oneOf)) {\n+                        // The null type does not have a discriminator. Skip.\n+                        hasNullTypeCnt++;\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTI0NA=="}, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzODU0MA==", "bodyText": "When mixing types in oneOf, should we disallow the use of allOf + anyOf in the composed schema?\nOtherwise you could have the invalid:\nCreature:\nallOf:\n- $ref: Animal\noneOf:\n- type: int\n- $ref: Pet", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414838540", "createdAt": "2020-04-24T20:18:37Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2526,36 +2526,60 @@ private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n             if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n                 // All oneOf definitions must contain the discriminator\n                 Integer hasDiscriminatorCnt = 0;\n+                Integer hasNullTypeCnt = 0;\n                 Set<String> discriminatorsPropNames = new HashSet<>();\n                 for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (ModelUtils.isNullType(oneOf)) {\n+                        // The null type does not have a discriminator. Skip.\n+                        hasNullTypeCnt++;\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTI0NA=="}, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0NzUyMA==", "bodyText": "Our users could just as easily write a spec that looks like this:\nAnimal:\noneOf:\n- $ref: NullType\n- $ref: Pet\ndiscriminator:\n  propertyName: animalType\n\nNullType:\ntype: \"null\"\n\nShould we handle that referenced null case? I think that we should.\n\nI don't think this matches what is written in the OAS 3.1 spec. If the type is a ref and there is a discriminator, the discriminator must be used. That's my understand of the spec. So your YAML is not equivalent.\n\nYou are proposing accepting nulls in a payload when a strict interpretation of the spec would require the presence of a pojo with a discriminator.propertyName at not null. So I feel like we're in uncharted territory here.\n\nWhich part of the spec (3.1) makes you think that? It is indeed my understanding, reading the many threads over the null type that the OAS spec authors intend to replace \"nullable\" with type: 'null' as oneOf child.\n\nIn your comment you mention that it would fail because it would double match null on AnyType and type: None. That wasn't the point that I was trying to make. The questions that I am trying to get your answers on are:\n\nShould AnyType be allowed in oneOf generally?\n\n\nYes, absolutely, for example below it's a sensible way to say the payload can be anything, including null. I think there is even one thread about this specific item in the draft discussions that led to 3.1, I will try to dig it up.\noneOf:\n- type: 'null'\n- description: any type\n\n\nMy vote is no. If they have this in the oneOf then it has to be the only entry. Also then they can't have any allOf definition. Which is equivalent to just using the AnyType directly.\nShould empty object type: object be allowed in oneOf?\n\nI think that we should allow type: \"null\" in oneOf with a discriminator but I do not think that that behavior is defined in the draft 3.1.0 spec yet.\n\nIt is, though admittedly to comprehend the spec it helps to read the many discussion threads rather than the spec itself. One relevant statement of the spec is:\n\nWhen using the discriminator, inline schemas will not be considered.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414847520", "createdAt": "2020-04-24T20:35:52Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2526,36 +2526,60 @@ private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n             if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n                 // All oneOf definitions must contain the discriminator\n                 Integer hasDiscriminatorCnt = 0;\n+                Integer hasNullTypeCnt = 0;\n                 Set<String> discriminatorsPropNames = new HashSet<>();\n                 for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (ModelUtils.isNullType(oneOf)) {\n+                        // The null type does not have a discriminator. Skip.\n+                        hasNullTypeCnt++;\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTI0NA=="}, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg1MTI0NA==", "bodyText": "When mixing types in oneOf, should we disallow the use of allOf + anyOf in the composed schema?\n\nSorry I'm not getting this part. Did you mean a schema like this where there is \"anyOf\"? In the example you provide it is allOf + oneOf, not anyOf.\nCreature:\nallOf:\n- $ref: Animal\nanyOf:\n- type: int\n- $ref: Pet\n\nAlso, can you help me understand how your questions are relevant to this PR? I'm just trying to handle the \"null\" case here, I'm certainly not claiming to cover all possible composed scenarios + \"null\". Is there something specific you see that I am breaking with the support of the \"null\" value? Or are you extending the discussion to other use cases?\n\nOtherwise you could have the invalid:\nCreature:\nallOf:\n- $ref: Animal\noneOf:\n- type: int\n- $ref: Pet", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414851244", "createdAt": "2020-04-24T20:42:52Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2526,36 +2526,60 @@ private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n             if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n                 // All oneOf definitions must contain the discriminator\n                 Integer hasDiscriminatorCnt = 0;\n+                Integer hasNullTypeCnt = 0;\n                 Set<String> discriminatorsPropNames = new HashSet<>();\n                 for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (ModelUtils.isNullType(oneOf)) {\n+                        // The null type does not have a discriminator. Skip.\n+                        hasNullTypeCnt++;\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTI0NA=="}, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg1NDg5Mw==", "bodyText": "This is may be warranted as a separate discussion. It is relevant here because we are mixing types in oneOf definition and we may want to not allow allOf or anyOf definition when we have mixed types like this.\nThe use case that I was highlighting is:\noneOf w/ mixed types AND (allOf AND/OR anyOf)\nCreature:\nallOf:\n- $ref: Animal\noneOf:\n- type: int\n- $ref: Pet\n\nor this case\n\nCreature:\nanyOf:\n- $ref: Animal\noneOf:\n- type: int\n- $ref: Pet", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414854893", "createdAt": "2020-04-24T20:50:12Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2526,36 +2526,60 @@ private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n             if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n                 // All oneOf definitions must contain the discriminator\n                 Integer hasDiscriminatorCnt = 0;\n+                Integer hasNullTypeCnt = 0;\n                 Set<String> discriminatorsPropNames = new HashSet<>();\n                 for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (ModelUtils.isNullType(oneOf)) {\n+                        // The null type does not have a discriminator. Skip.\n+                        hasNullTypeCnt++;\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTI0NA=="}, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg1ODk3MA==", "bodyText": "Which part of the spec (3.1) makes you think that? It is indeed my understanding, reading the many threads over the null type that the OAS spec authors intend to replace \"nullable\" with type: 'null' as oneOf child.\n\nWhen using the discriminator, inline schemas will not be considered.\nI read this as don't deserialize inline schemas when a discriminator exists in a composed schema (don't allow/process null payloads).\nWhen the discriminator exists in the spec or the payload?\nWhen the discriminator exists in the spec it must be in the payload per:\nThe expectation now is that a property with name petType MUST be present in the response payload, and the value will correspond to the name of a schema defined in the OAS document. ...", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r414858970", "createdAt": "2020-04-24T20:57:58Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2526,36 +2526,60 @@ private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n             if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n                 // All oneOf definitions must contain the discriminator\n                 Integer hasDiscriminatorCnt = 0;\n+                Integer hasNullTypeCnt = 0;\n                 Set<String> discriminatorsPropNames = new HashSet<>();\n                 for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (ModelUtils.isNullType(oneOf)) {\n+                        // The null type does not have a discriminator. Skip.\n+                        hasNullTypeCnt++;\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTI0NA=="}, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MzY2Mjc1OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQyMDo1MDoxOVrOGMJ4CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjowMTowNFrOGMrDDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5Nzg5Ng==", "bodyText": "Can you add type descriptions here?\nA tuple containing (used_model_class, discr_propertyname_js, discr_value)\nused_model_class (class/None): the chosen child class that will be used to deserialize the data, for example dog.Dog. If a class is not found, None is returned\ndiscr_propertyname_js (string): the discriminator.propertyName from the opeanpi spec\ndiscr_value (string): the class name in model_data which is the key that we use to return used_model_class from our discriminator, for example 'Dog'", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r415397896", "createdAt": "2020-04-26T20:50:19Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "diffHunk": "@@ -567,6 +567,43 @@ def fix_model_input_data(model_data, model_class):\n             )\n     return fixed_model_data\n \n+def get_discriminator_class(model_class, from_server, model_data, cls_visited):\n+    \"\"\"Returns the child class specified by the discriminator.\n+\n+    Args:\n+        model_class (OpenApiModel): the model class\n+        from_server (bool): True if the model_data is from the server\n+            False if the data is from the client\n+        model_data (list/dict): data to instantiate the model.\n+        cls_visited (set): list of model classes that have been visited.\n+            Used to determine the discriminator class without\n+            visiting circular references indefinitely.\n+\n+    Returns:\n+        A tuple containing the child class specified by the discriminator,\n+        the name of the discriminator property, and the discriminator value\n+        in the input data.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk0MTM4OQ==", "bodyText": "Sure, I am adding. We should use the term \"OpenAPI document\" not \"OpenAPI specification\" when referring to a YAML/JSON document describing an API. The \"spec\" is the standard.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r415941389", "createdAt": "2020-04-27T16:01:04Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "diffHunk": "@@ -567,6 +567,43 @@ def fix_model_input_data(model_data, model_class):\n             )\n     return fixed_model_data\n \n+def get_discriminator_class(model_class, from_server, model_data, cls_visited):\n+    \"\"\"Returns the child class specified by the discriminator.\n+\n+    Args:\n+        model_class (OpenApiModel): the model class\n+        from_server (bool): True if the model_data is from the server\n+            False if the data is from the client\n+        model_data (list/dict): data to instantiate the model.\n+        cls_visited (set): list of model classes that have been visited.\n+            Used to determine the discriminator class without\n+            visiting circular references indefinitely.\n+\n+    Returns:\n+        A tuple containing the child class specified by the discriminator,\n+        the name of the discriminator property, and the discriminator value\n+        in the input data.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5Nzg5Ng=="}, "originalCommit": {"oid": "46669f100b82643f1405f9ed2fd1f34fd1d1caf9"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzQyNTAwOnYy", "diffSide": "RIGHT", "path": "samples/client/petstore/python-experimental/petstore_api/model_utils.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzoyODowNlrOGQ_QUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMzoyNDo1OVrOGRo6BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2Njc2OA==", "bodyText": "We may be passing in _visited_composed_classes in kwargs here, so we need to include it in the inputs to get_discriminator_class.\nCan you extract _visited_composed_classes from kwargs and pass it in to get_discriminator_class here?", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r420466768", "createdAt": "2020-05-05T23:28:06Z", "author": {"login": "spacether"}, "path": "samples/client/petstore/python-experimental/petstore_api/model_utils.py", "diffHunk": "@@ -148,7 +148,7 @@ def __new__(cls, *args, **kwargs):\n         oneof_anyof_classes = []\n         oneof_anyof_classes.extend(cls._composed_schemas.get('oneOf', ()))\n         oneof_anyof_classes.extend(cls._composed_schemas.get('anyOf', ()))\n-        new_cls = cls.get_discriminator_class(kwargs)\n+        new_cls = get_discriminator_class(cls, kwargs, set())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93297051892c88d22b7f8d187ce7c97cf6a9b206"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE0NzA2Mw==", "bodyText": "I mean:\n_visited_composed_classes = kwargs.get('_visited_composed_classes', ())\nnew_cls = get_discriminator_class(cls, kwargs, _visited_composed_classes)\n\nYou need this because if we travel through two discriminators. The __new__ call to the class with the second discriminator will be passing in _visited_composed_classes here.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r421147063", "createdAt": "2020-05-06T23:18:39Z", "author": {"login": "spacether"}, "path": "samples/client/petstore/python-experimental/petstore_api/model_utils.py", "diffHunk": "@@ -148,7 +148,7 @@ def __new__(cls, *args, **kwargs):\n         oneof_anyof_classes = []\n         oneof_anyof_classes.extend(cls._composed_schemas.get('oneOf', ()))\n         oneof_anyof_classes.extend(cls._composed_schemas.get('anyOf', ()))\n-        new_cls = cls.get_discriminator_class(kwargs)\n+        new_cls = get_discriminator_class(cls, kwargs, set())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2Njc2OA=="}, "originalCommit": {"oid": "93297051892c88d22b7f8d187ce7c97cf6a9b206"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE0OTE4OQ==", "bodyText": "hmm, ok, I am going through your code to try to understand what it does, because now there would be two parts of the code adding to the _visited_composed_classes tuple, with two separate tests to check if a class has already been visited or not.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r421149189", "createdAt": "2020-05-06T23:24:59Z", "author": {"login": "sebastien-rosset"}, "path": "samples/client/petstore/python-experimental/petstore_api/model_utils.py", "diffHunk": "@@ -148,7 +148,7 @@ def __new__(cls, *args, **kwargs):\n         oneof_anyof_classes = []\n         oneof_anyof_classes.extend(cls._composed_schemas.get('oneOf', ()))\n         oneof_anyof_classes.extend(cls._composed_schemas.get('anyOf', ()))\n-        new_cls = cls.get_discriminator_class(kwargs)\n+        new_cls = get_discriminator_class(cls, kwargs, set())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2Njc2OA=="}, "originalCommit": {"oid": "93297051892c88d22b7f8d187ce7c97cf6a9b206"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzQ4NDc0OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzo1NjozOVrOGQ_zow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMzozOTozN1rOGTIopQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NTgxMQ==", "bodyText": "Why are we looping over these values?\nDo we want to loop over the ancestors here?\nIf we have:\nallOf:\n\nAnimal\n\noneOf:\n\nCat\nDog\n\nwe are looking at the discriminators in Cat and Dog.\nDon't we instead want to look at the discriminator in Animal? Can you add comments here describing what we are doing?\n# if we didn't find a discriminated class it may exist in an ancestor\nWhatever you are adding, can you add a sample schema and test that verifies that this feature is working?\nOtherwise if it breaks in the future, we will have no way of seeing that it has broken.\nFor example ParentPet only discriminates to\n\nChildCat\nChildDog\nChildLizard\n\nBut it allOf includes GrandparentAnimal.\nwhich includes those AND ParentPet.\nSo if we deserialize a payload:\n{petType: \"ParentPet\"} where data_type = parent_pet.ParentPet, we should travel back through its GrandparentAnimal ancestor to find the correct class to deserialize to, as long as the discriminator is the same.\nShould we look in the current discriminator, then look in descendants, then look in ancestors?\nIt looks like yes per https://github.com/OpenAPITools/openapi-generator/pull/4913/files", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r420475811", "createdAt": "2020-05-05T23:56:39Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "diffHunk": "@@ -622,6 +622,46 @@ def deserialize_primitive(data, klass, path_to_item):\n         )\n \n \n+def get_discriminator_class(model_class, model_data, cls_visited):\n+    \"\"\"Returns the child class specified by the discriminator.\n+\n+    Args:\n+        model_class (OpenApiModel): the model class\n+        model_data (list/dict): data to instantiate the model.\n+        cls_visited (set): list of model classes that have been visited.\n+            Used to determine the discriminator class without\n+            visiting circular references indefinitely.\n+\n+    Returns:\n+        used_model_class (class/None): the chosen child class that will be used\n+            to deserialize the data, for example dog.Dog.\n+            If a class is not found, None is returned.\n+    \"\"\"\n+\n+    cls_visited.add(model_class)\n+    discriminator = model_class.discriminator\n+    discr_propertyname_py = list(discriminator.keys())[0]\n+    discr_propertyname_js = model_class.attribute_map[discr_propertyname_py]\n+    if discr_propertyname_js in model_data:\n+        discr_value = model_data[discr_propertyname_js]\n+    elif discr_propertyname_py in model_data:\n+        discr_value = model_data[discr_propertyname_py]\n+    else:\n+        # The input data does not contain the discriminator property.\n+        # The caller will raise an exception.\n+        return None\n+    class_name_to_discr_class = discriminator[discr_propertyname_py]\n+    used_model_class = class_name_to_discr_class.get(discr_value)\n+    if used_model_class is None:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93297051892c88d22b7f8d187ce7c97cf6a9b206"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEyNDIxMQ==", "bodyText": "Why are we looping over these values?\nDo we want to loop over the ancestors here?\n\nWhat is your exact definition of ancestor? Is it the allOf children?\n\nIf we have:\nallOf:\n\nAnimal\n\noneOf:\n\nCat\nDog\n\nwe are looking at the discriminators in Cat and Dog.\nDon't we instead want to look at the discriminator in Animal?\n\nSure yes in that example, but what if instead the schema is:\noneOf:\n- Animal\n- Plant\nIn that case there are potentially many subclasses of animal and plant, so we would need to traverse through oneOf. Same thing for anyOf.\n\nCan you add comments here describing what we are doing?\n# if we didn't find a discriminated class it may exist in an ancestor\nWhatever you are adding, can you add a sample schema and test that verifies that this feature is working?\nOtherwise if it breaks in the future, we will have no way of seeing that it has broken.\nFor example ParentPet only discriminates to\n\nChildCat\nChildDog\nChildLizard\n\nBut it allOf includes GrandparentAnimal.\nwhich includes those AND ParentPet.\nSo if we deserialize a payload:\n{petType: \"ParentPet\"} where data_type = parent_pet.ParentPet, we should travel back through its GrandparentAnimal ancestor to find the correct class to deserialize to, as long as the discriminator is the same.\nShould we look in the current discriminator, then look in descendants, then look in ancestors?\nIt looks like yes per https://github.com/OpenAPITools/openapi-generator/pull/4913/files", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r421124211", "createdAt": "2020-05-06T22:16:11Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "diffHunk": "@@ -622,6 +622,46 @@ def deserialize_primitive(data, klass, path_to_item):\n         )\n \n \n+def get_discriminator_class(model_class, model_data, cls_visited):\n+    \"\"\"Returns the child class specified by the discriminator.\n+\n+    Args:\n+        model_class (OpenApiModel): the model class\n+        model_data (list/dict): data to instantiate the model.\n+        cls_visited (set): list of model classes that have been visited.\n+            Used to determine the discriminator class without\n+            visiting circular references indefinitely.\n+\n+    Returns:\n+        used_model_class (class/None): the chosen child class that will be used\n+            to deserialize the data, for example dog.Dog.\n+            If a class is not found, None is returned.\n+    \"\"\"\n+\n+    cls_visited.add(model_class)\n+    discriminator = model_class.discriminator\n+    discr_propertyname_py = list(discriminator.keys())[0]\n+    discr_propertyname_js = model_class.attribute_map[discr_propertyname_py]\n+    if discr_propertyname_js in model_data:\n+        discr_value = model_data[discr_propertyname_js]\n+    elif discr_propertyname_py in model_data:\n+        discr_value = model_data[discr_propertyname_py]\n+    else:\n+        # The input data does not contain the discriminator property.\n+        # The caller will raise an exception.\n+        return None\n+    class_name_to_discr_class = discriminator[discr_propertyname_py]\n+    used_model_class = class_name_to_discr_class.get(discr_value)\n+    if used_model_class is None:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NTgxMQ=="}, "originalCommit": {"oid": "93297051892c88d22b7f8d187ce7c97cf6a9b206"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE0NTc2NA==", "bodyText": "We are agreed that we should loop over descendants then ancestors pr our slack chat.\nDescendants are the oneOf/anyOf children and are present in the class_name_to_discr_class.\nAncestors are in cls._composed_schemas['allOf']\nCan you:\n\nadd comments describing where we are looping over ancestors and descentents and why were are looping over them\nadd code to loop over ancestors\nadd a test case that demonstrates deserializing a descendent\nadd a test case that demonstrates deserializing an ancestor. You should be able to do this with the ParentPet class deserializing a ParentPet\nupdate this function to not pass in model_data, instead pass in the value from the payload corresponding to the discriminator.propertyName. This lets us cache the results of function calls in the next item.\ncache the results of the function calls by adding a lru_cache decorator around the get_discriminator_class function. I am fine with us only adding this for python3 because we will drop python 2.7 sometime in the near future. You can do this with pseudocode:\n\nif six.PY3:\n  get_discriminator_class = lru_cache(get_discriminator_class)", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r421145764", "createdAt": "2020-05-06T23:14:44Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "diffHunk": "@@ -622,6 +622,46 @@ def deserialize_primitive(data, klass, path_to_item):\n         )\n \n \n+def get_discriminator_class(model_class, model_data, cls_visited):\n+    \"\"\"Returns the child class specified by the discriminator.\n+\n+    Args:\n+        model_class (OpenApiModel): the model class\n+        model_data (list/dict): data to instantiate the model.\n+        cls_visited (set): list of model classes that have been visited.\n+            Used to determine the discriminator class without\n+            visiting circular references indefinitely.\n+\n+    Returns:\n+        used_model_class (class/None): the chosen child class that will be used\n+            to deserialize the data, for example dog.Dog.\n+            If a class is not found, None is returned.\n+    \"\"\"\n+\n+    cls_visited.add(model_class)\n+    discriminator = model_class.discriminator\n+    discr_propertyname_py = list(discriminator.keys())[0]\n+    discr_propertyname_js = model_class.attribute_map[discr_propertyname_py]\n+    if discr_propertyname_js in model_data:\n+        discr_value = model_data[discr_propertyname_js]\n+    elif discr_propertyname_py in model_data:\n+        discr_value = model_data[discr_propertyname_py]\n+    else:\n+        # The input data does not contain the discriminator property.\n+        # The caller will raise an exception.\n+        return None\n+    class_name_to_discr_class = discriminator[discr_propertyname_py]\n+    used_model_class = class_name_to_discr_class.get(discr_value)\n+    if used_model_class is None:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NTgxMQ=="}, "originalCommit": {"oid": "93297051892c88d22b7f8d187ce7c97cf6a9b206"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcyMjkyNQ==", "bodyText": "I will not do 6 in this PR. This increases the scope of the PR and should be handled in a different PR.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r421722925", "createdAt": "2020-05-07T18:54:33Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "diffHunk": "@@ -622,6 +622,46 @@ def deserialize_primitive(data, klass, path_to_item):\n         )\n \n \n+def get_discriminator_class(model_class, model_data, cls_visited):\n+    \"\"\"Returns the child class specified by the discriminator.\n+\n+    Args:\n+        model_class (OpenApiModel): the model class\n+        model_data (list/dict): data to instantiate the model.\n+        cls_visited (set): list of model classes that have been visited.\n+            Used to determine the discriminator class without\n+            visiting circular references indefinitely.\n+\n+    Returns:\n+        used_model_class (class/None): the chosen child class that will be used\n+            to deserialize the data, for example dog.Dog.\n+            If a class is not found, None is returned.\n+    \"\"\"\n+\n+    cls_visited.add(model_class)\n+    discriminator = model_class.discriminator\n+    discr_propertyname_py = list(discriminator.keys())[0]\n+    discr_propertyname_js = model_class.attribute_map[discr_propertyname_py]\n+    if discr_propertyname_js in model_data:\n+        discr_value = model_data[discr_propertyname_js]\n+    elif discr_propertyname_py in model_data:\n+        discr_value = model_data[discr_propertyname_py]\n+    else:\n+        # The input data does not contain the discriminator property.\n+        # The caller will raise an exception.\n+        return None\n+    class_name_to_discr_class = discriminator[discr_propertyname_py]\n+    used_model_class = class_name_to_discr_class.get(discr_value)\n+    if used_model_class is None:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NTgxMQ=="}, "originalCommit": {"oid": "93297051892c88d22b7f8d187ce7c97cf6a9b206"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcxNzYwNQ==", "bodyText": "Thanks for letting me know about point 6. I can definitely add 6 in a different PR.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r422717605", "createdAt": "2020-05-10T23:39:37Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "diffHunk": "@@ -622,6 +622,46 @@ def deserialize_primitive(data, klass, path_to_item):\n         )\n \n \n+def get_discriminator_class(model_class, model_data, cls_visited):\n+    \"\"\"Returns the child class specified by the discriminator.\n+\n+    Args:\n+        model_class (OpenApiModel): the model class\n+        model_data (list/dict): data to instantiate the model.\n+        cls_visited (set): list of model classes that have been visited.\n+            Used to determine the discriminator class without\n+            visiting circular references indefinitely.\n+\n+    Returns:\n+        used_model_class (class/None): the chosen child class that will be used\n+            to deserialize the data, for example dog.Dog.\n+            If a class is not found, None is returned.\n+    \"\"\"\n+\n+    cls_visited.add(model_class)\n+    discriminator = model_class.discriminator\n+    discr_propertyname_py = list(discriminator.keys())[0]\n+    discr_propertyname_js = model_class.attribute_map[discr_propertyname_py]\n+    if discr_propertyname_js in model_data:\n+        discr_value = model_data[discr_propertyname_js]\n+    elif discr_propertyname_py in model_data:\n+        discr_value = model_data[discr_propertyname_py]\n+    else:\n+        # The input data does not contain the discriminator property.\n+        # The caller will raise an exception.\n+        return None\n+    class_name_to_discr_class = discriminator[discr_propertyname_py]\n+    used_model_class = class_name_to_discr_class.get(discr_value)\n+    if used_model_class is None:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NTgxMQ=="}, "originalCommit": {"oid": "93297051892c88d22b7f8d187ce7c97cf6a9b206"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTgwMDI0OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMzozOToyMVrOGRpLmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMDo1MDoyNVrOGRqg4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1MzY4OA==", "bodyText": "cls_visited should be a tuple, not a set. Our classes are not hashable so we need to make sure to store them in a tuple not a set.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r421153688", "createdAt": "2020-05-06T23:39:21Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "diffHunk": "@@ -622,6 +622,46 @@ def deserialize_primitive(data, klass, path_to_item):\n         )\n \n \n+def get_discriminator_class(model_class, model_data, cls_visited):\n+    \"\"\"Returns the child class specified by the discriminator.\n+\n+    Args:\n+        model_class (OpenApiModel): the model class\n+        model_data (list/dict): data to instantiate the model.\n+        cls_visited (set): list of model classes that have been visited.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1329d282d41a91529556325621b8e1223fe159f"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE3NTUyMQ==", "bodyText": "done", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r421175521", "createdAt": "2020-05-07T00:50:25Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "diffHunk": "@@ -622,6 +622,46 @@ def deserialize_primitive(data, klass, path_to_item):\n         )\n \n \n+def get_discriminator_class(model_class, model_data, cls_visited):\n+    \"\"\"Returns the child class specified by the discriminator.\n+\n+    Args:\n+        model_class (OpenApiModel): the model class\n+        model_data (list/dict): data to instantiate the model.\n+        cls_visited (set): list of model classes that have been visited.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1MzY4OA=="}, "originalCommit": {"oid": "b1329d282d41a91529556325621b8e1223fe159f"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjEwMzUxOnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjoxMjo0MlrOGRr6Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjoxMjo0MlrOGRr6Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODM3OQ==", "bodyText": "We have 2 use cases here:\n\nthis openapi schema does not have a discriminator\nwe have visited this class deserializing a payload with a discriminator. During that process we traveled through this class but did not make an instance of it. Now we are making an instance of a composed class which contains cls in it, so this time make an instance of cls.\nHere's an example of use case 2: If Animal has a discriminator\npetType and we pass in \"Dog\", and the class Dog\nallOf includes Animal, we move through Animal\nonce using the discriminator, and pick Dog.\nThen in the composed schema dog Dog, we will make an instance of the\nAnimal class (because Dal has allOf: Animal) but this time we won't travel\nthrough Animal's discriminator because we passed in\n_visited_composed_classes = (Animal,)", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r421198379", "createdAt": "2020-05-07T02:12:42Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "diffHunk": "@@ -65,31 +65,53 @@ class OpenApiModel(object):\n         # pick a new schema/class to instantiate because a discriminator\n         # propertyName value was passed in\n \n+        # Build a list containing all oneOf and anyOf descendants.\n+        oneof_anyof_classes = cls._composed_schemas.get('oneOf', ()) +\n+                                cls._composed_schemas.get('anyOf', ())\n+        if oneof_anyof_classes and none_type in oneof_anyof_classes and args[0] is None:\n+            # The input data is the 'null' value AND one of the oneOf/anyOf children\n+            # is the 'null' type (which is introduced in OAS schema >= 3.1).\n+            return None\n+\n         visited_composed_classes = kwargs.get('_visited_composed_classes', ())\n         if (\n             cls.discriminator is None or\n             cls in visited_composed_classes\n         ):\n-            # we don't have a discriminator\n-            # or we have already visited this class before and are sure that we\n-            # want to instantiate it this time\n+            # There is no discriminator.\n+            # Or we have already visited this class before and are sure that we\n+            # want to instantiate it this time. For example, this happens when\n+            # we deserialize Dog from Animal. Dog contains an Animal instance. We go from Animal to Dog back to Animal", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca44756249ef04b3b2f31acde553a93824fa8b9c"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjE5NjI5OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMzowNTo0OVrOGRsvsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNTo0NjowNFrOGSE2gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMjA4MQ==", "bodyText": "# if we are making an instance of a composed schema Descendent\n        # which allOf includes Ancestor, then Ancestor contains\n        # a discriminator that includes Descendent.\n        # So if we make an instance of Descendent, we have to make an\n        # instance of Ancestor to hold the allOf properties.\n        # This code detects that use case and makes the instance of Ancestor\n        # For example:\n        # When making an instance of Dog, _visited_composed_classes = (Dog,)\n        # then we make an instance of Animal to include in dog._composed_instances\n        # so when we are here, cls is Animal\n        # cls.discriminator != None\n        # cls not in _visited_composed_classes\n        # new_cls = Dog\n        # but we know we know that we already have Dog\n        # because it is in visited_composed_classes\n        # so make Animal here", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r421212081", "createdAt": "2020-05-07T03:05:49Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "diffHunk": "@@ -65,31 +65,53 @@ class OpenApiModel(object):\n         # pick a new schema/class to instantiate because a discriminator\n         # propertyName value was passed in\n \n+        # Build a list containing all oneOf and anyOf descendants.\n+        oneof_anyof_classes = cls._composed_schemas.get('oneOf', ()) +\n+                                cls._composed_schemas.get('anyOf', ())\n+        if oneof_anyof_classes and none_type in oneof_anyof_classes and args[0] is None:\n+            # The input data is the 'null' value AND one of the oneOf/anyOf children\n+            # is the 'null' type (which is introduced in OAS schema >= 3.1).\n+            return None\n+\n         visited_composed_classes = kwargs.get('_visited_composed_classes', ())\n         if (\n             cls.discriminator is None or\n             cls in visited_composed_classes\n         ):\n-            # we don't have a discriminator\n-            # or we have already visited this class before and are sure that we\n-            # want to instantiate it this time\n+            # There is no discriminator.\n+            # Or we have already visited this class before and are sure that we\n+            # want to instantiate it this time. For example, this happens when\n+            # we deserialize Dog from Animal. Dog contains an Animal instance. We go from Animal to Dog back to Animal\n             return super(OpenApiModel, cls).__new__(cls)\n \n-        oneof_anyof_classes = []\n-        oneof_anyof_classes.extend(cls._composed_schemas.get('oneOf', ()))\n-        oneof_anyof_classes.extend(cls._composed_schemas.get('anyOf', ()))\n-        new_cls = cls.get_discriminator_class(kwargs)\n+        # Get the name and value of the discriminator property.\n+        # The discriminator name is obtained from the discriminator meta-data\n+        # and the discriminator value is obtained from the input data.\n+        discr_propertyname_py = list(cls.discriminator.keys())[0]\n+        discr_propertyname_js = cls.attribute_map[discr_propertyname_py]\n+        if discr_propertyname_js in kwargs:\n+            discr_value = kwargs[discr_propertyname_js]\n+        elif discr_propertyname_py in kwargs:\n+            discr_value = kwargs[discr_propertyname_py]\n+        else:\n+            # The input data does not contain the discriminator property.\n+            path_to_item = kwargs.get('_path_to_item', ())\n+            raise ApiValueError(\n+                \"Cannot deserialize input data due to missing discriminator. \"\n+                \"The discriminator property '%s' is missing at path: \"\n+                \"'%s'\" % (discr_propertyname_js, path_to_item)\n+            )\n+\n+        new_cls = get_discriminator_class(cls, visited_composed_classes, discr_value)\n         if new_cls is None:\n-            disc_prop_name_py = list(cls.discriminator.keys())[0]\n-            disc_prop_name_js = cls.attribute_map[disc_prop_name_py]\n             path_to_item = kwargs.get('_path_to_item', ())\n             disc_prop_value = kwargs.get(\n-                disc_prop_name_js, kwargs.get(disc_prop_name_py))\n+                discr_propertyname_js, kwargs.get(discr_propertyname_py))\n             raise ApiValueError(\n                 \"Cannot deserialize input data due to invalid discriminator \"\n                 \"value. The OpenAPI document has no mapping for discriminator \"\n                 \"property '%s'='%s' at path: %s\" %\n-                (disc_prop_name_js, disc_prop_value, path_to_item)\n+                (discr_propertyname_js, disc_prop_value, path_to_item)\n             )\n \n         if new_cls in visited_composed_classes:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca44756249ef04b3b2f31acde553a93824fa8b9c"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYwNzA0Mg==", "bodyText": "I have copied this as is. Please submit a pull request if you want to make changes.", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r421607042", "createdAt": "2020-05-07T15:46:04Z", "author": {"login": "sebastien-rosset"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "diffHunk": "@@ -65,31 +65,53 @@ class OpenApiModel(object):\n         # pick a new schema/class to instantiate because a discriminator\n         # propertyName value was passed in\n \n+        # Build a list containing all oneOf and anyOf descendants.\n+        oneof_anyof_classes = cls._composed_schemas.get('oneOf', ()) +\n+                                cls._composed_schemas.get('anyOf', ())\n+        if oneof_anyof_classes and none_type in oneof_anyof_classes and args[0] is None:\n+            # The input data is the 'null' value AND one of the oneOf/anyOf children\n+            # is the 'null' type (which is introduced in OAS schema >= 3.1).\n+            return None\n+\n         visited_composed_classes = kwargs.get('_visited_composed_classes', ())\n         if (\n             cls.discriminator is None or\n             cls in visited_composed_classes\n         ):\n-            # we don't have a discriminator\n-            # or we have already visited this class before and are sure that we\n-            # want to instantiate it this time\n+            # There is no discriminator.\n+            # Or we have already visited this class before and are sure that we\n+            # want to instantiate it this time. For example, this happens when\n+            # we deserialize Dog from Animal. Dog contains an Animal instance. We go from Animal to Dog back to Animal\n             return super(OpenApiModel, cls).__new__(cls)\n \n-        oneof_anyof_classes = []\n-        oneof_anyof_classes.extend(cls._composed_schemas.get('oneOf', ()))\n-        oneof_anyof_classes.extend(cls._composed_schemas.get('anyOf', ()))\n-        new_cls = cls.get_discriminator_class(kwargs)\n+        # Get the name and value of the discriminator property.\n+        # The discriminator name is obtained from the discriminator meta-data\n+        # and the discriminator value is obtained from the input data.\n+        discr_propertyname_py = list(cls.discriminator.keys())[0]\n+        discr_propertyname_js = cls.attribute_map[discr_propertyname_py]\n+        if discr_propertyname_js in kwargs:\n+            discr_value = kwargs[discr_propertyname_js]\n+        elif discr_propertyname_py in kwargs:\n+            discr_value = kwargs[discr_propertyname_py]\n+        else:\n+            # The input data does not contain the discriminator property.\n+            path_to_item = kwargs.get('_path_to_item', ())\n+            raise ApiValueError(\n+                \"Cannot deserialize input data due to missing discriminator. \"\n+                \"The discriminator property '%s' is missing at path: \"\n+                \"'%s'\" % (discr_propertyname_js, path_to_item)\n+            )\n+\n+        new_cls = get_discriminator_class(cls, visited_composed_classes, discr_value)\n         if new_cls is None:\n-            disc_prop_name_py = list(cls.discriminator.keys())[0]\n-            disc_prop_name_js = cls.attribute_map[disc_prop_name_py]\n             path_to_item = kwargs.get('_path_to_item', ())\n             disc_prop_value = kwargs.get(\n-                disc_prop_name_js, kwargs.get(disc_prop_name_py))\n+                discr_propertyname_js, kwargs.get(discr_propertyname_py))\n             raise ApiValueError(\n                 \"Cannot deserialize input data due to invalid discriminator \"\n                 \"value. The OpenAPI document has no mapping for discriminator \"\n                 \"property '%s'='%s' at path: %s\" %\n-                (disc_prop_name_js, disc_prop_value, path_to_item)\n+                (discr_propertyname_js, disc_prop_value, path_to_item)\n             )\n \n         if new_cls in visited_composed_classes:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMjA4MQ=="}, "originalCommit": {"oid": "ca44756249ef04b3b2f31acde553a93824fa8b9c"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMjMyOTY5OnYy", "diffSide": "RIGHT", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwMDowMTowNlrOGTIzEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwMDowMTowNlrOGTIzEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcyMDI3NQ==", "bodyText": "We are not yet handling the use case where discr_name is not in model_class.discriminator here.\nIf we hit that case, then the discriminator propertyName is different than what we are looking for and we should return None early. Here, can you add:\nelse:\n    # the discr_name is not what we are looking for, we did not find the class that we are looking for\n    return None\n\nOr maybe we should make it the clearer:\nif discr_name not in model_class.discriminator:\n    # the discr_name is not what we are looking for, we did not find the class that we are looking for\n    return None\nclass_name_to_discr_class = model_class.discriminator[discr_name]\nused_model_class = class_name_to_discr_class.get(discr_value)", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5809#discussion_r422720275", "createdAt": "2020-05-11T00:01:06Z", "author": {"login": "spacether"}, "path": "modules/openapi-generator/src/main/resources/python/python-experimental/model_utils.mustache", "diffHunk": "@@ -622,6 +691,56 @@ def deserialize_primitive(data, klass, path_to_item):\n         )\n \n \n+def get_discriminator_class(model_class,\n+                            discr_name,\n+                            discr_value, cls_visited):\n+    \"\"\"Returns the child class specified by the discriminator.\n+\n+    Args:\n+        model_class (OpenApiModel): the model class.\n+        discr_name (string): the name of the discriminator property.\n+        discr_value (any): the discriminator value.\n+        cls_visited (list): list of model classes that have been visited.\n+            Used to determine the discriminator class without\n+            visiting circular references indefinitely.\n+\n+    Returns:\n+        used_model_class (class/None): the chosen child class that will be used\n+            to deserialize the data, for example dog.Dog.\n+            If a class is not found, None is returned.\n+    \"\"\"\n+\n+    if model_class in cls_visited:\n+        # The class has already been visited and no suitable class was found.\n+        return None\n+    cls_visited.append(model_class)\n+    used_model_class = None\n+    if discr_name in model_class.discriminator:\n+        class_name_to_discr_class = model_class.discriminator[discr_name]\n+        used_model_class = class_name_to_discr_class.get(discr_value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b587d59ceea3e2dce0378d28c9e681ee603bbcf2"}, "originalPosition": 160}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3633, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}