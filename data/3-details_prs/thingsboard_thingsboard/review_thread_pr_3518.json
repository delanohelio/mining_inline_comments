{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0MTE5MDY5", "number": 3518, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzoxMDowMFrOEoElRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowOToyMFrOEr_H_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDUzNTcyOnYy", "diffSide": "RIGHT", "path": "common/transport/mqtt/src/main/java/org/thingsboard/server/transport/mqtt/MqttTransportHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzoxMDowMFrOHY861A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzoxMDowMFrOHY861A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkyNTk3Mg==", "bodyText": "Is it need?", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r495925972", "createdAt": "2020-09-28T13:10:00Z", "author": {"login": "YevhenBondarenko"}, "path": "common/transport/mqtt/src/main/java/org/thingsboard/server/transport/mqtt/MqttTransportHandler.java", "diffHunk": "@@ -136,10 +136,49 @@ private void processMqttMsg(ChannelHandlerContext ctx, MqttMessage msg) {\n             return;\n         }\n         deviceSessionCtx.setChannel(ctx);\n+        if (CONNECT.equals(msg.fixedHeader().messageType())) {\n+            processConnect(ctx, (MqttConnectMessage) msg);\n+        } else if (deviceSessionCtx.isProvisionOnly()) {\n+            processProvisionSessionMsg(ctx, msg);\n+        } else {\n+            processRegularSessionMsg(ctx, msg);\n+        }\n+    }\n+\n+    private void processProvisionSessionMsg(ChannelHandlerContext ctx, MqttMessage msg) {\n         switch (msg.fixedHeader().messageType()) {\n-            case CONNECT:\n-                processConnect(ctx, (MqttConnectMessage) msg);\n+            case PUBLISH:\n+                MqttPublishMessage mqttMsg = (MqttPublishMessage) msg;\n+                String topicName = mqttMsg.variableHeader().topicName();\n+                int msgId = mqttMsg.variableHeader().packetId();\n+                try {\n+                    if (topicName.equals(MqttTopics.DEVICE_PROVISION_REQUEST_TOPIC)) {\n+                        TransportProtos.ProvisionDeviceRequestMsg provisionRequestMsg = adaptor.convertToProvisionRequestMsg(deviceSessionCtx, mqttMsg);\n+                        transportService.process(provisionRequestMsg, new DeviceProvisionCallback(ctx, msgId, provisionRequestMsg));\n+                        log.trace(\"[{}][{}] Processing publish msg [{}][{}]!\", sessionId, deviceSessionCtx.getDeviceId(), topicName, msgId);\n+                    } else {\n+                        throw new RuntimeException(\"Unsupported topic for provisioning requests!\");\n+                    }\n+                } catch (RuntimeException | AdaptorException e) {\n+                    log.warn(\"[{}] Failed to process publish msg [{}][{}]\", sessionId, topicName, msgId, e);\n+                    ctx.close();\n+                }\n                 break;\n+            case PINGREQ:\n+                ctx.writeAndFlush(new MqttMessage(new MqttFixedHeader(PINGRESP, false, AT_MOST_ONCE, false, 0)));\n+                break;\n+//            case SUBSCRIBE:\n+//                deviceSessionCtx.setDeviceInfo(TransportDeviceInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b80fc6592bb207718ca601d9adf4e779d04ae542"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDU2OTU0OnYy", "diffSide": "RIGHT", "path": "common/transport/transport-api/src/main/java/org/thingsboard/server/common/transport/adaptor/JsonConverter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzoxNzo0MlrOHY9PFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzoxNzo0MlrOHY9PFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzMTE1Nw==", "bodyText": "Do not need to create DeviceId, new UUID(...).toString() will be enough.", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r495931157", "createdAt": "2020-09-28T13:17:42Z", "author": {"login": "YevhenBondarenko"}, "path": "common/transport/transport-api/src/main/java/org/thingsboard/server/common/transport/adaptor/JsonConverter.java", "diffHunk": "@@ -397,6 +399,34 @@ public static JsonElement toJson(TransportProtos.ToServerRpcResponseMsg msg) {\n         }\n     }\n \n+    public static JsonObject toJson(ProvisionDeviceResponseMsg payload) {\n+        return toJson(payload, false, 0);\n+    }\n+\n+    public static JsonObject toJson(ProvisionDeviceResponseMsg payload, int requestId) {\n+        return toJson(payload, true, requestId);\n+    }\n+\n+    private static JsonObject toJson(ProvisionDeviceResponseMsg payload, boolean toGateway, int requestId) {\n+        JsonObject result = new JsonObject();\n+        if (payload.getProvisionResponseStatus() == TransportProtos.ProvisionResponseStatus.NOT_FOUND) {\n+            result.addProperty(\"errorMsg\", \"Provision data was not found!\");\n+        } else if (payload.getProvisionResponseStatus() == TransportProtos.ProvisionResponseStatus.FAILURE) {\n+            result.addProperty(\"errorMsg\", \"Failed to provision device!\");\n+        } else {\n+            if (toGateway) {\n+                result.addProperty(\"id\", requestId);\n+            }\n+            result.addProperty(\"deviceId\", new DeviceId(\n+                    new UUID(payload.getDeviceCredentials().getDeviceIdMSB(), payload.getDeviceCredentials().getDeviceIdLSB())).toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b80fc6592bb207718ca601d9adf4e779d04ae542"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDU5OTI5OnYy", "diffSide": "RIGHT", "path": "dao/src/main/java/org/thingsboard/server/dao/sql/device/JpaDeviceProfileDao.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzoyNDoyMFrOHY9hVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzoyNDoyMFrOHY9hVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzNTgyOA==", "bodyText": "not used", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r495935828", "createdAt": "2020-09-28T13:24:20Z", "author": {"login": "YevhenBondarenko"}, "path": "dao/src/main/java/org/thingsboard/server/dao/sql/device/JpaDeviceProfileDao.java", "diffHunk": "@@ -29,6 +29,7 @@\n import org.thingsboard.server.dao.sql.JpaAbstractSearchTextDao;\n \n import java.util.Objects;\n+import java.util.Optional;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b80fc6592bb207718ca601d9adf4e779d04ae542"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDYwMDc3OnYy", "diffSide": "RIGHT", "path": "dao/src/main/java/org/thingsboard/server/dao/device/DeviceProfileDao.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzoyNDo0MVrOHY9iWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzoyNDo0MVrOHY9iWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzNjA4OQ==", "bodyText": "not used", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r495936089", "createdAt": "2020-09-28T13:24:41Z", "author": {"login": "YevhenBondarenko"}, "path": "dao/src/main/java/org/thingsboard/server/dao/device/DeviceProfileDao.java", "diffHunk": "@@ -22,6 +22,7 @@\n import org.thingsboard.server.common.data.page.PageLink;\n import org.thingsboard.server.dao.Dao;\n \n+import java.util.Optional;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b80fc6592bb207718ca601d9adf4e779d04ae542"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDY1MDYwOnYy", "diffSide": "RIGHT", "path": "common/dao-api/src/main/java/org/thingsboard/server/dao/device/provision/ProvisionResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzozNTozOFrOHY-AeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzozNTozOFrOHY-AeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk0MzgwMQ==", "bodyText": "You can add the final modifier to fields and remove the annotation @AllArgsConstructor. (@DaTa create a constructor with all final fields)", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r495943801", "createdAt": "2020-09-28T13:35:38Z", "author": {"login": "YevhenBondarenko"}, "path": "common/dao-api/src/main/java/org/thingsboard/server/dao/device/provision/ProvisionResponse.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright \u00a9 2016-2020 The Thingsboard Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.thingsboard.server.dao.device.provision;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import org.thingsboard.server.common.data.security.DeviceCredentials;\n+\n+@Data\n+@AllArgsConstructor\n+public class ProvisionResponse {\n+    private DeviceCredentials deviceCredentials;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b80fc6592bb207718ca601d9adf4e779d04ae542"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwODA0NzY1OnYy", "diffSide": "RIGHT", "path": "dao/src/main/java/org/thingsboard/server/dao/sql/device/DeviceProfileRepository.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNzoyODo1MlrOHZegZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNzoyODo1MlrOHZegZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ3NjI2Mg==", "bodyText": "if this query is slow, we should replace embedded json fields with separate columns in the device_profle table.", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r496476262", "createdAt": "2020-09-29T07:28:52Z", "author": {"login": "ashvayka"}, "path": "dao/src/main/java/org/thingsboard/server/dao/sql/device/DeviceProfileRepository.java", "diffHunk": "@@ -57,4 +56,14 @@\n \n     DeviceProfileEntity findByTenantIdAndName(UUID id, String profileName);\n \n+    @Query(value = \"SELECT d.* FROM device_profile as d \" +\n+            \"WHERE d.name = :profileName \" +\n+            \"AND d.profile_data->'configuration'->>'provisionDeviceKey' IS NOT NULL \" +\n+            \"AND d.profile_data->'configuration'->>'provisionDeviceSecret' IS NOT NULL \" +\n+            \"AND d.profile_data->'configuration'->>'provisionDeviceKey' = :provisionDeviceKey \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b80fc6592bb207718ca601d9adf4e779d04ae542"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNjI4ODc5OnYy", "diffSide": "RIGHT", "path": "ui-ngx/src/assets/locale/locale.constant-en_US.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwOTo0NzowMVrOHdrVTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwOTo0NzowMVrOHdrVTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg4MDcxNg==", "bodyText": "CRITICAL ERRROR! Please review your code before commits!", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r500880716", "createdAt": "2020-10-07T09:47:01Z", "author": {"login": "ashvayka"}, "path": "ui-ngx/src/assets/locale/locale.constant-en_US.json", "diffHunk": "@@ -846,6 +846,16 @@\n         \"alarm-rule-condition\": \"Alarm rule condition\",\n         \"enter-alarm-rule-condition-prompt\": \"Please add alarm rule condition\",\n         \"edit-alarm-rule-condition\": \"Edit alarm rule condition\",\n+        \"device-provisioning\": \"Device provisioning\",\n+        \"provision-strategy\": \"Provision strategy\",\n+        \"provision-strategy-required\": \"Provision strategy is required.\",\n+        \"provision-strategy-disabled\": \"Disabled\",\n+        \"provision-strategy-created-new\": \"Allow create new devices\",\n+        \"provision-strategy-check-pre-provisioned\": \"Check pre provisioned devices\",\n+        \"provision-device-key\": \"Provision device key\",\n+        \"provision-device-key-required\": \"Provision device key is required.\",\n+        \"provision-device-secret\": \"Provision device secret\",\n+        \"provision-device-secret-required\": \"Provision device secret is required.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4494f3dd67504a4e488869868ba3eade8bf087b7"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTUzNjgyOnYy", "diffSide": "RIGHT", "path": "application/src/main/java/org/thingsboard/server/service/device/DeviceProvisionServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwOTo1NDo0NVrOHfDGsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwOTo1NDo0NVrOHfDGsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMxODc2OA==", "bodyText": "Why you return Future if you don't have any async operations in the implementation?", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r502318768", "createdAt": "2020-10-09T09:54:45Z", "author": {"login": "ashvayka"}, "path": "application/src/main/java/org/thingsboard/server/service/device/DeviceProvisionServiceImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright \u00a9 2016-2020 The Thingsboard Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.thingsboard.server.service.device;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import lombok.extern.slf4j.Slf4j;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+import org.springframework.util.StringUtils;\n+import org.thingsboard.server.common.data.DataConstants;\n+import org.thingsboard.server.common.data.Device;\n+import org.thingsboard.server.common.data.DeviceProfile;\n+import org.thingsboard.server.common.data.audit.ActionType;\n+import org.thingsboard.server.common.data.device.credentials.BasicMqttCredentials;\n+import org.thingsboard.server.common.data.device.profile.AllowCreateNewDevicesDeviceProfileProvisionConfiguration;\n+import org.thingsboard.server.common.data.device.profile.CheckPreProvisionedDevicesDeviceProfileProvisionConfiguration;\n+import org.thingsboard.server.common.data.id.CustomerId;\n+import org.thingsboard.server.common.data.id.TenantId;\n+import org.thingsboard.server.common.data.id.UserId;\n+import org.thingsboard.server.common.data.kv.AttributeKvEntry;\n+import org.thingsboard.server.common.data.kv.BaseAttributeKvEntry;\n+import org.thingsboard.server.common.data.kv.StringDataEntry;\n+import org.thingsboard.server.common.data.security.DeviceCredentials;\n+import org.thingsboard.server.common.msg.TbMsg;\n+import org.thingsboard.server.common.msg.TbMsgMetaData;\n+import org.thingsboard.server.common.msg.queue.ServiceType;\n+import org.thingsboard.server.common.msg.queue.TopicPartitionInfo;\n+import org.thingsboard.server.dao.attributes.AttributesService;\n+import org.thingsboard.server.dao.audit.AuditLogService;\n+import org.thingsboard.server.dao.device.DeviceCredentialsService;\n+import org.thingsboard.server.dao.device.DeviceDao;\n+import org.thingsboard.server.dao.device.DeviceProfileDao;\n+import org.thingsboard.server.dao.device.DeviceProvisionService;\n+import org.thingsboard.server.dao.device.DeviceService;\n+import org.thingsboard.server.dao.device.provision.ProvisionRequest;\n+import org.thingsboard.server.dao.device.provision.ProvisionResponse;\n+import org.thingsboard.server.dao.device.provision.ProvisionResponseStatus;\n+import org.thingsboard.server.dao.util.mapping.JacksonUtil;\n+import org.thingsboard.server.gen.transport.TransportProtos;\n+import org.thingsboard.server.gen.transport.TransportProtos.ToRuleEngineMsg;\n+import org.thingsboard.server.queue.TbQueueCallback;\n+import org.thingsboard.server.queue.TbQueueProducer;\n+import org.thingsboard.server.queue.common.TbProtoQueueMsg;\n+import org.thingsboard.server.queue.discovery.PartitionService;\n+import org.thingsboard.server.queue.provider.TbQueueProducerProvider;\n+import org.thingsboard.server.queue.util.TbCoreComponent;\n+import org.thingsboard.server.service.state.DeviceStateService;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+\n+@Service\n+@Slf4j\n+@TbCoreComponent\n+public class DeviceProvisionServiceImpl implements DeviceProvisionService {\n+\n+    protected TbQueueProducer<TbProtoQueueMsg<ToRuleEngineMsg>> ruleEngineMsgProducer;\n+\n+    private static final String DEVICE_PROVISION_STATE = \"provisionState\";\n+    private static final String PROVISIONED_STATE = \"provisioned\";\n+\n+    private final ReentrantLock deviceCreationLock = new ReentrantLock();\n+\n+    @Autowired\n+    DeviceDao deviceDao;\n+\n+    @Autowired\n+    DeviceProfileDao deviceProfileDao;\n+\n+    @Autowired\n+    DeviceService deviceService;\n+\n+    @Autowired\n+    DeviceCredentialsService deviceCredentialsService;\n+\n+    @Autowired\n+    AttributesService attributesService;\n+\n+    @Autowired\n+    DeviceStateService deviceStateService;\n+\n+    @Autowired\n+    AuditLogService auditLogService;\n+\n+    @Autowired\n+    PartitionService partitionService;\n+\n+    public DeviceProvisionServiceImpl(TbQueueProducerProvider producerProvider) {\n+        ruleEngineMsgProducer = producerProvider.getRuleEngineMsgProducer();\n+    }\n+\n+    @Override\n+    public ListenableFuture<ProvisionResponse> provisionDevice(ProvisionRequest provisionRequest) {\n+        String provisionRequestKey = provisionRequest.getCredentials().getProvisionDeviceKey();\n+        String provisionRequestSecret = provisionRequest.getCredentials().getProvisionDeviceSecret();\n+\n+        if (StringUtils.isEmpty(provisionRequestKey) || StringUtils.isEmpty(provisionRequestSecret)) {\n+            return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+        }\n+\n+        if (provisionRequest.getCredentialsType() != null) {\n+            ListenableFuture<ProvisionResponse> error = validateCredentials(provisionRequest);\n+            if (error != null) {\n+                return error;\n+            }\n+        }\n+\n+        DeviceProfile targetProfile = deviceProfileDao.findByProvisionDeviceKey(provisionRequestKey);\n+\n+        if (targetProfile == null) {\n+            return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+        }\n+\n+        Device targetDevice = deviceDao.findDeviceByTenantIdAndName(targetProfile.getTenantId().getId(), provisionRequest.getDeviceName()).orElse(null);\n+\n+        switch (targetProfile.getProvisionType()) {\n+            case ALLOW_CREATE_NEW_DEVICES:\n+                if (((AllowCreateNewDevicesDeviceProfileProvisionConfiguration) targetProfile.getProfileData().getProvisionConfiguration()).getProvisionDeviceSecret().equals(provisionRequestSecret)) {\n+                    if (targetDevice != null) {\n+                        log.warn(\"[{}] The device is present and could not be provisioned once more!\", targetDevice.getName());\n+                        notify(targetDevice, provisionRequest, DataConstants.PROVISION_FAILURE, false);\n+                        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                    } else {\n+                        return createDevice(provisionRequest, targetProfile);\n+                    }\n+                }\n+                break;\n+            case CHECK_PRE_PROVISIONED_DEVICES:\n+                if (((CheckPreProvisionedDevicesDeviceProfileProvisionConfiguration) targetProfile.getProfileData().getProvisionConfiguration()).getProvisionDeviceSecret().equals(provisionRequestSecret)) {\n+                    if (targetDevice != null && targetDevice.getDeviceProfileId().equals(targetProfile.getId())) {\n+                        return processProvision(targetDevice, provisionRequest);\n+                    } else {\n+                        log.warn(\"[{}] Failed to find pre provisioned device!\", provisionRequest.getDeviceName());\n+                        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                    }\n+                }\n+                break;\n+        }\n+        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> validateCredentials(ProvisionRequest provisionRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6683158c6b262ed930db41c3ced73efec94320aa"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTU1NzQ0OnYy", "diffSide": "RIGHT", "path": "application/src/main/java/org/thingsboard/server/service/device/DeviceProvisionServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowMDozOFrOHfDTfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowMDozOFrOHfDTfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyMjA0Ng==", "bodyText": "Make new method \"getProvisionConfiguration\" in ProvisionConfiguration interface and avoid all this casts.", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r502322046", "createdAt": "2020-10-09T10:00:38Z", "author": {"login": "ashvayka"}, "path": "application/src/main/java/org/thingsboard/server/service/device/DeviceProvisionServiceImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright \u00a9 2016-2020 The Thingsboard Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.thingsboard.server.service.device;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import lombok.extern.slf4j.Slf4j;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+import org.springframework.util.StringUtils;\n+import org.thingsboard.server.common.data.DataConstants;\n+import org.thingsboard.server.common.data.Device;\n+import org.thingsboard.server.common.data.DeviceProfile;\n+import org.thingsboard.server.common.data.audit.ActionType;\n+import org.thingsboard.server.common.data.device.credentials.BasicMqttCredentials;\n+import org.thingsboard.server.common.data.device.profile.AllowCreateNewDevicesDeviceProfileProvisionConfiguration;\n+import org.thingsboard.server.common.data.device.profile.CheckPreProvisionedDevicesDeviceProfileProvisionConfiguration;\n+import org.thingsboard.server.common.data.id.CustomerId;\n+import org.thingsboard.server.common.data.id.TenantId;\n+import org.thingsboard.server.common.data.id.UserId;\n+import org.thingsboard.server.common.data.kv.AttributeKvEntry;\n+import org.thingsboard.server.common.data.kv.BaseAttributeKvEntry;\n+import org.thingsboard.server.common.data.kv.StringDataEntry;\n+import org.thingsboard.server.common.data.security.DeviceCredentials;\n+import org.thingsboard.server.common.msg.TbMsg;\n+import org.thingsboard.server.common.msg.TbMsgMetaData;\n+import org.thingsboard.server.common.msg.queue.ServiceType;\n+import org.thingsboard.server.common.msg.queue.TopicPartitionInfo;\n+import org.thingsboard.server.dao.attributes.AttributesService;\n+import org.thingsboard.server.dao.audit.AuditLogService;\n+import org.thingsboard.server.dao.device.DeviceCredentialsService;\n+import org.thingsboard.server.dao.device.DeviceDao;\n+import org.thingsboard.server.dao.device.DeviceProfileDao;\n+import org.thingsboard.server.dao.device.DeviceProvisionService;\n+import org.thingsboard.server.dao.device.DeviceService;\n+import org.thingsboard.server.dao.device.provision.ProvisionRequest;\n+import org.thingsboard.server.dao.device.provision.ProvisionResponse;\n+import org.thingsboard.server.dao.device.provision.ProvisionResponseStatus;\n+import org.thingsboard.server.dao.util.mapping.JacksonUtil;\n+import org.thingsboard.server.gen.transport.TransportProtos;\n+import org.thingsboard.server.gen.transport.TransportProtos.ToRuleEngineMsg;\n+import org.thingsboard.server.queue.TbQueueCallback;\n+import org.thingsboard.server.queue.TbQueueProducer;\n+import org.thingsboard.server.queue.common.TbProtoQueueMsg;\n+import org.thingsboard.server.queue.discovery.PartitionService;\n+import org.thingsboard.server.queue.provider.TbQueueProducerProvider;\n+import org.thingsboard.server.queue.util.TbCoreComponent;\n+import org.thingsboard.server.service.state.DeviceStateService;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+\n+@Service\n+@Slf4j\n+@TbCoreComponent\n+public class DeviceProvisionServiceImpl implements DeviceProvisionService {\n+\n+    protected TbQueueProducer<TbProtoQueueMsg<ToRuleEngineMsg>> ruleEngineMsgProducer;\n+\n+    private static final String DEVICE_PROVISION_STATE = \"provisionState\";\n+    private static final String PROVISIONED_STATE = \"provisioned\";\n+\n+    private final ReentrantLock deviceCreationLock = new ReentrantLock();\n+\n+    @Autowired\n+    DeviceDao deviceDao;\n+\n+    @Autowired\n+    DeviceProfileDao deviceProfileDao;\n+\n+    @Autowired\n+    DeviceService deviceService;\n+\n+    @Autowired\n+    DeviceCredentialsService deviceCredentialsService;\n+\n+    @Autowired\n+    AttributesService attributesService;\n+\n+    @Autowired\n+    DeviceStateService deviceStateService;\n+\n+    @Autowired\n+    AuditLogService auditLogService;\n+\n+    @Autowired\n+    PartitionService partitionService;\n+\n+    public DeviceProvisionServiceImpl(TbQueueProducerProvider producerProvider) {\n+        ruleEngineMsgProducer = producerProvider.getRuleEngineMsgProducer();\n+    }\n+\n+    @Override\n+    public ListenableFuture<ProvisionResponse> provisionDevice(ProvisionRequest provisionRequest) {\n+        String provisionRequestKey = provisionRequest.getCredentials().getProvisionDeviceKey();\n+        String provisionRequestSecret = provisionRequest.getCredentials().getProvisionDeviceSecret();\n+\n+        if (StringUtils.isEmpty(provisionRequestKey) || StringUtils.isEmpty(provisionRequestSecret)) {\n+            return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+        }\n+\n+        if (provisionRequest.getCredentialsType() != null) {\n+            ListenableFuture<ProvisionResponse> error = validateCredentials(provisionRequest);\n+            if (error != null) {\n+                return error;\n+            }\n+        }\n+\n+        DeviceProfile targetProfile = deviceProfileDao.findByProvisionDeviceKey(provisionRequestKey);\n+\n+        if (targetProfile == null) {\n+            return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+        }\n+\n+        Device targetDevice = deviceDao.findDeviceByTenantIdAndName(targetProfile.getTenantId().getId(), provisionRequest.getDeviceName()).orElse(null);\n+\n+        switch (targetProfile.getProvisionType()) {\n+            case ALLOW_CREATE_NEW_DEVICES:\n+                if (((AllowCreateNewDevicesDeviceProfileProvisionConfiguration) targetProfile.getProfileData().getProvisionConfiguration()).getProvisionDeviceSecret().equals(provisionRequestSecret)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6683158c6b262ed930db41c3ced73efec94320aa"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTU2Mjk1OnYy", "diffSide": "RIGHT", "path": "application/src/main/java/org/thingsboard/server/service/device/DeviceProvisionServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowMjoyM1rOHfDW6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowMjoyM1rOHfDW6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyMjkyMw==", "bodyText": "}else{\n..\n}", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r502322923", "createdAt": "2020-10-09T10:02:23Z", "author": {"login": "ashvayka"}, "path": "application/src/main/java/org/thingsboard/server/service/device/DeviceProvisionServiceImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright \u00a9 2016-2020 The Thingsboard Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.thingsboard.server.service.device;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import lombok.extern.slf4j.Slf4j;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+import org.springframework.util.StringUtils;\n+import org.thingsboard.server.common.data.DataConstants;\n+import org.thingsboard.server.common.data.Device;\n+import org.thingsboard.server.common.data.DeviceProfile;\n+import org.thingsboard.server.common.data.audit.ActionType;\n+import org.thingsboard.server.common.data.device.credentials.BasicMqttCredentials;\n+import org.thingsboard.server.common.data.device.profile.AllowCreateNewDevicesDeviceProfileProvisionConfiguration;\n+import org.thingsboard.server.common.data.device.profile.CheckPreProvisionedDevicesDeviceProfileProvisionConfiguration;\n+import org.thingsboard.server.common.data.id.CustomerId;\n+import org.thingsboard.server.common.data.id.TenantId;\n+import org.thingsboard.server.common.data.id.UserId;\n+import org.thingsboard.server.common.data.kv.AttributeKvEntry;\n+import org.thingsboard.server.common.data.kv.BaseAttributeKvEntry;\n+import org.thingsboard.server.common.data.kv.StringDataEntry;\n+import org.thingsboard.server.common.data.security.DeviceCredentials;\n+import org.thingsboard.server.common.msg.TbMsg;\n+import org.thingsboard.server.common.msg.TbMsgMetaData;\n+import org.thingsboard.server.common.msg.queue.ServiceType;\n+import org.thingsboard.server.common.msg.queue.TopicPartitionInfo;\n+import org.thingsboard.server.dao.attributes.AttributesService;\n+import org.thingsboard.server.dao.audit.AuditLogService;\n+import org.thingsboard.server.dao.device.DeviceCredentialsService;\n+import org.thingsboard.server.dao.device.DeviceDao;\n+import org.thingsboard.server.dao.device.DeviceProfileDao;\n+import org.thingsboard.server.dao.device.DeviceProvisionService;\n+import org.thingsboard.server.dao.device.DeviceService;\n+import org.thingsboard.server.dao.device.provision.ProvisionRequest;\n+import org.thingsboard.server.dao.device.provision.ProvisionResponse;\n+import org.thingsboard.server.dao.device.provision.ProvisionResponseStatus;\n+import org.thingsboard.server.dao.util.mapping.JacksonUtil;\n+import org.thingsboard.server.gen.transport.TransportProtos;\n+import org.thingsboard.server.gen.transport.TransportProtos.ToRuleEngineMsg;\n+import org.thingsboard.server.queue.TbQueueCallback;\n+import org.thingsboard.server.queue.TbQueueProducer;\n+import org.thingsboard.server.queue.common.TbProtoQueueMsg;\n+import org.thingsboard.server.queue.discovery.PartitionService;\n+import org.thingsboard.server.queue.provider.TbQueueProducerProvider;\n+import org.thingsboard.server.queue.util.TbCoreComponent;\n+import org.thingsboard.server.service.state.DeviceStateService;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+\n+@Service\n+@Slf4j\n+@TbCoreComponent\n+public class DeviceProvisionServiceImpl implements DeviceProvisionService {\n+\n+    protected TbQueueProducer<TbProtoQueueMsg<ToRuleEngineMsg>> ruleEngineMsgProducer;\n+\n+    private static final String DEVICE_PROVISION_STATE = \"provisionState\";\n+    private static final String PROVISIONED_STATE = \"provisioned\";\n+\n+    private final ReentrantLock deviceCreationLock = new ReentrantLock();\n+\n+    @Autowired\n+    DeviceDao deviceDao;\n+\n+    @Autowired\n+    DeviceProfileDao deviceProfileDao;\n+\n+    @Autowired\n+    DeviceService deviceService;\n+\n+    @Autowired\n+    DeviceCredentialsService deviceCredentialsService;\n+\n+    @Autowired\n+    AttributesService attributesService;\n+\n+    @Autowired\n+    DeviceStateService deviceStateService;\n+\n+    @Autowired\n+    AuditLogService auditLogService;\n+\n+    @Autowired\n+    PartitionService partitionService;\n+\n+    public DeviceProvisionServiceImpl(TbQueueProducerProvider producerProvider) {\n+        ruleEngineMsgProducer = producerProvider.getRuleEngineMsgProducer();\n+    }\n+\n+    @Override\n+    public ListenableFuture<ProvisionResponse> provisionDevice(ProvisionRequest provisionRequest) {\n+        String provisionRequestKey = provisionRequest.getCredentials().getProvisionDeviceKey();\n+        String provisionRequestSecret = provisionRequest.getCredentials().getProvisionDeviceSecret();\n+\n+        if (StringUtils.isEmpty(provisionRequestKey) || StringUtils.isEmpty(provisionRequestSecret)) {\n+            return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+        }\n+\n+        if (provisionRequest.getCredentialsType() != null) {\n+            ListenableFuture<ProvisionResponse> error = validateCredentials(provisionRequest);\n+            if (error != null) {\n+                return error;\n+            }\n+        }\n+\n+        DeviceProfile targetProfile = deviceProfileDao.findByProvisionDeviceKey(provisionRequestKey);\n+\n+        if (targetProfile == null) {\n+            return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+        }\n+\n+        Device targetDevice = deviceDao.findDeviceByTenantIdAndName(targetProfile.getTenantId().getId(), provisionRequest.getDeviceName()).orElse(null);\n+\n+        switch (targetProfile.getProvisionType()) {\n+            case ALLOW_CREATE_NEW_DEVICES:\n+                if (((AllowCreateNewDevicesDeviceProfileProvisionConfiguration) targetProfile.getProfileData().getProvisionConfiguration()).getProvisionDeviceSecret().equals(provisionRequestSecret)) {\n+                    if (targetDevice != null) {\n+                        log.warn(\"[{}] The device is present and could not be provisioned once more!\", targetDevice.getName());\n+                        notify(targetDevice, provisionRequest, DataConstants.PROVISION_FAILURE, false);\n+                        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                    } else {\n+                        return createDevice(provisionRequest, targetProfile);\n+                    }\n+                }\n+                break;\n+            case CHECK_PRE_PROVISIONED_DEVICES:\n+                if (((CheckPreProvisionedDevicesDeviceProfileProvisionConfiguration) targetProfile.getProfileData().getProvisionConfiguration()).getProvisionDeviceSecret().equals(provisionRequestSecret)) {\n+                    if (targetDevice != null && targetDevice.getDeviceProfileId().equals(targetProfile.getId())) {\n+                        return processProvision(targetDevice, provisionRequest);\n+                    } else {\n+                        log.warn(\"[{}] Failed to find pre provisioned device!\", provisionRequest.getDeviceName());\n+                        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                    }\n+                }\n+                break;\n+        }\n+        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> validateCredentials(ProvisionRequest provisionRequest) {\n+        switch (provisionRequest.getCredentialsType()) {\n+            case MQTT_BASIC:\n+                if (StringUtils.isEmpty(provisionRequest.getCredentialsData().getClientId()) ||\n+                        StringUtils.isEmpty(provisionRequest.getCredentialsData().getUsername()) ||\n+                        StringUtils.isEmpty(provisionRequest.getCredentialsData().getPassword())) {\n+                    log.error(\"Failed to get basic mqtt credentials from credentials data!\");\n+                    return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                }\n+                break;\n+            case X509_CERTIFICATE:\n+                if (StringUtils.isEmpty(provisionRequest.getCredentialsData().getHash())) {\n+                    log.error(\"Failed to get hash from credentials data!\");\n+                    return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                }\n+                break;\n+        }\n+        return null;\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> processProvision(Device device, ProvisionRequest provisionRequest) {\n+        ListenableFuture<Optional<AttributeKvEntry>> provisionStateFuture = attributesService.find(device.getTenantId(), device.getId(),\n+                DataConstants.SERVER_SCOPE, DEVICE_PROVISION_STATE);\n+        ListenableFuture<Boolean> provisionedFuture = Futures.transformAsync(provisionStateFuture, optionalAtr -> {\n+            if (optionalAtr.isPresent()) {\n+                String state = optionalAtr.get().getValueAsString();\n+                if (state.equals(PROVISIONED_STATE)) {\n+                    return Futures.immediateFuture(true);\n+                } else {\n+                    log.error(\"[{}][{}] Unknown provision state: {}!\", device.getName(), DEVICE_PROVISION_STATE, state);\n+                    return Futures.immediateCancelledFuture();\n+                }\n+            }\n+            return Futures.transform(saveProvisionStateAttribute(device), input -> false, MoreExecutors.directExecutor());\n+        }, MoreExecutors.directExecutor());\n+        if (provisionedFuture.isCancelled()) {\n+            throw new RuntimeException(\"Unknown provision state!\");\n+        }\n+        return Futures.transform(provisionedFuture, provisioned -> {\n+            if (provisioned) {\n+                notify(device, provisionRequest, DataConstants.PROVISION_FAILURE, false);\n+                return new ProvisionResponse(null, ProvisionResponseStatus.FAILURE);\n+            }\n+            notify(device, provisionRequest, DataConstants.PROVISION_SUCCESS, true);\n+            return new ProvisionResponse(deviceCredentialsService.findDeviceCredentialsByDeviceId(device.getTenantId(), device.getId()), ProvisionResponseStatus.SUCCESS);\n+        }, MoreExecutors.directExecutor());\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> createDevice(ProvisionRequest provisionRequest, DeviceProfile profile) {\n+        deviceCreationLock.lock();\n+        try {\n+            return processCreateDevice(provisionRequest, profile);\n+        } finally {\n+            deviceCreationLock.unlock();\n+        }\n+    }\n+\n+    private void notify(Device device, ProvisionRequest provisionRequest, String type, boolean success) {\n+        pushProvisionEventToRuleEngine(provisionRequest, device, type);\n+        logAction(device.getTenantId(), device.getCustomerId(), device, success, provisionRequest);\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> processCreateDevice(ProvisionRequest provisionRequest, DeviceProfile profile) {\n+        Device device = deviceService.findDeviceByTenantIdAndName(profile.getTenantId(), provisionRequest.getDeviceName());\n+        if (device == null) {\n+            Device savedDevice = saveDevice(provisionRequest, profile);\n+\n+            deviceStateService.onDeviceAdded(savedDevice);\n+            pushDeviceCreatedEventToRuleEngine(savedDevice);\n+            notify(savedDevice, provisionRequest, DataConstants.PROVISION_SUCCESS, true);\n+\n+            return Futures.transform(saveProvisionStateAttribute(savedDevice), input ->\n+                    new ProvisionResponse(\n+                            getDeviceCredentials(savedDevice),\n+                            ProvisionResponseStatus.SUCCESS), MoreExecutors.directExecutor());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6683158c6b262ed930db41c3ced73efec94320aa"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTU2NjQ0OnYy", "diffSide": "RIGHT", "path": "application/src/main/java/org/thingsboard/server/service/device/DeviceProvisionServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowMzoyNlrOHfDZJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowMzoyNlrOHfDZJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyMzQ5Mg==", "bodyText": "Where is ACCESS_TOKEN case?", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r502323492", "createdAt": "2020-10-09T10:03:26Z", "author": {"login": "ashvayka"}, "path": "application/src/main/java/org/thingsboard/server/service/device/DeviceProvisionServiceImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright \u00a9 2016-2020 The Thingsboard Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.thingsboard.server.service.device;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import lombok.extern.slf4j.Slf4j;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+import org.springframework.util.StringUtils;\n+import org.thingsboard.server.common.data.DataConstants;\n+import org.thingsboard.server.common.data.Device;\n+import org.thingsboard.server.common.data.DeviceProfile;\n+import org.thingsboard.server.common.data.audit.ActionType;\n+import org.thingsboard.server.common.data.device.credentials.BasicMqttCredentials;\n+import org.thingsboard.server.common.data.device.profile.AllowCreateNewDevicesDeviceProfileProvisionConfiguration;\n+import org.thingsboard.server.common.data.device.profile.CheckPreProvisionedDevicesDeviceProfileProvisionConfiguration;\n+import org.thingsboard.server.common.data.id.CustomerId;\n+import org.thingsboard.server.common.data.id.TenantId;\n+import org.thingsboard.server.common.data.id.UserId;\n+import org.thingsboard.server.common.data.kv.AttributeKvEntry;\n+import org.thingsboard.server.common.data.kv.BaseAttributeKvEntry;\n+import org.thingsboard.server.common.data.kv.StringDataEntry;\n+import org.thingsboard.server.common.data.security.DeviceCredentials;\n+import org.thingsboard.server.common.msg.TbMsg;\n+import org.thingsboard.server.common.msg.TbMsgMetaData;\n+import org.thingsboard.server.common.msg.queue.ServiceType;\n+import org.thingsboard.server.common.msg.queue.TopicPartitionInfo;\n+import org.thingsboard.server.dao.attributes.AttributesService;\n+import org.thingsboard.server.dao.audit.AuditLogService;\n+import org.thingsboard.server.dao.device.DeviceCredentialsService;\n+import org.thingsboard.server.dao.device.DeviceDao;\n+import org.thingsboard.server.dao.device.DeviceProfileDao;\n+import org.thingsboard.server.dao.device.DeviceProvisionService;\n+import org.thingsboard.server.dao.device.DeviceService;\n+import org.thingsboard.server.dao.device.provision.ProvisionRequest;\n+import org.thingsboard.server.dao.device.provision.ProvisionResponse;\n+import org.thingsboard.server.dao.device.provision.ProvisionResponseStatus;\n+import org.thingsboard.server.dao.util.mapping.JacksonUtil;\n+import org.thingsboard.server.gen.transport.TransportProtos;\n+import org.thingsboard.server.gen.transport.TransportProtos.ToRuleEngineMsg;\n+import org.thingsboard.server.queue.TbQueueCallback;\n+import org.thingsboard.server.queue.TbQueueProducer;\n+import org.thingsboard.server.queue.common.TbProtoQueueMsg;\n+import org.thingsboard.server.queue.discovery.PartitionService;\n+import org.thingsboard.server.queue.provider.TbQueueProducerProvider;\n+import org.thingsboard.server.queue.util.TbCoreComponent;\n+import org.thingsboard.server.service.state.DeviceStateService;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+\n+@Service\n+@Slf4j\n+@TbCoreComponent\n+public class DeviceProvisionServiceImpl implements DeviceProvisionService {\n+\n+    protected TbQueueProducer<TbProtoQueueMsg<ToRuleEngineMsg>> ruleEngineMsgProducer;\n+\n+    private static final String DEVICE_PROVISION_STATE = \"provisionState\";\n+    private static final String PROVISIONED_STATE = \"provisioned\";\n+\n+    private final ReentrantLock deviceCreationLock = new ReentrantLock();\n+\n+    @Autowired\n+    DeviceDao deviceDao;\n+\n+    @Autowired\n+    DeviceProfileDao deviceProfileDao;\n+\n+    @Autowired\n+    DeviceService deviceService;\n+\n+    @Autowired\n+    DeviceCredentialsService deviceCredentialsService;\n+\n+    @Autowired\n+    AttributesService attributesService;\n+\n+    @Autowired\n+    DeviceStateService deviceStateService;\n+\n+    @Autowired\n+    AuditLogService auditLogService;\n+\n+    @Autowired\n+    PartitionService partitionService;\n+\n+    public DeviceProvisionServiceImpl(TbQueueProducerProvider producerProvider) {\n+        ruleEngineMsgProducer = producerProvider.getRuleEngineMsgProducer();\n+    }\n+\n+    @Override\n+    public ListenableFuture<ProvisionResponse> provisionDevice(ProvisionRequest provisionRequest) {\n+        String provisionRequestKey = provisionRequest.getCredentials().getProvisionDeviceKey();\n+        String provisionRequestSecret = provisionRequest.getCredentials().getProvisionDeviceSecret();\n+\n+        if (StringUtils.isEmpty(provisionRequestKey) || StringUtils.isEmpty(provisionRequestSecret)) {\n+            return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+        }\n+\n+        if (provisionRequest.getCredentialsType() != null) {\n+            ListenableFuture<ProvisionResponse> error = validateCredentials(provisionRequest);\n+            if (error != null) {\n+                return error;\n+            }\n+        }\n+\n+        DeviceProfile targetProfile = deviceProfileDao.findByProvisionDeviceKey(provisionRequestKey);\n+\n+        if (targetProfile == null) {\n+            return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+        }\n+\n+        Device targetDevice = deviceDao.findDeviceByTenantIdAndName(targetProfile.getTenantId().getId(), provisionRequest.getDeviceName()).orElse(null);\n+\n+        switch (targetProfile.getProvisionType()) {\n+            case ALLOW_CREATE_NEW_DEVICES:\n+                if (((AllowCreateNewDevicesDeviceProfileProvisionConfiguration) targetProfile.getProfileData().getProvisionConfiguration()).getProvisionDeviceSecret().equals(provisionRequestSecret)) {\n+                    if (targetDevice != null) {\n+                        log.warn(\"[{}] The device is present and could not be provisioned once more!\", targetDevice.getName());\n+                        notify(targetDevice, provisionRequest, DataConstants.PROVISION_FAILURE, false);\n+                        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                    } else {\n+                        return createDevice(provisionRequest, targetProfile);\n+                    }\n+                }\n+                break;\n+            case CHECK_PRE_PROVISIONED_DEVICES:\n+                if (((CheckPreProvisionedDevicesDeviceProfileProvisionConfiguration) targetProfile.getProfileData().getProvisionConfiguration()).getProvisionDeviceSecret().equals(provisionRequestSecret)) {\n+                    if (targetDevice != null && targetDevice.getDeviceProfileId().equals(targetProfile.getId())) {\n+                        return processProvision(targetDevice, provisionRequest);\n+                    } else {\n+                        log.warn(\"[{}] Failed to find pre provisioned device!\", provisionRequest.getDeviceName());\n+                        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                    }\n+                }\n+                break;\n+        }\n+        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> validateCredentials(ProvisionRequest provisionRequest) {\n+        switch (provisionRequest.getCredentialsType()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6683158c6b262ed930db41c3ced73efec94320aa"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTU2ODM5OnYy", "diffSide": "RIGHT", "path": "application/src/main/java/org/thingsboard/server/service/device/DeviceProvisionServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowNDoxMFrOHfDakw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowNDoxMFrOHfDakw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyMzg1OQ==", "bodyText": "There is a method \"valueToTree\" in the JacksonUtil", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r502323859", "createdAt": "2020-10-09T10:04:10Z", "author": {"login": "ashvayka"}, "path": "application/src/main/java/org/thingsboard/server/service/device/DeviceProvisionServiceImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright \u00a9 2016-2020 The Thingsboard Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.thingsboard.server.service.device;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import lombok.extern.slf4j.Slf4j;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+import org.springframework.util.StringUtils;\n+import org.thingsboard.server.common.data.DataConstants;\n+import org.thingsboard.server.common.data.Device;\n+import org.thingsboard.server.common.data.DeviceProfile;\n+import org.thingsboard.server.common.data.audit.ActionType;\n+import org.thingsboard.server.common.data.device.credentials.BasicMqttCredentials;\n+import org.thingsboard.server.common.data.device.profile.AllowCreateNewDevicesDeviceProfileProvisionConfiguration;\n+import org.thingsboard.server.common.data.device.profile.CheckPreProvisionedDevicesDeviceProfileProvisionConfiguration;\n+import org.thingsboard.server.common.data.id.CustomerId;\n+import org.thingsboard.server.common.data.id.TenantId;\n+import org.thingsboard.server.common.data.id.UserId;\n+import org.thingsboard.server.common.data.kv.AttributeKvEntry;\n+import org.thingsboard.server.common.data.kv.BaseAttributeKvEntry;\n+import org.thingsboard.server.common.data.kv.StringDataEntry;\n+import org.thingsboard.server.common.data.security.DeviceCredentials;\n+import org.thingsboard.server.common.msg.TbMsg;\n+import org.thingsboard.server.common.msg.TbMsgMetaData;\n+import org.thingsboard.server.common.msg.queue.ServiceType;\n+import org.thingsboard.server.common.msg.queue.TopicPartitionInfo;\n+import org.thingsboard.server.dao.attributes.AttributesService;\n+import org.thingsboard.server.dao.audit.AuditLogService;\n+import org.thingsboard.server.dao.device.DeviceCredentialsService;\n+import org.thingsboard.server.dao.device.DeviceDao;\n+import org.thingsboard.server.dao.device.DeviceProfileDao;\n+import org.thingsboard.server.dao.device.DeviceProvisionService;\n+import org.thingsboard.server.dao.device.DeviceService;\n+import org.thingsboard.server.dao.device.provision.ProvisionRequest;\n+import org.thingsboard.server.dao.device.provision.ProvisionResponse;\n+import org.thingsboard.server.dao.device.provision.ProvisionResponseStatus;\n+import org.thingsboard.server.dao.util.mapping.JacksonUtil;\n+import org.thingsboard.server.gen.transport.TransportProtos;\n+import org.thingsboard.server.gen.transport.TransportProtos.ToRuleEngineMsg;\n+import org.thingsboard.server.queue.TbQueueCallback;\n+import org.thingsboard.server.queue.TbQueueProducer;\n+import org.thingsboard.server.queue.common.TbProtoQueueMsg;\n+import org.thingsboard.server.queue.discovery.PartitionService;\n+import org.thingsboard.server.queue.provider.TbQueueProducerProvider;\n+import org.thingsboard.server.queue.util.TbCoreComponent;\n+import org.thingsboard.server.service.state.DeviceStateService;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+\n+@Service\n+@Slf4j\n+@TbCoreComponent\n+public class DeviceProvisionServiceImpl implements DeviceProvisionService {\n+\n+    protected TbQueueProducer<TbProtoQueueMsg<ToRuleEngineMsg>> ruleEngineMsgProducer;\n+\n+    private static final String DEVICE_PROVISION_STATE = \"provisionState\";\n+    private static final String PROVISIONED_STATE = \"provisioned\";\n+\n+    private final ReentrantLock deviceCreationLock = new ReentrantLock();\n+\n+    @Autowired\n+    DeviceDao deviceDao;\n+\n+    @Autowired\n+    DeviceProfileDao deviceProfileDao;\n+\n+    @Autowired\n+    DeviceService deviceService;\n+\n+    @Autowired\n+    DeviceCredentialsService deviceCredentialsService;\n+\n+    @Autowired\n+    AttributesService attributesService;\n+\n+    @Autowired\n+    DeviceStateService deviceStateService;\n+\n+    @Autowired\n+    AuditLogService auditLogService;\n+\n+    @Autowired\n+    PartitionService partitionService;\n+\n+    public DeviceProvisionServiceImpl(TbQueueProducerProvider producerProvider) {\n+        ruleEngineMsgProducer = producerProvider.getRuleEngineMsgProducer();\n+    }\n+\n+    @Override\n+    public ListenableFuture<ProvisionResponse> provisionDevice(ProvisionRequest provisionRequest) {\n+        String provisionRequestKey = provisionRequest.getCredentials().getProvisionDeviceKey();\n+        String provisionRequestSecret = provisionRequest.getCredentials().getProvisionDeviceSecret();\n+\n+        if (StringUtils.isEmpty(provisionRequestKey) || StringUtils.isEmpty(provisionRequestSecret)) {\n+            return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+        }\n+\n+        if (provisionRequest.getCredentialsType() != null) {\n+            ListenableFuture<ProvisionResponse> error = validateCredentials(provisionRequest);\n+            if (error != null) {\n+                return error;\n+            }\n+        }\n+\n+        DeviceProfile targetProfile = deviceProfileDao.findByProvisionDeviceKey(provisionRequestKey);\n+\n+        if (targetProfile == null) {\n+            return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+        }\n+\n+        Device targetDevice = deviceDao.findDeviceByTenantIdAndName(targetProfile.getTenantId().getId(), provisionRequest.getDeviceName()).orElse(null);\n+\n+        switch (targetProfile.getProvisionType()) {\n+            case ALLOW_CREATE_NEW_DEVICES:\n+                if (((AllowCreateNewDevicesDeviceProfileProvisionConfiguration) targetProfile.getProfileData().getProvisionConfiguration()).getProvisionDeviceSecret().equals(provisionRequestSecret)) {\n+                    if (targetDevice != null) {\n+                        log.warn(\"[{}] The device is present and could not be provisioned once more!\", targetDevice.getName());\n+                        notify(targetDevice, provisionRequest, DataConstants.PROVISION_FAILURE, false);\n+                        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                    } else {\n+                        return createDevice(provisionRequest, targetProfile);\n+                    }\n+                }\n+                break;\n+            case CHECK_PRE_PROVISIONED_DEVICES:\n+                if (((CheckPreProvisionedDevicesDeviceProfileProvisionConfiguration) targetProfile.getProfileData().getProvisionConfiguration()).getProvisionDeviceSecret().equals(provisionRequestSecret)) {\n+                    if (targetDevice != null && targetDevice.getDeviceProfileId().equals(targetProfile.getId())) {\n+                        return processProvision(targetDevice, provisionRequest);\n+                    } else {\n+                        log.warn(\"[{}] Failed to find pre provisioned device!\", provisionRequest.getDeviceName());\n+                        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                    }\n+                }\n+                break;\n+        }\n+        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> validateCredentials(ProvisionRequest provisionRequest) {\n+        switch (provisionRequest.getCredentialsType()) {\n+            case MQTT_BASIC:\n+                if (StringUtils.isEmpty(provisionRequest.getCredentialsData().getClientId()) ||\n+                        StringUtils.isEmpty(provisionRequest.getCredentialsData().getUsername()) ||\n+                        StringUtils.isEmpty(provisionRequest.getCredentialsData().getPassword())) {\n+                    log.error(\"Failed to get basic mqtt credentials from credentials data!\");\n+                    return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                }\n+                break;\n+            case X509_CERTIFICATE:\n+                if (StringUtils.isEmpty(provisionRequest.getCredentialsData().getHash())) {\n+                    log.error(\"Failed to get hash from credentials data!\");\n+                    return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                }\n+                break;\n+        }\n+        return null;\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> processProvision(Device device, ProvisionRequest provisionRequest) {\n+        ListenableFuture<Optional<AttributeKvEntry>> provisionStateFuture = attributesService.find(device.getTenantId(), device.getId(),\n+                DataConstants.SERVER_SCOPE, DEVICE_PROVISION_STATE);\n+        ListenableFuture<Boolean> provisionedFuture = Futures.transformAsync(provisionStateFuture, optionalAtr -> {\n+            if (optionalAtr.isPresent()) {\n+                String state = optionalAtr.get().getValueAsString();\n+                if (state.equals(PROVISIONED_STATE)) {\n+                    return Futures.immediateFuture(true);\n+                } else {\n+                    log.error(\"[{}][{}] Unknown provision state: {}!\", device.getName(), DEVICE_PROVISION_STATE, state);\n+                    return Futures.immediateCancelledFuture();\n+                }\n+            }\n+            return Futures.transform(saveProvisionStateAttribute(device), input -> false, MoreExecutors.directExecutor());\n+        }, MoreExecutors.directExecutor());\n+        if (provisionedFuture.isCancelled()) {\n+            throw new RuntimeException(\"Unknown provision state!\");\n+        }\n+        return Futures.transform(provisionedFuture, provisioned -> {\n+            if (provisioned) {\n+                notify(device, provisionRequest, DataConstants.PROVISION_FAILURE, false);\n+                return new ProvisionResponse(null, ProvisionResponseStatus.FAILURE);\n+            }\n+            notify(device, provisionRequest, DataConstants.PROVISION_SUCCESS, true);\n+            return new ProvisionResponse(deviceCredentialsService.findDeviceCredentialsByDeviceId(device.getTenantId(), device.getId()), ProvisionResponseStatus.SUCCESS);\n+        }, MoreExecutors.directExecutor());\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> createDevice(ProvisionRequest provisionRequest, DeviceProfile profile) {\n+        deviceCreationLock.lock();\n+        try {\n+            return processCreateDevice(provisionRequest, profile);\n+        } finally {\n+            deviceCreationLock.unlock();\n+        }\n+    }\n+\n+    private void notify(Device device, ProvisionRequest provisionRequest, String type, boolean success) {\n+        pushProvisionEventToRuleEngine(provisionRequest, device, type);\n+        logAction(device.getTenantId(), device.getCustomerId(), device, success, provisionRequest);\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> processCreateDevice(ProvisionRequest provisionRequest, DeviceProfile profile) {\n+        Device device = deviceService.findDeviceByTenantIdAndName(profile.getTenantId(), provisionRequest.getDeviceName());\n+        if (device == null) {\n+            Device savedDevice = saveDevice(provisionRequest, profile);\n+\n+            deviceStateService.onDeviceAdded(savedDevice);\n+            pushDeviceCreatedEventToRuleEngine(savedDevice);\n+            notify(savedDevice, provisionRequest, DataConstants.PROVISION_SUCCESS, true);\n+\n+            return Futures.transform(saveProvisionStateAttribute(savedDevice), input ->\n+                    new ProvisionResponse(\n+                            getDeviceCredentials(savedDevice),\n+                            ProvisionResponseStatus.SUCCESS), MoreExecutors.directExecutor());\n+        }\n+        log.warn(\"[{}] The device is already provisioned!\", device.getName());\n+        notify(device, provisionRequest, DataConstants.PROVISION_FAILURE, false);\n+        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+    }\n+\n+    private ListenableFuture<List<Void>> saveProvisionStateAttribute(Device device) {\n+        return attributesService.save(device.getTenantId(), device.getId(), DataConstants.SERVER_SCOPE,\n+                Collections.singletonList(new BaseAttributeKvEntry(new StringDataEntry(DEVICE_PROVISION_STATE, PROVISIONED_STATE),\n+                        System.currentTimeMillis())));\n+    }\n+\n+    private Device saveDevice(ProvisionRequest provisionRequest, DeviceProfile profile) {\n+        Device device = new Device();\n+        device.setName(provisionRequest.getDeviceName());\n+        device.setType(profile.getName());\n+        device.setTenantId(profile.getTenantId());\n+        Device savedDevice = deviceService.saveDevice(device);\n+        if (!StringUtils.isEmpty(provisionRequest.getCredentialsData().getToken()) ||\n+                !StringUtils.isEmpty(provisionRequest.getCredentialsData().getHash()) ||\n+                !StringUtils.isEmpty(provisionRequest.getCredentialsData().getUsername()) ||\n+                !StringUtils.isEmpty(provisionRequest.getCredentialsData().getPassword()) ||\n+                !StringUtils.isEmpty(provisionRequest.getCredentialsData().getClientId())) {\n+            DeviceCredentials deviceCredentials = deviceCredentialsService.findDeviceCredentialsByDeviceId(savedDevice.getTenantId(), savedDevice.getId());\n+            deviceCredentials.setCredentialsType(provisionRequest.getCredentialsType());\n+            switch (provisionRequest.getCredentialsType()) {\n+                case ACCESS_TOKEN:\n+                    deviceCredentials.setDeviceId(savedDevice.getId());\n+                    deviceCredentials.setCredentialsId(provisionRequest.getCredentialsData().getToken());\n+                    break;\n+                case MQTT_BASIC:\n+                    BasicMqttCredentials mqttCredentials = new BasicMqttCredentials();\n+                    mqttCredentials.setClientId(provisionRequest.getCredentialsData().getClientId());\n+                    mqttCredentials.setUserName(provisionRequest.getCredentialsData().getUsername());\n+                    mqttCredentials.setPassword(provisionRequest.getCredentialsData().getPassword());\n+                    deviceCredentials.setCredentialsValue(JacksonUtil.toString(mqttCredentials));\n+                    break;\n+                case X509_CERTIFICATE:\n+                    deviceCredentials.setCredentialsValue(provisionRequest.getCredentialsData().getHash());\n+                    break;\n+            }\n+            deviceCredentials.setCredentialsType(provisionRequest.getCredentialsType());\n+            deviceCredentialsService.updateDeviceCredentials(savedDevice.getTenantId(), deviceCredentials);\n+        }\n+        return savedDevice;\n+    }\n+\n+    private DeviceCredentials getDeviceCredentials(Device device) {\n+        return deviceCredentialsService.findDeviceCredentialsByDeviceId(device.getTenantId(), device.getId());\n+    }\n+\n+    private void pushProvisionEventToRuleEngine(ProvisionRequest request, Device device, String type) {\n+        try {\n+            ObjectNode entityNode = JacksonUtil.OBJECT_MAPPER.valueToTree(request);\n+            TbMsg msg = TbMsg.newMsg(type, device.getId(), createTbMsgMetaData(device), JacksonUtil.OBJECT_MAPPER.writeValueAsString(entityNode));\n+            sendToRuleEngine(device.getTenantId(), msg, null);\n+        } catch (JsonProcessingException | IllegalArgumentException e) {\n+            log.warn(\"[{}] Failed to push device action to rule engine: {}\", device.getId(), type, e);\n+        }\n+    }\n+\n+    private void pushDeviceCreatedEventToRuleEngine(Device device) {\n+        try {\n+            ObjectNode entityNode = JacksonUtil.OBJECT_MAPPER.valueToTree(device);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6683158c6b262ed930db41c3ced73efec94320aa"}, "originalPosition": 300}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTU3NDk0OnYy", "diffSide": "RIGHT", "path": "application/src/main/java/org/thingsboard/server/service/device/DeviceProvisionServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowNjowN1rOHfDeeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowNjowN1rOHfDeeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyNDg1Nw==", "bodyText": "We need to make the main method transactional and pay attention to avoid using DAO layer that is executed in different threads (to avoid locks). Same for TB PE.", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r502324857", "createdAt": "2020-10-09T10:06:07Z", "author": {"login": "ashvayka"}, "path": "application/src/main/java/org/thingsboard/server/service/device/DeviceProvisionServiceImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright \u00a9 2016-2020 The Thingsboard Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.thingsboard.server.service.device;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import lombok.extern.slf4j.Slf4j;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+import org.springframework.util.StringUtils;\n+import org.thingsboard.server.common.data.DataConstants;\n+import org.thingsboard.server.common.data.Device;\n+import org.thingsboard.server.common.data.DeviceProfile;\n+import org.thingsboard.server.common.data.audit.ActionType;\n+import org.thingsboard.server.common.data.device.credentials.BasicMqttCredentials;\n+import org.thingsboard.server.common.data.device.profile.AllowCreateNewDevicesDeviceProfileProvisionConfiguration;\n+import org.thingsboard.server.common.data.device.profile.CheckPreProvisionedDevicesDeviceProfileProvisionConfiguration;\n+import org.thingsboard.server.common.data.id.CustomerId;\n+import org.thingsboard.server.common.data.id.TenantId;\n+import org.thingsboard.server.common.data.id.UserId;\n+import org.thingsboard.server.common.data.kv.AttributeKvEntry;\n+import org.thingsboard.server.common.data.kv.BaseAttributeKvEntry;\n+import org.thingsboard.server.common.data.kv.StringDataEntry;\n+import org.thingsboard.server.common.data.security.DeviceCredentials;\n+import org.thingsboard.server.common.msg.TbMsg;\n+import org.thingsboard.server.common.msg.TbMsgMetaData;\n+import org.thingsboard.server.common.msg.queue.ServiceType;\n+import org.thingsboard.server.common.msg.queue.TopicPartitionInfo;\n+import org.thingsboard.server.dao.attributes.AttributesService;\n+import org.thingsboard.server.dao.audit.AuditLogService;\n+import org.thingsboard.server.dao.device.DeviceCredentialsService;\n+import org.thingsboard.server.dao.device.DeviceDao;\n+import org.thingsboard.server.dao.device.DeviceProfileDao;\n+import org.thingsboard.server.dao.device.DeviceProvisionService;\n+import org.thingsboard.server.dao.device.DeviceService;\n+import org.thingsboard.server.dao.device.provision.ProvisionRequest;\n+import org.thingsboard.server.dao.device.provision.ProvisionResponse;\n+import org.thingsboard.server.dao.device.provision.ProvisionResponseStatus;\n+import org.thingsboard.server.dao.util.mapping.JacksonUtil;\n+import org.thingsboard.server.gen.transport.TransportProtos;\n+import org.thingsboard.server.gen.transport.TransportProtos.ToRuleEngineMsg;\n+import org.thingsboard.server.queue.TbQueueCallback;\n+import org.thingsboard.server.queue.TbQueueProducer;\n+import org.thingsboard.server.queue.common.TbProtoQueueMsg;\n+import org.thingsboard.server.queue.discovery.PartitionService;\n+import org.thingsboard.server.queue.provider.TbQueueProducerProvider;\n+import org.thingsboard.server.queue.util.TbCoreComponent;\n+import org.thingsboard.server.service.state.DeviceStateService;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+\n+@Service\n+@Slf4j\n+@TbCoreComponent\n+public class DeviceProvisionServiceImpl implements DeviceProvisionService {\n+\n+    protected TbQueueProducer<TbProtoQueueMsg<ToRuleEngineMsg>> ruleEngineMsgProducer;\n+\n+    private static final String DEVICE_PROVISION_STATE = \"provisionState\";\n+    private static final String PROVISIONED_STATE = \"provisioned\";\n+\n+    private final ReentrantLock deviceCreationLock = new ReentrantLock();\n+\n+    @Autowired\n+    DeviceDao deviceDao;\n+\n+    @Autowired\n+    DeviceProfileDao deviceProfileDao;\n+\n+    @Autowired\n+    DeviceService deviceService;\n+\n+    @Autowired\n+    DeviceCredentialsService deviceCredentialsService;\n+\n+    @Autowired\n+    AttributesService attributesService;\n+\n+    @Autowired\n+    DeviceStateService deviceStateService;\n+\n+    @Autowired\n+    AuditLogService auditLogService;\n+\n+    @Autowired\n+    PartitionService partitionService;\n+\n+    public DeviceProvisionServiceImpl(TbQueueProducerProvider producerProvider) {\n+        ruleEngineMsgProducer = producerProvider.getRuleEngineMsgProducer();\n+    }\n+\n+    @Override\n+    public ListenableFuture<ProvisionResponse> provisionDevice(ProvisionRequest provisionRequest) {\n+        String provisionRequestKey = provisionRequest.getCredentials().getProvisionDeviceKey();\n+        String provisionRequestSecret = provisionRequest.getCredentials().getProvisionDeviceSecret();\n+\n+        if (StringUtils.isEmpty(provisionRequestKey) || StringUtils.isEmpty(provisionRequestSecret)) {\n+            return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+        }\n+\n+        if (provisionRequest.getCredentialsType() != null) {\n+            ListenableFuture<ProvisionResponse> error = validateCredentials(provisionRequest);\n+            if (error != null) {\n+                return error;\n+            }\n+        }\n+\n+        DeviceProfile targetProfile = deviceProfileDao.findByProvisionDeviceKey(provisionRequestKey);\n+\n+        if (targetProfile == null) {\n+            return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+        }\n+\n+        Device targetDevice = deviceDao.findDeviceByTenantIdAndName(targetProfile.getTenantId().getId(), provisionRequest.getDeviceName()).orElse(null);\n+\n+        switch (targetProfile.getProvisionType()) {\n+            case ALLOW_CREATE_NEW_DEVICES:\n+                if (((AllowCreateNewDevicesDeviceProfileProvisionConfiguration) targetProfile.getProfileData().getProvisionConfiguration()).getProvisionDeviceSecret().equals(provisionRequestSecret)) {\n+                    if (targetDevice != null) {\n+                        log.warn(\"[{}] The device is present and could not be provisioned once more!\", targetDevice.getName());\n+                        notify(targetDevice, provisionRequest, DataConstants.PROVISION_FAILURE, false);\n+                        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                    } else {\n+                        return createDevice(provisionRequest, targetProfile);\n+                    }\n+                }\n+                break;\n+            case CHECK_PRE_PROVISIONED_DEVICES:\n+                if (((CheckPreProvisionedDevicesDeviceProfileProvisionConfiguration) targetProfile.getProfileData().getProvisionConfiguration()).getProvisionDeviceSecret().equals(provisionRequestSecret)) {\n+                    if (targetDevice != null && targetDevice.getDeviceProfileId().equals(targetProfile.getId())) {\n+                        return processProvision(targetDevice, provisionRequest);\n+                    } else {\n+                        log.warn(\"[{}] Failed to find pre provisioned device!\", provisionRequest.getDeviceName());\n+                        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                    }\n+                }\n+                break;\n+        }\n+        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.NOT_FOUND));\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> validateCredentials(ProvisionRequest provisionRequest) {\n+        switch (provisionRequest.getCredentialsType()) {\n+            case MQTT_BASIC:\n+                if (StringUtils.isEmpty(provisionRequest.getCredentialsData().getClientId()) ||\n+                        StringUtils.isEmpty(provisionRequest.getCredentialsData().getUsername()) ||\n+                        StringUtils.isEmpty(provisionRequest.getCredentialsData().getPassword())) {\n+                    log.error(\"Failed to get basic mqtt credentials from credentials data!\");\n+                    return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                }\n+                break;\n+            case X509_CERTIFICATE:\n+                if (StringUtils.isEmpty(provisionRequest.getCredentialsData().getHash())) {\n+                    log.error(\"Failed to get hash from credentials data!\");\n+                    return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+                }\n+                break;\n+        }\n+        return null;\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> processProvision(Device device, ProvisionRequest provisionRequest) {\n+        ListenableFuture<Optional<AttributeKvEntry>> provisionStateFuture = attributesService.find(device.getTenantId(), device.getId(),\n+                DataConstants.SERVER_SCOPE, DEVICE_PROVISION_STATE);\n+        ListenableFuture<Boolean> provisionedFuture = Futures.transformAsync(provisionStateFuture, optionalAtr -> {\n+            if (optionalAtr.isPresent()) {\n+                String state = optionalAtr.get().getValueAsString();\n+                if (state.equals(PROVISIONED_STATE)) {\n+                    return Futures.immediateFuture(true);\n+                } else {\n+                    log.error(\"[{}][{}] Unknown provision state: {}!\", device.getName(), DEVICE_PROVISION_STATE, state);\n+                    return Futures.immediateCancelledFuture();\n+                }\n+            }\n+            return Futures.transform(saveProvisionStateAttribute(device), input -> false, MoreExecutors.directExecutor());\n+        }, MoreExecutors.directExecutor());\n+        if (provisionedFuture.isCancelled()) {\n+            throw new RuntimeException(\"Unknown provision state!\");\n+        }\n+        return Futures.transform(provisionedFuture, provisioned -> {\n+            if (provisioned) {\n+                notify(device, provisionRequest, DataConstants.PROVISION_FAILURE, false);\n+                return new ProvisionResponse(null, ProvisionResponseStatus.FAILURE);\n+            }\n+            notify(device, provisionRequest, DataConstants.PROVISION_SUCCESS, true);\n+            return new ProvisionResponse(deviceCredentialsService.findDeviceCredentialsByDeviceId(device.getTenantId(), device.getId()), ProvisionResponseStatus.SUCCESS);\n+        }, MoreExecutors.directExecutor());\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> createDevice(ProvisionRequest provisionRequest, DeviceProfile profile) {\n+        deviceCreationLock.lock();\n+        try {\n+            return processCreateDevice(provisionRequest, profile);\n+        } finally {\n+            deviceCreationLock.unlock();\n+        }\n+    }\n+\n+    private void notify(Device device, ProvisionRequest provisionRequest, String type, boolean success) {\n+        pushProvisionEventToRuleEngine(provisionRequest, device, type);\n+        logAction(device.getTenantId(), device.getCustomerId(), device, success, provisionRequest);\n+    }\n+\n+    private ListenableFuture<ProvisionResponse> processCreateDevice(ProvisionRequest provisionRequest, DeviceProfile profile) {\n+        Device device = deviceService.findDeviceByTenantIdAndName(profile.getTenantId(), provisionRequest.getDeviceName());\n+        if (device == null) {\n+            Device savedDevice = saveDevice(provisionRequest, profile);\n+\n+            deviceStateService.onDeviceAdded(savedDevice);\n+            pushDeviceCreatedEventToRuleEngine(savedDevice);\n+            notify(savedDevice, provisionRequest, DataConstants.PROVISION_SUCCESS, true);\n+\n+            return Futures.transform(saveProvisionStateAttribute(savedDevice), input ->\n+                    new ProvisionResponse(\n+                            getDeviceCredentials(savedDevice),\n+                            ProvisionResponseStatus.SUCCESS), MoreExecutors.directExecutor());\n+        }\n+        log.warn(\"[{}] The device is already provisioned!\", device.getName());\n+        notify(device, provisionRequest, DataConstants.PROVISION_FAILURE, false);\n+        return Futures.immediateFuture(new ProvisionResponse(null, ProvisionResponseStatus.FAILURE));\n+    }\n+\n+    private ListenableFuture<List<Void>> saveProvisionStateAttribute(Device device) {\n+        return attributesService.save(device.getTenantId(), device.getId(), DataConstants.SERVER_SCOPE,\n+                Collections.singletonList(new BaseAttributeKvEntry(new StringDataEntry(DEVICE_PROVISION_STATE, PROVISIONED_STATE),\n+                        System.currentTimeMillis())));\n+    }\n+\n+    private Device saveDevice(ProvisionRequest provisionRequest, DeviceProfile profile) {\n+        Device device = new Device();\n+        device.setName(provisionRequest.getDeviceName());\n+        device.setType(profile.getName());\n+        device.setTenantId(profile.getTenantId());\n+        Device savedDevice = deviceService.saveDevice(device);\n+        if (!StringUtils.isEmpty(provisionRequest.getCredentialsData().getToken()) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6683158c6b262ed930db41c3ced73efec94320aa"}, "originalPosition": 255}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTU3NzYzOnYy", "diffSide": "RIGHT", "path": "common/dao-api/src/main/java/org/thingsboard/server/dao/device/provision/ProvisionResponseStatus.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowNzowMVrOHfDgKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowNzowMVrOHfDgKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyNTI5MQ==", "bodyText": "empty line", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r502325291", "createdAt": "2020-10-09T10:07:01Z", "author": {"login": "ashvayka"}, "path": "common/dao-api/src/main/java/org/thingsboard/server/dao/device/provision/ProvisionResponseStatus.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright \u00a9 2016-2020 The Thingsboard Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.thingsboard.server.dao.device.provision;\n+\n+public enum ProvisionResponseStatus {\n+    UNKNOWN,\n+    SUCCESS,\n+    NOT_FOUND,\n+    FAILURE\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6683158c6b262ed930db41c3ced73efec94320aa"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTU3OTk1OnYy", "diffSide": "RIGHT", "path": "common/data/src/main/java/org/thingsboard/server/common/data/device/credentials/ProvisionDeviceCredentialsData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowNzo0N1rOHfDhuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowNzo0N1rOHfDhuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyNTY4OA==", "bodyText": "make the variable name clear. Something like x509CertHash", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r502325688", "createdAt": "2020-10-09T10:07:47Z", "author": {"login": "ashvayka"}, "path": "common/data/src/main/java/org/thingsboard/server/common/data/device/credentials/ProvisionDeviceCredentialsData.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright \u00a9 2016-2020 The Thingsboard Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.thingsboard.server.common.data.device.credentials;\n+\n+import lombok.Data;\n+\n+@Data\n+public class ProvisionDeviceCredentialsData {\n+    private final String token;\n+    private final String clientId;\n+    private final String username;\n+    private final String password;\n+    private final String hash;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6683158c6b262ed930db41c3ced73efec94320aa"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTU4MDgxOnYy", "diffSide": "RIGHT", "path": "common/data/src/main/java/org/thingsboard/server/common/data/device/profile/DeviceProfileProvisionConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowODowNFrOHfDiRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowODowNFrOHfDiRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyNTgzMA==", "bodyText": "no new line", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r502325830", "createdAt": "2020-10-09T10:08:04Z", "author": {"login": "ashvayka"}, "path": "common/data/src/main/java/org/thingsboard/server/common/data/device/profile/DeviceProfileProvisionConfiguration.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Copyright \u00a9 2016-2020 The Thingsboard Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.thingsboard.server.common.data.device.profile;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import org.thingsboard.server.common.data.DeviceProfileProvisionType;\n+\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@JsonTypeInfo(\n+        use = JsonTypeInfo.Id.NAME,\n+        include = JsonTypeInfo.As.PROPERTY,\n+        property = \"type\")\n+@JsonSubTypes({\n+        @JsonSubTypes.Type(value = DisabledDeviceProfileProvisionConfiguration.class, name = \"DISABLED\"),\n+        @JsonSubTypes.Type(value = AllowCreateNewDevicesDeviceProfileProvisionConfiguration.class, name = \"ALLOW_CREATE_NEW_DEVICES\"),\n+        @JsonSubTypes.Type(value = CheckPreProvisionedDevicesDeviceProfileProvisionConfiguration.class, name = \"CHECK_PRE_PROVISIONED_DEVICES\")})\n+public interface DeviceProfileProvisionConfiguration {\n+\n+    @JsonIgnore\n+    DeviceProfileProvisionType getType();\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6683158c6b262ed930db41c3ced73efec94320aa"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTU4NDYwOnYy", "diffSide": "RIGHT", "path": "common/transport/transport-api/src/main/proto/transport.proto", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowOToyMFrOHfDktA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowOToyMFrOHfDktA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyNjQ1Mg==", "bodyText": "remove this", "url": "https://github.com/thingsboard/thingsboard/pull/3518#discussion_r502326452", "createdAt": "2020-10-09T10:09:20Z", "author": {"login": "ashvayka"}, "path": "common/transport/transport-api/src/main/proto/transport.proto", "diffHunk": "@@ -72,6 +72,11 @@ message GatewayAttributesMsg {\n   repeated AttributesMsg msg = 1;\n }\n \n+message GatewayProvisionResponseMsg {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6683158c6b262ed930db41c3ced73efec94320aa"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1322, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}