{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2MDY4MTAw", "number": 1544, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNDozNTo0MFrOE3QUSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMTozMzoxNVrOE6hjtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Mzc0NDczOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNDozNTo0MFrOHwfeBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNDozNTo0MFrOHwfeBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwOTI4Nw==", "bodyText": "Apparently, we should use the dockerRegistryApiService here, not the mockDockerRegistryManager. And also in the test below.", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r520609287", "createdAt": "2020-11-10T14:35:40Z", "author": {"login": "YouKofan"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.manager.security.AuthManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry();\n+    private final DockerRegistry dockerRegistryWithOwner = DockerCreatorUtils.getDockerRegistry(SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList();\n+    private final Tool tool = ToolCreatorUtils.getTool();\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Autowired\n+    private AuthManager mockAuthManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistryWithOwner, AclPermission.WRITE);\n+        doReturn(SIMPLE_USER).when(mockAuthManager).getAuthorizedUser();\n+        doReturn(dockerRegistryWithOwner).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        final DockerRegistry resultRegistry = dockerRegistryApiService.updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(resultRegistry).isEqualTo(dockerRegistryWithOwner);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        doReturn(dockerRegistryWithOwner).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+        initAclEntity(dockerRegistryWithOwner);\n+        doReturn(SIMPLE_USER).when(mockAuthManager).getAuthorizedUser();\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithOwner));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(mockDockerRegistryManager.delete(ID, true)).isEqualTo(dockerRegistry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663ad3a99f2552639481f236603945c5730c7195"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzczMDYwOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/ToolCreatorUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOTo1ODoyN1rOHxGOKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOTo1ODoyN1rOHxGOKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NDIwMA==", "bodyText": "To my mind it would be better to overload the method\nCould we add final to method argument?", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r521244200", "createdAt": "2020-11-11T09:58:27Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/ToolCreatorUtils.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.docker;\n+\n+import com.epam.pipeline.entity.pipeline.Tool;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+\n+public final class ToolCreatorUtils {\n+\n+    private ToolCreatorUtils() {\n+\n+    }\n+\n+    public static Tool getTool() {\n+        final Tool tool = new Tool();\n+        tool.setId(ID);\n+        tool.setName(TEST_STRING);\n+        tool.setCpu(TEST_STRING);\n+        tool.setDefaultCommand(TEST_STRING);\n+        tool.setToolGroupId(ID);\n+        tool.setRegistry(TEST_STRING);\n+        tool.setRegistryId(ID);\n+        return tool;\n+    }\n+\n+    public static Tool getTool(String owner) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663ad3a99f2552639481f236603945c5730c7195"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzczMzU0OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOTo1OToxN1rOHxGQCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOTo1OToxN1rOHxGQCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NDY4MQ==", "bodyText": "To my mind it would be better to overload the method\nCould we add final to method argument?", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r521244681", "createdAt": "2020-11-11T09:59:17Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+\n+public final class DockerCreatorUtils {\n+\n+    private DockerCreatorUtils() {\n+\n+    }\n+\n+    public static DockerRegistry getDockerRegistry() {\n+        final DockerRegistry dockerRegistry = new DockerRegistry();\n+        dockerRegistry.setCaCert(TEST_STRING);\n+        dockerRegistry.setId(ID);\n+        dockerRegistry.setDescription(TEST_STRING);\n+        dockerRegistry.setExternalUrl(TEST_STRING);\n+        dockerRegistry.setHasMetadata(true);\n+        dockerRegistry.setPassword(TEST_STRING);\n+        return dockerRegistry;\n+    }\n+\n+    public static DockerRegistry getDockerRegistry(String owner) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663ad3a99f2552639481f236603945c5730c7195"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Nzc0NDQ1OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDowMjowOFrOHxGWkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDowMjowOFrOHxGWkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NjM1NA==", "bodyText": "Do not forget to add final\nDo we really need this method?", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r521246354", "createdAt": "2020-11-11T10:02:08Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+\n+public final class DockerCreatorUtils {\n+\n+    private DockerCreatorUtils() {\n+\n+    }\n+\n+    public static DockerRegistry getDockerRegistry() {\n+        final DockerRegistry dockerRegistry = new DockerRegistry();\n+        dockerRegistry.setCaCert(TEST_STRING);\n+        dockerRegistry.setId(ID);\n+        dockerRegistry.setDescription(TEST_STRING);\n+        dockerRegistry.setExternalUrl(TEST_STRING);\n+        dockerRegistry.setHasMetadata(true);\n+        dockerRegistry.setPassword(TEST_STRING);\n+        return dockerRegistry;\n+    }\n+\n+    public static DockerRegistry getDockerRegistry(String owner) {\n+        final DockerRegistry dockerRegistry = new DockerRegistry();\n+        dockerRegistry.setOwner(owner);\n+        dockerRegistry.setCaCert(TEST_STRING);\n+        dockerRegistry.setId(ID);\n+        dockerRegistry.setDescription(TEST_STRING);\n+        dockerRegistry.setExternalUrl(TEST_STRING);\n+        dockerRegistry.setHasMetadata(true);\n+        dockerRegistry.setPassword(TEST_STRING);\n+        return dockerRegistry;\n+    }\n+\n+    public static DockerRegistryVO getDockerRegistryVO() {\n+        final DockerRegistryVO dockerRegistryVO = new DockerRegistryVO();\n+        dockerRegistryVO.setCaCert(TEST_STRING);\n+        dockerRegistryVO.setId(ID);\n+        dockerRegistryVO.setDescription(TEST_STRING);\n+        dockerRegistryVO.setExternalUrl(TEST_STRING);\n+        dockerRegistryVO.setPassword(TEST_STRING);\n+        return dockerRegistryVO;\n+    }\n+\n+    public static DockerRegistryList getDockerRegistryList() {\n+        final List<DockerRegistry> dockerRegistries = Collections.singletonList(getDockerRegistry());\n+        return new DockerRegistryList(dockerRegistries);\n+    }\n+\n+    public static DockerRegistryList getDockerRegistryList(String owner) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663ad3a99f2552639481f236603945c5730c7195"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Nzg4NzY1OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0MjowMlrOHxHvJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0MjowMlrOHxHvJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2OTAyOQ==", "bodyText": "Could you add a simple tests for methods with AclTree annotation?", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r521269029", "createdAt": "2020-11-11T10:42:02Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.manager.security.AuthManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "663ad3a99f2552639481f236603945c5730c7195"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzUxMTk3OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTozMDowM1rOH1kpWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTozMDowM1rOH1kpWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzNjk4NQ==", "bodyText": "Could it be realized like:\nreturn getTool(null, null)\n\n?", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525936985", "createdAt": "2020-11-18T09:30:03Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "diffHunk": "@@ -165,10 +166,56 @@ public static DockerRegistryVO getDockerRegistryVO() {\n     }\n \n     public static DockerRegistryList getDockerRegistryList() {\n-        return new DockerRegistryList(Collections.singletonList(getDockerRegistry()));\n+        final List<DockerRegistry> dockerRegistries = Collections.singletonList(getDockerRegistry());\n+        return new DockerRegistryList(dockerRegistries);\n+    }\n+\n+    public static DockerRegistryList getDockerRegistryList(final DockerRegistry dockerRegistry) {\n+        return new DockerRegistryList(Collections.singletonList(dockerRegistry));\n     }\n \n     public static DockerRegistryEventEnvelope getDockerRegistryEventEnvelope() {\n         return new DockerRegistryEventEnvelope();\n     }\n+\n+    public static Tool getTool(final Long id, final String owner) {\n+        final Tool tool = new Tool();\n+        tool.setOwner(owner);\n+        tool.setId(id);\n+        tool.setCpu(TEST_STRING);\n+        tool.setDefaultCommand(TEST_STRING);\n+        tool.setToolGroupId(ID);\n+        tool.setRegistry(TEST_STRING);\n+        return tool;\n+    }\n+\n+    public static Tool getTool(final String owner) {\n+        return getTool(ID, owner);\n+    }\n+\n+    public static Tool getTool() {\n+        final Tool tool = new Tool();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3103f3f4623dae614b7ca813920a21f643d8c0a"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzUyOTAyOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTozNDowM1rOH1kz4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTozNDowM1rOH1kz4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzOTY4MA==", "bodyText": "Could you please remove empty line?", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525939680", "createdAt": "2020-11-18T09:34:03Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3103f3f4623dae614b7ca813920a21f643d8c0a"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzcxMjM1OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDoxNjoyNVrOH1mkTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDoxNjoyNVrOH1mkTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk2ODQ2Mg==", "bodyText": "It looks a bit confusing: you are granting permission to object with name *WithoutPermission", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525968462", "createdAt": "2020-11-18T10:16:25Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3103f3f4623dae614b7ca813920a21f643d8c0a"}, "originalPosition": 332}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzgzNTk5OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDo0NToxOVrOH1nudQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDo0NToxOVrOH1nudQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4NzQ0NQ==", "bodyText": "Class fields mutation makes code confusing. To my mind it would more clearly to refactor this lines:\ntoolGroup.setTools(toolList);\ntoolGroupWithoutPermission.setTools(toolList);\ndockerRegistryWithTools.setGroups(toolGroups);\n\nI would suggest two options:\n\ncreate a new objects into the test\ninitialize this fields at the tests class beginning", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525987445", "createdAt": "2020-11-18T10:45:19Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3103f3f4623dae614b7ca813920a21f643d8c0a"}, "originalPosition": 327}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Nzg5MjExOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDo1OTowM1rOH1oQpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMTowNToyMlrOH1ogVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk5NjE5OA==", "bodyText": "Maybe assertThat(dockerRegistryChildren).containsAll(toolGroups); would be enough?", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525996198", "createdAt": "2020-11-18T10:59:03Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n+    }\n+\n+    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n+        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n+    }\n+\n+    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n+        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n+    }\n+\n+    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n+        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n+        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();\n+        final List<? extends AbstractSecuredEntity> emptyToolGroupLeaves = registry.getChildren().get(2).getLeaves();\n+\n+        assertThat(dockerRegistryChildren.size()).isEqualTo(toolGroups.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3103f3f4623dae614b7ca813920a21f643d8c0a"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwMDIxNQ==", "bodyText": "If so, could you please check it for other places? (and think about common method)", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526000215", "createdAt": "2020-11-18T11:05:22Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n+    }\n+\n+    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n+        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n+    }\n+\n+    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n+        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n+    }\n+\n+    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n+        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n+        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();\n+        final List<? extends AbstractSecuredEntity> emptyToolGroupLeaves = registry.getChildren().get(2).getLeaves();\n+\n+        assertThat(dockerRegistryChildren.size()).isEqualTo(toolGroups.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk5NjE5OA=="}, "originalCommit": {"oid": "c3103f3f4623dae614b7ca813920a21f643d8c0a"}, "originalPosition": 357}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzkyMDM4OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMTowNTo0N1rOH1ohfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMToxMDozM1rOH1osww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwMDUxMQ==", "bodyText": "Could we use hasSize here?", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526000511", "createdAt": "2020-11-18T11:05:47Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n+    }\n+\n+    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3103f3f4623dae614b7ca813920a21f643d8c0a"}, "originalPosition": 339}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwMzM5NQ==", "bodyText": "If so, could you please fix it for other methods?", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526003395", "createdAt": "2020-11-18T11:10:33Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n+    }\n+\n+    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwMDUxMQ=="}, "originalCommit": {"oid": "c3103f3f4623dae614b7ca813920a21f643d8c0a"}, "originalPosition": 339}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Nzk2NTA2OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMToxNzowMVrOH1o8Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMToxNzowMVrOH1o8Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwNzM1MA==", "bodyText": "Could we store dockerRegistryApiService.loadAllRegistriesContent().getChildren() into the local field?", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526007350", "createdAt": "2020-11-18T11:17:01Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3103f3f4623dae614b7ca813920a21f643d8c0a"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Nzk4NDc1OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMToyMTo1OVrOH1pH_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMToyMTo1OVrOH1pH_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxMDM2NA==", "bodyText": "Is it possible to rename this method to more clear?", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526010364", "createdAt": "2020-11-18T11:21:59Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3103f3f4623dae614b7ca813920a21f643d8c0a"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5ODAyNjc2OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMTozMzoxNVrOH1ph8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMTozMzoxNVrOH1ph8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNzAxMQ==", "bodyText": "Could we refactor this logic somehow: list.get(index) is not clear? (Maybe pick methods for each requested entity? by Id?)", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526017011", "createdAt": "2020-11-18T11:33:15Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n+    }\n+\n+    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n+        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n+    }\n+\n+    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n+        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n+    }\n+\n+    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n+        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n+        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3103f3f4623dae614b7ca813920a21f643d8c0a"}, "originalPosition": 354}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 306, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}