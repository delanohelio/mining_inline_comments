{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwMTUxNDMw", "number": 1222, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNzoxMToxN1rOEQS2YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNzoxNjozM1rOEQS91Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTIxNTA1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/epam/pipeline/dao/pipeline/PipelineRunDao.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNzoxMToxN1rOG0Xi7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwOTo1OTo1OVrOG0w67w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2NDkxMQ==", "bodyText": "I'd suggest to move this method to StopServerlessRunDao class", "url": "https://github.com/epam/cloud-pipeline/pull/1222#discussion_r457564911", "createdAt": "2020-07-20T17:11:17Z", "author": {"login": "mzueva"}, "path": "api/src/main/java/com/epam/pipeline/dao/pipeline/PipelineRunDao.java", "diffHunk": "@@ -449,11 +450,9 @@ public void deleteRunSidsByPipelineId(final Long pipelineId) {\n                 .findFirst();\n     }\n \n-    public List<PipelineRun> loadServerlessRunsToStop(final LocalDateTime maxLastUpdate) {\n-        final MapSqlParameterSource params = new MapSqlParameterSource();\n-        params.addValue(\"MAX_LAST_UPDATE\", maxLastUpdate);\n+    public List<StopServerlessRun> loadServerlessRunsToStop() {\n         return ListUtils.emptyIfNull(getNamedParameterJdbcTemplate()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba0cafd86038eac71f5ea92c6d6fdafb2499ccc6"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4MDY1NQ==", "bodyText": "Thanks, done", "url": "https://github.com/epam/cloud-pipeline/pull/1222#discussion_r457980655", "createdAt": "2020-07-21T09:59:59Z", "author": {"login": "ekazachkova"}, "path": "api/src/main/java/com/epam/pipeline/dao/pipeline/PipelineRunDao.java", "diffHunk": "@@ -449,11 +450,9 @@ public void deleteRunSidsByPipelineId(final Long pipelineId) {\n                 .findFirst();\n     }\n \n-    public List<PipelineRun> loadServerlessRunsToStop(final LocalDateTime maxLastUpdate) {\n-        final MapSqlParameterSource params = new MapSqlParameterSource();\n-        params.addValue(\"MAX_LAST_UPDATE\", maxLastUpdate);\n+    public List<StopServerlessRun> loadServerlessRunsToStop() {\n         return ListUtils.emptyIfNull(getNamedParameterJdbcTemplate()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2NDkxMQ=="}, "originalCommit": {"oid": "ba0cafd86038eac71f5ea92c6d6fdafb2499ccc6"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTIxOTg4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/epam/pipeline/dao/pipeline/StopServerlessRunDao.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNzoxMjoyNlrOG0XlnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMDowMzoyM1rOG0xCaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2NTU5Nw==", "bodyText": "For most classes we keep Mandatory propagation at DAO level, why do we need Required in this case?", "url": "https://github.com/epam/cloud-pipeline/pull/1222#discussion_r457565597", "createdAt": "2020-07-20T17:12:26Z", "author": {"login": "mzueva"}, "path": "api/src/main/java/com/epam/pipeline/dao/pipeline/StopServerlessRunDao.java", "diffHunk": "@@ -38,21 +39,22 @@\n     private String updateServerlessRunQuery;\n     private String loadAllServerlessRunsQuery;\n     private String deleteByRunIdServerlessRunQuery;\n+    private String loadServerlessunByRunIdQuery;\n \n     @Transactional(propagation = Propagation.MANDATORY)\n     public Long createServerlessRunId() {\n         return daoHelper.createId(serverlessRunSequenceQuery);\n     }\n \n-    @Transactional(propagation = Propagation.MANDATORY)\n+    @Transactional(propagation = Propagation.REQUIRED)\n     public void createServerlessRun(final StopServerlessRun run) {\n         final Long id = createServerlessRunId();\n         run.setId(id);\n         getNamedParameterJdbcTemplate().update(saveServerlessRunQuery,\n                 StopServerlessRunParameters.getParameters(run));\n     }\n \n-    @Transactional(propagation = Propagation.MANDATORY)\n+    @Transactional(propagation = Propagation.REQUIRED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba0cafd86038eac71f5ea92c6d6fdafb2499ccc6"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4MjU2OA==", "bodyText": "We need Required here due to this method called from non-transaction context.\nI added a new class StopServerlessRunManager to manage transactions.", "url": "https://github.com/epam/cloud-pipeline/pull/1222#discussion_r457982568", "createdAt": "2020-07-21T10:03:23Z", "author": {"login": "ekazachkova"}, "path": "api/src/main/java/com/epam/pipeline/dao/pipeline/StopServerlessRunDao.java", "diffHunk": "@@ -38,21 +39,22 @@\n     private String updateServerlessRunQuery;\n     private String loadAllServerlessRunsQuery;\n     private String deleteByRunIdServerlessRunQuery;\n+    private String loadServerlessunByRunIdQuery;\n \n     @Transactional(propagation = Propagation.MANDATORY)\n     public Long createServerlessRunId() {\n         return daoHelper.createId(serverlessRunSequenceQuery);\n     }\n \n-    @Transactional(propagation = Propagation.MANDATORY)\n+    @Transactional(propagation = Propagation.REQUIRED)\n     public void createServerlessRun(final StopServerlessRun run) {\n         final Long id = createServerlessRunId();\n         run.setId(id);\n         getNamedParameterJdbcTemplate().update(saveServerlessRunQuery,\n                 StopServerlessRunParameters.getParameters(run));\n     }\n \n-    @Transactional(propagation = Propagation.MANDATORY)\n+    @Transactional(propagation = Propagation.REQUIRED)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2NTU5Nw=="}, "originalCommit": {"oid": "ba0cafd86038eac71f5ea92c6d6fdafb2499ccc6"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTIzNDEzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/epam/pipeline/manager/cluster/performancemonitoring/ResourceMonitoringManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNzoxNjozM1rOG0Xugw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMDowMzozOFrOG0xC6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2Nzg3NQ==", "bodyText": "We also need to handle situation when LAUNCH_SERVERLESS_STOP_TIMEOUT is null - consider run non-expired in this case", "url": "https://github.com/epam/cloud-pipeline/pull/1222#discussion_r457567875", "createdAt": "2020-07-20T17:16:33Z", "author": {"login": "mzueva"}, "path": "api/src/main/java/com/epam/pipeline/manager/cluster/performancemonitoring/ResourceMonitoringManager.java", "diffHunk": "@@ -408,11 +409,21 @@ private void setInstanceTypeMap(final Map<String, InstanceType> instanceTypeMap)\n         }\n \n         private void processServerlessRuns() {\n-            final Integer timeout = preferenceManager.getPreference(SystemPreferences.LAUNCH_SERVERLESS_STOP_TIMEOUT);\n-            final LocalDateTime maxLastUpdate = LocalDateTime.now().minusMinutes(timeout);\n-            final List<PipelineRun> runs = ListUtils.emptyIfNull(\n-                    pipelineRunManager.loadExpiredServerlessRuns(maxLastUpdate));\n-            runs.forEach(run -> pipelineRunManager.stopServerlessRun(run.getId()));\n+            final List<StopServerlessRun> activeServerlessRuns = ListUtils.emptyIfNull(\n+                    pipelineRunManager.loadActiveServerlessRuns());\n+            activeServerlessRuns.stream()\n+                    .filter(this::serverlessRunIsExpired)\n+                    .forEach(run -> pipelineRunManager.stopServerlessRun(run.getId()));\n+        }\n+\n+        private boolean serverlessRunIsExpired(final StopServerlessRun run) {\n+            return run.getLastUpdate().isBefore(LocalDateTime.now().minusMinutes(getTimeoutMinutes(run)));\n+        }\n+\n+        private Long getTimeoutMinutes(final StopServerlessRun run) {\n+            return Objects.nonNull(run.getStopAfter())\n+                    ? run.getStopAfter()\n+                    : preferenceManager.getPreference(SystemPreferences.LAUNCH_SERVERLESS_STOP_TIMEOUT).longValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba0cafd86038eac71f5ea92c6d6fdafb2499ccc6"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4MjY5OQ==", "bodyText": "Thanks, done", "url": "https://github.com/epam/cloud-pipeline/pull/1222#discussion_r457982699", "createdAt": "2020-07-21T10:03:38Z", "author": {"login": "ekazachkova"}, "path": "api/src/main/java/com/epam/pipeline/manager/cluster/performancemonitoring/ResourceMonitoringManager.java", "diffHunk": "@@ -408,11 +409,21 @@ private void setInstanceTypeMap(final Map<String, InstanceType> instanceTypeMap)\n         }\n \n         private void processServerlessRuns() {\n-            final Integer timeout = preferenceManager.getPreference(SystemPreferences.LAUNCH_SERVERLESS_STOP_TIMEOUT);\n-            final LocalDateTime maxLastUpdate = LocalDateTime.now().minusMinutes(timeout);\n-            final List<PipelineRun> runs = ListUtils.emptyIfNull(\n-                    pipelineRunManager.loadExpiredServerlessRuns(maxLastUpdate));\n-            runs.forEach(run -> pipelineRunManager.stopServerlessRun(run.getId()));\n+            final List<StopServerlessRun> activeServerlessRuns = ListUtils.emptyIfNull(\n+                    pipelineRunManager.loadActiveServerlessRuns());\n+            activeServerlessRuns.stream()\n+                    .filter(this::serverlessRunIsExpired)\n+                    .forEach(run -> pipelineRunManager.stopServerlessRun(run.getId()));\n+        }\n+\n+        private boolean serverlessRunIsExpired(final StopServerlessRun run) {\n+            return run.getLastUpdate().isBefore(LocalDateTime.now().minusMinutes(getTimeoutMinutes(run)));\n+        }\n+\n+        private Long getTimeoutMinutes(final StopServerlessRun run) {\n+            return Objects.nonNull(run.getStopAfter())\n+                    ? run.getStopAfter()\n+                    : preferenceManager.getPreference(SystemPreferences.LAUNCH_SERVERLESS_STOP_TIMEOUT).longValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2Nzg3NQ=="}, "originalCommit": {"oid": "ba0cafd86038eac71f5ea92c6d6fdafb2499ccc6"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 403, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}