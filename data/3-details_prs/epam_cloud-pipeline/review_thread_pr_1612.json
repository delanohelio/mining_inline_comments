{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4NjE1OTkw", "number": 1612, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMzo0MTozOFrOE-qJKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMDowNzo0MVrOE_iz5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTM3NjQyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/epam/pipeline/acl/metadata/MetadataEntityApiService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMzo0MTozOFrOH77lCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMzo0MTozOFrOH77lCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYwNDE2OQ==", "bodyText": "I wonder how it ended up there :)\nIt is a good practice to review your pull request changes right before submitting it on GitHub. You can do this either in your IDE or in GitHub GUI during pull request creation.", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r532604169", "createdAt": "2020-11-30T13:41:38Z", "author": {"login": "tcibinan"}, "path": "api/src/main/java/com/epam/pipeline/acl/metadata/MetadataEntityApiService.java", "diffHunk": "@@ -129,7 +132,7 @@ public MetadataEntity deleteMetadataItemKey(Long id, String key) {\n     public Collection<MetadataClassDescription> getMetadataFields(Long folderId) {\n         return metadataEntityManager.getMetadataFields(folderId);\n     }\n-\n+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "245aa44ff1dcd4ead7a52e74d749c446a0dcd793"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTU5MDU0OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataApiServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDoyOTozOVrOH79mig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDoyOTozOVrOH79mig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYzNzMyMg==", "bodyText": "Looks like we can use mockLoadEntity here as well.", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r532637322", "createdAt": "2020-11-30T14:29:39Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataApiServiceTest.java", "diffHunk": "@@ -0,0 +1,453 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.metadata;\n+\n+import com.epam.pipeline.controller.vo.EntityVO;\n+import com.epam.pipeline.controller.vo.MetadataVO;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.metadata.MetadataEntry;\n+import com.epam.pipeline.entity.metadata.MetadataEntryWithIssuesCount;\n+import com.epam.pipeline.entity.security.acl.AclClass;\n+import com.epam.pipeline.manager.EntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.datastorage.DatastorageCreatorUtils;\n+import com.epam.pipeline.test.creator.metadata.MetadataCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.mock.web.MockMultipartFile;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.web.multipart.MultipartFile;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_SET;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class MetadataApiServiceTest extends AbstractAclTest {\n+\n+    private static final AclClass ENTITY_ACL_CLASS = AclClass.DATA_STORAGE;\n+\n+    private final MetadataVO metadataVO = MetadataCreatorUtils.getMetadataVO(ENTITY_ACL_CLASS);\n+    private final AbstractSecuredEntity entity = DatastorageCreatorUtils.getS3bucketDataStorage(ID, SIMPLE_USER);\n+    private final AbstractSecuredEntity anotherEntity =\n+            DatastorageCreatorUtils.getS3bucketDataStorage(ID_2, ANOTHER_SIMPLE_USER);\n+    private final EntityVO entityVO = SecurityCreatorUtils.getEntityVO(ID, ENTITY_ACL_CLASS);\n+    private final EntityVO anotherEntityVO = SecurityCreatorUtils.getEntityVO(ID_2, ENTITY_ACL_CLASS);\n+    private final MetadataEntry metadataEntry = MetadataCreatorUtils.getMetadataEntry(entityVO);\n+    private final MultipartFile file = new MockMultipartFile(TEST_STRING, TEST_STRING.getBytes());\n+    private final MetadataEntryWithIssuesCount entry = MetadataCreatorUtils.getMetadataEntryWithIssuesCount(entityVO);\n+    private final MetadataEntryWithIssuesCount anotherEntry =\n+            MetadataCreatorUtils.getMetadataEntryWithIssuesCount(anotherEntityVO);\n+\n+    private final List<MetadataEntry> metadataEntries = Collections.singletonList(metadataEntry);\n+    private final List<EntityVO> entityVOList = Collections.singletonList(entityVO);\n+\n+    @Autowired\n+    private MetadataApiService metadataApiService;\n+\n+    @Autowired\n+    private MetadataManager mockMetadataManager;\n+\n+    @Autowired\n+    private EntityManager mockEntityManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataItemKeyForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKey(metadataVO);\n+\n+        assertThat(metadataApiService.updateMetadataItemKey(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateMetadataItemKeyWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKey(metadataVO);\n+        doReturn(entity).when(mockEntityManager).load(ENTITY_ACL_CLASS, ID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "245aa44ff1dcd4ead7a52e74d749c446a0dcd793"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTYwMDkxOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataApiServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDozMTo1M1rOH79s1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDozMTo1M1rOH79s1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYzODkzMg==", "bodyText": "I suppose that these two test scenarios can be called shouldUpdateMetadataItemKeyForOwner and shouldDenyUpdateMetadataItemKeyForNonOwner. It clarifies what kind of permissions are tested.\nCould you please also check other test methods for the same issue in the test class below.", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r532638932", "createdAt": "2020-11-30T14:31:53Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataApiServiceTest.java", "diffHunk": "@@ -0,0 +1,453 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.metadata;\n+\n+import com.epam.pipeline.controller.vo.EntityVO;\n+import com.epam.pipeline.controller.vo.MetadataVO;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.metadata.MetadataEntry;\n+import com.epam.pipeline.entity.metadata.MetadataEntryWithIssuesCount;\n+import com.epam.pipeline.entity.security.acl.AclClass;\n+import com.epam.pipeline.manager.EntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.datastorage.DatastorageCreatorUtils;\n+import com.epam.pipeline.test.creator.metadata.MetadataCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.mock.web.MockMultipartFile;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.web.multipart.MultipartFile;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_SET;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class MetadataApiServiceTest extends AbstractAclTest {\n+\n+    private static final AclClass ENTITY_ACL_CLASS = AclClass.DATA_STORAGE;\n+\n+    private final MetadataVO metadataVO = MetadataCreatorUtils.getMetadataVO(ENTITY_ACL_CLASS);\n+    private final AbstractSecuredEntity entity = DatastorageCreatorUtils.getS3bucketDataStorage(ID, SIMPLE_USER);\n+    private final AbstractSecuredEntity anotherEntity =\n+            DatastorageCreatorUtils.getS3bucketDataStorage(ID_2, ANOTHER_SIMPLE_USER);\n+    private final EntityVO entityVO = SecurityCreatorUtils.getEntityVO(ID, ENTITY_ACL_CLASS);\n+    private final EntityVO anotherEntityVO = SecurityCreatorUtils.getEntityVO(ID_2, ENTITY_ACL_CLASS);\n+    private final MetadataEntry metadataEntry = MetadataCreatorUtils.getMetadataEntry(entityVO);\n+    private final MultipartFile file = new MockMultipartFile(TEST_STRING, TEST_STRING.getBytes());\n+    private final MetadataEntryWithIssuesCount entry = MetadataCreatorUtils.getMetadataEntryWithIssuesCount(entityVO);\n+    private final MetadataEntryWithIssuesCount anotherEntry =\n+            MetadataCreatorUtils.getMetadataEntryWithIssuesCount(anotherEntityVO);\n+\n+    private final List<MetadataEntry> metadataEntries = Collections.singletonList(metadataEntry);\n+    private final List<EntityVO> entityVOList = Collections.singletonList(entityVO);\n+\n+    @Autowired\n+    private MetadataApiService metadataApiService;\n+\n+    @Autowired\n+    private MetadataManager mockMetadataManager;\n+\n+    @Autowired\n+    private EntityManager mockEntityManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataItemKeyForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKey(metadataVO);\n+\n+        assertThat(metadataApiService.updateMetadataItemKey(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateMetadataItemKeyWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKey(metadataVO);\n+        doReturn(entity).when(mockEntityManager).load(ENTITY_ACL_CLASS, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.updateMetadataItemKey(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataItemKeyWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKey(metadataVO);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> metadataApiService.updateMetadataItemKey(metadataVO));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "245aa44ff1dcd4ead7a52e74d749c446a0dcd793"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTY1MjM4OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/test/acl/AbstractAclTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDo0Mjo1MFrOH7-Mfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDo0Mjo1MFrOH7-Mfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY0NzAzOQ==", "bodyText": "I'm wondering if we can remove existing mockAuthUser method and rename mockAuthentication to mockAuthUser. I don't think that there is a need to have both methods.", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r532647039", "createdAt": "2020-11-30T14:42:50Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/test/acl/AbstractAclTest.java", "diffHunk": "@@ -148,7 +149,16 @@ public Sid toSid() {\n         return list;\n     }\n \n+    protected void mockAuthentication(final String user) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "245aa44ff1dcd4ead7a52e74d749c446a0dcd793"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTc2Mzk5OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataApiServiceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNTowNTo1NVrOH7_QwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzoxNTowNVrOH8sBAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY2NDUxMw==", "bodyText": "What do you think about moving mockAuthentication call to the test class setup method? User name can be retrieved from the security context. It will also require to change some of the method @WithMockUser annotations.", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r532664513", "createdAt": "2020-11-30T15:05:55Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataApiServiceTest.java", "diffHunk": "@@ -0,0 +1,453 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.metadata;\n+\n+import com.epam.pipeline.controller.vo.EntityVO;\n+import com.epam.pipeline.controller.vo.MetadataVO;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.metadata.MetadataEntry;\n+import com.epam.pipeline.entity.metadata.MetadataEntryWithIssuesCount;\n+import com.epam.pipeline.entity.security.acl.AclClass;\n+import com.epam.pipeline.manager.EntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.datastorage.DatastorageCreatorUtils;\n+import com.epam.pipeline.test.creator.metadata.MetadataCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.mock.web.MockMultipartFile;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.web.multipart.MultipartFile;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_SET;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class MetadataApiServiceTest extends AbstractAclTest {\n+\n+    private static final AclClass ENTITY_ACL_CLASS = AclClass.DATA_STORAGE;\n+\n+    private final MetadataVO metadataVO = MetadataCreatorUtils.getMetadataVO(ENTITY_ACL_CLASS);\n+    private final AbstractSecuredEntity entity = DatastorageCreatorUtils.getS3bucketDataStorage(ID, SIMPLE_USER);\n+    private final AbstractSecuredEntity anotherEntity =\n+            DatastorageCreatorUtils.getS3bucketDataStorage(ID_2, ANOTHER_SIMPLE_USER);\n+    private final EntityVO entityVO = SecurityCreatorUtils.getEntityVO(ID, ENTITY_ACL_CLASS);\n+    private final EntityVO anotherEntityVO = SecurityCreatorUtils.getEntityVO(ID_2, ENTITY_ACL_CLASS);\n+    private final MetadataEntry metadataEntry = MetadataCreatorUtils.getMetadataEntry(entityVO);\n+    private final MultipartFile file = new MockMultipartFile(TEST_STRING, TEST_STRING.getBytes());\n+    private final MetadataEntryWithIssuesCount entry = MetadataCreatorUtils.getMetadataEntryWithIssuesCount(entityVO);\n+    private final MetadataEntryWithIssuesCount anotherEntry =\n+            MetadataCreatorUtils.getMetadataEntryWithIssuesCount(anotherEntityVO);\n+\n+    private final List<MetadataEntry> metadataEntries = Collections.singletonList(metadataEntry);\n+    private final List<EntityVO> entityVOList = Collections.singletonList(entityVO);\n+\n+    @Autowired\n+    private MetadataApiService metadataApiService;\n+\n+    @Autowired\n+    private MetadataManager mockMetadataManager;\n+\n+    @Autowired\n+    private EntityManager mockEntityManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataItemKeyForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKey(metadataVO);\n+\n+        assertThat(metadataApiService.updateMetadataItemKey(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateMetadataItemKeyWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKey(metadataVO);\n+        doReturn(entity).when(mockEntityManager).load(ENTITY_ACL_CLASS, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.updateMetadataItemKey(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataItemKeyWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKey(metadataVO);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> metadataApiService.updateMetadataItemKey(metadataVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataItemKeysForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKeys(metadataVO);\n+\n+        assertThat(metadataApiService.updateMetadataItemKeys(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateMetadataItemKeysWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKeys(metadataVO);\n+        mockLoadEntity(entity, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.updateMetadataItemKeys(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataItemKeysWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKeys(metadataVO);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> metadataApiService.updateMetadataItemKeys(metadataVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataItemForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItem(metadataVO);\n+\n+        assertThat(metadataApiService.updateMetadataItem(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateMetadataItemWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItem(metadataVO);\n+        mockLoadEntity(entity, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.updateMetadataItem(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataItemWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItem(metadataVO);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> metadataApiService.updateMetadataItem(metadataVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldListMetadataItemsForAdmin() {\n+        doReturn(metadataEntries).when(mockMetadataManager).listMetadataItems(entityVOList);\n+\n+        assertThat(metadataApiService.listMetadataItems(entityVOList)).isEqualTo(metadataEntries);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListMetadataItemsWhenPermissionIsGranted() {\n+        initAclEntity(entity, AclPermission.READ);\n+        doReturn(metadataEntries).when(mockMetadataManager).listMetadataItems(entityVOList);\n+        mockLoadEntity(entity, ID);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.listMetadataItems(entityVOList)).isEqualTo(metadataEntries);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyListMetadataItemsWhenPermissionIsNotGranted() {\n+        initAclEntity(entity);\n+        doReturn(metadataEntries).when(mockMetadataManager).listMetadataItems(entityVOList);\n+        mockLoadEntity(entity, ID);\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> metadataApiService.listMetadataItems(entityVOList));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataItemKeyForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItemKey(entityVO, TEST_STRING);\n+\n+        assertThat(metadataApiService.deleteMetadataItemKey(entityVO, TEST_STRING)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDeleteMetadataItemKeyWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItemKey(entityVO, TEST_STRING);\n+        mockLoadEntity(entity, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.deleteMetadataItemKey(entityVO, TEST_STRING)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataItemKeyWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItemKey(entityVO, TEST_STRING);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                metadataApiService.deleteMetadataItemKey(entityVO, TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataItemForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItem(entityVO);\n+\n+        assertThat(metadataApiService.deleteMetadataItem(entityVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDeleteMetadataItemWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItem(entityVO);\n+        mockLoadEntity(entity, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.deleteMetadataItem(entityVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataItemWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItem(entityVO);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> metadataApiService.deleteMetadataItem(entityVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataItemKeysForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItemKeys(metadataVO);\n+\n+        assertThat(metadataApiService.deleteMetadataItemKeys(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDeleteMetadataItemKeysWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItemKeys(metadataVO);\n+        mockLoadEntity(entity, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.deleteMetadataItemKeys(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataItemKeysWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItemKeys(metadataVO);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> metadataApiService.deleteMetadataItemKeys(metadataVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldFindMetadataEntityIdByNameForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).findMetadataEntryByNameOrId(TEST_STRING, ENTITY_ACL_CLASS);\n+\n+        assertThat(metadataApiService.findMetadataEntityIdByName(TEST_STRING, ENTITY_ACL_CLASS))\n+                .isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldFindMetadataEntityIdByNameWhenPermissionIsGranted() {\n+        initAclEntity(entity, AclPermission.READ);\n+        doReturn(metadataEntry).when(mockMetadataManager).findMetadataEntryByNameOrId(TEST_STRING, ENTITY_ACL_CLASS);\n+        mockLoadEntity(entity, ID);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.findMetadataEntityIdByName(TEST_STRING, ENTITY_ACL_CLASS))\n+                .isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyFindMetadataEntityIdByNameWhenPermissionIsNotGranted() {\n+        initAclEntity(entity);\n+        doReturn(metadataEntry).when(mockMetadataManager).findMetadataEntryByNameOrId(TEST_STRING, ENTITY_ACL_CLASS);\n+        mockSecurityContext();\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                metadataApiService.findMetadataEntityIdByName(TEST_STRING, ENTITY_ACL_CLASS));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUploadMetadataFromFileForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).uploadMetadataFromFile(entityVO, file, true);\n+\n+        assertThat(metadataApiService.uploadMetadataFromFile(entityVO, file, true)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUploadMetadataFromFileWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).uploadMetadataFromFile(entityVO, file, true);\n+        mockLoadEntity(entity, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.uploadMetadataFromFile(entityVO, file, true)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUploadMetadataFromFileWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).uploadMetadataFromFile(entityVO, file, true);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                metadataApiService.uploadMetadataFromFile(entityVO, file, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadEntitiesMetadataFromFolderForAdmin() {\n+        doReturn(mutableListOf(entry)).when(mockMetadataManager).loadEntitiesMetadataFromFolder(ID);\n+\n+        assertThat(metadataApiService.loadEntitiesMetadataFromFolder(ID)).hasSize(1).contains(entry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadEntitiesMetadataFromFolderWhenPermissionIsGranted() {\n+        initAclEntity(entity, AclPermission.READ);\n+        doReturn(mutableListOf(entry)).when(mockMetadataManager).loadEntitiesMetadataFromFolder(ID);\n+        mockLoadEntity(entity, ID);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.loadEntitiesMetadataFromFolder(ID)).hasSize(1).contains(entry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadEntitiesMetadataFromFolderWhichPermissionIsGranted() {\n+        initAclEntity(entity, AclPermission.READ);\n+        initAclEntity(anotherEntity);\n+        doReturn(mutableListOf(entry, anotherEntry)).when(mockMetadataManager).loadEntitiesMetadataFromFolder(ID);\n+        mockLoadEntity(entity, ID);\n+        mockLoadEntity(anotherEntity, ID_2);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.loadEntitiesMetadataFromFolder(ID)).hasSize(1).contains(entry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyLoadEntitiesMetadataFromFolderWhenPermissionIsNotGranted() {\n+        initAclEntity(anotherEntity);\n+        doReturn(mutableListOf(anotherEntry)).when(mockMetadataManager).loadEntitiesMetadataFromFolder(ID);\n+        mockLoadEntity(anotherEntity, ID_2);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.loadEntitiesMetadataFromFolder(ID)).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldSearchMetadataByClassAndKeyValueForAdmin() {\n+        doReturn(mutableListOf(entityVO)).when(mockMetadataManager)\n+                .searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING);\n+\n+        assertThat(metadataApiService.searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING))\n+                .hasSize(1).contains(entityVO);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldSearchMetadataByClassAndKeyValueWhenPermissionIsGranted() {\n+        initAclEntity(entity, AclPermission.READ);\n+        doReturn(mutableListOf(entityVO)).when(mockMetadataManager)\n+                .searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING);\n+        mockLoadEntity(entity, ID);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING))\n+                .hasSize(1).contains(entityVO);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldSearchMetadataByClassAndKeyValueWhichPermissionIsGranted() {\n+        initAclEntity(entity, AclPermission.READ);\n+        initAclEntity(anotherEntity);\n+        doReturn(mutableListOf(entityVO, anotherEntityVO)).when(mockMetadataManager)\n+                .searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING);\n+        mockLoadEntity(entity, ID);\n+        mockLoadEntity(anotherEntity, ID_2);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING))\n+                .hasSize(1).contains(entityVO);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenySearchMetadataByClassAndKeyValueWhenPermissionIsNotGranted() {\n+        initAclEntity(anotherEntity);\n+        doReturn(mutableListOf(anotherEntityVO)).when(mockMetadataManager)\n+                .searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING);\n+        mockLoadEntity(anotherEntity, ID_2);\n+        mockAuthentication(SIMPLE_USER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "245aa44ff1dcd4ead7a52e74d749c446a0dcd793"}, "originalPosition": 420}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM5Nzc2Mg==", "bodyText": "Discussed and refused.", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r533397762", "createdAt": "2020-12-01T13:15:05Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataApiServiceTest.java", "diffHunk": "@@ -0,0 +1,453 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.metadata;\n+\n+import com.epam.pipeline.controller.vo.EntityVO;\n+import com.epam.pipeline.controller.vo.MetadataVO;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.metadata.MetadataEntry;\n+import com.epam.pipeline.entity.metadata.MetadataEntryWithIssuesCount;\n+import com.epam.pipeline.entity.security.acl.AclClass;\n+import com.epam.pipeline.manager.EntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.datastorage.DatastorageCreatorUtils;\n+import com.epam.pipeline.test.creator.metadata.MetadataCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.mock.web.MockMultipartFile;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.web.multipart.MultipartFile;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_SET;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class MetadataApiServiceTest extends AbstractAclTest {\n+\n+    private static final AclClass ENTITY_ACL_CLASS = AclClass.DATA_STORAGE;\n+\n+    private final MetadataVO metadataVO = MetadataCreatorUtils.getMetadataVO(ENTITY_ACL_CLASS);\n+    private final AbstractSecuredEntity entity = DatastorageCreatorUtils.getS3bucketDataStorage(ID, SIMPLE_USER);\n+    private final AbstractSecuredEntity anotherEntity =\n+            DatastorageCreatorUtils.getS3bucketDataStorage(ID_2, ANOTHER_SIMPLE_USER);\n+    private final EntityVO entityVO = SecurityCreatorUtils.getEntityVO(ID, ENTITY_ACL_CLASS);\n+    private final EntityVO anotherEntityVO = SecurityCreatorUtils.getEntityVO(ID_2, ENTITY_ACL_CLASS);\n+    private final MetadataEntry metadataEntry = MetadataCreatorUtils.getMetadataEntry(entityVO);\n+    private final MultipartFile file = new MockMultipartFile(TEST_STRING, TEST_STRING.getBytes());\n+    private final MetadataEntryWithIssuesCount entry = MetadataCreatorUtils.getMetadataEntryWithIssuesCount(entityVO);\n+    private final MetadataEntryWithIssuesCount anotherEntry =\n+            MetadataCreatorUtils.getMetadataEntryWithIssuesCount(anotherEntityVO);\n+\n+    private final List<MetadataEntry> metadataEntries = Collections.singletonList(metadataEntry);\n+    private final List<EntityVO> entityVOList = Collections.singletonList(entityVO);\n+\n+    @Autowired\n+    private MetadataApiService metadataApiService;\n+\n+    @Autowired\n+    private MetadataManager mockMetadataManager;\n+\n+    @Autowired\n+    private EntityManager mockEntityManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataItemKeyForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKey(metadataVO);\n+\n+        assertThat(metadataApiService.updateMetadataItemKey(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateMetadataItemKeyWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKey(metadataVO);\n+        doReturn(entity).when(mockEntityManager).load(ENTITY_ACL_CLASS, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.updateMetadataItemKey(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataItemKeyWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKey(metadataVO);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> metadataApiService.updateMetadataItemKey(metadataVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataItemKeysForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKeys(metadataVO);\n+\n+        assertThat(metadataApiService.updateMetadataItemKeys(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateMetadataItemKeysWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKeys(metadataVO);\n+        mockLoadEntity(entity, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.updateMetadataItemKeys(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataItemKeysWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKeys(metadataVO);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> metadataApiService.updateMetadataItemKeys(metadataVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataItemForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItem(metadataVO);\n+\n+        assertThat(metadataApiService.updateMetadataItem(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateMetadataItemWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItem(metadataVO);\n+        mockLoadEntity(entity, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.updateMetadataItem(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataItemWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItem(metadataVO);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> metadataApiService.updateMetadataItem(metadataVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldListMetadataItemsForAdmin() {\n+        doReturn(metadataEntries).when(mockMetadataManager).listMetadataItems(entityVOList);\n+\n+        assertThat(metadataApiService.listMetadataItems(entityVOList)).isEqualTo(metadataEntries);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListMetadataItemsWhenPermissionIsGranted() {\n+        initAclEntity(entity, AclPermission.READ);\n+        doReturn(metadataEntries).when(mockMetadataManager).listMetadataItems(entityVOList);\n+        mockLoadEntity(entity, ID);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.listMetadataItems(entityVOList)).isEqualTo(metadataEntries);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyListMetadataItemsWhenPermissionIsNotGranted() {\n+        initAclEntity(entity);\n+        doReturn(metadataEntries).when(mockMetadataManager).listMetadataItems(entityVOList);\n+        mockLoadEntity(entity, ID);\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> metadataApiService.listMetadataItems(entityVOList));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataItemKeyForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItemKey(entityVO, TEST_STRING);\n+\n+        assertThat(metadataApiService.deleteMetadataItemKey(entityVO, TEST_STRING)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDeleteMetadataItemKeyWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItemKey(entityVO, TEST_STRING);\n+        mockLoadEntity(entity, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.deleteMetadataItemKey(entityVO, TEST_STRING)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataItemKeyWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItemKey(entityVO, TEST_STRING);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                metadataApiService.deleteMetadataItemKey(entityVO, TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataItemForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItem(entityVO);\n+\n+        assertThat(metadataApiService.deleteMetadataItem(entityVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDeleteMetadataItemWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItem(entityVO);\n+        mockLoadEntity(entity, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.deleteMetadataItem(entityVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataItemWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItem(entityVO);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> metadataApiService.deleteMetadataItem(entityVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataItemKeysForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItemKeys(metadataVO);\n+\n+        assertThat(metadataApiService.deleteMetadataItemKeys(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDeleteMetadataItemKeysWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItemKeys(metadataVO);\n+        mockLoadEntity(entity, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.deleteMetadataItemKeys(metadataVO)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataItemKeysWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).deleteMetadataItemKeys(metadataVO);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> metadataApiService.deleteMetadataItemKeys(metadataVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldFindMetadataEntityIdByNameForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).findMetadataEntryByNameOrId(TEST_STRING, ENTITY_ACL_CLASS);\n+\n+        assertThat(metadataApiService.findMetadataEntityIdByName(TEST_STRING, ENTITY_ACL_CLASS))\n+                .isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldFindMetadataEntityIdByNameWhenPermissionIsGranted() {\n+        initAclEntity(entity, AclPermission.READ);\n+        doReturn(metadataEntry).when(mockMetadataManager).findMetadataEntryByNameOrId(TEST_STRING, ENTITY_ACL_CLASS);\n+        mockLoadEntity(entity, ID);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.findMetadataEntityIdByName(TEST_STRING, ENTITY_ACL_CLASS))\n+                .isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyFindMetadataEntityIdByNameWhenPermissionIsNotGranted() {\n+        initAclEntity(entity);\n+        doReturn(metadataEntry).when(mockMetadataManager).findMetadataEntryByNameOrId(TEST_STRING, ENTITY_ACL_CLASS);\n+        mockSecurityContext();\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                metadataApiService.findMetadataEntityIdByName(TEST_STRING, ENTITY_ACL_CLASS));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUploadMetadataFromFileForAdmin() {\n+        doReturn(metadataEntry).when(mockMetadataManager).uploadMetadataFromFile(entityVO, file, true);\n+\n+        assertThat(metadataApiService.uploadMetadataFromFile(entityVO, file, true)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUploadMetadataFromFileWhenPermissionIsGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).uploadMetadataFromFile(entityVO, file, true);\n+        mockLoadEntity(entity, ID);\n+        mockAuthUser(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.uploadMetadataFromFile(entityVO, file, true)).isEqualTo(metadataEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUploadMetadataFromFileWhenPermissionIsNotGranted() {\n+        doReturn(metadataEntry).when(mockMetadataManager).uploadMetadataFromFile(entityVO, file, true);\n+        mockLoadEntity(entity, ID);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                metadataApiService.uploadMetadataFromFile(entityVO, file, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadEntitiesMetadataFromFolderForAdmin() {\n+        doReturn(mutableListOf(entry)).when(mockMetadataManager).loadEntitiesMetadataFromFolder(ID);\n+\n+        assertThat(metadataApiService.loadEntitiesMetadataFromFolder(ID)).hasSize(1).contains(entry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadEntitiesMetadataFromFolderWhenPermissionIsGranted() {\n+        initAclEntity(entity, AclPermission.READ);\n+        doReturn(mutableListOf(entry)).when(mockMetadataManager).loadEntitiesMetadataFromFolder(ID);\n+        mockLoadEntity(entity, ID);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.loadEntitiesMetadataFromFolder(ID)).hasSize(1).contains(entry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadEntitiesMetadataFromFolderWhichPermissionIsGranted() {\n+        initAclEntity(entity, AclPermission.READ);\n+        initAclEntity(anotherEntity);\n+        doReturn(mutableListOf(entry, anotherEntry)).when(mockMetadataManager).loadEntitiesMetadataFromFolder(ID);\n+        mockLoadEntity(entity, ID);\n+        mockLoadEntity(anotherEntity, ID_2);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.loadEntitiesMetadataFromFolder(ID)).hasSize(1).contains(entry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyLoadEntitiesMetadataFromFolderWhenPermissionIsNotGranted() {\n+        initAclEntity(anotherEntity);\n+        doReturn(mutableListOf(anotherEntry)).when(mockMetadataManager).loadEntitiesMetadataFromFolder(ID);\n+        mockLoadEntity(anotherEntity, ID_2);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.loadEntitiesMetadataFromFolder(ID)).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldSearchMetadataByClassAndKeyValueForAdmin() {\n+        doReturn(mutableListOf(entityVO)).when(mockMetadataManager)\n+                .searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING);\n+\n+        assertThat(metadataApiService.searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING))\n+                .hasSize(1).contains(entityVO);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldSearchMetadataByClassAndKeyValueWhenPermissionIsGranted() {\n+        initAclEntity(entity, AclPermission.READ);\n+        doReturn(mutableListOf(entityVO)).when(mockMetadataManager)\n+                .searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING);\n+        mockLoadEntity(entity, ID);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING))\n+                .hasSize(1).contains(entityVO);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldSearchMetadataByClassAndKeyValueWhichPermissionIsGranted() {\n+        initAclEntity(entity, AclPermission.READ);\n+        initAclEntity(anotherEntity);\n+        doReturn(mutableListOf(entityVO, anotherEntityVO)).when(mockMetadataManager)\n+                .searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING);\n+        mockLoadEntity(entity, ID);\n+        mockLoadEntity(anotherEntity, ID_2);\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(metadataApiService.searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING))\n+                .hasSize(1).contains(entityVO);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenySearchMetadataByClassAndKeyValueWhenPermissionIsNotGranted() {\n+        initAclEntity(anotherEntity);\n+        doReturn(mutableListOf(anotherEntityVO)).when(mockMetadataManager)\n+                .searchMetadataByClassAndKeyValue(ENTITY_ACL_CLASS, TEST_STRING, TEST_STRING);\n+        mockLoadEntity(anotherEntity, ID_2);\n+        mockAuthentication(SIMPLE_USER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY2NDUxMw=="}, "originalCommit": {"oid": "245aa44ff1dcd4ead7a52e74d749c446a0dcd793"}, "originalPosition": 420}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTc5OTczOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataEntityApiServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToxMzoyMlrOH7_mbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToxMzoyMlrOH7_mbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY3MDA2MA==", "bodyText": "It would be nice to extract FireCloudClass.PARTICIPANT to the class field.", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r532670060", "createdAt": "2020-11-30T15:13:22Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataEntityApiServiceTest.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.metadata;\n+\n+import com.epam.pipeline.controller.PagedResult;\n+import com.epam.pipeline.controller.vo.metadata.MetadataEntityVO;\n+import com.epam.pipeline.entity.metadata.FireCloudClass;\n+import com.epam.pipeline.entity.metadata.MetadataClass;\n+import com.epam.pipeline.entity.metadata.MetadataClassDescription;\n+import com.epam.pipeline.entity.metadata.MetadataEntity;\n+import com.epam.pipeline.entity.metadata.MetadataField;\n+import com.epam.pipeline.entity.metadata.MetadataFilter;\n+import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.security.acl.AclClass;\n+import com.epam.pipeline.manager.EntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataDownloadManager;\n+import com.epam.pipeline.manager.metadata.MetadataEntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataUploadManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.folder.FolderCreatorUtils;\n+import com.epam.pipeline.test.creator.metadata.MetadataCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.mock.web.MockMultipartFile;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.web.multipart.MultipartFile;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_LONG_SET;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_MAP;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+\n+public class MetadataEntityApiServiceTest extends AbstractAclTest {\n+\n+    private final MetadataClass metadataClass = MetadataCreatorUtils.getMetadataClass();\n+    private final MetadataEntityVO metadataEntityVO = MetadataCreatorUtils.getMetadataEntityVO(ID);\n+    private final Folder folder = FolderCreatorUtils.getFolder(ID, SIMPLE_USER);\n+    private final MetadataEntity metadataEntity = MetadataCreatorUtils.getMetadataEntity(ID, folder);\n+    private final PagedResult<List<MetadataEntity>> pagedResult = MetadataCreatorUtils.getPagedResult();\n+    private final MetadataFilter metadataFilter = MetadataCreatorUtils.getMetadataFilter(ID);\n+    private final MetadataField metadataField = MetadataCreatorUtils.getMetadataField();\n+    private final MultipartFile file = new MockMultipartFile(TEST_STRING, TEST_STRING.getBytes());\n+    private final InputStream inputStream = new ByteArrayInputStream(TEST_STRING.getBytes());\n+\n+    private final List<MetadataEntity> metadataEntities = Collections.singletonList(metadataEntity);\n+    private final List<MetadataField> metadataFields = Collections.singletonList(metadataField);\n+    private final List<MetadataClassDescription> descriptions =\n+            Collections.singletonList(MetadataCreatorUtils.getMetadataClassDescription());\n+\n+    @Autowired\n+    private MetadataEntityApiService entityApiService;\n+\n+    @Autowired\n+    private MetadataEntityManager mockMetadataEntityManager;\n+\n+    @Autowired\n+    private MetadataUploadManager mockMetadataUploadManager;\n+\n+    @Autowired\n+    private MetadataDownloadManager mockMetadataDownloadManager;\n+\n+    @Autowired\n+    private EntityManager mockEntityManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateMetadataClassForAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).createMetadataClass(TEST_STRING);\n+\n+        assertThat(entityApiService.createMetadataClass(TEST_STRING)).isEqualTo(metadataClass);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateMetadataClassForNotAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).createMetadataClass(TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.createMetadataClass(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataClassForAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).deleteMetadataClass(ID);\n+\n+        assertThat(entityApiService.deleteMetadataClass(ID)).isEqualTo(metadataClass);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataClassForNotAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).deleteMetadataClass(ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.deleteMetadataClass(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataClassForAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).updateExternalClassName(ID, FireCloudClass.PARTICIPANT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "245aa44ff1dcd4ead7a52e74d749c446a0dcd793"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTgxODUyOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataEntityApiServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToxNzoxM1rOH7_x8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToxNzoxM1rOH7_x8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY3MzAxMA==", "bodyText": "Let's add test for MetadataEntityApiService.loadAllMetadataClasses even if there is no acl on the method yet. Let's test that it works for a regular user.", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r532673010", "createdAt": "2020-11-30T15:17:13Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataEntityApiServiceTest.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.metadata;\n+\n+import com.epam.pipeline.controller.PagedResult;\n+import com.epam.pipeline.controller.vo.metadata.MetadataEntityVO;\n+import com.epam.pipeline.entity.metadata.FireCloudClass;\n+import com.epam.pipeline.entity.metadata.MetadataClass;\n+import com.epam.pipeline.entity.metadata.MetadataClassDescription;\n+import com.epam.pipeline.entity.metadata.MetadataEntity;\n+import com.epam.pipeline.entity.metadata.MetadataField;\n+import com.epam.pipeline.entity.metadata.MetadataFilter;\n+import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.security.acl.AclClass;\n+import com.epam.pipeline.manager.EntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataDownloadManager;\n+import com.epam.pipeline.manager.metadata.MetadataEntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataUploadManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.folder.FolderCreatorUtils;\n+import com.epam.pipeline.test.creator.metadata.MetadataCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.mock.web.MockMultipartFile;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.web.multipart.MultipartFile;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_LONG_SET;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_MAP;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+\n+public class MetadataEntityApiServiceTest extends AbstractAclTest {\n+\n+    private final MetadataClass metadataClass = MetadataCreatorUtils.getMetadataClass();\n+    private final MetadataEntityVO metadataEntityVO = MetadataCreatorUtils.getMetadataEntityVO(ID);\n+    private final Folder folder = FolderCreatorUtils.getFolder(ID, SIMPLE_USER);\n+    private final MetadataEntity metadataEntity = MetadataCreatorUtils.getMetadataEntity(ID, folder);\n+    private final PagedResult<List<MetadataEntity>> pagedResult = MetadataCreatorUtils.getPagedResult();\n+    private final MetadataFilter metadataFilter = MetadataCreatorUtils.getMetadataFilter(ID);\n+    private final MetadataField metadataField = MetadataCreatorUtils.getMetadataField();\n+    private final MultipartFile file = new MockMultipartFile(TEST_STRING, TEST_STRING.getBytes());\n+    private final InputStream inputStream = new ByteArrayInputStream(TEST_STRING.getBytes());\n+\n+    private final List<MetadataEntity> metadataEntities = Collections.singletonList(metadataEntity);\n+    private final List<MetadataField> metadataFields = Collections.singletonList(metadataField);\n+    private final List<MetadataClassDescription> descriptions =\n+            Collections.singletonList(MetadataCreatorUtils.getMetadataClassDescription());\n+\n+    @Autowired\n+    private MetadataEntityApiService entityApiService;\n+\n+    @Autowired\n+    private MetadataEntityManager mockMetadataEntityManager;\n+\n+    @Autowired\n+    private MetadataUploadManager mockMetadataUploadManager;\n+\n+    @Autowired\n+    private MetadataDownloadManager mockMetadataDownloadManager;\n+\n+    @Autowired\n+    private EntityManager mockEntityManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateMetadataClassForAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).createMetadataClass(TEST_STRING);\n+\n+        assertThat(entityApiService.createMetadataClass(TEST_STRING)).isEqualTo(metadataClass);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateMetadataClassForNotAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).createMetadataClass(TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.createMetadataClass(TEST_STRING));\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "245aa44ff1dcd4ead7a52e74d749c446a0dcd793"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTg0ODY4OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataEntityApiServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToyMzoxOVrOH8AEHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToyMzoxOVrOH8AEHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY3NzY2MA==", "bodyText": "I imagine that READ permission would be enough in this case.", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r532677660", "createdAt": "2020-11-30T15:23:19Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataEntityApiServiceTest.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.metadata;\n+\n+import com.epam.pipeline.controller.PagedResult;\n+import com.epam.pipeline.controller.vo.metadata.MetadataEntityVO;\n+import com.epam.pipeline.entity.metadata.FireCloudClass;\n+import com.epam.pipeline.entity.metadata.MetadataClass;\n+import com.epam.pipeline.entity.metadata.MetadataClassDescription;\n+import com.epam.pipeline.entity.metadata.MetadataEntity;\n+import com.epam.pipeline.entity.metadata.MetadataField;\n+import com.epam.pipeline.entity.metadata.MetadataFilter;\n+import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.security.acl.AclClass;\n+import com.epam.pipeline.manager.EntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataDownloadManager;\n+import com.epam.pipeline.manager.metadata.MetadataEntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataUploadManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.folder.FolderCreatorUtils;\n+import com.epam.pipeline.test.creator.metadata.MetadataCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.mock.web.MockMultipartFile;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.web.multipart.MultipartFile;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_LONG_SET;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_MAP;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+\n+public class MetadataEntityApiServiceTest extends AbstractAclTest {\n+\n+    private final MetadataClass metadataClass = MetadataCreatorUtils.getMetadataClass();\n+    private final MetadataEntityVO metadataEntityVO = MetadataCreatorUtils.getMetadataEntityVO(ID);\n+    private final Folder folder = FolderCreatorUtils.getFolder(ID, SIMPLE_USER);\n+    private final MetadataEntity metadataEntity = MetadataCreatorUtils.getMetadataEntity(ID, folder);\n+    private final PagedResult<List<MetadataEntity>> pagedResult = MetadataCreatorUtils.getPagedResult();\n+    private final MetadataFilter metadataFilter = MetadataCreatorUtils.getMetadataFilter(ID);\n+    private final MetadataField metadataField = MetadataCreatorUtils.getMetadataField();\n+    private final MultipartFile file = new MockMultipartFile(TEST_STRING, TEST_STRING.getBytes());\n+    private final InputStream inputStream = new ByteArrayInputStream(TEST_STRING.getBytes());\n+\n+    private final List<MetadataEntity> metadataEntities = Collections.singletonList(metadataEntity);\n+    private final List<MetadataField> metadataFields = Collections.singletonList(metadataField);\n+    private final List<MetadataClassDescription> descriptions =\n+            Collections.singletonList(MetadataCreatorUtils.getMetadataClassDescription());\n+\n+    @Autowired\n+    private MetadataEntityApiService entityApiService;\n+\n+    @Autowired\n+    private MetadataEntityManager mockMetadataEntityManager;\n+\n+    @Autowired\n+    private MetadataUploadManager mockMetadataUploadManager;\n+\n+    @Autowired\n+    private MetadataDownloadManager mockMetadataDownloadManager;\n+\n+    @Autowired\n+    private EntityManager mockEntityManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateMetadataClassForAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).createMetadataClass(TEST_STRING);\n+\n+        assertThat(entityApiService.createMetadataClass(TEST_STRING)).isEqualTo(metadataClass);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateMetadataClassForNotAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).createMetadataClass(TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.createMetadataClass(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataClassForAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).deleteMetadataClass(ID);\n+\n+        assertThat(entityApiService.deleteMetadataClass(ID)).isEqualTo(metadataClass);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataClassForNotAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).deleteMetadataClass(ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.deleteMetadataClass(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataClassForAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).updateExternalClassName(ID, FireCloudClass.PARTICIPANT);\n+\n+        assertThat(entityApiService.updateExternalClassName(ID, FireCloudClass.PARTICIPANT)).isEqualTo(metadataClass);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataClassForNotAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).updateExternalClassName(ID, FireCloudClass.PARTICIPANT);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                entityApiService.updateExternalClassName(ID, FireCloudClass.PARTICIPANT));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataEntityForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThat(entityApiService.updateMetadataEntity(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateMetadataEntityWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThat(entityApiService.updateMetadataEntity(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataEntityWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.updateMetadataEntity(metadataEntityVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateMetadataEntityForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThat(entityApiService.createMetadataEntity(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = ENTITIES_MANAGER_ROLE)\n+    public void shouldCreateMetadataEntityWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThat(entityApiService.createMetadataEntity(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateMetadataEntityWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.updateMetadataEntity(metadataEntityVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadMetadataEntityForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).load(ID);\n+\n+        assertThat(entityApiService.loadMetadataEntity(ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadMetadataEntityWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);\n+        mockLoadEntities();\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(entityApiService.loadMetadataEntity(ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyLoadMetadataEntityWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        mockLoadEntities();\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.loadMetadataEntity(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataEntityForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataEntity(ID);\n+\n+        assertThat(entityApiService.deleteMetadataEntity(ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = ENTITIES_MANAGER_ROLE)\n+    public void shouldDeleteMetadataEntityWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataEntity(ID);\n+        mockLoadEntities();\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(entityApiService.deleteMetadataEntity(ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataEntityWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataEntity(ID);\n+        mockLoadEntities();\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.deleteMetadataEntity(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadMetadataEntityByClassForAdmin() {\n+        doReturn(metadataEntities).when(mockMetadataEntityManager)\n+                .loadMetadataEntityByClassNameAndFolderId(ID, TEST_STRING);\n+\n+        assertThat(entityApiService.loadMetadataEntityByClass(ID, TEST_STRING)).isEqualTo(metadataEntities);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadMetadataEntityByClassWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);\n+        doReturn(metadataEntities).when(mockMetadataEntityManager)\n+                .loadMetadataEntityByClassNameAndFolderId(ID, TEST_STRING);\n+\n+        assertThat(entityApiService.loadMetadataEntityByClass(ID, TEST_STRING)).isEqualTo(metadataEntities);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyLoadMetadataEntityByClassWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntities).when(mockMetadataEntityManager)\n+                .loadMetadataEntityByClassNameAndFolderId(ID, TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.loadMetadataEntityByClass(ID, TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataItemKeyForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataItemKey(metadataEntityVO);\n+\n+        assertThat(entityApiService.updateMetadataItemKey(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateMetadataItemKeyWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataItemKey(metadataEntityVO);\n+\n+        assertThat(entityApiService.updateMetadataItemKey(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataItemKeyWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataItemKey(metadataEntityVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.updateMetadataItemKey(metadataEntityVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataItemKeyForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataItemKey(ID, TEST_STRING);\n+\n+        assertThat(entityApiService.deleteMetadataItemKey(ID, TEST_STRING)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteMetadataItemKeyWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataItemKey(ID, TEST_STRING);\n+        mockLoadEntities();\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(entityApiService.deleteMetadataItemKey(ID, TEST_STRING)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataItemKeyWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataItemKey(ID, TEST_STRING);\n+        mockLoadEntities();\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.deleteMetadataItemKey(ID, TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataEntitiesForAdmin() {\n+        doReturn(TEST_LONG_SET).when(mockMetadataEntityManager).deleteMetadataEntities(TEST_LONG_SET);\n+\n+        assertThat(entityApiService.deleteMetadataEntities(TEST_LONG_SET)).isEqualTo(TEST_LONG_SET);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = ENTITIES_MANAGER_ROLE)\n+    public void shouldDeleteMetadataEntitiesWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(TEST_LONG_SET).when(mockMetadataEntityManager).deleteMetadataEntities(TEST_LONG_SET);\n+        mockLoadEntities();\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(entityApiService.deleteMetadataEntities(TEST_LONG_SET)).isEqualTo(TEST_LONG_SET);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataEntitiesWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(TEST_LONG_SET).when(mockMetadataEntityManager).deleteMetadataEntities(TEST_LONG_SET);\n+        mockLoadEntities();\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.deleteMetadataEntities(TEST_LONG_SET));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldFilterMetadataForAdmin() {\n+        doReturn(pagedResult).when(mockMetadataEntityManager).filterMetadata(metadataFilter);\n+\n+        assertThat(entityApiService.filterMetadata(metadataFilter)).isEqualTo(pagedResult);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldFilterMetadataWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "245aa44ff1dcd4ead7a52e74d749c446a0dcd793"}, "originalPosition": 376}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTg2MzU4OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataEntityApiServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToyNjoxMlrOH8ANKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToyNjoxMlrOH8ANKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY3OTk3Ng==", "bodyText": "Seems like WRITE permission is required for the testing method to work. I'm not pretty sure how it passes right now but it should be investigated.", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r532679976", "createdAt": "2020-11-30T15:26:12Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataEntityApiServiceTest.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.metadata;\n+\n+import com.epam.pipeline.controller.PagedResult;\n+import com.epam.pipeline.controller.vo.metadata.MetadataEntityVO;\n+import com.epam.pipeline.entity.metadata.FireCloudClass;\n+import com.epam.pipeline.entity.metadata.MetadataClass;\n+import com.epam.pipeline.entity.metadata.MetadataClassDescription;\n+import com.epam.pipeline.entity.metadata.MetadataEntity;\n+import com.epam.pipeline.entity.metadata.MetadataField;\n+import com.epam.pipeline.entity.metadata.MetadataFilter;\n+import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.security.acl.AclClass;\n+import com.epam.pipeline.manager.EntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataDownloadManager;\n+import com.epam.pipeline.manager.metadata.MetadataEntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataUploadManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.folder.FolderCreatorUtils;\n+import com.epam.pipeline.test.creator.metadata.MetadataCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.mock.web.MockMultipartFile;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.web.multipart.MultipartFile;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_LONG_SET;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_MAP;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+\n+public class MetadataEntityApiServiceTest extends AbstractAclTest {\n+\n+    private final MetadataClass metadataClass = MetadataCreatorUtils.getMetadataClass();\n+    private final MetadataEntityVO metadataEntityVO = MetadataCreatorUtils.getMetadataEntityVO(ID);\n+    private final Folder folder = FolderCreatorUtils.getFolder(ID, SIMPLE_USER);\n+    private final MetadataEntity metadataEntity = MetadataCreatorUtils.getMetadataEntity(ID, folder);\n+    private final PagedResult<List<MetadataEntity>> pagedResult = MetadataCreatorUtils.getPagedResult();\n+    private final MetadataFilter metadataFilter = MetadataCreatorUtils.getMetadataFilter(ID);\n+    private final MetadataField metadataField = MetadataCreatorUtils.getMetadataField();\n+    private final MultipartFile file = new MockMultipartFile(TEST_STRING, TEST_STRING.getBytes());\n+    private final InputStream inputStream = new ByteArrayInputStream(TEST_STRING.getBytes());\n+\n+    private final List<MetadataEntity> metadataEntities = Collections.singletonList(metadataEntity);\n+    private final List<MetadataField> metadataFields = Collections.singletonList(metadataField);\n+    private final List<MetadataClassDescription> descriptions =\n+            Collections.singletonList(MetadataCreatorUtils.getMetadataClassDescription());\n+\n+    @Autowired\n+    private MetadataEntityApiService entityApiService;\n+\n+    @Autowired\n+    private MetadataEntityManager mockMetadataEntityManager;\n+\n+    @Autowired\n+    private MetadataUploadManager mockMetadataUploadManager;\n+\n+    @Autowired\n+    private MetadataDownloadManager mockMetadataDownloadManager;\n+\n+    @Autowired\n+    private EntityManager mockEntityManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateMetadataClassForAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).createMetadataClass(TEST_STRING);\n+\n+        assertThat(entityApiService.createMetadataClass(TEST_STRING)).isEqualTo(metadataClass);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateMetadataClassForNotAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).createMetadataClass(TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.createMetadataClass(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataClassForAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).deleteMetadataClass(ID);\n+\n+        assertThat(entityApiService.deleteMetadataClass(ID)).isEqualTo(metadataClass);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataClassForNotAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).deleteMetadataClass(ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.deleteMetadataClass(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataClassForAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).updateExternalClassName(ID, FireCloudClass.PARTICIPANT);\n+\n+        assertThat(entityApiService.updateExternalClassName(ID, FireCloudClass.PARTICIPANT)).isEqualTo(metadataClass);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataClassForNotAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).updateExternalClassName(ID, FireCloudClass.PARTICIPANT);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                entityApiService.updateExternalClassName(ID, FireCloudClass.PARTICIPANT));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataEntityForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThat(entityApiService.updateMetadataEntity(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateMetadataEntityWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThat(entityApiService.updateMetadataEntity(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataEntityWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.updateMetadataEntity(metadataEntityVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateMetadataEntityForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThat(entityApiService.createMetadataEntity(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = ENTITIES_MANAGER_ROLE)\n+    public void shouldCreateMetadataEntityWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThat(entityApiService.createMetadataEntity(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateMetadataEntityWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.updateMetadataEntity(metadataEntityVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadMetadataEntityForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).load(ID);\n+\n+        assertThat(entityApiService.loadMetadataEntity(ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadMetadataEntityWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);\n+        mockLoadEntities();\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(entityApiService.loadMetadataEntity(ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyLoadMetadataEntityWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        mockLoadEntities();\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.loadMetadataEntity(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataEntityForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataEntity(ID);\n+\n+        assertThat(entityApiService.deleteMetadataEntity(ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = ENTITIES_MANAGER_ROLE)\n+    public void shouldDeleteMetadataEntityWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataEntity(ID);\n+        mockLoadEntities();\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(entityApiService.deleteMetadataEntity(ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataEntityWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataEntity(ID);\n+        mockLoadEntities();\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.deleteMetadataEntity(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadMetadataEntityByClassForAdmin() {\n+        doReturn(metadataEntities).when(mockMetadataEntityManager)\n+                .loadMetadataEntityByClassNameAndFolderId(ID, TEST_STRING);\n+\n+        assertThat(entityApiService.loadMetadataEntityByClass(ID, TEST_STRING)).isEqualTo(metadataEntities);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadMetadataEntityByClassWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);\n+        doReturn(metadataEntities).when(mockMetadataEntityManager)\n+                .loadMetadataEntityByClassNameAndFolderId(ID, TEST_STRING);\n+\n+        assertThat(entityApiService.loadMetadataEntityByClass(ID, TEST_STRING)).isEqualTo(metadataEntities);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyLoadMetadataEntityByClassWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntities).when(mockMetadataEntityManager)\n+                .loadMetadataEntityByClassNameAndFolderId(ID, TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.loadMetadataEntityByClass(ID, TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataItemKeyForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataItemKey(metadataEntityVO);\n+\n+        assertThat(entityApiService.updateMetadataItemKey(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateMetadataItemKeyWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataItemKey(metadataEntityVO);\n+\n+        assertThat(entityApiService.updateMetadataItemKey(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataItemKeyWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataItemKey(metadataEntityVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.updateMetadataItemKey(metadataEntityVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataItemKeyForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataItemKey(ID, TEST_STRING);\n+\n+        assertThat(entityApiService.deleteMetadataItemKey(ID, TEST_STRING)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteMetadataItemKeyWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataItemKey(ID, TEST_STRING);\n+        mockLoadEntities();\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(entityApiService.deleteMetadataItemKey(ID, TEST_STRING)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataItemKeyWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataItemKey(ID, TEST_STRING);\n+        mockLoadEntities();\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.deleteMetadataItemKey(ID, TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataEntitiesForAdmin() {\n+        doReturn(TEST_LONG_SET).when(mockMetadataEntityManager).deleteMetadataEntities(TEST_LONG_SET);\n+\n+        assertThat(entityApiService.deleteMetadataEntities(TEST_LONG_SET)).isEqualTo(TEST_LONG_SET);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = ENTITIES_MANAGER_ROLE)\n+    public void shouldDeleteMetadataEntitiesWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(TEST_LONG_SET).when(mockMetadataEntityManager).deleteMetadataEntities(TEST_LONG_SET);\n+        mockLoadEntities();\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(entityApiService.deleteMetadataEntities(TEST_LONG_SET)).isEqualTo(TEST_LONG_SET);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataEntitiesWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(TEST_LONG_SET).when(mockMetadataEntityManager).deleteMetadataEntities(TEST_LONG_SET);\n+        mockLoadEntities();\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.deleteMetadataEntities(TEST_LONG_SET));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldFilterMetadataForAdmin() {\n+        doReturn(pagedResult).when(mockMetadataEntityManager).filterMetadata(metadataFilter);\n+\n+        assertThat(entityApiService.filterMetadata(metadataFilter)).isEqualTo(pagedResult);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldFilterMetadataWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(pagedResult).when(mockMetadataEntityManager).filterMetadata(metadataFilter);\n+\n+        assertThat(entityApiService.filterMetadata(metadataFilter)).isEqualTo(pagedResult);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyFilterMetadataWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(pagedResult).when(mockMetadataEntityManager).filterMetadata(metadataFilter);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.filterMetadata(metadataFilter));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetMetadataKeysForAdmin() {\n+        doReturn(metadataFields).when(mockMetadataEntityManager).getMetadataKeys(ID, TEST_STRING);\n+\n+        assertThat(entityApiService.getMetadataKeys(ID, TEST_STRING)).isEqualTo(metadataFields);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetMetadataKeysWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);\n+        doReturn(metadataFields).when(mockMetadataEntityManager).getMetadataKeys(ID, TEST_STRING);\n+\n+        assertThat(entityApiService.getMetadataKeys(ID, TEST_STRING)).isEqualTo(metadataFields);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyGetMetadataKeysWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataFields).when(mockMetadataEntityManager).getMetadataKeys(ID, TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.getMetadataKeys(ID, TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetMetadataFieldsForAdmin() {\n+        doReturn(descriptions).when(mockMetadataEntityManager).getMetadataFields(ID);\n+\n+        assertThat(entityApiService.getMetadataFields(ID)).isEqualTo(descriptions);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetMetadataFieldsWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);\n+        doReturn(descriptions).when(mockMetadataEntityManager).getMetadataFields(ID);\n+\n+        assertThat(entityApiService.getMetadataFields(ID)).isEqualTo(descriptions);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyGetMetadataFieldsWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(descriptions).when(mockMetadataEntityManager).getMetadataFields(ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.getMetadataFields(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUploadMetadataFromFileForAdmin() {\n+        doReturn(metadataEntities).when(mockMetadataUploadManager).uploadFromFile(ID, file);\n+\n+        assertThat(entityApiService.uploadMetadataFromFile(ID, file)).isEqualTo(metadataEntities);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = ENTITIES_MANAGER_ROLE)\n+    public void shouldUploadMetadataFromFileWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "245aa44ff1dcd4ead7a52e74d749c446a0dcd793"}, "originalPosition": 454}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTg3NjUxOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataEntityApiServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToyODo0OFrOH8AVag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToyODo0OFrOH8AVag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY4MjA5MA==", "bodyText": "Wrong permissions again. How does this test pass?", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r532682090", "createdAt": "2020-11-30T15:28:48Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataEntityApiServiceTest.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.metadata;\n+\n+import com.epam.pipeline.controller.PagedResult;\n+import com.epam.pipeline.controller.vo.metadata.MetadataEntityVO;\n+import com.epam.pipeline.entity.metadata.FireCloudClass;\n+import com.epam.pipeline.entity.metadata.MetadataClass;\n+import com.epam.pipeline.entity.metadata.MetadataClassDescription;\n+import com.epam.pipeline.entity.metadata.MetadataEntity;\n+import com.epam.pipeline.entity.metadata.MetadataField;\n+import com.epam.pipeline.entity.metadata.MetadataFilter;\n+import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.security.acl.AclClass;\n+import com.epam.pipeline.manager.EntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataDownloadManager;\n+import com.epam.pipeline.manager.metadata.MetadataEntityManager;\n+import com.epam.pipeline.manager.metadata.MetadataUploadManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.folder.FolderCreatorUtils;\n+import com.epam.pipeline.test.creator.metadata.MetadataCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.mock.web.MockMultipartFile;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.web.multipart.MultipartFile;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_LONG_SET;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_MAP;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+\n+public class MetadataEntityApiServiceTest extends AbstractAclTest {\n+\n+    private final MetadataClass metadataClass = MetadataCreatorUtils.getMetadataClass();\n+    private final MetadataEntityVO metadataEntityVO = MetadataCreatorUtils.getMetadataEntityVO(ID);\n+    private final Folder folder = FolderCreatorUtils.getFolder(ID, SIMPLE_USER);\n+    private final MetadataEntity metadataEntity = MetadataCreatorUtils.getMetadataEntity(ID, folder);\n+    private final PagedResult<List<MetadataEntity>> pagedResult = MetadataCreatorUtils.getPagedResult();\n+    private final MetadataFilter metadataFilter = MetadataCreatorUtils.getMetadataFilter(ID);\n+    private final MetadataField metadataField = MetadataCreatorUtils.getMetadataField();\n+    private final MultipartFile file = new MockMultipartFile(TEST_STRING, TEST_STRING.getBytes());\n+    private final InputStream inputStream = new ByteArrayInputStream(TEST_STRING.getBytes());\n+\n+    private final List<MetadataEntity> metadataEntities = Collections.singletonList(metadataEntity);\n+    private final List<MetadataField> metadataFields = Collections.singletonList(metadataField);\n+    private final List<MetadataClassDescription> descriptions =\n+            Collections.singletonList(MetadataCreatorUtils.getMetadataClassDescription());\n+\n+    @Autowired\n+    private MetadataEntityApiService entityApiService;\n+\n+    @Autowired\n+    private MetadataEntityManager mockMetadataEntityManager;\n+\n+    @Autowired\n+    private MetadataUploadManager mockMetadataUploadManager;\n+\n+    @Autowired\n+    private MetadataDownloadManager mockMetadataDownloadManager;\n+\n+    @Autowired\n+    private EntityManager mockEntityManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateMetadataClassForAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).createMetadataClass(TEST_STRING);\n+\n+        assertThat(entityApiService.createMetadataClass(TEST_STRING)).isEqualTo(metadataClass);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateMetadataClassForNotAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).createMetadataClass(TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.createMetadataClass(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataClassForAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).deleteMetadataClass(ID);\n+\n+        assertThat(entityApiService.deleteMetadataClass(ID)).isEqualTo(metadataClass);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataClassForNotAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).deleteMetadataClass(ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.deleteMetadataClass(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataClassForAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).updateExternalClassName(ID, FireCloudClass.PARTICIPANT);\n+\n+        assertThat(entityApiService.updateExternalClassName(ID, FireCloudClass.PARTICIPANT)).isEqualTo(metadataClass);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataClassForNotAdmin() {\n+        doReturn(metadataClass).when(mockMetadataEntityManager).updateExternalClassName(ID, FireCloudClass.PARTICIPANT);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                entityApiService.updateExternalClassName(ID, FireCloudClass.PARTICIPANT));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataEntityForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThat(entityApiService.updateMetadataEntity(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateMetadataEntityWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThat(entityApiService.updateMetadataEntity(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataEntityWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.updateMetadataEntity(metadataEntityVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateMetadataEntityForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThat(entityApiService.createMetadataEntity(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = ENTITIES_MANAGER_ROLE)\n+    public void shouldCreateMetadataEntityWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThat(entityApiService.createMetadataEntity(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateMetadataEntityWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataEntity(metadataEntityVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.updateMetadataEntity(metadataEntityVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadMetadataEntityForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).load(ID);\n+\n+        assertThat(entityApiService.loadMetadataEntity(ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadMetadataEntityWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);\n+        mockLoadEntities();\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(entityApiService.loadMetadataEntity(ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyLoadMetadataEntityWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        mockLoadEntities();\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.loadMetadataEntity(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataEntityForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataEntity(ID);\n+\n+        assertThat(entityApiService.deleteMetadataEntity(ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = ENTITIES_MANAGER_ROLE)\n+    public void shouldDeleteMetadataEntityWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataEntity(ID);\n+        mockLoadEntities();\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(entityApiService.deleteMetadataEntity(ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataEntityWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataEntity(ID);\n+        mockLoadEntities();\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.deleteMetadataEntity(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadMetadataEntityByClassForAdmin() {\n+        doReturn(metadataEntities).when(mockMetadataEntityManager)\n+                .loadMetadataEntityByClassNameAndFolderId(ID, TEST_STRING);\n+\n+        assertThat(entityApiService.loadMetadataEntityByClass(ID, TEST_STRING)).isEqualTo(metadataEntities);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadMetadataEntityByClassWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);\n+        doReturn(metadataEntities).when(mockMetadataEntityManager)\n+                .loadMetadataEntityByClassNameAndFolderId(ID, TEST_STRING);\n+\n+        assertThat(entityApiService.loadMetadataEntityByClass(ID, TEST_STRING)).isEqualTo(metadataEntities);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyLoadMetadataEntityByClassWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntities).when(mockMetadataEntityManager)\n+                .loadMetadataEntityByClassNameAndFolderId(ID, TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.loadMetadataEntityByClass(ID, TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataItemKeyForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataItemKey(metadataEntityVO);\n+\n+        assertThat(entityApiService.updateMetadataItemKey(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateMetadataItemKeyWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataItemKey(metadataEntityVO);\n+\n+        assertThat(entityApiService.updateMetadataItemKey(metadataEntityVO)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateMetadataItemKeyWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).updateMetadataItemKey(metadataEntityVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.updateMetadataItemKey(metadataEntityVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataItemKeyForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataItemKey(ID, TEST_STRING);\n+\n+        assertThat(entityApiService.deleteMetadataItemKey(ID, TEST_STRING)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteMetadataItemKeyWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataItemKey(ID, TEST_STRING);\n+        mockLoadEntities();\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(entityApiService.deleteMetadataItemKey(ID, TEST_STRING)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataItemKeyWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).deleteMetadataItemKey(ID, TEST_STRING);\n+        mockLoadEntities();\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.deleteMetadataItemKey(ID, TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataEntitiesForAdmin() {\n+        doReturn(TEST_LONG_SET).when(mockMetadataEntityManager).deleteMetadataEntities(TEST_LONG_SET);\n+\n+        assertThat(entityApiService.deleteMetadataEntities(TEST_LONG_SET)).isEqualTo(TEST_LONG_SET);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = ENTITIES_MANAGER_ROLE)\n+    public void shouldDeleteMetadataEntitiesWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(TEST_LONG_SET).when(mockMetadataEntityManager).deleteMetadataEntities(TEST_LONG_SET);\n+        mockLoadEntities();\n+        mockAuthentication(SIMPLE_USER);\n+\n+        assertThat(entityApiService.deleteMetadataEntities(TEST_LONG_SET)).isEqualTo(TEST_LONG_SET);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteMetadataEntitiesWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(TEST_LONG_SET).when(mockMetadataEntityManager).deleteMetadataEntities(TEST_LONG_SET);\n+        mockLoadEntities();\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.deleteMetadataEntities(TEST_LONG_SET));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldFilterMetadataForAdmin() {\n+        doReturn(pagedResult).when(mockMetadataEntityManager).filterMetadata(metadataFilter);\n+\n+        assertThat(entityApiService.filterMetadata(metadataFilter)).isEqualTo(pagedResult);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldFilterMetadataWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(pagedResult).when(mockMetadataEntityManager).filterMetadata(metadataFilter);\n+\n+        assertThat(entityApiService.filterMetadata(metadataFilter)).isEqualTo(pagedResult);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyFilterMetadataWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(pagedResult).when(mockMetadataEntityManager).filterMetadata(metadataFilter);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.filterMetadata(metadataFilter));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetMetadataKeysForAdmin() {\n+        doReturn(metadataFields).when(mockMetadataEntityManager).getMetadataKeys(ID, TEST_STRING);\n+\n+        assertThat(entityApiService.getMetadataKeys(ID, TEST_STRING)).isEqualTo(metadataFields);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetMetadataKeysWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);\n+        doReturn(metadataFields).when(mockMetadataEntityManager).getMetadataKeys(ID, TEST_STRING);\n+\n+        assertThat(entityApiService.getMetadataKeys(ID, TEST_STRING)).isEqualTo(metadataFields);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyGetMetadataKeysWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataFields).when(mockMetadataEntityManager).getMetadataKeys(ID, TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.getMetadataKeys(ID, TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetMetadataFieldsForAdmin() {\n+        doReturn(descriptions).when(mockMetadataEntityManager).getMetadataFields(ID);\n+\n+        assertThat(entityApiService.getMetadataFields(ID)).isEqualTo(descriptions);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetMetadataFieldsWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);\n+        doReturn(descriptions).when(mockMetadataEntityManager).getMetadataFields(ID);\n+\n+        assertThat(entityApiService.getMetadataFields(ID)).isEqualTo(descriptions);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyGetMetadataFieldsWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(descriptions).when(mockMetadataEntityManager).getMetadataFields(ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.getMetadataFields(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUploadMetadataFromFileForAdmin() {\n+        doReturn(metadataEntities).when(mockMetadataUploadManager).uploadFromFile(ID, file);\n+\n+        assertThat(entityApiService.uploadMetadataFromFile(ID, file)).isEqualTo(metadataEntities);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = ENTITIES_MANAGER_ROLE)\n+    public void shouldUploadMetadataFromFileWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);\n+        doReturn(metadataEntities).when(mockMetadataUploadManager).uploadFromFile(ID, file);\n+\n+        assertThat(entityApiService.uploadMetadataFromFile(ID, file)).isEqualTo(metadataEntities);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUploadMetadataFromFileWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntities).when(mockMetadataUploadManager).uploadFromFile(ID, file);\n+\n+        assertThrows(AccessDeniedException.class, () -> entityApiService.uploadMetadataFromFile(ID, file));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadByExternalIdForAdmin() {\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).loadByExternalId(TEST_STRING, TEST_STRING, ID);\n+\n+        assertThat(entityApiService.loadByExternalId(TEST_STRING, TEST_STRING, ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadByExternalIdWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).loadByExternalId(TEST_STRING, TEST_STRING, ID);\n+\n+        assertThat(entityApiService.loadByExternalId(TEST_STRING, TEST_STRING, ID)).isEqualTo(metadataEntity);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyLoadByExternalIdWhenPermissionIsNotGranted() {\n+        initAclEntity(folder);\n+        doReturn(metadataEntity).when(mockMetadataEntityManager).loadByExternalId(TEST_STRING, TEST_STRING, ID);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                entityApiService.loadByExternalId(TEST_STRING, TEST_STRING, ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteMetadataFromProjectForAdmin() {\n+        doNothing().when(mockMetadataEntityManager).deleteMetadataEntitiesInProject(ID, TEST_STRING);\n+\n+        entityApiService.deleteMetadataFromProject(ID, TEST_STRING);\n+\n+        verify(mockMetadataEntityManager).deleteMetadataEntitiesInProject(ID, TEST_STRING);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteMetadataFromProjectWhenPermissionIsGranted() {\n+        initAclEntity(folder, AclPermission.READ);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "245aa44ff1dcd4ead7a52e74d749c446a0dcd793"}, "originalPosition": 509}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTg5NTY5OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/manager/metadata/MetadataApiServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNTozMjozMVrOH8Ag1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNTozMjozMVrOH8Ag1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY4NTAxNA==", "bodyText": "This test class should be removed. But before we can do that we should either ensure that all tests in the class are covered by some tests in other classes or move them from the deleting class to some other classes.", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r532685014", "createdAt": "2020-11-30T15:32:31Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/manager/metadata/MetadataApiServiceTest.java", "diffHunk": "@@ -16,6 +16,7 @@\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "245aa44ff1dcd4ead7a52e74d749c446a0dcd793"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MDYzOTA4OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataApiServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMDowMjoxNlrOH9TQFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMDowMjoxNlrOH9TQFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA0MDU5Ng==", "bodyText": "This method should have suffix ForAdmin, don't you think?", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r534040596", "createdAt": "2020-12-02T10:02:16Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataApiServiceTest.java", "diffHunk": "@@ -85,19 +111,37 @@ public void shouldUpdateMetadataItemKeyForAdmin() {\n \n     @Test\n     @WithMockUser\n-    public void shouldUpdateMetadataItemKeyWhenPermissionIsGranted() {\n+    public void shouldUpdateMetadataItemKeyForOwner() {\n         doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKey(metadataVO);\n-        doReturn(entity).when(mockEntityManager).load(ENTITY_ACL_CLASS, ID);\n+        mockLoadEntity(entityWithOwner, ID);\n         mockAuthUser(SIMPLE_USER);\n \n         assertThat(metadataApiService.updateMetadataItemKey(metadataVO)).isEqualTo(metadataEntry);\n     }\n \n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateMetadataItemKeyForPipelineUser() {\n+        doReturn(pipelineUserEntry).when(mockMetadataManager).updateMetadataItemKey(pipelineUserVO);\n+        mockAuthAndLoadUser();\n+\n+        assertThat(metadataApiService.updateMetadataItemKey(pipelineUserVO)).isEqualTo(pipelineUserEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = ADMIN_ROLE)\n+    public void shouldUpdateMetadataItemKeyForRole() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b275054fbddf97f411d4501445c42bfe9891287"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MDY0OTMxOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataApiServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMDowNDo0MFrOH9TWbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMDowNDo0MFrOH9TWbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA0MjIyMg==", "bodyText": "Let's add the similar test to check if an admin is able to perform the operation for pipeline user metadata.", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r534042222", "createdAt": "2020-12-02T10:04:40Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataApiServiceTest.java", "diffHunk": "@@ -85,19 +111,37 @@ public void shouldUpdateMetadataItemKeyForAdmin() {\n \n     @Test\n     @WithMockUser\n-    public void shouldUpdateMetadataItemKeyWhenPermissionIsGranted() {\n+    public void shouldUpdateMetadataItemKeyForOwner() {\n         doReturn(metadataEntry).when(mockMetadataManager).updateMetadataItemKey(metadataVO);\n-        doReturn(entity).when(mockEntityManager).load(ENTITY_ACL_CLASS, ID);\n+        mockLoadEntity(entityWithOwner, ID);\n         mockAuthUser(SIMPLE_USER);\n \n         assertThat(metadataApiService.updateMetadataItemKey(metadataVO)).isEqualTo(metadataEntry);\n     }\n \n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateMetadataItemKeyForPipelineUser() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b275054fbddf97f411d4501445c42bfe9891287"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MDY2MDg0OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataApiServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMDowNzo0MVrOH9Td3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMDowNzo0MVrOH9Td3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA0NDEyNQ==", "bodyText": "Seems like mockUser would be quite enough for this helper method.", "url": "https://github.com/epam/cloud-pipeline/pull/1612#discussion_r534044125", "createdAt": "2020-12-02T10:07:41Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/acl/metadata/MetadataApiServiceTest.java", "diffHunk": "@@ -450,4 +693,9 @@ public void shouldDenyGetMetadataKeysWithoutUserRole() {\n     private void mockLoadEntity(final AbstractSecuredEntity entity, final Long id) {\n         doReturn(entity).when(mockEntityManager).load(ENTITY_ACL_CLASS, id);\n     }\n+\n+    private void mockAuthAndLoadUser() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b275054fbddf97f411d4501445c42bfe9891287"}, "originalPosition": 586}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 193, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}