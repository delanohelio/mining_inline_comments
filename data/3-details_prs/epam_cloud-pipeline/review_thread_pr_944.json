{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxODQwODE0", "number": 944, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoxODoyOFrODdraCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoyNzoyOVrODdrkOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNDQ2NDc0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/epam/pipeline/manager/pipeline/RunScheduleManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoxODoyOFrOFmar2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoxODoyOFrOFmar2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgyNzQxOQ==", "bodyText": "I'd suggest replacing switch with interface call where implementation is selected depending on type, similar to storage handling approach.", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375827419", "createdAt": "2020-02-06T13:18:28Z", "author": {"login": "mzueva"}, "path": "api/src/main/java/com/epam/pipeline/manager/pipeline/RunScheduleManager.java", "diffHunk": "@@ -135,73 +148,115 @@ public void init() {\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public List<RunSchedule> deleteRunSchedules(final Long runId, final List<Long> scheduleIds) {\n+    public List<RunSchedule> deleteSchedules(final Long schedulableId, final ScheduleType scheduleType,\n+                                             final List<Long> scheduleIds) {\n         final List<RunSchedule> schedules = scheduleIds.stream()\n-            .map(this::loadRunSchedule)\n-            .peek(schedule -> Assert.isTrue(runId.equals(schedule.getRunId()),\n-                                        messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING)))\n+            .map(this::loadSchedule)\n+            .peek(schedule -> Assert.isTrue(\n+                    schedulableId.equals(schedule.getSchedulableId()) && schedule.getType() == scheduleType,\n+                    messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING))\n+            )\n             .peek(scheduler::unscheduleRunSchedule)\n             .collect(Collectors.toList());\n         runScheduleDao.deleteRunSchedules(scheduleIds);\n         return schedules;\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public void deleteRunSchedulesForRun(final Long runId) {\n-        runScheduleDao.deleteRunSchedulesForRun(runId);\n+    public void deleteSchedules(final Long schedulableId, final ScheduleType scheduleType) {\n+        runScheduleDao.deleteRunSchedules(schedulableId, scheduleType);\n     }\n \n-    public RunSchedule loadRunSchedule(final Long id) {\n+    public RunSchedule loadSchedule(final Long id) {\n         return runScheduleDao.loadRunSchedule(id).orElseThrow(() -> new IllegalArgumentException(\n             messageHelper.getMessage(MessageConstants.ERROR_RUN_SCHEDULE_NOT_FOUND, id)));\n     }\n \n-    private void checkNewScheduleRequirements(final Long runId, final PipelineRun pipelineRun,\n-                                              final PipelineRunScheduleVO runScheduleVO) {\n-        checkIdenticalCronExpressionForRun(runId, runScheduleVO);\n-        verifyRunSchedule(runId, pipelineRun, runScheduleVO);\n+    @Transactional(propagation = Propagation.REQUIRED)\n+    public void deleteSchedulesForRunByPipeline(final Long pipelineId) {\n+        runScheduleDao.deleteRunSchedulesForRunByPipeline(pipelineId);\n+    }\n+\n+    private void checkNewRunScheduleRequirements(final Long schedulableId, final PipelineRunScheduleVO runScheduleVO,\n+                                                 final ScheduleType scheduleType) {\n+        checkIdenticalCronExpression(schedulableId, scheduleType, runScheduleVO);\n+        verifyRunSchedule(schedulableId, runScheduleVO, scheduleType);\n     }\n \n-    private void verifyRunSchedule(final Long runId, final PipelineRun pipelineRun,\n-                                   final PipelineRunScheduleVO runScheduleVO) {\n+    private void verifyRunSchedule(final Long runId, final PipelineRunScheduleVO runScheduleVO,\n+                                   final ScheduleType type) {\n         verifyCronExpression(runId, runScheduleVO);\n         Assert.notNull(runScheduleVO.getAction(),\n                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_PROVIDED, runId));\n-        Assert.notNull(pipelineRun,\n-                       messageHelper.getMessage(MessageConstants.ERROR_RUN_PIPELINES_NOT_FOUND, pipelineRun.getName()));\n-        Assert.isTrue(!pipelineRun.getInstance().getSpot(), messageHelper.getMessage(\n-            MessageConstants.ERROR_ON_DEMAND_REQUIRED));\n-        Assert.isTrue(!pipelineRun.getStatus().isFinal(), messageHelper.getMessage(\n-            MessageConstants.ERROR_PIPELINE_RUN_FINISHED, runId));\n         Assert.isTrue(StringUtils.hasText(runScheduleVO.getTimeZone()),\n                       messageHelper.getMessage(MessageConstants.ERROR_TIME_ZONE_IS_NOT_PROVIDED, runId));\n-        Assert.isTrue(!(runScheduleVO.getAction().equals(RunScheduledAction.PAUSE)\n-                        && isNonPauseOrClusterRun(pipelineRun)),\n-                      messageHelper.getMessage(MessageConstants.DEBUG_RUN_IDLE_SKIP_CHECK));\n+        switch (type) {\n+            case PIPELINE_RUN:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNDQ2NjY1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/epam/pipeline/manager/pipeline/RunScheduleManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoxOTowOFrOFmas9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoxOTowOFrOFmas9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgyNzcwMA==", "bodyText": "missing final", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375827700", "createdAt": "2020-02-06T13:19:08Z", "author": {"login": "mzueva"}, "path": "api/src/main/java/com/epam/pipeline/manager/pipeline/RunScheduleManager.java", "diffHunk": "@@ -135,73 +148,115 @@ public void init() {\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public List<RunSchedule> deleteRunSchedules(final Long runId, final List<Long> scheduleIds) {\n+    public List<RunSchedule> deleteSchedules(final Long schedulableId, final ScheduleType scheduleType,\n+                                             final List<Long> scheduleIds) {\n         final List<RunSchedule> schedules = scheduleIds.stream()\n-            .map(this::loadRunSchedule)\n-            .peek(schedule -> Assert.isTrue(runId.equals(schedule.getRunId()),\n-                                        messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING)))\n+            .map(this::loadSchedule)\n+            .peek(schedule -> Assert.isTrue(\n+                    schedulableId.equals(schedule.getSchedulableId()) && schedule.getType() == scheduleType,\n+                    messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING))\n+            )\n             .peek(scheduler::unscheduleRunSchedule)\n             .collect(Collectors.toList());\n         runScheduleDao.deleteRunSchedules(scheduleIds);\n         return schedules;\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public void deleteRunSchedulesForRun(final Long runId) {\n-        runScheduleDao.deleteRunSchedulesForRun(runId);\n+    public void deleteSchedules(final Long schedulableId, final ScheduleType scheduleType) {\n+        runScheduleDao.deleteRunSchedules(schedulableId, scheduleType);\n     }\n \n-    public RunSchedule loadRunSchedule(final Long id) {\n+    public RunSchedule loadSchedule(final Long id) {\n         return runScheduleDao.loadRunSchedule(id).orElseThrow(() -> new IllegalArgumentException(\n             messageHelper.getMessage(MessageConstants.ERROR_RUN_SCHEDULE_NOT_FOUND, id)));\n     }\n \n-    private void checkNewScheduleRequirements(final Long runId, final PipelineRun pipelineRun,\n-                                              final PipelineRunScheduleVO runScheduleVO) {\n-        checkIdenticalCronExpressionForRun(runId, runScheduleVO);\n-        verifyRunSchedule(runId, pipelineRun, runScheduleVO);\n+    @Transactional(propagation = Propagation.REQUIRED)\n+    public void deleteSchedulesForRunByPipeline(final Long pipelineId) {\n+        runScheduleDao.deleteRunSchedulesForRunByPipeline(pipelineId);\n+    }\n+\n+    private void checkNewRunScheduleRequirements(final Long schedulableId, final PipelineRunScheduleVO runScheduleVO,\n+                                                 final ScheduleType scheduleType) {\n+        checkIdenticalCronExpression(schedulableId, scheduleType, runScheduleVO);\n+        verifyRunSchedule(schedulableId, runScheduleVO, scheduleType);\n     }\n \n-    private void verifyRunSchedule(final Long runId, final PipelineRun pipelineRun,\n-                                   final PipelineRunScheduleVO runScheduleVO) {\n+    private void verifyRunSchedule(final Long runId, final PipelineRunScheduleVO runScheduleVO,\n+                                   final ScheduleType type) {\n         verifyCronExpression(runId, runScheduleVO);\n         Assert.notNull(runScheduleVO.getAction(),\n                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_PROVIDED, runId));\n-        Assert.notNull(pipelineRun,\n-                       messageHelper.getMessage(MessageConstants.ERROR_RUN_PIPELINES_NOT_FOUND, pipelineRun.getName()));\n-        Assert.isTrue(!pipelineRun.getInstance().getSpot(), messageHelper.getMessage(\n-            MessageConstants.ERROR_ON_DEMAND_REQUIRED));\n-        Assert.isTrue(!pipelineRun.getStatus().isFinal(), messageHelper.getMessage(\n-            MessageConstants.ERROR_PIPELINE_RUN_FINISHED, runId));\n         Assert.isTrue(StringUtils.hasText(runScheduleVO.getTimeZone()),\n                       messageHelper.getMessage(MessageConstants.ERROR_TIME_ZONE_IS_NOT_PROVIDED, runId));\n-        Assert.isTrue(!(runScheduleVO.getAction().equals(RunScheduledAction.PAUSE)\n-                        && isNonPauseOrClusterRun(pipelineRun)),\n-                      messageHelper.getMessage(MessageConstants.DEBUG_RUN_IDLE_SKIP_CHECK));\n+        switch (type) {\n+            case PIPELINE_RUN:\n+                Assert.isTrue(runScheduleVO.getAction() == RunScheduledAction.PAUSE\n+                        || runScheduleVO.getAction() == RunScheduledAction.RESUME,\n+                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_ALLOWED,\n+                                RunScheduledAction.RESUME.name() + \", \" + RunScheduledAction.PAUSE.name(),\n+                                runScheduleVO.getAction()));\n+                break;\n+            case RUN_CONFIGURATION:\n+                Assert.isTrue(runScheduleVO.getAction() == RunScheduledAction.RUN,\n+                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_ALLOWED,\n+                                RunScheduledAction.RUN.name(), runScheduleVO.getAction()));\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    private void verifySchedulable(final Long schedulableId, final ScheduleType scheduleType) {\n+        switch (scheduleType) {\n+            case PIPELINE_RUN:\n+                PipelineRun pipelineRun = pipelineRunManager.loadPipelineRun(schedulableId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNDQ2NzgzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/epam/pipeline/manager/pipeline/RunScheduleManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoxOTozN1rOFmattg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoxOTozN1rOFmattg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgyNzg5NA==", "bodyText": "Not sure: shouldn't we throw an exception here?", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375827894", "createdAt": "2020-02-06T13:19:37Z", "author": {"login": "mzueva"}, "path": "api/src/main/java/com/epam/pipeline/manager/pipeline/RunScheduleManager.java", "diffHunk": "@@ -135,73 +148,115 @@ public void init() {\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public List<RunSchedule> deleteRunSchedules(final Long runId, final List<Long> scheduleIds) {\n+    public List<RunSchedule> deleteSchedules(final Long schedulableId, final ScheduleType scheduleType,\n+                                             final List<Long> scheduleIds) {\n         final List<RunSchedule> schedules = scheduleIds.stream()\n-            .map(this::loadRunSchedule)\n-            .peek(schedule -> Assert.isTrue(runId.equals(schedule.getRunId()),\n-                                        messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING)))\n+            .map(this::loadSchedule)\n+            .peek(schedule -> Assert.isTrue(\n+                    schedulableId.equals(schedule.getSchedulableId()) && schedule.getType() == scheduleType,\n+                    messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING))\n+            )\n             .peek(scheduler::unscheduleRunSchedule)\n             .collect(Collectors.toList());\n         runScheduleDao.deleteRunSchedules(scheduleIds);\n         return schedules;\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public void deleteRunSchedulesForRun(final Long runId) {\n-        runScheduleDao.deleteRunSchedulesForRun(runId);\n+    public void deleteSchedules(final Long schedulableId, final ScheduleType scheduleType) {\n+        runScheduleDao.deleteRunSchedules(schedulableId, scheduleType);\n     }\n \n-    public RunSchedule loadRunSchedule(final Long id) {\n+    public RunSchedule loadSchedule(final Long id) {\n         return runScheduleDao.loadRunSchedule(id).orElseThrow(() -> new IllegalArgumentException(\n             messageHelper.getMessage(MessageConstants.ERROR_RUN_SCHEDULE_NOT_FOUND, id)));\n     }\n \n-    private void checkNewScheduleRequirements(final Long runId, final PipelineRun pipelineRun,\n-                                              final PipelineRunScheduleVO runScheduleVO) {\n-        checkIdenticalCronExpressionForRun(runId, runScheduleVO);\n-        verifyRunSchedule(runId, pipelineRun, runScheduleVO);\n+    @Transactional(propagation = Propagation.REQUIRED)\n+    public void deleteSchedulesForRunByPipeline(final Long pipelineId) {\n+        runScheduleDao.deleteRunSchedulesForRunByPipeline(pipelineId);\n+    }\n+\n+    private void checkNewRunScheduleRequirements(final Long schedulableId, final PipelineRunScheduleVO runScheduleVO,\n+                                                 final ScheduleType scheduleType) {\n+        checkIdenticalCronExpression(schedulableId, scheduleType, runScheduleVO);\n+        verifyRunSchedule(schedulableId, runScheduleVO, scheduleType);\n     }\n \n-    private void verifyRunSchedule(final Long runId, final PipelineRun pipelineRun,\n-                                   final PipelineRunScheduleVO runScheduleVO) {\n+    private void verifyRunSchedule(final Long runId, final PipelineRunScheduleVO runScheduleVO,\n+                                   final ScheduleType type) {\n         verifyCronExpression(runId, runScheduleVO);\n         Assert.notNull(runScheduleVO.getAction(),\n                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_PROVIDED, runId));\n-        Assert.notNull(pipelineRun,\n-                       messageHelper.getMessage(MessageConstants.ERROR_RUN_PIPELINES_NOT_FOUND, pipelineRun.getName()));\n-        Assert.isTrue(!pipelineRun.getInstance().getSpot(), messageHelper.getMessage(\n-            MessageConstants.ERROR_ON_DEMAND_REQUIRED));\n-        Assert.isTrue(!pipelineRun.getStatus().isFinal(), messageHelper.getMessage(\n-            MessageConstants.ERROR_PIPELINE_RUN_FINISHED, runId));\n         Assert.isTrue(StringUtils.hasText(runScheduleVO.getTimeZone()),\n                       messageHelper.getMessage(MessageConstants.ERROR_TIME_ZONE_IS_NOT_PROVIDED, runId));\n-        Assert.isTrue(!(runScheduleVO.getAction().equals(RunScheduledAction.PAUSE)\n-                        && isNonPauseOrClusterRun(pipelineRun)),\n-                      messageHelper.getMessage(MessageConstants.DEBUG_RUN_IDLE_SKIP_CHECK));\n+        switch (type) {\n+            case PIPELINE_RUN:\n+                Assert.isTrue(runScheduleVO.getAction() == RunScheduledAction.PAUSE\n+                        || runScheduleVO.getAction() == RunScheduledAction.RESUME,\n+                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_ALLOWED,\n+                                RunScheduledAction.RESUME.name() + \", \" + RunScheduledAction.PAUSE.name(),\n+                                runScheduleVO.getAction()));\n+                break;\n+            case RUN_CONFIGURATION:\n+                Assert.isTrue(runScheduleVO.getAction() == RunScheduledAction.RUN,\n+                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_ALLOWED,\n+                                RunScheduledAction.RUN.name(), runScheduleVO.getAction()));\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    private void verifySchedulable(final Long schedulableId, final ScheduleType scheduleType) {\n+        switch (scheduleType) {\n+            case PIPELINE_RUN:\n+                PipelineRun pipelineRun = pipelineRunManager.loadPipelineRun(schedulableId);\n+                Assert.notNull(pipelineRun, messageHelper\n+                        .getMessage(MessageConstants.ERROR_RUN_PIPELINES_NOT_FOUND, pipelineRun.getName()));\n+                Assert.isTrue(!pipelineRun.getInstance().getSpot(), messageHelper.getMessage(\n+                        MessageConstants.ERROR_ON_DEMAND_REQUIRED));\n+                Assert.isTrue(!pipelineRun.getStatus().isFinal(), messageHelper.getMessage(\n+                        MessageConstants.ERROR_PIPELINE_RUN_FINISHED, schedulableId));\n+                Assert.isTrue(!isNonPauseOrClusterRun(pipelineRun),\n+                        messageHelper.getMessage(MessageConstants.DEBUG_RUN_IDLE_SKIP_CHECK));\n+                break;\n+            case RUN_CONFIGURATION:\n+                RunConfiguration configuration = configurationManager.load(schedulableId);\n+                Assert.notNull(configuration,\n+                        messageHelper.getMessage(MessageConstants.ERROR_RUN_CONFIG_NOT_FOUND, schedulableId));\n+                break;\n+            default:\n+                log.error(messageHelper.getMessage(MessageConstants.CRON_EXPRESSION_IDENTICAL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNDQ3NTEwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/epam/pipeline/manager/scheduling/RunScheduler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoyMjoxOVrOFmayXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoyMjoxOVrOFmayXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgyOTA4Ng==", "bodyText": "One more place to use some polymorphic interface for handling different ScheduleTypes", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375829086", "createdAt": "2020-02-06T13:22:19Z", "author": {"login": "mzueva"}, "path": "api/src/main/java/com/epam/pipeline/manager/scheduling/RunScheduler.java", "diffHunk": "@@ -68,42 +78,50 @@ public void init() {\n \n     public void scheduleRunSchedule(final RunSchedule schedule) {\n         try {\n-            log.debug(\"Request received to schedule run \");\n+            log.debug(\"Request received to schedule action: \" + schedule.getAction() + \" for \"\n+                    + schedule.getType() + ID + schedule.getSchedulableId());\n             final JobDetail jobDetail = jobDetail(schedule);\n \n             log.debug(\"Creating trigger for key \" + jobDetail.getKey().getName() + \" at date: \" + DateUtils.now());\n             final Trigger cronTrigger = createCronTrigger(schedule);\n \n             final Date scheduledDate = quartzScheduler.scheduleJob(jobDetail, cronTrigger);\n-            log.debug(\"Job for run: \" + schedule.getRunId() + \" scheduled successfully for date: \" + scheduledDate);\n+            log.debug(\"Job for: \" + schedule.getType() + ID\n+                    + schedule.getSchedulableId() + \" scheduled successfully for date: \" + scheduledDate);\n         } catch (SchedulerException | ParseException e) {\n-            log.error(\"SchedulerException while scheduling job for run \" + schedule.getRunId() + \" : \" +\n+            log.error(\"SchedulerException while scheduling job for run \" + schedule.getSchedulableId() + \" : \" +\n                       e.getMessage());\n         }\n     }\n \n     public void unscheduleRunSchedule(final RunSchedule schedule) {\n         try {\n-            log.debug(\"Request received to unscheduling trigger for run \" + schedule.getRunId());\n+            log.debug(\"Request received to unscheduling trigger for: \" + schedule.getType()\n+                    + ID + schedule.getSchedulableId());\n \n             final JobKey key = jobDetail(schedule).getKey();\n \n             quartzScheduler.deleteJob(key);\n \n-            log.debug(\"Schedule \" + schedule.getCronExpression() + \" for run \" + schedule.getRunId() +\n-                      \" was revoked successfully.\");\n+            log.debug(\"Schedule \" + schedule.getCronExpression() + \" for \"  + schedule.getType()\n+                    + ID + schedule.getSchedulableId() + \" was revoked successfully.\");\n         } catch (SchedulerException e) {\n-            log.error(\"SchedulerException while unscheduling trigger for run \" + schedule.getRunId() + \" : \" +\n-                      e.getMessage());\n+            log.error(\"SchedulerException while unscheduling trigger for \"  + schedule.getType()\n+                    + ID + schedule.getSchedulableId() + \" : \" + e.getMessage());\n         }\n     }\n \n     private JobDetail jobDetail(final RunSchedule runSchedule) {\n         JobDetailFactoryBean jobDetailFactory = new JobDetailFactoryBean();\n-        jobDetailFactory.setJobClass(RunScheduleJob.class);\n-        jobDetailFactory.getJobDataMap().put(\"RunId\", runSchedule.getRunId());\n+        jobDetailFactory.setJobClass(runSchedule.getType() == ScheduleType.PIPELINE_RUN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNDQ5MDgzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/epam/pipeline/manager/scheduling/RunScheduler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoyNzoyOVrOFma8Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoyNzoyOVrOFma8Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgzMTU2Nw==", "bodyText": "Method authManager.issueToken with null expiration will issue a token with default expiration (1 month by default). We need to specify expiration manually, if we need a long-term token", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375831567", "createdAt": "2020-02-06T13:27:29Z", "author": {"login": "mzueva"}, "path": "api/src/main/java/com/epam/pipeline/manager/scheduling/RunScheduler.java", "diffHunk": "@@ -68,42 +78,50 @@ public void init() {\n \n     public void scheduleRunSchedule(final RunSchedule schedule) {\n         try {\n-            log.debug(\"Request received to schedule run \");\n+            log.debug(\"Request received to schedule action: \" + schedule.getAction() + \" for \"\n+                    + schedule.getType() + ID + schedule.getSchedulableId());\n             final JobDetail jobDetail = jobDetail(schedule);\n \n             log.debug(\"Creating trigger for key \" + jobDetail.getKey().getName() + \" at date: \" + DateUtils.now());\n             final Trigger cronTrigger = createCronTrigger(schedule);\n \n             final Date scheduledDate = quartzScheduler.scheduleJob(jobDetail, cronTrigger);\n-            log.debug(\"Job for run: \" + schedule.getRunId() + \" scheduled successfully for date: \" + scheduledDate);\n+            log.debug(\"Job for: \" + schedule.getType() + ID\n+                    + schedule.getSchedulableId() + \" scheduled successfully for date: \" + scheduledDate);\n         } catch (SchedulerException | ParseException e) {\n-            log.error(\"SchedulerException while scheduling job for run \" + schedule.getRunId() + \" : \" +\n+            log.error(\"SchedulerException while scheduling job for run \" + schedule.getSchedulableId() + \" : \" +\n                       e.getMessage());\n         }\n     }\n \n     public void unscheduleRunSchedule(final RunSchedule schedule) {\n         try {\n-            log.debug(\"Request received to unscheduling trigger for run \" + schedule.getRunId());\n+            log.debug(\"Request received to unscheduling trigger for: \" + schedule.getType()\n+                    + ID + schedule.getSchedulableId());\n \n             final JobKey key = jobDetail(schedule).getKey();\n \n             quartzScheduler.deleteJob(key);\n \n-            log.debug(\"Schedule \" + schedule.getCronExpression() + \" for run \" + schedule.getRunId() +\n-                      \" was revoked successfully.\");\n+            log.debug(\"Schedule \" + schedule.getCronExpression() + \" for \"  + schedule.getType()\n+                    + ID + schedule.getSchedulableId() + \" was revoked successfully.\");\n         } catch (SchedulerException e) {\n-            log.error(\"SchedulerException while unscheduling trigger for run \" + schedule.getRunId() + \" : \" +\n-                      e.getMessage());\n+            log.error(\"SchedulerException while unscheduling trigger for \"  + schedule.getType()\n+                    + ID + schedule.getSchedulableId() + \" : \" + e.getMessage());\n         }\n     }\n \n     private JobDetail jobDetail(final RunSchedule runSchedule) {\n         JobDetailFactoryBean jobDetailFactory = new JobDetailFactoryBean();\n-        jobDetailFactory.setJobClass(RunScheduleJob.class);\n-        jobDetailFactory.getJobDataMap().put(\"RunId\", runSchedule.getRunId());\n+        jobDetailFactory.setJobClass(runSchedule.getType() == ScheduleType.PIPELINE_RUN\n+                ? RunScheduleJob.class\n+                : ConfigurationScheduleJob.class);\n+        jobDetailFactory.getJobDataMap().put(\"SchedulableId\", runSchedule.getSchedulableId());\n+        jobDetailFactory.getJobDataMap().put(\n+                \"UserToken\", authManager.issueToken(userManager.loadUserContext(runSchedule.getUser()), null).getToken()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5"}, "originalPosition": 96}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 474, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}