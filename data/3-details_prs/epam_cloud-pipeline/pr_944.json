{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxODQwODE0", "number": 944, "title": "Issue 938 Start run configuration by schedule", "bodyText": "This PR provides opportunity to run Run configuration by schedule, as it was implemented for pipeline runs. Issue #938\n\nOnly RUN action available for Run Configuration\nFor one configuration several different Schedules can be specified\nConfiguration will be run from User who creates or updates this schedule\nIf Configuration has several entries only default will be run by schedule\n\nFor implementation code for scheduling Pipeline run was reused.\nThe main idea of this PR is to refactor and reuse code that manages scheduling of runs.\nMain changes:\n\nNew controller for Scheduling of Run Configuration\nExpanded ApiService for scheduling with additional methods for Run Configuration\nIntroduced type of scheduling (PIPELINE_RUN RUN_CONFIGURATION) to be able to distinguish schedules\nIntroduce new ConfigurationScheduleJob to run Configurations", "createdAt": "2020-02-06T11:09:54Z", "url": "https://github.com/epam/cloud-pipeline/pull/944", "merged": true, "mergeCommit": {"oid": "cc0836f8caeaae280ea7f87be4b1452ba5a662cf"}, "closed": true, "closedAt": "2020-02-07T11:56:46Z", "author": {"login": "SilinPavel"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBUnCkgH2gAyMzcxODQwODE0OjA1NWQ3Y2VkNWI1NTRlZTczZThlNTlkOWJhMWE0MWM4ZDUzZjljZjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcB9OTHAH2gAyMzcxODQwODE0OmMyNzBlOTMyZDQ5ODFiNjczMzk0NjdlM2EzNGRjOTkwN2MzMDhlN2E=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "055d7ced5b554ee73e8e59d9ba1a41c8d53f9cf6", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/055d7ced5b554ee73e8e59d9ba1a41c8d53f9cf6", "committedDate": "2020-02-05T11:40:45Z", "message": "(issue #938) expand Run Schedule Api to be able to schedule to run Detached Configurations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d66ee01ff4cde1d55f17a40b751d13ad5e3e5246", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/d66ee01ff4cde1d55f17a40b751d13ad5e3e5246", "committedDate": "2020-02-05T11:40:45Z", "message": "(issue #938) refactor code to unify work with pipelineRun and RunConfiguration in PipelineRunScheduleManager and etc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d01c4f7f7dd46cf9a48c4612ecb978844911bc2", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/7d01c4f7f7dd46cf9a48c4612ecb978844911bc2", "committedDate": "2020-02-05T11:40:46Z", "message": "(issue #938)tests WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "176b312bfebad79e88f9bfef86e8a520337df42c", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/176b312bfebad79e88f9bfef86e8a520337df42c", "committedDate": "2020-02-05T14:17:04Z", "message": "(issue #938) tests WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c660d6525be608d43739975a8ea040532092b48d", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/c660d6525be608d43739975a8ea040532092b48d", "committedDate": "2020-02-05T15:15:17Z", "message": "(issue #938) tests WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f5f84ae62ac6a0867e2098da549c8e114d8a844", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/0f5f84ae62ac6a0867e2098da549c8e114d8a844", "committedDate": "2020-02-05T16:28:08Z", "message": "(issue #938) save user name to restore auth context"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92beb2ff14c1c50cc43b86b0ebfda5f9eeeb47fc", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/92beb2ff14c1c50cc43b86b0ebfda5f9eeeb47fc", "committedDate": "2020-02-06T09:27:35Z", "message": "(issue #938) tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a40fa26daa4a52496b7a1b128eb43b9b71865738", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/a40fa26daa4a52496b7a1b128eb43b9b71865738", "committedDate": "2020-02-06T11:20:35Z", "message": "(issue #938) cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/3cb78fc3ce09edb0b6da59f84da046ecd97422e5", "committedDate": "2020-02-06T11:30:34Z", "message": "(issue #938) licenses"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0NDQwODUz", "url": "https://github.com/epam/cloud-pipeline/pull/944#pullrequestreview-354440853", "createdAt": "2020-02-06T13:18:28Z", "commit": {"oid": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoxODoyOFrOFmar2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzoyNzoyOVrOFma8Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgyNzQxOQ==", "bodyText": "I'd suggest replacing switch with interface call where implementation is selected depending on type, similar to storage handling approach.", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375827419", "createdAt": "2020-02-06T13:18:28Z", "author": {"login": "mzueva"}, "path": "api/src/main/java/com/epam/pipeline/manager/pipeline/RunScheduleManager.java", "diffHunk": "@@ -135,73 +148,115 @@ public void init() {\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public List<RunSchedule> deleteRunSchedules(final Long runId, final List<Long> scheduleIds) {\n+    public List<RunSchedule> deleteSchedules(final Long schedulableId, final ScheduleType scheduleType,\n+                                             final List<Long> scheduleIds) {\n         final List<RunSchedule> schedules = scheduleIds.stream()\n-            .map(this::loadRunSchedule)\n-            .peek(schedule -> Assert.isTrue(runId.equals(schedule.getRunId()),\n-                                        messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING)))\n+            .map(this::loadSchedule)\n+            .peek(schedule -> Assert.isTrue(\n+                    schedulableId.equals(schedule.getSchedulableId()) && schedule.getType() == scheduleType,\n+                    messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING))\n+            )\n             .peek(scheduler::unscheduleRunSchedule)\n             .collect(Collectors.toList());\n         runScheduleDao.deleteRunSchedules(scheduleIds);\n         return schedules;\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public void deleteRunSchedulesForRun(final Long runId) {\n-        runScheduleDao.deleteRunSchedulesForRun(runId);\n+    public void deleteSchedules(final Long schedulableId, final ScheduleType scheduleType) {\n+        runScheduleDao.deleteRunSchedules(schedulableId, scheduleType);\n     }\n \n-    public RunSchedule loadRunSchedule(final Long id) {\n+    public RunSchedule loadSchedule(final Long id) {\n         return runScheduleDao.loadRunSchedule(id).orElseThrow(() -> new IllegalArgumentException(\n             messageHelper.getMessage(MessageConstants.ERROR_RUN_SCHEDULE_NOT_FOUND, id)));\n     }\n \n-    private void checkNewScheduleRequirements(final Long runId, final PipelineRun pipelineRun,\n-                                              final PipelineRunScheduleVO runScheduleVO) {\n-        checkIdenticalCronExpressionForRun(runId, runScheduleVO);\n-        verifyRunSchedule(runId, pipelineRun, runScheduleVO);\n+    @Transactional(propagation = Propagation.REQUIRED)\n+    public void deleteSchedulesForRunByPipeline(final Long pipelineId) {\n+        runScheduleDao.deleteRunSchedulesForRunByPipeline(pipelineId);\n+    }\n+\n+    private void checkNewRunScheduleRequirements(final Long schedulableId, final PipelineRunScheduleVO runScheduleVO,\n+                                                 final ScheduleType scheduleType) {\n+        checkIdenticalCronExpression(schedulableId, scheduleType, runScheduleVO);\n+        verifyRunSchedule(schedulableId, runScheduleVO, scheduleType);\n     }\n \n-    private void verifyRunSchedule(final Long runId, final PipelineRun pipelineRun,\n-                                   final PipelineRunScheduleVO runScheduleVO) {\n+    private void verifyRunSchedule(final Long runId, final PipelineRunScheduleVO runScheduleVO,\n+                                   final ScheduleType type) {\n         verifyCronExpression(runId, runScheduleVO);\n         Assert.notNull(runScheduleVO.getAction(),\n                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_PROVIDED, runId));\n-        Assert.notNull(pipelineRun,\n-                       messageHelper.getMessage(MessageConstants.ERROR_RUN_PIPELINES_NOT_FOUND, pipelineRun.getName()));\n-        Assert.isTrue(!pipelineRun.getInstance().getSpot(), messageHelper.getMessage(\n-            MessageConstants.ERROR_ON_DEMAND_REQUIRED));\n-        Assert.isTrue(!pipelineRun.getStatus().isFinal(), messageHelper.getMessage(\n-            MessageConstants.ERROR_PIPELINE_RUN_FINISHED, runId));\n         Assert.isTrue(StringUtils.hasText(runScheduleVO.getTimeZone()),\n                       messageHelper.getMessage(MessageConstants.ERROR_TIME_ZONE_IS_NOT_PROVIDED, runId));\n-        Assert.isTrue(!(runScheduleVO.getAction().equals(RunScheduledAction.PAUSE)\n-                        && isNonPauseOrClusterRun(pipelineRun)),\n-                      messageHelper.getMessage(MessageConstants.DEBUG_RUN_IDLE_SKIP_CHECK));\n+        switch (type) {\n+            case PIPELINE_RUN:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgyNzcwMA==", "bodyText": "missing final", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375827700", "createdAt": "2020-02-06T13:19:08Z", "author": {"login": "mzueva"}, "path": "api/src/main/java/com/epam/pipeline/manager/pipeline/RunScheduleManager.java", "diffHunk": "@@ -135,73 +148,115 @@ public void init() {\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public List<RunSchedule> deleteRunSchedules(final Long runId, final List<Long> scheduleIds) {\n+    public List<RunSchedule> deleteSchedules(final Long schedulableId, final ScheduleType scheduleType,\n+                                             final List<Long> scheduleIds) {\n         final List<RunSchedule> schedules = scheduleIds.stream()\n-            .map(this::loadRunSchedule)\n-            .peek(schedule -> Assert.isTrue(runId.equals(schedule.getRunId()),\n-                                        messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING)))\n+            .map(this::loadSchedule)\n+            .peek(schedule -> Assert.isTrue(\n+                    schedulableId.equals(schedule.getSchedulableId()) && schedule.getType() == scheduleType,\n+                    messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING))\n+            )\n             .peek(scheduler::unscheduleRunSchedule)\n             .collect(Collectors.toList());\n         runScheduleDao.deleteRunSchedules(scheduleIds);\n         return schedules;\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public void deleteRunSchedulesForRun(final Long runId) {\n-        runScheduleDao.deleteRunSchedulesForRun(runId);\n+    public void deleteSchedules(final Long schedulableId, final ScheduleType scheduleType) {\n+        runScheduleDao.deleteRunSchedules(schedulableId, scheduleType);\n     }\n \n-    public RunSchedule loadRunSchedule(final Long id) {\n+    public RunSchedule loadSchedule(final Long id) {\n         return runScheduleDao.loadRunSchedule(id).orElseThrow(() -> new IllegalArgumentException(\n             messageHelper.getMessage(MessageConstants.ERROR_RUN_SCHEDULE_NOT_FOUND, id)));\n     }\n \n-    private void checkNewScheduleRequirements(final Long runId, final PipelineRun pipelineRun,\n-                                              final PipelineRunScheduleVO runScheduleVO) {\n-        checkIdenticalCronExpressionForRun(runId, runScheduleVO);\n-        verifyRunSchedule(runId, pipelineRun, runScheduleVO);\n+    @Transactional(propagation = Propagation.REQUIRED)\n+    public void deleteSchedulesForRunByPipeline(final Long pipelineId) {\n+        runScheduleDao.deleteRunSchedulesForRunByPipeline(pipelineId);\n+    }\n+\n+    private void checkNewRunScheduleRequirements(final Long schedulableId, final PipelineRunScheduleVO runScheduleVO,\n+                                                 final ScheduleType scheduleType) {\n+        checkIdenticalCronExpression(schedulableId, scheduleType, runScheduleVO);\n+        verifyRunSchedule(schedulableId, runScheduleVO, scheduleType);\n     }\n \n-    private void verifyRunSchedule(final Long runId, final PipelineRun pipelineRun,\n-                                   final PipelineRunScheduleVO runScheduleVO) {\n+    private void verifyRunSchedule(final Long runId, final PipelineRunScheduleVO runScheduleVO,\n+                                   final ScheduleType type) {\n         verifyCronExpression(runId, runScheduleVO);\n         Assert.notNull(runScheduleVO.getAction(),\n                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_PROVIDED, runId));\n-        Assert.notNull(pipelineRun,\n-                       messageHelper.getMessage(MessageConstants.ERROR_RUN_PIPELINES_NOT_FOUND, pipelineRun.getName()));\n-        Assert.isTrue(!pipelineRun.getInstance().getSpot(), messageHelper.getMessage(\n-            MessageConstants.ERROR_ON_DEMAND_REQUIRED));\n-        Assert.isTrue(!pipelineRun.getStatus().isFinal(), messageHelper.getMessage(\n-            MessageConstants.ERROR_PIPELINE_RUN_FINISHED, runId));\n         Assert.isTrue(StringUtils.hasText(runScheduleVO.getTimeZone()),\n                       messageHelper.getMessage(MessageConstants.ERROR_TIME_ZONE_IS_NOT_PROVIDED, runId));\n-        Assert.isTrue(!(runScheduleVO.getAction().equals(RunScheduledAction.PAUSE)\n-                        && isNonPauseOrClusterRun(pipelineRun)),\n-                      messageHelper.getMessage(MessageConstants.DEBUG_RUN_IDLE_SKIP_CHECK));\n+        switch (type) {\n+            case PIPELINE_RUN:\n+                Assert.isTrue(runScheduleVO.getAction() == RunScheduledAction.PAUSE\n+                        || runScheduleVO.getAction() == RunScheduledAction.RESUME,\n+                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_ALLOWED,\n+                                RunScheduledAction.RESUME.name() + \", \" + RunScheduledAction.PAUSE.name(),\n+                                runScheduleVO.getAction()));\n+                break;\n+            case RUN_CONFIGURATION:\n+                Assert.isTrue(runScheduleVO.getAction() == RunScheduledAction.RUN,\n+                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_ALLOWED,\n+                                RunScheduledAction.RUN.name(), runScheduleVO.getAction()));\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    private void verifySchedulable(final Long schedulableId, final ScheduleType scheduleType) {\n+        switch (scheduleType) {\n+            case PIPELINE_RUN:\n+                PipelineRun pipelineRun = pipelineRunManager.loadPipelineRun(schedulableId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgyNzg5NA==", "bodyText": "Not sure: shouldn't we throw an exception here?", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375827894", "createdAt": "2020-02-06T13:19:37Z", "author": {"login": "mzueva"}, "path": "api/src/main/java/com/epam/pipeline/manager/pipeline/RunScheduleManager.java", "diffHunk": "@@ -135,73 +148,115 @@ public void init() {\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public List<RunSchedule> deleteRunSchedules(final Long runId, final List<Long> scheduleIds) {\n+    public List<RunSchedule> deleteSchedules(final Long schedulableId, final ScheduleType scheduleType,\n+                                             final List<Long> scheduleIds) {\n         final List<RunSchedule> schedules = scheduleIds.stream()\n-            .map(this::loadRunSchedule)\n-            .peek(schedule -> Assert.isTrue(runId.equals(schedule.getRunId()),\n-                                        messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING)))\n+            .map(this::loadSchedule)\n+            .peek(schedule -> Assert.isTrue(\n+                    schedulableId.equals(schedule.getSchedulableId()) && schedule.getType() == scheduleType,\n+                    messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING))\n+            )\n             .peek(scheduler::unscheduleRunSchedule)\n             .collect(Collectors.toList());\n         runScheduleDao.deleteRunSchedules(scheduleIds);\n         return schedules;\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public void deleteRunSchedulesForRun(final Long runId) {\n-        runScheduleDao.deleteRunSchedulesForRun(runId);\n+    public void deleteSchedules(final Long schedulableId, final ScheduleType scheduleType) {\n+        runScheduleDao.deleteRunSchedules(schedulableId, scheduleType);\n     }\n \n-    public RunSchedule loadRunSchedule(final Long id) {\n+    public RunSchedule loadSchedule(final Long id) {\n         return runScheduleDao.loadRunSchedule(id).orElseThrow(() -> new IllegalArgumentException(\n             messageHelper.getMessage(MessageConstants.ERROR_RUN_SCHEDULE_NOT_FOUND, id)));\n     }\n \n-    private void checkNewScheduleRequirements(final Long runId, final PipelineRun pipelineRun,\n-                                              final PipelineRunScheduleVO runScheduleVO) {\n-        checkIdenticalCronExpressionForRun(runId, runScheduleVO);\n-        verifyRunSchedule(runId, pipelineRun, runScheduleVO);\n+    @Transactional(propagation = Propagation.REQUIRED)\n+    public void deleteSchedulesForRunByPipeline(final Long pipelineId) {\n+        runScheduleDao.deleteRunSchedulesForRunByPipeline(pipelineId);\n+    }\n+\n+    private void checkNewRunScheduleRequirements(final Long schedulableId, final PipelineRunScheduleVO runScheduleVO,\n+                                                 final ScheduleType scheduleType) {\n+        checkIdenticalCronExpression(schedulableId, scheduleType, runScheduleVO);\n+        verifyRunSchedule(schedulableId, runScheduleVO, scheduleType);\n     }\n \n-    private void verifyRunSchedule(final Long runId, final PipelineRun pipelineRun,\n-                                   final PipelineRunScheduleVO runScheduleVO) {\n+    private void verifyRunSchedule(final Long runId, final PipelineRunScheduleVO runScheduleVO,\n+                                   final ScheduleType type) {\n         verifyCronExpression(runId, runScheduleVO);\n         Assert.notNull(runScheduleVO.getAction(),\n                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_PROVIDED, runId));\n-        Assert.notNull(pipelineRun,\n-                       messageHelper.getMessage(MessageConstants.ERROR_RUN_PIPELINES_NOT_FOUND, pipelineRun.getName()));\n-        Assert.isTrue(!pipelineRun.getInstance().getSpot(), messageHelper.getMessage(\n-            MessageConstants.ERROR_ON_DEMAND_REQUIRED));\n-        Assert.isTrue(!pipelineRun.getStatus().isFinal(), messageHelper.getMessage(\n-            MessageConstants.ERROR_PIPELINE_RUN_FINISHED, runId));\n         Assert.isTrue(StringUtils.hasText(runScheduleVO.getTimeZone()),\n                       messageHelper.getMessage(MessageConstants.ERROR_TIME_ZONE_IS_NOT_PROVIDED, runId));\n-        Assert.isTrue(!(runScheduleVO.getAction().equals(RunScheduledAction.PAUSE)\n-                        && isNonPauseOrClusterRun(pipelineRun)),\n-                      messageHelper.getMessage(MessageConstants.DEBUG_RUN_IDLE_SKIP_CHECK));\n+        switch (type) {\n+            case PIPELINE_RUN:\n+                Assert.isTrue(runScheduleVO.getAction() == RunScheduledAction.PAUSE\n+                        || runScheduleVO.getAction() == RunScheduledAction.RESUME,\n+                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_ALLOWED,\n+                                RunScheduledAction.RESUME.name() + \", \" + RunScheduledAction.PAUSE.name(),\n+                                runScheduleVO.getAction()));\n+                break;\n+            case RUN_CONFIGURATION:\n+                Assert.isTrue(runScheduleVO.getAction() == RunScheduledAction.RUN,\n+                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_ALLOWED,\n+                                RunScheduledAction.RUN.name(), runScheduleVO.getAction()));\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    private void verifySchedulable(final Long schedulableId, final ScheduleType scheduleType) {\n+        switch (scheduleType) {\n+            case PIPELINE_RUN:\n+                PipelineRun pipelineRun = pipelineRunManager.loadPipelineRun(schedulableId);\n+                Assert.notNull(pipelineRun, messageHelper\n+                        .getMessage(MessageConstants.ERROR_RUN_PIPELINES_NOT_FOUND, pipelineRun.getName()));\n+                Assert.isTrue(!pipelineRun.getInstance().getSpot(), messageHelper.getMessage(\n+                        MessageConstants.ERROR_ON_DEMAND_REQUIRED));\n+                Assert.isTrue(!pipelineRun.getStatus().isFinal(), messageHelper.getMessage(\n+                        MessageConstants.ERROR_PIPELINE_RUN_FINISHED, schedulableId));\n+                Assert.isTrue(!isNonPauseOrClusterRun(pipelineRun),\n+                        messageHelper.getMessage(MessageConstants.DEBUG_RUN_IDLE_SKIP_CHECK));\n+                break;\n+            case RUN_CONFIGURATION:\n+                RunConfiguration configuration = configurationManager.load(schedulableId);\n+                Assert.notNull(configuration,\n+                        messageHelper.getMessage(MessageConstants.ERROR_RUN_CONFIG_NOT_FOUND, schedulableId));\n+                break;\n+            default:\n+                log.error(messageHelper.getMessage(MessageConstants.CRON_EXPRESSION_IDENTICAL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgyOTA4Ng==", "bodyText": "One more place to use some polymorphic interface for handling different ScheduleTypes", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375829086", "createdAt": "2020-02-06T13:22:19Z", "author": {"login": "mzueva"}, "path": "api/src/main/java/com/epam/pipeline/manager/scheduling/RunScheduler.java", "diffHunk": "@@ -68,42 +78,50 @@ public void init() {\n \n     public void scheduleRunSchedule(final RunSchedule schedule) {\n         try {\n-            log.debug(\"Request received to schedule run \");\n+            log.debug(\"Request received to schedule action: \" + schedule.getAction() + \" for \"\n+                    + schedule.getType() + ID + schedule.getSchedulableId());\n             final JobDetail jobDetail = jobDetail(schedule);\n \n             log.debug(\"Creating trigger for key \" + jobDetail.getKey().getName() + \" at date: \" + DateUtils.now());\n             final Trigger cronTrigger = createCronTrigger(schedule);\n \n             final Date scheduledDate = quartzScheduler.scheduleJob(jobDetail, cronTrigger);\n-            log.debug(\"Job for run: \" + schedule.getRunId() + \" scheduled successfully for date: \" + scheduledDate);\n+            log.debug(\"Job for: \" + schedule.getType() + ID\n+                    + schedule.getSchedulableId() + \" scheduled successfully for date: \" + scheduledDate);\n         } catch (SchedulerException | ParseException e) {\n-            log.error(\"SchedulerException while scheduling job for run \" + schedule.getRunId() + \" : \" +\n+            log.error(\"SchedulerException while scheduling job for run \" + schedule.getSchedulableId() + \" : \" +\n                       e.getMessage());\n         }\n     }\n \n     public void unscheduleRunSchedule(final RunSchedule schedule) {\n         try {\n-            log.debug(\"Request received to unscheduling trigger for run \" + schedule.getRunId());\n+            log.debug(\"Request received to unscheduling trigger for: \" + schedule.getType()\n+                    + ID + schedule.getSchedulableId());\n \n             final JobKey key = jobDetail(schedule).getKey();\n \n             quartzScheduler.deleteJob(key);\n \n-            log.debug(\"Schedule \" + schedule.getCronExpression() + \" for run \" + schedule.getRunId() +\n-                      \" was revoked successfully.\");\n+            log.debug(\"Schedule \" + schedule.getCronExpression() + \" for \"  + schedule.getType()\n+                    + ID + schedule.getSchedulableId() + \" was revoked successfully.\");\n         } catch (SchedulerException e) {\n-            log.error(\"SchedulerException while unscheduling trigger for run \" + schedule.getRunId() + \" : \" +\n-                      e.getMessage());\n+            log.error(\"SchedulerException while unscheduling trigger for \"  + schedule.getType()\n+                    + ID + schedule.getSchedulableId() + \" : \" + e.getMessage());\n         }\n     }\n \n     private JobDetail jobDetail(final RunSchedule runSchedule) {\n         JobDetailFactoryBean jobDetailFactory = new JobDetailFactoryBean();\n-        jobDetailFactory.setJobClass(RunScheduleJob.class);\n-        jobDetailFactory.getJobDataMap().put(\"RunId\", runSchedule.getRunId());\n+        jobDetailFactory.setJobClass(runSchedule.getType() == ScheduleType.PIPELINE_RUN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgzMTU2Nw==", "bodyText": "Method authManager.issueToken with null expiration will issue a token with default expiration (1 month by default). We need to specify expiration manually, if we need a long-term token", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375831567", "createdAt": "2020-02-06T13:27:29Z", "author": {"login": "mzueva"}, "path": "api/src/main/java/com/epam/pipeline/manager/scheduling/RunScheduler.java", "diffHunk": "@@ -68,42 +78,50 @@ public void init() {\n \n     public void scheduleRunSchedule(final RunSchedule schedule) {\n         try {\n-            log.debug(\"Request received to schedule run \");\n+            log.debug(\"Request received to schedule action: \" + schedule.getAction() + \" for \"\n+                    + schedule.getType() + ID + schedule.getSchedulableId());\n             final JobDetail jobDetail = jobDetail(schedule);\n \n             log.debug(\"Creating trigger for key \" + jobDetail.getKey().getName() + \" at date: \" + DateUtils.now());\n             final Trigger cronTrigger = createCronTrigger(schedule);\n \n             final Date scheduledDate = quartzScheduler.scheduleJob(jobDetail, cronTrigger);\n-            log.debug(\"Job for run: \" + schedule.getRunId() + \" scheduled successfully for date: \" + scheduledDate);\n+            log.debug(\"Job for: \" + schedule.getType() + ID\n+                    + schedule.getSchedulableId() + \" scheduled successfully for date: \" + scheduledDate);\n         } catch (SchedulerException | ParseException e) {\n-            log.error(\"SchedulerException while scheduling job for run \" + schedule.getRunId() + \" : \" +\n+            log.error(\"SchedulerException while scheduling job for run \" + schedule.getSchedulableId() + \" : \" +\n                       e.getMessage());\n         }\n     }\n \n     public void unscheduleRunSchedule(final RunSchedule schedule) {\n         try {\n-            log.debug(\"Request received to unscheduling trigger for run \" + schedule.getRunId());\n+            log.debug(\"Request received to unscheduling trigger for: \" + schedule.getType()\n+                    + ID + schedule.getSchedulableId());\n \n             final JobKey key = jobDetail(schedule).getKey();\n \n             quartzScheduler.deleteJob(key);\n \n-            log.debug(\"Schedule \" + schedule.getCronExpression() + \" for run \" + schedule.getRunId() +\n-                      \" was revoked successfully.\");\n+            log.debug(\"Schedule \" + schedule.getCronExpression() + \" for \"  + schedule.getType()\n+                    + ID + schedule.getSchedulableId() + \" was revoked successfully.\");\n         } catch (SchedulerException e) {\n-            log.error(\"SchedulerException while unscheduling trigger for run \" + schedule.getRunId() + \" : \" +\n-                      e.getMessage());\n+            log.error(\"SchedulerException while unscheduling trigger for \"  + schedule.getType()\n+                    + ID + schedule.getSchedulableId() + \" : \" + e.getMessage());\n         }\n     }\n \n     private JobDetail jobDetail(final RunSchedule runSchedule) {\n         JobDetailFactoryBean jobDetailFactory = new JobDetailFactoryBean();\n-        jobDetailFactory.setJobClass(RunScheduleJob.class);\n-        jobDetailFactory.getJobDataMap().put(\"RunId\", runSchedule.getRunId());\n+        jobDetailFactory.setJobClass(runSchedule.getType() == ScheduleType.PIPELINE_RUN\n+                ? RunScheduleJob.class\n+                : ConfigurationScheduleJob.class);\n+        jobDetailFactory.getJobDataMap().put(\"SchedulableId\", runSchedule.getSchedulableId());\n+        jobDetailFactory.getJobDataMap().put(\n+                \"UserToken\", authManager.issueToken(userManager.loadUserContext(runSchedule.getUser()), null).getToken()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5"}, "originalPosition": 96}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a043ea59f27ddb84aca9ada6e9d2cad8e9276c4", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/1a043ea59f27ddb84aca9ada6e9d2cad8e9276c4", "committedDate": "2020-02-06T15:39:26Z", "message": "(issue #938) correction on review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9633ca5bdc0345fef6229a6d0c3a78051bb610dd", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/9633ca5bdc0345fef6229a6d0c3a78051bb610dd", "committedDate": "2020-02-06T15:42:11Z", "message": "(issue #938) controller description fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fe6e64e2f8f66d51b498ba9c625a873720e00cc", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/0fe6e64e2f8f66d51b498ba9c625a873720e00cc", "committedDate": "2020-02-06T16:29:29Z", "message": "(issue #938) restore Security Context by loading PipelineUser instead of using jwt token"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c4c5b443050e86508244880bb415e9b22bba01a3", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/c4c5b443050e86508244880bb415e9b22bba01a3", "committedDate": "2020-02-06T16:22:53Z", "message": "(issue #938) restore Security Context by loading PipelineUser instead of using jwt token"}, "afterCommit": {"oid": "0fe6e64e2f8f66d51b498ba9c625a873720e00cc", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/0fe6e64e2f8f66d51b498ba9c625a873720e00cc", "committedDate": "2020-02-06T16:29:29Z", "message": "(issue #938) restore Security Context by loading PipelineUser instead of using jwt token"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MDUwODkx", "url": "https://github.com/epam/cloud-pipeline/pull/944#pullrequestreview-355050891", "createdAt": "2020-02-07T10:07:36Z", "commit": {"oid": "0fe6e64e2f8f66d51b498ba9c625a873720e00cc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c270e932d4981b67339467e3a34dc9907c308e7a", "author": {"user": {"login": "SilinPavel", "name": "Pavel Silin"}}, "url": "https://github.com/epam/cloud-pipeline/commit/c270e932d4981b67339467e3a34dc9907c308e7a", "committedDate": "2020-02-07T10:59:50Z", "message": "(issue #938) test fix"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3867, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}