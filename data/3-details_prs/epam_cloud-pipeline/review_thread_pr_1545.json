{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2MDg5ODk5", "number": 1545, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTozNzoyMlrOE4N9VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjowNzo0NVrOE4O4PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzg0NDA1OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTozNzoyMlrOHyAkdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTozNzoyMlrOHyAkdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwMDE4Mg==", "bodyText": "Let's move this constants to CommonCreatorConstants class.", "url": "https://github.com/epam/cloud-pipeline/pull/1545#discussion_r522200182", "createdAt": "2020-11-12T15:37:22Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolApiServiceTest.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.entity.configuration.ConfigurationEntry;\n+import com.epam.pipeline.entity.docker.ImageDescription;\n+import com.epam.pipeline.entity.docker.ImageHistoryLayer;\n+import com.epam.pipeline.entity.docker.ToolDescription;\n+import com.epam.pipeline.entity.docker.ToolVersion;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.scan.ToolScanPolicy;\n+import com.epam.pipeline.entity.scan.ToolScanResult;\n+import com.epam.pipeline.entity.scan.ToolScanResultView;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResult;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResultView;\n+import com.epam.pipeline.entity.tool.ToolSymlinkRequest;\n+import com.epam.pipeline.manager.docker.ToolVersionManager;\n+import com.epam.pipeline.manager.docker.scan.ToolScanManager;\n+import com.epam.pipeline.manager.docker.scan.ToolScanScheduler;\n+import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n+import com.epam.pipeline.manager.pipeline.ToolManager;\n+import com.epam.pipeline.manager.security.AuthManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolGroupCreatorUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.core.context.SecurityContextHolder;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.io.ByteArrayInputStream;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_LIST;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.mockito.Mockito.doReturn;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.verify;\n+\n+public class ToolApiServiceTest extends AbstractAclTest {\n+\n+    private static final String TOOL_GROUP_MANAGER = \"TOOL_GROUP_MANAGER\";\n+    private static final int READ_PERMISSION = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34721112977367b3552a995cbdcd3952ffe5f571"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzkwOTE1OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1MDoxNFrOHyBNEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1MDoxNFrOHyBNEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxMDU3Ng==", "bodyText": "Could we use StringUtils.EMPTY or other meaningful name?", "url": "https://github.com/epam/cloud-pipeline/pull/1545#discussion_r522210576", "createdAt": "2020-11-12T15:50:14Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolApiServiceTest.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.entity.configuration.ConfigurationEntry;\n+import com.epam.pipeline.entity.docker.ImageDescription;\n+import com.epam.pipeline.entity.docker.ImageHistoryLayer;\n+import com.epam.pipeline.entity.docker.ToolDescription;\n+import com.epam.pipeline.entity.docker.ToolVersion;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.scan.ToolScanPolicy;\n+import com.epam.pipeline.entity.scan.ToolScanResult;\n+import com.epam.pipeline.entity.scan.ToolScanResultView;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResult;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResultView;\n+import com.epam.pipeline.entity.tool.ToolSymlinkRequest;\n+import com.epam.pipeline.manager.docker.ToolVersionManager;\n+import com.epam.pipeline.manager.docker.scan.ToolScanManager;\n+import com.epam.pipeline.manager.docker.scan.ToolScanScheduler;\n+import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n+import com.epam.pipeline.manager.pipeline.ToolManager;\n+import com.epam.pipeline.manager.security.AuthManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolGroupCreatorUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.core.context.SecurityContextHolder;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.io.ByteArrayInputStream;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_LIST;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.mockito.Mockito.doReturn;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.verify;\n+\n+public class ToolApiServiceTest extends AbstractAclTest {\n+\n+    private static final String TOOL_GROUP_MANAGER = \"TOOL_GROUP_MANAGER\";\n+    private static final int READ_PERMISSION = 1;\n+    private static final int WRITE_PERMISSION = 2;\n+    private static final int EXECUTE_PERMISSION = 4;\n+    private static final List<ConfigurationEntry> CONFIG_LIST = Collections.singletonList(new ConfigurationEntry());\n+    private final Tool tool = ToolCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final ToolVersionScanResult toolVersionScanResult = ToolCreatorUtils.getToolVersionScanResult();\n+    private final ImageDescription imageDescription = ToolCreatorUtils.getImageDescription();\n+    private final List<ImageHistoryLayer> imageHistoryLayers =\n+            Collections.singletonList(ToolCreatorUtils.getImageHistoryLayer());\n+    private final Pair<String, ByteArrayInputStream> pair =\n+            Pair.of(TEST_STRING, new ByteArrayInputStream(TEST_STRING.getBytes()));\n+    private final ToolDescription toolDescription = ToolCreatorUtils.getToolDescription();\n+    private final ToolVersion toolVersion = ToolCreatorUtils.getToolVersion();\n+    private final ToolScanPolicy toolScanPolicy = new ToolScanPolicy();\n+    private final List<ToolVersion> toolVersionList = Collections.singletonList(toolVersion);\n+    private final ToolSymlinkRequest toolSymlinkRequest = ToolCreatorUtils.getToolSymlinkRequest();\n+    private final ToolScanResult toolScanResult = ToolCreatorUtils.getToolScanResult();\n+    private final ToolScanResultView toolScanResultView = new ToolScanResultView(toolScanResult.getToolId(),\n+            Collections.singletonMap(TEST_STRING, ToolVersionScanResultView.builder().version(TEST_STRING).build()));\n+    private final ToolGroup toolGroup = ToolGroupCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+\n+    @Autowired\n+    private ToolApiService toolApiService;\n+\n+    @Autowired\n+    private ToolManager mockToolManager;\n+\n+    @Autowired\n+    private ToolScanManager mockToolScanManager;\n+\n+    @Autowired\n+    private ToolScanScheduler mockToolScanScheduler;\n+\n+    @Autowired\n+    private ToolVersionManager mockToolVersionManager;\n+\n+    @Autowired\n+    private ToolGroupManager mockToolGroupManager;\n+\n+    @Autowired\n+    private AuthManager mockAuthManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateToolForAdmin() {\n+        doReturn(tool).when(mockToolManager).create(tool, true);\n+\n+        assertThat(toolApiService.create(tool)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldCreateToolWhenPermissionIsGranted() {\n+        doReturn(tool).when(mockToolManager).create(tool, true);\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+\n+        assertThat(toolApiService.create(tool)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyCreateToolWhenPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolApiService.create(tool));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateToolForAdmin() {\n+        doReturn(tool).when(mockToolManager).updateTool(tool);\n+\n+        assertThat(toolApiService.updateTool(tool)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateToolWhenPermissionIsGranted() {\n+        doReturn(tool).when(mockToolManager).loadTool(TEST_STRING, TEST_STRING);\n+        doReturn(tool).when(mockToolManager).updateTool(tool);\n+        initAclEntity(tool, AclPermission.WRITE);\n+\n+        doReturn(SecurityContextHolder.getContext().getAuthentication()).when(mockAuthManager).getAuthentication();\n+        final Tool returnedTool = toolApiService.updateTool(tool);\n+\n+        assertThat(returnedTool.getMask()).isEqualTo(WRITE_PERMISSION);\n+        assertThat(returnedTool).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateToolWhenPermissionIsNotGranted() {\n+        doReturn(tool).when(mockToolManager).loadTool(TEST_STRING, TEST_STRING);\n+        initAclEntity(tool);\n+\n+        doReturn(SecurityContextHolder.getContext().getAuthentication()).when(mockAuthManager).getAuthentication();\n+\n+        assertThrows(AccessDeniedException.class, () -> toolApiService.updateTool(tool));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void updateWhiteListWithToolVersion() {\n+        doReturn(toolVersionScanResult).when(mockToolManager)\n+                .updateWhiteListWithToolVersionStatus(ID, TEST_STRING, true);\n+\n+        assertThat(toolApiService.updateWhiteListWithToolVersion(ID, TEST_STRING, true))\n+                .isEqualTo(toolVersionScanResult);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateWhiteListWithToolVersion() {\n+        doReturn(toolVersionScanResult).when(mockToolManager)\n+                .updateWhiteListWithToolVersionStatus(ID, TEST_STRING, true);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> toolApiService.updateWhiteListWithToolVersion(ID, TEST_STRING, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolWithRegistryForAdmin() {\n+        doReturn(tool).when(mockToolManager).loadTool(TEST_STRING, TEST_STRING);\n+\n+        assertThat(toolApiService.loadTool(TEST_STRING, TEST_STRING)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolWithoutRegistryForAdmin() {\n+        doReturn(tool).when(mockToolManager).loadByNameOrId(TEST_STRING);\n+\n+        assertThat(toolApiService.loadTool(\"\", TEST_STRING)).isEqualTo(tool);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34721112977367b3552a995cbdcd3952ffe5f571"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzkzNDAxOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1NToxNlrOHyBcgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1NToxNlrOHyBcgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxNDUyOA==", "bodyText": "Maybe it would be useful (for other tests too) to create a new common method e.g. mockSecurityContext?", "url": "https://github.com/epam/cloud-pipeline/pull/1545#discussion_r522214528", "createdAt": "2020-11-12T15:55:16Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolApiServiceTest.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.entity.configuration.ConfigurationEntry;\n+import com.epam.pipeline.entity.docker.ImageDescription;\n+import com.epam.pipeline.entity.docker.ImageHistoryLayer;\n+import com.epam.pipeline.entity.docker.ToolDescription;\n+import com.epam.pipeline.entity.docker.ToolVersion;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.scan.ToolScanPolicy;\n+import com.epam.pipeline.entity.scan.ToolScanResult;\n+import com.epam.pipeline.entity.scan.ToolScanResultView;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResult;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResultView;\n+import com.epam.pipeline.entity.tool.ToolSymlinkRequest;\n+import com.epam.pipeline.manager.docker.ToolVersionManager;\n+import com.epam.pipeline.manager.docker.scan.ToolScanManager;\n+import com.epam.pipeline.manager.docker.scan.ToolScanScheduler;\n+import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n+import com.epam.pipeline.manager.pipeline.ToolManager;\n+import com.epam.pipeline.manager.security.AuthManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolGroupCreatorUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.core.context.SecurityContextHolder;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.io.ByteArrayInputStream;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_LIST;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.mockito.Mockito.doReturn;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.verify;\n+\n+public class ToolApiServiceTest extends AbstractAclTest {\n+\n+    private static final String TOOL_GROUP_MANAGER = \"TOOL_GROUP_MANAGER\";\n+    private static final int READ_PERMISSION = 1;\n+    private static final int WRITE_PERMISSION = 2;\n+    private static final int EXECUTE_PERMISSION = 4;\n+    private static final List<ConfigurationEntry> CONFIG_LIST = Collections.singletonList(new ConfigurationEntry());\n+    private final Tool tool = ToolCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final ToolVersionScanResult toolVersionScanResult = ToolCreatorUtils.getToolVersionScanResult();\n+    private final ImageDescription imageDescription = ToolCreatorUtils.getImageDescription();\n+    private final List<ImageHistoryLayer> imageHistoryLayers =\n+            Collections.singletonList(ToolCreatorUtils.getImageHistoryLayer());\n+    private final Pair<String, ByteArrayInputStream> pair =\n+            Pair.of(TEST_STRING, new ByteArrayInputStream(TEST_STRING.getBytes()));\n+    private final ToolDescription toolDescription = ToolCreatorUtils.getToolDescription();\n+    private final ToolVersion toolVersion = ToolCreatorUtils.getToolVersion();\n+    private final ToolScanPolicy toolScanPolicy = new ToolScanPolicy();\n+    private final List<ToolVersion> toolVersionList = Collections.singletonList(toolVersion);\n+    private final ToolSymlinkRequest toolSymlinkRequest = ToolCreatorUtils.getToolSymlinkRequest();\n+    private final ToolScanResult toolScanResult = ToolCreatorUtils.getToolScanResult();\n+    private final ToolScanResultView toolScanResultView = new ToolScanResultView(toolScanResult.getToolId(),\n+            Collections.singletonMap(TEST_STRING, ToolVersionScanResultView.builder().version(TEST_STRING).build()));\n+    private final ToolGroup toolGroup = ToolGroupCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+\n+    @Autowired\n+    private ToolApiService toolApiService;\n+\n+    @Autowired\n+    private ToolManager mockToolManager;\n+\n+    @Autowired\n+    private ToolScanManager mockToolScanManager;\n+\n+    @Autowired\n+    private ToolScanScheduler mockToolScanScheduler;\n+\n+    @Autowired\n+    private ToolVersionManager mockToolVersionManager;\n+\n+    @Autowired\n+    private ToolGroupManager mockToolGroupManager;\n+\n+    @Autowired\n+    private AuthManager mockAuthManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateToolForAdmin() {\n+        doReturn(tool).when(mockToolManager).create(tool, true);\n+\n+        assertThat(toolApiService.create(tool)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldCreateToolWhenPermissionIsGranted() {\n+        doReturn(tool).when(mockToolManager).create(tool, true);\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+\n+        assertThat(toolApiService.create(tool)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyCreateToolWhenPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolApiService.create(tool));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateToolForAdmin() {\n+        doReturn(tool).when(mockToolManager).updateTool(tool);\n+\n+        assertThat(toolApiService.updateTool(tool)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateToolWhenPermissionIsGranted() {\n+        doReturn(tool).when(mockToolManager).loadTool(TEST_STRING, TEST_STRING);\n+        doReturn(tool).when(mockToolManager).updateTool(tool);\n+        initAclEntity(tool, AclPermission.WRITE);\n+\n+        doReturn(SecurityContextHolder.getContext().getAuthentication()).when(mockAuthManager).getAuthentication();\n+        final Tool returnedTool = toolApiService.updateTool(tool);\n+\n+        assertThat(returnedTool.getMask()).isEqualTo(WRITE_PERMISSION);\n+        assertThat(returnedTool).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateToolWhenPermissionIsNotGranted() {\n+        doReturn(tool).when(mockToolManager).loadTool(TEST_STRING, TEST_STRING);\n+        initAclEntity(tool);\n+\n+        doReturn(SecurityContextHolder.getContext().getAuthentication()).when(mockAuthManager).getAuthentication();\n+\n+        assertThrows(AccessDeniedException.class, () -> toolApiService.updateTool(tool));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void updateWhiteListWithToolVersion() {\n+        doReturn(toolVersionScanResult).when(mockToolManager)\n+                .updateWhiteListWithToolVersionStatus(ID, TEST_STRING, true);\n+\n+        assertThat(toolApiService.updateWhiteListWithToolVersion(ID, TEST_STRING, true))\n+                .isEqualTo(toolVersionScanResult);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateWhiteListWithToolVersion() {\n+        doReturn(toolVersionScanResult).when(mockToolManager)\n+                .updateWhiteListWithToolVersionStatus(ID, TEST_STRING, true);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> toolApiService.updateWhiteListWithToolVersion(ID, TEST_STRING, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolWithRegistryForAdmin() {\n+        doReturn(tool).when(mockToolManager).loadTool(TEST_STRING, TEST_STRING);\n+\n+        assertThat(toolApiService.loadTool(TEST_STRING, TEST_STRING)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolWithoutRegistryForAdmin() {\n+        doReturn(tool).when(mockToolManager).loadByNameOrId(TEST_STRING);\n+\n+        assertThat(toolApiService.loadTool(\"\", TEST_STRING)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolWithRegistryWhenPermissionIsGranted() {\n+        initAclEntity(tool, AclPermission.READ);\n+        doReturn(tool).when(mockToolManager).loadTool(TEST_STRING, TEST_STRING);\n+\n+        doReturn(SecurityContextHolder.getContext().getAuthentication()).when(mockAuthManager).getAuthentication();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34721112977367b3552a995cbdcd3952ffe5f571"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzk5NDg1OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjowNzo0NlrOHyCCjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjowNzo0NlrOHyCCjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyNDI3MA==", "bodyText": "I would rather not divide this logic: doReturn(SecurityContextHolder.getContext().getAuthentication()).when(mockAuthManager).getAuthentication(); is another mock in this test.", "url": "https://github.com/epam/cloud-pipeline/pull/1545#discussion_r522224270", "createdAt": "2020-11-12T16:07:46Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolApiServiceTest.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.entity.configuration.ConfigurationEntry;\n+import com.epam.pipeline.entity.docker.ImageDescription;\n+import com.epam.pipeline.entity.docker.ImageHistoryLayer;\n+import com.epam.pipeline.entity.docker.ToolDescription;\n+import com.epam.pipeline.entity.docker.ToolVersion;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.scan.ToolScanPolicy;\n+import com.epam.pipeline.entity.scan.ToolScanResult;\n+import com.epam.pipeline.entity.scan.ToolScanResultView;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResult;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResultView;\n+import com.epam.pipeline.entity.tool.ToolSymlinkRequest;\n+import com.epam.pipeline.manager.docker.ToolVersionManager;\n+import com.epam.pipeline.manager.docker.scan.ToolScanManager;\n+import com.epam.pipeline.manager.docker.scan.ToolScanScheduler;\n+import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n+import com.epam.pipeline.manager.pipeline.ToolManager;\n+import com.epam.pipeline.manager.security.AuthManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolGroupCreatorUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.core.context.SecurityContextHolder;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.io.ByteArrayInputStream;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_LIST;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.mockito.Mockito.doReturn;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.verify;\n+\n+public class ToolApiServiceTest extends AbstractAclTest {\n+\n+    private static final String TOOL_GROUP_MANAGER = \"TOOL_GROUP_MANAGER\";\n+    private static final int READ_PERMISSION = 1;\n+    private static final int WRITE_PERMISSION = 2;\n+    private static final int EXECUTE_PERMISSION = 4;\n+    private static final List<ConfigurationEntry> CONFIG_LIST = Collections.singletonList(new ConfigurationEntry());\n+    private final Tool tool = ToolCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final ToolVersionScanResult toolVersionScanResult = ToolCreatorUtils.getToolVersionScanResult();\n+    private final ImageDescription imageDescription = ToolCreatorUtils.getImageDescription();\n+    private final List<ImageHistoryLayer> imageHistoryLayers =\n+            Collections.singletonList(ToolCreatorUtils.getImageHistoryLayer());\n+    private final Pair<String, ByteArrayInputStream> pair =\n+            Pair.of(TEST_STRING, new ByteArrayInputStream(TEST_STRING.getBytes()));\n+    private final ToolDescription toolDescription = ToolCreatorUtils.getToolDescription();\n+    private final ToolVersion toolVersion = ToolCreatorUtils.getToolVersion();\n+    private final ToolScanPolicy toolScanPolicy = new ToolScanPolicy();\n+    private final List<ToolVersion> toolVersionList = Collections.singletonList(toolVersion);\n+    private final ToolSymlinkRequest toolSymlinkRequest = ToolCreatorUtils.getToolSymlinkRequest();\n+    private final ToolScanResult toolScanResult = ToolCreatorUtils.getToolScanResult();\n+    private final ToolScanResultView toolScanResultView = new ToolScanResultView(toolScanResult.getToolId(),\n+            Collections.singletonMap(TEST_STRING, ToolVersionScanResultView.builder().version(TEST_STRING).build()));\n+    private final ToolGroup toolGroup = ToolGroupCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+\n+    @Autowired\n+    private ToolApiService toolApiService;\n+\n+    @Autowired\n+    private ToolManager mockToolManager;\n+\n+    @Autowired\n+    private ToolScanManager mockToolScanManager;\n+\n+    @Autowired\n+    private ToolScanScheduler mockToolScanScheduler;\n+\n+    @Autowired\n+    private ToolVersionManager mockToolVersionManager;\n+\n+    @Autowired\n+    private ToolGroupManager mockToolGroupManager;\n+\n+    @Autowired\n+    private AuthManager mockAuthManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateToolForAdmin() {\n+        doReturn(tool).when(mockToolManager).create(tool, true);\n+\n+        assertThat(toolApiService.create(tool)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldCreateToolWhenPermissionIsGranted() {\n+        doReturn(tool).when(mockToolManager).create(tool, true);\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+\n+        assertThat(toolApiService.create(tool)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyCreateToolWhenPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolApiService.create(tool));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateToolForAdmin() {\n+        doReturn(tool).when(mockToolManager).updateTool(tool);\n+\n+        assertThat(toolApiService.updateTool(tool)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateToolWhenPermissionIsGranted() {\n+        doReturn(tool).when(mockToolManager).loadTool(TEST_STRING, TEST_STRING);\n+        doReturn(tool).when(mockToolManager).updateTool(tool);\n+        initAclEntity(tool, AclPermission.WRITE);\n+\n+        doReturn(SecurityContextHolder.getContext().getAuthentication()).when(mockAuthManager).getAuthentication();\n+        final Tool returnedTool = toolApiService.updateTool(tool);\n+\n+        assertThat(returnedTool.getMask()).isEqualTo(WRITE_PERMISSION);\n+        assertThat(returnedTool).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateToolWhenPermissionIsNotGranted() {\n+        doReturn(tool).when(mockToolManager).loadTool(TEST_STRING, TEST_STRING);\n+        initAclEntity(tool);\n+\n+        doReturn(SecurityContextHolder.getContext().getAuthentication()).when(mockAuthManager).getAuthentication();\n+\n+        assertThrows(AccessDeniedException.class, () -> toolApiService.updateTool(tool));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void updateWhiteListWithToolVersion() {\n+        doReturn(toolVersionScanResult).when(mockToolManager)\n+                .updateWhiteListWithToolVersionStatus(ID, TEST_STRING, true);\n+\n+        assertThat(toolApiService.updateWhiteListWithToolVersion(ID, TEST_STRING, true))\n+                .isEqualTo(toolVersionScanResult);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateWhiteListWithToolVersion() {\n+        doReturn(toolVersionScanResult).when(mockToolManager)\n+                .updateWhiteListWithToolVersionStatus(ID, TEST_STRING, true);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> toolApiService.updateWhiteListWithToolVersion(ID, TEST_STRING, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolWithRegistryForAdmin() {\n+        doReturn(tool).when(mockToolManager).loadTool(TEST_STRING, TEST_STRING);\n+\n+        assertThat(toolApiService.loadTool(TEST_STRING, TEST_STRING)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolWithoutRegistryForAdmin() {\n+        doReturn(tool).when(mockToolManager).loadByNameOrId(TEST_STRING);\n+\n+        assertThat(toolApiService.loadTool(\"\", TEST_STRING)).isEqualTo(tool);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolWithRegistryWhenPermissionIsGranted() {\n+        initAclEntity(tool, AclPermission.READ);\n+        doReturn(tool).when(mockToolManager).loadTool(TEST_STRING, TEST_STRING);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34721112977367b3552a995cbdcd3952ffe5f571"}, "originalPosition": 205}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 309, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}