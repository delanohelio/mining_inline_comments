{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4MzY0MDky", "number": 1555, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNTowMToyM1rOE3RGfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjozODoxMFrOE_IaJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Mzg3MzI0OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolGroupApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNTowMToyM1rOHwgu-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNTowMToyM1rOHwgu-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMDAxMQ==", "bodyText": "Maybe  you can replace 1 with something like private static final int READ_PERMISSION for better readability (as I did in the tests on DataStorageApiService). Or, in case you only check the READ permission mask, you can replace 1 with AclPermission.READ.getMask() (as it done in the Gitlab project). The same at line 195.", "url": "https://github.com/epam/cloud-pipeline/pull/1555#discussion_r520630011", "createdAt": "2020-11-10T15:01:23Z", "author": {"login": "YouKofan"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolGroupApiServiceTest.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.pipeline.ToolGroupWithIssues;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n+import com.epam.pipeline.manager.security.AuthManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolGroupCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.core.context.SecurityContextHolder;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class ToolGroupApiServiceTest extends AbstractAclTest {\n+\n+\n+    private static final String TOOL_GROUP_MANAGER = \"TOOL_GROUP_MANAGER\";\n+    private final ToolGroup toolGroup = ToolGroupCreatorUtils.getToolGroup(ID, SIMPLE_USER);\n+    private final ToolGroup anotherToolGroup = ToolGroupCreatorUtils.getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, SIMPLE_USER);\n+    private final Tool tool = ToolCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+\n+    @Autowired\n+    private ToolGroupApiService toolGroupApiService;\n+\n+    @Autowired\n+    private ToolGroupManager mockToolGroupManager;\n+\n+    @Autowired\n+    private AuthManager mockAuthManager;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).create(toolGroup);\n+\n+        assertThat(toolGroupApiService.create(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = TOOL_GROUP_MANAGER)\n+    public void shouldCreateToolGroupForManagerWhenPermissionGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(SIMPLE_USER).when(mockAuthManager).getAuthorizedUser();\n+        doReturn(toolGroup).when(mockToolGroupManager).create(toolGroup);\n+\n+        assertThat(toolGroupApiService.create(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateToolGroupWithInvalidRole() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).create(toolGroup);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.create(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = TOOL_GROUP_MANAGER)\n+    public void shouldDenyCreateToolGroupWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+        doReturn(SIMPLE_USER).when(mockAuthManager).getAuthorizedUser();\n+        doReturn(toolGroup).when(mockToolGroupManager).create(toolGroup);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.create(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).updateToolGroup(toolGroup);\n+\n+        assertThat(toolGroupApiService.update(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateToolGroupWhenPermissionIsGranted() {\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        doReturn(SIMPLE_USER).when(mockAuthManager).getAuthorizedUser();\n+        doReturn(toolGroup).when(mockToolGroupManager).updateToolGroup(toolGroup);\n+\n+        assertThat(toolGroupApiService.update(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateWhenPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.update(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolGroupsByRegistryIdForAdmin() {\n+        final List<ToolGroup> toolGroups = mutableListOf(toolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryId(ID);\n+\n+        assertThat(toolGroupApiService.loadByRegistryId(ID)).isEqualTo(toolGroups);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolGroupsByRegistryIdWhenPermissionIsGranted() {\n+        initAclEntity(anotherToolGroup, AclPermission.READ);\n+        doReturn(SIMPLE_USER).when(mockAuthManager).getAuthorizedUser();\n+        final List<ToolGroup> toolGroups = mutableListOf(anotherToolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryId(ID);\n+\n+        final List<ToolGroup> returnedTollGroups = toolGroupApiService.loadByRegistryId(ID);\n+\n+        assertThat(returnedTollGroups).isEqualTo(toolGroups);\n+        assertThat(returnedTollGroups.get(0).getMask()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f035951b1ffefcd99927996ea522a67ccad86b88"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Nzk1MTU1OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/ToolGroupCreatorUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMTowMDozNVrOHxIWBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMTowMDozNVrOHxIWBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI3ODk4MQ==", "bodyText": "To my mind it would be better to overload the method?\nCould we add final to method arguments?", "url": "https://github.com/epam/cloud-pipeline/pull/1555#discussion_r521278981", "createdAt": "2020-11-11T11:00:35Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/ToolGroupCreatorUtils.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.docker;\n+\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.pipeline.ToolGroupWithIssues;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+\n+public final class ToolGroupCreatorUtils {\n+\n+    private ToolGroupCreatorUtils() {\n+\n+    }\n+\n+    public static ToolGroup getToolGroup() {\n+        final ToolGroup toolGroup = new ToolGroup();\n+        toolGroup.setId(ID);\n+        toolGroup.setRegistryId(ID);\n+        return toolGroup;\n+    }\n+\n+    public static ToolGroup getToolGroup(Long id, String owner) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f035951b1ffefcd99927996ea522a67ccad86b88"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Nzk1NTQ4OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolGroupApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMTowMTo0OVrOHxIYaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMTowMTo0OVrOHxIYaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI3OTU5Mg==", "bodyText": "Could you please remove an extra empty line?", "url": "https://github.com/epam/cloud-pipeline/pull/1555#discussion_r521279592", "createdAt": "2020-11-11T11:01:49Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolGroupApiServiceTest.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.pipeline.ToolGroupWithIssues;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n+import com.epam.pipeline.manager.security.AuthManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolGroupCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.core.context.SecurityContextHolder;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class ToolGroupApiServiceTest extends AbstractAclTest {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f035951b1ffefcd99927996ea522a67ccad86b88"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2ODE0MDUzOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolGroupApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMTo1ODo1M1rOHxKJsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMTo1ODo1M1rOHxKJsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMwODU5NQ==", "bodyText": "Could you add test for AclTree annotation for this test class too?", "url": "https://github.com/epam/cloud-pipeline/pull/1555#discussion_r521308595", "createdAt": "2020-11-11T11:58:53Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolGroupApiServiceTest.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.pipeline.ToolGroupWithIssues;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n+import com.epam.pipeline.manager.security.AuthManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolGroupCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.core.context.SecurityContextHolder;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class ToolGroupApiServiceTest extends AbstractAclTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f035951b1ffefcd99927996ea522a67ccad86b88"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTg4MTk2OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolGroupApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDozOTozNVrOH8mZBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDozOTozNVrOH8mZBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMwNTYwNw==", "bodyText": "Remove empty line, please", "url": "https://github.com/epam/cloud-pipeline/pull/1555#discussion_r533305607", "createdAt": "2020-12-01T10:39:35Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolGroupApiServiceTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.pipeline.ToolGroupWithIssues;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class ToolGroupApiServiceTest extends AbstractAclTest {\n+\n+    private static final String TOOL_GROUP_MANAGER = \"TOOL_GROUP_MANAGER\";\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Arrays.asList(tool, toolWithoutPermission);\n+    private final ToolGroupWithIssues toolGroupWithIssues = DockerCreatorUtils.getToolGroupWithIssues();\n+\n+    @Autowired\n+    private ToolGroupApiService toolGroupApiService;\n+\n+    @Autowired\n+    private ToolGroupManager mockToolGroupManager;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).create(toolGroup);\n+\n+        assertThat(toolGroupApiService.create(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = TOOL_GROUP_MANAGER)\n+    public void shouldCreateToolGroupForManagerWhenPermissionGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).create(toolGroup);\n+\n+        assertThat(toolGroupApiService.create(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyCreateToolGroupWithInvalidRole() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.create(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = TOOL_GROUP_MANAGER, username = SIMPLE_USER)\n+    public void shouldDenyCreateToolGroupWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.create(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).updateToolGroup(toolGroup);\n+\n+        assertThat(toolGroupApiService.update(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateToolGroupWhenPermissionIsGranted() {\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).updateToolGroup(toolGroup);\n+\n+        assertThat(toolGroupApiService.update(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldDenyUpdateWhenPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.update(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolGroupsByRegistryIdForAdmin() {\n+        final List<ToolGroup> toolGroups = mutableListOf(toolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryId(ID);\n+\n+        assertThat(toolGroupApiService.loadByRegistryId(ID)).isEqualTo(toolGroups);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolGroupsByRegistryIdWhenPermissionIsGranted() {\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        final List<ToolGroup> toolGroups = mutableListOf(toolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryId(ID);\n+\n+        final List<ToolGroup> returnedTollGroups = toolGroupApiService.loadByRegistryId(ID);\n+\n+        assertThat(returnedTollGroups).isEqualTo(toolGroups);\n+        assertThat(returnedTollGroups.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolsGroupsByRegistryIdWhichPermissionIsGranted() {\n+        final ToolGroup anotherToolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(anotherToolGroup);\n+        doReturn(mutableListOf(toolGroup, anotherToolGroup)).when(mockToolGroupManager).loadByRegistryId(ID);\n+\n+        assertThat(toolGroupApiService.loadByRegistryId(ID)).hasSize(1).contains(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadToolGroupsByRegistryIdWhichPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+\n+        assertThat(toolGroupApiService.loadByRegistryId(ID)).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolGroupsByRegistryNameOrIdForAdmin() {\n+        final List<ToolGroup> toolGroups = mutableListOf(toolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryNameOrId(TEST_STRING);\n+\n+        assertThat(toolGroupApiService.loadByRegistryNameOrId(TEST_STRING)).isEqualTo(toolGroups);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolGroupsByRegistryNameOrIdWhenPermissionIsGranted() {\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        final List<ToolGroup> toolGroups = mutableListOf(toolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryNameOrId(TEST_STRING);\n+\n+        final List<ToolGroup> returnedTollGroups = toolGroupApiService.loadByRegistryNameOrId(TEST_STRING);\n+\n+        assertThat(returnedTollGroups).isEqualTo(toolGroups);\n+        assertThat(returnedTollGroups.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolsGroupsByRegistryNameOrIdWhichPermissionIsGranted() {\n+        final ToolGroup anotherToolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(anotherToolGroup);\n+        doReturn(mutableListOf(toolGroup, anotherToolGroup))\n+                .when(mockToolGroupManager).loadByRegistryNameOrId(TEST_STRING);\n+\n+        assertThat(toolGroupApiService.loadByRegistryNameOrId(TEST_STRING)).hasSize(1).contains(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldDenyLoadToolGroupsByRegistryNameOrIdWhichPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+\n+        assertThat(toolGroupApiService.loadByRegistryNameOrId(TEST_STRING)).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).load(ID);\n+\n+        assertThat(toolGroupApiService.load(ID)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadToolGroup() {\n+        final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        initAclEntity(dockerRegistry);\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setParent(dockerRegistry);\n+        doReturn(toolGroup).when(mockToolGroupManager).load(ID);\n+\n+        assertThat(toolGroupApiService.load(ID)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolGroupHierarchy() {\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setParent(dockerRegistry);\n+        toolGroup.setTools(tools);\n+        initToolGroupAclTree();\n+        doReturn(toolGroup).when(mockToolGroupManager).load(ID);\n+\n+        final ToolGroup returnedToolGroup = toolGroupApiService.load(ID);\n+\n+        assertToolGroupAclTree(returnedToolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadToolsWithIssuesCount() {\n+        doReturn(toolGroupWithIssues).when(mockToolGroupManager).loadToolsWithIssuesCount(ID);\n+\n+        assertThat(toolGroupApiService.loadToolsWithIssuesCount(ID)).isEqualTo(toolGroupWithIssues);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolsWithIssuesCountHierarchy() {\n+        final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroupWithIssues toolGroupWithIssues =\n+                DockerCreatorUtils.getToolGroupWithIssues(ID_2, ANOTHER_SIMPLE_USER);\n+        toolGroupWithIssues.setParent(dockerRegistry);\n+        toolGroupWithIssues.setTools(tools);\n+        initToolGroupAclTree();\n+        doReturn(toolGroupWithIssues).when(mockToolGroupManager).loadToolsWithIssuesCount(ID);\n+\n+        final ToolGroupWithIssues returnedToolGroup = toolGroupApiService.loadToolsWithIssuesCount(ID);\n+\n+        assertToolGroupAclTree(returnedToolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadByNameOrId() {\n+        final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        initAclEntity(dockerRegistry);\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setParent(dockerRegistry);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        assertThat(toolGroupApiService.loadByNameOrId(TEST_STRING)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolGroupHierarchyByNameOrId() {\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setParent(dockerRegistry);\n+        toolGroup.setTools(tools);\n+        initToolGroupAclTree();\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+\n+        final ToolGroup returnedToolGroup = toolGroupApiService.loadByNameOrId(TEST_STRING);\n+\n+        assertToolGroupAclTree(returnedToolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadPrivate() {\n+        doReturn(toolGroup).when(mockToolGroupManager).loadPrivate(ID);\n+\n+        assertThat(toolGroupApiService.loadPrivate(ID)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreatePrivateForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).createPrivate(ID);\n+\n+        assertThat(toolGroupApiService.createPrivate(ID)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldCreatePrivateWhenPermissionIsGranted() {\n+        final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        dockerRegistry.setGroups(mutableListOf(toolGroup));\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).getDockerRegistryTree(ID);\n+        doReturn(toolGroup).when(mockToolGroupManager).createPrivate(ID);\n+\n+        assertThat(toolGroupApiService.createPrivate(ID)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreatePrivateWhenPermissionIsNotGranted() {\n+        final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        initAclEntity(toolGroup);\n+        dockerRegistry.setGroups(mutableListOf(toolGroup));\n+        initAclEntity(dockerRegistry);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).getDockerRegistryTree(ID);\n+        doReturn(toolGroup).when(mockToolGroupManager).createPrivate(ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.createPrivate(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, false);\n+\n+        assertThat(toolGroupApiService.delete(TEST_STRING)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = TOOL_GROUP_MANAGER, username = SIMPLE_USER)\n+    public void shouldDeleteToolGroupForManagerWhenPermissionIsGranted() {\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, false);\n+        mockSecurityContext();\n+\n+        assertThat(toolGroupApiService.delete(TEST_STRING)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteToolGroupWithInvalidRole() {\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, false);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.delete(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = TOOL_GROUP_MANAGER)\n+    public void shouldDenyDeleteToolGroupWhenPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, false);\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.delete(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteForceToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, true);\n+\n+        assertThat(toolGroupApiService.deleteForce(TEST_STRING)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteForceToolGroupWithInvalidRole() {\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(mutableListOf(tool));\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        initAclEntity(tool, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.deleteForce(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = TOOL_GROUP_MANAGER, username = SIMPLE_USER)\n+    public void shouldDeleteForceToolGroupForManagerWhenChildPermissionIsGranted() {\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(mutableListOf(tool));\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        initAclEntity(tool, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, true);\n+        mockSecurityContext();\n+\n+        assertThat(toolGroupApiService.deleteForce(TEST_STRING)).isEqualTo(toolGroup);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f979c63c0e7cb36986ef900237c8acada5af979f"}, "originalPosition": 402}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjA3MTkxOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolGroupApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMToyNTozNVrOH8oPsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMDozNDoyMVrOH9UlOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzNTk4NQ==", "bodyText": "typo: returnedTollGroups -> returnedToolGroups", "url": "https://github.com/epam/cloud-pipeline/pull/1555#discussion_r533335985", "createdAt": "2020-12-01T11:25:35Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolGroupApiServiceTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.pipeline.ToolGroupWithIssues;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class ToolGroupApiServiceTest extends AbstractAclTest {\n+\n+    private static final String TOOL_GROUP_MANAGER = \"TOOL_GROUP_MANAGER\";\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Arrays.asList(tool, toolWithoutPermission);\n+    private final ToolGroupWithIssues toolGroupWithIssues = DockerCreatorUtils.getToolGroupWithIssues();\n+\n+    @Autowired\n+    private ToolGroupApiService toolGroupApiService;\n+\n+    @Autowired\n+    private ToolGroupManager mockToolGroupManager;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).create(toolGroup);\n+\n+        assertThat(toolGroupApiService.create(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = TOOL_GROUP_MANAGER)\n+    public void shouldCreateToolGroupForManagerWhenPermissionGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).create(toolGroup);\n+\n+        assertThat(toolGroupApiService.create(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyCreateToolGroupWithInvalidRole() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.create(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = TOOL_GROUP_MANAGER, username = SIMPLE_USER)\n+    public void shouldDenyCreateToolGroupWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.create(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).updateToolGroup(toolGroup);\n+\n+        assertThat(toolGroupApiService.update(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateToolGroupWhenPermissionIsGranted() {\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).updateToolGroup(toolGroup);\n+\n+        assertThat(toolGroupApiService.update(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldDenyUpdateWhenPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.update(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolGroupsByRegistryIdForAdmin() {\n+        final List<ToolGroup> toolGroups = mutableListOf(toolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryId(ID);\n+\n+        assertThat(toolGroupApiService.loadByRegistryId(ID)).isEqualTo(toolGroups);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolGroupsByRegistryIdWhenPermissionIsGranted() {\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        final List<ToolGroup> toolGroups = mutableListOf(toolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryId(ID);\n+\n+        final List<ToolGroup> returnedTollGroups = toolGroupApiService.loadByRegistryId(ID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f979c63c0e7cb36986ef900237c8acada5af979f"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA2MjM5NQ==", "bodyText": "and this line too", "url": "https://github.com/epam/cloud-pipeline/pull/1555#discussion_r534062395", "createdAt": "2020-12-02T10:34:21Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolGroupApiServiceTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.pipeline.ToolGroupWithIssues;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class ToolGroupApiServiceTest extends AbstractAclTest {\n+\n+    private static final String TOOL_GROUP_MANAGER = \"TOOL_GROUP_MANAGER\";\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Arrays.asList(tool, toolWithoutPermission);\n+    private final ToolGroupWithIssues toolGroupWithIssues = DockerCreatorUtils.getToolGroupWithIssues();\n+\n+    @Autowired\n+    private ToolGroupApiService toolGroupApiService;\n+\n+    @Autowired\n+    private ToolGroupManager mockToolGroupManager;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).create(toolGroup);\n+\n+        assertThat(toolGroupApiService.create(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = TOOL_GROUP_MANAGER)\n+    public void shouldCreateToolGroupForManagerWhenPermissionGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).create(toolGroup);\n+\n+        assertThat(toolGroupApiService.create(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyCreateToolGroupWithInvalidRole() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.create(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = TOOL_GROUP_MANAGER, username = SIMPLE_USER)\n+    public void shouldDenyCreateToolGroupWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.create(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).updateToolGroup(toolGroup);\n+\n+        assertThat(toolGroupApiService.update(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateToolGroupWhenPermissionIsGranted() {\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).updateToolGroup(toolGroup);\n+\n+        assertThat(toolGroupApiService.update(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldDenyUpdateWhenPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.update(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolGroupsByRegistryIdForAdmin() {\n+        final List<ToolGroup> toolGroups = mutableListOf(toolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryId(ID);\n+\n+        assertThat(toolGroupApiService.loadByRegistryId(ID)).isEqualTo(toolGroups);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolGroupsByRegistryIdWhenPermissionIsGranted() {\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        final List<ToolGroup> toolGroups = mutableListOf(toolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryId(ID);\n+\n+        final List<ToolGroup> returnedTollGroups = toolGroupApiService.loadByRegistryId(ID);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzNTk4NQ=="}, "originalCommit": {"oid": "f979c63c0e7cb36986ef900237c8acada5af979f"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjMzNTExOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolGroupApiServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjozODoxMFrOH8qujQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjozODoxMFrOH8qujQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3NjY1Mw==", "bodyText": "Could we add assertion for tool mask?", "url": "https://github.com/epam/cloud-pipeline/pull/1555#discussion_r533376653", "createdAt": "2020-12-01T12:38:10Z", "author": {"login": "ekazachkova"}, "path": "api/src/test/java/com/epam/pipeline/acl/docker/ToolGroupApiServiceTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.pipeline.ToolGroupWithIssues;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class ToolGroupApiServiceTest extends AbstractAclTest {\n+\n+    private static final String TOOL_GROUP_MANAGER = \"TOOL_GROUP_MANAGER\";\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Arrays.asList(tool, toolWithoutPermission);\n+    private final ToolGroupWithIssues toolGroupWithIssues = DockerCreatorUtils.getToolGroupWithIssues();\n+\n+    @Autowired\n+    private ToolGroupApiService toolGroupApiService;\n+\n+    @Autowired\n+    private ToolGroupManager mockToolGroupManager;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).create(toolGroup);\n+\n+        assertThat(toolGroupApiService.create(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = TOOL_GROUP_MANAGER)\n+    public void shouldCreateToolGroupForManagerWhenPermissionGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).create(toolGroup);\n+\n+        assertThat(toolGroupApiService.create(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyCreateToolGroupWithInvalidRole() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.create(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = TOOL_GROUP_MANAGER, username = SIMPLE_USER)\n+    public void shouldDenyCreateToolGroupWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.create(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).updateToolGroup(toolGroup);\n+\n+        assertThat(toolGroupApiService.update(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateToolGroupWhenPermissionIsGranted() {\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).updateToolGroup(toolGroup);\n+\n+        assertThat(toolGroupApiService.update(toolGroup)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldDenyUpdateWhenPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.update(toolGroup));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolGroupsByRegistryIdForAdmin() {\n+        final List<ToolGroup> toolGroups = mutableListOf(toolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryId(ID);\n+\n+        assertThat(toolGroupApiService.loadByRegistryId(ID)).isEqualTo(toolGroups);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolGroupsByRegistryIdWhenPermissionIsGranted() {\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        final List<ToolGroup> toolGroups = mutableListOf(toolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryId(ID);\n+\n+        final List<ToolGroup> returnedTollGroups = toolGroupApiService.loadByRegistryId(ID);\n+\n+        assertThat(returnedTollGroups).isEqualTo(toolGroups);\n+        assertThat(returnedTollGroups.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolsGroupsByRegistryIdWhichPermissionIsGranted() {\n+        final ToolGroup anotherToolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(anotherToolGroup);\n+        doReturn(mutableListOf(toolGroup, anotherToolGroup)).when(mockToolGroupManager).loadByRegistryId(ID);\n+\n+        assertThat(toolGroupApiService.loadByRegistryId(ID)).hasSize(1).contains(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadToolGroupsByRegistryIdWhichPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+\n+        assertThat(toolGroupApiService.loadByRegistryId(ID)).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolGroupsByRegistryNameOrIdForAdmin() {\n+        final List<ToolGroup> toolGroups = mutableListOf(toolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryNameOrId(TEST_STRING);\n+\n+        assertThat(toolGroupApiService.loadByRegistryNameOrId(TEST_STRING)).isEqualTo(toolGroups);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolGroupsByRegistryNameOrIdWhenPermissionIsGranted() {\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        final List<ToolGroup> toolGroups = mutableListOf(toolGroup);\n+        doReturn(toolGroups).when(mockToolGroupManager).loadByRegistryNameOrId(TEST_STRING);\n+\n+        final List<ToolGroup> returnedTollGroups = toolGroupApiService.loadByRegistryNameOrId(TEST_STRING);\n+\n+        assertThat(returnedTollGroups).isEqualTo(toolGroups);\n+        assertThat(returnedTollGroups.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolsGroupsByRegistryNameOrIdWhichPermissionIsGranted() {\n+        final ToolGroup anotherToolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(anotherToolGroup);\n+        doReturn(mutableListOf(toolGroup, anotherToolGroup))\n+                .when(mockToolGroupManager).loadByRegistryNameOrId(TEST_STRING);\n+\n+        assertThat(toolGroupApiService.loadByRegistryNameOrId(TEST_STRING)).hasSize(1).contains(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldDenyLoadToolGroupsByRegistryNameOrIdWhichPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+\n+        assertThat(toolGroupApiService.loadByRegistryNameOrId(TEST_STRING)).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).load(ID);\n+\n+        assertThat(toolGroupApiService.load(ID)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadToolGroup() {\n+        final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        initAclEntity(dockerRegistry);\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setParent(dockerRegistry);\n+        doReturn(toolGroup).when(mockToolGroupManager).load(ID);\n+\n+        assertThat(toolGroupApiService.load(ID)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolGroupHierarchy() {\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setParent(dockerRegistry);\n+        toolGroup.setTools(tools);\n+        initToolGroupAclTree();\n+        doReturn(toolGroup).when(mockToolGroupManager).load(ID);\n+\n+        final ToolGroup returnedToolGroup = toolGroupApiService.load(ID);\n+\n+        assertToolGroupAclTree(returnedToolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadToolsWithIssuesCount() {\n+        doReturn(toolGroupWithIssues).when(mockToolGroupManager).loadToolsWithIssuesCount(ID);\n+\n+        assertThat(toolGroupApiService.loadToolsWithIssuesCount(ID)).isEqualTo(toolGroupWithIssues);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolsWithIssuesCountHierarchy() {\n+        final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroupWithIssues toolGroupWithIssues =\n+                DockerCreatorUtils.getToolGroupWithIssues(ID_2, ANOTHER_SIMPLE_USER);\n+        toolGroupWithIssues.setParent(dockerRegistry);\n+        toolGroupWithIssues.setTools(tools);\n+        initToolGroupAclTree();\n+        doReturn(toolGroupWithIssues).when(mockToolGroupManager).loadToolsWithIssuesCount(ID);\n+\n+        final ToolGroupWithIssues returnedToolGroup = toolGroupApiService.loadToolsWithIssuesCount(ID);\n+\n+        assertToolGroupAclTree(returnedToolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadByNameOrId() {\n+        final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        initAclEntity(dockerRegistry);\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setParent(dockerRegistry);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        assertThat(toolGroupApiService.loadByNameOrId(TEST_STRING)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadToolGroupHierarchyByNameOrId() {\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setParent(dockerRegistry);\n+        toolGroup.setTools(tools);\n+        initToolGroupAclTree();\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+\n+        final ToolGroup returnedToolGroup = toolGroupApiService.loadByNameOrId(TEST_STRING);\n+\n+        assertToolGroupAclTree(returnedToolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadPrivate() {\n+        doReturn(toolGroup).when(mockToolGroupManager).loadPrivate(ID);\n+\n+        assertThat(toolGroupApiService.loadPrivate(ID)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreatePrivateForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).createPrivate(ID);\n+\n+        assertThat(toolGroupApiService.createPrivate(ID)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldCreatePrivateWhenPermissionIsGranted() {\n+        final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        dockerRegistry.setGroups(mutableListOf(toolGroup));\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).getDockerRegistryTree(ID);\n+        doReturn(toolGroup).when(mockToolGroupManager).createPrivate(ID);\n+\n+        assertThat(toolGroupApiService.createPrivate(ID)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreatePrivateWhenPermissionIsNotGranted() {\n+        final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        initAclEntity(toolGroup);\n+        dockerRegistry.setGroups(mutableListOf(toolGroup));\n+        initAclEntity(dockerRegistry);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).getDockerRegistryTree(ID);\n+        doReturn(toolGroup).when(mockToolGroupManager).createPrivate(ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.createPrivate(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, false);\n+\n+        assertThat(toolGroupApiService.delete(TEST_STRING)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = TOOL_GROUP_MANAGER, username = SIMPLE_USER)\n+    public void shouldDeleteToolGroupForManagerWhenPermissionIsGranted() {\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, false);\n+        mockSecurityContext();\n+\n+        assertThat(toolGroupApiService.delete(TEST_STRING)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteToolGroupWithInvalidRole() {\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, false);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.delete(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = TOOL_GROUP_MANAGER)\n+    public void shouldDenyDeleteToolGroupWhenPermissionIsNotGranted() {\n+        initAclEntity(toolGroup);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, false);\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.delete(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteForceToolGroupForAdmin() {\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, true);\n+\n+        assertThat(toolGroupApiService.deleteForce(TEST_STRING)).isEqualTo(toolGroup);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyDeleteForceToolGroupWithInvalidRole() {\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(mutableListOf(tool));\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        initAclEntity(tool, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.deleteForce(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = TOOL_GROUP_MANAGER, username = SIMPLE_USER)\n+    public void shouldDeleteForceToolGroupForManagerWhenChildPermissionIsGranted() {\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(mutableListOf(tool));\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        initAclEntity(tool, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, true);\n+        mockSecurityContext();\n+\n+        assertThat(toolGroupApiService.deleteForce(TEST_STRING)).isEqualTo(toolGroup);\n+    }\n+\n+\n+    @Test\n+    @WithMockUser(roles = TOOL_GROUP_MANAGER, username = SIMPLE_USER)\n+    public void shouldDenyDeleteForceToolGroupForManagerWhenChildPermissionIsNotGranted() {\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(mutableListOf(tool));\n+        initAclEntity(toolGroup, AclPermission.WRITE);\n+        initAclEntity(tool);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, true);\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.deleteForce(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = TOOL_GROUP_MANAGER)\n+    public void shouldDenyDeleteForceToolGroupForManagerWhenPermissionIsNotGranted() {\n+        final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(mutableListOf(tool));\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.WRITE);\n+        doReturn(toolGroup).when(mockToolGroupManager).loadByNameOrId(TEST_STRING);\n+        doReturn(toolGroup).when(mockToolGroupManager).delete(TEST_STRING, true);\n+        mockSecurityContext();\n+\n+        assertThrows(AccessDeniedException.class, () -> toolGroupApiService.deleteForce(TEST_STRING));\n+    }\n+\n+    private void initToolGroupAclTree() {\n+        initAclEntity(dockerRegistry);\n+        initAclEntity(tool, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+    }\n+\n+    private void assertToolGroupAclTree(final ToolGroup returnedToolGroup) {\n+        assertThat(returnedToolGroup.getParent()).isEqualTo(dockerRegistry);\n+        assertThat(returnedToolGroup.getLeaves()).hasSize(1);\n+        assertThat(returnedToolGroup.getLeaves().get(0)).isEqualTo(tool);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f979c63c0e7cb36986ef900237c8acada5af979f"}, "originalPosition": 441}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 323, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}