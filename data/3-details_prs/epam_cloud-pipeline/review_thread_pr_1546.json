{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2NTY1NzMx", "number": 1546, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzoyNTowOFrOE2oj7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOToyMDoxN1rOE3nxvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzIzMTE2OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/test/creator/tool/ToolCreatorUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzoyNTowOFrOHvhwGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzoyNTowOFrOHvhwGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5ODEwNQ==", "bodyText": "Let's add final here just in order to be consistent with all the new code.", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r519598105", "createdAt": "2020-11-09T07:25:08Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/test/creator/tool/ToolCreatorUtils.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.tool;\n+\n+import com.epam.pipeline.entity.pipeline.Tool;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+\n+public final class ToolCreatorUtils {\n+\n+    private ToolCreatorUtils() {\n+\n+    }\n+\n+    public static Tool getTool() {\n+        Tool tool = new Tool();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f3035559809c14069eb04f6f19c00838736a249"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzU5OTYxOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOToxMjowN1rOHvlJqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOToxMjowN1rOHvlJqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1MzgwMA==", "bodyText": "I suppose we can move such type reference to common constants utils class.", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r519653800", "createdAt": "2020-11-09T09:12:07Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.docker;\n+\n+import com.epam.pipeline.controller.Result;\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+\n+public final class DockerCreatorUtils {\n+\n+    public static final TypeReference<Result<DockerRegistry>> DOCKER_REGISTRY_INSTANCE_TYPE =\n+            new TypeReference<Result<DockerRegistry>>() {};\n+    public static final TypeReference<Result<DockerRegistryList>> DOCKER_REGISTRY_LIST_INSTANCE_TYPE =\n+            new TypeReference<Result<DockerRegistryList>>() {};\n+    public static final TypeReference<Result<Map<String, String>>> STRING_MAP_INSTANCE_TYPE =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f3035559809c14069eb04f6f19c00838736a249"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzY5NDg2OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOTozNToxM1rOHvmDHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOTozNToxM1rOHvmDHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2ODUwOA==", "bodyText": "The type could be extracted to the existing security creator utils class.", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r519668508", "createdAt": "2020-11-09T09:35:13Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.docker;\n+\n+import com.epam.pipeline.config.JsonMapper;\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryApiService;\n+import com.epam.pipeline.security.UserAccessService;\n+import com.epam.pipeline.security.UserContext;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import com.epam.pipeline.test.creator.tool.ToolCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.CERTIFICATE_NAME;\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.DOCKER_LOGIN_SCRIPT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.refEq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = DockerRegistryController.class)\n+public class DockerRegistryControllerTest extends AbstractControllerTest {\n+\n+    private static final String DOCKER_REGISTRY_URL = SERVLET_PATH + \"/dockerRegistry\";\n+    private static final String REGISTER_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/register\";\n+    private static final String UPDATE_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/update\";\n+    private static final String UPDATE_DOCKER_REGISTRY_CREDS_URL = DOCKER_REGISTRY_URL + \"/updateCredentials\";\n+    private static final String OAUTH_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/oauth\";\n+    private static final String LOAD_TREE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadTree\";\n+    private static final String LOAD_CERTS_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadCerts\";\n+    private static final String LOAD_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%s/load\";\n+    private static final String DELETE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/delete\";\n+    private static final String CERT_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/cert\";\n+    private static final String LOGIN_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/login\";\n+    private static final String NOTIFY_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/notify\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+\n+    private static final String CONTENT_DISPOSITION_HEADER = \"Content-Disposition\";\n+    private static final String FORCE = \"force\";\n+    private static final String TRUE_AS_STRING = String.valueOf(true);\n+    private static final String REGISTRY_PATH = \"Registry-Path\";\n+    private static final String SERVICE = \"service\";\n+    private static final String SCOPE = \"scope\";\n+    private final byte[] bytes = {1, 1, 1};\n+\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry();\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final JwtRawToken jwtRawToken = SecurityCreatorUtils.getJwtRawToken();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList();\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+\n+    @Autowired\n+    private DockerRegistryApiService mockDockerRegistryApiService;\n+\n+    @Autowired\n+    private UserAccessService mockAccessService;\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldCreateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(REGISTER_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailCreateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(REGISTER_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistry);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistryCredentials() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService)\n+                .updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistryCredentials() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldOauthEndpoint() throws Exception {\n+        final UserContext userContext = SecurityCreatorUtils.getUserContext();\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        final String testNameAndPass = TEST_STRING + \":\" + TEST_STRING;\n+        final String encodedNameAndPass = new String(Base64.getEncoder()\n+                .encode(testNameAndPass.getBytes(StandardCharsets.UTF_8)));\n+        doReturn(userContext).when(mockAccessService).getJwtUser(any(), any());\n+        doReturn(jwtRawToken).when(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        final MvcResult mvcResult = performRequest(get(OAUTH_DOCKER_REGISTRY_URL)\n+                .header(\"Authorization\", \"Basic\" + encodedNameAndPass).params(params));\n+\n+        verify(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+        final JwtRawToken actualResult = JsonMapper.parseData(mvcResult.getResponse().getContentAsString(),\n+                new TypeReference<JwtRawToken>() {});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f3035559809c14069eb04f6f19c00838736a249"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzcxMDMzOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOTozODo1MlrOHvmMfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOTozODo1MlrOHvmMfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY3MDkwOQ==", "bodyText": "It could be extracted even if there is only a single call now because it can be reused later.", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r519670909", "createdAt": "2020-11-09T09:38:52Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.docker;\n+\n+import com.epam.pipeline.config.JsonMapper;\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryApiService;\n+import com.epam.pipeline.security.UserAccessService;\n+import com.epam.pipeline.security.UserContext;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import com.epam.pipeline.test.creator.tool.ToolCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.CERTIFICATE_NAME;\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.DOCKER_LOGIN_SCRIPT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.refEq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = DockerRegistryController.class)\n+public class DockerRegistryControllerTest extends AbstractControllerTest {\n+\n+    private static final String DOCKER_REGISTRY_URL = SERVLET_PATH + \"/dockerRegistry\";\n+    private static final String REGISTER_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/register\";\n+    private static final String UPDATE_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/update\";\n+    private static final String UPDATE_DOCKER_REGISTRY_CREDS_URL = DOCKER_REGISTRY_URL + \"/updateCredentials\";\n+    private static final String OAUTH_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/oauth\";\n+    private static final String LOAD_TREE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadTree\";\n+    private static final String LOAD_CERTS_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadCerts\";\n+    private static final String LOAD_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%s/load\";\n+    private static final String DELETE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/delete\";\n+    private static final String CERT_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/cert\";\n+    private static final String LOGIN_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/login\";\n+    private static final String NOTIFY_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/notify\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+\n+    private static final String CONTENT_DISPOSITION_HEADER = \"Content-Disposition\";\n+    private static final String FORCE = \"force\";\n+    private static final String TRUE_AS_STRING = String.valueOf(true);\n+    private static final String REGISTRY_PATH = \"Registry-Path\";\n+    private static final String SERVICE = \"service\";\n+    private static final String SCOPE = \"scope\";\n+    private final byte[] bytes = {1, 1, 1};\n+\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry();\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final JwtRawToken jwtRawToken = SecurityCreatorUtils.getJwtRawToken();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList();\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+\n+    @Autowired\n+    private DockerRegistryApiService mockDockerRegistryApiService;\n+\n+    @Autowired\n+    private UserAccessService mockAccessService;\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldCreateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(REGISTER_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailCreateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(REGISTER_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistry);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistryCredentials() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService)\n+                .updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistryCredentials() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldOauthEndpoint() throws Exception {\n+        final UserContext userContext = SecurityCreatorUtils.getUserContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f3035559809c14069eb04f6f19c00838736a249"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzczMDM2OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOTo0Mzo1MlrOHvmYvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOTo0Mzo1MlrOHvmYvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY3NDA0NQ==", "bodyText": "Probably we can use more accurate test name such as shouldDownloadRegistryCertificate.", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r519674045", "createdAt": "2020-11-09T09:43:52Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.docker;\n+\n+import com.epam.pipeline.config.JsonMapper;\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryApiService;\n+import com.epam.pipeline.security.UserAccessService;\n+import com.epam.pipeline.security.UserContext;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import com.epam.pipeline.test.creator.tool.ToolCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.CERTIFICATE_NAME;\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.DOCKER_LOGIN_SCRIPT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.refEq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = DockerRegistryController.class)\n+public class DockerRegistryControllerTest extends AbstractControllerTest {\n+\n+    private static final String DOCKER_REGISTRY_URL = SERVLET_PATH + \"/dockerRegistry\";\n+    private static final String REGISTER_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/register\";\n+    private static final String UPDATE_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/update\";\n+    private static final String UPDATE_DOCKER_REGISTRY_CREDS_URL = DOCKER_REGISTRY_URL + \"/updateCredentials\";\n+    private static final String OAUTH_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/oauth\";\n+    private static final String LOAD_TREE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadTree\";\n+    private static final String LOAD_CERTS_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadCerts\";\n+    private static final String LOAD_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%s/load\";\n+    private static final String DELETE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/delete\";\n+    private static final String CERT_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/cert\";\n+    private static final String LOGIN_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/login\";\n+    private static final String NOTIFY_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/notify\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+\n+    private static final String CONTENT_DISPOSITION_HEADER = \"Content-Disposition\";\n+    private static final String FORCE = \"force\";\n+    private static final String TRUE_AS_STRING = String.valueOf(true);\n+    private static final String REGISTRY_PATH = \"Registry-Path\";\n+    private static final String SERVICE = \"service\";\n+    private static final String SCOPE = \"scope\";\n+    private final byte[] bytes = {1, 1, 1};\n+\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry();\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final JwtRawToken jwtRawToken = SecurityCreatorUtils.getJwtRawToken();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList();\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+\n+    @Autowired\n+    private DockerRegistryApiService mockDockerRegistryApiService;\n+\n+    @Autowired\n+    private UserAccessService mockAccessService;\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldCreateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(REGISTER_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailCreateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(REGISTER_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistry);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistryCredentials() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService)\n+                .updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistryCredentials() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldOauthEndpoint() throws Exception {\n+        final UserContext userContext = SecurityCreatorUtils.getUserContext();\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        final String testNameAndPass = TEST_STRING + \":\" + TEST_STRING;\n+        final String encodedNameAndPass = new String(Base64.getEncoder()\n+                .encode(testNameAndPass.getBytes(StandardCharsets.UTF_8)));\n+        doReturn(userContext).when(mockAccessService).getJwtUser(any(), any());\n+        doReturn(jwtRawToken).when(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        final MvcResult mvcResult = performRequest(get(OAUTH_DOCKER_REGISTRY_URL)\n+                .header(\"Authorization\", \"Basic\" + encodedNameAndPass).params(params));\n+\n+        verify(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+        final JwtRawToken actualResult = JsonMapper.parseData(mvcResult.getResponse().getContentAsString(),\n+                new TypeReference<JwtRawToken>() {});\n+        Assert.assertEquals(jwtRawToken, actualResult);\n+    }\n+\n+    @Test\n+    public void shouldFailOauthEndpoint() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        performUnauthorizedRequest(get(OAUTH_DOCKER_REGISTRY_URL).params(params));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistryContent() throws Exception {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryApiService).loadAllRegistriesContent();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_TREE_REGISTRY_URL));\n+\n+        verify(mockDockerRegistryApiService).loadAllRegistriesContent();\n+        assertResponse(mvcResult, dockerRegistryList, DockerCreatorUtils.DOCKER_REGISTRY_LIST_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllRegistryContent() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_TREE_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadRegistryCertificates() throws Exception {\n+        final Map<String, String> loadedCerts = Collections.singletonMap(TEST_STRING, TEST_STRING);\n+        doReturn(dockerRegistryList).when(mockDockerRegistryApiService).listDockerRegistriesWithCerts();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_CERTS_REGISTRY_URL));\n+\n+        verify(mockDockerRegistryApiService).listDockerRegistriesWithCerts();\n+        assertResponse(mvcResult, loadedCerts, DockerCreatorUtils.STRING_MAP_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadRegistryCertificates() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_CERTS_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() throws Exception {\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).load(ID);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(LOAD_REGISTRY_URL, ID)));\n+\n+        verify(mockDockerRegistryApiService).load(ID);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDeleteDockerRegistry() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(FORCE, TRUE_AS_STRING);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).delete(ID, true);\n+\n+        final MvcResult mvcResult = performRequest(delete(String.format(DELETE_REGISTRY_URL, ID)).params(params));\n+\n+        verify(mockDockerRegistryApiService).delete(ID, true);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailDeleteDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(delete(DELETE_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldNotifyRegistryEvents() throws Exception {\n+        final Tool tool = ToolCreatorUtils.getTool();\n+        final List<Tool> tools = Collections.singletonList(tool);\n+        final String content = getObjectMapper().writeValueAsString(eventEnvelope);\n+        doReturn(tools).when(mockDockerRegistryApiService)\n+                .notifyDockerRegistryEvents(eq(TEST_STRING), refEq(eventEnvelope));\n+\n+        final MvcResult mvcResult = performRequest(\n+                post(NOTIFY_REGISTRY_URL).header(REGISTRY_PATH, TEST_STRING).content(content));\n+\n+        verify(mockDockerRegistryApiService).notifyDockerRegistryEvents(eq(TEST_STRING), refEq(eventEnvelope));\n+        assertResponse(mvcResult, tools, DockerCreatorUtils.TOOL_LIST_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailNotifyRegistryEvents() throws Exception {\n+        performUnauthorizedRequest(get(NOTIFY_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDownloadPipelineFile() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f3035559809c14069eb04f6f19c00838736a249"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1Nzc0MDU5OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOTo0NjoxMVrOHvmetg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOTo0NjoxMVrOHvmetg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY3NTU3NA==", "bodyText": "Let's extract this downloading file parameters assertion to the abstract class. It definitely has a potential to be reused in other tests.", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r519675574", "createdAt": "2020-11-09T09:46:11Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.docker;\n+\n+import com.epam.pipeline.config.JsonMapper;\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryApiService;\n+import com.epam.pipeline.security.UserAccessService;\n+import com.epam.pipeline.security.UserContext;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import com.epam.pipeline.test.creator.tool.ToolCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.CERTIFICATE_NAME;\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.DOCKER_LOGIN_SCRIPT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.refEq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = DockerRegistryController.class)\n+public class DockerRegistryControllerTest extends AbstractControllerTest {\n+\n+    private static final String DOCKER_REGISTRY_URL = SERVLET_PATH + \"/dockerRegistry\";\n+    private static final String REGISTER_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/register\";\n+    private static final String UPDATE_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/update\";\n+    private static final String UPDATE_DOCKER_REGISTRY_CREDS_URL = DOCKER_REGISTRY_URL + \"/updateCredentials\";\n+    private static final String OAUTH_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/oauth\";\n+    private static final String LOAD_TREE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadTree\";\n+    private static final String LOAD_CERTS_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadCerts\";\n+    private static final String LOAD_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%s/load\";\n+    private static final String DELETE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/delete\";\n+    private static final String CERT_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/cert\";\n+    private static final String LOGIN_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/login\";\n+    private static final String NOTIFY_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/notify\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+\n+    private static final String CONTENT_DISPOSITION_HEADER = \"Content-Disposition\";\n+    private static final String FORCE = \"force\";\n+    private static final String TRUE_AS_STRING = String.valueOf(true);\n+    private static final String REGISTRY_PATH = \"Registry-Path\";\n+    private static final String SERVICE = \"service\";\n+    private static final String SCOPE = \"scope\";\n+    private final byte[] bytes = {1, 1, 1};\n+\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry();\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final JwtRawToken jwtRawToken = SecurityCreatorUtils.getJwtRawToken();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList();\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+\n+    @Autowired\n+    private DockerRegistryApiService mockDockerRegistryApiService;\n+\n+    @Autowired\n+    private UserAccessService mockAccessService;\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldCreateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(REGISTER_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailCreateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(REGISTER_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistry);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistryCredentials() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService)\n+                .updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistryCredentials() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldOauthEndpoint() throws Exception {\n+        final UserContext userContext = SecurityCreatorUtils.getUserContext();\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        final String testNameAndPass = TEST_STRING + \":\" + TEST_STRING;\n+        final String encodedNameAndPass = new String(Base64.getEncoder()\n+                .encode(testNameAndPass.getBytes(StandardCharsets.UTF_8)));\n+        doReturn(userContext).when(mockAccessService).getJwtUser(any(), any());\n+        doReturn(jwtRawToken).when(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        final MvcResult mvcResult = performRequest(get(OAUTH_DOCKER_REGISTRY_URL)\n+                .header(\"Authorization\", \"Basic\" + encodedNameAndPass).params(params));\n+\n+        verify(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+        final JwtRawToken actualResult = JsonMapper.parseData(mvcResult.getResponse().getContentAsString(),\n+                new TypeReference<JwtRawToken>() {});\n+        Assert.assertEquals(jwtRawToken, actualResult);\n+    }\n+\n+    @Test\n+    public void shouldFailOauthEndpoint() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        performUnauthorizedRequest(get(OAUTH_DOCKER_REGISTRY_URL).params(params));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistryContent() throws Exception {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryApiService).loadAllRegistriesContent();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_TREE_REGISTRY_URL));\n+\n+        verify(mockDockerRegistryApiService).loadAllRegistriesContent();\n+        assertResponse(mvcResult, dockerRegistryList, DockerCreatorUtils.DOCKER_REGISTRY_LIST_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllRegistryContent() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_TREE_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadRegistryCertificates() throws Exception {\n+        final Map<String, String> loadedCerts = Collections.singletonMap(TEST_STRING, TEST_STRING);\n+        doReturn(dockerRegistryList).when(mockDockerRegistryApiService).listDockerRegistriesWithCerts();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_CERTS_REGISTRY_URL));\n+\n+        verify(mockDockerRegistryApiService).listDockerRegistriesWithCerts();\n+        assertResponse(mvcResult, loadedCerts, DockerCreatorUtils.STRING_MAP_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadRegistryCertificates() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_CERTS_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() throws Exception {\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).load(ID);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(LOAD_REGISTRY_URL, ID)));\n+\n+        verify(mockDockerRegistryApiService).load(ID);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDeleteDockerRegistry() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(FORCE, TRUE_AS_STRING);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).delete(ID, true);\n+\n+        final MvcResult mvcResult = performRequest(delete(String.format(DELETE_REGISTRY_URL, ID)).params(params));\n+\n+        verify(mockDockerRegistryApiService).delete(ID, true);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailDeleteDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(delete(DELETE_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldNotifyRegistryEvents() throws Exception {\n+        final Tool tool = ToolCreatorUtils.getTool();\n+        final List<Tool> tools = Collections.singletonList(tool);\n+        final String content = getObjectMapper().writeValueAsString(eventEnvelope);\n+        doReturn(tools).when(mockDockerRegistryApiService)\n+                .notifyDockerRegistryEvents(eq(TEST_STRING), refEq(eventEnvelope));\n+\n+        final MvcResult mvcResult = performRequest(\n+                post(NOTIFY_REGISTRY_URL).header(REGISTRY_PATH, TEST_STRING).content(content));\n+\n+        verify(mockDockerRegistryApiService).notifyDockerRegistryEvents(eq(TEST_STRING), refEq(eventEnvelope));\n+        assertResponse(mvcResult, tools, DockerCreatorUtils.TOOL_LIST_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailNotifyRegistryEvents() throws Exception {\n+        performUnauthorizedRequest(get(NOTIFY_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDownloadPipelineFile() throws Exception {\n+        doReturn(bytes).when(mockDockerRegistryApiService).getCertificateContent(ID);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(CERT_REGISTRY_URL, ID)),\n+                OCTET_STREAM_CONTENT_TYPE);\n+\n+        verify(mockDockerRegistryApiService).getCertificateContent(ID);\n+        final byte[] actualByteArray = mvcResult.getResponse().getContentAsByteArray();\n+        final String contentDispositionHeader = mvcResult.getResponse().getHeader(CONTENT_DISPOSITION_HEADER);\n+        assertThat(actualByteArray).isEqualTo(bytes);\n+        assertThat(contentDispositionHeader).contains(CERTIFICATE_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f3035559809c14069eb04f6f19c00838736a249"}, "originalPosition": 284}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzU4ODQ2OnYy", "diffSide": "RIGHT", "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOToyMDoxN1rOHxE2eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOToyMDoxN1rOHxE2eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMTc1Mw==", "bodyText": "Let's now extract both assertions into a single one like the following.\nassertFileResponse(mvcResult, fileName, fileContent);\nAlso let's use the added method in shouldDownloadConfigScript test as well.", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r521221753", "createdAt": "2020-11-11T09:20:17Z", "author": {"login": "tcibinan"}, "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.docker;\n+\n+import com.epam.pipeline.config.JsonMapper;\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryApiService;\n+import com.epam.pipeline.security.UserAccessService;\n+import com.epam.pipeline.security.UserContext;\n+import com.epam.pipeline.test.creator.CommonCreatorConstants;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import com.epam.pipeline.test.creator.tool.ToolCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.DOCKER_LOGIN_SCRIPT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.refEq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = DockerRegistryController.class)\n+public class DockerRegistryControllerTest extends AbstractControllerTest {\n+\n+    private static final String DOCKER_REGISTRY_URL = SERVLET_PATH + \"/dockerRegistry\";\n+    private static final String REGISTER_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/register\";\n+    private static final String UPDATE_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/update\";\n+    private static final String UPDATE_DOCKER_REGISTRY_CREDS_URL = DOCKER_REGISTRY_URL + \"/updateCredentials\";\n+    private static final String OAUTH_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/oauth\";\n+    private static final String LOAD_TREE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadTree\";\n+    private static final String LOAD_CERTS_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadCerts\";\n+    private static final String LOAD_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%s/load\";\n+    private static final String DELETE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/delete\";\n+    private static final String CERT_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/cert\";\n+    private static final String LOGIN_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/login\";\n+    private static final String NOTIFY_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/notify\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+\n+    private static final String CONTENT_DISPOSITION_HEADER = \"Content-Disposition\";\n+    private static final String FORCE = \"force\";\n+    private static final String TRUE_AS_STRING = String.valueOf(true);\n+    private static final String REGISTRY_PATH = \"Registry-Path\";\n+    private static final String SERVICE = \"service\";\n+    private static final String SCOPE = \"scope\";\n+    private final byte[] bytes = {1, 1, 1};\n+\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry();\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final JwtRawToken jwtRawToken = SecurityCreatorUtils.getJwtRawToken();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList();\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final UserContext userContext = SecurityCreatorUtils.getUserContext();\n+\n+    @Autowired\n+    private DockerRegistryApiService mockDockerRegistryApiService;\n+\n+    @Autowired\n+    private UserAccessService mockAccessService;\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldCreateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(REGISTER_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailCreateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(REGISTER_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistry);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistryCredentials() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService)\n+                .updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistryCredentials() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldOauthEndpoint() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        final String testNameAndPass = TEST_STRING + \":\" + TEST_STRING;\n+        final String encodedNameAndPass = new String(Base64.getEncoder()\n+                .encode(testNameAndPass.getBytes(StandardCharsets.UTF_8)));\n+        doReturn(userContext).when(mockAccessService).getJwtUser(any(), any());\n+        doReturn(jwtRawToken).when(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        final MvcResult mvcResult = performRequest(get(OAUTH_DOCKER_REGISTRY_URL)\n+                .header(\"Authorization\", \"Basic\" + encodedNameAndPass).params(params));\n+\n+        verify(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+        final JwtRawToken actualResult = JsonMapper.parseData(mvcResult.getResponse().getContentAsString(),\n+                SecurityCreatorUtils.JWT_RAW_TOKEN_INSTANCE_TYPE);\n+        Assert.assertEquals(jwtRawToken, actualResult);\n+    }\n+\n+    @Test\n+    public void shouldFailOauthEndpoint() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        performUnauthorizedRequest(get(OAUTH_DOCKER_REGISTRY_URL).params(params));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistryContent() throws Exception {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryApiService).loadAllRegistriesContent();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_TREE_REGISTRY_URL));\n+\n+        verify(mockDockerRegistryApiService).loadAllRegistriesContent();\n+        assertResponse(mvcResult, dockerRegistryList, DockerCreatorUtils.DOCKER_REGISTRY_LIST_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllRegistryContent() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_TREE_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadRegistryCertificates() throws Exception {\n+        final Map<String, String> loadedCerts = Collections.singletonMap(TEST_STRING, TEST_STRING);\n+        doReturn(dockerRegistryList).when(mockDockerRegistryApiService).listDockerRegistriesWithCerts();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_CERTS_REGISTRY_URL));\n+\n+        verify(mockDockerRegistryApiService).listDockerRegistriesWithCerts();\n+        assertResponse(mvcResult, loadedCerts, CommonCreatorConstants.STRING_MAP_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadRegistryCertificates() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_CERTS_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() throws Exception {\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).load(ID);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(LOAD_REGISTRY_URL, ID)));\n+\n+        verify(mockDockerRegistryApiService).load(ID);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDeleteDockerRegistry() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(FORCE, TRUE_AS_STRING);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).delete(ID, true);\n+\n+        final MvcResult mvcResult = performRequest(delete(String.format(DELETE_REGISTRY_URL, ID)).params(params));\n+\n+        verify(mockDockerRegistryApiService).delete(ID, true);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailDeleteDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(delete(DELETE_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldNotifyRegistryEvents() throws Exception {\n+        final Tool tool = ToolCreatorUtils.getTool();\n+        final List<Tool> tools = Collections.singletonList(tool);\n+        final String content = getObjectMapper().writeValueAsString(eventEnvelope);\n+        doReturn(tools).when(mockDockerRegistryApiService)\n+                .notifyDockerRegistryEvents(eq(TEST_STRING), refEq(eventEnvelope));\n+\n+        final MvcResult mvcResult = performRequest(\n+                post(NOTIFY_REGISTRY_URL).header(REGISTRY_PATH, TEST_STRING).content(content));\n+\n+        verify(mockDockerRegistryApiService).notifyDockerRegistryEvents(eq(TEST_STRING), refEq(eventEnvelope));\n+        assertResponse(mvcResult, tools, ToolCreatorUtils.TOOL_LIST_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailNotifyRegistryEvents() throws Exception {\n+        performUnauthorizedRequest(get(NOTIFY_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDownloadRegistryCertificate() throws Exception {\n+        doReturn(bytes).when(mockDockerRegistryApiService).getCertificateContent(ID);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(CERT_REGISTRY_URL, ID)),\n+                OCTET_STREAM_CONTENT_TYPE);\n+\n+        verify(mockDockerRegistryApiService).getCertificateContent(ID);\n+        final byte[] actualByteArray = mvcResult.getResponse().getContentAsByteArray();\n+        assertThat(actualByteArray).isEqualTo(bytes);\n+        assertResponseHeader(mvcResult, CONTENT_DISPOSITION_HEADER, CERTIFICATE_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bddab1c9c769bde63cf36fca027ab8fbfeb12ec1"}, "originalPosition": 282}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 312, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}