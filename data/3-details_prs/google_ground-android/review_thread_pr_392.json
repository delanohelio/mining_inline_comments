{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3NDQ5Njcz", "number": 392, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo1MTo0NVrODnn4wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozMDo1NlrODpMB9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODc0NTYwOnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/RoomLocalDataStore.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo1MTo0NVrOF1u5aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNTowMDo1MVrOF4JEaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4NzIwOQ==", "bodyText": "Rather than using findAll and filtering, can we define a method on the DAO that only returns tiles with state == PENDING?", "url": "https://github.com/google/ground-android/pull/392#discussion_r391887209", "createdAt": "2020-03-12T20:51:45Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/RoomLocalDataStore.java", "diffHunk": "@@ -436,4 +438,19 @@ public Completable insertOrUpdateTile(Tile tile) {\n   public Maybe<Tile> getTile(String tileId) {\n     return tileDao.findById(tileId).map(TileEntity::toTile).subscribeOn(schedulers.io());\n   }\n+\n+  @Override\n+  public Single<ImmutableList<Tile>> getPendingTiles() {\n+    // TODO: Only retrieve tiles for a given area.\n+    // This currently retrieves all pending tiles in the DB.\n+    return tileDao\n+        .findAll()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM5NjEwOA==", "bodyText": "The DAO Query strings have to be constant, which unfortunately means we can't exactly add a Pending tiles method to the DAO directly without using an int literal, which is too brittle for my taste.\nHowever, I have switched to using a findByState method instead, which is simpler!", "url": "https://github.com/google/ground-android/pull/392#discussion_r394396108", "createdAt": "2020-03-18T14:38:52Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/RoomLocalDataStore.java", "diffHunk": "@@ -436,4 +438,19 @@ public Completable insertOrUpdateTile(Tile tile) {\n   public Maybe<Tile> getTile(String tileId) {\n     return tileDao.findById(tileId).map(TileEntity::toTile).subscribeOn(schedulers.io());\n   }\n+\n+  @Override\n+  public Single<ImmutableList<Tile>> getPendingTiles() {\n+    // TODO: Only retrieve tiles for a given area.\n+    // This currently retrieves all pending tiles in the DB.\n+    return tileDao\n+        .findAll()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4NzIwOQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQxMzE2MQ==", "bodyText": "see commit 2b867a8", "url": "https://github.com/google/ground-android/pull/392#discussion_r394413161", "createdAt": "2020-03-18T15:00:51Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/RoomLocalDataStore.java", "diffHunk": "@@ -436,4 +438,19 @@ public Completable insertOrUpdateTile(Tile tile) {\n   public Maybe<Tile> getTile(String tileId) {\n     return tileDao.findById(tileId).map(TileEntity::toTile).subscribeOn(schedulers.io());\n   }\n+\n+  @Override\n+  public Single<ImmutableList<Tile>> getPendingTiles() {\n+    // TODO: Only retrieve tiles for a given area.\n+    // This currently retrieves all pending tiles in the DB.\n+    return tileDao\n+        .findAll()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4NzIwOQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODc0OTc1OnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo1MzoxOFrOF1u8Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNToyMzoxNFrOF4KIQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4Nzg5MA==", "bodyText": "Does this need to be in a finally block?", "url": "https://github.com/google/ground-android/pull/392#discussion_r391887890", "createdAt": "2020-03-12T20:53:18Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQyNDM1MA==", "bodyText": "Used a try-with-resources block instead (since android studio suggested it).", "url": "https://github.com/google/ground-android/pull/392#discussion_r394424350", "createdAt": "2020-03-18T15:15:24Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4Nzg5MA=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDUzMA==", "bodyText": "Done see 2b81c0b", "url": "https://github.com/google/ground-android/pull/392#discussion_r394430530", "createdAt": "2020-03-18T15:23:14Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4Nzg5MA=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODc1NjkxOnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo1NTo1NFrOF1vAmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNTo0NDowOFrOF4LGiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4OTA1MQ==", "bodyText": "Do I understand correct that \"Tile\" actually refers to an entire pyramid of tiles, and not a single tile? If so, at some point we may want to rename it something more appropriate to avoid confusing others (and ourselves).", "url": "https://github.com/google/ground-android/pull/392#discussion_r391889051", "createdAt": "2020-03-12T20:55:54Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDgwNg==", "bodyText": "Have any ideas on what we should call it?", "url": "https://github.com/google/ground-android/pull/392#discussion_r394430806", "createdAt": "2020-03-18T15:23:34Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4OTA1MQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDk4OQ==", "bodyText": "Will probably hold off on this for a later PR", "url": "https://github.com/google/ground-android/pull/392#discussion_r394430989", "createdAt": "2020-03-18T15:23:47Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4OTA1MQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0NjQ3Mw==", "bodyText": "SGTM. Filed #400 to track!", "url": "https://github.com/google/ground-android/pull/392#discussion_r394446473", "createdAt": "2020-03-18T15:44:08Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4OTA1MQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODc2ODAwOnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo1OTo1N1rOF1vHtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNToyMjo1OVrOF4KHgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MDg3MQ==", "bodyText": "If you use Completable.fromRunnable instead you don't need to return anything and can use an inline lambda instead of a block.", "url": "https://github.com/google/ground-android/pull/392#discussion_r391890871", "createdAt": "2020-03-12T20:59:57Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();\n \n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    if (tile.getState() == State.IN_PROGRESS) {\n+      File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+      requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    }\n \n-    return downloadTileFile(tile, Optional.of(requestProperties));\n+    return localDataStore\n+        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n+        .andThen(\n+            Completable.fromCallable(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk0OTI3Mg==", "bodyText": "I wanted to do this, but since the IO exception here is a checked exception, we'd have to explicitly handle the error in the runnable itself, losing the elegance of its automatic propagation upstream (though I suppose NBD since we're already losing elegance with this approach). see here for more info: https://stackoverflow.com/questions/44179444/how-to-create-observable-out-of-runnable\nOur options are what we currently have here, or:\nCompletable.fromRunnable(() -> {try {downloadTile(tile)} catch (IOException e) { Log.d(TAG, \"Failed to download tile: \" + tile, e);}})\nI opted for the Callable variant since it's shorter. Though I think it may be more confusing to someone unfamiliar with the checked exception restriction....but then again so would handling the exception in the runnable itself.\nI'm good with using whichever style you prefer.", "url": "https://github.com/google/ground-android/pull/392#discussion_r391949272", "createdAt": "2020-03-12T23:00:08Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();\n \n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    if (tile.getState() == State.IN_PROGRESS) {\n+      File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+      requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    }\n \n-    return downloadTileFile(tile, Optional.of(requestProperties));\n+    return localDataStore\n+        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n+        .andThen(\n+            Completable.fromCallable(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MDg3MQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0MDQ0Mg==", "bodyText": "Perhaps downloadTileFile() should catch the error and rethrow an unchecked exception?\nWe need to try {} finally {} in downloadTileFile() to close the connection, so adding catch() should be easy. Wdyt?", "url": "https://github.com/google/ground-android/pull/392#discussion_r392340442", "createdAt": "2020-03-13T16:35:40Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();\n \n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    if (tile.getState() == State.IN_PROGRESS) {\n+      File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+      requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    }\n \n-    return downloadTileFile(tile, Optional.of(requestProperties));\n+    return localDataStore\n+        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n+        .andThen(\n+            Completable.fromCallable(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MDg3MQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MjkxMA==", "bodyText": "Perhaps downloadTileFile() should catch the error and rethrow an unchecked exception?\nWe need to try {} finally {} in downloadTileFile() to close the connection, so adding catch() should be easy. Wdyt?\n\nThat's a great idea! Let's do that.", "url": "https://github.com/google/ground-android/pull/392#discussion_r392382910", "createdAt": "2020-03-13T17:52:07Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();\n \n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    if (tile.getState() == State.IN_PROGRESS) {\n+      File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+      requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    }\n \n-    return downloadTileFile(tile, Optional.of(requestProperties));\n+    return localDataStore\n+        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n+        .andThen(\n+            Completable.fromCallable(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MDg3MQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDMzNw==", "bodyText": "Done see 2b81c0b", "url": "https://github.com/google/ground-android/pull/392#discussion_r394430337", "createdAt": "2020-03-18T15:22:59Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();\n \n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    if (tile.getState() == State.IN_PROGRESS) {\n+      File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+      requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    }\n \n-    return downloadTileFile(tile, Optional.of(requestProperties));\n+    return localDataStore\n+        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n+        .andThen(\n+            Completable.fromCallable(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MDg3MQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODc2OTQ3OnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTowMDozMFrOF1vIkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjowOToxOFrOF4MT3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTA4OQ==", "bodyText": "Please add a comment explaining why we do this (to resume downloads)? Btw, have you seen this work in practice?", "url": "https://github.com/google/ground-android/pull/392#discussion_r391891089", "createdAt": "2020-03-12T21:00:30Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();\n \n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    if (tile.getState() == State.IN_PROGRESS) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1MDA3OQ==", "bodyText": "The range request is supposed to let us resume the file download from where it stopped, but tbh I haven't confirmed it works in practice, and I don't really know much about HTTP range requests at all.\nIt might be safer to just start the entire file download again when we resume something in progress and overwrite anything that was already on disk. Even though we're technically doing extra work in that case.", "url": "https://github.com/google/ground-android/pull/392#discussion_r391950079", "createdAt": "2020-03-12T23:02:43Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();\n \n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    if (tile.getState() == State.IN_PROGRESS) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTA4OQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzODg1Mw==", "bodyText": "Hmm.. perhaps.. we can leave it for now provided we test it out.", "url": "https://github.com/google/ground-android/pull/392#discussion_r392338853", "createdAt": "2020-03-13T16:33:09Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();\n \n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    if (tile.getState() == State.IN_PROGRESS) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTA4OQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQyNDYwOQ==", "bodyText": "sg!", "url": "https://github.com/google/ground-android/pull/392#discussion_r394424609", "createdAt": "2020-03-18T15:15:42Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();\n \n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    if (tile.getState() == State.IN_PROGRESS) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTA4OQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ2NjI2OQ==", "bodyText": "Fixed some problems w/ this and added explanatory comments in 7582c4f", "url": "https://github.com/google/ground-android/pull/392#discussion_r394466269", "createdAt": "2020-03-18T16:09:18Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();\n \n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    if (tile.getState() == State.IN_PROGRESS) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTA4OQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODc3MzU0OnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTowMTo1N1rOF1vLGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNToyNzozOVrOF4KVNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTczOQ==", "bodyText": "Please define variable as Map instead.", "url": "https://github.com/google/ground-android/pull/392#discussion_r391891739", "createdAt": "2020-03-12T21:01:57Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMzg0NA==", "bodyText": "c68a03b", "url": "https://github.com/google/ground-android/pull/392#discussion_r394433844", "createdAt": "2020-03-18T15:27:39Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTczOQ=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODc3ODUzOnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTowMzo0NVrOF1vOTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNTozNTowNFrOF4KrQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MjU1OA==", "bodyText": "We shouldn't care if there are no pending tiles; if so another instance of the worker may have completed the job for us, and we should just exit since everything is in the proper state.", "url": "https://github.com/google/ground-android/pull/392#discussion_r391892558", "createdAt": "2020-03-12T21:03:45Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -150,27 +153,23 @@ private Result checkDownload(Tile tile) {\n   @NonNull\n   @Override\n   public Result doWork() {\n-    Tile tile = localDataStore.getTile(tileId).blockingGet();\n+    ImmutableList<Tile> pendingTiles = localDataStore.getPendingTiles().blockingGet();\n \n-    // When there is no tile in the db, the Maybe completes and returns null.\n+    // When there are no tiles in the db, the blockingGet returns null.\n     // We expect tiles to be added to the DB prior to downloading.\n     // If that isn't the case, we fail.\n-    if (tile == null) {\n+    if (pendingTiles == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzOTQ5MQ==", "bodyText": "Gotcha, we'll just treat it as a success then eec1754", "url": "https://github.com/google/ground-android/pull/392#discussion_r394439491", "createdAt": "2020-03-18T15:35:04Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -150,27 +153,23 @@ private Result checkDownload(Tile tile) {\n   @NonNull\n   @Override\n   public Result doWork() {\n-    Tile tile = localDataStore.getTile(tileId).blockingGet();\n+    ImmutableList<Tile> pendingTiles = localDataStore.getPendingTiles().blockingGet();\n \n-    // When there is no tile in the db, the Maybe completes and returns null.\n+    // When there are no tiles in the db, the blockingGet returns null.\n     // We expect tiles to be added to the DB prior to downloading.\n     // If that isn't the case, we fail.\n-    if (tile == null) {\n+    if (pendingTiles == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MjU1OA=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODc3OTgzOnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTowNDoxNVrOF1vPIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNToyNzozMFrOF4KUyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5Mjc2OA==", "bodyText": "Fyi: After Shobhit's recent PR, you can now just Timber.d(\"Downloading tiles %s\", pendingTiles).", "url": "https://github.com/google/ground-android/pull/392#discussion_r391892768", "createdAt": "2020-03-12T21:04:15Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -150,27 +153,23 @@ private Result checkDownload(Tile tile) {\n   @NonNull\n   @Override\n   public Result doWork() {\n-    Tile tile = localDataStore.getTile(tileId).blockingGet();\n+    ImmutableList<Tile> pendingTiles = localDataStore.getPendingTiles().blockingGet();\n \n-    // When there is no tile in the db, the Maybe completes and returns null.\n+    // When there are no tiles in the db, the blockingGet returns null.\n     // We expect tiles to be added to the DB prior to downloading.\n     // If that isn't the case, we fail.\n-    if (tile == null) {\n+    if (pendingTiles == null) {\n       return Result.failure();\n     }\n \n-    Log.d(TAG, \"Downloading tile: \" + tile.getPath());\n-\n-    switch (tile.getState()) {\n-      case DOWNLOADED:\n-        return checkDownload(tile);\n-      case PENDING:\n-      case FAILED:\n-        return downloadTile(tile);\n-      case IN_PROGRESS:\n-        return resumeTileDownload(tile);\n-      default:\n-        return Result.failure();\n+    Log.d(TAG, \"Downloading tiles: \" + pendingTiles);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQyOTY3Nw==", "bodyText": "Whoops not actually done, will be shortly", "url": "https://github.com/google/ground-android/pull/392#discussion_r394429677", "createdAt": "2020-03-18T15:22:11Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -150,27 +153,23 @@ private Result checkDownload(Tile tile) {\n   @NonNull\n   @Override\n   public Result doWork() {\n-    Tile tile = localDataStore.getTile(tileId).blockingGet();\n+    ImmutableList<Tile> pendingTiles = localDataStore.getPendingTiles().blockingGet();\n \n-    // When there is no tile in the db, the Maybe completes and returns null.\n+    // When there are no tiles in the db, the blockingGet returns null.\n     // We expect tiles to be added to the DB prior to downloading.\n     // If that isn't the case, we fail.\n-    if (tile == null) {\n+    if (pendingTiles == null) {\n       return Result.failure();\n     }\n \n-    Log.d(TAG, \"Downloading tile: \" + tile.getPath());\n-\n-    switch (tile.getState()) {\n-      case DOWNLOADED:\n-        return checkDownload(tile);\n-      case PENDING:\n-      case FAILED:\n-        return downloadTile(tile);\n-      case IN_PROGRESS:\n-        return resumeTileDownload(tile);\n-      default:\n-        return Result.failure();\n+    Log.d(TAG, \"Downloading tiles: \" + pendingTiles);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5Mjc2OA=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMzczNw==", "bodyText": "Now it's done :) c68a03b", "url": "https://github.com/google/ground-android/pull/392#discussion_r394433737", "createdAt": "2020-03-18T15:27:30Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -150,27 +153,23 @@ private Result checkDownload(Tile tile) {\n   @NonNull\n   @Override\n   public Result doWork() {\n-    Tile tile = localDataStore.getTile(tileId).blockingGet();\n+    ImmutableList<Tile> pendingTiles = localDataStore.getPendingTiles().blockingGet();\n \n-    // When there is no tile in the db, the Maybe completes and returns null.\n+    // When there are no tiles in the db, the blockingGet returns null.\n     // We expect tiles to be added to the DB prior to downloading.\n     // If that isn't the case, we fail.\n-    if (tile == null) {\n+    if (pendingTiles == null) {\n       return Result.failure();\n     }\n \n-    Log.d(TAG, \"Downloading tile: \" + tile.getPath());\n-\n-    switch (tile.getState()) {\n-      case DOWNLOADED:\n-        return checkDownload(tile);\n-      case PENDING:\n-      case FAILED:\n-        return downloadTile(tile);\n-      case IN_PROGRESS:\n-        return resumeTileDownload(tile);\n-      default:\n-        return Result.failure();\n+    Log.d(TAG, \"Downloading tiles: \" + pendingTiles);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5Mjc2OA=="}, "originalCommit": {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTE1MzE4OnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozMDo1NlrOF4NPcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo1NzoyM1rOF4OV8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MTUyMQ==", "bodyText": "Naming nit: Since this both checking and downloads, maybe downloadIfNotFound? This can be done in a follow up though.", "url": "https://github.com/google/ground-android/pull/392#discussion_r394481521", "createdAt": "2020-03-18T16:30:56Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -32,116 +35,140 @@\n import java.net.URL;\n import java.util.HashMap;\n import java.util.Map;\n-import java8.util.Optional;\n+import timber.log.Timber;\n \n /**\n  * A worker that downloads files to the device in the background. The target URL and file name are\n  * provided in a {@link Data} object. This worker should only run when the device has a network\n  * connection.\n  */\n public class TileDownloadWorker extends Worker {\n-  private static final String TAG = TileDownloadWorker.class.getSimpleName();\n-\n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n+\n+  class TileDownloadException extends RuntimeException {\n+\n+    TileDownloadException(String msg, Throwable e) {\n+      super(msg, e);\n+    }\n+  }\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws TileDownloadException {\n+\n+    int mode = Context.MODE_PRIVATE;\n+\n     try {\n       URL url = new URL(tile.getUrl());\n       HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n \n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n+      if (!requestProperties.isEmpty()) {\n+        for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n           connection.setRequestProperty(property.getKey(), property.getValue());\n         }\n+        mode = Context.MODE_APPEND;\n       }\n \n       connection.connect();\n \n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n+      try (InputStream is = connection.getInputStream();\n+          FileOutputStream fos = context.openFileOutput(tile.getPath(), mode)) {\n \n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n-      }\n-\n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n+        byte[] byteChunk = new byte[BUFFER_SIZE];\n+        int n;\n \n+        while ((n = is.read(byteChunk)) > 0) {\n+          fos.write(byteChunk, 0, n);\n+        }\n+      }\n     } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n-\n-      return Result.failure();\n+      throw new TileDownloadException(\"Failed to download tile\", e);\n     }\n   }\n \n   /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n-\n-    return downloadTileFile(tile, Optional.empty());\n-  }\n-\n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n-    HashMap<String, String> requestProperties = new HashMap<>();\n-\n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+  private Completable downloadTile(Tile tile) {\n+    Map<String, String> requestProperties = new HashMap<>();\n+\n+    // To resume a download for an in progress tile, we use the HTTP Range request property.\n+    // The range property takes a range of bytes, the server returns the content of the resource\n+    // that corresponds to the given byte range.\n+    //\n+    // To resume a download, we get the current length, in bytes, of the file on disk.\n+    // appending '-' to the byte value tells the server to return the range of bytes from the given\n+    // byte value to the end of the file, e.g. '500-' returns contents starting at byte 500 to EOF.\n+    //\n+    // Note that length returns 0 when the file does not exist, so this correctly handles an edge\n+    // case whereby the local DB has a tile state of IN_PROGRESS but none of the file has been\n+    // downloaded yet (since then we'll fetch the range '0-', the entire file).\n+    //\n+    // For more info see: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range\n+    if (tile.getState() == State.IN_PROGRESS) {\n+      File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+      requestProperties.put(\"Range\", \"bytes=\" + existingTileFile.length() + \"-\");\n+    }\n \n-    return downloadTileFile(tile, Optional.of(requestProperties));\n+    return localDataStore\n+        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n+        .andThen(\n+            Completable.fromRunnable(\n+                () -> {\n+                  downloadTileFile(tile, requestProperties);\n+                }))\n+        .onErrorResumeNext(\n+            e -> {\n+              Timber.d(e, \"Failed to download tile: %s\", tile);\n+              return localDataStore.insertOrUpdateTile(\n+                  tile.toBuilder().setState(State.FAILED).build());\n+            })\n+        .andThen(\n+            localDataStore.insertOrUpdateTile(tile.toBuilder().setState(State.DOWNLOADED).build()));\n   }\n \n   /**\n    * Verifies that {@param tile} marked as {@code Tile.State.DOWNLOADED} in the local database still\n    * exists in the app's storage. If the tile's source file isn't present, initiates a download of\n    * source file.\n    */\n-  private Result checkDownload(Tile tile) {\n+  private Completable checkDownload(Tile tile) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de5953f827699ffb70383cb6557d9a04904851cf"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5OTU3MA==", "bodyText": "Done! 6373a71", "url": "https://github.com/google/ground-android/pull/392#discussion_r394499570", "createdAt": "2020-03-18T16:57:23Z", "author": {"login": "scolsen"}, "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -32,116 +35,140 @@\n import java.net.URL;\n import java.util.HashMap;\n import java.util.Map;\n-import java8.util.Optional;\n+import timber.log.Timber;\n \n /**\n  * A worker that downloads files to the device in the background. The target URL and file name are\n  * provided in a {@link Data} object. This worker should only run when the device has a network\n  * connection.\n  */\n public class TileDownloadWorker extends Worker {\n-  private static final String TAG = TileDownloadWorker.class.getSimpleName();\n-\n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n+\n+  class TileDownloadException extends RuntimeException {\n+\n+    TileDownloadException(String msg, Throwable e) {\n+      super(msg, e);\n+    }\n+  }\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws TileDownloadException {\n+\n+    int mode = Context.MODE_PRIVATE;\n+\n     try {\n       URL url = new URL(tile.getUrl());\n       HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n \n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n+      if (!requestProperties.isEmpty()) {\n+        for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n           connection.setRequestProperty(property.getKey(), property.getValue());\n         }\n+        mode = Context.MODE_APPEND;\n       }\n \n       connection.connect();\n \n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n+      try (InputStream is = connection.getInputStream();\n+          FileOutputStream fos = context.openFileOutput(tile.getPath(), mode)) {\n \n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n-      }\n-\n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n+        byte[] byteChunk = new byte[BUFFER_SIZE];\n+        int n;\n \n+        while ((n = is.read(byteChunk)) > 0) {\n+          fos.write(byteChunk, 0, n);\n+        }\n+      }\n     } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n-\n-      return Result.failure();\n+      throw new TileDownloadException(\"Failed to download tile\", e);\n     }\n   }\n \n   /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n-\n-    return downloadTileFile(tile, Optional.empty());\n-  }\n-\n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n-    HashMap<String, String> requestProperties = new HashMap<>();\n-\n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+  private Completable downloadTile(Tile tile) {\n+    Map<String, String> requestProperties = new HashMap<>();\n+\n+    // To resume a download for an in progress tile, we use the HTTP Range request property.\n+    // The range property takes a range of bytes, the server returns the content of the resource\n+    // that corresponds to the given byte range.\n+    //\n+    // To resume a download, we get the current length, in bytes, of the file on disk.\n+    // appending '-' to the byte value tells the server to return the range of bytes from the given\n+    // byte value to the end of the file, e.g. '500-' returns contents starting at byte 500 to EOF.\n+    //\n+    // Note that length returns 0 when the file does not exist, so this correctly handles an edge\n+    // case whereby the local DB has a tile state of IN_PROGRESS but none of the file has been\n+    // downloaded yet (since then we'll fetch the range '0-', the entire file).\n+    //\n+    // For more info see: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range\n+    if (tile.getState() == State.IN_PROGRESS) {\n+      File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+      requestProperties.put(\"Range\", \"bytes=\" + existingTileFile.length() + \"-\");\n+    }\n \n-    return downloadTileFile(tile, Optional.of(requestProperties));\n+    return localDataStore\n+        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n+        .andThen(\n+            Completable.fromRunnable(\n+                () -> {\n+                  downloadTileFile(tile, requestProperties);\n+                }))\n+        .onErrorResumeNext(\n+            e -> {\n+              Timber.d(e, \"Failed to download tile: %s\", tile);\n+              return localDataStore.insertOrUpdateTile(\n+                  tile.toBuilder().setState(State.FAILED).build());\n+            })\n+        .andThen(\n+            localDataStore.insertOrUpdateTile(tile.toBuilder().setState(State.DOWNLOADED).build()));\n   }\n \n   /**\n    * Verifies that {@param tile} marked as {@code Tile.State.DOWNLOADED} in the local database still\n    * exists in the app's storage. If the tile's source file isn't present, initiates a download of\n    * source file.\n    */\n-  private Result checkDownload(Tile tile) {\n+  private Completable checkDownload(Tile tile) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MTUyMQ=="}, "originalCommit": {"oid": "de5953f827699ffb70383cb6557d9a04904851cf"}, "originalPosition": 183}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2635, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}