{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5MTMxODUy", "number": 425, "reviewThreads": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMjoyODowNFrODu7JLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzozNDozM1rODzfPpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNTMwMDkzOnYy", "diffSide": "RIGHT", "path": "gnd/src/androidTest/java/com/google/android/gnd/persistence/local/room/dao/UserDaoTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMjoyODowNFrOGBD5qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNjozODo1NVrOGBJmSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc2NTY3NA==", "bodyText": "Should we include the name of the entry point in this method as well for consistency? Perhaps we can create a convention like testEntryPoint_condition_result, e.g. testInsertUser_alreadyPresent_raisesError?  If condition and result are missing it can be assumed we're testing the default code path?", "url": "https://github.com/google/ground-android/pull/425#discussion_r403765674", "createdAt": "2020-04-05T22:28:04Z", "author": {"login": "gino-m"}, "path": "gnd/src/androidTest/java/com/google/android/gnd/persistence/local/room/dao/UserDaoTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local.room.dao;\n+\n+import androidx.test.runner.AndroidJUnit4;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.persistence.local.room.entity.UserEntity;\n+import javax.inject.Inject;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class UserDaoTest {\n+\n+  @Inject UserDao userDao;\n+\n+  private User testUser =\n+      User.builder().setId(\"foo id\").setDisplayName(\"foo name\").setEmail(\"foo@gmail.com\").build();\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testEmptyDb() {\n+    userDao.findById(testUser.getId()).test().assertNoValues();\n+  }\n+\n+  @Test\n+  public void testInsertUser() {\n+    userDao.insert(UserEntity.fromUser(testUser)).test().assertNoErrors();\n+    userDao\n+        .findById(testUser.getId())\n+        .test()\n+        .assertNoErrors()\n+        .assertValue(UserEntity.fromUser(testUser));\n+  }\n+\n+  @Test\n+  public void insertingAlreadyPresentUser_shouldRaiseError() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f283375e986b3ad84695c0c06761347e3656be26"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg1OTAxOQ==", "bodyText": "Done. PTAL", "url": "https://github.com/google/ground-android/pull/425#discussion_r403859019", "createdAt": "2020-04-06T06:38:55Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/androidTest/java/com/google/android/gnd/persistence/local/room/dao/UserDaoTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local.room.dao;\n+\n+import androidx.test.runner.AndroidJUnit4;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.persistence.local.room.entity.UserEntity;\n+import javax.inject.Inject;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class UserDaoTest {\n+\n+  @Inject UserDao userDao;\n+\n+  private User testUser =\n+      User.builder().setId(\"foo id\").setDisplayName(\"foo name\").setEmail(\"foo@gmail.com\").build();\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testEmptyDb() {\n+    userDao.findById(testUser.getId()).test().assertNoValues();\n+  }\n+\n+  @Test\n+  public void testInsertUser() {\n+    userDao.insert(UserEntity.fromUser(testUser)).test().assertNoErrors();\n+    userDao\n+        .findById(testUser.getId())\n+        .test()\n+        .assertNoErrors()\n+        .assertValue(UserEntity.fromUser(testUser));\n+  }\n+\n+  @Test\n+  public void insertingAlreadyPresentUser_shouldRaiseError() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc2NTY3NA=="}, "originalCommit": {"oid": "f283375e986b3ad84695c0c06761347e3656be26"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDMwMjk5OnYy", "diffSide": "RIGHT", "path": "config/spotbugs/spotbugs-filter.xml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjo1NzoyM1rOGEtIGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoxOTozNVrOGH-UvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4Njg0MA==", "bodyText": "Can we use @VisibileForTesting annotation instead of disabling this check altogether?", "url": "https://github.com/google/ground-android/pull/425#discussion_r407586840", "createdAt": "2020-04-13T16:57:23Z", "author": {"login": "gino-m"}, "path": "config/spotbugs/spotbugs-filter.xml", "diffHunk": "@@ -80,4 +81,7 @@\n   <Match>\n     <Bug pattern=\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\" />\n   </Match>\n+  <Match>\n+    <Bug pattern=\"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14749960635afa4a4e6dd97065a3999ef2f1dd9c"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NDc4Ng==", "bodyText": "That didn't work. I also tried SuppressFBWarnings but even that isn't working.", "url": "https://github.com/google/ground-android/pull/425#discussion_r407644786", "createdAt": "2020-04-13T18:42:25Z", "author": {"login": "shobhitagarwal1612"}, "path": "config/spotbugs/spotbugs-filter.xml", "diffHunk": "@@ -80,4 +81,7 @@\n   <Match>\n     <Bug pattern=\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\" />\n   </Match>\n+  <Match>\n+    <Bug pattern=\"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4Njg0MA=="}, "originalCommit": {"oid": "14749960635afa4a4e6dd97065a3999ef2f1dd9c"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNDMzMg==", "bodyText": "Did you try setting value = \"UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD\" in the annotation?", "url": "https://github.com/google/ground-android/pull/425#discussion_r411014332", "createdAt": "2020-04-19T23:19:35Z", "author": {"login": "gino-m"}, "path": "config/spotbugs/spotbugs-filter.xml", "diffHunk": "@@ -80,4 +81,7 @@\n   <Match>\n     <Bug pattern=\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\" />\n   </Match>\n+  <Match>\n+    <Bug pattern=\"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4Njg0MA=="}, "originalCommit": {"oid": "14749960635afa4a4e6dd97065a3999ef2f1dd9c"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDMyOTg2OnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/LocalDataStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzowNTozN1rOGEtZYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxODo0NTo1NlrOGEwySA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5MTI2NQ==", "bodyText": "\ud83d\udc4f \ud83d\udc4f\nThanks also for the name fixes, the DAO injection, and all the rest!", "url": "https://github.com/google/ground-android/pull/425#discussion_r407591265", "createdAt": "2020-04-13T17:05:37Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/LocalDataStore.java", "diffHunk": "@@ -49,13 +48,13 @@\n public interface LocalDataStore {\n \n   /** Load projects stored in local database. */\n-  Single<List<Project>> getProjects();\n+  Single<ImmutableList<Project>> getProjects();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14749960635afa4a4e6dd97065a3999ef2f1dd9c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0Njc5Mg==", "bodyText": "I even found a bug while testing.", "url": "https://github.com/google/ground-android/pull/425#discussion_r407646792", "createdAt": "2020-04-13T18:45:56Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/LocalDataStore.java", "diffHunk": "@@ -49,13 +48,13 @@\n public interface LocalDataStore {\n \n   /** Load projects stored in local database. */\n-  Single<List<Project>> getProjects();\n+  Single<ImmutableList<Project>> getProjects();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5MTI2NQ=="}, "originalCommit": {"oid": "14749960635afa4a4e6dd97065a3999ef2f1dd9c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDM2MDg3OnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/LocalDataStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzoxNDo0OFrOGEts1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzoxNDo0OFrOGEts1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5NjI0NA==", "bodyText": "\"all saved\" -> \"all queued, failed, and completed\"", "url": "https://github.com/google/ground-android/pull/425#discussion_r407596244", "createdAt": "2020-04-13T17:14:48Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/LocalDataStore.java", "diffHunk": "@@ -145,4 +144,7 @@\n    * the area into the local data store.\n    */\n   Completable insertOrUpdateOfflineArea(OfflineArea area);\n+\n+  /** Returns all saved offline areas from the local data store. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14749960635afa4a4e6dd97065a3999ef2f1dd9c"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDM3NDMzOnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/dao/OfflineAreaDao.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzoxODo1MlrOGEt1Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzoxODo1MlrOGEt1Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5ODQxNA==", "bodyText": "Good catch.", "url": "https://github.com/google/ground-android/pull/425#discussion_r407598414", "createdAt": "2020-04-13T17:18:52Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/dao/OfflineAreaDao.java", "diffHunk": "@@ -19,15 +19,15 @@\n import androidx.room.Dao;\n import androidx.room.Query;\n import com.google.android.gnd.persistence.local.room.entity.OfflineAreaEntity;\n-import io.reactivex.Flowable;\n import io.reactivex.Maybe;\n+import io.reactivex.Single;\n import java.util.List;\n \n /** Provides read/write operations for writing {@link OfflineAreaEntity} to the local db. */\n @Dao\n public interface OfflineAreaDao extends BaseDao<OfflineAreaEntity> {\n   @Query(\"SELECT * FROM offline_area\")\n-  Flowable<List<OfflineAreaEntity>> findAll();\n+  Single<List<OfflineAreaEntity>> findAll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14749960635afa4a4e6dd97065a3999ef2f1dd9c"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDM3NjU3OnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/dao/TileDao.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzoxOToyOVrOGEt2tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDowMzo1OVrOGF7TLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5ODc3Mg==", "bodyText": "Why return a Flowable here? Do we want to subscribe to future tile changes?", "url": "https://github.com/google/ground-android/pull/425#discussion_r407598772", "createdAt": "2020-04-13T17:19:29Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/dao/TileDao.java", "diffHunk": "@@ -27,7 +28,7 @@\n public interface TileDao extends BaseDao<TileEntity> {\n \n   @Query(\"SELECT * FROM tile\")\n-  Single<List<TileEntity>> findAll();\n+  Flowable<List<TileEntity>> findAll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14749960635afa4a4e6dd97065a3999ef2f1dd9c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzMDYzNQ==", "bodyText": "The code in LocalDataStore was converting the single to flowable. So why not do it directly?\nThe corresponding method in LocalDataStore was unused. But I think @scolsen would be needing that later since he added them. I've added tests for the same to verify that it indeed works as it says.", "url": "https://github.com/google/ground-android/pull/425#discussion_r407630635", "createdAt": "2020-04-13T18:16:25Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/dao/TileDao.java", "diffHunk": "@@ -27,7 +28,7 @@\n public interface TileDao extends BaseDao<TileEntity> {\n \n   @Query(\"SELECT * FROM tile\")\n-  Single<List<TileEntity>> findAll();\n+  Flowable<List<TileEntity>> findAll();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5ODc3Mg=="}, "originalCommit": {"oid": "14749960635afa4a4e6dd97065a3999ef2f1dd9c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0OTQ2Mw==", "bodyText": "The semantics of Single and Flowable are different in Room generated classes; Single returns a result and completes, whereas Flowable continues emitting values on each change. We convert to Flowable in upstream code because we're merging with a hot observable that doesn't complete as soon as a value is emitted. Here we expect the stream to terminate after the first item is emitted, so Single is appropriate here.", "url": "https://github.com/google/ground-android/pull/425#discussion_r408249463", "createdAt": "2020-04-14T15:56:23Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/dao/TileDao.java", "diffHunk": "@@ -27,7 +28,7 @@\n public interface TileDao extends BaseDao<TileEntity> {\n \n   @Query(\"SELECT * FROM tile\")\n-  Single<List<TileEntity>> findAll();\n+  Flowable<List<TileEntity>> findAll();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5ODc3Mg=="}, "originalCommit": {"oid": "14749960635afa4a4e6dd97065a3999ef2f1dd9c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2NzYzMQ==", "bodyText": "The semantics of Single and Flowable are different in Room generated classes; Single returns a result and completes, whereas Flowable continues emitting values on each change. We convert to Flowable in upstream code because we're merging with a hot observable that doesn't complete as soon as a value is emitted. Here we expect the stream to terminate after the first item is emitted, so Single is appropriate here.\n\n@gino-m Reverting back Flowable to Single fails the test testGetTilesOnceAndStream. Can you or @scolsen please take a look at the test to verify that I am testing the correct behavior or not?", "url": "https://github.com/google/ground-android/pull/425#discussion_r408867631", "createdAt": "2020-04-15T14:03:59Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/dao/TileDao.java", "diffHunk": "@@ -27,7 +28,7 @@\n public interface TileDao extends BaseDao<TileEntity> {\n \n   @Query(\"SELECT * FROM tile\")\n-  Single<List<TileEntity>> findAll();\n+  Flowable<List<TileEntity>> findAll();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5ODc3Mg=="}, "originalCommit": {"oid": "14749960635afa4a4e6dd97065a3999ef2f1dd9c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDM4NjcxOnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/TestScheduler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzoyMjoxOFrOGEt8_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxODoxNzoxMFrOGEv0mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYwMDM4Mg==", "bodyText": "Neat.. could you please add a class description that explains what this does in practice?", "url": "https://github.com/google/ground-android/pull/425#discussion_r407600382", "createdAt": "2020-04-13T17:22:18Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/TestScheduler.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd;\n+\n+import com.google.android.gnd.rx.Schedulers;\n+import io.reactivex.Scheduler;\n+import javax.inject.Inject;\n+\n+public class TestScheduler implements Schedulers {\n+\n+  @Inject\n+  TestScheduler() {}\n+\n+  @Override\n+  public Scheduler io() {\n+    return io.reactivex.schedulers.Schedulers.trampoline();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14749960635afa4a4e6dd97065a3999ef2f1dd9c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzMTAwMQ==", "bodyText": "Sure", "url": "https://github.com/google/ground-android/pull/425#discussion_r407631001", "createdAt": "2020-04-13T18:17:10Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/test/java/com/google/android/gnd/TestScheduler.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd;\n+\n+import com.google.android.gnd.rx.Schedulers;\n+import io.reactivex.Scheduler;\n+import javax.inject.Inject;\n+\n+public class TestScheduler implements Schedulers {\n+\n+  @Inject\n+  TestScheduler() {}\n+\n+  @Override\n+  public Scheduler io() {\n+    return io.reactivex.schedulers.Schedulers.trampoline();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYwMDM4Mg=="}, "originalCommit": {"oid": "14749960635afa4a4e6dd97065a3999ef2f1dd9c"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDM5NzMxOnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzoyNToxOFrOGEuDgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzoyNToxOFrOGEuDgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYwMjA1MA==", "bodyText": "Please make helpers static, include word \"Test\" so it's clear these don't just create a new empty instance (e.g. createTestUser()).", "url": "https://github.com/google/ground-android/pull/425#discussion_r407602050", "createdAt": "2020-04-13T17:25:18Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,565 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Builder;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  private User createUser() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e552b174758c6a83d48d1f5f87fcb7f6e326750b"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDYxNjk5OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjoxNDowNlrOGFWWRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMzo1MToyN1rOGF6tTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2MjIxMg==", "bodyText": "In the InMemoryCacheTest we kept constant fake objects as static members, FAKE_... Should we do the same here for clarity and consistency?", "url": "https://github.com/google/ground-android/pull/425#discussion_r408262212", "createdAt": "2020-04-14T16:14:06Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,611 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Builder;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static User createTestUser() {\n+    return User.builder()\n+        .setId(\"test_user_id\")\n+        .setEmail(\"test@gmail.com\")\n+        .setDisplayName(\"test user\")\n+        .build();\n+  }\n+\n+  private static Project createTestProject() {\n+    Builder multipleChoiceBuilder =\n+        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n+    multipleChoiceBuilder\n+        .optionsBuilder()\n+        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n+        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n+\n+    Field field =\n+        Field.newBuilder()\n+            .setId(\"field id\")\n+            .setLabel(\"field label\")\n+            .setRequired(false)\n+            .setType(Type.MULTIPLE_CHOICE)\n+            .setMultipleChoice(multipleChoiceBuilder.build())\n+            .build();\n+\n+    Element element = Element.ofField(field);\n+\n+    Form form =\n+        Form.newBuilder()\n+            .setId(\"form id\")\n+            .setElements(ImmutableList.<Element>builder().add(element).build())\n+            .build();\n+\n+    Layer layer =\n+        Layer.newBuilder()\n+            .setId(\"layer id\")\n+            .setItemLabel(\"item label\")\n+            .setListHeading(\"heading title\")\n+            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+            .setForm(form)\n+            .build();\n+\n+    Project.Builder builder =\n+        Project.newBuilder()\n+            .setId(\"project id\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f19366bc11942167e22c82666e751169de42eb8"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg1NzkzNA==", "bodyText": "Thanks. Done", "url": "https://github.com/google/ground-android/pull/425#discussion_r408857934", "createdAt": "2020-04-15T13:51:27Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,611 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Builder;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static User createTestUser() {\n+    return User.builder()\n+        .setId(\"test_user_id\")\n+        .setEmail(\"test@gmail.com\")\n+        .setDisplayName(\"test user\")\n+        .build();\n+  }\n+\n+  private static Project createTestProject() {\n+    Builder multipleChoiceBuilder =\n+        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n+    multipleChoiceBuilder\n+        .optionsBuilder()\n+        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n+        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n+\n+    Field field =\n+        Field.newBuilder()\n+            .setId(\"field id\")\n+            .setLabel(\"field label\")\n+            .setRequired(false)\n+            .setType(Type.MULTIPLE_CHOICE)\n+            .setMultipleChoice(multipleChoiceBuilder.build())\n+            .build();\n+\n+    Element element = Element.ofField(field);\n+\n+    Form form =\n+        Form.newBuilder()\n+            .setId(\"form id\")\n+            .setElements(ImmutableList.<Element>builder().add(element).build())\n+            .build();\n+\n+    Layer layer =\n+        Layer.newBuilder()\n+            .setId(\"layer id\")\n+            .setItemLabel(\"item label\")\n+            .setListHeading(\"heading title\")\n+            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+            .setForm(form)\n+            .build();\n+\n+    Project.Builder builder =\n+        Project.newBuilder()\n+            .setId(\"project id\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2MjIxMg=="}, "originalCommit": {"oid": "7f19366bc11942167e22c82666e751169de42eb8"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDYzMzM4OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjoxNzo1MVrOGFWgeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMzoxNToxNFrOGF5GiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NDgyNg==", "bodyText": "Can we use ImmutableList.of() here instead?\nI didn't realize RxJava had test helpers and assertions built in.", "url": "https://github.com/google/ground-android/pull/425#discussion_r408264826", "createdAt": "2020-04-14T16:17:51Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,611 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Builder;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static User createTestUser() {\n+    return User.builder()\n+        .setId(\"test_user_id\")\n+        .setEmail(\"test@gmail.com\")\n+        .setDisplayName(\"test user\")\n+        .build();\n+  }\n+\n+  private static Project createTestProject() {\n+    Builder multipleChoiceBuilder =\n+        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n+    multipleChoiceBuilder\n+        .optionsBuilder()\n+        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n+        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n+\n+    Field field =\n+        Field.newBuilder()\n+            .setId(\"field id\")\n+            .setLabel(\"field label\")\n+            .setRequired(false)\n+            .setType(Type.MULTIPLE_CHOICE)\n+            .setMultipleChoice(multipleChoiceBuilder.build())\n+            .build();\n+\n+    Element element = Element.ofField(field);\n+\n+    Form form =\n+        Form.newBuilder()\n+            .setId(\"form id\")\n+            .setElements(ImmutableList.<Element>builder().add(element).build())\n+            .build();\n+\n+    Layer layer =\n+        Layer.newBuilder()\n+            .setId(\"layer id\")\n+            .setItemLabel(\"item label\")\n+            .setListHeading(\"heading title\")\n+            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+            .setForm(form)\n+            .build();\n+\n+    Project.Builder builder =\n+        Project.newBuilder()\n+            .setId(\"project id\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\");\n+    builder.putLayer(layer.getId(), layer);\n+    return builder.build();\n+  }\n+\n+  private static FeatureMutation createTestFeatureMutation(\n+      String userId, String projectId, String layerId) {\n+    return FeatureMutation.builder()\n+        .setId(1L)\n+        .setType(Mutation.Type.CREATE)\n+        .setUserId(userId)\n+        .setProjectId(projectId)\n+        .setFeatureId(\"feature id\")\n+        .setLayerId(layerId)\n+        .setNewLocation(\n+            Optional.ofNullable(Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build()))\n+        .setClientTimestamp(new Date())\n+        .build();\n+  }\n+\n+  private static ObservationMutation createTestObservationMutation(\n+      String projectId, String featureId, String layerId, String formId, String userId) {\n+    return ObservationMutation.builder()\n+        .setType(Mutation.Type.CREATE)\n+        .setProjectId(projectId)\n+        .setFeatureId(featureId)\n+        .setLayerId(layerId)\n+        .setObservationId(\"observation id\")\n+        .setFormId(formId)\n+        .setResponseDeltas(\n+            ImmutableList.<ResponseDelta>builder()\n+                .add(\n+                    ResponseDelta.builder()\n+                        .setFieldId(\"field id\")\n+                        .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                        .build())\n+                .build())\n+        .setClientTimestamp(new Date())\n+        .setUserId(userId)\n+        .build();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    Project project1 =\n+        Project.newBuilder()\n+            .setId(\"id 1\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\")\n+            .build();\n+    Project project2 =\n+        Project.newBuilder()\n+            .setId(\"id 2\")\n+            .setTitle(\"project 2\")\n+            .setDescription(\"foo description 2\")\n+            .build();\n+    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n+    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n+    localDataStore\n+        .getProjects()\n+        .test()\n+        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f19366bc11942167e22c82666e751169de42eb8"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgzMTYyNA==", "bodyText": "Thanks. I didn't realize that this is also available. Done", "url": "https://github.com/google/ground-android/pull/425#discussion_r408831624", "createdAt": "2020-04-15T13:15:14Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,611 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Builder;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static User createTestUser() {\n+    return User.builder()\n+        .setId(\"test_user_id\")\n+        .setEmail(\"test@gmail.com\")\n+        .setDisplayName(\"test user\")\n+        .build();\n+  }\n+\n+  private static Project createTestProject() {\n+    Builder multipleChoiceBuilder =\n+        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n+    multipleChoiceBuilder\n+        .optionsBuilder()\n+        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n+        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n+\n+    Field field =\n+        Field.newBuilder()\n+            .setId(\"field id\")\n+            .setLabel(\"field label\")\n+            .setRequired(false)\n+            .setType(Type.MULTIPLE_CHOICE)\n+            .setMultipleChoice(multipleChoiceBuilder.build())\n+            .build();\n+\n+    Element element = Element.ofField(field);\n+\n+    Form form =\n+        Form.newBuilder()\n+            .setId(\"form id\")\n+            .setElements(ImmutableList.<Element>builder().add(element).build())\n+            .build();\n+\n+    Layer layer =\n+        Layer.newBuilder()\n+            .setId(\"layer id\")\n+            .setItemLabel(\"item label\")\n+            .setListHeading(\"heading title\")\n+            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+            .setForm(form)\n+            .build();\n+\n+    Project.Builder builder =\n+        Project.newBuilder()\n+            .setId(\"project id\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\");\n+    builder.putLayer(layer.getId(), layer);\n+    return builder.build();\n+  }\n+\n+  private static FeatureMutation createTestFeatureMutation(\n+      String userId, String projectId, String layerId) {\n+    return FeatureMutation.builder()\n+        .setId(1L)\n+        .setType(Mutation.Type.CREATE)\n+        .setUserId(userId)\n+        .setProjectId(projectId)\n+        .setFeatureId(\"feature id\")\n+        .setLayerId(layerId)\n+        .setNewLocation(\n+            Optional.ofNullable(Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build()))\n+        .setClientTimestamp(new Date())\n+        .build();\n+  }\n+\n+  private static ObservationMutation createTestObservationMutation(\n+      String projectId, String featureId, String layerId, String formId, String userId) {\n+    return ObservationMutation.builder()\n+        .setType(Mutation.Type.CREATE)\n+        .setProjectId(projectId)\n+        .setFeatureId(featureId)\n+        .setLayerId(layerId)\n+        .setObservationId(\"observation id\")\n+        .setFormId(formId)\n+        .setResponseDeltas(\n+            ImmutableList.<ResponseDelta>builder()\n+                .add(\n+                    ResponseDelta.builder()\n+                        .setFieldId(\"field id\")\n+                        .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                        .build())\n+                .build())\n+        .setClientTimestamp(new Date())\n+        .setUserId(userId)\n+        .build();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    Project project1 =\n+        Project.newBuilder()\n+            .setId(\"id 1\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\")\n+            .build();\n+    Project project2 =\n+        Project.newBuilder()\n+            .setId(\"id 2\")\n+            .setTitle(\"project 2\")\n+            .setDescription(\"foo description 2\")\n+            .build();\n+    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n+    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n+    localDataStore\n+        .getProjects()\n+        .test()\n+        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NDgyNg=="}, "originalCommit": {"oid": "7f19366bc11942167e22c82666e751169de42eb8"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDY1OTA4OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjoyMzo1NlrOGFWwyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMzoxMDoyNlrOGF46Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2OTAwMQ==", "bodyText": "Can we use Google Truth and compare the entire object here and throughout?\nassertThat(savedMutations).containsExactly(expectedValue)\nAlso, consider creating expected mutation as a constant to simplify these tests.\nRx assertValue is still fine for simple cases, or we can always use Truth, no opinion there.", "url": "https://github.com/google/ground-android/pull/425#discussion_r408269001", "createdAt": "2020-04-14T16:23:56Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,611 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Builder;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static User createTestUser() {\n+    return User.builder()\n+        .setId(\"test_user_id\")\n+        .setEmail(\"test@gmail.com\")\n+        .setDisplayName(\"test user\")\n+        .build();\n+  }\n+\n+  private static Project createTestProject() {\n+    Builder multipleChoiceBuilder =\n+        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n+    multipleChoiceBuilder\n+        .optionsBuilder()\n+        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n+        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n+\n+    Field field =\n+        Field.newBuilder()\n+            .setId(\"field id\")\n+            .setLabel(\"field label\")\n+            .setRequired(false)\n+            .setType(Type.MULTIPLE_CHOICE)\n+            .setMultipleChoice(multipleChoiceBuilder.build())\n+            .build();\n+\n+    Element element = Element.ofField(field);\n+\n+    Form form =\n+        Form.newBuilder()\n+            .setId(\"form id\")\n+            .setElements(ImmutableList.<Element>builder().add(element).build())\n+            .build();\n+\n+    Layer layer =\n+        Layer.newBuilder()\n+            .setId(\"layer id\")\n+            .setItemLabel(\"item label\")\n+            .setListHeading(\"heading title\")\n+            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+            .setForm(form)\n+            .build();\n+\n+    Project.Builder builder =\n+        Project.newBuilder()\n+            .setId(\"project id\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\");\n+    builder.putLayer(layer.getId(), layer);\n+    return builder.build();\n+  }\n+\n+  private static FeatureMutation createTestFeatureMutation(\n+      String userId, String projectId, String layerId) {\n+    return FeatureMutation.builder()\n+        .setId(1L)\n+        .setType(Mutation.Type.CREATE)\n+        .setUserId(userId)\n+        .setProjectId(projectId)\n+        .setFeatureId(\"feature id\")\n+        .setLayerId(layerId)\n+        .setNewLocation(\n+            Optional.ofNullable(Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build()))\n+        .setClientTimestamp(new Date())\n+        .build();\n+  }\n+\n+  private static ObservationMutation createTestObservationMutation(\n+      String projectId, String featureId, String layerId, String formId, String userId) {\n+    return ObservationMutation.builder()\n+        .setType(Mutation.Type.CREATE)\n+        .setProjectId(projectId)\n+        .setFeatureId(featureId)\n+        .setLayerId(layerId)\n+        .setObservationId(\"observation id\")\n+        .setFormId(formId)\n+        .setResponseDeltas(\n+            ImmutableList.<ResponseDelta>builder()\n+                .add(\n+                    ResponseDelta.builder()\n+                        .setFieldId(\"field id\")\n+                        .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                        .build())\n+                .build())\n+        .setClientTimestamp(new Date())\n+        .setUserId(userId)\n+        .build();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    Project project1 =\n+        Project.newBuilder()\n+            .setId(\"id 1\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\")\n+            .build();\n+    Project project2 =\n+        Project.newBuilder()\n+            .setId(\"id 2\")\n+            .setTitle(\"project 2\")\n+            .setDescription(\"foo description 2\")\n+            .build();\n+    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n+    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n+    localDataStore\n+        .getProjects()\n+        .test()\n+        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.getProjectById(project.getId()).test().assertValue(project);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.deleteProject(project).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+    localDataStore.getUser(user.getId()).test().assertValue(user);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    ImmutableList<Mutation> savedMutations =\n+        localDataStore.getPendingMutations(mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(1, savedMutations.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f19366bc11942167e22c82666e751169de42eb8"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgyODUxMA==", "bodyText": "Thanks. Truth assertions are also very easy to read.", "url": "https://github.com/google/ground-android/pull/425#discussion_r408828510", "createdAt": "2020-04-15T13:10:26Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,611 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Builder;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static User createTestUser() {\n+    return User.builder()\n+        .setId(\"test_user_id\")\n+        .setEmail(\"test@gmail.com\")\n+        .setDisplayName(\"test user\")\n+        .build();\n+  }\n+\n+  private static Project createTestProject() {\n+    Builder multipleChoiceBuilder =\n+        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n+    multipleChoiceBuilder\n+        .optionsBuilder()\n+        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n+        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n+\n+    Field field =\n+        Field.newBuilder()\n+            .setId(\"field id\")\n+            .setLabel(\"field label\")\n+            .setRequired(false)\n+            .setType(Type.MULTIPLE_CHOICE)\n+            .setMultipleChoice(multipleChoiceBuilder.build())\n+            .build();\n+\n+    Element element = Element.ofField(field);\n+\n+    Form form =\n+        Form.newBuilder()\n+            .setId(\"form id\")\n+            .setElements(ImmutableList.<Element>builder().add(element).build())\n+            .build();\n+\n+    Layer layer =\n+        Layer.newBuilder()\n+            .setId(\"layer id\")\n+            .setItemLabel(\"item label\")\n+            .setListHeading(\"heading title\")\n+            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+            .setForm(form)\n+            .build();\n+\n+    Project.Builder builder =\n+        Project.newBuilder()\n+            .setId(\"project id\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\");\n+    builder.putLayer(layer.getId(), layer);\n+    return builder.build();\n+  }\n+\n+  private static FeatureMutation createTestFeatureMutation(\n+      String userId, String projectId, String layerId) {\n+    return FeatureMutation.builder()\n+        .setId(1L)\n+        .setType(Mutation.Type.CREATE)\n+        .setUserId(userId)\n+        .setProjectId(projectId)\n+        .setFeatureId(\"feature id\")\n+        .setLayerId(layerId)\n+        .setNewLocation(\n+            Optional.ofNullable(Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build()))\n+        .setClientTimestamp(new Date())\n+        .build();\n+  }\n+\n+  private static ObservationMutation createTestObservationMutation(\n+      String projectId, String featureId, String layerId, String formId, String userId) {\n+    return ObservationMutation.builder()\n+        .setType(Mutation.Type.CREATE)\n+        .setProjectId(projectId)\n+        .setFeatureId(featureId)\n+        .setLayerId(layerId)\n+        .setObservationId(\"observation id\")\n+        .setFormId(formId)\n+        .setResponseDeltas(\n+            ImmutableList.<ResponseDelta>builder()\n+                .add(\n+                    ResponseDelta.builder()\n+                        .setFieldId(\"field id\")\n+                        .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                        .build())\n+                .build())\n+        .setClientTimestamp(new Date())\n+        .setUserId(userId)\n+        .build();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    Project project1 =\n+        Project.newBuilder()\n+            .setId(\"id 1\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\")\n+            .build();\n+    Project project2 =\n+        Project.newBuilder()\n+            .setId(\"id 2\")\n+            .setTitle(\"project 2\")\n+            .setDescription(\"foo description 2\")\n+            .build();\n+    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n+    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n+    localDataStore\n+        .getProjects()\n+        .test()\n+        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.getProjectById(project.getId()).test().assertValue(project);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.deleteProject(project).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+    localDataStore.getUser(user.getId()).test().assertValue(user);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    ImmutableList<Mutation> savedMutations =\n+        localDataStore.getPendingMutations(mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(1, savedMutations.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2OTAwMQ=="}, "originalCommit": {"oid": "7f19366bc11942167e22c82666e751169de42eb8"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDY3MDM1OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjoyNjo0MVrOGFW4IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDowMjoxMFrOGF7NuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MDg4MA==", "bodyText": "I'm not sure we want to assert our precondition setup - don't we already have coverage for these code paths in other tests?", "url": "https://github.com/google/ground-android/pull/425#discussion_r408270880", "createdAt": "2020-04-14T16:26:41Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,611 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Builder;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static User createTestUser() {\n+    return User.builder()\n+        .setId(\"test_user_id\")\n+        .setEmail(\"test@gmail.com\")\n+        .setDisplayName(\"test user\")\n+        .build();\n+  }\n+\n+  private static Project createTestProject() {\n+    Builder multipleChoiceBuilder =\n+        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n+    multipleChoiceBuilder\n+        .optionsBuilder()\n+        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n+        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n+\n+    Field field =\n+        Field.newBuilder()\n+            .setId(\"field id\")\n+            .setLabel(\"field label\")\n+            .setRequired(false)\n+            .setType(Type.MULTIPLE_CHOICE)\n+            .setMultipleChoice(multipleChoiceBuilder.build())\n+            .build();\n+\n+    Element element = Element.ofField(field);\n+\n+    Form form =\n+        Form.newBuilder()\n+            .setId(\"form id\")\n+            .setElements(ImmutableList.<Element>builder().add(element).build())\n+            .build();\n+\n+    Layer layer =\n+        Layer.newBuilder()\n+            .setId(\"layer id\")\n+            .setItemLabel(\"item label\")\n+            .setListHeading(\"heading title\")\n+            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+            .setForm(form)\n+            .build();\n+\n+    Project.Builder builder =\n+        Project.newBuilder()\n+            .setId(\"project id\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\");\n+    builder.putLayer(layer.getId(), layer);\n+    return builder.build();\n+  }\n+\n+  private static FeatureMutation createTestFeatureMutation(\n+      String userId, String projectId, String layerId) {\n+    return FeatureMutation.builder()\n+        .setId(1L)\n+        .setType(Mutation.Type.CREATE)\n+        .setUserId(userId)\n+        .setProjectId(projectId)\n+        .setFeatureId(\"feature id\")\n+        .setLayerId(layerId)\n+        .setNewLocation(\n+            Optional.ofNullable(Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build()))\n+        .setClientTimestamp(new Date())\n+        .build();\n+  }\n+\n+  private static ObservationMutation createTestObservationMutation(\n+      String projectId, String featureId, String layerId, String formId, String userId) {\n+    return ObservationMutation.builder()\n+        .setType(Mutation.Type.CREATE)\n+        .setProjectId(projectId)\n+        .setFeatureId(featureId)\n+        .setLayerId(layerId)\n+        .setObservationId(\"observation id\")\n+        .setFormId(formId)\n+        .setResponseDeltas(\n+            ImmutableList.<ResponseDelta>builder()\n+                .add(\n+                    ResponseDelta.builder()\n+                        .setFieldId(\"field id\")\n+                        .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                        .build())\n+                .build())\n+        .setClientTimestamp(new Date())\n+        .setUserId(userId)\n+        .build();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    Project project1 =\n+        Project.newBuilder()\n+            .setId(\"id 1\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\")\n+            .build();\n+    Project project2 =\n+        Project.newBuilder()\n+            .setId(\"id 2\")\n+            .setTitle(\"project 2\")\n+            .setDescription(\"foo description 2\")\n+            .build();\n+    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n+    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n+    localDataStore\n+        .getProjects()\n+        .test()\n+        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.getProjectById(project.getId()).test().assertValue(project);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.deleteProject(project).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+    localDataStore.getUser(user.getId()).test().assertValue(user);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    ImmutableList<Mutation> savedMutations =\n+        localDataStore.getPendingMutations(mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(1, savedMutations.size());\n+\n+    // assert that mutation is saved to local database\n+    FeatureMutation savedMutation = (FeatureMutation) savedMutations.get(0);\n+    Assert.assertEquals(mutation.getNewLocation(), savedMutation.getNewLocation());\n+    Assert.assertEquals(mutation.getType(), savedMutation.getType());\n+    Assert.assertEquals(mutation.getUserId(), savedMutation.getUserId());\n+    Assert.assertEquals(mutation.getProjectId(), savedMutation.getProjectId());\n+    Assert.assertEquals(mutation.getFeatureId(), savedMutation.getFeatureId());\n+    Assert.assertEquals(mutation.getLayerId(), savedMutation.getLayerId());\n+    Assert.assertEquals(mutation.getClientTimestamp(), savedMutation.getClientTimestamp());\n+    Assert.assertEquals(0, savedMutation.getRetryCount());\n+    Assert.assertNull(savedMutation.getLastError());\n+\n+    // assert feature is saved to local database\n+    Feature feature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(mutation.getFeatureId(), feature.getId());\n+    Assert.assertEquals(project, feature.getProject());\n+    Assert.assertEquals(layer.getItemLabel(), feature.getTitle());\n+    Assert.assertEquals(layer, feature.getLayer());\n+    Assert.assertNull(feature.getCustomId());\n+    Assert.assertNull(feature.getCaption());\n+    Assert.assertEquals(mutation.getNewLocation().get(), feature.getPoint());\n+    Assert.assertEquals(user, feature.getCreated().getUser());\n+    Assert.assertEquals(user, feature.getLastModified().getUser());\n+  }\n+\n+  @Test\n+  public void testGetFeaturesOnceAndStream() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f19366bc11942167e22c82666e751169de42eb8"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgxOTQ4NA==", "bodyText": "insertOrUpdateUser needs to be subscribed to create the user. So either test().assertComplete() or blockingAwait() or subscribe(). I thought the cleanest would be to use test()", "url": "https://github.com/google/ground-android/pull/425#discussion_r408819484", "createdAt": "2020-04-15T12:56:02Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,611 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Builder;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static User createTestUser() {\n+    return User.builder()\n+        .setId(\"test_user_id\")\n+        .setEmail(\"test@gmail.com\")\n+        .setDisplayName(\"test user\")\n+        .build();\n+  }\n+\n+  private static Project createTestProject() {\n+    Builder multipleChoiceBuilder =\n+        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n+    multipleChoiceBuilder\n+        .optionsBuilder()\n+        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n+        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n+\n+    Field field =\n+        Field.newBuilder()\n+            .setId(\"field id\")\n+            .setLabel(\"field label\")\n+            .setRequired(false)\n+            .setType(Type.MULTIPLE_CHOICE)\n+            .setMultipleChoice(multipleChoiceBuilder.build())\n+            .build();\n+\n+    Element element = Element.ofField(field);\n+\n+    Form form =\n+        Form.newBuilder()\n+            .setId(\"form id\")\n+            .setElements(ImmutableList.<Element>builder().add(element).build())\n+            .build();\n+\n+    Layer layer =\n+        Layer.newBuilder()\n+            .setId(\"layer id\")\n+            .setItemLabel(\"item label\")\n+            .setListHeading(\"heading title\")\n+            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+            .setForm(form)\n+            .build();\n+\n+    Project.Builder builder =\n+        Project.newBuilder()\n+            .setId(\"project id\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\");\n+    builder.putLayer(layer.getId(), layer);\n+    return builder.build();\n+  }\n+\n+  private static FeatureMutation createTestFeatureMutation(\n+      String userId, String projectId, String layerId) {\n+    return FeatureMutation.builder()\n+        .setId(1L)\n+        .setType(Mutation.Type.CREATE)\n+        .setUserId(userId)\n+        .setProjectId(projectId)\n+        .setFeatureId(\"feature id\")\n+        .setLayerId(layerId)\n+        .setNewLocation(\n+            Optional.ofNullable(Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build()))\n+        .setClientTimestamp(new Date())\n+        .build();\n+  }\n+\n+  private static ObservationMutation createTestObservationMutation(\n+      String projectId, String featureId, String layerId, String formId, String userId) {\n+    return ObservationMutation.builder()\n+        .setType(Mutation.Type.CREATE)\n+        .setProjectId(projectId)\n+        .setFeatureId(featureId)\n+        .setLayerId(layerId)\n+        .setObservationId(\"observation id\")\n+        .setFormId(formId)\n+        .setResponseDeltas(\n+            ImmutableList.<ResponseDelta>builder()\n+                .add(\n+                    ResponseDelta.builder()\n+                        .setFieldId(\"field id\")\n+                        .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                        .build())\n+                .build())\n+        .setClientTimestamp(new Date())\n+        .setUserId(userId)\n+        .build();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    Project project1 =\n+        Project.newBuilder()\n+            .setId(\"id 1\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\")\n+            .build();\n+    Project project2 =\n+        Project.newBuilder()\n+            .setId(\"id 2\")\n+            .setTitle(\"project 2\")\n+            .setDescription(\"foo description 2\")\n+            .build();\n+    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n+    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n+    localDataStore\n+        .getProjects()\n+        .test()\n+        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.getProjectById(project.getId()).test().assertValue(project);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.deleteProject(project).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+    localDataStore.getUser(user.getId()).test().assertValue(user);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    ImmutableList<Mutation> savedMutations =\n+        localDataStore.getPendingMutations(mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(1, savedMutations.size());\n+\n+    // assert that mutation is saved to local database\n+    FeatureMutation savedMutation = (FeatureMutation) savedMutations.get(0);\n+    Assert.assertEquals(mutation.getNewLocation(), savedMutation.getNewLocation());\n+    Assert.assertEquals(mutation.getType(), savedMutation.getType());\n+    Assert.assertEquals(mutation.getUserId(), savedMutation.getUserId());\n+    Assert.assertEquals(mutation.getProjectId(), savedMutation.getProjectId());\n+    Assert.assertEquals(mutation.getFeatureId(), savedMutation.getFeatureId());\n+    Assert.assertEquals(mutation.getLayerId(), savedMutation.getLayerId());\n+    Assert.assertEquals(mutation.getClientTimestamp(), savedMutation.getClientTimestamp());\n+    Assert.assertEquals(0, savedMutation.getRetryCount());\n+    Assert.assertNull(savedMutation.getLastError());\n+\n+    // assert feature is saved to local database\n+    Feature feature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(mutation.getFeatureId(), feature.getId());\n+    Assert.assertEquals(project, feature.getProject());\n+    Assert.assertEquals(layer.getItemLabel(), feature.getTitle());\n+    Assert.assertEquals(layer, feature.getLayer());\n+    Assert.assertNull(feature.getCustomId());\n+    Assert.assertNull(feature.getCaption());\n+    Assert.assertEquals(mutation.getNewLocation().get(), feature.getPoint());\n+    Assert.assertEquals(user, feature.getCreated().getUser());\n+    Assert.assertEquals(user, feature.getLastModified().getUser());\n+  }\n+\n+  @Test\n+  public void testGetFeaturesOnceAndStream() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MDg4MA=="}, "originalCommit": {"oid": "7f19366bc11942167e22c82666e751169de42eb8"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg1OTM0Mg==", "bodyText": "On second thought, we can use subscribe for simplicity and to remove redundancy", "url": "https://github.com/google/ground-android/pull/425#discussion_r408859342", "createdAt": "2020-04-15T13:53:20Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,611 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Builder;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static User createTestUser() {\n+    return User.builder()\n+        .setId(\"test_user_id\")\n+        .setEmail(\"test@gmail.com\")\n+        .setDisplayName(\"test user\")\n+        .build();\n+  }\n+\n+  private static Project createTestProject() {\n+    Builder multipleChoiceBuilder =\n+        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n+    multipleChoiceBuilder\n+        .optionsBuilder()\n+        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n+        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n+\n+    Field field =\n+        Field.newBuilder()\n+            .setId(\"field id\")\n+            .setLabel(\"field label\")\n+            .setRequired(false)\n+            .setType(Type.MULTIPLE_CHOICE)\n+            .setMultipleChoice(multipleChoiceBuilder.build())\n+            .build();\n+\n+    Element element = Element.ofField(field);\n+\n+    Form form =\n+        Form.newBuilder()\n+            .setId(\"form id\")\n+            .setElements(ImmutableList.<Element>builder().add(element).build())\n+            .build();\n+\n+    Layer layer =\n+        Layer.newBuilder()\n+            .setId(\"layer id\")\n+            .setItemLabel(\"item label\")\n+            .setListHeading(\"heading title\")\n+            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+            .setForm(form)\n+            .build();\n+\n+    Project.Builder builder =\n+        Project.newBuilder()\n+            .setId(\"project id\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\");\n+    builder.putLayer(layer.getId(), layer);\n+    return builder.build();\n+  }\n+\n+  private static FeatureMutation createTestFeatureMutation(\n+      String userId, String projectId, String layerId) {\n+    return FeatureMutation.builder()\n+        .setId(1L)\n+        .setType(Mutation.Type.CREATE)\n+        .setUserId(userId)\n+        .setProjectId(projectId)\n+        .setFeatureId(\"feature id\")\n+        .setLayerId(layerId)\n+        .setNewLocation(\n+            Optional.ofNullable(Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build()))\n+        .setClientTimestamp(new Date())\n+        .build();\n+  }\n+\n+  private static ObservationMutation createTestObservationMutation(\n+      String projectId, String featureId, String layerId, String formId, String userId) {\n+    return ObservationMutation.builder()\n+        .setType(Mutation.Type.CREATE)\n+        .setProjectId(projectId)\n+        .setFeatureId(featureId)\n+        .setLayerId(layerId)\n+        .setObservationId(\"observation id\")\n+        .setFormId(formId)\n+        .setResponseDeltas(\n+            ImmutableList.<ResponseDelta>builder()\n+                .add(\n+                    ResponseDelta.builder()\n+                        .setFieldId(\"field id\")\n+                        .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                        .build())\n+                .build())\n+        .setClientTimestamp(new Date())\n+        .setUserId(userId)\n+        .build();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    Project project1 =\n+        Project.newBuilder()\n+            .setId(\"id 1\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\")\n+            .build();\n+    Project project2 =\n+        Project.newBuilder()\n+            .setId(\"id 2\")\n+            .setTitle(\"project 2\")\n+            .setDescription(\"foo description 2\")\n+            .build();\n+    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n+    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n+    localDataStore\n+        .getProjects()\n+        .test()\n+        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.getProjectById(project.getId()).test().assertValue(project);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.deleteProject(project).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+    localDataStore.getUser(user.getId()).test().assertValue(user);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    ImmutableList<Mutation> savedMutations =\n+        localDataStore.getPendingMutations(mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(1, savedMutations.size());\n+\n+    // assert that mutation is saved to local database\n+    FeatureMutation savedMutation = (FeatureMutation) savedMutations.get(0);\n+    Assert.assertEquals(mutation.getNewLocation(), savedMutation.getNewLocation());\n+    Assert.assertEquals(mutation.getType(), savedMutation.getType());\n+    Assert.assertEquals(mutation.getUserId(), savedMutation.getUserId());\n+    Assert.assertEquals(mutation.getProjectId(), savedMutation.getProjectId());\n+    Assert.assertEquals(mutation.getFeatureId(), savedMutation.getFeatureId());\n+    Assert.assertEquals(mutation.getLayerId(), savedMutation.getLayerId());\n+    Assert.assertEquals(mutation.getClientTimestamp(), savedMutation.getClientTimestamp());\n+    Assert.assertEquals(0, savedMutation.getRetryCount());\n+    Assert.assertNull(savedMutation.getLastError());\n+\n+    // assert feature is saved to local database\n+    Feature feature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(mutation.getFeatureId(), feature.getId());\n+    Assert.assertEquals(project, feature.getProject());\n+    Assert.assertEquals(layer.getItemLabel(), feature.getTitle());\n+    Assert.assertEquals(layer, feature.getLayer());\n+    Assert.assertNull(feature.getCustomId());\n+    Assert.assertNull(feature.getCaption());\n+    Assert.assertEquals(mutation.getNewLocation().get(), feature.getPoint());\n+    Assert.assertEquals(user, feature.getCreated().getUser());\n+    Assert.assertEquals(user, feature.getLastModified().getUser());\n+  }\n+\n+  @Test\n+  public void testGetFeaturesOnceAndStream() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MDg4MA=="}, "originalCommit": {"oid": "7f19366bc11942167e22c82666e751169de42eb8"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2NjIzMw==", "bodyText": "Done", "url": "https://github.com/google/ground-android/pull/425#discussion_r408866233", "createdAt": "2020-04-15T14:02:10Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,611 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Builder;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static User createTestUser() {\n+    return User.builder()\n+        .setId(\"test_user_id\")\n+        .setEmail(\"test@gmail.com\")\n+        .setDisplayName(\"test user\")\n+        .build();\n+  }\n+\n+  private static Project createTestProject() {\n+    Builder multipleChoiceBuilder =\n+        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n+    multipleChoiceBuilder\n+        .optionsBuilder()\n+        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n+        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n+\n+    Field field =\n+        Field.newBuilder()\n+            .setId(\"field id\")\n+            .setLabel(\"field label\")\n+            .setRequired(false)\n+            .setType(Type.MULTIPLE_CHOICE)\n+            .setMultipleChoice(multipleChoiceBuilder.build())\n+            .build();\n+\n+    Element element = Element.ofField(field);\n+\n+    Form form =\n+        Form.newBuilder()\n+            .setId(\"form id\")\n+            .setElements(ImmutableList.<Element>builder().add(element).build())\n+            .build();\n+\n+    Layer layer =\n+        Layer.newBuilder()\n+            .setId(\"layer id\")\n+            .setItemLabel(\"item label\")\n+            .setListHeading(\"heading title\")\n+            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+            .setForm(form)\n+            .build();\n+\n+    Project.Builder builder =\n+        Project.newBuilder()\n+            .setId(\"project id\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\");\n+    builder.putLayer(layer.getId(), layer);\n+    return builder.build();\n+  }\n+\n+  private static FeatureMutation createTestFeatureMutation(\n+      String userId, String projectId, String layerId) {\n+    return FeatureMutation.builder()\n+        .setId(1L)\n+        .setType(Mutation.Type.CREATE)\n+        .setUserId(userId)\n+        .setProjectId(projectId)\n+        .setFeatureId(\"feature id\")\n+        .setLayerId(layerId)\n+        .setNewLocation(\n+            Optional.ofNullable(Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build()))\n+        .setClientTimestamp(new Date())\n+        .build();\n+  }\n+\n+  private static ObservationMutation createTestObservationMutation(\n+      String projectId, String featureId, String layerId, String formId, String userId) {\n+    return ObservationMutation.builder()\n+        .setType(Mutation.Type.CREATE)\n+        .setProjectId(projectId)\n+        .setFeatureId(featureId)\n+        .setLayerId(layerId)\n+        .setObservationId(\"observation id\")\n+        .setFormId(formId)\n+        .setResponseDeltas(\n+            ImmutableList.<ResponseDelta>builder()\n+                .add(\n+                    ResponseDelta.builder()\n+                        .setFieldId(\"field id\")\n+                        .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                        .build())\n+                .build())\n+        .setClientTimestamp(new Date())\n+        .setUserId(userId)\n+        .build();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    Project project1 =\n+        Project.newBuilder()\n+            .setId(\"id 1\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\")\n+            .build();\n+    Project project2 =\n+        Project.newBuilder()\n+            .setId(\"id 2\")\n+            .setTitle(\"project 2\")\n+            .setDescription(\"foo description 2\")\n+            .build();\n+    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n+    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n+    localDataStore\n+        .getProjects()\n+        .test()\n+        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.getProjectById(project.getId()).test().assertValue(project);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.deleteProject(project).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+    localDataStore.getUser(user.getId()).test().assertValue(user);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    ImmutableList<Mutation> savedMutations =\n+        localDataStore.getPendingMutations(mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(1, savedMutations.size());\n+\n+    // assert that mutation is saved to local database\n+    FeatureMutation savedMutation = (FeatureMutation) savedMutations.get(0);\n+    Assert.assertEquals(mutation.getNewLocation(), savedMutation.getNewLocation());\n+    Assert.assertEquals(mutation.getType(), savedMutation.getType());\n+    Assert.assertEquals(mutation.getUserId(), savedMutation.getUserId());\n+    Assert.assertEquals(mutation.getProjectId(), savedMutation.getProjectId());\n+    Assert.assertEquals(mutation.getFeatureId(), savedMutation.getFeatureId());\n+    Assert.assertEquals(mutation.getLayerId(), savedMutation.getLayerId());\n+    Assert.assertEquals(mutation.getClientTimestamp(), savedMutation.getClientTimestamp());\n+    Assert.assertEquals(0, savedMutation.getRetryCount());\n+    Assert.assertNull(savedMutation.getLastError());\n+\n+    // assert feature is saved to local database\n+    Feature feature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(mutation.getFeatureId(), feature.getId());\n+    Assert.assertEquals(project, feature.getProject());\n+    Assert.assertEquals(layer.getItemLabel(), feature.getTitle());\n+    Assert.assertEquals(layer, feature.getLayer());\n+    Assert.assertNull(feature.getCustomId());\n+    Assert.assertNull(feature.getCaption());\n+    Assert.assertEquals(mutation.getNewLocation().get(), feature.getPoint());\n+    Assert.assertEquals(user, feature.getCreated().getUser());\n+    Assert.assertEquals(user, feature.getLastModified().getUser());\n+  }\n+\n+  @Test\n+  public void testGetFeaturesOnceAndStream() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MDg4MA=="}, "originalCommit": {"oid": "7f19366bc11942167e22c82666e751169de42eb8"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDk2MjE0OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzozOTo1OVrOGFZvoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0OTowMVrOGF9aWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNzg1Nw==", "bodyText": "This test (and ones like it) look they're testing more than one behavior, which is why they're longer . Can we split these into clear preconditions, execute, and postconditions? See previous comments for ways to simplify.", "url": "https://github.com/google/ground-android/pull/425#discussion_r408317857", "createdAt": "2020-04-14T17:39:59Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,611 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Builder;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static User createTestUser() {\n+    return User.builder()\n+        .setId(\"test_user_id\")\n+        .setEmail(\"test@gmail.com\")\n+        .setDisplayName(\"test user\")\n+        .build();\n+  }\n+\n+  private static Project createTestProject() {\n+    Builder multipleChoiceBuilder =\n+        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n+    multipleChoiceBuilder\n+        .optionsBuilder()\n+        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n+        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n+\n+    Field field =\n+        Field.newBuilder()\n+            .setId(\"field id\")\n+            .setLabel(\"field label\")\n+            .setRequired(false)\n+            .setType(Type.MULTIPLE_CHOICE)\n+            .setMultipleChoice(multipleChoiceBuilder.build())\n+            .build();\n+\n+    Element element = Element.ofField(field);\n+\n+    Form form =\n+        Form.newBuilder()\n+            .setId(\"form id\")\n+            .setElements(ImmutableList.<Element>builder().add(element).build())\n+            .build();\n+\n+    Layer layer =\n+        Layer.newBuilder()\n+            .setId(\"layer id\")\n+            .setItemLabel(\"item label\")\n+            .setListHeading(\"heading title\")\n+            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+            .setForm(form)\n+            .build();\n+\n+    Project.Builder builder =\n+        Project.newBuilder()\n+            .setId(\"project id\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\");\n+    builder.putLayer(layer.getId(), layer);\n+    return builder.build();\n+  }\n+\n+  private static FeatureMutation createTestFeatureMutation(\n+      String userId, String projectId, String layerId) {\n+    return FeatureMutation.builder()\n+        .setId(1L)\n+        .setType(Mutation.Type.CREATE)\n+        .setUserId(userId)\n+        .setProjectId(projectId)\n+        .setFeatureId(\"feature id\")\n+        .setLayerId(layerId)\n+        .setNewLocation(\n+            Optional.ofNullable(Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build()))\n+        .setClientTimestamp(new Date())\n+        .build();\n+  }\n+\n+  private static ObservationMutation createTestObservationMutation(\n+      String projectId, String featureId, String layerId, String formId, String userId) {\n+    return ObservationMutation.builder()\n+        .setType(Mutation.Type.CREATE)\n+        .setProjectId(projectId)\n+        .setFeatureId(featureId)\n+        .setLayerId(layerId)\n+        .setObservationId(\"observation id\")\n+        .setFormId(formId)\n+        .setResponseDeltas(\n+            ImmutableList.<ResponseDelta>builder()\n+                .add(\n+                    ResponseDelta.builder()\n+                        .setFieldId(\"field id\")\n+                        .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                        .build())\n+                .build())\n+        .setClientTimestamp(new Date())\n+        .setUserId(userId)\n+        .build();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    Project project1 =\n+        Project.newBuilder()\n+            .setId(\"id 1\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\")\n+            .build();\n+    Project project2 =\n+        Project.newBuilder()\n+            .setId(\"id 2\")\n+            .setTitle(\"project 2\")\n+            .setDescription(\"foo description 2\")\n+            .build();\n+    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n+    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n+    localDataStore\n+        .getProjects()\n+        .test()\n+        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.getProjectById(project.getId()).test().assertValue(project);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.deleteProject(project).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+    localDataStore.getUser(user.getId()).test().assertValue(user);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    ImmutableList<Mutation> savedMutations =\n+        localDataStore.getPendingMutations(mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(1, savedMutations.size());\n+\n+    // assert that mutation is saved to local database\n+    FeatureMutation savedMutation = (FeatureMutation) savedMutations.get(0);\n+    Assert.assertEquals(mutation.getNewLocation(), savedMutation.getNewLocation());\n+    Assert.assertEquals(mutation.getType(), savedMutation.getType());\n+    Assert.assertEquals(mutation.getUserId(), savedMutation.getUserId());\n+    Assert.assertEquals(mutation.getProjectId(), savedMutation.getProjectId());\n+    Assert.assertEquals(mutation.getFeatureId(), savedMutation.getFeatureId());\n+    Assert.assertEquals(mutation.getLayerId(), savedMutation.getLayerId());\n+    Assert.assertEquals(mutation.getClientTimestamp(), savedMutation.getClientTimestamp());\n+    Assert.assertEquals(0, savedMutation.getRetryCount());\n+    Assert.assertNull(savedMutation.getLastError());\n+\n+    // assert feature is saved to local database\n+    Feature feature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(mutation.getFeatureId(), feature.getId());\n+    Assert.assertEquals(project, feature.getProject());\n+    Assert.assertEquals(layer.getItemLabel(), feature.getTitle());\n+    Assert.assertEquals(layer, feature.getLayer());\n+    Assert.assertNull(feature.getCustomId());\n+    Assert.assertNull(feature.getCaption());\n+    Assert.assertEquals(mutation.getNewLocation().get(), feature.getPoint());\n+    Assert.assertEquals(user, feature.getCreated().getUser());\n+    Assert.assertEquals(user, feature.getLastModified().getUser());\n+  }\n+\n+  @Test\n+  public void testGetFeaturesOnceAndStream() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    TestSubscriber<ImmutableSet<Feature>> subscriber =\n+        localDataStore.getFeaturesOnceAndStream(project).test();\n+\n+    subscriber.assertValueCount(1);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    Feature feature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+\n+    subscriber.assertValueCount(2);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+    subscriber.assertValueAt(1, ImmutableSet.<Feature>builder().add(feature).build());\n+  }\n+\n+  @Test\n+  public void testUpdateMutations() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    Point newPoint = Point.newBuilder().setLatitude(51.0).setLongitude(44.0).build();\n+    Mutation updatedMutation =\n+        mutation.toBuilder().setNewLocation(Optional.ofNullable(newPoint)).build();\n+\n+    localDataStore\n+        .updateMutations(ImmutableList.<Mutation>builder().add(updatedMutation).build())\n+        .test()\n+        .assertComplete();\n+\n+    ImmutableList<Mutation> savedMutations =\n+        localDataStore.getPendingMutations(updatedMutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(1, savedMutations.size());\n+\n+    FeatureMutation savedMutation = (FeatureMutation) savedMutations.get(0);\n+    Assert.assertEquals(newPoint, savedMutation.getNewLocation().get());\n+  }\n+\n+  @Test\n+  public void testRemovePendingMutation() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    localDataStore\n+        .removePendingMutations(ImmutableList.<Mutation>builder().add(mutation).build())\n+        .test()\n+        .assertComplete();\n+\n+    localDataStore\n+        .getPendingMutations(mutation.getFeatureId())\n+        .test()\n+        .assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testMergeFeature() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    Feature feature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+    Point point = Point.newBuilder().setLongitude(11.0).setLatitude(33.0).build();\n+    feature = feature.toBuilder().setPoint(point).build();\n+    localDataStore.mergeFeature(feature).test().assertComplete();\n+\n+    Feature newFeature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(mutation.getFeatureId(), newFeature.getId());\n+    Assert.assertEquals(project, newFeature.getProject());\n+    Assert.assertEquals(layer.getItemLabel(), newFeature.getTitle());\n+    Assert.assertEquals(layer, newFeature.getLayer());\n+    Assert.assertNull(newFeature.getCustomId());\n+    Assert.assertNull(newFeature.getCaption());\n+    Assert.assertEquals(point, newFeature.getPoint());\n+    Assert.assertEquals(user, newFeature.getCreated().getUser());\n+    Assert.assertEquals(user, newFeature.getLastModified().getUser());\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_observationMutation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d067567ac55be392063ab19c3d46df237e0e657"}, "originalPosition": 365}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMjIzMw==", "bodyText": "Done. PTAL", "url": "https://github.com/google/ground-android/pull/425#discussion_r408902233", "createdAt": "2020-04-15T14:49:01Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,611 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Builder;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static User createTestUser() {\n+    return User.builder()\n+        .setId(\"test_user_id\")\n+        .setEmail(\"test@gmail.com\")\n+        .setDisplayName(\"test user\")\n+        .build();\n+  }\n+\n+  private static Project createTestProject() {\n+    Builder multipleChoiceBuilder =\n+        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n+    multipleChoiceBuilder\n+        .optionsBuilder()\n+        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n+        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n+\n+    Field field =\n+        Field.newBuilder()\n+            .setId(\"field id\")\n+            .setLabel(\"field label\")\n+            .setRequired(false)\n+            .setType(Type.MULTIPLE_CHOICE)\n+            .setMultipleChoice(multipleChoiceBuilder.build())\n+            .build();\n+\n+    Element element = Element.ofField(field);\n+\n+    Form form =\n+        Form.newBuilder()\n+            .setId(\"form id\")\n+            .setElements(ImmutableList.<Element>builder().add(element).build())\n+            .build();\n+\n+    Layer layer =\n+        Layer.newBuilder()\n+            .setId(\"layer id\")\n+            .setItemLabel(\"item label\")\n+            .setListHeading(\"heading title\")\n+            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+            .setForm(form)\n+            .build();\n+\n+    Project.Builder builder =\n+        Project.newBuilder()\n+            .setId(\"project id\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\");\n+    builder.putLayer(layer.getId(), layer);\n+    return builder.build();\n+  }\n+\n+  private static FeatureMutation createTestFeatureMutation(\n+      String userId, String projectId, String layerId) {\n+    return FeatureMutation.builder()\n+        .setId(1L)\n+        .setType(Mutation.Type.CREATE)\n+        .setUserId(userId)\n+        .setProjectId(projectId)\n+        .setFeatureId(\"feature id\")\n+        .setLayerId(layerId)\n+        .setNewLocation(\n+            Optional.ofNullable(Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build()))\n+        .setClientTimestamp(new Date())\n+        .build();\n+  }\n+\n+  private static ObservationMutation createTestObservationMutation(\n+      String projectId, String featureId, String layerId, String formId, String userId) {\n+    return ObservationMutation.builder()\n+        .setType(Mutation.Type.CREATE)\n+        .setProjectId(projectId)\n+        .setFeatureId(featureId)\n+        .setLayerId(layerId)\n+        .setObservationId(\"observation id\")\n+        .setFormId(formId)\n+        .setResponseDeltas(\n+            ImmutableList.<ResponseDelta>builder()\n+                .add(\n+                    ResponseDelta.builder()\n+                        .setFieldId(\"field id\")\n+                        .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                        .build())\n+                .build())\n+        .setClientTimestamp(new Date())\n+        .setUserId(userId)\n+        .build();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    Project project1 =\n+        Project.newBuilder()\n+            .setId(\"id 1\")\n+            .setTitle(\"project 1\")\n+            .setDescription(\"foo description\")\n+            .build();\n+    Project project2 =\n+        Project.newBuilder()\n+            .setId(\"id 2\")\n+            .setTitle(\"project 2\")\n+            .setDescription(\"foo description 2\")\n+            .build();\n+    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n+    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n+    localDataStore\n+        .getProjects()\n+        .test()\n+        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.getProjectById(project.getId()).test().assertValue(project);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.deleteProject(project).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+    localDataStore.getUser(user.getId()).test().assertValue(user);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    ImmutableList<Mutation> savedMutations =\n+        localDataStore.getPendingMutations(mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(1, savedMutations.size());\n+\n+    // assert that mutation is saved to local database\n+    FeatureMutation savedMutation = (FeatureMutation) savedMutations.get(0);\n+    Assert.assertEquals(mutation.getNewLocation(), savedMutation.getNewLocation());\n+    Assert.assertEquals(mutation.getType(), savedMutation.getType());\n+    Assert.assertEquals(mutation.getUserId(), savedMutation.getUserId());\n+    Assert.assertEquals(mutation.getProjectId(), savedMutation.getProjectId());\n+    Assert.assertEquals(mutation.getFeatureId(), savedMutation.getFeatureId());\n+    Assert.assertEquals(mutation.getLayerId(), savedMutation.getLayerId());\n+    Assert.assertEquals(mutation.getClientTimestamp(), savedMutation.getClientTimestamp());\n+    Assert.assertEquals(0, savedMutation.getRetryCount());\n+    Assert.assertNull(savedMutation.getLastError());\n+\n+    // assert feature is saved to local database\n+    Feature feature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(mutation.getFeatureId(), feature.getId());\n+    Assert.assertEquals(project, feature.getProject());\n+    Assert.assertEquals(layer.getItemLabel(), feature.getTitle());\n+    Assert.assertEquals(layer, feature.getLayer());\n+    Assert.assertNull(feature.getCustomId());\n+    Assert.assertNull(feature.getCaption());\n+    Assert.assertEquals(mutation.getNewLocation().get(), feature.getPoint());\n+    Assert.assertEquals(user, feature.getCreated().getUser());\n+    Assert.assertEquals(user, feature.getLastModified().getUser());\n+  }\n+\n+  @Test\n+  public void testGetFeaturesOnceAndStream() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    TestSubscriber<ImmutableSet<Feature>> subscriber =\n+        localDataStore.getFeaturesOnceAndStream(project).test();\n+\n+    subscriber.assertValueCount(1);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    Feature feature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+\n+    subscriber.assertValueCount(2);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+    subscriber.assertValueAt(1, ImmutableSet.<Feature>builder().add(feature).build());\n+  }\n+\n+  @Test\n+  public void testUpdateMutations() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    Point newPoint = Point.newBuilder().setLatitude(51.0).setLongitude(44.0).build();\n+    Mutation updatedMutation =\n+        mutation.toBuilder().setNewLocation(Optional.ofNullable(newPoint)).build();\n+\n+    localDataStore\n+        .updateMutations(ImmutableList.<Mutation>builder().add(updatedMutation).build())\n+        .test()\n+        .assertComplete();\n+\n+    ImmutableList<Mutation> savedMutations =\n+        localDataStore.getPendingMutations(updatedMutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(1, savedMutations.size());\n+\n+    FeatureMutation savedMutation = (FeatureMutation) savedMutations.get(0);\n+    Assert.assertEquals(newPoint, savedMutation.getNewLocation().get());\n+  }\n+\n+  @Test\n+  public void testRemovePendingMutation() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    localDataStore\n+        .removePendingMutations(ImmutableList.<Mutation>builder().add(mutation).build())\n+        .test()\n+        .assertComplete();\n+\n+    localDataStore\n+        .getPendingMutations(mutation.getFeatureId())\n+        .test()\n+        .assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testMergeFeature() {\n+    User user = createTestUser();\n+    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+\n+    Project project = createTestProject();\n+    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+\n+    Layer layer = project.getLayers().get(0);\n+    FeatureMutation mutation =\n+        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n+\n+    Feature feature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+    Point point = Point.newBuilder().setLongitude(11.0).setLatitude(33.0).build();\n+    feature = feature.toBuilder().setPoint(point).build();\n+    localDataStore.mergeFeature(feature).test().assertComplete();\n+\n+    Feature newFeature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+    Assert.assertEquals(mutation.getFeatureId(), newFeature.getId());\n+    Assert.assertEquals(project, newFeature.getProject());\n+    Assert.assertEquals(layer.getItemLabel(), newFeature.getTitle());\n+    Assert.assertEquals(layer, newFeature.getLayer());\n+    Assert.assertNull(newFeature.getCustomId());\n+    Assert.assertNull(newFeature.getCaption());\n+    Assert.assertEquals(point, newFeature.getPoint());\n+    Assert.assertEquals(user, newFeature.getCreated().getUser());\n+    Assert.assertEquals(user, newFeature.getLastModified().getUser());\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_observationMutation() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNzg1Nw=="}, "originalCommit": {"oid": "4d067567ac55be392063ab19c3d46df237e0e657"}, "originalPosition": 365}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDY2MjM1OnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/RoomLocalDataStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToxNjozNFrOGG3dxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToxNjozNFrOGG3dxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg1MzM4Mg==", "bodyText": "let's stick with the \"findAll\" prefix for consistency with other DAOs, so \"findAllOnceAndStream?", "url": "https://github.com/google/ground-android/pull/425#discussion_r409853382", "createdAt": "2020-04-16T21:16:34Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/RoomLocalDataStore.java", "diffHunk": "@@ -268,7 +268,7 @@ public Completable applyAndEnqueue(FeatureMutation mutation) {\n   @Override\n   public Flowable<ImmutableSet<Tile>> getTilesOnceAndStream() {\n     return tileDao\n-        .findAll()\n+        .getTilesOnceAndStream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbcfe556d9d7c343cf2ac9f95d7d01dee76089a7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDY2NDY4OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToxNzoyNlrOGG3fMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToxNzoyNlrOGG3fMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg1Mzc0NA==", "bodyText": "Nit: Please use natural word order for readability: TEST_PENDING_TILE here and below.", "url": "https://github.com/google/ground-android/pull/425#discussion_r409853744", "createdAt": "2020-04-16T21:17:26Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -67,97 +66,138 @@\n @Config(application = TestApplication.class)\n public class LocalDataStoreTest {\n \n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_TILE_PENDING =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbcfe556d9d7c343cf2ac9f95d7d01dee76089a7"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDY2OTQyOnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToxODo1OFrOGG3iKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToxODo1OFrOGG3iKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg1NDUwNg==", "bodyText": "One asserts that something Xs, so here it would be assertObservationMutationEquals.\nBut this also does something extra, so should be reflected in the name, e.g.:\nassertEqualsIgnoreId.\nWe can omit \"ObservationMutation\" from the name for brevity since it will be clear from the arguments what's being compared.", "url": "https://github.com/google/ground-android/pull/425#discussion_r409854506", "createdAt": "2020-04-16T21:18:58Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -67,97 +66,138 @@\n @Config(application = TestApplication.class)\n public class LocalDataStoreTest {\n \n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_TILE_PENDING =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_TILE_DOWNLOADED =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_TILE_FAILED =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n   // This rule makes sure that Room executes all the database operations instantly.\n   @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n \n   @Inject LocalDataStore localDataStore;\n \n-  private static User createTestUser() {\n-    return User.builder()\n-        .setId(\"test_user_id\")\n-        .setEmail(\"test@gmail.com\")\n-        .setDisplayName(\"test user\")\n-        .build();\n-  }\n-\n-  private static Project createTestProject() {\n-    Builder multipleChoiceBuilder =\n-        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n-    multipleChoiceBuilder\n-        .optionsBuilder()\n-        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n-        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n-\n-    Field field =\n-        Field.newBuilder()\n-            .setId(\"field id\")\n-            .setLabel(\"field label\")\n-            .setRequired(false)\n-            .setType(Type.MULTIPLE_CHOICE)\n-            .setMultipleChoice(multipleChoiceBuilder.build())\n-            .build();\n-\n-    Element element = Element.ofField(field);\n-\n-    Form form =\n-        Form.newBuilder()\n-            .setId(\"form id\")\n-            .setElements(ImmutableList.<Element>builder().add(element).build())\n-            .build();\n-\n-    Layer layer =\n-        Layer.newBuilder()\n-            .setId(\"layer id\")\n-            .setItemLabel(\"item label\")\n-            .setListHeading(\"heading title\")\n-            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n-            .setForm(form)\n-            .build();\n-\n-    Project.Builder builder =\n-        Project.newBuilder()\n-            .setId(\"project id\")\n-            .setTitle(\"project 1\")\n-            .setDescription(\"foo description\");\n-    builder.putLayer(layer.getId(), layer);\n-    return builder.build();\n-  }\n-\n-  private static FeatureMutation createTestFeatureMutation(\n-      String userId, String projectId, String layerId) {\n-    return FeatureMutation.builder()\n-        .setId(1L)\n-        .setType(Mutation.Type.CREATE)\n-        .setUserId(userId)\n-        .setProjectId(projectId)\n-        .setFeatureId(\"feature id\")\n-        .setLayerId(layerId)\n-        .setNewLocation(\n-            Optional.ofNullable(Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build()))\n-        .setClientTimestamp(new Date())\n-        .build();\n+  private static void assertObservationMutation(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbcfe556d9d7c343cf2ac9f95d7d01dee76089a7"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDY3NTkyOnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToyMTowOVrOGG3mNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToyMTowOVrOGG3mNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg1NTU0MQ==", "bodyText": "Let's use Google Truth consistently here and throughout to set a stable precedent and to get more useful error messages. i.e. assertThat(actual).isEqualTo(expected).", "url": "https://github.com/google/ground-android/pull/425#discussion_r409855541", "createdAt": "2020-04-16T21:21:09Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -67,97 +66,138 @@\n @Config(application = TestApplication.class)\n public class LocalDataStoreTest {\n \n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_TILE_PENDING =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_TILE_DOWNLOADED =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_TILE_FAILED =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n   // This rule makes sure that Room executes all the database operations instantly.\n   @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n \n   @Inject LocalDataStore localDataStore;\n \n-  private static User createTestUser() {\n-    return User.builder()\n-        .setId(\"test_user_id\")\n-        .setEmail(\"test@gmail.com\")\n-        .setDisplayName(\"test user\")\n-        .build();\n-  }\n-\n-  private static Project createTestProject() {\n-    Builder multipleChoiceBuilder =\n-        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n-    multipleChoiceBuilder\n-        .optionsBuilder()\n-        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n-        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n-\n-    Field field =\n-        Field.newBuilder()\n-            .setId(\"field id\")\n-            .setLabel(\"field label\")\n-            .setRequired(false)\n-            .setType(Type.MULTIPLE_CHOICE)\n-            .setMultipleChoice(multipleChoiceBuilder.build())\n-            .build();\n-\n-    Element element = Element.ofField(field);\n-\n-    Form form =\n-        Form.newBuilder()\n-            .setId(\"form id\")\n-            .setElements(ImmutableList.<Element>builder().add(element).build())\n-            .build();\n-\n-    Layer layer =\n-        Layer.newBuilder()\n-            .setId(\"layer id\")\n-            .setItemLabel(\"item label\")\n-            .setListHeading(\"heading title\")\n-            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n-            .setForm(form)\n-            .build();\n-\n-    Project.Builder builder =\n-        Project.newBuilder()\n-            .setId(\"project id\")\n-            .setTitle(\"project 1\")\n-            .setDescription(\"foo description\");\n-    builder.putLayer(layer.getId(), layer);\n-    return builder.build();\n-  }\n-\n-  private static FeatureMutation createTestFeatureMutation(\n-      String userId, String projectId, String layerId) {\n-    return FeatureMutation.builder()\n-        .setId(1L)\n-        .setType(Mutation.Type.CREATE)\n-        .setUserId(userId)\n-        .setProjectId(projectId)\n-        .setFeatureId(\"feature id\")\n-        .setLayerId(layerId)\n-        .setNewLocation(\n-            Optional.ofNullable(Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build()))\n-        .setClientTimestamp(new Date())\n-        .build();\n+  private static void assertObservationMutation(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    Assert.assertEquals(expected, actual);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbcfe556d9d7c343cf2ac9f95d7d01dee76089a7"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDY4MTI5OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToyMzowMlrOGG3p0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToyMzowMlrOGG3p0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg1NjQ2NA==", "bodyText": "Same here: https://truth.dev/\nPlease be sure to use static imports to make assertions more fluent.", "url": "https://github.com/google/ground-android/pull/425#discussion_r409856464", "createdAt": "2020-04-16T21:23:02Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -67,97 +66,138 @@\n @Config(application = TestApplication.class)\n public class LocalDataStoreTest {\n \n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_TILE_PENDING =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_TILE_DOWNLOADED =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_TILE_FAILED =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n   // This rule makes sure that Room executes all the database operations instantly.\n   @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n \n   @Inject LocalDataStore localDataStore;\n \n-  private static User createTestUser() {\n-    return User.builder()\n-        .setId(\"test_user_id\")\n-        .setEmail(\"test@gmail.com\")\n-        .setDisplayName(\"test user\")\n-        .build();\n-  }\n-\n-  private static Project createTestProject() {\n-    Builder multipleChoiceBuilder =\n-        MultipleChoice.newBuilder().setCardinality(Cardinality.SELECT_ONE);\n-    multipleChoiceBuilder\n-        .optionsBuilder()\n-        .add(Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build())\n-        .add(Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build());\n-\n-    Field field =\n-        Field.newBuilder()\n-            .setId(\"field id\")\n-            .setLabel(\"field label\")\n-            .setRequired(false)\n-            .setType(Type.MULTIPLE_CHOICE)\n-            .setMultipleChoice(multipleChoiceBuilder.build())\n-            .build();\n-\n-    Element element = Element.ofField(field);\n-\n-    Form form =\n-        Form.newBuilder()\n-            .setId(\"form id\")\n-            .setElements(ImmutableList.<Element>builder().add(element).build())\n-            .build();\n-\n-    Layer layer =\n-        Layer.newBuilder()\n-            .setId(\"layer id\")\n-            .setItemLabel(\"item label\")\n-            .setListHeading(\"heading title\")\n-            .setDefaultStyle(Style.builder().setColor(\"000\").build())\n-            .setForm(form)\n-            .build();\n-\n-    Project.Builder builder =\n-        Project.newBuilder()\n-            .setId(\"project id\")\n-            .setTitle(\"project 1\")\n-            .setDescription(\"foo description\");\n-    builder.putLayer(layer.getId(), layer);\n-    return builder.build();\n-  }\n-\n-  private static FeatureMutation createTestFeatureMutation(\n-      String userId, String projectId, String layerId) {\n-    return FeatureMutation.builder()\n-        .setId(1L)\n-        .setType(Mutation.Type.CREATE)\n-        .setUserId(userId)\n-        .setProjectId(projectId)\n-        .setFeatureId(\"feature id\")\n-        .setLayerId(layerId)\n-        .setNewLocation(\n-            Optional.ofNullable(Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build()))\n-        .setClientTimestamp(new Date())\n-        .build();\n+  private static void assertObservationMutation(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    Assert.assertEquals(expected, actual);\n   }\n \n-  private static ObservationMutation createTestObservationMutation(\n-      String projectId, String featureId, String layerId, String formId, String userId) {\n-    return ObservationMutation.builder()\n-        .setType(Mutation.Type.CREATE)\n-        .setProjectId(projectId)\n-        .setFeatureId(featureId)\n-        .setLayerId(layerId)\n-        .setObservationId(\"observation id\")\n-        .setFormId(formId)\n-        .setResponseDeltas(\n-            ImmutableList.<ResponseDelta>builder()\n-                .add(\n-                    ResponseDelta.builder()\n-                        .setFieldId(\"field id\")\n-                        .setNewResponse(TextResponse.fromString(\"response for field id\"))\n-                        .build())\n-                .build())\n-        .setClientTimestamp(new Date())\n-        .setUserId(userId)\n-        .build();\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {\n+    Assert.assertEquals(mutation.getObservationId(), observation.getId());\n+    Assert.assertEquals(mutation.getFeatureId(), observation.getFeature().getId());\n+    Assert.assertEquals(TEST_USER, observation.getCreated().getUser());\n+    Assert.assertEquals(TEST_FORM, observation.getForm());\n+    Assert.assertEquals(TEST_PROJECT, observation.getProject());\n+    Assert.assertEquals(TEST_USER, observation.getLastModified().getUser());\n+    MatcherAssert.assertThat(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbcfe556d9d7c343cf2ac9f95d7d01dee76089a7"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDY4MzQ4OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToyMzo0MVrOGG3rLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToyMzo0MVrOGG3rLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg1NjgxNA==", "bodyText": "Please use constants directly, here and throughout; extra indirection makes tests [marginally] harder to ready.", "url": "https://github.com/google/ground-android/pull/425#discussion_r409856814", "createdAt": "2020-04-16T21:23:41Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -167,137 +207,97 @@ public void setUp() {\n \n   @Test\n   public void testGetProjects() {\n-    Project project1 =\n-        Project.newBuilder()\n-            .setId(\"id 1\")\n-            .setTitle(\"project 1\")\n-            .setDescription(\"foo description\")\n-            .build();\n-    Project project2 =\n-        Project.newBuilder()\n-            .setId(\"id 2\")\n-            .setTitle(\"project 2\")\n-            .setDescription(\"foo description 2\")\n-            .build();\n-    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n-    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n-    localDataStore\n-        .getProjects()\n-        .test()\n-        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());\n+    Project project = TEST_PROJECT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbcfe556d9d7c343cf2ac9f95d7d01dee76089a7"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDY4NTg4OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToyNDoyM1rOGG3smQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToyNDoyM1rOGG3smQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg1NzE3Nw==", "bodyText": "Please use blocking* instead of subscribe here and throughout.", "url": "https://github.com/google/ground-android/pull/425#discussion_r409857177", "createdAt": "2020-04-16T21:24:23Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -167,137 +207,97 @@ public void setUp() {\n \n   @Test\n   public void testGetProjects() {\n-    Project project1 =\n-        Project.newBuilder()\n-            .setId(\"id 1\")\n-            .setTitle(\"project 1\")\n-            .setDescription(\"foo description\")\n-            .build();\n-    Project project2 =\n-        Project.newBuilder()\n-            .setId(\"id 2\")\n-            .setTitle(\"project 2\")\n-            .setDescription(\"foo description 2\")\n-            .build();\n-    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n-    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n-    localDataStore\n-        .getProjects()\n-        .test()\n-        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());\n+    Project project = TEST_PROJECT;\n+    localDataStore.insertOrUpdateProject(project).subscribe();\n+    localDataStore.getProjects().test().assertValue(ImmutableList.of(project));\n   }\n \n   @Test\n   public void testGetProjectById() {\n-    Project project = createTestProject();\n-    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    Project project = TEST_PROJECT;\n+    localDataStore.insertOrUpdateProject(project).subscribe();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbcfe556d9d7c343cf2ac9f95d7d01dee76089a7"}, "originalPosition": 263}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDY5NzMxOnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToyODoxM1rOGG3zjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODoxNDowNlrOGHEU4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg1ODk1Nw==", "bodyText": "Can this entire block be replaced with:\n   localDataStore.getFeature(TEST_PROJECT, mutation.getFeatureId()).test().assertValue(TEST_FEATURE);\n\n?", "url": "https://github.com/google/ground-android/pull/425#discussion_r409858957", "createdAt": "2020-04-16T21:28:13Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -167,137 +207,97 @@ public void setUp() {\n \n   @Test\n   public void testGetProjects() {\n-    Project project1 =\n-        Project.newBuilder()\n-            .setId(\"id 1\")\n-            .setTitle(\"project 1\")\n-            .setDescription(\"foo description\")\n-            .build();\n-    Project project2 =\n-        Project.newBuilder()\n-            .setId(\"id 2\")\n-            .setTitle(\"project 2\")\n-            .setDescription(\"foo description 2\")\n-            .build();\n-    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n-    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n-    localDataStore\n-        .getProjects()\n-        .test()\n-        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());\n+    Project project = TEST_PROJECT;\n+    localDataStore.insertOrUpdateProject(project).subscribe();\n+    localDataStore.getProjects().test().assertValue(ImmutableList.of(project));\n   }\n \n   @Test\n   public void testGetProjectById() {\n-    Project project = createTestProject();\n-    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    Project project = TEST_PROJECT;\n+    localDataStore.insertOrUpdateProject(project).subscribe();\n     localDataStore.getProjectById(project.getId()).test().assertValue(project);\n   }\n \n   @Test\n   public void testDeleteProject() {\n-    Project project = createTestProject();\n-    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    Project project = TEST_PROJECT;\n+    localDataStore.insertOrUpdateProject(project).subscribe();\n     localDataStore.deleteProject(project).test().assertComplete();\n     localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n   }\n \n   @Test\n   public void testGetUser() {\n-    User user = createTestUser();\n-    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+    User user = TEST_USER;\n+    localDataStore.insertOrUpdateUser(user).subscribe();\n     localDataStore.getUser(user.getId()).test().assertValue(user);\n   }\n \n   @Test\n   public void testApplyAndEnqueue_featureMutation() {\n-    User user = createTestUser();\n-    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n-\n-    Project project = createTestProject();\n-    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.insertOrUpdateUser(TEST_USER).subscribe();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).subscribe();\n \n-    Layer layer = project.getLayers().get(0);\n-    FeatureMutation mutation =\n-        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    FeatureMutation mutation = TEST_FEATURE_MUTATION;\n     localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n \n-    ImmutableList<Mutation> savedMutations =\n-        localDataStore.getPendingMutations(mutation.getFeatureId()).blockingGet();\n-    Assert.assertEquals(1, savedMutations.size());\n-\n     // assert that mutation is saved to local database\n-    FeatureMutation savedMutation = (FeatureMutation) savedMutations.get(0);\n-    Assert.assertEquals(mutation.getNewLocation(), savedMutation.getNewLocation());\n-    Assert.assertEquals(mutation.getType(), savedMutation.getType());\n-    Assert.assertEquals(mutation.getUserId(), savedMutation.getUserId());\n-    Assert.assertEquals(mutation.getProjectId(), savedMutation.getProjectId());\n-    Assert.assertEquals(mutation.getFeatureId(), savedMutation.getFeatureId());\n-    Assert.assertEquals(mutation.getLayerId(), savedMutation.getLayerId());\n-    Assert.assertEquals(mutation.getClientTimestamp(), savedMutation.getClientTimestamp());\n-    Assert.assertEquals(0, savedMutation.getRetryCount());\n-    Assert.assertNull(savedMutation.getLastError());\n+    localDataStore\n+        .getPendingMutations(mutation.getFeatureId())\n+        .test()\n+        .assertValue(ImmutableList.of(mutation));\n \n     // assert feature is saved to local database\n-    Feature feature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+    Feature feature =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbcfe556d9d7c343cf2ac9f95d7d01dee76089a7"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2NDA5Ng==", "bodyText": "That would require mocking a static method in AuditInfo. For that power mock can be used. https://github.com/robolectric/robolectric/wiki/Using-PowerMock\nBut I didn't have any success with that.", "url": "https://github.com/google/ground-android/pull/425#discussion_r410064096", "createdAt": "2020-04-17T08:14:06Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -167,137 +207,97 @@ public void setUp() {\n \n   @Test\n   public void testGetProjects() {\n-    Project project1 =\n-        Project.newBuilder()\n-            .setId(\"id 1\")\n-            .setTitle(\"project 1\")\n-            .setDescription(\"foo description\")\n-            .build();\n-    Project project2 =\n-        Project.newBuilder()\n-            .setId(\"id 2\")\n-            .setTitle(\"project 2\")\n-            .setDescription(\"foo description 2\")\n-            .build();\n-    localDataStore.insertOrUpdateProject(project1).test().assertComplete();\n-    localDataStore.insertOrUpdateProject(project2).test().assertComplete();\n-    localDataStore\n-        .getProjects()\n-        .test()\n-        .assertValue(ImmutableList.<Project>builder().add(project1, project2).build());\n+    Project project = TEST_PROJECT;\n+    localDataStore.insertOrUpdateProject(project).subscribe();\n+    localDataStore.getProjects().test().assertValue(ImmutableList.of(project));\n   }\n \n   @Test\n   public void testGetProjectById() {\n-    Project project = createTestProject();\n-    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    Project project = TEST_PROJECT;\n+    localDataStore.insertOrUpdateProject(project).subscribe();\n     localDataStore.getProjectById(project.getId()).test().assertValue(project);\n   }\n \n   @Test\n   public void testDeleteProject() {\n-    Project project = createTestProject();\n-    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    Project project = TEST_PROJECT;\n+    localDataStore.insertOrUpdateProject(project).subscribe();\n     localDataStore.deleteProject(project).test().assertComplete();\n     localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n   }\n \n   @Test\n   public void testGetUser() {\n-    User user = createTestUser();\n-    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n+    User user = TEST_USER;\n+    localDataStore.insertOrUpdateUser(user).subscribe();\n     localDataStore.getUser(user.getId()).test().assertValue(user);\n   }\n \n   @Test\n   public void testApplyAndEnqueue_featureMutation() {\n-    User user = createTestUser();\n-    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n-\n-    Project project = createTestProject();\n-    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n+    localDataStore.insertOrUpdateUser(TEST_USER).subscribe();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).subscribe();\n \n-    Layer layer = project.getLayers().get(0);\n-    FeatureMutation mutation =\n-        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n+    FeatureMutation mutation = TEST_FEATURE_MUTATION;\n     localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n \n-    ImmutableList<Mutation> savedMutations =\n-        localDataStore.getPendingMutations(mutation.getFeatureId()).blockingGet();\n-    Assert.assertEquals(1, savedMutations.size());\n-\n     // assert that mutation is saved to local database\n-    FeatureMutation savedMutation = (FeatureMutation) savedMutations.get(0);\n-    Assert.assertEquals(mutation.getNewLocation(), savedMutation.getNewLocation());\n-    Assert.assertEquals(mutation.getType(), savedMutation.getType());\n-    Assert.assertEquals(mutation.getUserId(), savedMutation.getUserId());\n-    Assert.assertEquals(mutation.getProjectId(), savedMutation.getProjectId());\n-    Assert.assertEquals(mutation.getFeatureId(), savedMutation.getFeatureId());\n-    Assert.assertEquals(mutation.getLayerId(), savedMutation.getLayerId());\n-    Assert.assertEquals(mutation.getClientTimestamp(), savedMutation.getClientTimestamp());\n-    Assert.assertEquals(0, savedMutation.getRetryCount());\n-    Assert.assertNull(savedMutation.getLastError());\n+    localDataStore\n+        .getPendingMutations(mutation.getFeatureId())\n+        .test()\n+        .assertValue(ImmutableList.of(mutation));\n \n     // assert feature is saved to local database\n-    Feature feature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+    Feature feature =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg1ODk1Nw=="}, "originalCommit": {"oid": "fbcfe556d9d7c343cf2ac9f95d7d01dee76089a7"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDcwNDE3OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTozMDozMVrOGG331A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTozMDozMVrOGG331A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg2MDA1Mg==", "bodyText": "You probably will also want to assertThat(mutation).isInstanceOf(ObservationMutation.class)", "url": "https://github.com/google/ground-android/pull/425#discussion_r409860052", "createdAt": "2020-04-16T21:30:31Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -352,136 +341,75 @@ public void testMergeFeature() {\n     Feature newFeature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n     Assert.assertEquals(mutation.getFeatureId(), newFeature.getId());\n     Assert.assertEquals(project, newFeature.getProject());\n-    Assert.assertEquals(layer.getItemLabel(), newFeature.getTitle());\n-    Assert.assertEquals(layer, newFeature.getLayer());\n+    Assert.assertEquals(TEST_LAYER.getItemLabel(), newFeature.getTitle());\n+    Assert.assertEquals(TEST_LAYER, newFeature.getLayer());\n     Assert.assertNull(newFeature.getCustomId());\n     Assert.assertNull(newFeature.getCaption());\n     Assert.assertEquals(point, newFeature.getPoint());\n-    Assert.assertEquals(user, newFeature.getCreated().getUser());\n-    Assert.assertEquals(user, newFeature.getLastModified().getUser());\n+    Assert.assertEquals(TEST_USER, newFeature.getCreated().getUser());\n+    Assert.assertEquals(TEST_USER, newFeature.getLastModified().getUser());\n   }\n \n   @Test\n   public void testApplyAndEnqueue_observationMutation() {\n-    User user = createTestUser();\n-    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n-\n-    Project project = createTestProject();\n-    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n-\n-    Layer layer = project.getLayers().get(0);\n-    FeatureMutation featureMutation =\n-        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n-    localDataStore.applyAndEnqueue(featureMutation).test().assertComplete();\n-\n-    ObservationMutation mutation =\n-        createTestObservationMutation(\n-            project.getId(),\n-            featureMutation.getFeatureId(),\n-            layer.getId(),\n-            layer.getForm().get().getId(),\n-            user.getId());\n+    localDataStore.insertOrUpdateUser(TEST_USER).subscribe();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).subscribe();\n+    localDataStore.applyAndEnqueue(TEST_FEATURE_MUTATION).subscribe();\n+\n+    ObservationMutation mutation = TEST_OBSERVATION_MUTATION;\n     localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n \n     ImmutableList<Mutation> savedMutations =\n         localDataStore.getPendingMutations(mutation.getFeatureId()).blockingGet();\n     Assert.assertEquals(2, savedMutations.size());\n-\n     // ignoring the first item, which is a FeatureMutation. Already tested separately.\n-    ObservationMutation savedMutation = (ObservationMutation) savedMutations.get(1);\n-    Assert.assertEquals(mutation.getResponseDeltas(), savedMutation.getResponseDeltas());\n-    Assert.assertEquals(mutation.getType(), savedMutation.getType());\n-    Assert.assertEquals(mutation.getUserId(), savedMutation.getUserId());\n-    Assert.assertEquals(mutation.getProjectId(), savedMutation.getProjectId());\n-    Assert.assertEquals(mutation.getFeatureId(), savedMutation.getFeatureId());\n-    Assert.assertEquals(layer.getId(), savedMutation.getLayerId());\n-    Assert.assertEquals(mutation.getClientTimestamp(), savedMutation.getClientTimestamp());\n-    Assert.assertEquals(0, savedMutation.getRetryCount());\n-    Assert.assertNull(savedMutation.getLastError());\n+    assertObservationMutation(mutation, (ObservationMutation) savedMutations.get(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbcfe556d9d7c343cf2ac9f95d7d01dee76089a7"}, "originalPosition": 512}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDcwNzYyOnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTozMTo0NlrOGG36BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTozMTo0NlrOGG36BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg2MDYxMw==", "bodyText": "Please replace secondary assertions (i.e. those that don't test the behavior in question) with blocking*(). If those code paths don't already have their own tests, please be sure to add them.", "url": "https://github.com/google/ground-android/pull/425#discussion_r409860613", "createdAt": "2020-04-16T21:31:46Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -352,136 +341,75 @@ public void testMergeFeature() {\n     Feature newFeature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n     Assert.assertEquals(mutation.getFeatureId(), newFeature.getId());\n     Assert.assertEquals(project, newFeature.getProject());\n-    Assert.assertEquals(layer.getItemLabel(), newFeature.getTitle());\n-    Assert.assertEquals(layer, newFeature.getLayer());\n+    Assert.assertEquals(TEST_LAYER.getItemLabel(), newFeature.getTitle());\n+    Assert.assertEquals(TEST_LAYER, newFeature.getLayer());\n     Assert.assertNull(newFeature.getCustomId());\n     Assert.assertNull(newFeature.getCaption());\n     Assert.assertEquals(point, newFeature.getPoint());\n-    Assert.assertEquals(user, newFeature.getCreated().getUser());\n-    Assert.assertEquals(user, newFeature.getLastModified().getUser());\n+    Assert.assertEquals(TEST_USER, newFeature.getCreated().getUser());\n+    Assert.assertEquals(TEST_USER, newFeature.getLastModified().getUser());\n   }\n \n   @Test\n   public void testApplyAndEnqueue_observationMutation() {\n-    User user = createTestUser();\n-    localDataStore.insertOrUpdateUser(user).test().assertComplete();\n-\n-    Project project = createTestProject();\n-    localDataStore.insertOrUpdateProject(project).test().assertComplete();\n-\n-    Layer layer = project.getLayers().get(0);\n-    FeatureMutation featureMutation =\n-        createTestFeatureMutation(user.getId(), project.getId(), layer.getId());\n-    localDataStore.applyAndEnqueue(featureMutation).test().assertComplete();\n-\n-    ObservationMutation mutation =\n-        createTestObservationMutation(\n-            project.getId(),\n-            featureMutation.getFeatureId(),\n-            layer.getId(),\n-            layer.getForm().get().getId(),\n-            user.getId());\n+    localDataStore.insertOrUpdateUser(TEST_USER).subscribe();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).subscribe();\n+    localDataStore.applyAndEnqueue(TEST_FEATURE_MUTATION).subscribe();\n+\n+    ObservationMutation mutation = TEST_OBSERVATION_MUTATION;\n     localDataStore.applyAndEnqueue(mutation).test().assertComplete();\n \n     ImmutableList<Mutation> savedMutations =\n         localDataStore.getPendingMutations(mutation.getFeatureId()).blockingGet();\n     Assert.assertEquals(2, savedMutations.size());\n-\n     // ignoring the first item, which is a FeatureMutation. Already tested separately.\n-    ObservationMutation savedMutation = (ObservationMutation) savedMutations.get(1);\n-    Assert.assertEquals(mutation.getResponseDeltas(), savedMutation.getResponseDeltas());\n-    Assert.assertEquals(mutation.getType(), savedMutation.getType());\n-    Assert.assertEquals(mutation.getUserId(), savedMutation.getUserId());\n-    Assert.assertEquals(mutation.getProjectId(), savedMutation.getProjectId());\n-    Assert.assertEquals(mutation.getFeatureId(), savedMutation.getFeatureId());\n-    Assert.assertEquals(layer.getId(), savedMutation.getLayerId());\n-    Assert.assertEquals(mutation.getClientTimestamp(), savedMutation.getClientTimestamp());\n-    Assert.assertEquals(0, savedMutation.getRetryCount());\n-    Assert.assertNull(savedMutation.getLastError());\n+    assertObservationMutation(mutation, (ObservationMutation) savedMutations.get(1));\n \n     // check if the observation was saved properly to local database\n-    Feature feature = localDataStore.getFeature(project, mutation.getFeatureId()).blockingGet();\n+    Feature feature =\n+        localDataStore.getFeature(TEST_PROJECT, mutation.getFeatureId()).blockingGet();\n     Observation observation =\n         localDataStore.getObservation(feature, mutation.getObservationId()).blockingGet();\n-    Assert.assertEquals(mutation.getObservationId(), observation.getId());\n-    Assert.assertEquals(user, observation.getCreated().getUser());\n-    Assert.assertEquals(feature, observation.getFeature());\n-    Assert.assertEquals(layer.getForm().get(), observation.getForm());\n-    Assert.assertEquals(project, observation.getProject());\n-    Assert.assertEquals(user, observation.getLastModified().getUser());\n-    MatcherAssert.assertThat(\n-        ResponseMap.builder().applyDeltas(mutation.getResponseDeltas()).build(),\n-        samePropertyValuesAs(observation.getResponses()));\n+    assertObservation(mutation, observation);\n \n     // now update the inserted observation with new responses\n     ImmutableList<ResponseDelta> deltas =\n-        ImmutableList.<ResponseDelta>builder()\n-            .add(\n-                ResponseDelta.builder()\n-                    .setFieldId(\"really new field\")\n-                    .setNewResponse(TextResponse.fromString(\"value for the really new field\"))\n-                    .build())\n-            .build();\n+        ImmutableList.of(\n+            ResponseDelta.builder()\n+                .setFieldId(\"really new field\")\n+                .setNewResponse(TextResponse.fromString(\"value for the really new field\"))\n+                .build());\n     mutation = mutation.toBuilder().setResponseDeltas(deltas).setType(Mutation.Type.UPDATE).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbcfe556d9d7c343cf2ac9f95d7d01dee76089a7"}, "originalPosition": 545}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzEzNzM1OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyMToxN1rOGH-WRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyMToxN1rOGH-WRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNDcyNQ==", "bodyText": "Naming nit: assert that observation is what? assertEquivalent?", "url": "https://github.com/google/ground-android/pull/425#discussion_r411014725", "createdAt": "2020-04-19T23:21:17Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_PENDING_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_DOWNLOADED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_FAILED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static void assertEqualsIgnoreId(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    assertThat(expected).isEqualTo(actual);\n+  }\n+\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761beb1cb735a763ac3b42a577be73b8274f2cd6"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzEzNzg3OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyMTo0N1rOGH-Whw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzo0ODoxNVrOGJQv6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNDc5MQ==", "bodyText": "Seems a bit surprising that this method would compare to constant values - should we be looking instead at the user, form, project in the mutation instead?", "url": "https://github.com/google/ground-android/pull/425#discussion_r411014791", "createdAt": "2020-04-19T23:21:47Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_PENDING_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_DOWNLOADED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_FAILED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static void assertEqualsIgnoreId(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    assertThat(expected).isEqualTo(actual);\n+  }\n+\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {\n+    assertThat(mutation.getObservationId()).isEqualTo(observation.getId());\n+    assertThat(mutation.getFeatureId()).isEqualTo(observation.getFeature().getId());\n+    assertThat(TEST_USER).isEqualTo(observation.getCreated().getUser());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761beb1cb735a763ac3b42a577be73b8274f2cd6"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM2NDc3Nw==", "bodyText": "makes sense. Removing them", "url": "https://github.com/google/ground-android/pull/425#discussion_r412364777", "createdAt": "2020-04-21T17:48:15Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_PENDING_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_DOWNLOADED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_FAILED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static void assertEqualsIgnoreId(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    assertThat(expected).isEqualTo(actual);\n+  }\n+\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {\n+    assertThat(mutation.getObservationId()).isEqualTo(observation.getId());\n+    assertThat(mutation.getFeatureId()).isEqualTo(observation.getFeature().getId());\n+    assertThat(TEST_USER).isEqualTo(observation.getCreated().getUser());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNDc5MQ=="}, "originalCommit": {"oid": "761beb1cb735a763ac3b42a577be73b8274f2cd6"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzEzOTA3OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyMjozNFrOGH-XDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyMjozNFrOGH-XDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNDkyNg==", "bodyText": "Same here - the name seems to be missing what is actually being asserted (i.e. or it seems to imply it's just checking that the supplied value is a feature)", "url": "https://github.com/google/ground-android/pull/425#discussion_r411014926", "createdAt": "2020-04-19T23:22:34Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_PENDING_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_DOWNLOADED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_FAILED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static void assertEqualsIgnoreId(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    assertThat(expected).isEqualTo(actual);\n+  }\n+\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {\n+    assertThat(mutation.getObservationId()).isEqualTo(observation.getId());\n+    assertThat(mutation.getFeatureId()).isEqualTo(observation.getFeature().getId());\n+    assertThat(TEST_USER).isEqualTo(observation.getCreated().getUser());\n+    assertThat(TEST_FORM).isEqualTo(observation.getForm());\n+    assertThat(TEST_PROJECT).isEqualTo(observation.getProject());\n+    assertThat(TEST_USER).isEqualTo(observation.getLastModified().getUser());\n+    MatcherAssert.assertThat(\n+        ResponseMap.builder().applyDeltas(mutation.getResponseDeltas()).build(),\n+        samePropertyValuesAs(observation.getResponses()));\n+  }\n+\n+  private static void assertFeature(String featureId, Point point, Feature feature) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761beb1cb735a763ac3b42a577be73b8274f2cd6"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzEzOTUzOnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyMjo1MFrOGH-XQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyMjo1MFrOGH-XQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNDk3Nw==", "bodyText": "Same comment here re constants.", "url": "https://github.com/google/ground-android/pull/425#discussion_r411014977", "createdAt": "2020-04-19T23:22:50Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_PENDING_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_DOWNLOADED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_FAILED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static void assertEqualsIgnoreId(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    assertThat(expected).isEqualTo(actual);\n+  }\n+\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {\n+    assertThat(mutation.getObservationId()).isEqualTo(observation.getId());\n+    assertThat(mutation.getFeatureId()).isEqualTo(observation.getFeature().getId());\n+    assertThat(TEST_USER).isEqualTo(observation.getCreated().getUser());\n+    assertThat(TEST_FORM).isEqualTo(observation.getForm());\n+    assertThat(TEST_PROJECT).isEqualTo(observation.getProject());\n+    assertThat(TEST_USER).isEqualTo(observation.getLastModified().getUser());\n+    MatcherAssert.assertThat(\n+        ResponseMap.builder().applyDeltas(mutation.getResponseDeltas()).build(),\n+        samePropertyValuesAs(observation.getResponses()));\n+  }\n+\n+  private static void assertFeature(String featureId, Point point, Feature feature) {\n+    assertThat(featureId).isEqualTo(feature.getId());\n+    assertThat(TEST_PROJECT).isEqualTo(feature.getProject());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761beb1cb735a763ac3b42a577be73b8274f2cd6"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzE0MjQxOnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyNDoxMVrOGH-YdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyNDoxMVrOGH-YdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNTI4NQ==", "bodyText": "In testDeleteProject we checked that the project was actually deleted. Should we do the same here for user insertion? The method could then be called testInsertAndGetUser and the next method deleted.", "url": "https://github.com/google/ground-android/pull/425#discussion_r411015285", "createdAt": "2020-04-19T23:24:11Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_PENDING_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_DOWNLOADED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_FAILED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static void assertEqualsIgnoreId(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    assertThat(expected).isEqualTo(actual);\n+  }\n+\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {\n+    assertThat(mutation.getObservationId()).isEqualTo(observation.getId());\n+    assertThat(mutation.getFeatureId()).isEqualTo(observation.getFeature().getId());\n+    assertThat(TEST_USER).isEqualTo(observation.getCreated().getUser());\n+    assertThat(TEST_FORM).isEqualTo(observation.getForm());\n+    assertThat(TEST_PROJECT).isEqualTo(observation.getProject());\n+    assertThat(TEST_USER).isEqualTo(observation.getLastModified().getUser());\n+    MatcherAssert.assertThat(\n+        ResponseMap.builder().applyDeltas(mutation.getResponseDeltas()).build(),\n+        samePropertyValuesAs(observation.getResponses()));\n+  }\n+\n+  private static void assertFeature(String featureId, Point point, Feature feature) {\n+    assertThat(featureId).isEqualTo(feature.getId());\n+    assertThat(TEST_PROJECT).isEqualTo(feature.getProject());\n+    assertThat(TEST_LAYER.getItemLabel()).isEqualTo(feature.getTitle());\n+    assertThat(TEST_LAYER).isEqualTo(feature.getLayer());\n+    assertThat(feature.getCustomId()).isNull();\n+    assertThat(feature.getCaption()).isNull();\n+    assertThat(point).isEqualTo(feature.getPoint());\n+    assertThat(TEST_USER).isEqualTo(feature.getCreated().getUser());\n+    assertThat(TEST_USER).isEqualTo(feature.getLastModified().getUser());\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testInsertProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjects().test().assertValue(ImmutableList.of(TEST_PROJECT));\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjectById(\"project id\").test().assertValue(TEST_PROJECT);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.deleteProject(TEST_PROJECT).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testInsertUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).test().assertComplete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761beb1cb735a763ac3b42a577be73b8274f2cd6"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzE0OTI5OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyODo0MlrOGH-bkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyODo0MlrOGH-bkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNjA4MQ==", "bodyText": "Since we check this at the end of the method, do we also need to check it here?", "url": "https://github.com/google/ground-android/pull/425#discussion_r411016081", "createdAt": "2020-04-19T23:28:42Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_PENDING_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_DOWNLOADED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_FAILED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static void assertEqualsIgnoreId(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    assertThat(expected).isEqualTo(actual);\n+  }\n+\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {\n+    assertThat(mutation.getObservationId()).isEqualTo(observation.getId());\n+    assertThat(mutation.getFeatureId()).isEqualTo(observation.getFeature().getId());\n+    assertThat(TEST_USER).isEqualTo(observation.getCreated().getUser());\n+    assertThat(TEST_FORM).isEqualTo(observation.getForm());\n+    assertThat(TEST_PROJECT).isEqualTo(observation.getProject());\n+    assertThat(TEST_USER).isEqualTo(observation.getLastModified().getUser());\n+    MatcherAssert.assertThat(\n+        ResponseMap.builder().applyDeltas(mutation.getResponseDeltas()).build(),\n+        samePropertyValuesAs(observation.getResponses()));\n+  }\n+\n+  private static void assertFeature(String featureId, Point point, Feature feature) {\n+    assertThat(featureId).isEqualTo(feature.getId());\n+    assertThat(TEST_PROJECT).isEqualTo(feature.getProject());\n+    assertThat(TEST_LAYER.getItemLabel()).isEqualTo(feature.getTitle());\n+    assertThat(TEST_LAYER).isEqualTo(feature.getLayer());\n+    assertThat(feature.getCustomId()).isNull();\n+    assertThat(feature.getCaption()).isNull();\n+    assertThat(point).isEqualTo(feature.getPoint());\n+    assertThat(TEST_USER).isEqualTo(feature.getCreated().getUser());\n+    assertThat(TEST_USER).isEqualTo(feature.getLastModified().getUser());\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testInsertProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjects().test().assertValue(ImmutableList.of(TEST_PROJECT));\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjectById(\"project id\").test().assertValue(TEST_PROJECT);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.deleteProject(TEST_PROJECT).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testInsertUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.getUser(\"user id\").test().assertValue(TEST_USER);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    localDataStore.applyAndEnqueue(TEST_FEATURE_MUTATION).test().assertComplete();\n+\n+    // assert that mutation is saved to local database\n+    localDataStore\n+        .getPendingMutations(\"feature id\")\n+        .test()\n+        .assertValue(ImmutableList.of(TEST_FEATURE_MUTATION));\n+\n+    // assert feature is saved to local database\n+    Feature feature = localDataStore.getFeature(TEST_PROJECT, \"feature id\").blockingGet();\n+    assertFeature(\"feature id\", TEST_POINT, feature);\n+  }\n+\n+  @Test\n+  public void testGetFeaturesOnceAndStream() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    TestSubscriber<ImmutableSet<Feature>> subscriber =\n+        localDataStore.getFeaturesOnceAndStream(TEST_PROJECT).test();\n+\n+    subscriber.assertValueCount(1);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761beb1cb735a763ac3b42a577be73b8274f2cd6"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzE0OTc5OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyODo1NlrOGH-byg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyODo1NlrOGH-byg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNjEzOA==", "bodyText": "Please inline this variable since it always contains a constant.", "url": "https://github.com/google/ground-android/pull/425#discussion_r411016138", "createdAt": "2020-04-19T23:28:56Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_PENDING_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_DOWNLOADED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_FAILED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static void assertEqualsIgnoreId(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    assertThat(expected).isEqualTo(actual);\n+  }\n+\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {\n+    assertThat(mutation.getObservationId()).isEqualTo(observation.getId());\n+    assertThat(mutation.getFeatureId()).isEqualTo(observation.getFeature().getId());\n+    assertThat(TEST_USER).isEqualTo(observation.getCreated().getUser());\n+    assertThat(TEST_FORM).isEqualTo(observation.getForm());\n+    assertThat(TEST_PROJECT).isEqualTo(observation.getProject());\n+    assertThat(TEST_USER).isEqualTo(observation.getLastModified().getUser());\n+    MatcherAssert.assertThat(\n+        ResponseMap.builder().applyDeltas(mutation.getResponseDeltas()).build(),\n+        samePropertyValuesAs(observation.getResponses()));\n+  }\n+\n+  private static void assertFeature(String featureId, Point point, Feature feature) {\n+    assertThat(featureId).isEqualTo(feature.getId());\n+    assertThat(TEST_PROJECT).isEqualTo(feature.getProject());\n+    assertThat(TEST_LAYER.getItemLabel()).isEqualTo(feature.getTitle());\n+    assertThat(TEST_LAYER).isEqualTo(feature.getLayer());\n+    assertThat(feature.getCustomId()).isNull();\n+    assertThat(feature.getCaption()).isNull();\n+    assertThat(point).isEqualTo(feature.getPoint());\n+    assertThat(TEST_USER).isEqualTo(feature.getCreated().getUser());\n+    assertThat(TEST_USER).isEqualTo(feature.getLastModified().getUser());\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testInsertProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjects().test().assertValue(ImmutableList.of(TEST_PROJECT));\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjectById(\"project id\").test().assertValue(TEST_PROJECT);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.deleteProject(TEST_PROJECT).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testInsertUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.getUser(\"user id\").test().assertValue(TEST_USER);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    localDataStore.applyAndEnqueue(TEST_FEATURE_MUTATION).test().assertComplete();\n+\n+    // assert that mutation is saved to local database\n+    localDataStore\n+        .getPendingMutations(\"feature id\")\n+        .test()\n+        .assertValue(ImmutableList.of(TEST_FEATURE_MUTATION));\n+\n+    // assert feature is saved to local database\n+    Feature feature = localDataStore.getFeature(TEST_PROJECT, \"feature id\").blockingGet();\n+    assertFeature(\"feature id\", TEST_POINT, feature);\n+  }\n+\n+  @Test\n+  public void testGetFeaturesOnceAndStream() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    TestSubscriber<ImmutableSet<Feature>> subscriber =\n+        localDataStore.getFeaturesOnceAndStream(TEST_PROJECT).test();\n+\n+    subscriber.assertValueCount(1);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+\n+    FeatureMutation mutation = TEST_FEATURE_MUTATION;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761beb1cb735a763ac3b42a577be73b8274f2cd6"}, "originalPosition": 284}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzE1MDE0OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyOToxOVrOGH-b_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyOToxOVrOGH-b_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNjE4OQ==", "bodyText": "We could also use subscriber.assertValues() here instead of two assertValueAt calls.", "url": "https://github.com/google/ground-android/pull/425#discussion_r411016189", "createdAt": "2020-04-19T23:29:19Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_PENDING_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_DOWNLOADED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_FAILED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static void assertEqualsIgnoreId(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    assertThat(expected).isEqualTo(actual);\n+  }\n+\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {\n+    assertThat(mutation.getObservationId()).isEqualTo(observation.getId());\n+    assertThat(mutation.getFeatureId()).isEqualTo(observation.getFeature().getId());\n+    assertThat(TEST_USER).isEqualTo(observation.getCreated().getUser());\n+    assertThat(TEST_FORM).isEqualTo(observation.getForm());\n+    assertThat(TEST_PROJECT).isEqualTo(observation.getProject());\n+    assertThat(TEST_USER).isEqualTo(observation.getLastModified().getUser());\n+    MatcherAssert.assertThat(\n+        ResponseMap.builder().applyDeltas(mutation.getResponseDeltas()).build(),\n+        samePropertyValuesAs(observation.getResponses()));\n+  }\n+\n+  private static void assertFeature(String featureId, Point point, Feature feature) {\n+    assertThat(featureId).isEqualTo(feature.getId());\n+    assertThat(TEST_PROJECT).isEqualTo(feature.getProject());\n+    assertThat(TEST_LAYER.getItemLabel()).isEqualTo(feature.getTitle());\n+    assertThat(TEST_LAYER).isEqualTo(feature.getLayer());\n+    assertThat(feature.getCustomId()).isNull();\n+    assertThat(feature.getCaption()).isNull();\n+    assertThat(point).isEqualTo(feature.getPoint());\n+    assertThat(TEST_USER).isEqualTo(feature.getCreated().getUser());\n+    assertThat(TEST_USER).isEqualTo(feature.getLastModified().getUser());\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testInsertProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjects().test().assertValue(ImmutableList.of(TEST_PROJECT));\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjectById(\"project id\").test().assertValue(TEST_PROJECT);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.deleteProject(TEST_PROJECT).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testInsertUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.getUser(\"user id\").test().assertValue(TEST_USER);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    localDataStore.applyAndEnqueue(TEST_FEATURE_MUTATION).test().assertComplete();\n+\n+    // assert that mutation is saved to local database\n+    localDataStore\n+        .getPendingMutations(\"feature id\")\n+        .test()\n+        .assertValue(ImmutableList.of(TEST_FEATURE_MUTATION));\n+\n+    // assert feature is saved to local database\n+    Feature feature = localDataStore.getFeature(TEST_PROJECT, \"feature id\").blockingGet();\n+    assertFeature(\"feature id\", TEST_POINT, feature);\n+  }\n+\n+  @Test\n+  public void testGetFeaturesOnceAndStream() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    TestSubscriber<ImmutableSet<Feature>> subscriber =\n+        localDataStore.getFeaturesOnceAndStream(TEST_PROJECT).test();\n+\n+    subscriber.assertValueCount(1);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+\n+    FeatureMutation mutation = TEST_FEATURE_MUTATION;\n+    localDataStore.applyAndEnqueue(mutation).blockingAwait();\n+\n+    Feature feature =\n+        localDataStore.getFeature(TEST_PROJECT, mutation.getFeatureId()).blockingGet();\n+\n+    subscriber.assertValueCount(2);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761beb1cb735a763ac3b42a577be73b8274f2cd6"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzE1MDMyOnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyOToyNlrOGH-cEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzoyOToyNlrOGH-cEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNjIwOA==", "bodyText": "Please inline.", "url": "https://github.com/google/ground-android/pull/425#discussion_r411016208", "createdAt": "2020-04-19T23:29:26Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_PENDING_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_DOWNLOADED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_FAILED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static void assertEqualsIgnoreId(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    assertThat(expected).isEqualTo(actual);\n+  }\n+\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {\n+    assertThat(mutation.getObservationId()).isEqualTo(observation.getId());\n+    assertThat(mutation.getFeatureId()).isEqualTo(observation.getFeature().getId());\n+    assertThat(TEST_USER).isEqualTo(observation.getCreated().getUser());\n+    assertThat(TEST_FORM).isEqualTo(observation.getForm());\n+    assertThat(TEST_PROJECT).isEqualTo(observation.getProject());\n+    assertThat(TEST_USER).isEqualTo(observation.getLastModified().getUser());\n+    MatcherAssert.assertThat(\n+        ResponseMap.builder().applyDeltas(mutation.getResponseDeltas()).build(),\n+        samePropertyValuesAs(observation.getResponses()));\n+  }\n+\n+  private static void assertFeature(String featureId, Point point, Feature feature) {\n+    assertThat(featureId).isEqualTo(feature.getId());\n+    assertThat(TEST_PROJECT).isEqualTo(feature.getProject());\n+    assertThat(TEST_LAYER.getItemLabel()).isEqualTo(feature.getTitle());\n+    assertThat(TEST_LAYER).isEqualTo(feature.getLayer());\n+    assertThat(feature.getCustomId()).isNull();\n+    assertThat(feature.getCaption()).isNull();\n+    assertThat(point).isEqualTo(feature.getPoint());\n+    assertThat(TEST_USER).isEqualTo(feature.getCreated().getUser());\n+    assertThat(TEST_USER).isEqualTo(feature.getLastModified().getUser());\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testInsertProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjects().test().assertValue(ImmutableList.of(TEST_PROJECT));\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjectById(\"project id\").test().assertValue(TEST_PROJECT);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.deleteProject(TEST_PROJECT).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testInsertUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.getUser(\"user id\").test().assertValue(TEST_USER);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    localDataStore.applyAndEnqueue(TEST_FEATURE_MUTATION).test().assertComplete();\n+\n+    // assert that mutation is saved to local database\n+    localDataStore\n+        .getPendingMutations(\"feature id\")\n+        .test()\n+        .assertValue(ImmutableList.of(TEST_FEATURE_MUTATION));\n+\n+    // assert feature is saved to local database\n+    Feature feature = localDataStore.getFeature(TEST_PROJECT, \"feature id\").blockingGet();\n+    assertFeature(\"feature id\", TEST_POINT, feature);\n+  }\n+\n+  @Test\n+  public void testGetFeaturesOnceAndStream() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    TestSubscriber<ImmutableSet<Feature>> subscriber =\n+        localDataStore.getFeaturesOnceAndStream(TEST_PROJECT).test();\n+\n+    subscriber.assertValueCount(1);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+\n+    FeatureMutation mutation = TEST_FEATURE_MUTATION;\n+    localDataStore.applyAndEnqueue(mutation).blockingAwait();\n+\n+    Feature feature =\n+        localDataStore.getFeature(TEST_PROJECT, mutation.getFeatureId()).blockingGet();\n+\n+    subscriber.assertValueCount(2);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+    subscriber.assertValueAt(1, ImmutableSet.of(feature));\n+  }\n+\n+  @Test\n+  public void testUpdateMutations() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    FeatureMutation mutation = TEST_FEATURE_MUTATION;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761beb1cb735a763ac3b42a577be73b8274f2cd6"}, "originalPosition": 300}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzE1MTY1OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzozMDowOVrOGH-cqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzozMDowOVrOGH-cqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNjM2Mg==", "bodyText": "Shall we create a constant, TEST_POINT_2, for example, for use here and throughout instead? Otherwise it may seem like these values might have special meaning.\nAlso, consider creating a constructor method createTestFeatureMutation(point) that you can use for both cases.", "url": "https://github.com/google/ground-android/pull/425#discussion_r411016362", "createdAt": "2020-04-19T23:30:09Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_PENDING_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_DOWNLOADED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_FAILED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static void assertEqualsIgnoreId(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    assertThat(expected).isEqualTo(actual);\n+  }\n+\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {\n+    assertThat(mutation.getObservationId()).isEqualTo(observation.getId());\n+    assertThat(mutation.getFeatureId()).isEqualTo(observation.getFeature().getId());\n+    assertThat(TEST_USER).isEqualTo(observation.getCreated().getUser());\n+    assertThat(TEST_FORM).isEqualTo(observation.getForm());\n+    assertThat(TEST_PROJECT).isEqualTo(observation.getProject());\n+    assertThat(TEST_USER).isEqualTo(observation.getLastModified().getUser());\n+    MatcherAssert.assertThat(\n+        ResponseMap.builder().applyDeltas(mutation.getResponseDeltas()).build(),\n+        samePropertyValuesAs(observation.getResponses()));\n+  }\n+\n+  private static void assertFeature(String featureId, Point point, Feature feature) {\n+    assertThat(featureId).isEqualTo(feature.getId());\n+    assertThat(TEST_PROJECT).isEqualTo(feature.getProject());\n+    assertThat(TEST_LAYER.getItemLabel()).isEqualTo(feature.getTitle());\n+    assertThat(TEST_LAYER).isEqualTo(feature.getLayer());\n+    assertThat(feature.getCustomId()).isNull();\n+    assertThat(feature.getCaption()).isNull();\n+    assertThat(point).isEqualTo(feature.getPoint());\n+    assertThat(TEST_USER).isEqualTo(feature.getCreated().getUser());\n+    assertThat(TEST_USER).isEqualTo(feature.getLastModified().getUser());\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testInsertProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjects().test().assertValue(ImmutableList.of(TEST_PROJECT));\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjectById(\"project id\").test().assertValue(TEST_PROJECT);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.deleteProject(TEST_PROJECT).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testInsertUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.getUser(\"user id\").test().assertValue(TEST_USER);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    localDataStore.applyAndEnqueue(TEST_FEATURE_MUTATION).test().assertComplete();\n+\n+    // assert that mutation is saved to local database\n+    localDataStore\n+        .getPendingMutations(\"feature id\")\n+        .test()\n+        .assertValue(ImmutableList.of(TEST_FEATURE_MUTATION));\n+\n+    // assert feature is saved to local database\n+    Feature feature = localDataStore.getFeature(TEST_PROJECT, \"feature id\").blockingGet();\n+    assertFeature(\"feature id\", TEST_POINT, feature);\n+  }\n+\n+  @Test\n+  public void testGetFeaturesOnceAndStream() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    TestSubscriber<ImmutableSet<Feature>> subscriber =\n+        localDataStore.getFeaturesOnceAndStream(TEST_PROJECT).test();\n+\n+    subscriber.assertValueCount(1);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+\n+    FeatureMutation mutation = TEST_FEATURE_MUTATION;\n+    localDataStore.applyAndEnqueue(mutation).blockingAwait();\n+\n+    Feature feature =\n+        localDataStore.getFeature(TEST_PROJECT, mutation.getFeatureId()).blockingGet();\n+\n+    subscriber.assertValueCount(2);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+    subscriber.assertValueAt(1, ImmutableSet.of(feature));\n+  }\n+\n+  @Test\n+  public void testUpdateMutations() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    FeatureMutation mutation = TEST_FEATURE_MUTATION;\n+    localDataStore.applyAndEnqueue(mutation).blockingAwait();\n+\n+    Point newPoint = Point.newBuilder().setLatitude(51.0).setLongitude(44.0).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761beb1cb735a763ac3b42a577be73b8274f2cd6"}, "originalPosition": 303}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzE1NjgyOnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzozMzozM1rOGH-e_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzozMzozM1rOGH-e_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNjk1Ng==", "bodyText": "Please use assertThat(savedMutations).containsExactly instead of hasSize, get, isEqualTo.", "url": "https://github.com/google/ground-android/pull/425#discussion_r411016956", "createdAt": "2020-04-19T23:33:33Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_PENDING_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_DOWNLOADED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_FAILED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static void assertEqualsIgnoreId(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    assertThat(expected).isEqualTo(actual);\n+  }\n+\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {\n+    assertThat(mutation.getObservationId()).isEqualTo(observation.getId());\n+    assertThat(mutation.getFeatureId()).isEqualTo(observation.getFeature().getId());\n+    assertThat(TEST_USER).isEqualTo(observation.getCreated().getUser());\n+    assertThat(TEST_FORM).isEqualTo(observation.getForm());\n+    assertThat(TEST_PROJECT).isEqualTo(observation.getProject());\n+    assertThat(TEST_USER).isEqualTo(observation.getLastModified().getUser());\n+    MatcherAssert.assertThat(\n+        ResponseMap.builder().applyDeltas(mutation.getResponseDeltas()).build(),\n+        samePropertyValuesAs(observation.getResponses()));\n+  }\n+\n+  private static void assertFeature(String featureId, Point point, Feature feature) {\n+    assertThat(featureId).isEqualTo(feature.getId());\n+    assertThat(TEST_PROJECT).isEqualTo(feature.getProject());\n+    assertThat(TEST_LAYER.getItemLabel()).isEqualTo(feature.getTitle());\n+    assertThat(TEST_LAYER).isEqualTo(feature.getLayer());\n+    assertThat(feature.getCustomId()).isNull();\n+    assertThat(feature.getCaption()).isNull();\n+    assertThat(point).isEqualTo(feature.getPoint());\n+    assertThat(TEST_USER).isEqualTo(feature.getCreated().getUser());\n+    assertThat(TEST_USER).isEqualTo(feature.getLastModified().getUser());\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testInsertProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjects().test().assertValue(ImmutableList.of(TEST_PROJECT));\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjectById(\"project id\").test().assertValue(TEST_PROJECT);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.deleteProject(TEST_PROJECT).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testInsertUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.getUser(\"user id\").test().assertValue(TEST_USER);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    localDataStore.applyAndEnqueue(TEST_FEATURE_MUTATION).test().assertComplete();\n+\n+    // assert that mutation is saved to local database\n+    localDataStore\n+        .getPendingMutations(\"feature id\")\n+        .test()\n+        .assertValue(ImmutableList.of(TEST_FEATURE_MUTATION));\n+\n+    // assert feature is saved to local database\n+    Feature feature = localDataStore.getFeature(TEST_PROJECT, \"feature id\").blockingGet();\n+    assertFeature(\"feature id\", TEST_POINT, feature);\n+  }\n+\n+  @Test\n+  public void testGetFeaturesOnceAndStream() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    TestSubscriber<ImmutableSet<Feature>> subscriber =\n+        localDataStore.getFeaturesOnceAndStream(TEST_PROJECT).test();\n+\n+    subscriber.assertValueCount(1);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+\n+    FeatureMutation mutation = TEST_FEATURE_MUTATION;\n+    localDataStore.applyAndEnqueue(mutation).blockingAwait();\n+\n+    Feature feature =\n+        localDataStore.getFeature(TEST_PROJECT, mutation.getFeatureId()).blockingGet();\n+\n+    subscriber.assertValueCount(2);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+    subscriber.assertValueAt(1, ImmutableSet.of(feature));\n+  }\n+\n+  @Test\n+  public void testUpdateMutations() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    FeatureMutation mutation = TEST_FEATURE_MUTATION;\n+    localDataStore.applyAndEnqueue(mutation).blockingAwait();\n+\n+    Point newPoint = Point.newBuilder().setLatitude(51.0).setLongitude(44.0).build();\n+    Mutation updatedMutation =\n+        mutation.toBuilder().setNewLocation(Optional.ofNullable(newPoint)).build();\n+\n+    localDataStore.updateMutations(ImmutableList.of(updatedMutation)).test().assertComplete();\n+\n+    ImmutableList<Mutation> savedMutations =\n+        localDataStore.getPendingMutations(updatedMutation.getFeatureId()).blockingGet();\n+    assertThat(savedMutations).hasSize(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761beb1cb735a763ac3b42a577be73b8274f2cd6"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzE1ODc3OnYy", "diffSide": "RIGHT", "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzozNDozM1rOGH-f1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMzozNDozM1rOGH-f1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNzE3NA==", "bodyText": "Same here re containsExactly. I think it will also check the type for you.", "url": "https://github.com/google/ground-android/pull/425#discussion_r411017174", "createdAt": "2020-04-19T23:34:33Z", "author": {"login": "gino-m"}, "path": "gnd/src/test/java/com/google/android/gnd/persistence/local/LocalDataStoreTest.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.local;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.hamcrest.Matchers.samePropertyValuesAs;\n+\n+import androidx.arch.core.executor.testing.InstantTaskExecutorRule;\n+import com.google.android.gms.maps.model.LatLng;\n+import com.google.android.gms.maps.model.LatLngBounds;\n+import com.google.android.gnd.TestApplication;\n+import com.google.android.gnd.inject.DaggerTestComponent;\n+import com.google.android.gnd.model.Mutation;\n+import com.google.android.gnd.model.Project;\n+import com.google.android.gnd.model.User;\n+import com.google.android.gnd.model.basemap.OfflineArea;\n+import com.google.android.gnd.model.basemap.tile.Tile;\n+import com.google.android.gnd.model.basemap.tile.Tile.State;\n+import com.google.android.gnd.model.feature.Feature;\n+import com.google.android.gnd.model.feature.FeatureMutation;\n+import com.google.android.gnd.model.feature.Point;\n+import com.google.android.gnd.model.form.Element;\n+import com.google.android.gnd.model.form.Field;\n+import com.google.android.gnd.model.form.Field.Type;\n+import com.google.android.gnd.model.form.Form;\n+import com.google.android.gnd.model.form.MultipleChoice;\n+import com.google.android.gnd.model.form.MultipleChoice.Cardinality;\n+import com.google.android.gnd.model.form.Option;\n+import com.google.android.gnd.model.layer.Layer;\n+import com.google.android.gnd.model.layer.Style;\n+import com.google.android.gnd.model.observation.Observation;\n+import com.google.android.gnd.model.observation.ObservationMutation;\n+import com.google.android.gnd.model.observation.ResponseDelta;\n+import com.google.android.gnd.model.observation.ResponseMap;\n+import com.google.android.gnd.model.observation.TextResponse;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.reactivex.subscribers.TestSubscriber;\n+import java.util.AbstractCollection;\n+import java.util.Date;\n+import java8.util.Optional;\n+import javax.inject.Inject;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(application = TestApplication.class)\n+public class LocalDataStoreTest {\n+\n+  private static final User TEST_USER =\n+      User.builder().setId(\"user id\").setEmail(\"user@gmail.com\").setDisplayName(\"user 1\").build();\n+\n+  private static final MultipleChoice TEST_MULTIPLE_CHOICE =\n+      MultipleChoice.newBuilder()\n+          .setCardinality(Cardinality.SELECT_ONE)\n+          .setOptions(\n+              ImmutableList.of(\n+                  Option.newBuilder().setCode(\"a\").setLabel(\"Name\").build(),\n+                  Option.newBuilder().setCode(\"b\").setLabel(\"Age\").build()))\n+          .build();\n+\n+  private static final Field TEST_FIELD =\n+      Field.newBuilder()\n+          .setId(\"field id\")\n+          .setLabel(\"field label\")\n+          .setRequired(false)\n+          .setType(Type.MULTIPLE_CHOICE)\n+          .setMultipleChoice(TEST_MULTIPLE_CHOICE)\n+          .build();\n+\n+  private static final Form TEST_FORM =\n+      Form.newBuilder()\n+          .setId(\"form id\")\n+          .setElements(ImmutableList.of(Element.ofField(TEST_FIELD)))\n+          .build();\n+\n+  private static final Layer TEST_LAYER =\n+      Layer.newBuilder()\n+          .setId(\"layer id\")\n+          .setItemLabel(\"item label\")\n+          .setListHeading(\"heading title\")\n+          .setDefaultStyle(Style.builder().setColor(\"000\").build())\n+          .setForm(TEST_FORM)\n+          .build();\n+\n+  private static final Project TEST_PROJECT =\n+      Project.newBuilder()\n+          .setId(\"project id\")\n+          .setTitle(\"project 1\")\n+          .setDescription(\"foo description\")\n+          .putLayer(\"layer id\", TEST_LAYER)\n+          .build();\n+\n+  private static final Point TEST_POINT =\n+      Point.newBuilder().setLatitude(110.0).setLongitude(-23.1).build();\n+\n+  private static final FeatureMutation TEST_FEATURE_MUTATION =\n+      FeatureMutation.builder()\n+          .setId(1L)\n+          .setFeatureId(\"feature id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setUserId(\"user id\")\n+          .setProjectId(\"project id\")\n+          .setLayerId(\"layer id\")\n+          .setNewLocation(Optional.ofNullable(TEST_POINT))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final ObservationMutation TEST_OBSERVATION_MUTATION =\n+      ObservationMutation.builder()\n+          .setObservationId(\"observation id\")\n+          .setType(Mutation.Type.CREATE)\n+          .setProjectId(\"project id\")\n+          .setFeatureId(\"feature id\")\n+          .setLayerId(\"layer id\")\n+          .setFormId(\"form id\")\n+          .setUserId(\"user id\")\n+          .setResponseDeltas(\n+              ImmutableList.of(\n+                  ResponseDelta.builder()\n+                      .setFieldId(\"field id\")\n+                      .setNewResponse(TextResponse.fromString(\"response for field id\"))\n+                      .build()))\n+          .setClientTimestamp(new Date())\n+          .build();\n+\n+  private static final Tile TEST_PENDING_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_1\")\n+          .setState(State.PENDING)\n+          .setPath(\"some_path 1\")\n+          .setUrl(\"some_url 1\")\n+          .build();\n+\n+  private static final Tile TEST_DOWNLOADED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_2\")\n+          .setState(State.DOWNLOADED)\n+          .setPath(\"some_path 2\")\n+          .setUrl(\"some_url 2\")\n+          .build();\n+\n+  private static final Tile TEST_FAILED_TILE =\n+      Tile.newBuilder()\n+          .setId(\"id_3\")\n+          .setState(State.FAILED)\n+          .setPath(\"some_path 3\")\n+          .setUrl(\"some_url 3\")\n+          .build();\n+\n+  private static final OfflineArea TEST_OFFLINE_AREA =\n+      OfflineArea.newBuilder()\n+          .setId(\"id_1\")\n+          .setBounds(LatLngBounds.builder().include(new LatLng(0.0, 0.0)).build())\n+          .setState(OfflineArea.State.PENDING)\n+          .build();\n+\n+  // This rule makes sure that Room executes all the database operations instantly.\n+  @Rule public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();\n+\n+  @Inject LocalDataStore localDataStore;\n+\n+  private static void assertEqualsIgnoreId(\n+      ObservationMutation expected, ObservationMutation actual) {\n+    // TODO: Id is auto-assigned to ObservationMutation.\n+    //  If we try to give it while inserting, then it causes problems. Improve this behavior.\n+    //  So, copy the id from actual to expected and then compare the objects.\n+    expected = expected.toBuilder().setId(actual.getId()).build();\n+    assertThat(expected).isEqualTo(actual);\n+  }\n+\n+  private static void assertObservation(ObservationMutation mutation, Observation observation) {\n+    assertThat(mutation.getObservationId()).isEqualTo(observation.getId());\n+    assertThat(mutation.getFeatureId()).isEqualTo(observation.getFeature().getId());\n+    assertThat(TEST_USER).isEqualTo(observation.getCreated().getUser());\n+    assertThat(TEST_FORM).isEqualTo(observation.getForm());\n+    assertThat(TEST_PROJECT).isEqualTo(observation.getProject());\n+    assertThat(TEST_USER).isEqualTo(observation.getLastModified().getUser());\n+    MatcherAssert.assertThat(\n+        ResponseMap.builder().applyDeltas(mutation.getResponseDeltas()).build(),\n+        samePropertyValuesAs(observation.getResponses()));\n+  }\n+\n+  private static void assertFeature(String featureId, Point point, Feature feature) {\n+    assertThat(featureId).isEqualTo(feature.getId());\n+    assertThat(TEST_PROJECT).isEqualTo(feature.getProject());\n+    assertThat(TEST_LAYER.getItemLabel()).isEqualTo(feature.getTitle());\n+    assertThat(TEST_LAYER).isEqualTo(feature.getLayer());\n+    assertThat(feature.getCustomId()).isNull();\n+    assertThat(feature.getCaption()).isNull();\n+    assertThat(point).isEqualTo(feature.getPoint());\n+    assertThat(TEST_USER).isEqualTo(feature.getCreated().getUser());\n+    assertThat(TEST_USER).isEqualTo(feature.getLastModified().getUser());\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    DaggerTestComponent.create().inject(this);\n+  }\n+\n+  @Test\n+  public void testInsertProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetProjects() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjects().test().assertValue(ImmutableList.of(TEST_PROJECT));\n+  }\n+\n+  @Test\n+  public void testGetProjectById() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.getProjectById(\"project id\").test().assertValue(TEST_PROJECT);\n+  }\n+\n+  @Test\n+  public void testDeleteProject() {\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.deleteProject(TEST_PROJECT).test().assertComplete();\n+    localDataStore.getProjects().test().assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testInsertUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).test().assertComplete();\n+  }\n+\n+  @Test\n+  public void testGetUser() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.getUser(\"user id\").test().assertValue(TEST_USER);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_featureMutation() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    localDataStore.applyAndEnqueue(TEST_FEATURE_MUTATION).test().assertComplete();\n+\n+    // assert that mutation is saved to local database\n+    localDataStore\n+        .getPendingMutations(\"feature id\")\n+        .test()\n+        .assertValue(ImmutableList.of(TEST_FEATURE_MUTATION));\n+\n+    // assert feature is saved to local database\n+    Feature feature = localDataStore.getFeature(TEST_PROJECT, \"feature id\").blockingGet();\n+    assertFeature(\"feature id\", TEST_POINT, feature);\n+  }\n+\n+  @Test\n+  public void testGetFeaturesOnceAndStream() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    TestSubscriber<ImmutableSet<Feature>> subscriber =\n+        localDataStore.getFeaturesOnceAndStream(TEST_PROJECT).test();\n+\n+    subscriber.assertValueCount(1);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+\n+    FeatureMutation mutation = TEST_FEATURE_MUTATION;\n+    localDataStore.applyAndEnqueue(mutation).blockingAwait();\n+\n+    Feature feature =\n+        localDataStore.getFeature(TEST_PROJECT, mutation.getFeatureId()).blockingGet();\n+\n+    subscriber.assertValueCount(2);\n+    subscriber.assertValueAt(0, AbstractCollection::isEmpty);\n+    subscriber.assertValueAt(1, ImmutableSet.of(feature));\n+  }\n+\n+  @Test\n+  public void testUpdateMutations() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+\n+    FeatureMutation mutation = TEST_FEATURE_MUTATION;\n+    localDataStore.applyAndEnqueue(mutation).blockingAwait();\n+\n+    Point newPoint = Point.newBuilder().setLatitude(51.0).setLongitude(44.0).build();\n+    Mutation updatedMutation =\n+        mutation.toBuilder().setNewLocation(Optional.ofNullable(newPoint)).build();\n+\n+    localDataStore.updateMutations(ImmutableList.of(updatedMutation)).test().assertComplete();\n+\n+    ImmutableList<Mutation> savedMutations =\n+        localDataStore.getPendingMutations(updatedMutation.getFeatureId()).blockingGet();\n+    assertThat(savedMutations).hasSize(1);\n+\n+    FeatureMutation savedMutation = (FeatureMutation) savedMutations.get(0);\n+    assertThat(newPoint).isEqualTo(savedMutation.getNewLocation().get());\n+  }\n+\n+  @Test\n+  public void testRemovePendingMutation() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.applyAndEnqueue(TEST_FEATURE_MUTATION).blockingAwait();\n+\n+    localDataStore\n+        .removePendingMutations(ImmutableList.of(TEST_FEATURE_MUTATION))\n+        .test()\n+        .assertComplete();\n+\n+    localDataStore\n+        .getPendingMutations(\"feature id\")\n+        .test()\n+        .assertValue(AbstractCollection::isEmpty);\n+  }\n+\n+  @Test\n+  public void testMergeFeature() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.applyAndEnqueue(TEST_FEATURE_MUTATION).blockingAwait();\n+\n+    Feature feature = localDataStore.getFeature(TEST_PROJECT, \"feature id\").blockingGet();\n+    Point point = Point.newBuilder().setLongitude(11.0).setLatitude(33.0).build();\n+    feature = feature.toBuilder().setPoint(point).build();\n+    localDataStore.mergeFeature(feature).test().assertComplete();\n+\n+    Feature newFeature = localDataStore.getFeature(TEST_PROJECT, \"feature id\").blockingGet();\n+    assertFeature(\"feature id\", point, newFeature);\n+  }\n+\n+  @Test\n+  public void testApplyAndEnqueue_observationMutation() {\n+    localDataStore.insertOrUpdateUser(TEST_USER).blockingAwait();\n+    localDataStore.insertOrUpdateProject(TEST_PROJECT).blockingAwait();\n+    localDataStore.applyAndEnqueue(TEST_FEATURE_MUTATION).blockingAwait();\n+\n+    localDataStore.applyAndEnqueue(TEST_OBSERVATION_MUTATION).test().assertComplete();\n+\n+    ImmutableList<Mutation> savedMutations =\n+        localDataStore.getPendingMutations(\"feature id\").blockingGet();\n+    assertThat(savedMutations).hasSize(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761beb1cb735a763ac3b42a577be73b8274f2cd6"}, "originalPosition": 359}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2669, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}