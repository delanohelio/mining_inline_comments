{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMjk2NjA3", "number": 506, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMToyOToyMVrOEJnTCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTowNzo0NFrOEJtBQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NTE2NDkxOnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/LocalValueStore.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMToyOToyMVrOGqMhNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjowMDo1NFrOGskoXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg5ODQ4Ng==", "bodyText": "We might want to change this to shouldUploadMediaOverUnmeteredConnectionOnly. Whilst most Wi-Fi connections are unmetered some are not (hotspot tethering, airport Wi-Fi), also with 5G there are some mobile connections which are unmetered.\nMy point being: we're presumably trying to avoid the user being charged for data rather than simply letting them choose a specific network protocol.", "url": "https://github.com/google/ground-android/pull/506#discussion_r446898486", "createdAt": "2020-06-29T11:29:21Z", "author": {"login": "dturner"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/LocalValueStore.java", "diffHunk": "@@ -46,17 +47,19 @@ public String getLastActiveProjectId() {\n \n   /** Set the id of the last project successfully activated by the user. */\n   public void setLastActiveProjectId(@NonNull String id) {\n-    preferences\n-      .edit()\n-      .putString(ACTIVE_PROJECT_ID_KEY, id)\n-      .apply();\n+    preferences.edit().putString(ACTIVE_PROJECT_ID_KEY, id).apply();\n   }\n \n   /** Removes the last active project id in the local value store. */\n   public void clearLastActiveProjectId() {\n-    preferences\n-      .edit()\n-      .remove(ACTIVE_PROJECT_ID_KEY)\n-      .apply();\n+    preferences.edit().remove(ACTIVE_PROJECT_ID_KEY).apply();\n+  }\n+\n+  public boolean shouldUploadMediaOverWifiOnly() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "880c2a9c4aebb076f4d26b8b7313a79979a61770"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4MTc3OQ==", "bodyText": "Thanks for pointing that out. So does that mean I should update the label in the settings as well?", "url": "https://github.com/google/ground-android/pull/506#discussion_r446981779", "createdAt": "2020-06-29T13:43:46Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/LocalValueStore.java", "diffHunk": "@@ -46,17 +47,19 @@ public String getLastActiveProjectId() {\n \n   /** Set the id of the last project successfully activated by the user. */\n   public void setLastActiveProjectId(@NonNull String id) {\n-    preferences\n-      .edit()\n-      .putString(ACTIVE_PROJECT_ID_KEY, id)\n-      .apply();\n+    preferences.edit().putString(ACTIVE_PROJECT_ID_KEY, id).apply();\n   }\n \n   /** Removes the last active project id in the local value store. */\n   public void clearLastActiveProjectId() {\n-    preferences\n-      .edit()\n-      .remove(ACTIVE_PROJECT_ID_KEY)\n-      .apply();\n+    preferences.edit().remove(ACTIVE_PROJECT_ID_KEY).apply();\n+  }\n+\n+  public boolean shouldUploadMediaOverWifiOnly() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg5ODQ4Ng=="}, "originalCommit": {"oid": "880c2a9c4aebb076f4d26b8b7313a79979a61770"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzNzQ3Nw==", "bodyText": "Good catch, @dturner. Google Photos and other apps still prompt the user to \"Wait for Wi-Fi\" rather than \"Wait for Unmetered connection\". The latter is harder to explain to beginner users - @sergeydolgov1 do you think we should use \"Wi-Fi\" as a proxy for \"Unmetered Network\" in the UIs, even though it's not really 100% correct?", "url": "https://github.com/google/ground-android/pull/506#discussion_r447037477", "createdAt": "2020-06-29T14:59:20Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/LocalValueStore.java", "diffHunk": "@@ -46,17 +47,19 @@ public String getLastActiveProjectId() {\n \n   /** Set the id of the last project successfully activated by the user. */\n   public void setLastActiveProjectId(@NonNull String id) {\n-    preferences\n-      .edit()\n-      .putString(ACTIVE_PROJECT_ID_KEY, id)\n-      .apply();\n+    preferences.edit().putString(ACTIVE_PROJECT_ID_KEY, id).apply();\n   }\n \n   /** Removes the last active project id in the local value store. */\n   public void clearLastActiveProjectId() {\n-    preferences\n-      .edit()\n-      .remove(ACTIVE_PROJECT_ID_KEY)\n-      .apply();\n+    preferences.edit().remove(ACTIVE_PROJECT_ID_KEY).apply();\n+  }\n+\n+  public boolean shouldUploadMediaOverWifiOnly() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg5ODQ4Ng=="}, "originalCommit": {"oid": "880c2a9c4aebb076f4d26b8b7313a79979a61770"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5MDY4Ng==", "bodyText": "@gino-m Suggest that we use \"Wi-Fi\" as a proxy for Unmetered Network as Wi-Fi is usually the way people use the Internet free of charge. Also, FYI -- this is Android developer documentation, they also use \"Wi-Fi\" terminology: https://developer.android.com/training/basics/network-ops/managing", "url": "https://github.com/google/ground-android/pull/506#discussion_r449390686", "createdAt": "2020-07-03T06:00:54Z", "author": {"login": "sergeydolgov1"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/LocalValueStore.java", "diffHunk": "@@ -46,17 +47,19 @@ public String getLastActiveProjectId() {\n \n   /** Set the id of the last project successfully activated by the user. */\n   public void setLastActiveProjectId(@NonNull String id) {\n-    preferences\n-      .edit()\n-      .putString(ACTIVE_PROJECT_ID_KEY, id)\n-      .apply();\n+    preferences.edit().putString(ACTIVE_PROJECT_ID_KEY, id).apply();\n   }\n \n   /** Removes the last active project id in the local value store. */\n   public void clearLastActiveProjectId() {\n-    preferences\n-      .edit()\n-      .remove(ACTIVE_PROJECT_ID_KEY)\n-      .apply();\n+    preferences.edit().remove(ACTIVE_PROJECT_ID_KEY).apply();\n+  }\n+\n+  public boolean shouldUploadMediaOverWifiOnly() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg5ODQ4Ng=="}, "originalCommit": {"oid": "880c2a9c4aebb076f4d26b8b7313a79979a61770"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NTE2NTUxOnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/LocalValueStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMToyOTozMVrOGqMhjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMToyOTozMVrOGqMhjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg5ODU3NA==", "bodyText": "As comment above", "url": "https://github.com/google/ground-android/pull/506#discussion_r446898574", "createdAt": "2020-06-29T11:29:31Z", "author": {"login": "dturner"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/LocalValueStore.java", "diffHunk": "@@ -46,17 +47,19 @@ public String getLastActiveProjectId() {\n \n   /** Set the id of the last project successfully activated by the user. */\n   public void setLastActiveProjectId(@NonNull String id) {\n-    preferences\n-      .edit()\n-      .putString(ACTIVE_PROJECT_ID_KEY, id)\n-      .apply();\n+    preferences.edit().putString(ACTIVE_PROJECT_ID_KEY, id).apply();\n   }\n \n   /** Removes the last active project id in the local value store. */\n   public void clearLastActiveProjectId() {\n-    preferences\n-      .edit()\n-      .remove(ACTIVE_PROJECT_ID_KEY)\n-      .apply();\n+    preferences.edit().remove(ACTIVE_PROJECT_ID_KEY).apply();\n+  }\n+\n+  public boolean shouldUploadMediaOverWifiOnly() {\n+    return preferences.getBoolean(Keys.UPLOAD_MEDIA, false);\n+  }\n+\n+  public boolean shouldDownloadOfflineAreasOverWifiOnly() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "880c2a9c4aebb076f4d26b8b7313a79979a61770"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NTE2NzcwOnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/GndApplicationModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMTozMDowNVrOGqMi0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMzo0NToyN1rOGqRrjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg5ODg5OQ==", "bodyText": "Out of interest, what caused this to become public?", "url": "https://github.com/google/ground-android/pull/506#discussion_r446898899", "createdAt": "2020-06-29T11:30:05Z", "author": {"login": "dturner"}, "path": "gnd/src/main/java/com/google/android/gnd/GndApplicationModule.java", "diffHunk": "@@ -45,8 +45,7 @@\n import javax.inject.Singleton;\n \n @Module(includes = {AndroidSupportInjectionModule.class, ViewModelModule.class})\n-abstract class GndApplicationModule {\n-  private static final String SHARED_PREFERENCES_NAME = \"shared_prefs\";\n+public abstract class GndApplicationModule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "880c2a9c4aebb076f4d26b8b7313a79979a61770"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4MzA1Mw==", "bodyText": "At first, I reused the same variable SHARED_PREFERENCES_NAME in the SettingsFragment, but then moved it Config.java. So this can be reverted back now. Nice catch!", "url": "https://github.com/google/ground-android/pull/506#discussion_r446983053", "createdAt": "2020-06-29T13:45:27Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/main/java/com/google/android/gnd/GndApplicationModule.java", "diffHunk": "@@ -45,8 +45,7 @@\n import javax.inject.Singleton;\n \n @Module(includes = {AndroidSupportInjectionModule.class, ViewModelModule.class})\n-abstract class GndApplicationModule {\n-  private static final String SHARED_PREFERENCES_NAME = \"shared_prefs\";\n+public abstract class GndApplicationModule {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg5ODg5OQ=="}, "originalCommit": {"oid": "880c2a9c4aebb076f4d26b8b7313a79979a61770"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NTIwMzQ1OnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/persistence/sync/BaseWorkManager.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMTo0MDoxMlrOGqM3yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNDoxNjoxMVrOGr82mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkwNDI2NA==", "bodyText": "Any reason for picking LINEAR backoff? I thought the generally accepted best practice was to use EXPONENTIAL", "url": "https://github.com/google/ground-android/pull/506#discussion_r446904264", "createdAt": "2020-06-29T11:40:12Z", "author": {"login": "dturner"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/sync/BaseWorkManager.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.sync;\n+\n+import androidx.annotation.Nullable;\n+import androidx.work.BackoffPolicy;\n+import androidx.work.Constraints;\n+import androidx.work.Data;\n+import androidx.work.NetworkType;\n+import androidx.work.OneTimeWorkRequest;\n+import androidx.work.OneTimeWorkRequest.Builder;\n+import androidx.work.WorkManager;\n+import androidx.work.WorkRequest;\n+import java.util.concurrent.TimeUnit;\n+import javax.inject.Provider;\n+\n+public abstract class BaseWorkManager {\n+\n+  /** Number of milliseconds to wait before retrying failed sync tasks. */\n+  private static final long SYNC_BACKOFF_MILLIS = WorkRequest.MIN_BACKOFF_MILLIS;\n+\n+  /** Any working network connection is required for this work. */\n+  private static final NetworkType DEFAULT_NETWORK_TYPE = NetworkType.CONNECTED;\n+\n+  /**\n+   * WorkManager is injected via {@code Provider} rather than directly to ensure the {@code\n+   * Application} has a change to initialize it before {@code WorkManager.getInstance()} is called.\n+   */\n+  private final Provider<WorkManager> workManagerProvider;\n+\n+  public BaseWorkManager(Provider<WorkManager> workManagerProvider) {\n+    this.workManagerProvider = workManagerProvider;\n+  }\n+\n+  protected WorkManager getWorkManager() {\n+    return workManagerProvider.get().getInstance();\n+  }\n+\n+  protected Constraints getWorkerConstraints() {\n+    return new Constraints.Builder().setRequiredNetworkType(preferredNetworkType()).build();\n+  }\n+\n+  /**\n+   * Override this method if the worker requires a stable internet connection for large file\n+   * upload/download. By default, the worker just needs access to internet connection.\n+   */\n+  protected NetworkType preferredNetworkType() {\n+    return DEFAULT_NETWORK_TYPE;\n+  }\n+\n+  abstract Class<? extends BaseWorker> getWorkerClass();\n+\n+  protected OneTimeWorkRequest buildWorkerRequest(@Nullable Data inputData) {\n+    Builder builder =\n+        new Builder(getWorkerClass())\n+            .setConstraints(getWorkerConstraints())\n+            .setBackoffCriteria(BackoffPolicy.LINEAR, SYNC_BACKOFF_MILLIS, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "880c2a9c4aebb076f4d26b8b7313a79979a61770"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4NTcwNQ==", "bodyText": "This is the current backoff criteria being used in DataSyncWorkManager. I just pulled it out and moved to BaseWorkerManager so we can apply a common template to all of our *WorkManager and move boiler-plate code to this base class.\nBut I do agree EXPONENTIAL seems to be the best practice. @gino-m Could you please provide some background why it LINEAR was set as the default choice?", "url": "https://github.com/google/ground-android/pull/506#discussion_r446985705", "createdAt": "2020-06-29T13:49:00Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/sync/BaseWorkManager.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.sync;\n+\n+import androidx.annotation.Nullable;\n+import androidx.work.BackoffPolicy;\n+import androidx.work.Constraints;\n+import androidx.work.Data;\n+import androidx.work.NetworkType;\n+import androidx.work.OneTimeWorkRequest;\n+import androidx.work.OneTimeWorkRequest.Builder;\n+import androidx.work.WorkManager;\n+import androidx.work.WorkRequest;\n+import java.util.concurrent.TimeUnit;\n+import javax.inject.Provider;\n+\n+public abstract class BaseWorkManager {\n+\n+  /** Number of milliseconds to wait before retrying failed sync tasks. */\n+  private static final long SYNC_BACKOFF_MILLIS = WorkRequest.MIN_BACKOFF_MILLIS;\n+\n+  /** Any working network connection is required for this work. */\n+  private static final NetworkType DEFAULT_NETWORK_TYPE = NetworkType.CONNECTED;\n+\n+  /**\n+   * WorkManager is injected via {@code Provider} rather than directly to ensure the {@code\n+   * Application} has a change to initialize it before {@code WorkManager.getInstance()} is called.\n+   */\n+  private final Provider<WorkManager> workManagerProvider;\n+\n+  public BaseWorkManager(Provider<WorkManager> workManagerProvider) {\n+    this.workManagerProvider = workManagerProvider;\n+  }\n+\n+  protected WorkManager getWorkManager() {\n+    return workManagerProvider.get().getInstance();\n+  }\n+\n+  protected Constraints getWorkerConstraints() {\n+    return new Constraints.Builder().setRequiredNetworkType(preferredNetworkType()).build();\n+  }\n+\n+  /**\n+   * Override this method if the worker requires a stable internet connection for large file\n+   * upload/download. By default, the worker just needs access to internet connection.\n+   */\n+  protected NetworkType preferredNetworkType() {\n+    return DEFAULT_NETWORK_TYPE;\n+  }\n+\n+  abstract Class<? extends BaseWorker> getWorkerClass();\n+\n+  protected OneTimeWorkRequest buildWorkerRequest(@Nullable Data inputData) {\n+    Builder builder =\n+        new Builder(getWorkerClass())\n+            .setConstraints(getWorkerConstraints())\n+            .setBackoffCriteria(BackoffPolicy.LINEAR, SYNC_BACKOFF_MILLIS, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkwNDI2NA=="}, "originalCommit": {"oid": "880c2a9c4aebb076f4d26b8b7313a79979a61770"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzOTg5OQ==", "bodyText": "I don't remember for certain, but it might have been an attempt to compensate for the fact that gRPC can take awhile to wake up after a connection becomes available.\nHow does backoff interact with the required network type? i.e. is the worker expected to start ASAP after the required network is available, regardless of backoff?", "url": "https://github.com/google/ground-android/pull/506#discussion_r447039899", "createdAt": "2020-06-29T15:02:37Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/sync/BaseWorkManager.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.sync;\n+\n+import androidx.annotation.Nullable;\n+import androidx.work.BackoffPolicy;\n+import androidx.work.Constraints;\n+import androidx.work.Data;\n+import androidx.work.NetworkType;\n+import androidx.work.OneTimeWorkRequest;\n+import androidx.work.OneTimeWorkRequest.Builder;\n+import androidx.work.WorkManager;\n+import androidx.work.WorkRequest;\n+import java.util.concurrent.TimeUnit;\n+import javax.inject.Provider;\n+\n+public abstract class BaseWorkManager {\n+\n+  /** Number of milliseconds to wait before retrying failed sync tasks. */\n+  private static final long SYNC_BACKOFF_MILLIS = WorkRequest.MIN_BACKOFF_MILLIS;\n+\n+  /** Any working network connection is required for this work. */\n+  private static final NetworkType DEFAULT_NETWORK_TYPE = NetworkType.CONNECTED;\n+\n+  /**\n+   * WorkManager is injected via {@code Provider} rather than directly to ensure the {@code\n+   * Application} has a change to initialize it before {@code WorkManager.getInstance()} is called.\n+   */\n+  private final Provider<WorkManager> workManagerProvider;\n+\n+  public BaseWorkManager(Provider<WorkManager> workManagerProvider) {\n+    this.workManagerProvider = workManagerProvider;\n+  }\n+\n+  protected WorkManager getWorkManager() {\n+    return workManagerProvider.get().getInstance();\n+  }\n+\n+  protected Constraints getWorkerConstraints() {\n+    return new Constraints.Builder().setRequiredNetworkType(preferredNetworkType()).build();\n+  }\n+\n+  /**\n+   * Override this method if the worker requires a stable internet connection for large file\n+   * upload/download. By default, the worker just needs access to internet connection.\n+   */\n+  protected NetworkType preferredNetworkType() {\n+    return DEFAULT_NETWORK_TYPE;\n+  }\n+\n+  abstract Class<? extends BaseWorker> getWorkerClass();\n+\n+  protected OneTimeWorkRequest buildWorkerRequest(@Nullable Data inputData) {\n+    Builder builder =\n+        new Builder(getWorkerClass())\n+            .setConstraints(getWorkerConstraints())\n+            .setBackoffCriteria(BackoffPolicy.LINEAR, SYNC_BACKOFF_MILLIS, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkwNDI2NA=="}, "originalCommit": {"oid": "880c2a9c4aebb076f4d26b8b7313a79979a61770"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ3OTIxMw==", "bodyText": "It will check for the constraint only after the required amount of time has passed based of last backoff delay. Only then it will start.", "url": "https://github.com/google/ground-android/pull/506#discussion_r447479213", "createdAt": "2020-06-30T07:46:31Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/sync/BaseWorkManager.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.sync;\n+\n+import androidx.annotation.Nullable;\n+import androidx.work.BackoffPolicy;\n+import androidx.work.Constraints;\n+import androidx.work.Data;\n+import androidx.work.NetworkType;\n+import androidx.work.OneTimeWorkRequest;\n+import androidx.work.OneTimeWorkRequest.Builder;\n+import androidx.work.WorkManager;\n+import androidx.work.WorkRequest;\n+import java.util.concurrent.TimeUnit;\n+import javax.inject.Provider;\n+\n+public abstract class BaseWorkManager {\n+\n+  /** Number of milliseconds to wait before retrying failed sync tasks. */\n+  private static final long SYNC_BACKOFF_MILLIS = WorkRequest.MIN_BACKOFF_MILLIS;\n+\n+  /** Any working network connection is required for this work. */\n+  private static final NetworkType DEFAULT_NETWORK_TYPE = NetworkType.CONNECTED;\n+\n+  /**\n+   * WorkManager is injected via {@code Provider} rather than directly to ensure the {@code\n+   * Application} has a change to initialize it before {@code WorkManager.getInstance()} is called.\n+   */\n+  private final Provider<WorkManager> workManagerProvider;\n+\n+  public BaseWorkManager(Provider<WorkManager> workManagerProvider) {\n+    this.workManagerProvider = workManagerProvider;\n+  }\n+\n+  protected WorkManager getWorkManager() {\n+    return workManagerProvider.get().getInstance();\n+  }\n+\n+  protected Constraints getWorkerConstraints() {\n+    return new Constraints.Builder().setRequiredNetworkType(preferredNetworkType()).build();\n+  }\n+\n+  /**\n+   * Override this method if the worker requires a stable internet connection for large file\n+   * upload/download. By default, the worker just needs access to internet connection.\n+   */\n+  protected NetworkType preferredNetworkType() {\n+    return DEFAULT_NETWORK_TYPE;\n+  }\n+\n+  abstract Class<? extends BaseWorker> getWorkerClass();\n+\n+  protected OneTimeWorkRequest buildWorkerRequest(@Nullable Data inputData) {\n+    Builder builder =\n+        new Builder(getWorkerClass())\n+            .setConstraints(getWorkerConstraints())\n+            .setBackoffCriteria(BackoffPolicy.LINEAR, SYNC_BACKOFF_MILLIS, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkwNDI2NA=="}, "originalCommit": {"oid": "880c2a9c4aebb076f4d26b8b7313a79979a61770"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczNTUxNw==", "bodyText": "Is there no way to wake up the worker as soon as the connection becomes available? (@dturner?).  If not, perhaps LINEAR is a safer bet? As it's currently defined, retries will only occur at 10 sec, then 100 sec, and 1000 sec?", "url": "https://github.com/google/ground-android/pull/506#discussion_r447735517", "createdAt": "2020-06-30T14:38:36Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/sync/BaseWorkManager.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.sync;\n+\n+import androidx.annotation.Nullable;\n+import androidx.work.BackoffPolicy;\n+import androidx.work.Constraints;\n+import androidx.work.Data;\n+import androidx.work.NetworkType;\n+import androidx.work.OneTimeWorkRequest;\n+import androidx.work.OneTimeWorkRequest.Builder;\n+import androidx.work.WorkManager;\n+import androidx.work.WorkRequest;\n+import java.util.concurrent.TimeUnit;\n+import javax.inject.Provider;\n+\n+public abstract class BaseWorkManager {\n+\n+  /** Number of milliseconds to wait before retrying failed sync tasks. */\n+  private static final long SYNC_BACKOFF_MILLIS = WorkRequest.MIN_BACKOFF_MILLIS;\n+\n+  /** Any working network connection is required for this work. */\n+  private static final NetworkType DEFAULT_NETWORK_TYPE = NetworkType.CONNECTED;\n+\n+  /**\n+   * WorkManager is injected via {@code Provider} rather than directly to ensure the {@code\n+   * Application} has a change to initialize it before {@code WorkManager.getInstance()} is called.\n+   */\n+  private final Provider<WorkManager> workManagerProvider;\n+\n+  public BaseWorkManager(Provider<WorkManager> workManagerProvider) {\n+    this.workManagerProvider = workManagerProvider;\n+  }\n+\n+  protected WorkManager getWorkManager() {\n+    return workManagerProvider.get().getInstance();\n+  }\n+\n+  protected Constraints getWorkerConstraints() {\n+    return new Constraints.Builder().setRequiredNetworkType(preferredNetworkType()).build();\n+  }\n+\n+  /**\n+   * Override this method if the worker requires a stable internet connection for large file\n+   * upload/download. By default, the worker just needs access to internet connection.\n+   */\n+  protected NetworkType preferredNetworkType() {\n+    return DEFAULT_NETWORK_TYPE;\n+  }\n+\n+  abstract Class<? extends BaseWorker> getWorkerClass();\n+\n+  protected OneTimeWorkRequest buildWorkerRequest(@Nullable Data inputData) {\n+    Builder builder =\n+        new Builder(getWorkerClass())\n+            .setConstraints(getWorkerConstraints())\n+            .setBackoffCriteria(BackoffPolicy.LINEAR, SYNC_BACKOFF_MILLIS, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkwNDI2NA=="}, "originalCommit": {"oid": "880c2a9c4aebb076f4d26b8b7313a79979a61770"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODczODk2OA==", "bodyText": "Reverted back to LINEAR", "url": "https://github.com/google/ground-android/pull/506#discussion_r448738968", "createdAt": "2020-07-02T04:16:11Z", "author": {"login": "shobhitagarwal1612"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/sync/BaseWorkManager.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.sync;\n+\n+import androidx.annotation.Nullable;\n+import androidx.work.BackoffPolicy;\n+import androidx.work.Constraints;\n+import androidx.work.Data;\n+import androidx.work.NetworkType;\n+import androidx.work.OneTimeWorkRequest;\n+import androidx.work.OneTimeWorkRequest.Builder;\n+import androidx.work.WorkManager;\n+import androidx.work.WorkRequest;\n+import java.util.concurrent.TimeUnit;\n+import javax.inject.Provider;\n+\n+public abstract class BaseWorkManager {\n+\n+  /** Number of milliseconds to wait before retrying failed sync tasks. */\n+  private static final long SYNC_BACKOFF_MILLIS = WorkRequest.MIN_BACKOFF_MILLIS;\n+\n+  /** Any working network connection is required for this work. */\n+  private static final NetworkType DEFAULT_NETWORK_TYPE = NetworkType.CONNECTED;\n+\n+  /**\n+   * WorkManager is injected via {@code Provider} rather than directly to ensure the {@code\n+   * Application} has a change to initialize it before {@code WorkManager.getInstance()} is called.\n+   */\n+  private final Provider<WorkManager> workManagerProvider;\n+\n+  public BaseWorkManager(Provider<WorkManager> workManagerProvider) {\n+    this.workManagerProvider = workManagerProvider;\n+  }\n+\n+  protected WorkManager getWorkManager() {\n+    return workManagerProvider.get().getInstance();\n+  }\n+\n+  protected Constraints getWorkerConstraints() {\n+    return new Constraints.Builder().setRequiredNetworkType(preferredNetworkType()).build();\n+  }\n+\n+  /**\n+   * Override this method if the worker requires a stable internet connection for large file\n+   * upload/download. By default, the worker just needs access to internet connection.\n+   */\n+  protected NetworkType preferredNetworkType() {\n+    return DEFAULT_NETWORK_TYPE;\n+  }\n+\n+  abstract Class<? extends BaseWorker> getWorkerClass();\n+\n+  protected OneTimeWorkRequest buildWorkerRequest(@Nullable Data inputData) {\n+    Builder builder =\n+        new Builder(getWorkerClass())\n+            .setConstraints(getWorkerConstraints())\n+            .setBackoffCriteria(BackoffPolicy.LINEAR, SYNC_BACKOFF_MILLIS, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkwNDI2NA=="}, "originalCommit": {"oid": "880c2a9c4aebb076f4d26b8b7313a79979a61770"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjA4NDY2OnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/persistence/sync/BaseWorkManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTowMzo1OVrOGqVNXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTowMzo1OVrOGqVNXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MDg2MQ==", "bodyText": "Please add class JavaDoc with quick summary of what this base class provides.", "url": "https://github.com/google/ground-android/pull/506#discussion_r447040861", "createdAt": "2020-06-29T15:03:59Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/sync/BaseWorkManager.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.android.gnd.persistence.sync;\n+\n+import androidx.annotation.Nullable;\n+import androidx.work.BackoffPolicy;\n+import androidx.work.Constraints;\n+import androidx.work.Data;\n+import androidx.work.NetworkType;\n+import androidx.work.OneTimeWorkRequest;\n+import androidx.work.OneTimeWorkRequest.Builder;\n+import androidx.work.WorkManager;\n+import androidx.work.WorkRequest;\n+import java.util.concurrent.TimeUnit;\n+import javax.inject.Provider;\n+\n+public abstract class BaseWorkManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5eea20685f4c0c3f3d576a3f17b5f8ba43ac7b0"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjEwMjQzOnYy", "diffSide": "RIGHT", "path": "gnd/src/main/java/com/google/android/gnd/persistence/sync/TileDownloadWorkManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTowNzo0NFrOGqVYPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTowNzo0NFrOGqVYPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MzY0NQ==", "bodyText": "Consider adding a noargs override of buildWorkerRquest() instead of passing null here with JavaDoc explaining the default behavior with noargs.", "url": "https://github.com/google/ground-android/pull/506#discussion_r447043645", "createdAt": "2020-06-29T15:07:44Z", "author": {"login": "gino-m"}, "path": "gnd/src/main/java/com/google/android/gnd/persistence/sync/TileDownloadWorkManager.java", "diffHunk": "@@ -16,47 +16,48 @@\n \n package com.google.android.gnd.persistence.sync;\n \n-import androidx.work.Constraints;\n import androidx.work.NetworkType;\n import androidx.work.OneTimeWorkRequest;\n import androidx.work.WorkManager;\n+import com.google.android.gnd.persistence.local.LocalValueStore;\n import io.reactivex.Completable;\n import javax.inject.Inject;\n import javax.inject.Provider;\n \n /** Enqueues file download work to be done in the background. */\n-public class TileDownloadWorkManager {\n-  private static final Constraints CONSTRAINTS =\n-      new Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build();\n+public class TileDownloadWorkManager extends BaseWorkManager {\n \n-  private final Provider<WorkManager> workManagerProvider;\n+  private final LocalValueStore localValueStore;\n \n   @Inject\n-  public TileDownloadWorkManager(Provider<WorkManager> workManagerProvider) {\n-    this.workManagerProvider = workManagerProvider;\n+  public TileDownloadWorkManager(\n+      Provider<WorkManager> workManagerProvider, LocalValueStore localValueStore) {\n+    super(workManagerProvider);\n+    this.localValueStore = localValueStore;\n+  }\n+\n+  @Override\n+  Class<TileDownloadWorker> getWorkerClass() {\n+    return TileDownloadWorker.class;\n+  }\n+\n+  @Override\n+  protected NetworkType preferredNetworkType() {\n+    return localValueStore.shouldDownloadOfflineAreasOverUnmeteredConnectionOnly()\n+        ? NetworkType.UNMETERED\n+        : NetworkType.CONNECTED;\n   }\n \n   /**\n    * Enqueues a worker that downloads files when a network connection is available, returning a\n-   * completeable upon enqueueing.\n+   * completable upon enqueueing.\n    */\n   public Completable enqueueTileDownloadWorker() {\n     return Completable.fromRunnable(this::enqueueTileDownloadWorkerInternal);\n   }\n \n   private void enqueueTileDownloadWorkerInternal() {\n-    OneTimeWorkRequest request = buildWorkerRequest();\n-\n+    OneTimeWorkRequest request = buildWorkerRequest(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5eea20685f4c0c3f3d576a3f17b5f8ba43ac7b0"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2477, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}