{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3ODQ3Mjc2", "number": 1527, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNjoyMjoyOVrODhlyyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNToyMDo0NVrODjHk4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTQ4ODA5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/accumulo/core/logging/FateLogger.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNjoyMjoyOVrOFsaD9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjoxNzozNVrOFu-atA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwODY2MQ==", "bodyText": "I do not like that the code to convert a Repo to a string for logging is not in this class.  I would like for a user to look at the source code for this class and see exactly what will be logged.  However I could not figure out how to make Gson do what I wanted in this class, I had to move the code to master module.  When the code was here Gson kept converting the Repo's to {}.", "url": "https://github.com/apache/accumulo/pull/1527#discussion_r382108661", "createdAt": "2020-02-20T16:22:29Z", "author": {"login": "keith-turner"}, "path": "core/src/main/java/org/apache/accumulo/core/logging/FateLogger.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.accumulo.core.logging;\n+\n+import static org.apache.accumulo.fate.FateTxId.formatTid;\n+\n+import java.io.Serializable;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import org.apache.accumulo.fate.ReadOnlyRepo;\n+import org.apache.accumulo.fate.Repo;\n+import org.apache.accumulo.fate.StackOverflowException;\n+import org.apache.accumulo.fate.TStore;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FateLogger {\n+  private static final String PREFIX = Logging.PREFIX + \"fate.\";\n+\n+  // Logs all mutations to FATEs persistent storage. Enabling this logger could help debug\n+  // reproducible problems with FATE transactions.\n+  private static final Logger storeLog = LoggerFactory.getLogger(PREFIX + \"store\");\n+\n+  public static <T> TStore<T> wrap(TStore<T> store, Function<Repo<T>,String> toLogString) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8ce058431f5cf7261fa1f7434b640e81456504c"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgwMTQ2MA==", "bodyText": "One possible solution is to create a simple pojo to be serialized... and put in it whatever you need from the Repo, and serialize the pojo with Gson rather than serialize the Repo. That's what I did for AccumuloMonitorAppender in #1528 rather than try to serialize Log4j's LogEvent type.", "url": "https://github.com/apache/accumulo/pull/1527#discussion_r384801460", "createdAt": "2020-02-26T22:17:35Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/logging/FateLogger.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.accumulo.core.logging;\n+\n+import static org.apache.accumulo.fate.FateTxId.formatTid;\n+\n+import java.io.Serializable;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import org.apache.accumulo.fate.ReadOnlyRepo;\n+import org.apache.accumulo.fate.Repo;\n+import org.apache.accumulo.fate.StackOverflowException;\n+import org.apache.accumulo.fate.TStore;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FateLogger {\n+  private static final String PREFIX = Logging.PREFIX + \"fate.\";\n+\n+  // Logs all mutations to FATEs persistent storage. Enabling this logger could help debug\n+  // reproducible problems with FATE transactions.\n+  private static final Logger storeLog = LoggerFactory.getLogger(PREFIX + \"store\");\n+\n+  public static <T> TStore<T> wrap(TStore<T> store, Function<Repo<T>,String> toLogString) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwODY2MQ=="}, "originalCommit": {"oid": "d8ce058431f5cf7261fa1f7434b640e81456504c"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTQ4ODYxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/accumulo/core/logging/FateLogger.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNToxNjoxM1rOFuvlGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo1NDoxN1rOFu5_Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1ODM2MQ==", "bodyText": "Why is this one not wrapped?", "url": "https://github.com/apache/accumulo/pull/1527#discussion_r384558361", "createdAt": "2020-02-26T15:16:13Z", "author": {"login": "phrocker"}, "path": "core/src/main/java/org/apache/accumulo/core/logging/FateLogger.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.accumulo.core.logging;\n+\n+import static org.apache.accumulo.fate.FateTxId.formatTid;\n+\n+import java.io.Serializable;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import org.apache.accumulo.fate.ReadOnlyRepo;\n+import org.apache.accumulo.fate.Repo;\n+import org.apache.accumulo.fate.StackOverflowException;\n+import org.apache.accumulo.fate.TStore;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FateLogger {\n+  private static final String PREFIX = Logging.PREFIX + \"fate.\";\n+\n+  // Logs all mutations to FATEs persistent storage. Enabling this logger could help debug\n+  // reproducible problems with FATE transactions.\n+  private static final Logger storeLog = LoggerFactory.getLogger(PREFIX + \"store\");\n+\n+  public static <T> TStore<T> wrap(TStore<T> store, Function<Repo<T>,String> toLogString) {\n+\n+    // only logging operations that change the persisted data, not operations that only read data\n+    return new TStore<T>() {\n+\n+      @Override\n+      public long reserve() {\n+        return store.reserve();\n+      }\n+\n+      @Override\n+      public void reserve(long tid) {\n+        store.reserve(tid);\n+      }\n+\n+      @Override\n+      public void unreserve(long tid, long deferTime) {\n+        store.unreserve(tid, deferTime);\n+      }\n+\n+      @Override\n+      public List<ReadOnlyRepo<T>> getStack(long tid) {\n+        return store.getStack(tid);\n+      }\n+\n+      @Override\n+      public TStatus getStatus(long tid) {\n+        return store.getStatus(tid);\n+      }\n+\n+      @Override\n+      public TStatus waitForStatusChange(long tid, EnumSet<TStatus> expected) {\n+        return store.waitForStatusChange(tid, expected);\n+      }\n+\n+      @Override\n+      public Serializable getProperty(long tid, String prop) {\n+        return store.getProperty(tid, prop);\n+      }\n+\n+      @Override\n+      public List<Long> list() {\n+        return store.list();\n+      }\n+\n+      @Override\n+      public long create() {\n+        long tid = store.create();\n+        if (storeLog.isTraceEnabled())\n+          storeLog.trace(\"created {}\", formatTid(tid));\n+        return tid;\n+      }\n+\n+      @Override\n+      public Repo<T> top(long tid) {\n+        return store.top(tid);\n+      }\n+\n+      @Override\n+      public void push(long tid, Repo<T> repo) throws StackOverflowException {\n+        store.push(tid, repo);\n+        storeLog.trace(\"pushed {} {}\", formatTid(tid), toLogString.apply(repo));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eea5fb5c3f52060eb6a4a8c4e6a0812773e20ef"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYyMDkxNg==", "bodyText": "It should be wrapped.", "url": "https://github.com/apache/accumulo/pull/1527#discussion_r384620916", "createdAt": "2020-02-26T16:44:33Z", "author": {"login": "keith-turner"}, "path": "core/src/main/java/org/apache/accumulo/core/logging/FateLogger.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.accumulo.core.logging;\n+\n+import static org.apache.accumulo.fate.FateTxId.formatTid;\n+\n+import java.io.Serializable;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import org.apache.accumulo.fate.ReadOnlyRepo;\n+import org.apache.accumulo.fate.Repo;\n+import org.apache.accumulo.fate.StackOverflowException;\n+import org.apache.accumulo.fate.TStore;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FateLogger {\n+  private static final String PREFIX = Logging.PREFIX + \"fate.\";\n+\n+  // Logs all mutations to FATEs persistent storage. Enabling this logger could help debug\n+  // reproducible problems with FATE transactions.\n+  private static final Logger storeLog = LoggerFactory.getLogger(PREFIX + \"store\");\n+\n+  public static <T> TStore<T> wrap(TStore<T> store, Function<Repo<T>,String> toLogString) {\n+\n+    // only logging operations that change the persisted data, not operations that only read data\n+    return new TStore<T>() {\n+\n+      @Override\n+      public long reserve() {\n+        return store.reserve();\n+      }\n+\n+      @Override\n+      public void reserve(long tid) {\n+        store.reserve(tid);\n+      }\n+\n+      @Override\n+      public void unreserve(long tid, long deferTime) {\n+        store.unreserve(tid, deferTime);\n+      }\n+\n+      @Override\n+      public List<ReadOnlyRepo<T>> getStack(long tid) {\n+        return store.getStack(tid);\n+      }\n+\n+      @Override\n+      public TStatus getStatus(long tid) {\n+        return store.getStatus(tid);\n+      }\n+\n+      @Override\n+      public TStatus waitForStatusChange(long tid, EnumSet<TStatus> expected) {\n+        return store.waitForStatusChange(tid, expected);\n+      }\n+\n+      @Override\n+      public Serializable getProperty(long tid, String prop) {\n+        return store.getProperty(tid, prop);\n+      }\n+\n+      @Override\n+      public List<Long> list() {\n+        return store.list();\n+      }\n+\n+      @Override\n+      public long create() {\n+        long tid = store.create();\n+        if (storeLog.isTraceEnabled())\n+          storeLog.trace(\"created {}\", formatTid(tid));\n+        return tid;\n+      }\n+\n+      @Override\n+      public Repo<T> top(long tid) {\n+        return store.top(tid);\n+      }\n+\n+      @Override\n+      public void push(long tid, Repo<T> repo) throws StackOverflowException {\n+        store.push(tid, repo);\n+        storeLog.trace(\"pushed {} {}\", formatTid(tid), toLogString.apply(repo));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1ODM2MQ=="}, "originalCommit": {"oid": "9eea5fb5c3f52060eb6a4a8c4e6a0812773e20ef"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyODg4Nw==", "bodyText": "its wrapped now", "url": "https://github.com/apache/accumulo/pull/1527#discussion_r384728887", "createdAt": "2020-02-26T19:54:17Z", "author": {"login": "keith-turner"}, "path": "core/src/main/java/org/apache/accumulo/core/logging/FateLogger.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.accumulo.core.logging;\n+\n+import static org.apache.accumulo.fate.FateTxId.formatTid;\n+\n+import java.io.Serializable;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import org.apache.accumulo.fate.ReadOnlyRepo;\n+import org.apache.accumulo.fate.Repo;\n+import org.apache.accumulo.fate.StackOverflowException;\n+import org.apache.accumulo.fate.TStore;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FateLogger {\n+  private static final String PREFIX = Logging.PREFIX + \"fate.\";\n+\n+  // Logs all mutations to FATEs persistent storage. Enabling this logger could help debug\n+  // reproducible problems with FATE transactions.\n+  private static final Logger storeLog = LoggerFactory.getLogger(PREFIX + \"store\");\n+\n+  public static <T> TStore<T> wrap(TStore<T> store, Function<Repo<T>,String> toLogString) {\n+\n+    // only logging operations that change the persisted data, not operations that only read data\n+    return new TStore<T>() {\n+\n+      @Override\n+      public long reserve() {\n+        return store.reserve();\n+      }\n+\n+      @Override\n+      public void reserve(long tid) {\n+        store.reserve(tid);\n+      }\n+\n+      @Override\n+      public void unreserve(long tid, long deferTime) {\n+        store.unreserve(tid, deferTime);\n+      }\n+\n+      @Override\n+      public List<ReadOnlyRepo<T>> getStack(long tid) {\n+        return store.getStack(tid);\n+      }\n+\n+      @Override\n+      public TStatus getStatus(long tid) {\n+        return store.getStatus(tid);\n+      }\n+\n+      @Override\n+      public TStatus waitForStatusChange(long tid, EnumSet<TStatus> expected) {\n+        return store.waitForStatusChange(tid, expected);\n+      }\n+\n+      @Override\n+      public Serializable getProperty(long tid, String prop) {\n+        return store.getProperty(tid, prop);\n+      }\n+\n+      @Override\n+      public List<Long> list() {\n+        return store.list();\n+      }\n+\n+      @Override\n+      public long create() {\n+        long tid = store.create();\n+        if (storeLog.isTraceEnabled())\n+          storeLog.trace(\"created {}\", formatTid(tid));\n+        return tid;\n+      }\n+\n+      @Override\n+      public Repo<T> top(long tid) {\n+        return store.top(tid);\n+      }\n+\n+      @Override\n+      public void push(long tid, Repo<T> repo) throws StackOverflowException {\n+        store.push(tid, repo);\n+        storeLog.trace(\"pushed {} {}\", formatTid(tid), toLogString.apply(repo));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1ODM2MQ=="}, "originalCommit": {"oid": "9eea5fb5c3f52060eb6a4a8c4e6a0812773e20ef"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTQ5MzQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/accumulo/core/logging/FateLogger.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNToxNzoxNlrOFuvoMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMDowNTowNlrOFu6WPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1OTE1Mg==", "bodyText": "I see your comments about avoiding logging on reads; however, I do feel that when a status changes it would be nice to see the update and the receive on that code path. Therefore when a status change occurs, it may be nice to have a log statement.", "url": "https://github.com/apache/accumulo/pull/1527#discussion_r384559152", "createdAt": "2020-02-26T15:17:16Z", "author": {"login": "phrocker"}, "path": "core/src/main/java/org/apache/accumulo/core/logging/FateLogger.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.accumulo.core.logging;\n+\n+import static org.apache.accumulo.fate.FateTxId.formatTid;\n+\n+import java.io.Serializable;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import org.apache.accumulo.fate.ReadOnlyRepo;\n+import org.apache.accumulo.fate.Repo;\n+import org.apache.accumulo.fate.StackOverflowException;\n+import org.apache.accumulo.fate.TStore;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FateLogger {\n+  private static final String PREFIX = Logging.PREFIX + \"fate.\";\n+\n+  // Logs all mutations to FATEs persistent storage. Enabling this logger could help debug\n+  // reproducible problems with FATE transactions.\n+  private static final Logger storeLog = LoggerFactory.getLogger(PREFIX + \"store\");\n+\n+  public static <T> TStore<T> wrap(TStore<T> store, Function<Repo<T>,String> toLogString) {\n+\n+    // only logging operations that change the persisted data, not operations that only read data\n+    return new TStore<T>() {\n+\n+      @Override\n+      public long reserve() {\n+        return store.reserve();\n+      }\n+\n+      @Override\n+      public void reserve(long tid) {\n+        store.reserve(tid);\n+      }\n+\n+      @Override\n+      public void unreserve(long tid, long deferTime) {\n+        store.unreserve(tid, deferTime);\n+      }\n+\n+      @Override\n+      public List<ReadOnlyRepo<T>> getStack(long tid) {\n+        return store.getStack(tid);\n+      }\n+\n+      @Override\n+      public TStatus getStatus(long tid) {\n+        return store.getStatus(tid);\n+      }\n+\n+      @Override\n+      public TStatus waitForStatusChange(long tid, EnumSet<TStatus> expected) {\n+        return store.waitForStatusChange(tid, expected);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eea5fb5c3f52060eb6a4a8c4e6a0812773e20ef"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNDc4MQ==", "bodyText": "If write logging is enabled, then when the status changes that will be seen.\nI considered having a separate prefix for read related log messages so that it could be turned on and off independently from write log messages.  However I could not think of use cases for the read logging that was not covered by the write logging.  One use case I thought of was when a thread is stuck reading something, but I think jstack and memory dumps may be better tools for that use case.", "url": "https://github.com/apache/accumulo/pull/1527#discussion_r384734781", "createdAt": "2020-02-26T20:05:06Z", "author": {"login": "keith-turner"}, "path": "core/src/main/java/org/apache/accumulo/core/logging/FateLogger.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.accumulo.core.logging;\n+\n+import static org.apache.accumulo.fate.FateTxId.formatTid;\n+\n+import java.io.Serializable;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import org.apache.accumulo.fate.ReadOnlyRepo;\n+import org.apache.accumulo.fate.Repo;\n+import org.apache.accumulo.fate.StackOverflowException;\n+import org.apache.accumulo.fate.TStore;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FateLogger {\n+  private static final String PREFIX = Logging.PREFIX + \"fate.\";\n+\n+  // Logs all mutations to FATEs persistent storage. Enabling this logger could help debug\n+  // reproducible problems with FATE transactions.\n+  private static final Logger storeLog = LoggerFactory.getLogger(PREFIX + \"store\");\n+\n+  public static <T> TStore<T> wrap(TStore<T> store, Function<Repo<T>,String> toLogString) {\n+\n+    // only logging operations that change the persisted data, not operations that only read data\n+    return new TStore<T>() {\n+\n+      @Override\n+      public long reserve() {\n+        return store.reserve();\n+      }\n+\n+      @Override\n+      public void reserve(long tid) {\n+        store.reserve(tid);\n+      }\n+\n+      @Override\n+      public void unreserve(long tid, long deferTime) {\n+        store.unreserve(tid, deferTime);\n+      }\n+\n+      @Override\n+      public List<ReadOnlyRepo<T>> getStack(long tid) {\n+        return store.getStack(tid);\n+      }\n+\n+      @Override\n+      public TStatus getStatus(long tid) {\n+        return store.getStatus(tid);\n+      }\n+\n+      @Override\n+      public TStatus waitForStatusChange(long tid, EnumSet<TStatus> expected) {\n+        return store.waitForStatusChange(tid, expected);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1OTE1Mg=="}, "originalCommit": {"oid": "9eea5fb5c3f52060eb6a4a8c4e6a0812773e20ef"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTUwODgyOnYy", "diffSide": "RIGHT", "path": "server/master/src/main/java/org/apache/accumulo/master/tableOps/TraceRepo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNToyMDo0NVrOFuvx5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoyNzowNlrOFu1AUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MTYzOA==", "bodyText": "Memory may not be serving me well but I think you can define a JSONSerializer that may help avoid this [1]. But I could be wrong as it's much easier to be an armchair quarterback reviewer than the one writing the code :)\n[1] https://howtodoinjava.com/gson/custom-serialization-deserialization/", "url": "https://github.com/apache/accumulo/pull/1527#discussion_r384561638", "createdAt": "2020-02-26T15:20:45Z", "author": {"login": "phrocker"}, "path": "server/master/src/main/java/org/apache/accumulo/master/tableOps/TraceRepo.java", "diffHunk": "@@ -72,4 +75,19 @@ public String getReturn() {\n     return repo.getReturn();\n   }\n \n+  /**\n+   * @return string version of Repo that is suitable for logging\n+   */\n+  public static String toLogString(Repo<Master> repo) {\n+    if (repo instanceof TraceRepo) {\n+      // There are two reasons the repo is unwrapped. First I could not figure out how to get this\n+      // to work with Gson. Gson kept serializing nothing for the generic pointer TraceRepo.repo.\n+      // Second I thought this information was not useful for logging.\n+      repo = ((TraceRepo<Master>) repo).repo;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eea5fb5c3f52060eb6a4a8c4e6a0812773e20ef"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NzI1MA==", "bodyText": "I think I tried some of those.  My solutions kept leading to an infinite loop or no output.  The wall I kept running into was that Gson wanted to work with concrete types. I had a generic interface that I wanted Gson to generate json for.  Gson did not like that, it wants to write out things that could be deserialized.  I was trying to get it write json out that it would not be able to deserialize back into concrete types.", "url": "https://github.com/apache/accumulo/pull/1527#discussion_r384647250", "createdAt": "2020-02-26T17:27:06Z", "author": {"login": "keith-turner"}, "path": "server/master/src/main/java/org/apache/accumulo/master/tableOps/TraceRepo.java", "diffHunk": "@@ -72,4 +75,19 @@ public String getReturn() {\n     return repo.getReturn();\n   }\n \n+  /**\n+   * @return string version of Repo that is suitable for logging\n+   */\n+  public static String toLogString(Repo<Master> repo) {\n+    if (repo instanceof TraceRepo) {\n+      // There are two reasons the repo is unwrapped. First I could not figure out how to get this\n+      // to work with Gson. Gson kept serializing nothing for the generic pointer TraceRepo.repo.\n+      // Second I thought this information was not useful for logging.\n+      repo = ((TraceRepo<Master>) repo).repo;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MTYzOA=="}, "originalCommit": {"oid": "9eea5fb5c3f52060eb6a4a8c4e6a0812773e20ef"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4164, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}