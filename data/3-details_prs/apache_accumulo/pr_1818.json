{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NzgxMDcw", "number": 1818, "title": "Fixes #1808 - Stop server side VM on Error in Thread", "bodyText": "Modified the AccumuloUncaughtExceptionHandler to log Exception and\nError and Halt the VM if the system property HaltVMOnThreadError\nis set to true. Modified all Executors to use the NamingThreadFactory\nwhich uses AccumuloUncaughtExceptionHandler. When modifying\nSimpleTimer I found that some critical tasks could fail and only\nbe logged. Created SimpleCriticalTimer for the critical tasks.", "createdAt": "2020-11-30T20:06:00Z", "url": "https://github.com/apache/accumulo/pull/1818", "merged": true, "mergeCommit": {"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9"}, "closed": true, "closedAt": "2021-01-19T12:22:40Z", "author": {"login": "dlmarion"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdhq91GgH2gAyNTI5NzgxMDcwOmQ2NmJhNDJiYzNhYzIyN2Q4NWFhYTBjYmNlOThjZjE3OWRkMDFiZTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdxp9-4AH2gAyNTI5NzgxMDcwOjM1NjU3MjQyYmVkYmM2YzA4NTBjZmVmOWJkZWY0NGJkOWRlODIyNTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "committedDate": "2020-11-30T20:00:17Z", "message": "Fixes #1808 - Stop server side VM on Error in Thread\n\nModified the AccumuloUncaughtExceptionHandler to log Exception and\nError and Halt the VM if the system property HaltVMOnThreadError\nis set to true. Modified all Executors to use the NamingThreadFactory\nwhich uses AccumuloUncaughtExceptionHandler. When modifying\nSimpleTimer I found that some critical tasks could fail and only\nbe logged. Created SimpleCriticalTimer for the critical tasks."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMjY3NTk1", "url": "https://github.com/apache/accumulo/pull/1818#pullrequestreview-541267595", "createdAt": "2020-11-30T20:26:34Z", "commit": {"oid": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMDoyNjozNFrOH8MjYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMDo0MjowNlrOH8NDYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4MjI3NA==", "bodyText": "We don't need String.format here. The slf4j logger supports substitution with {}\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    log.error(String.format(\"Caught an exception in %s.\", t), e);\n          \n          \n            \n                    log.error(\"Caught an exception in {}.\", t, e);", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532882274", "createdAt": "2020-11-30T20:26:34Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java", "diffHunk": "@@ -26,10 +26,20 @@\n public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n   private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n+  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n-    log.error(String.format(\"Caught an exception in %s.  Shutting down.\", t), e);\n+    if (e instanceof Exception) {\n+      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+    } else {\n+      if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n+        log.error(String.format(\"Caught an exception in %s.\", t), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4MzIyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n          \n          \n            \n                  log.error(\"Caught an exception in {}. Thread is dead.\", t, e);", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532883229", "createdAt": "2020-11-30T20:28:27Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java", "diffHunk": "@@ -26,10 +26,20 @@\n public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n   private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n+  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n-    log.error(String.format(\"Caught an exception in %s.  Shutting down.\", t), e);\n+    if (e instanceof Exception) {\n+      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4MzU3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n          \n          \n            \n                    log.error(\"Caught an exception in {}. Thread is dead.\", t, e);", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532883579", "createdAt": "2020-11-30T20:29:05Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java", "diffHunk": "@@ -26,10 +26,20 @@\n public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n   private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n+  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n-    log.error(String.format(\"Caught an exception in %s.  Shutting down.\", t), e);\n+    if (e instanceof Exception) {\n+      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+    } else {\n+      if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n+        log.error(String.format(\"Caught an exception in %s.\", t), e);\n+        Halt.halt(String.format(\"Caught an exception in %s. Halting VM, check the logs.\", t));\n+      } else {\n+        log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4NDk0Ng==", "bodyText": "What differentiates this from SimpleTimer? Could improve the javadoc here with a high-level explanation.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532884946", "createdAt": "2020-11-30T20:31:37Z", "author": {"login": "ctubbsii"}, "path": "server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleCriticalTimer.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.server.util.time;\n+\n+import java.lang.Thread.UncaughtExceptionHandler;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.util.AccumuloUncaughtExceptionHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic singleton timer for critical tasks.\n+ */\n+public class SimpleCriticalTimer extends SimpleTimer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4NjkzNA==", "bodyText": "This is probably a little easier to read if you assign the ThreadFactory to a variable first, like the following (formatting probably isn't right):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ExecutorService tp = threads == 0\n          \n          \n            \n                    ? Executors.newCachedThreadPool(new NamingThreadFactory(\"GatherTableInformation\"))\n          \n          \n            \n                    : Executors.newFixedThreadPool(threads, new NamingThreadFactory(\"GatherTableInformation\"));\n          \n          \n            \n                var threadFactory = new NamingThreadFactory(\"GatherTableInformation\");\n          \n          \n            \n                ExecutorService tp = threads == 0\n          \n          \n            \n                    ? Executors.newCachedThreadPool(threadFactory)\n          \n          \n            \n                    : Executors.newFixedThreadPool(threads, threadFactory);", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532886934", "createdAt": "2020-11-30T20:35:32Z", "author": {"login": "ctubbsii"}, "path": "server/manager/src/main/java/org/apache/accumulo/master/Master.java", "diffHunk": "@@ -884,8 +886,9 @@ private long balanceTablets() {\n       gatherTableInformation(Set<TServerInstance> currentServers) {\n     final long rpcTimeout = getConfiguration().getTimeInMillis(Property.GENERAL_RPC_TIMEOUT);\n     int threads = getConfiguration().getCount(Property.MASTER_STATUS_THREAD_POOL_SIZE);\n-    ExecutorService tp =\n-        threads == 0 ? Executors.newCachedThreadPool() : Executors.newFixedThreadPool(threads);\n+    ExecutorService tp = threads == 0\n+        ? Executors.newCachedThreadPool(new NamingThreadFactory(\"GatherTableInformation\"))\n+        : Executors.newFixedThreadPool(threads, new NamingThreadFactory(\"GatherTableInformation\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4OTIwOA==", "bodyText": "I'm curious what non-critical use cases we still have for this, that would warrant continuing to swallow OOM errors and such.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532889208", "createdAt": "2020-11-30T20:39:40Z", "author": {"login": "ctubbsii"}, "path": "server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleTimer.java", "diffHunk": "@@ -100,10 +93,19 @@ static int getInstanceThreadPoolSize() {\n     return instanceThreadPoolSize;\n   }\n \n-  private SimpleTimer(int threadPoolSize) {\n+  protected SimpleTimer(int threadPoolSize) {\n     executor = Executors.newScheduledThreadPool(threadPoolSize,\n         new ThreadFactoryBuilder().setNameFormat(\"SimpleTimer-%d\").setDaemon(true)\n-            .setUncaughtExceptionHandler(new ExceptionHandler()).build());\n+            .setUncaughtExceptionHandler(getUncaughtExceptionHandler()).build());\n+  }\n+\n+  protected Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() {\n+    return new Thread.UncaughtExceptionHandler() {\n+      @Override\n+      public void uncaughtException(Thread t, Throwable e) {\n+        log.warn(\"SimpleTimer task failed\", e);\n+      }\n+    };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg5MDQ2NA==", "bodyText": "Interesting strategy. I wonder if the way you're handling this bypasses our setting for '-XX:OnOutOfMemoryError=kill -9 %p' in these threads.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532890464", "createdAt": "2020-11-30T20:42:06Z", "author": {"login": "ctubbsii"}, "path": "assemble/conf/accumulo-env.sh", "diffHunk": "@@ -95,7 +95,7 @@ JAVA_OPTS=(\"${JAVA_OPTS[@]}\"\n \n case \"$cmd\" in\n   monitor|gc|master|tserver|tracer)\n-    JAVA_OPTS=(\"${JAVA_OPTS[@]}\" \"-Dlog4j.configurationFile=log4j2-service.properties\")\n+    JAVA_OPTS=(\"${JAVA_OPTS[@]}\" \"-Dlog4j.configurationFile=log4j2-service.properties\" \"-DHaltVMOnThreadError=true\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0efa5901a38d42a1628fcbe8bd7cba46c9a0f8d0", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/0efa5901a38d42a1628fcbe8bd7cba46c9a0f8d0", "committedDate": "2020-11-30T21:11:33Z", "message": "re #1808 addressed some PR comments, added uncaught exception handler to Daemon"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de1846bcd05b9d967b760146580fa8eadc4545e8", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/de1846bcd05b9d967b760146580fa8eadc4545e8", "committedDate": "2020-12-01T22:26:55Z", "message": "re *1808: wip, does not compile, working on consolidating all thread pool creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2f62e73b96f0605a16099ec047b5ff41bdab380", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/b2f62e73b96f0605a16099ec047b5ff41bdab380", "committedDate": "2020-12-03T19:46:31Z", "message": "re #1808 - consolidate Thread and ThreadPool creation down to one consistent code path"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5649ff9a81cc825cf46e32078a20e960d7b5e766", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/5649ff9a81cc825cf46e32078a20e960d7b5e766", "committedDate": "2020-12-03T19:48:08Z", "message": "Merge branch 'main' into 1808-thread-errors\n\nConflicts:\n\tserver/base/src/test/java/org/apache/accumulo/server/util/time/SimpleTimerTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dad05e0f314a73e792da919661f1308645c7806", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/3dad05e0f314a73e792da919661f1308645c7806", "committedDate": "2020-12-03T21:01:58Z", "message": "re #1808 - fixing build issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80faa9eb2b7840b77ba9adb0922c8b12d0111ed8", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/80faa9eb2b7840b77ba9adb0922c8b12d0111ed8", "committedDate": "2020-12-03T21:39:33Z", "message": "re #1808 - javadoc fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6af4545fad5c9d45632bce5ce29cb310fa4f60ca", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/6af4545fad5c9d45632bce5ce29cb310fa4f60ca", "committedDate": "2020-12-04T16:23:13Z", "message": "Merge branch 'main' into 1808-thread-errors\n\nConflicts:\n\tserver/tracer/src/main/java/org/apache/accumulo/tracer/ZooTraceClient.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79dfb9e5ab0a61a398fe167e73976d70709be698", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/79dfb9e5ab0a61a398fe167e73976d70709be698", "committedDate": "2020-12-04T18:55:03Z", "message": "re #1808 - Remove almost all of the uses of Timer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a8cd565976e1ebb9917a3adefc8d71c617498c8", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/4a8cd565976e1ebb9917a3adefc8d71c617498c8", "committedDate": "2020-12-04T19:34:59Z", "message": "re #1808 - removed property, always halt VM on Error in Thread."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NDE1Njk1", "url": "https://github.com/apache/accumulo/pull/1818#pullrequestreview-545415695", "createdAt": "2020-12-05T06:16:39Z", "commit": {"oid": "4a8cd565976e1ebb9917a3adefc8d71c617498c8"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNjoxNjo0MFrOH_q54g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNjoyMjowNlrOH_q9EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNTI4Mg==", "bodyText": "Rather than create this new type, you can just have a different cleanup method in CleanerUtil that calls shutdownNow instead of close on the argument. It should be a much smaller change... and fewer types is good. I can help with this part, if you're not sure what I mean.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536525282", "createdAt": "2020-12-05T06:16:40Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.OptionalInt;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.util.Threads.NamedRunnable;\n+import org.apache.htrace.wrappers.TraceCallable;\n+import org.apache.htrace.wrappers.TraceRunnable;\n+\n+public class ThreadPools {\n+\n+  /**\n+   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n+   */\n+  private static class NamedThreadFactory implements ThreadFactory {\n+\n+    private static final String FORMAT = \"%s-%s-%d\";\n+\n+    private AtomicInteger threadNum = new AtomicInteger(1);\n+    private String name;\n+    private OptionalInt priority;\n+\n+    private NamedThreadFactory(String name) {\n+      this(name, OptionalInt.empty());\n+    }\n+\n+    private NamedThreadFactory(String name, OptionalInt priority) {\n+      this.name = name;\n+      this.priority = priority;\n+    }\n+\n+    @Override\n+    public Thread newThread(Runnable r) {\n+      String threadName = null;\n+      if (r instanceof NamedRunnable) {\n+        NamedRunnable nr = (NamedRunnable) r;\n+        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n+      } else {\n+        threadName =\n+            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n+      }\n+      return Threads.createThread(threadName, priority, r);\n+    }\n+  }\n+\n+  /**\n+   * ScheduledThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n+\n+    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n+      super(corePoolSize, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  /**\n+   * ThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n+\n+    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n+        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n+      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n+\n+    private final ThreadPoolExecutor tpe;\n+\n+    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n+      this.tpe = tpe;\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+      this.tpe.shutdownNow();\n+    }\n+\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8cd565976e1ebb9917a3adefc8d71c617498c8"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNTU0MQ==", "bodyText": "There's a few of these methods that don't do anything other than call the superclass implementation. These overriding methods can be removed, so the caller of these methods can call the superclass' implementation directly.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536525541", "createdAt": "2020-12-05T06:18:14Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.OptionalInt;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.util.Threads.NamedRunnable;\n+import org.apache.htrace.wrappers.TraceCallable;\n+import org.apache.htrace.wrappers.TraceRunnable;\n+\n+public class ThreadPools {\n+\n+  /**\n+   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n+   */\n+  private static class NamedThreadFactory implements ThreadFactory {\n+\n+    private static final String FORMAT = \"%s-%s-%d\";\n+\n+    private AtomicInteger threadNum = new AtomicInteger(1);\n+    private String name;\n+    private OptionalInt priority;\n+\n+    private NamedThreadFactory(String name) {\n+      this(name, OptionalInt.empty());\n+    }\n+\n+    private NamedThreadFactory(String name, OptionalInt priority) {\n+      this.name = name;\n+      this.priority = priority;\n+    }\n+\n+    @Override\n+    public Thread newThread(Runnable r) {\n+      String threadName = null;\n+      if (r instanceof NamedRunnable) {\n+        NamedRunnable nr = (NamedRunnable) r;\n+        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n+      } else {\n+        threadName =\n+            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n+      }\n+      return Threads.createThread(threadName, priority, r);\n+    }\n+  }\n+\n+  /**\n+   * ScheduledThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n+\n+    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n+      super(corePoolSize, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  /**\n+   * ThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n+\n+    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n+        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n+      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8cd565976e1ebb9917a3adefc8d71c617498c8"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNTg5NA==", "bodyText": "This method, and how you based it on the property might be my favorite piece of code this year. \ud83d\ude3a  This was a great way to bring all the various implementations into one centralized place.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536525894", "createdAt": "2020-12-05T06:20:49Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.OptionalInt;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.util.Threads.NamedRunnable;\n+import org.apache.htrace.wrappers.TraceCallable;\n+import org.apache.htrace.wrappers.TraceRunnable;\n+\n+public class ThreadPools {\n+\n+  /**\n+   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n+   */\n+  private static class NamedThreadFactory implements ThreadFactory {\n+\n+    private static final String FORMAT = \"%s-%s-%d\";\n+\n+    private AtomicInteger threadNum = new AtomicInteger(1);\n+    private String name;\n+    private OptionalInt priority;\n+\n+    private NamedThreadFactory(String name) {\n+      this(name, OptionalInt.empty());\n+    }\n+\n+    private NamedThreadFactory(String name, OptionalInt priority) {\n+      this.name = name;\n+      this.priority = priority;\n+    }\n+\n+    @Override\n+    public Thread newThread(Runnable r) {\n+      String threadName = null;\n+      if (r instanceof NamedRunnable) {\n+        NamedRunnable nr = (NamedRunnable) r;\n+        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n+      } else {\n+        threadName =\n+            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n+      }\n+      return Threads.createThread(threadName, priority, r);\n+    }\n+  }\n+\n+  /**\n+   * ScheduledThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n+\n+    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n+      super(corePoolSize, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  /**\n+   * ThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n+\n+    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n+        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n+      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n+\n+    private final ThreadPoolExecutor tpe;\n+\n+    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n+      this.tpe = tpe;\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+      this.tpe.shutdownNow();\n+    }\n+\n+  }\n+\n+  // the number of seconds before we allow a thread to terminate with non-use.\n+  public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n+\n+  /**\n+   * Get a thread pool based on a thread pool related property\n+   *\n+   * @param conf\n+   *          accumulo configuration\n+   * @param p\n+   *          thread pool related property\n+   * @return ExecutorService impl\n+   * @throws RuntimeException\n+   *           if property is not handled\n+   */\n+  public static ExecutorService getExecutorService(AccumuloConfiguration conf, Property p) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8cd565976e1ebb9917a3adefc8d71c617498c8"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNjA5Ng==", "bodyText": "Let's move this to a subpackage of util. Util is pretty bloated, and in a subpackage, we can break out all the inner classes. Inner classes make it hard to follow the code. package-private classes would be better than private inner classes.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536526096", "createdAt": "2020-12-05T06:22:06Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8cd565976e1ebb9917a3adefc8d71c617498c8"}, "originalPosition": 19}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe29c4cfd724ae81cad630471775ceb335aeed6d", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/fe29c4cfd724ae81cad630471775ceb335aeed6d", "committedDate": "2020-12-05T22:10:31Z", "message": "re #1808 - addressing comments from PR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06209ca242705ff42c5f2b925e5bef8d2b5b7952", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/06209ca242705ff42c5f2b925e5bef8d2b5b7952", "committedDate": "2020-12-14T15:48:15Z", "message": "Merge branch 'main' into 1808-thread-errors\n\nConflicts:\n\tserver/tserver/src/main/java/org/apache/accumulo/tserver/TabletServerResourceManager.java\n\tshell/src/main/java/org/apache/accumulo/shell/commands/ActiveCompactionHelper.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a15ae5c2bd1b82ab2980a34ec655648edad1862", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/6a15ae5c2bd1b82ab2980a34ec655648edad1862", "committedDate": "2020-12-14T16:01:49Z", "message": "Merge branch '1808-thread-errors' of github.com:dlmarion/accumulo into 1808-thread-errors\n\nConflicts:\n\tshell/src/main/java/org/apache/accumulo/shell/commands/ActiveCompactionHelper.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7c1aeba61833a89e02c738a5841866810b04de4", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/d7c1aeba61833a89e02c738a5841866810b04de4", "committedDate": "2020-12-15T16:14:16Z", "message": "re #1808 - don't log message in CleanerUtil if thread pool is already shut down"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNjQ1Mjkz", "url": "https://github.com/apache/accumulo/pull/1818#pullrequestreview-552645293", "createdAt": "2020-12-15T16:33:18Z", "commit": {"oid": "d7c1aeba61833a89e02c738a5841866810b04de4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjozMzoxOFrOIGUfiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjozNzo0N1rOIGUtvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5ODEyMw==", "bodyText": "Why cast here? Why not just make the type more restrictive in the method signature 4 lines above?", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543498123", "createdAt": "2020-12-15T16:33:18Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java", "diffHunk": "@@ -107,10 +107,14 @@ public static Cleanable shutdownThreadPoolExecutor(Object tpe, Logger log) {\n     requireNonNull(tpe);\n     requireNonNull(log);\n     return CLEANER.register(tpe, () -> {\n+      ThreadPoolExecutor pool = (ThreadPoolExecutor) tpe;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c1aeba61833a89e02c738a5841866810b04de4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMDIyOA==", "bodyText": "We really should deregister the cleanable first, so we don't get duplicate exceptions from that if there's a problem calling the shutdown.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543500228", "createdAt": "2020-12-15T16:36:01Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchReader.java", "diffHunk": "@@ -72,16 +72,15 @@ protected TabletServerBatchReader(ClientContext context, Class<?> scopeClass, Ta\n \n     queryThreadPool = ThreadPools.getFixedThreadPool(numQueryThreads,\n         \"batch scanner \" + batchReaderInstance + \"-\", false);\n+    // Call shutdown on this thread pool in case the caller does not call close().\n     cleanable = CleanerUtil.shutdownThreadPoolExecutor(queryThreadPool, log);\n   }\n \n   @Override\n   public void close() {\n     if (closed.compareAndSet(false, true)) {\n-      // deregister cleanable, but it won't run because it checks\n-      // the value of closed first, which is now true\n-      cleanable.clean();\n       queryThreadPool.shutdownNow();\n+      cleanable.clean();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c1aeba61833a89e02c738a5841866810b04de4"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMTc1OA==", "bodyText": "The other cleanables pass in the closed atomic boolean, so they can detect whether the resource has already been closed, and the cleanable action isn't needed. I suggest following the same pattern, just for convenience, rather than follow a custom pattern here.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543501758", "createdAt": "2020-12-15T16:37:47Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java", "diffHunk": "@@ -107,10 +107,14 @@ public static Cleanable shutdownThreadPoolExecutor(Object tpe, Logger log) {\n     requireNonNull(tpe);\n     requireNonNull(log);\n     return CLEANER.register(tpe, () -> {\n+      ThreadPoolExecutor pool = (ThreadPoolExecutor) tpe;\n+      if (pool.isShutdown()) {\n+        return;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c1aeba61833a89e02c738a5841866810b04de4"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b", "committedDate": "2020-12-15T17:21:29Z", "message": "re #1808: addressing PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNzY2NjY4", "url": "https://github.com/apache/accumulo/pull/1818#pullrequestreview-552766668", "createdAt": "2020-12-15T18:50:20Z", "commit": {"oid": "e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODo1MDoyMFrOIGaq2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODo1MDoyMFrOIGaq2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA==", "bodyText": "In talking with @ivakegg and @drewfarris, this may be too severe as it does not run any shutdown hooks and does not perform a graceful shutdown of the application. For example, in TabletServer a normal shutdown will close the FileSystem and return leases on the files in HDFS. Or, maybe this remains the default action and we need to better handle the errors in the threads.\nThere is also the case where we may want to still catch Throwable in non-critical threads (e.g. QueryTask) so that a StackOverflowError does not shutdown the TabletServer, for example.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543599320", "createdAt": "2020-12-15T18:50:20Z", "author": {"login": "dlmarion"}, "path": "core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java", "diffHunk": "@@ -16,20 +16,36 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.accumulo.core.util;\n+package org.apache.accumulo.core.util.threads;\n \n import java.lang.Thread.UncaughtExceptionHandler;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n+/**\n+ * UncaughtExceptionHandler that logs all Exceptions and Errors thrown from a Thread. If an Error is\n+ * thrown, halt the JVM.\n+ *\n+ */\n+class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n-  private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n+  private static final Logger LOG = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n-    log.error(String.format(\"Caught an exception in %s.  Shutting down.\", t), e);\n+    if (e instanceof Exception) {\n+      LOG.error(\"Caught an Exception in {}. Thread is dead.\", t, e);\n+    } else if (e instanceof Error) {\n+      try {\n+        e.printStackTrace();\n+        System.err.println(\"Error thrown in thread: \" + t + \", halting VM.\");\n+      } catch (Throwable e1) {\n+        // If e == OutOfMemoryError, then it's probably that another Error might be\n+        // thrown when trying to print to System.err.\n+      } finally {\n+        Runtime.getRuntime().halt(-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b818173015c5e9c42246b11836060d86a34d5c1", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/4b818173015c5e9c42246b11836060d86a34d5c1", "committedDate": "2021-01-11T13:38:59Z", "message": "Merge branch 'main' into 1808-thread-errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NDI1NDA4", "url": "https://github.com/apache/accumulo/pull/1818#pullrequestreview-565425408", "createdAt": "2021-01-11T14:51:32Z", "commit": {"oid": "4b818173015c5e9c42246b11836060d86a34d5c1"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNDo1MTozM1rOIRYo6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNTo1NDoyOVrOIRblMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMDM5NQ==", "bodyText": "Just curious why the initialization for failedMutations was moved into the constructor but the other nearby inline final initializations (violations, authorizationFailures, serverSideErrors) weren't?", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555100395", "createdAt": "2021-01-11T14:51:33Z", "author": {"login": "brianloss"}, "path": "core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java", "diffHunk": "@@ -198,6 +197,8 @@ public long getTimeOut() {\n \n   public TabletServerBatchWriter(ClientContext context, BatchWriterConfig config) {\n     this.context = context;\n+    this.executor = ThreadPools.getGeneralScheduledExecutorService(this.context.getConfiguration());\n+    this.failedMutations = new FailedMutations();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b818173015c5e9c42246b11836060d86a34d5c1"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMTM0Nw==", "bodyText": "It seems like maybe calling ThreadPools.getGeneralScheduledExecutorService depends on the configuration having a value for Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE. Should this logic be moved into ThreadPools.getGeneralScheduledExecutorService?", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555101347", "createdAt": "2021-01-11T14:52:58Z", "author": {"login": "brianloss"}, "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -59,18 +60,20 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+    final ConfigurationCopy cc = new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = cc.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    if (null == size || size.isEmpty()) {\n+      cc.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b818173015c5e9c42246b11836060d86a34d5c1"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTExMDgyMg==", "bodyText": "I like the fact that previously the timer thread would have BatchWriter in its name. Only latency timer makes it just a little harder to figure out when looking at a thread dump, IMO.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"latency timer\", () -> {\n          \n          \n            \n                  executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"BatchWriterLatencyTimer\", () -> {", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555110822", "createdAt": "2021-01-11T15:06:03Z", "author": {"login": "brianloss"}, "path": "core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java", "diffHunk": "@@ -209,20 +210,17 @@ public TabletServerBatchWriter(ClientContext context, BatchWriterConfig config)\n     this.writer = new MutationWriter(config.getMaxWriteThreads());\n \n     if (this.maxLatency != Long.MAX_VALUE) {\n-      jtimer.schedule(new TimerTask() {\n-        @Override\n-        public void run() {\n-          try {\n-            synchronized (TabletServerBatchWriter.this) {\n-              if ((System.currentTimeMillis() - lastProcessingStartTime)\n-                  > TabletServerBatchWriter.this.maxLatency)\n-                startProcessing();\n-            }\n-          } catch (Throwable t) {\n-            updateUnknownErrors(\"Max latency task failed \" + t.getMessage(), t);\n+      executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"latency timer\", () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b818173015c5e9c42246b11836060d86a34d5c1"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTExNTcwOQ==", "bodyText": "Not a super strong opinion, but when I first started reading the code I thought maybe these methods could be returning cached/shared executors. I suggest considering changing all of the methods in this class from \"get*\" to \"create*\" (or \"new*\" to match the pattern in the java.util.concurrent.Executors class) to make it explicit that they are always creating a resource.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555115709", "createdAt": "2021-01-11T15:13:05Z", "author": {"login": "brianloss"}, "path": "core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util.threads;\n+\n+import java.util.OptionalInt;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+\n+public class ThreadPools {\n+\n+  // the number of seconds before we allow a thread to terminate with non-use.\n+  public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n+\n+  /**\n+   * Get a thread pool based on a thread pool related property\n+   *\n+   * @param conf\n+   *          accumulo configuration\n+   * @param p\n+   *          thread pool related property\n+   * @return ExecutorService impl\n+   * @throws RuntimeException\n+   *           if property is not handled\n+   */\n+  public static ExecutorService getExecutorService(AccumuloConfiguration conf, Property p) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b818173015c5e9c42246b11836060d86a34d5c1"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEyMjc0OA==", "bodyText": "Just a nit, but it doesn't appear that the initialization of thread is any different based on the type of Runnable passed in. Why not move the initialization up? Maybe something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Thread thread = null;\n          \n          \n            \n                if (r instanceof NamedRunnable) {\n          \n          \n            \n                  NamedRunnable nr = (NamedRunnable) r;\n          \n          \n            \n                  thread = new Thread(r, name);\n          \n          \n            \n                  if (nr.getPriority().isPresent()) {\n          \n          \n            \n                    thread.setPriority(nr.getPriority().getAsInt());\n          \n          \n            \n                  } else if (priority.isPresent()) {\n          \n          \n            \n                    thread.setPriority(priority.getAsInt());\n          \n          \n            \n                  }\n          \n          \n            \n                } else {\n          \n          \n            \n                  thread = new Thread(r, name);\n          \n          \n            \n                  if (priority.isPresent()) {\n          \n          \n            \n                    thread.setPriority(priority.getAsInt());\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                Thread thread = new Thread(r, name);\n          \n          \n            \n                if (r instanceof NamedRunnable) {\n          \n          \n            \n                  NamedRunnable nr = (NamedRunnable) r;\n          \n          \n            \n                  if (nr.getPriority().isPresent()) {\n          \n          \n            \n                    priority = nr.getPriority();\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                if (priority.isPresent()) {\n          \n          \n            \n                  thread.setPriority(priority.getAsInt());\n          \n          \n            \n                }", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555122748", "createdAt": "2021-01-11T15:22:56Z", "author": {"login": "brianloss"}, "path": "core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util.threads;\n+\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.util.OptionalInt;\n+\n+public class Threads {\n+\n+  public static Runnable createNamedRunnable(String name, Runnable r) {\n+    return new NamedRunnable(name, r);\n+  }\n+\n+  public static Runnable createNamedRunnable(String name, OptionalInt priority, Runnable r) {\n+    return new NamedRunnable(name, priority, r);\n+  }\n+\n+  private static final UncaughtExceptionHandler UEH = new AccumuloUncaughtExceptionHandler();\n+\n+  public static Thread createThread(String name, Runnable r) {\n+    return createThread(name, OptionalInt.empty(), r);\n+  }\n+\n+  public static Thread createThread(String name, OptionalInt priority, Runnable r) {\n+    Thread thread = null;\n+    if (r instanceof NamedRunnable) {\n+      NamedRunnable nr = (NamedRunnable) r;\n+      thread = new Thread(r, name);\n+      if (nr.getPriority().isPresent()) {\n+        thread.setPriority(nr.getPriority().getAsInt());\n+      } else if (priority.isPresent()) {\n+        thread.setPriority(priority.getAsInt());\n+      }\n+    } else {\n+      thread = new Thread(r, name);\n+      if (priority.isPresent()) {\n+        thread.setPriority(priority.getAsInt());\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b818173015c5e9c42246b11836060d86a34d5c1"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE0ODU5NA==", "bodyText": "From reading the discussion here, it sounds like there's some uncertainty of what action to take if we get here. Did Ivan or Drew ever weigh in again? I think Christopher's arguments make sense, but am just wondering if it's worth adding configuration to skip halting the tserver? The main reason I suggest that is if there's some unanticipated case where this is hit and it has a big impact on production systems. At least in such a case it could be disabled with a configuration change vs a re-release and deployment of Accumulo. I only suggest that given the uncertainty of whether or not this is too severe of a response to uncaught errors.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555148594", "createdAt": "2021-01-11T15:54:29Z", "author": {"login": "brianloss"}, "path": "core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java", "diffHunk": "@@ -16,20 +16,36 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.accumulo.core.util;\n+package org.apache.accumulo.core.util.threads;\n \n import java.lang.Thread.UncaughtExceptionHandler;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n+/**\n+ * UncaughtExceptionHandler that logs all Exceptions and Errors thrown from a Thread. If an Error is\n+ * thrown, halt the JVM.\n+ *\n+ */\n+class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n-  private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n+  private static final Logger LOG = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n-    log.error(String.format(\"Caught an exception in %s.  Shutting down.\", t), e);\n+    if (e instanceof Exception) {\n+      LOG.error(\"Caught an Exception in {}. Thread is dead.\", t, e);\n+    } else if (e instanceof Error) {\n+      try {\n+        e.printStackTrace();\n+        System.err.println(\"Error thrown in thread: \" + t + \", halting VM.\");\n+      } catch (Throwable e1) {\n+        // If e == OutOfMemoryError, then it's probably that another Error might be\n+        // thrown when trying to print to System.err.\n+      } finally {\n+        Runtime.getRuntime().halt(-1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, "originalCommit": {"oid": "e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7957d8240581ce74a942c4858cf452bbb2067b90", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/7957d8240581ce74a942c4858cf452bbb2067b90", "committedDate": "2021-01-11T17:02:52Z", "message": "re #1808: addressing PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180", "author": {"user": {"login": "ctubbsii", "name": "Christopher Tubbs"}}, "url": "https://github.com/apache/accumulo/commit/8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180", "committedDate": "2021-01-13T05:44:26Z", "message": "Merge branch 'main' into 1808-thread-errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2OTI1NDA5", "url": "https://github.com/apache/accumulo/pull/1818#pullrequestreview-566925409", "createdAt": "2021-01-13T06:32:14Z", "commit": {"oid": "8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwNjozMjoxNFrOIShRiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwNjo0MjowMFrOISheQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MDQ0Mw==", "bodyText": "This updates the context using the ConfigurationCopy instead of the contextConfigSupplier, which would provide it on-demand. Using the ConfigurationCopy means it will get the same initial value every time the thread executes, and will never see the updated value of VFS_CONTEXT_CLASSPATH_PROPERTY if it changes.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556290443", "createdAt": "2021-01-13T06:32:14Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -59,18 +60,20 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+    final ConfigurationCopy cc = new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = cc.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    if (null == size || size.isEmpty()) {\n+      cc.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n+    }\n+    ThreadPools.createGeneralScheduledExecutorService(cc)\n+        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, cc);\n+          Set<String> contextsInUse = cc\n+              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MjY4OQ==", "bodyText": "Would this work?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  task = Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", () -> {\n          \n          \n            \n                    run();\n          \n          \n            \n                  });\n          \n          \n            \n                  task = Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", this::run);", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556292689", "createdAt": "2021-01-13T06:38:59Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java", "diffHunk": "@@ -571,13 +570,17 @@ private synchronized void addFailedMutations(MutationSet failedMutations) {\n     }\n   }\n \n-  private class FailedMutations extends TimerTask {\n+  private class FailedMutations {\n \n     private MutationSet recentFailures = null;\n     private long initTime;\n+    private final Runnable task;\n \n     FailedMutations() {\n-      jtimer.schedule(this, 0, 500);\n+      task = Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", () -> {\n+        run();\n+      });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MzY5Ng==", "bodyText": "Is it legal to switch to a Daemon thread after it has already started executing? Will this have any effect?", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556293696", "createdAt": "2021-01-13T06:42:00Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/util/Halt.java", "diffHunk": "@@ -51,9 +50,10 @@ public void run() {\n   public static void halt(final int status, Runnable runnable) {\n     try {\n       // give ourselves a little time to try and do something\n-      new Daemon() {\n+      new Thread() {\n         @Override\n         public void run() {\n+          setDaemon(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30f63b14b8d638ed6d641d493379586cf5f9e42d", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/30f63b14b8d638ed6d641d493379586cf5f9e42d", "committedDate": "2021-01-13T13:55:26Z", "message": "re #1808 - addressing PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MjQ5NzI1", "url": "https://github.com/apache/accumulo/pull/1818#pullrequestreview-567249725", "createdAt": "2021-01-13T14:03:32Z", "commit": {"oid": "30f63b14b8d638ed6d641d493379586cf5f9e42d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxNDowMzozMlrOISwmoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxNDowMzozMlrOISwmoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0MTYwMQ==", "bodyText": "We should avoid using Hadoop's Daemon. I doubt that is stable public API. Even if it is, we don't want to increase our dependency on Hadoop library code for this. It should be simple to construct the object assigned to a local variable, set it to daemon, and start it in 3 statements, rather than rely on a the Hadoop library.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556541601", "createdAt": "2021-01-13T14:03:32Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/util/Halt.java", "diffHunk": "@@ -50,10 +51,9 @@ public void run() {\n   public static void halt(final int status, Runnable runnable) {\n     try {\n       // give ourselves a little time to try and do something\n-      new Thread() {\n+      new Daemon() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30f63b14b8d638ed6d641d493379586cf5f9e42d"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "137f7859f81a89744da60c7b0849a1041b178119", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/137f7859f81a89744da60c7b0849a1041b178119", "committedDate": "2021-01-13T14:41:54Z", "message": "re #1808 - don't use Hadoop Daemon class and other changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MzAwMjk5", "url": "https://github.com/apache/accumulo/pull/1818#pullrequestreview-567300299", "createdAt": "2021-01-13T14:53:52Z", "commit": {"oid": "137f7859f81a89744da60c7b0849a1041b178119"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxNDo1Mzo1MlrOISy2xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxNTowMDo0MVrOISzMvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU3ODUwMg==", "bodyText": "Reading properties other than those that start with the VFS_CONTEXT_CLASSPATH_PROPERTY won't work here, because the contextConfigSupplier already filters out all other properties. So, you can't read the SIMPLETIMER properties from this map.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556578502", "createdAt": "2021-01-13T14:53:52Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -59,18 +60,23 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+    final ConfigurationCopy threadPoolProperties =\n+        new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    if (null == size || size.isEmpty()) {\n+      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "137f7859f81a89744da60c7b0849a1041b178119"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU4MDgyMA==", "bodyText": "Placing it in a new ConfigurationCopy to use the method that strips the property prefix out seems a bit more work than the old code did. The contextConfigSupplier already filters matching items, so all we need to do is strip out the prefix. We can avoid creating a new ConfigurationCopy object for this.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556580820", "createdAt": "2021-01-13T14:56:39Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -59,18 +60,23 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+    final ConfigurationCopy threadPoolProperties =\n+        new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    if (null == size || size.isEmpty()) {\n+      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n+    }\n+    ThreadPools.createGeneralScheduledExecutorService(threadPoolProperties)\n+        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n+          ConfigurationCopy contextCleanerProperties =\n+              new ConfigurationCopy(contextConfigSupplier.get());\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, threadPoolProperties);\n+          Set<String> contextsInUse = contextCleanerProperties\n+              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "137f7859f81a89744da60c7b0849a1041b178119"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU4NDEyNw==", "bodyText": "With a lambda, this would be slightly shorter:\n      Threads.createThread(\"Halt Thread\", () -> {\n        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n        Runtime.getRuntime().halt(status);\n      }).start();", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556584127", "createdAt": "2021-01-13T15:00:41Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/util/Halt.java", "diffHunk": "@@ -49,15 +49,16 @@ public void run() {\n   }\n \n   public static void halt(final int status, Runnable runnable) {\n+\n     try {\n       // give ourselves a little time to try and do something\n-      new Daemon() {\n+      Threads.createThread(\"Halt Thread\", new Runnable() {\n         @Override\n         public void run() {\n           sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n           Runtime.getRuntime().halt(status);\n         }\n-      }.start();\n+      }).start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "137f7859f81a89744da60c7b0849a1041b178119"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "370bb25fb6fb640647a2e8ce0076a6e3600b3b79", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/370bb25fb6fb640647a2e8ce0076a6e3600b3b79", "committedDate": "2021-01-13T16:10:14Z", "message": "re #1808: Don't create two ConfigurationCopy instances"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c479969590703e3ce7f99485f7389fda24f03259", "author": {"user": {"login": "ctubbsii", "name": "Christopher Tubbs"}}, "url": "https://github.com/apache/accumulo/commit/c479969590703e3ce7f99485f7389fda24f03259", "committedDate": "2021-01-13T16:41:29Z", "message": "Merge branch 'main' into 1808-thread-errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NDI4OTEz", "url": "https://github.com/apache/accumulo/pull/1818#pullrequestreview-567428913", "createdAt": "2021-01-13T16:56:24Z", "commit": {"oid": "c479969590703e3ce7f99485f7389fda24f03259"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxNjo1NjoyNFrOIS5D9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxNjo1NjoyNFrOIS5D9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY4MDE4MA==", "bodyText": "Two things are wrong with this filter line:\n\nThis is using the enum name(), when it should be filtering on the enum's getKey() method, and\nIt's not even necessary to execute this filter, because the contextConfigSupplier already performs this filter.", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556680180", "createdAt": "2021-01-13T16:56:24Z", "author": {"login": "ctubbsii"}, "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -55,22 +56,21 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n         () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n     AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(contextConfigSupplier);\n+    startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n-  private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+  private static void startCleanupThread(final AccumuloConfiguration conf,\n+      final Supplier<Map<String,String>> contextConfigSupplier) {\n+    ThreadPools.createGeneralScheduledExecutorService(conf)\n+        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n+          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n+              .filter(k -> k.startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.name()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c479969590703e3ce7f99485f7389fda24f03259"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5153181e5002cc4ea8ade6b747fac66659e64e99", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/5153181e5002cc4ea8ade6b747fac66659e64e99", "committedDate": "2021-01-13T17:08:50Z", "message": "re #1808 - simplify Halt daemon thread, remove errant filter command"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da18f062d8a64757f9bf0a31b09c91f7ac225866", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/da18f062d8a64757f9bf0a31b09c91f7ac225866", "committedDate": "2021-01-13T17:10:46Z", "message": "Merge branch '1808-thread-errors' of github.com:dlmarion/accumulo into 1808-thread-errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3ODIwMTM4", "url": "https://github.com/apache/accumulo/pull/1818#pullrequestreview-567820138", "createdAt": "2021-01-14T03:06:47Z", "commit": {"oid": "da18f062d8a64757f9bf0a31b09c91f7ac225866"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35657242bedbc6c0850cfef9bdef44bd9de82256", "author": {"user": {"login": "dlmarion", "name": "Dave Marion"}}, "url": "https://github.com/apache/accumulo/commit/35657242bedbc6c0850cfef9bdef44bd9de82256", "committedDate": "2021-01-19T11:53:20Z", "message": "Merge branch 'main' into 1808-thread-errors"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1663, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}