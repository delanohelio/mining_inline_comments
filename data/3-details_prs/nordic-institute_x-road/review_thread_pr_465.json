{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0MTcwNjA3", "number": 465, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMTo0MjozNlrOD4AaKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjo0MjoxMlrOD4Bo-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDUzNTQ0OnYy", "diffSide": "LEFT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMTo0MjozNlrOGOljlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNTo1NDo1MlrOGPzbGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk0ODU2NQ==", "bodyText": "globalConfService is not used anymore so it can be removed from this class.", "url": "https://github.com/nordic-institute/X-Road/pull/465#discussion_r417948565", "createdAt": "2020-04-30T11:42:36Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -313,108 +381,161 @@ private ServiceClientDto accessRightTypeToServiceClientDto(AccessRightType acces\n     }\n \n     /**\n-     * Add access rights to given endpoint\n+     * Add access rights for (possibly) multiple subjects, to a given endpoint\n      *\n-     * @param subjectIds\n-     * @param clientType\n-     * @param endpoint\n+     * @param subjectIds access rights subjects to grant access for, \"service clients\"\n+     * @param clientType endpoint owner\n+     * @param endpoint endpoint to add access rights to\n+     * @return map, key = subjectId (service client), value = list of access rights added for the subject\n+     * @throws DuplicateAccessRightException if trying to add existing access right\n+     */\n+    private Map<XRoadId, List<ServiceClientAccessRightDto>> addAccessRights(Set<XRoadId> subjectIds,\n+            ClientType clientType, EndpointType endpoint)\n+            throws DuplicateAccessRightException, LocalGroupNotFoundException {\n+        List<EndpointType> endpoints = Collections.singletonList(endpoint);\n+        return addAccessRightsInternal(subjectIds, clientType, endpoints);\n+    }\n+\n+    /**\n+     * Add access rights for (possibly) multiple subjects, to (possibly) multiple endpoints.\n+     *\n+     * This method is not intended for use from outside, but is package protected for tests.\n+     *\n+     * @param subjectIds access rights subjects to grant access for, \"service clients\"\n+     * @param clientType endpoint owner\n+     * @param endpoints endpoints to add access rights to\n+     * @return map, key = subjectId (service client), value = list of access rights added for the subject\n      * @throws DuplicateAccessRightException if trying to add existing access right\n      */\n-    private void addAccessRights(Set<XRoadId> subjectIds, ClientType clientType, EndpointType endpoint)\n+    Map<XRoadId, List<ServiceClientAccessRightDto>> addAccessRightsInternal(Set<XRoadId> subjectIds,\n+            ClientType clientType, List<EndpointType> endpoints)\n             throws DuplicateAccessRightException, LocalGroupNotFoundException {\n         Date now = new Date();\n \n-        List<LocalGroupType> clientLocalGroups = clientType.getLocalGroup();\n+        if (subjectIds == null || subjectIds.isEmpty()) {\n+            throw new IllegalArgumentException(\"missing subjectIds\");\n+        }\n+        if (endpoints == null || endpoints.isEmpty()) {\n+            throw new IllegalArgumentException(\"missing endpoints\");\n+        }\n \n-        for (XRoadId subjectId : subjectIds) {\n-            // A LocalGroup must belong to this client\n-            if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n-                LocalGroupId localGroupId = (LocalGroupId) subjectId;\n-                boolean localGroupNotFound = clientLocalGroups.stream()\n-                        .noneMatch(localGroupType -> localGroupType.getGroupCode()\n-                                .equals(localGroupId.getGroupCode()));\n-                if (localGroupNotFound) {\n-                    String errorMsg = String.format(\"LocalGroup with the groupCode %s does not belong to client %s\",\n-                            subjectId.toShortString(), clientType.getIdentifier().toShortString());\n-                    throw new LocalGroupNotFoundException(errorMsg);\n-                }\n-            }\n-            Optional<AccessRightType> existingAccessRight = clientType.getAcl().stream()\n-                    .filter(accessRightType -> accessRightType.getSubjectId().equals(subjectId))\n-                    .findFirst();\n+        Map<XRoadId, List<ServiceClientAccessRightDto>> addedAccessRights = new HashMap<>();\n \n-            if (existingAccessRight.isPresent() && existingAccessRight.get().getEndpoint().equals(endpoint)) {\n-                throw new DuplicateAccessRightException(\"Subject \" + subjectId.toShortString()\n-                        + \" already has an access right for endpoint \" + endpoint.getId());\n+        for (EndpointType endpoint: endpoints) {\n+            for (XRoadId subjectId : subjectIds) {\n+                ServiceClientAccessRightDto dto = addAccessRightInternal(clientType, now, endpoint, subjectId);\n+                List<ServiceClientAccessRightDto> addedAccessRightsForSubject = addedAccessRights\n+                        .computeIfAbsent(subjectId, k -> new ArrayList<>());\n+                addedAccessRightsForSubject.add(dto);\n             }\n-            AccessRightType newAccessRight = new AccessRightType();\n-            newAccessRight.setEndpoint(endpoint);\n-            newAccessRight.setSubjectId(subjectId);\n-            newAccessRight.setRightsGiven(now);\n-            clientType.getAcl().add(newAccessRight);\n         }\n \n         clientRepository.saveOrUpdate(clientType);\n+        return addedAccessRights;\n     }\n \n-    private Set<XRoadId> mergeSubjectIdsWithLocalgroups(Set<XRoadId> subjectIds, Set<Long> localGroupIds)\n-            throws IdentifierNotFoundException, AccessRightNotFoundException {\n-        // Get persistent entities in order to change relations\n-        Set<XRoadId> txSubjects = new HashSet<>();\n-        if (subjectIds != null && !subjectIds.isEmpty()) {\n-            txSubjects.addAll(getOrPersistSubsystemIds(subjectIds.stream()\n-                    .filter(xRoadId -> xRoadId.getObjectType() == XRoadObjectType.SUBSYSTEM)\n-                    .collect(Collectors.toSet())));\n-            txSubjects.addAll(getOrPersistGlobalGroupIds(subjectIds.stream()\n-                    .filter(xRoadId -> xRoadId.getObjectType() == XRoadObjectType.GLOBALGROUP)\n-                    .collect(Collectors.toSet())));\n-        }\n-        if (localGroupIds != null && localGroupIds.size() > 0) {\n-            Set<XRoadId> localGroupXroadIds = null;\n-            try {\n-                localGroupXroadIds = localGroupService.getLocalGroupIdsAsXroadIds(localGroupIds);\n-            } catch (LocalGroupNotFoundException e) {\n-                throw new AccessRightNotFoundException(e);\n+    /**\n+     * Add access right for a single subject (subjectId), to a single endpoint (endpoint) that belongs to clientType\n+     * @param clientType\n+     * @param rightsGiven\n+     * @param endpoint\n+     * @param subjectId\n+     * @return\n+     * @throws LocalGroupNotFoundException if local group does not exist for given client\n+     * @throws DuplicateAccessRightException if access righ already exists\n+     */\n+    private ServiceClientAccessRightDto addAccessRightInternal(ClientType clientType, Date rightsGiven,\n+            EndpointType endpoint, XRoadId subjectId)\n+            throws LocalGroupNotFoundException, DuplicateAccessRightException {\n+\n+        // A LocalGroup must belong to this client\n+        List<LocalGroupType> clientLocalGroups = clientType.getLocalGroup();\n+\n+        if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n+            LocalGroupId localGroupId = (LocalGroupId) subjectId;\n+            boolean localGroupNotFound = clientLocalGroups.stream()\n+                    .noneMatch(localGroupType -> localGroupType.getGroupCode()\n+                            .equals(localGroupId.getGroupCode()));\n+            if (localGroupNotFound) {\n+                String errorMsg = String.format(\"LocalGroup with the groupCode %s does not belong to client %s\",\n+                        subjectId.toShortString(), clientType.getIdentifier().toShortString());\n+                throw new LocalGroupNotFoundException(errorMsg);\n             }\n-            // Get LocalGroupIds from serverconf db - or save them if they don't exist\n-            Set<XRoadId> txLocalGroupXroadIds = identifierService.getOrPersistXroadIds(localGroupXroadIds);\n-            txSubjects.addAll(txLocalGroupXroadIds);\n         }\n-        return txSubjects;\n-    }\n \n-    /**\n-     * Verify that all identifiers are authentic, then get the existing ones from the local db and persist\n-     * the not-existing ones. This is a necessary step if we are changing identifier relations (such as adding\n-     * access rights to services)\n-     * @param subsystemIds {@link GlobalGroupId} or {@link ClientId}\n-     * @return List of XRoadIds ({@link GlobalGroupId} or {@link ClientId})\n-     */\n-    private Set<XRoadId> getOrPersistSubsystemIds(Set<XRoadId> subsystemIds)\n-            throws IdentifierNotFoundException {\n-        // Check that the identifiers exist in globalconf\n-        // LocalGroups must be verified separately! (they do not exist in globalconf)\n-        if (!globalConfService.clientIdentifiersExist(subsystemIds)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1447f5cd865e482726850f1af514d162fa89c51"}, "originalPosition": 344}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyNDM0Ng==", "bodyText": "removed", "url": "https://github.com/nordic-institute/X-Road/pull/465#discussion_r419224346", "createdAt": "2020-05-04T05:54:52Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -313,108 +381,161 @@ private ServiceClientDto accessRightTypeToServiceClientDto(AccessRightType acces\n     }\n \n     /**\n-     * Add access rights to given endpoint\n+     * Add access rights for (possibly) multiple subjects, to a given endpoint\n      *\n-     * @param subjectIds\n-     * @param clientType\n-     * @param endpoint\n+     * @param subjectIds access rights subjects to grant access for, \"service clients\"\n+     * @param clientType endpoint owner\n+     * @param endpoint endpoint to add access rights to\n+     * @return map, key = subjectId (service client), value = list of access rights added for the subject\n+     * @throws DuplicateAccessRightException if trying to add existing access right\n+     */\n+    private Map<XRoadId, List<ServiceClientAccessRightDto>> addAccessRights(Set<XRoadId> subjectIds,\n+            ClientType clientType, EndpointType endpoint)\n+            throws DuplicateAccessRightException, LocalGroupNotFoundException {\n+        List<EndpointType> endpoints = Collections.singletonList(endpoint);\n+        return addAccessRightsInternal(subjectIds, clientType, endpoints);\n+    }\n+\n+    /**\n+     * Add access rights for (possibly) multiple subjects, to (possibly) multiple endpoints.\n+     *\n+     * This method is not intended for use from outside, but is package protected for tests.\n+     *\n+     * @param subjectIds access rights subjects to grant access for, \"service clients\"\n+     * @param clientType endpoint owner\n+     * @param endpoints endpoints to add access rights to\n+     * @return map, key = subjectId (service client), value = list of access rights added for the subject\n      * @throws DuplicateAccessRightException if trying to add existing access right\n      */\n-    private void addAccessRights(Set<XRoadId> subjectIds, ClientType clientType, EndpointType endpoint)\n+    Map<XRoadId, List<ServiceClientAccessRightDto>> addAccessRightsInternal(Set<XRoadId> subjectIds,\n+            ClientType clientType, List<EndpointType> endpoints)\n             throws DuplicateAccessRightException, LocalGroupNotFoundException {\n         Date now = new Date();\n \n-        List<LocalGroupType> clientLocalGroups = clientType.getLocalGroup();\n+        if (subjectIds == null || subjectIds.isEmpty()) {\n+            throw new IllegalArgumentException(\"missing subjectIds\");\n+        }\n+        if (endpoints == null || endpoints.isEmpty()) {\n+            throw new IllegalArgumentException(\"missing endpoints\");\n+        }\n \n-        for (XRoadId subjectId : subjectIds) {\n-            // A LocalGroup must belong to this client\n-            if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n-                LocalGroupId localGroupId = (LocalGroupId) subjectId;\n-                boolean localGroupNotFound = clientLocalGroups.stream()\n-                        .noneMatch(localGroupType -> localGroupType.getGroupCode()\n-                                .equals(localGroupId.getGroupCode()));\n-                if (localGroupNotFound) {\n-                    String errorMsg = String.format(\"LocalGroup with the groupCode %s does not belong to client %s\",\n-                            subjectId.toShortString(), clientType.getIdentifier().toShortString());\n-                    throw new LocalGroupNotFoundException(errorMsg);\n-                }\n-            }\n-            Optional<AccessRightType> existingAccessRight = clientType.getAcl().stream()\n-                    .filter(accessRightType -> accessRightType.getSubjectId().equals(subjectId))\n-                    .findFirst();\n+        Map<XRoadId, List<ServiceClientAccessRightDto>> addedAccessRights = new HashMap<>();\n \n-            if (existingAccessRight.isPresent() && existingAccessRight.get().getEndpoint().equals(endpoint)) {\n-                throw new DuplicateAccessRightException(\"Subject \" + subjectId.toShortString()\n-                        + \" already has an access right for endpoint \" + endpoint.getId());\n+        for (EndpointType endpoint: endpoints) {\n+            for (XRoadId subjectId : subjectIds) {\n+                ServiceClientAccessRightDto dto = addAccessRightInternal(clientType, now, endpoint, subjectId);\n+                List<ServiceClientAccessRightDto> addedAccessRightsForSubject = addedAccessRights\n+                        .computeIfAbsent(subjectId, k -> new ArrayList<>());\n+                addedAccessRightsForSubject.add(dto);\n             }\n-            AccessRightType newAccessRight = new AccessRightType();\n-            newAccessRight.setEndpoint(endpoint);\n-            newAccessRight.setSubjectId(subjectId);\n-            newAccessRight.setRightsGiven(now);\n-            clientType.getAcl().add(newAccessRight);\n         }\n \n         clientRepository.saveOrUpdate(clientType);\n+        return addedAccessRights;\n     }\n \n-    private Set<XRoadId> mergeSubjectIdsWithLocalgroups(Set<XRoadId> subjectIds, Set<Long> localGroupIds)\n-            throws IdentifierNotFoundException, AccessRightNotFoundException {\n-        // Get persistent entities in order to change relations\n-        Set<XRoadId> txSubjects = new HashSet<>();\n-        if (subjectIds != null && !subjectIds.isEmpty()) {\n-            txSubjects.addAll(getOrPersistSubsystemIds(subjectIds.stream()\n-                    .filter(xRoadId -> xRoadId.getObjectType() == XRoadObjectType.SUBSYSTEM)\n-                    .collect(Collectors.toSet())));\n-            txSubjects.addAll(getOrPersistGlobalGroupIds(subjectIds.stream()\n-                    .filter(xRoadId -> xRoadId.getObjectType() == XRoadObjectType.GLOBALGROUP)\n-                    .collect(Collectors.toSet())));\n-        }\n-        if (localGroupIds != null && localGroupIds.size() > 0) {\n-            Set<XRoadId> localGroupXroadIds = null;\n-            try {\n-                localGroupXroadIds = localGroupService.getLocalGroupIdsAsXroadIds(localGroupIds);\n-            } catch (LocalGroupNotFoundException e) {\n-                throw new AccessRightNotFoundException(e);\n+    /**\n+     * Add access right for a single subject (subjectId), to a single endpoint (endpoint) that belongs to clientType\n+     * @param clientType\n+     * @param rightsGiven\n+     * @param endpoint\n+     * @param subjectId\n+     * @return\n+     * @throws LocalGroupNotFoundException if local group does not exist for given client\n+     * @throws DuplicateAccessRightException if access righ already exists\n+     */\n+    private ServiceClientAccessRightDto addAccessRightInternal(ClientType clientType, Date rightsGiven,\n+            EndpointType endpoint, XRoadId subjectId)\n+            throws LocalGroupNotFoundException, DuplicateAccessRightException {\n+\n+        // A LocalGroup must belong to this client\n+        List<LocalGroupType> clientLocalGroups = clientType.getLocalGroup();\n+\n+        if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n+            LocalGroupId localGroupId = (LocalGroupId) subjectId;\n+            boolean localGroupNotFound = clientLocalGroups.stream()\n+                    .noneMatch(localGroupType -> localGroupType.getGroupCode()\n+                            .equals(localGroupId.getGroupCode()));\n+            if (localGroupNotFound) {\n+                String errorMsg = String.format(\"LocalGroup with the groupCode %s does not belong to client %s\",\n+                        subjectId.toShortString(), clientType.getIdentifier().toShortString());\n+                throw new LocalGroupNotFoundException(errorMsg);\n             }\n-            // Get LocalGroupIds from serverconf db - or save them if they don't exist\n-            Set<XRoadId> txLocalGroupXroadIds = identifierService.getOrPersistXroadIds(localGroupXroadIds);\n-            txSubjects.addAll(txLocalGroupXroadIds);\n         }\n-        return txSubjects;\n-    }\n \n-    /**\n-     * Verify that all identifiers are authentic, then get the existing ones from the local db and persist\n-     * the not-existing ones. This is a necessary step if we are changing identifier relations (such as adding\n-     * access rights to services)\n-     * @param subsystemIds {@link GlobalGroupId} or {@link ClientId}\n-     * @return List of XRoadIds ({@link GlobalGroupId} or {@link ClientId})\n-     */\n-    private Set<XRoadId> getOrPersistSubsystemIds(Set<XRoadId> subsystemIds)\n-            throws IdentifierNotFoundException {\n-        // Check that the identifiers exist in globalconf\n-        // LocalGroups must be verified separately! (they do not exist in globalconf)\n-        if (!globalConfService.clientIdentifiersExist(subsystemIds)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk0ODU2NQ=="}, "originalCommit": {"oid": "e1447f5cd865e482726850f1af514d162fa89c51"}, "originalPosition": 344}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDY5MjUxOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjoyOToyMVrOGOnCOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDo0ODo1MlrOGQtDuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk3Mjc5Mw==", "bodyText": "Javadoc throws not in sync (missing LocalGroupNotFoundException)", "url": "https://github.com/nordic-institute/X-Road/pull/465#discussion_r417972793", "createdAt": "2020-04-30T12:29:21Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -313,108 +381,161 @@ private ServiceClientDto accessRightTypeToServiceClientDto(AccessRightType acces\n     }\n \n     /**\n-     * Add access rights to given endpoint\n+     * Add access rights for (possibly) multiple subjects, to a given endpoint\n      *\n-     * @param subjectIds\n-     * @param clientType\n-     * @param endpoint\n+     * @param subjectIds access rights subjects to grant access for, \"service clients\"\n+     * @param clientType endpoint owner\n+     * @param endpoint endpoint to add access rights to\n+     * @return map, key = subjectId (service client), value = list of access rights added for the subject\n+     * @throws DuplicateAccessRightException if trying to add existing access right", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1447f5cd865e482726850f1af514d162fa89c51"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyNDI5OA==", "bodyText": "Did not find this, maybe down to changes after review, but fixed some other Javadoc-throws-not-in-sync. For me checkstyle and Idea return clean result.", "url": "https://github.com/nordic-institute/X-Road/pull/465#discussion_r419224298", "createdAt": "2020-05-04T05:54:43Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -313,108 +381,161 @@ private ServiceClientDto accessRightTypeToServiceClientDto(AccessRightType acces\n     }\n \n     /**\n-     * Add access rights to given endpoint\n+     * Add access rights for (possibly) multiple subjects, to a given endpoint\n      *\n-     * @param subjectIds\n-     * @param clientType\n-     * @param endpoint\n+     * @param subjectIds access rights subjects to grant access for, \"service clients\"\n+     * @param clientType endpoint owner\n+     * @param endpoint endpoint to add access rights to\n+     * @return map, key = subjectId (service client), value = list of access rights added for the subject\n+     * @throws DuplicateAccessRightException if trying to add existing access right", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk3Mjc5Mw=="}, "originalCommit": {"oid": "e1447f5cd865e482726850f1af514d162fa89c51"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE0NzMyMQ==", "bodyText": "Maybe it's fixed in the other branch? Still missing in here", "url": "https://github.com/nordic-institute/X-Road/pull/465#discussion_r420147321", "createdAt": "2020-05-05T14:20:48Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -313,108 +381,161 @@ private ServiceClientDto accessRightTypeToServiceClientDto(AccessRightType acces\n     }\n \n     /**\n-     * Add access rights to given endpoint\n+     * Add access rights for (possibly) multiple subjects, to a given endpoint\n      *\n-     * @param subjectIds\n-     * @param clientType\n-     * @param endpoint\n+     * @param subjectIds access rights subjects to grant access for, \"service clients\"\n+     * @param clientType endpoint owner\n+     * @param endpoint endpoint to add access rights to\n+     * @return map, key = subjectId (service client), value = list of access rights added for the subject\n+     * @throws DuplicateAccessRightException if trying to add existing access right", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk3Mjc5Mw=="}, "originalCommit": {"oid": "e1447f5cd865e482726850f1af514d162fa89c51"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2ODYzMg==", "bodyText": "I don't know why I did not see it the first time. Now that I rechecked, LocalGroupNotFoundException is indeed missing. But I (just) removed that exception from branch https://github.com/nordic-institute/X-Road/tree/XRDDEV-962-remove-service-client-access-rights so maybe that is enough?", "url": "https://github.com/nordic-institute/X-Road/pull/465#discussion_r420168632", "createdAt": "2020-05-05T14:48:52Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -313,108 +381,161 @@ private ServiceClientDto accessRightTypeToServiceClientDto(AccessRightType acces\n     }\n \n     /**\n-     * Add access rights to given endpoint\n+     * Add access rights for (possibly) multiple subjects, to a given endpoint\n      *\n-     * @param subjectIds\n-     * @param clientType\n-     * @param endpoint\n+     * @param subjectIds access rights subjects to grant access for, \"service clients\"\n+     * @param clientType endpoint owner\n+     * @param endpoint endpoint to add access rights to\n+     * @return map, key = subjectId (service client), value = list of access rights added for the subject\n+     * @throws DuplicateAccessRightException if trying to add existing access right", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk3Mjc5Mw=="}, "originalCommit": {"oid": "e1447f5cd865e482726850f1af514d162fa89c51"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDczNzIzOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjo0MjoxMlrOGOneMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzo1MTozMFrOGP12-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk3OTk1Mg==", "bodyText": "The .get() should probably be replaced with orElse(null) for service == null to ever be true. Or am I missing something here now?\nEdit: oh yes the filtering will always return a service", "url": "https://github.com/nordic-institute/X-Road/pull/465#discussion_r417979952", "createdAt": "2020-04-30T12:42:12Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -313,108 +381,161 @@ private ServiceClientDto accessRightTypeToServiceClientDto(AccessRightType acces\n     }\n \n     /**\n-     * Add access rights to given endpoint\n+     * Add access rights for (possibly) multiple subjects, to a given endpoint\n      *\n-     * @param subjectIds\n-     * @param clientType\n-     * @param endpoint\n+     * @param subjectIds access rights subjects to grant access for, \"service clients\"\n+     * @param clientType endpoint owner\n+     * @param endpoint endpoint to add access rights to\n+     * @return map, key = subjectId (service client), value = list of access rights added for the subject\n+     * @throws DuplicateAccessRightException if trying to add existing access right\n+     */\n+    private Map<XRoadId, List<ServiceClientAccessRightDto>> addAccessRights(Set<XRoadId> subjectIds,\n+            ClientType clientType, EndpointType endpoint)\n+            throws DuplicateAccessRightException, LocalGroupNotFoundException {\n+        List<EndpointType> endpoints = Collections.singletonList(endpoint);\n+        return addAccessRightsInternal(subjectIds, clientType, endpoints);\n+    }\n+\n+    /**\n+     * Add access rights for (possibly) multiple subjects, to (possibly) multiple endpoints.\n+     *\n+     * This method is not intended for use from outside, but is package protected for tests.\n+     *\n+     * @param subjectIds access rights subjects to grant access for, \"service clients\"\n+     * @param clientType endpoint owner\n+     * @param endpoints endpoints to add access rights to\n+     * @return map, key = subjectId (service client), value = list of access rights added for the subject\n      * @throws DuplicateAccessRightException if trying to add existing access right\n      */\n-    private void addAccessRights(Set<XRoadId> subjectIds, ClientType clientType, EndpointType endpoint)\n+    Map<XRoadId, List<ServiceClientAccessRightDto>> addAccessRightsInternal(Set<XRoadId> subjectIds,\n+            ClientType clientType, List<EndpointType> endpoints)\n             throws DuplicateAccessRightException, LocalGroupNotFoundException {\n         Date now = new Date();\n \n-        List<LocalGroupType> clientLocalGroups = clientType.getLocalGroup();\n+        if (subjectIds == null || subjectIds.isEmpty()) {\n+            throw new IllegalArgumentException(\"missing subjectIds\");\n+        }\n+        if (endpoints == null || endpoints.isEmpty()) {\n+            throw new IllegalArgumentException(\"missing endpoints\");\n+        }\n \n-        for (XRoadId subjectId : subjectIds) {\n-            // A LocalGroup must belong to this client\n-            if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n-                LocalGroupId localGroupId = (LocalGroupId) subjectId;\n-                boolean localGroupNotFound = clientLocalGroups.stream()\n-                        .noneMatch(localGroupType -> localGroupType.getGroupCode()\n-                                .equals(localGroupId.getGroupCode()));\n-                if (localGroupNotFound) {\n-                    String errorMsg = String.format(\"LocalGroup with the groupCode %s does not belong to client %s\",\n-                            subjectId.toShortString(), clientType.getIdentifier().toShortString());\n-                    throw new LocalGroupNotFoundException(errorMsg);\n-                }\n-            }\n-            Optional<AccessRightType> existingAccessRight = clientType.getAcl().stream()\n-                    .filter(accessRightType -> accessRightType.getSubjectId().equals(subjectId))\n-                    .findFirst();\n+        Map<XRoadId, List<ServiceClientAccessRightDto>> addedAccessRights = new HashMap<>();\n \n-            if (existingAccessRight.isPresent() && existingAccessRight.get().getEndpoint().equals(endpoint)) {\n-                throw new DuplicateAccessRightException(\"Subject \" + subjectId.toShortString()\n-                        + \" already has an access right for endpoint \" + endpoint.getId());\n+        for (EndpointType endpoint: endpoints) {\n+            for (XRoadId subjectId : subjectIds) {\n+                ServiceClientAccessRightDto dto = addAccessRightInternal(clientType, now, endpoint, subjectId);\n+                List<ServiceClientAccessRightDto> addedAccessRightsForSubject = addedAccessRights\n+                        .computeIfAbsent(subjectId, k -> new ArrayList<>());\n+                addedAccessRightsForSubject.add(dto);\n             }\n-            AccessRightType newAccessRight = new AccessRightType();\n-            newAccessRight.setEndpoint(endpoint);\n-            newAccessRight.setSubjectId(subjectId);\n-            newAccessRight.setRightsGiven(now);\n-            clientType.getAcl().add(newAccessRight);\n         }\n \n         clientRepository.saveOrUpdate(clientType);\n+        return addedAccessRights;\n     }\n \n-    private Set<XRoadId> mergeSubjectIdsWithLocalgroups(Set<XRoadId> subjectIds, Set<Long> localGroupIds)\n-            throws IdentifierNotFoundException, AccessRightNotFoundException {\n-        // Get persistent entities in order to change relations\n-        Set<XRoadId> txSubjects = new HashSet<>();\n-        if (subjectIds != null && !subjectIds.isEmpty()) {\n-            txSubjects.addAll(getOrPersistSubsystemIds(subjectIds.stream()\n-                    .filter(xRoadId -> xRoadId.getObjectType() == XRoadObjectType.SUBSYSTEM)\n-                    .collect(Collectors.toSet())));\n-            txSubjects.addAll(getOrPersistGlobalGroupIds(subjectIds.stream()\n-                    .filter(xRoadId -> xRoadId.getObjectType() == XRoadObjectType.GLOBALGROUP)\n-                    .collect(Collectors.toSet())));\n-        }\n-        if (localGroupIds != null && localGroupIds.size() > 0) {\n-            Set<XRoadId> localGroupXroadIds = null;\n-            try {\n-                localGroupXroadIds = localGroupService.getLocalGroupIdsAsXroadIds(localGroupIds);\n-            } catch (LocalGroupNotFoundException e) {\n-                throw new AccessRightNotFoundException(e);\n+    /**\n+     * Add access right for a single subject (subjectId), to a single endpoint (endpoint) that belongs to clientType\n+     * @param clientType\n+     * @param rightsGiven\n+     * @param endpoint\n+     * @param subjectId\n+     * @return\n+     * @throws LocalGroupNotFoundException if local group does not exist for given client\n+     * @throws DuplicateAccessRightException if access righ already exists\n+     */\n+    private ServiceClientAccessRightDto addAccessRightInternal(ClientType clientType, Date rightsGiven,\n+            EndpointType endpoint, XRoadId subjectId)\n+            throws LocalGroupNotFoundException, DuplicateAccessRightException {\n+\n+        // A LocalGroup must belong to this client\n+        List<LocalGroupType> clientLocalGroups = clientType.getLocalGroup();\n+\n+        if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n+            LocalGroupId localGroupId = (LocalGroupId) subjectId;\n+            boolean localGroupNotFound = clientLocalGroups.stream()\n+                    .noneMatch(localGroupType -> localGroupType.getGroupCode()\n+                            .equals(localGroupId.getGroupCode()));\n+            if (localGroupNotFound) {\n+                String errorMsg = String.format(\"LocalGroup with the groupCode %s does not belong to client %s\",\n+                        subjectId.toShortString(), clientType.getIdentifier().toShortString());\n+                throw new LocalGroupNotFoundException(errorMsg);\n             }\n-            // Get LocalGroupIds from serverconf db - or save them if they don't exist\n-            Set<XRoadId> txLocalGroupXroadIds = identifierService.getOrPersistXroadIds(localGroupXroadIds);\n-            txSubjects.addAll(txLocalGroupXroadIds);\n         }\n-        return txSubjects;\n-    }\n \n-    /**\n-     * Verify that all identifiers are authentic, then get the existing ones from the local db and persist\n-     * the not-existing ones. This is a necessary step if we are changing identifier relations (such as adding\n-     * access rights to services)\n-     * @param subsystemIds {@link GlobalGroupId} or {@link ClientId}\n-     * @return List of XRoadIds ({@link GlobalGroupId} or {@link ClientId})\n-     */\n-    private Set<XRoadId> getOrPersistSubsystemIds(Set<XRoadId> subsystemIds)\n-            throws IdentifierNotFoundException {\n-        // Check that the identifiers exist in globalconf\n-        // LocalGroups must be verified separately! (they do not exist in globalconf)\n-        if (!globalConfService.clientIdentifiersExist(subsystemIds)) {\n-            // This exception should be pretty rare since it only occurs if bogus subjects are found\n-            throw new IdentifierNotFoundException();\n+        // list endpoints, which this subject / service client has already been granted access to\n+        Set<EndpointType> existingAccessibleEndpoints = clientType.getAcl().stream()\n+                .filter(accessRightType -> accessRightType.getSubjectId().equals(subjectId))\n+                .map(accessRightType -> accessRightType.getEndpoint())\n+                .collect(Collectors.toSet());\n+\n+        if (existingAccessibleEndpoints.contains(endpoint)) {\n+            throw new DuplicateAccessRightException(\"Subject \" + subjectId.toShortString()\n+                    + \" already has an access right for endpoint \" + endpoint.getId());\n         }\n-        return identifierService.getOrPersistXroadIds(subsystemIds);\n+\n+        AccessRightType newAccessRight = new AccessRightType();\n+        newAccessRight.setEndpoint(endpoint);\n+        newAccessRight.setSubjectId(subjectId);\n+        newAccessRight.setRightsGiven(rightsGiven);\n+        clientType.getAcl().add(newAccessRight);\n+\n+        // return a dto\n+        ServiceClientAccessRightDto dto = ServiceClientAccessRightDto.builder()\n+                .serviceCode(endpoint.getServiceCode())\n+                .rightsGiven(FormatUtils.fromDateToOffsetDateTime(rightsGiven))\n+                .title(getServiceTitle(clientType, endpoint.getServiceCode()))\n+                .build();\n+        return dto;\n+    }\n+\n+    // TO DO: currently duplicate with ServiceClientService, not sure if ServiceClientService will be refactored,\n+    // and what is the correct place if both need this\n+    private String getServiceTitle(ClientType clientType, String serviceCode) {\n+        ServiceType service = clientType.getServiceDescription().stream()\n+                .flatMap(sd -> sd.getService().stream())\n+                .filter(serviceType -> serviceType.getServiceCode().equals(serviceCode))\n+                .findFirst()\n+                .get();\n+\n+        return service == null ? null : service.getTitle();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1447f5cd865e482726850f1af514d162fa89c51"}, "originalPosition": 383}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI2NDI0OA==", "bodyText": "I think this was a real bug? Good catch.\nFixed in 860f81a in branch XRDDEV-962-remove-service-client-access-rights since getServiceTitle has been refactored to a different class and it was easier to fix like that.", "url": "https://github.com/nordic-institute/X-Road/pull/465#discussion_r419264248", "createdAt": "2020-05-04T07:51:30Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -313,108 +381,161 @@ private ServiceClientDto accessRightTypeToServiceClientDto(AccessRightType acces\n     }\n \n     /**\n-     * Add access rights to given endpoint\n+     * Add access rights for (possibly) multiple subjects, to a given endpoint\n      *\n-     * @param subjectIds\n-     * @param clientType\n-     * @param endpoint\n+     * @param subjectIds access rights subjects to grant access for, \"service clients\"\n+     * @param clientType endpoint owner\n+     * @param endpoint endpoint to add access rights to\n+     * @return map, key = subjectId (service client), value = list of access rights added for the subject\n+     * @throws DuplicateAccessRightException if trying to add existing access right\n+     */\n+    private Map<XRoadId, List<ServiceClientAccessRightDto>> addAccessRights(Set<XRoadId> subjectIds,\n+            ClientType clientType, EndpointType endpoint)\n+            throws DuplicateAccessRightException, LocalGroupNotFoundException {\n+        List<EndpointType> endpoints = Collections.singletonList(endpoint);\n+        return addAccessRightsInternal(subjectIds, clientType, endpoints);\n+    }\n+\n+    /**\n+     * Add access rights for (possibly) multiple subjects, to (possibly) multiple endpoints.\n+     *\n+     * This method is not intended for use from outside, but is package protected for tests.\n+     *\n+     * @param subjectIds access rights subjects to grant access for, \"service clients\"\n+     * @param clientType endpoint owner\n+     * @param endpoints endpoints to add access rights to\n+     * @return map, key = subjectId (service client), value = list of access rights added for the subject\n      * @throws DuplicateAccessRightException if trying to add existing access right\n      */\n-    private void addAccessRights(Set<XRoadId> subjectIds, ClientType clientType, EndpointType endpoint)\n+    Map<XRoadId, List<ServiceClientAccessRightDto>> addAccessRightsInternal(Set<XRoadId> subjectIds,\n+            ClientType clientType, List<EndpointType> endpoints)\n             throws DuplicateAccessRightException, LocalGroupNotFoundException {\n         Date now = new Date();\n \n-        List<LocalGroupType> clientLocalGroups = clientType.getLocalGroup();\n+        if (subjectIds == null || subjectIds.isEmpty()) {\n+            throw new IllegalArgumentException(\"missing subjectIds\");\n+        }\n+        if (endpoints == null || endpoints.isEmpty()) {\n+            throw new IllegalArgumentException(\"missing endpoints\");\n+        }\n \n-        for (XRoadId subjectId : subjectIds) {\n-            // A LocalGroup must belong to this client\n-            if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n-                LocalGroupId localGroupId = (LocalGroupId) subjectId;\n-                boolean localGroupNotFound = clientLocalGroups.stream()\n-                        .noneMatch(localGroupType -> localGroupType.getGroupCode()\n-                                .equals(localGroupId.getGroupCode()));\n-                if (localGroupNotFound) {\n-                    String errorMsg = String.format(\"LocalGroup with the groupCode %s does not belong to client %s\",\n-                            subjectId.toShortString(), clientType.getIdentifier().toShortString());\n-                    throw new LocalGroupNotFoundException(errorMsg);\n-                }\n-            }\n-            Optional<AccessRightType> existingAccessRight = clientType.getAcl().stream()\n-                    .filter(accessRightType -> accessRightType.getSubjectId().equals(subjectId))\n-                    .findFirst();\n+        Map<XRoadId, List<ServiceClientAccessRightDto>> addedAccessRights = new HashMap<>();\n \n-            if (existingAccessRight.isPresent() && existingAccessRight.get().getEndpoint().equals(endpoint)) {\n-                throw new DuplicateAccessRightException(\"Subject \" + subjectId.toShortString()\n-                        + \" already has an access right for endpoint \" + endpoint.getId());\n+        for (EndpointType endpoint: endpoints) {\n+            for (XRoadId subjectId : subjectIds) {\n+                ServiceClientAccessRightDto dto = addAccessRightInternal(clientType, now, endpoint, subjectId);\n+                List<ServiceClientAccessRightDto> addedAccessRightsForSubject = addedAccessRights\n+                        .computeIfAbsent(subjectId, k -> new ArrayList<>());\n+                addedAccessRightsForSubject.add(dto);\n             }\n-            AccessRightType newAccessRight = new AccessRightType();\n-            newAccessRight.setEndpoint(endpoint);\n-            newAccessRight.setSubjectId(subjectId);\n-            newAccessRight.setRightsGiven(now);\n-            clientType.getAcl().add(newAccessRight);\n         }\n \n         clientRepository.saveOrUpdate(clientType);\n+        return addedAccessRights;\n     }\n \n-    private Set<XRoadId> mergeSubjectIdsWithLocalgroups(Set<XRoadId> subjectIds, Set<Long> localGroupIds)\n-            throws IdentifierNotFoundException, AccessRightNotFoundException {\n-        // Get persistent entities in order to change relations\n-        Set<XRoadId> txSubjects = new HashSet<>();\n-        if (subjectIds != null && !subjectIds.isEmpty()) {\n-            txSubjects.addAll(getOrPersistSubsystemIds(subjectIds.stream()\n-                    .filter(xRoadId -> xRoadId.getObjectType() == XRoadObjectType.SUBSYSTEM)\n-                    .collect(Collectors.toSet())));\n-            txSubjects.addAll(getOrPersistGlobalGroupIds(subjectIds.stream()\n-                    .filter(xRoadId -> xRoadId.getObjectType() == XRoadObjectType.GLOBALGROUP)\n-                    .collect(Collectors.toSet())));\n-        }\n-        if (localGroupIds != null && localGroupIds.size() > 0) {\n-            Set<XRoadId> localGroupXroadIds = null;\n-            try {\n-                localGroupXroadIds = localGroupService.getLocalGroupIdsAsXroadIds(localGroupIds);\n-            } catch (LocalGroupNotFoundException e) {\n-                throw new AccessRightNotFoundException(e);\n+    /**\n+     * Add access right for a single subject (subjectId), to a single endpoint (endpoint) that belongs to clientType\n+     * @param clientType\n+     * @param rightsGiven\n+     * @param endpoint\n+     * @param subjectId\n+     * @return\n+     * @throws LocalGroupNotFoundException if local group does not exist for given client\n+     * @throws DuplicateAccessRightException if access righ already exists\n+     */\n+    private ServiceClientAccessRightDto addAccessRightInternal(ClientType clientType, Date rightsGiven,\n+            EndpointType endpoint, XRoadId subjectId)\n+            throws LocalGroupNotFoundException, DuplicateAccessRightException {\n+\n+        // A LocalGroup must belong to this client\n+        List<LocalGroupType> clientLocalGroups = clientType.getLocalGroup();\n+\n+        if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n+            LocalGroupId localGroupId = (LocalGroupId) subjectId;\n+            boolean localGroupNotFound = clientLocalGroups.stream()\n+                    .noneMatch(localGroupType -> localGroupType.getGroupCode()\n+                            .equals(localGroupId.getGroupCode()));\n+            if (localGroupNotFound) {\n+                String errorMsg = String.format(\"LocalGroup with the groupCode %s does not belong to client %s\",\n+                        subjectId.toShortString(), clientType.getIdentifier().toShortString());\n+                throw new LocalGroupNotFoundException(errorMsg);\n             }\n-            // Get LocalGroupIds from serverconf db - or save them if they don't exist\n-            Set<XRoadId> txLocalGroupXroadIds = identifierService.getOrPersistXroadIds(localGroupXroadIds);\n-            txSubjects.addAll(txLocalGroupXroadIds);\n         }\n-        return txSubjects;\n-    }\n \n-    /**\n-     * Verify that all identifiers are authentic, then get the existing ones from the local db and persist\n-     * the not-existing ones. This is a necessary step if we are changing identifier relations (such as adding\n-     * access rights to services)\n-     * @param subsystemIds {@link GlobalGroupId} or {@link ClientId}\n-     * @return List of XRoadIds ({@link GlobalGroupId} or {@link ClientId})\n-     */\n-    private Set<XRoadId> getOrPersistSubsystemIds(Set<XRoadId> subsystemIds)\n-            throws IdentifierNotFoundException {\n-        // Check that the identifiers exist in globalconf\n-        // LocalGroups must be verified separately! (they do not exist in globalconf)\n-        if (!globalConfService.clientIdentifiersExist(subsystemIds)) {\n-            // This exception should be pretty rare since it only occurs if bogus subjects are found\n-            throw new IdentifierNotFoundException();\n+        // list endpoints, which this subject / service client has already been granted access to\n+        Set<EndpointType> existingAccessibleEndpoints = clientType.getAcl().stream()\n+                .filter(accessRightType -> accessRightType.getSubjectId().equals(subjectId))\n+                .map(accessRightType -> accessRightType.getEndpoint())\n+                .collect(Collectors.toSet());\n+\n+        if (existingAccessibleEndpoints.contains(endpoint)) {\n+            throw new DuplicateAccessRightException(\"Subject \" + subjectId.toShortString()\n+                    + \" already has an access right for endpoint \" + endpoint.getId());\n         }\n-        return identifierService.getOrPersistXroadIds(subsystemIds);\n+\n+        AccessRightType newAccessRight = new AccessRightType();\n+        newAccessRight.setEndpoint(endpoint);\n+        newAccessRight.setSubjectId(subjectId);\n+        newAccessRight.setRightsGiven(rightsGiven);\n+        clientType.getAcl().add(newAccessRight);\n+\n+        // return a dto\n+        ServiceClientAccessRightDto dto = ServiceClientAccessRightDto.builder()\n+                .serviceCode(endpoint.getServiceCode())\n+                .rightsGiven(FormatUtils.fromDateToOffsetDateTime(rightsGiven))\n+                .title(getServiceTitle(clientType, endpoint.getServiceCode()))\n+                .build();\n+        return dto;\n+    }\n+\n+    // TO DO: currently duplicate with ServiceClientService, not sure if ServiceClientService will be refactored,\n+    // and what is the correct place if both need this\n+    private String getServiceTitle(ClientType clientType, String serviceCode) {\n+        ServiceType service = clientType.getServiceDescription().stream()\n+                .flatMap(sd -> sd.getService().stream())\n+                .filter(serviceType -> serviceType.getServiceCode().equals(serviceCode))\n+                .findFirst()\n+                .get();\n+\n+        return service == null ? null : service.getTitle();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk3OTk1Mg=="}, "originalCommit": {"oid": "e1447f5cd865e482726850f1af514d162fa89c51"}, "originalPosition": 383}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2829, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}