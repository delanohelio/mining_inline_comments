{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNDE0ODQ1", "number": 400, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODo0MTo1NFrODmljaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMToxMjo0NFrODmotDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNzg3NzUzOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/ClientService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODo0MTo1NFrOF0FjKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzoxNDo0M1rOF0OMsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2MTE5Mw==", "bodyText": "Javadocs missing ClientNotFoundException", "url": "https://github.com/nordic-institute/X-Road/pull/400#discussion_r390161193", "createdAt": "2020-03-10T08:41:54Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/ClientService.java", "diffHunk": "@@ -560,6 +565,43 @@ private ClientId getPossiblyManagedEntity(ClientId transientClientId) {\n         }\n     }\n \n+    /**\n+     * Delete a local client.\n+     * @param clientId\n+     * @throws ActionNotPossibleException if client status did not allow delete\n+     * @throws CannotDeleteOwnerException if attempted to delete the owner\n+     */\n+    public void deleteLocalClient(ClientId clientId) throws ActionNotPossibleException,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05947f12d36847cecbd4d6bf239262019c8ed6bb"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMwMjg5OA==", "bodyText": "added", "url": "https://github.com/nordic-institute/X-Road/pull/400#discussion_r390302898", "createdAt": "2020-03-10T13:14:43Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/ClientService.java", "diffHunk": "@@ -560,6 +565,43 @@ private ClientId getPossiblyManagedEntity(ClientId transientClientId) {\n         }\n     }\n \n+    /**\n+     * Delete a local client.\n+     * @param clientId\n+     * @throws ActionNotPossibleException if client status did not allow delete\n+     * @throws CannotDeleteOwnerException if attempted to delete the owner\n+     */\n+    public void deleteLocalClient(ClientId clientId) throws ActionNotPossibleException,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2MTE5Mw=="}, "originalCommit": {"oid": "05947f12d36847cecbd4d6bf239262019c8ed6bb"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODM5Mzc0OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/TokenCertificateService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMToxMjo0NFrOF0KiMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzoxMjo1OFrOF0OIYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI0Mjg2Ng==", "bodyText": "This is probably intentionally a non-atomic operation? Just wondering what happens in a case where some certs are deleted and some are not because in the middle of the deletion process a wild CertificateNotFoundException appears?\nIn the case of removing orphans that shouldn't happen since the certs are not actually provided by the user. This is probably something to be looked more into if we ever need an API endpoint supporting the deletion of multiple certificates.", "url": "https://github.com/nordic-institute/X-Road/pull/400#discussion_r390242866", "createdAt": "2020-03-10T11:12:44Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/TokenCertificateService.java", "diffHunk": "@@ -744,6 +746,35 @@ static boolean isCausedByCertNotFound(CodedException e) {\n         return possibleActions;\n     }\n \n+    /**\n+     * Deletes a collection of certificates\n+     * @throws CertificateNotFoundException if certificate with given hash was not found\n+     * @throws ActionNotPossibleException if delete was not possible due to cert/key/token states\n+     */\n+    public void deleteCertificates(List<CertificateInfo> certificateInfos)\n+            throws CertificateNotFoundException, ActionNotPossibleException {\n+        List<TokenInfo> tokenInfos = tokenService.getAllTokens();\n+        for (CertificateInfo certificateInfo: certificateInfos) {\n+            deleteCertificate(certificateInfo.getId(), tokenInfos);\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05947f12d36847cecbd4d6bf239262019c8ed6bb"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMwMTc5Mw==", "bodyText": "Yeah, it is - kind of - intentional. If some of the certs have been deleted, and an error occurs midway, end result will be partly removed collection of certs.\nI believe the same thing would happen with the old UI implementation: \n  \n    \n      X-Road/src/proxy-ui/app/controllers/clients_controller.rb\n    \n    \n        Lines 407 to 426\n      in\n      05e6443\n    \n    \n    \n    \n\n        \n          \n           SignerProxy::getTokens.each do |token| \n        \n\n        \n          \n             token.keyInfo.each do |key| \n        \n\n        \n          \n               key.certs.each do |cert| \n        \n\n        \n          \n                 if client_id.memberEquals(cert.memberId) \n        \n\n        \n          \n                   audit_log_data[:certHashes] << \n        \n\n        \n          \n                     CommonUi::CertUtils.cert_hash(cert.certificateBytes) \n        \n\n        \n          \n            \n        \n\n        \n          \n                   SignerProxy::deleteCert(cert.id) \n        \n\n        \n          \n                 end \n        \n\n        \n          \n               end \n        \n\n        \n          \n            \n        \n\n        \n          \n               key.certRequests.each do |cert_request| \n        \n\n        \n          \n                 if client_id.memberEquals(cert_request.memberId) \n        \n\n        \n          \n                   audit_log_data[:certRequestIds] << cert_request.id \n        \n\n        \n          \n            \n        \n\n        \n          \n                   SignerProxy::deleteCertRequest(cert_request.id) \n        \n\n        \n          \n                 end \n        \n\n        \n          \n               end \n        \n\n        \n          \n             end \n        \n\n        \n          \n           end \n        \n    \n  \n\n\nI believe atomic deletion would be close to impossible since delete cert is a signer operation and core classes such as TokenManager, SoftwareTokenWorker and HardwareTokenWorker do not have concepts similar to rollbackable transactions?", "url": "https://github.com/nordic-institute/X-Road/pull/400#discussion_r390301793", "createdAt": "2020-03-10T13:12:58Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/TokenCertificateService.java", "diffHunk": "@@ -744,6 +746,35 @@ static boolean isCausedByCertNotFound(CodedException e) {\n         return possibleActions;\n     }\n \n+    /**\n+     * Deletes a collection of certificates\n+     * @throws CertificateNotFoundException if certificate with given hash was not found\n+     * @throws ActionNotPossibleException if delete was not possible due to cert/key/token states\n+     */\n+    public void deleteCertificates(List<CertificateInfo> certificateInfos)\n+            throws CertificateNotFoundException, ActionNotPossibleException {\n+        List<TokenInfo> tokenInfos = tokenService.getAllTokens();\n+        for (CertificateInfo certificateInfo: certificateInfos) {\n+            deleteCertificate(certificateInfo.getId(), tokenInfos);\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI0Mjg2Ng=="}, "originalCommit": {"oid": "05947f12d36847cecbd4d6bf239262019c8ed6bb"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2972, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}