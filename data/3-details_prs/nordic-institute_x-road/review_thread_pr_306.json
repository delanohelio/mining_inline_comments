{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4NjUwNDU1", "number": 306, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxMzowNjo0NlrODWPhjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNDoxODo0OVrODWQrrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NjQ5NjE0OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/PossibleActionsRuleEngine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxMzowNjo0NlrOFa41TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxNTo1NzoyNFrOFbbctQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzczODQ0NA==", "bodyText": "Could be in the same if-block?", "url": "https://github.com/nordic-institute/X-Road/pull/306#discussion_r363738444", "createdAt": "2020-01-07T13:06:46Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/PossibleActionsRuleEngine.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.signer.protocol.dto.CertRequestInfo;\n+import ee.ria.xroad.signer.protocol.dto.CertificateInfo;\n+import ee.ria.xroad.signer.protocol.dto.KeyInfo;\n+import ee.ria.xroad.signer.protocol.dto.KeyUsageInfo;\n+import ee.ria.xroad.signer.protocol.dto.TokenInfo;\n+\n+import org.springframework.stereotype.Component;\n+\n+import java.util.EnumSet;\n+\n+/**\n+ * Validation logic for possible actions done on tokens, keys, certs and csrs\n+ */\n+@Component\n+public class PossibleActionsRuleEngine {\n+\n+    // duplicate definition, since we dont want add direct dependency on signer\n+    public static final String SOFTWARE_TOKEN_ID = \"0\";\n+\n+    /**\n+     * Get possible actions for a token\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleTokenActions(TokenInfo tokenInfo) {\n+        EnumSet<PossibleActionEnum> actions = EnumSet.noneOf(PossibleActionEnum.class);\n+\n+        if (tokenInfo.isActive()) {\n+            actions.add(PossibleActionEnum.GENERATE_KEY);\n+        }\n+\n+        if (tokenInfo.isActive()) {\n+            actions.add(PossibleActionEnum.TOKEN_DEACTIVATE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bd4ee70b4efdfdf596c4b6ea4cdd12d360764b"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMwNTU4OQ==", "bodyText": "It could, but I think I would prefer to keep it separate. I think it helps to be able to look at each PossibleActionEnum value individually and see clearly all the conditions that cause one individual action to be enabled. And that maybe makes it a bit easier to take one action and compare it's rules to the old codebase.\nThis sounds a bit silly since those two tokenInfo.isActive's are so simple and close to each other but that was kind of the thought behind it, it was not completely coincidental. The principle is maybe more clear in getPossibleCertificateActions and getPossibleKeyActions, where I am sure the if-blocks could be optimized, combined and simplified somewhat by combining actions, but keeping them separated is better. And using the same approach for getPossibleTokenActions is nice, IMO.", "url": "https://github.com/nordic-institute/X-Road/pull/306#discussion_r364305589", "createdAt": "2020-01-08T15:57:24Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/PossibleActionsRuleEngine.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.signer.protocol.dto.CertRequestInfo;\n+import ee.ria.xroad.signer.protocol.dto.CertificateInfo;\n+import ee.ria.xroad.signer.protocol.dto.KeyInfo;\n+import ee.ria.xroad.signer.protocol.dto.KeyUsageInfo;\n+import ee.ria.xroad.signer.protocol.dto.TokenInfo;\n+\n+import org.springframework.stereotype.Component;\n+\n+import java.util.EnumSet;\n+\n+/**\n+ * Validation logic for possible actions done on tokens, keys, certs and csrs\n+ */\n+@Component\n+public class PossibleActionsRuleEngine {\n+\n+    // duplicate definition, since we dont want add direct dependency on signer\n+    public static final String SOFTWARE_TOKEN_ID = \"0\";\n+\n+    /**\n+     * Get possible actions for a token\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleTokenActions(TokenInfo tokenInfo) {\n+        EnumSet<PossibleActionEnum> actions = EnumSet.noneOf(PossibleActionEnum.class);\n+\n+        if (tokenInfo.isActive()) {\n+            actions.add(PossibleActionEnum.GENERATE_KEY);\n+        }\n+\n+        if (tokenInfo.isActive()) {\n+            actions.add(PossibleActionEnum.TOKEN_DEACTIVATE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzczODQ0NA=="}, "originalCommit": {"oid": "e4bd4ee70b4efdfdf596c4b6ea4cdd12d360764b"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NjU5MTIyOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/PossibleActionsRuleEngine.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxMzo0NDo1N1rOFa5uwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxNjo0NTowMlrOFbdCpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc1MzE1Mg==", "bodyText": "keyInfo and certRequestInfo not used", "url": "https://github.com/nordic-institute/X-Road/pull/306#discussion_r363753152", "createdAt": "2020-01-07T13:44:57Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/PossibleActionsRuleEngine.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.signer.protocol.dto.CertRequestInfo;\n+import ee.ria.xroad.signer.protocol.dto.CertificateInfo;\n+import ee.ria.xroad.signer.protocol.dto.KeyInfo;\n+import ee.ria.xroad.signer.protocol.dto.KeyUsageInfo;\n+import ee.ria.xroad.signer.protocol.dto.TokenInfo;\n+\n+import org.springframework.stereotype.Component;\n+\n+import java.util.EnumSet;\n+\n+/**\n+ * Validation logic for possible actions done on tokens, keys, certs and csrs\n+ */\n+@Component\n+public class PossibleActionsRuleEngine {\n+\n+    // duplicate definition, since we dont want add direct dependency on signer\n+    public static final String SOFTWARE_TOKEN_ID = \"0\";\n+\n+    /**\n+     * Get possible actions for a token\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleTokenActions(TokenInfo tokenInfo) {\n+        EnumSet<PossibleActionEnum> actions = EnumSet.noneOf(PossibleActionEnum.class);\n+\n+        if (tokenInfo.isActive()) {\n+            actions.add(PossibleActionEnum.GENERATE_KEY);\n+        }\n+\n+        if (tokenInfo.isActive()) {\n+            actions.add(PossibleActionEnum.TOKEN_DEACTIVATE);\n+        } else {\n+            if (tokenInfo.isAvailable()) {\n+                actions.add(PossibleActionEnum.TOKEN_ACTIVATE);\n+            }\n+        }\n+\n+        if (tokenInfo.isSavedToConfiguration()) {\n+            actions.add(PossibleActionEnum.EDIT_FRIENDLY_NAME);\n+        }\n+\n+        return actions;\n+    }\n+\n+    /**\n+     * key is \"not supported\" if it's an auth key inside other than softtoken (id 0)\n+     */\n+    public boolean isKeyUnsupported(TokenInfo tokenInfo, KeyInfo keyInfo) {\n+        return (!SOFTWARE_TOKEN_ID.equals(tokenInfo.getId()))\n+                && keyInfo.getUsage() == KeyUsageInfo.AUTHENTICATION;\n+\n+    }\n+\n+    /**\n+     * Get possible actions for a key\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleKeyActions(TokenInfo tokenInfo,\n+            KeyInfo keyInfo) {\n+        EnumSet<PossibleActionEnum> actions = EnumSet.noneOf(PossibleActionEnum.class);\n+\n+        // DELETE\n+        boolean keyNotSupported = isKeyUnsupported(tokenInfo, keyInfo);\n+\n+        // key.js#L26\n+        if (!keyNotSupported\n+            && !(tokenInfo.isReadOnly() && !keyInfo.isSavedToConfiguration())\n+            && (keyInfo.isSavedToConfiguration() || tokenInfo.isActive())) {\n+            actions.add(PossibleActionEnum.DELETE);\n+        }\n+\n+        // GENERATE_AUTH_CSR\n+        // keys.js#35\n+        if (SOFTWARE_TOKEN_ID.equals(tokenInfo.getId())\n+                && (keyInfo.getUsage() == null || keyInfo.getUsage() == KeyUsageInfo.AUTHENTICATION)\n+                && !(!keyInfo.isAvailable() || !tokenInfo.isActive() || keyNotSupported)) {\n+            actions.add(PossibleActionEnum.GENERATE_AUTH_CSR);\n+        }\n+        // GENERATE_SIGN_CSR\n+        if ((keyInfo.getUsage() == null || keyInfo.getUsage() == KeyUsageInfo.SIGNING)\n+                && !(!keyInfo.isAvailable() || !tokenInfo.isActive() || keyNotSupported)) {\n+            actions.add(PossibleActionEnum.GENERATE_SIGN_CSR);\n+        }\n+        // EDIT_FRIENDLY_NAME\n+        if (keyInfo.isSavedToConfiguration()) {\n+            actions.add(PossibleActionEnum.EDIT_FRIENDLY_NAME);\n+        }\n+\n+        return actions;\n+    }\n+\n+    /**\n+     * get possible actions for a certificate\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleCertificateActions(TokenInfo tokenInfo,\n+            KeyInfo keyInfo,\n+            CertificateInfo certificateInfo) {\n+        EnumSet<PossibleActionEnum> actions = EnumSet.noneOf(PossibleActionEnum.class);\n+        boolean canUnregister = keyInfo.getUsage() == KeyUsageInfo.AUTHENTICATION\n+                && (CertificateInfo.STATUS_REGINPROG.equals(certificateInfo.getStatus())\n+                || CertificateInfo.STATUS_REGISTERED.equals(certificateInfo.getStatus()));\n+        if (canUnregister) {\n+            actions.add(PossibleActionEnum.UNREGISTER);\n+        }\n+        boolean savedToConfiguration = certificateInfo.isSavedToConfiguration();\n+        if (canDeleteCertOrCsr(tokenInfo, savedToConfiguration, canUnregister)) {\n+            actions.add(PossibleActionEnum.DELETE);\n+        }\n+        if (keyInfo.getUsage() == KeyUsageInfo.AUTHENTICATION\n+                && CertificateInfo.STATUS_SAVED.equals(certificateInfo.getStatus())\n+                && (!canUnregister)) {\n+            actions.add(PossibleActionEnum.REGISTER);\n+        }\n+        if (keyInfo.getUsage() != null && certificateInfo.isSavedToConfiguration()) {\n+            if (certificateInfo.isActive()) {\n+                actions.add(PossibleActionEnum.DISABLE);\n+            } else {\n+                actions.add(PossibleActionEnum.ACTIVATE);\n+            }\n+        }\n+        if (!certificateInfo.isSavedToConfiguration()) {\n+            actions.add(PossibleActionEnum.IMPORT_FROM_TOKEN);\n+        }\n+\n+        return actions;\n+    }\n+\n+    /**\n+     * get possible actions for a csr\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleCsrActions(TokenInfo tokenInfo,\n+            KeyInfo keyInfo,\n+            CertRequestInfo certRequestInfo) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bd4ee70b4efdfdf596c4b6ea4cdd12d360764b"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMyMTg2Ng==", "bodyText": "Fixing that.", "url": "https://github.com/nordic-institute/X-Road/pull/306#discussion_r364321866", "createdAt": "2020-01-08T16:26:38Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/PossibleActionsRuleEngine.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.signer.protocol.dto.CertRequestInfo;\n+import ee.ria.xroad.signer.protocol.dto.CertificateInfo;\n+import ee.ria.xroad.signer.protocol.dto.KeyInfo;\n+import ee.ria.xroad.signer.protocol.dto.KeyUsageInfo;\n+import ee.ria.xroad.signer.protocol.dto.TokenInfo;\n+\n+import org.springframework.stereotype.Component;\n+\n+import java.util.EnumSet;\n+\n+/**\n+ * Validation logic for possible actions done on tokens, keys, certs and csrs\n+ */\n+@Component\n+public class PossibleActionsRuleEngine {\n+\n+    // duplicate definition, since we dont want add direct dependency on signer\n+    public static final String SOFTWARE_TOKEN_ID = \"0\";\n+\n+    /**\n+     * Get possible actions for a token\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleTokenActions(TokenInfo tokenInfo) {\n+        EnumSet<PossibleActionEnum> actions = EnumSet.noneOf(PossibleActionEnum.class);\n+\n+        if (tokenInfo.isActive()) {\n+            actions.add(PossibleActionEnum.GENERATE_KEY);\n+        }\n+\n+        if (tokenInfo.isActive()) {\n+            actions.add(PossibleActionEnum.TOKEN_DEACTIVATE);\n+        } else {\n+            if (tokenInfo.isAvailable()) {\n+                actions.add(PossibleActionEnum.TOKEN_ACTIVATE);\n+            }\n+        }\n+\n+        if (tokenInfo.isSavedToConfiguration()) {\n+            actions.add(PossibleActionEnum.EDIT_FRIENDLY_NAME);\n+        }\n+\n+        return actions;\n+    }\n+\n+    /**\n+     * key is \"not supported\" if it's an auth key inside other than softtoken (id 0)\n+     */\n+    public boolean isKeyUnsupported(TokenInfo tokenInfo, KeyInfo keyInfo) {\n+        return (!SOFTWARE_TOKEN_ID.equals(tokenInfo.getId()))\n+                && keyInfo.getUsage() == KeyUsageInfo.AUTHENTICATION;\n+\n+    }\n+\n+    /**\n+     * Get possible actions for a key\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleKeyActions(TokenInfo tokenInfo,\n+            KeyInfo keyInfo) {\n+        EnumSet<PossibleActionEnum> actions = EnumSet.noneOf(PossibleActionEnum.class);\n+\n+        // DELETE\n+        boolean keyNotSupported = isKeyUnsupported(tokenInfo, keyInfo);\n+\n+        // key.js#L26\n+        if (!keyNotSupported\n+            && !(tokenInfo.isReadOnly() && !keyInfo.isSavedToConfiguration())\n+            && (keyInfo.isSavedToConfiguration() || tokenInfo.isActive())) {\n+            actions.add(PossibleActionEnum.DELETE);\n+        }\n+\n+        // GENERATE_AUTH_CSR\n+        // keys.js#35\n+        if (SOFTWARE_TOKEN_ID.equals(tokenInfo.getId())\n+                && (keyInfo.getUsage() == null || keyInfo.getUsage() == KeyUsageInfo.AUTHENTICATION)\n+                && !(!keyInfo.isAvailable() || !tokenInfo.isActive() || keyNotSupported)) {\n+            actions.add(PossibleActionEnum.GENERATE_AUTH_CSR);\n+        }\n+        // GENERATE_SIGN_CSR\n+        if ((keyInfo.getUsage() == null || keyInfo.getUsage() == KeyUsageInfo.SIGNING)\n+                && !(!keyInfo.isAvailable() || !tokenInfo.isActive() || keyNotSupported)) {\n+            actions.add(PossibleActionEnum.GENERATE_SIGN_CSR);\n+        }\n+        // EDIT_FRIENDLY_NAME\n+        if (keyInfo.isSavedToConfiguration()) {\n+            actions.add(PossibleActionEnum.EDIT_FRIENDLY_NAME);\n+        }\n+\n+        return actions;\n+    }\n+\n+    /**\n+     * get possible actions for a certificate\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleCertificateActions(TokenInfo tokenInfo,\n+            KeyInfo keyInfo,\n+            CertificateInfo certificateInfo) {\n+        EnumSet<PossibleActionEnum> actions = EnumSet.noneOf(PossibleActionEnum.class);\n+        boolean canUnregister = keyInfo.getUsage() == KeyUsageInfo.AUTHENTICATION\n+                && (CertificateInfo.STATUS_REGINPROG.equals(certificateInfo.getStatus())\n+                || CertificateInfo.STATUS_REGISTERED.equals(certificateInfo.getStatus()));\n+        if (canUnregister) {\n+            actions.add(PossibleActionEnum.UNREGISTER);\n+        }\n+        boolean savedToConfiguration = certificateInfo.isSavedToConfiguration();\n+        if (canDeleteCertOrCsr(tokenInfo, savedToConfiguration, canUnregister)) {\n+            actions.add(PossibleActionEnum.DELETE);\n+        }\n+        if (keyInfo.getUsage() == KeyUsageInfo.AUTHENTICATION\n+                && CertificateInfo.STATUS_SAVED.equals(certificateInfo.getStatus())\n+                && (!canUnregister)) {\n+            actions.add(PossibleActionEnum.REGISTER);\n+        }\n+        if (keyInfo.getUsage() != null && certificateInfo.isSavedToConfiguration()) {\n+            if (certificateInfo.isActive()) {\n+                actions.add(PossibleActionEnum.DISABLE);\n+            } else {\n+                actions.add(PossibleActionEnum.ACTIVATE);\n+            }\n+        }\n+        if (!certificateInfo.isSavedToConfiguration()) {\n+            actions.add(PossibleActionEnum.IMPORT_FROM_TOKEN);\n+        }\n+\n+        return actions;\n+    }\n+\n+    /**\n+     * get possible actions for a csr\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleCsrActions(TokenInfo tokenInfo,\n+            KeyInfo keyInfo,\n+            CertRequestInfo certRequestInfo) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc1MzE1Mg=="}, "originalCommit": {"oid": "e4bd4ee70b4efdfdf596c4b6ea4cdd12d360764b"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMzMTY4Ng==", "bodyText": "fixed", "url": "https://github.com/nordic-institute/X-Road/pull/306#discussion_r364331686", "createdAt": "2020-01-08T16:45:02Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/PossibleActionsRuleEngine.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.signer.protocol.dto.CertRequestInfo;\n+import ee.ria.xroad.signer.protocol.dto.CertificateInfo;\n+import ee.ria.xroad.signer.protocol.dto.KeyInfo;\n+import ee.ria.xroad.signer.protocol.dto.KeyUsageInfo;\n+import ee.ria.xroad.signer.protocol.dto.TokenInfo;\n+\n+import org.springframework.stereotype.Component;\n+\n+import java.util.EnumSet;\n+\n+/**\n+ * Validation logic for possible actions done on tokens, keys, certs and csrs\n+ */\n+@Component\n+public class PossibleActionsRuleEngine {\n+\n+    // duplicate definition, since we dont want add direct dependency on signer\n+    public static final String SOFTWARE_TOKEN_ID = \"0\";\n+\n+    /**\n+     * Get possible actions for a token\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleTokenActions(TokenInfo tokenInfo) {\n+        EnumSet<PossibleActionEnum> actions = EnumSet.noneOf(PossibleActionEnum.class);\n+\n+        if (tokenInfo.isActive()) {\n+            actions.add(PossibleActionEnum.GENERATE_KEY);\n+        }\n+\n+        if (tokenInfo.isActive()) {\n+            actions.add(PossibleActionEnum.TOKEN_DEACTIVATE);\n+        } else {\n+            if (tokenInfo.isAvailable()) {\n+                actions.add(PossibleActionEnum.TOKEN_ACTIVATE);\n+            }\n+        }\n+\n+        if (tokenInfo.isSavedToConfiguration()) {\n+            actions.add(PossibleActionEnum.EDIT_FRIENDLY_NAME);\n+        }\n+\n+        return actions;\n+    }\n+\n+    /**\n+     * key is \"not supported\" if it's an auth key inside other than softtoken (id 0)\n+     */\n+    public boolean isKeyUnsupported(TokenInfo tokenInfo, KeyInfo keyInfo) {\n+        return (!SOFTWARE_TOKEN_ID.equals(tokenInfo.getId()))\n+                && keyInfo.getUsage() == KeyUsageInfo.AUTHENTICATION;\n+\n+    }\n+\n+    /**\n+     * Get possible actions for a key\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleKeyActions(TokenInfo tokenInfo,\n+            KeyInfo keyInfo) {\n+        EnumSet<PossibleActionEnum> actions = EnumSet.noneOf(PossibleActionEnum.class);\n+\n+        // DELETE\n+        boolean keyNotSupported = isKeyUnsupported(tokenInfo, keyInfo);\n+\n+        // key.js#L26\n+        if (!keyNotSupported\n+            && !(tokenInfo.isReadOnly() && !keyInfo.isSavedToConfiguration())\n+            && (keyInfo.isSavedToConfiguration() || tokenInfo.isActive())) {\n+            actions.add(PossibleActionEnum.DELETE);\n+        }\n+\n+        // GENERATE_AUTH_CSR\n+        // keys.js#35\n+        if (SOFTWARE_TOKEN_ID.equals(tokenInfo.getId())\n+                && (keyInfo.getUsage() == null || keyInfo.getUsage() == KeyUsageInfo.AUTHENTICATION)\n+                && !(!keyInfo.isAvailable() || !tokenInfo.isActive() || keyNotSupported)) {\n+            actions.add(PossibleActionEnum.GENERATE_AUTH_CSR);\n+        }\n+        // GENERATE_SIGN_CSR\n+        if ((keyInfo.getUsage() == null || keyInfo.getUsage() == KeyUsageInfo.SIGNING)\n+                && !(!keyInfo.isAvailable() || !tokenInfo.isActive() || keyNotSupported)) {\n+            actions.add(PossibleActionEnum.GENERATE_SIGN_CSR);\n+        }\n+        // EDIT_FRIENDLY_NAME\n+        if (keyInfo.isSavedToConfiguration()) {\n+            actions.add(PossibleActionEnum.EDIT_FRIENDLY_NAME);\n+        }\n+\n+        return actions;\n+    }\n+\n+    /**\n+     * get possible actions for a certificate\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleCertificateActions(TokenInfo tokenInfo,\n+            KeyInfo keyInfo,\n+            CertificateInfo certificateInfo) {\n+        EnumSet<PossibleActionEnum> actions = EnumSet.noneOf(PossibleActionEnum.class);\n+        boolean canUnregister = keyInfo.getUsage() == KeyUsageInfo.AUTHENTICATION\n+                && (CertificateInfo.STATUS_REGINPROG.equals(certificateInfo.getStatus())\n+                || CertificateInfo.STATUS_REGISTERED.equals(certificateInfo.getStatus()));\n+        if (canUnregister) {\n+            actions.add(PossibleActionEnum.UNREGISTER);\n+        }\n+        boolean savedToConfiguration = certificateInfo.isSavedToConfiguration();\n+        if (canDeleteCertOrCsr(tokenInfo, savedToConfiguration, canUnregister)) {\n+            actions.add(PossibleActionEnum.DELETE);\n+        }\n+        if (keyInfo.getUsage() == KeyUsageInfo.AUTHENTICATION\n+                && CertificateInfo.STATUS_SAVED.equals(certificateInfo.getStatus())\n+                && (!canUnregister)) {\n+            actions.add(PossibleActionEnum.REGISTER);\n+        }\n+        if (keyInfo.getUsage() != null && certificateInfo.isSavedToConfiguration()) {\n+            if (certificateInfo.isActive()) {\n+                actions.add(PossibleActionEnum.DISABLE);\n+            } else {\n+                actions.add(PossibleActionEnum.ACTIVATE);\n+            }\n+        }\n+        if (!certificateInfo.isSavedToConfiguration()) {\n+            actions.add(PossibleActionEnum.IMPORT_FROM_TOKEN);\n+        }\n+\n+        return actions;\n+    }\n+\n+    /**\n+     * get possible actions for a csr\n+     */\n+    public EnumSet<PossibleActionEnum> getPossibleCsrActions(TokenInfo tokenInfo,\n+            KeyInfo keyInfo,\n+            CertRequestInfo certRequestInfo) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc1MzE1Mg=="}, "originalCommit": {"oid": "e4bd4ee70b4efdfdf596c4b6ea4cdd12d360764b"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NjY4NTg5OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/service/TokenCertificateServiceTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNDoxODo0OVrOFa6o1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNzowOTo0MVrOFbshNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc2ODAyMA==", "bodyText": "These are probably redundant here", "url": "https://github.com/nordic-institute/X-Road/pull/306#discussion_r363768020", "createdAt": "2020-01-07T14:18:49Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/service/TokenCertificateServiceTest.java", "diffHunk": "@@ -79,58 +119,359 @@\n     @MockBean\n     private CertificateAuthorityService certificateAuthorityService;\n \n-    @MockBean\n+    @SpyBean\n     private KeyService keyService;\n \n+    @MockBean\n+    private GlobalConfService globalConfService;\n+\n+    @MockBean\n+    private GlobalConfFacade globalConfFacade;\n+\n+    @MockBean\n+    private ClientRepository clientRepository;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bd4ee70b4efdfdf596c4b6ea4cdd12d360764b"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMzMDQ4Mw==", "bodyText": "I guess they are not? I mean if I don't mock those, TokenCertificateService will e.g. use real GlobalConfService, which we do not want here since it's not meant to be an integration test.\nThis is pretty clumsy way to do it though, I agree, and usually you forget to add some dependencies as mocks, and can easily call the real implementation by mistake. I wonder if there's a better way to do this, or if it makes sense to use this approach at all.", "url": "https://github.com/nordic-institute/X-Road/pull/306#discussion_r364330483", "createdAt": "2020-01-08T16:42:37Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/service/TokenCertificateServiceTest.java", "diffHunk": "@@ -79,58 +119,359 @@\n     @MockBean\n     private CertificateAuthorityService certificateAuthorityService;\n \n-    @MockBean\n+    @SpyBean\n     private KeyService keyService;\n \n+    @MockBean\n+    private GlobalConfService globalConfService;\n+\n+    @MockBean\n+    private GlobalConfFacade globalConfFacade;\n+\n+    @MockBean\n+    private ClientRepository clientRepository;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc2ODAyMA=="}, "originalCommit": {"oid": "e4bd4ee70b4efdfdf596c4b6ea4cdd12d360764b"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU2OTg3OQ==", "bodyText": "Thought a bit more about and realized that if we mock everything, TokenCertificateServiceTest is then a pure unit test, so what sense does it make to implement it as a (slow) SpringBootTest? Would it not be better to just have it as a regular junit test which is more lightweight and guarantees we don't accidentally use some injected real dependencies?\nAnd then a counterpoint, spring test framework makes constructing, injecting and mocking the dependencies easier (probably, not sure how it would be done in pure mockito) and some of the tests use spring features such as mock users.\nI have a feeling this is related to the problem with slow tests, I need to ask for help somewhere. I don't think it should stop this PR though.", "url": "https://github.com/nordic-institute/X-Road/pull/306#discussion_r364569879", "createdAt": "2020-01-09T05:57:36Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/service/TokenCertificateServiceTest.java", "diffHunk": "@@ -79,58 +119,359 @@\n     @MockBean\n     private CertificateAuthorityService certificateAuthorityService;\n \n-    @MockBean\n+    @SpyBean\n     private KeyService keyService;\n \n+    @MockBean\n+    private GlobalConfService globalConfService;\n+\n+    @MockBean\n+    private GlobalConfFacade globalConfFacade;\n+\n+    @MockBean\n+    private ClientRepository clientRepository;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc2ODAyMA=="}, "originalCommit": {"oid": "e4bd4ee70b4efdfdf596c4b6ea4cdd12d360764b"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU4NTI3MQ==", "bodyText": "In this case I couldn't find any usage (direct or indirect) for the fields in question. But it might be good to mock them anyway to ensure nothing calls the real services.\nIt would be very nice to get the tests to execute faster but yeah that is for another task", "url": "https://github.com/nordic-institute/X-Road/pull/306#discussion_r364585271", "createdAt": "2020-01-09T07:09:41Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/service/TokenCertificateServiceTest.java", "diffHunk": "@@ -79,58 +119,359 @@\n     @MockBean\n     private CertificateAuthorityService certificateAuthorityService;\n \n-    @MockBean\n+    @SpyBean\n     private KeyService keyService;\n \n+    @MockBean\n+    private GlobalConfService globalConfService;\n+\n+    @MockBean\n+    private GlobalConfFacade globalConfFacade;\n+\n+    @MockBean\n+    private ClientRepository clientRepository;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc2ODAyMA=="}, "originalCommit": {"oid": "e4bd4ee70b4efdfdf596c4b6ea4cdd12d360764b"}, "originalPosition": 111}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2877, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}