{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0NDE5ODgz", "number": 468, "title": "XRDDEV-904 Initial configuration", "bodyText": "Initializing a new Security Server\nJIRA: https://jira.niis.org/browse/XRDDEV-904", "createdAt": "2020-04-16T14:36:27Z", "url": "https://github.com/nordic-institute/X-Road/pull/468", "merged": true, "mergeCommit": {"oid": "ebb949cc52f20b67565e667122fa8d215c7184a5"}, "closed": true, "closedAt": "2020-05-14T11:57:23Z", "author": {"login": "carohauta"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcV5lpWAH2gAyNDA0NDE5ODgzOjRlOWI3NmY3OTEyNDgzNzkwNjY0OTVjZGU0Mzc3YWZlZTYyYWJkOTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchLO-rAH2gAyNDA0NDE5ODgzOmJlZGM1NDE0YTIxNmRhM2E3MDY4YjU4OTZlZTMzZDI3MjkzZGM0NDU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4e9b76f791248379066495cde4377afee62abd97", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/4e9b76f791248379066495cde4377afee62abd97", "committedDate": "2020-04-09T10:04:12Z", "message": "XRDDEV-904 Initial configuration\n\n* api design"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "161887faa42f0e1626a631b9b3c524300315b9ca", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/161887faa42f0e1626a631b9b3c524300315b9ca", "committedDate": "2020-04-09T10:05:15Z", "message": "Merge branch 'develop' into XRDDEV-904-initial-configuration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f62d6b546bbc0a010c8b255625d0a4e5a83f700", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/6f62d6b546bbc0a010c8b255625d0a4e5a83f700", "committedDate": "2020-04-09T13:58:52Z", "message": "XRDDEV-904 Initial configuration\n\n* api design update\n* init status endpoint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9de5d3e79f63588f1d3b8c7dd32e4163df70248", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/c9de5d3e79f63588f1d3b8c7dd32e4163df70248", "committedDate": "2020-04-14T08:10:06Z", "message": "XRDDEV-904 Initial configuration / decoupling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97c4dff7b16c7e6f8db8d1ac98d07b7141c69d3c", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/97c4dff7b16c7e6f8db8d1ac98d07b7141c69d3c", "committedDate": "2020-04-14T13:47:19Z", "message": "XRDDEV-904 Initial configuration\n\n* API updates\n* service methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "217145307e4fe12b8a38bc3ec5125f9246b790c5", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/217145307e4fe12b8a38bc3ec5125f9246b790c5", "committedDate": "2020-04-15T06:19:03Z", "message": "XRDDEV-904 Initial configuration / WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a21746e016fa8ba17bd36f6eccd01e654318512", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/0a21746e016fa8ba17bd36f6eccd01e654318512", "committedDate": "2020-04-15T07:16:04Z", "message": "XRDDEV-904 Initial configuration\n\n* remove redundant annotation that was causing trouble!"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96a6a2acb2e6c52df5e4035061db945699cd0fec", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/96a6a2acb2e6c52df5e4035061db945699cd0fec", "committedDate": "2020-04-15T13:03:18Z", "message": "XRDDEV-904 Initial configuration / save game"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a504c4718b6a14bef593cefbe882f5c414605074", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/a504c4718b6a14bef593cefbe882f5c414605074", "committedDate": "2020-04-15T14:22:08Z", "message": "XRDDEV-904 Initial configuration\n\n* initial implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f877e958cd6bf4a76198911ca65413079d4cbeb", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/7f877e958cd6bf4a76198911ca65413079d4cbeb", "committedDate": "2020-04-16T08:40:29Z", "message": "XRDDEV-904 Initial configuration / WIP save game"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c27dd2968881a0ae6d136100ef3e7172f95557c9", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/c27dd2968881a0ae6d136100ef3e7172f95557c9", "committedDate": "2020-04-16T09:43:30Z", "message": "XRDDEV-904 Initial configuration\n\n* upload anchor api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43d30424b1a42ac1e7e0cdbbf8b45a49ad83cac7", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/43d30424b1a42ac1e7e0cdbbf8b45a49ad83cac7", "committedDate": "2020-04-16T10:23:01Z", "message": "XRDDEV-904 Initial configuration // fix code style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fd4b8a41bcbb9ec6160dec05055ed0da9993bd6", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/0fd4b8a41bcbb9ec6160dec05055ed0da9993bd6", "committedDate": "2020-04-16T10:24:02Z", "message": "Merge branch 'develop' into XRDDEV-904-initial-configuration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f6b1a57f8b14764c6c9c658f22657dec9556755", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/0f6b1a57f8b14764c6c9c658f22657dec9556755", "committedDate": "2020-04-16T13:02:17Z", "message": "XRDDEV-904 Initial configuration // tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1fe4d67eb89ca30d4995c53934469129a8d7bc6", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/a1fe4d67eb89ca30d4995c53934469129a8d7bc6", "committedDate": "2020-04-16T14:04:40Z", "message": "XRDDEV-904 Initial configuration // more tests and cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5168c0c0dc12dc02c2189587669adc380a7b6d69", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/5168c0c0dc12dc02c2189587669adc380a7b6d69", "committedDate": "2020-04-16T14:29:51Z", "message": "XRDDEV-904 Initial configuration // more cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26fb68c4917ba1e95be433d24353143c1a4f87c2", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/26fb68c4917ba1e95be433d24353143c1a4f87c2", "committedDate": "2020-04-17T07:11:51Z", "message": "XRDDEV-904 Initial configuration // param validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70fd09451e52d3d36eebae69039d2727d5ec9968", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/70fd09451e52d3d36eebae69039d2727d5ec9968", "committedDate": "2020-04-20T11:55:26Z", "message": "XRDDEV-904 Initial configuration // update query param name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f083cdabbaaeaa83b812e0357f85020344e12104", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/f083cdabbaaeaa83b812e0357f85020344e12104", "committedDate": "2020-05-04T06:36:13Z", "message": "Merge branch 'develop' into XRDDEV-904-initial-configuration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dda6994499a830df4da99e64feabdd7afff679e8", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/dda6994499a830df4da99e64feabdd7afff679e8", "committedDate": "2020-05-06T09:36:42Z", "message": "Merge branch 'develop' into XRDDEV-904-initial-configuration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/32c2419007b445d7f7582140934c675dca9ab2db", "committedDate": "2020-05-11T11:24:46Z", "message": "Merge branch 'develop' into XRDDEV-904-initial-configuration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MDc3NDk0", "url": "https://github.com/nordic-institute/X-Road/pull/468#pullrequestreview-409077494", "createdAt": "2020-05-11T11:12:33Z", "commit": {"oid": "dda6994499a830df4da99e64feabdd7afff679e8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMToxMjozM1rOGTXwVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo1ODoyNVrOGTbFMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2NTMzNQ==", "bodyText": "Requirements about partial init are currently unclear: https://app.slack.com/client/T80PN5RE2/GGBHVCYSY/thread/GGBHVCYSY-1586845272.007700", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422965335", "createdAt": "2020-05-11T11:12:33Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is\n+     * enforced by properties)\n+     * @throws InvalidPinException if the provided pin code does not follow the TokenPinPolicy (if token pin policy is\n+     * enforced by properties)\n+     * @throws SoftwareTokenInitException if something goes wrong with the token init\n+     */\n+    public void initialize(String securityServerCode, String ownerMemberClass, String ownerMemberCode,\n+            String softwareTokenPin, boolean ignoreWarnings) throws AnchorNotFoundException, InitializationException,\n+            UnhandledWarningsException, WeakPinException, InvalidPinException, SoftwareTokenInitException {\n+        if (!systemService.isAnchorImported()) {\n+            throw new AnchorNotFoundException(\"Configuration anchor was not found.\");\n+        }\n+        verifyInitializationPrerequisites();\n+        String instanceIdentifier = globalConfFacade.getInstanceIdentifier();\n+        // get id from db if exists - this is for partial init support since no client ids should yet exist\n+        ClientId ownerClientId = clientService.getPossiblyManagedEntity(ClientId.create(instanceIdentifier,\n+                ownerMemberClass, ownerMemberCode));\n+        if (!ignoreWarnings) {\n+            checkForWarnings(ownerClientId, securityServerCode);\n+        }\n+        // --- Start the init ---\n+        ServerConfType serverConf = createInitialServerConf(ownerClientId, securityServerCode);\n+        initializeSoftwareToken(softwareTokenPin);\n+        serverConfService.saveOrUpdate(serverConf);\n+    }\n+\n+    /**\n+     * Helper to create a software token\n+     * @param softwareTokenPin the pin of the token\n+     * @throws InvalidPinException\n+     * @throws WeakPinException\n+     * @throws SoftwareTokenInitException\n+     */\n+    private void initializeSoftwareToken(String softwareTokenPin) throws InvalidPinException, WeakPinException,\n+            SoftwareTokenInitException {\n+        char[] pin = softwareTokenPin.toCharArray();\n+        if (isTokenPinEnforced) {\n+            TokenPinPolicy.Description description = TokenPinPolicy.describe(pin);\n+            if (!description.isValid()) {\n+                if (description.hasInvalidCharacters()) {\n+                    throw new InvalidPinException(\"The provided pin code does not match with the pin code policy\");\n+                }\n+                List<String> metadata = new ArrayList<>();\n+                metadata.add(METADATA_PIN_MIN_LENGTH);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_PASSWORD_LENGTH));\n+                metadata.add(METADATA_PIN_MIN_CHAR_CLASSES);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_CHARACTER_CLASS_COUNT));\n+                throw new WeakPinException(\"The provided pin code was too weak\", metadata);\n+            }\n+        }\n+        try {\n+            signerProxyFacade.initSoftwareToken(pin);\n+        } catch (Exception e) {\n+            // not good\n+            throw new SoftwareTokenInitException(\"Error initializing software token\", e);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create the initial server conf\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @return ServerConfType\n+     */\n+    private ServerConfType createInitialServerConf(ClientId ownerClientId, String securityServerCode) {\n+        /* get serverconf from db if exists\n+           - this is for partial init support since no server confs should yet exist\n+         */\n+        ServerConfType serverConf = serverConfService.getOrCreateServerConf();\n+        ClientType ownerClient = null;\n+        // get client from db if exists - this is for partial init support since no clients should yet exist\n+        Optional<ClientType> foundClient = serverConf.getClient().stream()\n+                .filter(clientType -> clientType.getIdentifier().equals(ownerClientId))\n+                .findFirst();\n+        ownerClient = foundClient.orElse(getInitialClient(ownerClientId));\n+        ownerClient.setConf(serverConf);\n+        // again for partial init support: if the client already exists there is no reason to add it again\n+        if (!serverConf.getClient().contains(ownerClient)) {\n+            serverConf.getClient().add(ownerClient);\n+        }\n+        serverConf.setOwner(ownerClient);\n+        serverConf.setServerCode(securityServerCode);\n+        return serverConf;\n+    }\n+\n+    /**\n+     * Helper to check for warnings\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @throws UnhandledWarningsException\n+     */\n+    private void checkForWarnings(ClientId ownerClientId, String securityServerCode)\n+            throws UnhandledWarningsException {\n+        String ownerMemberName = globalConfFacade.getMemberName(ownerClientId);\n+        SecurityServerId serverId = SecurityServerId.create(ownerClientId, securityServerCode);\n+        List<WarningDeviation> warnings = new ArrayList<>();\n+        if (StringUtils.isEmpty(ownerMemberName)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_UNREGISTERED_MEMBER,\n+                    ownerClientId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (globalConfFacade.existsSecurityServer(serverId)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_SERVER_ID_EXISTS,\n+                    serverId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (!warnings.isEmpty()) {\n+            throw new UnhandledWarningsException(warnings);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create an initial client\n+     * @param clientId\n+     * @return\n+     */\n+    private ClientType getInitialClient(ClientId clientId) {\n+        ClientType localClient = clientService.getLocalClient(clientId);\n+        if (localClient == null) {\n+            localClient = new ClientType();\n+            localClient.setIdentifier(clientId);\n+            localClient.setClientStatus(ClientType.STATUS_SAVED);\n+            localClient.setIsAuthentication(IsAuthentication.SSLAUTH.name());\n+        }\n+        return localClient;\n+    }\n+\n+    /**\n+     * Verify that the initialization process can proceed and that the security server has not already been\n+     * initialized. This means verifying that an anchor has been imported,\n+     * server conf does not exist and a software token has not yet been initialized. This method could also be\n+     * changed into throwing an UnhandledWarningsException with warning metadata instead of the current\n+     * InitializationException if partial init needs to be supported in the future\n+     * @throws InitializationException if server conf exists OR software token is already initialized\n+     */\n+    private void verifyInitializationPrerequisites() throws InitializationException {\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda6994499a830df4da99e64feabdd7afff679e8"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2OTA2Mg==", "bodyText": "nitpick: isSecurityServerInitialized typically returns boolean. E.g. getSecurityServerInitializationStatus might be more idiomatic naming", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422969062", "createdAt": "2020-05-11T11:20:16Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda6994499a830df4da99e64feabdd7afff679e8"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODI5OQ==", "bodyText": "If we intend to ignore specifically X_MALFORMED_SERVERCONF, it would be even better to check against the faultCode, and rethrow others. Otherwise there's a possibility for hiding errors, if other types of CodedExceptions happen (which is unlikely, but not impossible, could be a result of some unrelated future change in ServerConfDAOImpl).", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422978299", "createdAt": "2020-05-11T11:38:38Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/ServerConfService.java", "diffHunk": "@@ -91,4 +108,30 @@ public ClientId getSecurityServerOwnerId() {\n         Hibernate.initialize(tsp);\n         return tsp;\n     }\n+\n+    /**\n+     * Is server conf initialized -> it is if whe can find one\n+     * @return\n+     */\n+    public boolean isServerConfInitialized() {\n+        boolean isServerConfInitialized = false;\n+        try {\n+            ServerConfType serverConfType = getServerConf();\n+            if (serverConfType != null) {\n+                isServerConfInitialized = true;\n+            }\n+        } catch (CodedException ce) { // -> this is X_MALFORMED_SERVERCONF, \"Server conf is not initialized!\"\n+            log.info(\"ServerConfService#isServerConfInitialized: CodedException thrown when getting Server Conf\", ce);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4MDk3Nw==", "bodyText": "Why is dto's isServerConfInitialized a combination of isServerConfInitialized and isSoftwareTokenInitialized? It feels a bit weird. Should dto.isServerConfInitialized maybe be renamed, or should dto contain both isServerConfInitialized and isSoftwareTokenInitialized separately? Maybe also not in sync with javadoc, which describes init status as consisting of 3 parts.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422980977", "createdAt": "2020-05-11T11:43:59Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4MTI4MA==", "bodyText": "Pro level javadocs here and elsewhere, too \ud83d\udc4d", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422981280", "createdAt": "2020-05-11T11:44:42Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5NTk1MA==", "bodyText": "Had some trouble understanding WeakPinException and InvalidPinException initially. Reading the exception names and javadocs made me think \"Isn't a weak pin also an invalid PIN? And what is InvalidPinException about, if not length and complexity requirements\".\nI guess the idea is that frontend will be able to show proper error messages based on classification to error types invalid_pin and weak_pin? And that there will likely be two different error messages?\nThe difference between invalid_pin and weak_pin does not seem too obvious. Could also do some renaming and updating of javadocs to make it more clear? To me it looks like bad characters in PIN is invalid_pin and too few characters or too few character classes is weak_pin. But it took a few rereads to understand that.\nThere's also the possibility of using one single exception class InvalidPinException and using the same metadata-based way of specifying how exactly was it invalid as is already used for weak / METADATA_PIN_MIN_LENGTH and weak / METADATA_PIN_MIN_CHAR_CLASSES. I am not sure if it would be better or worse.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422995950", "createdAt": "2020-05-11T12:14:41Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5NzM2NA==", "bodyText": "This method does not verify that anchor has been imported, but javadoc days it does?", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422997364", "createdAt": "2020-05-11T12:17:18Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is\n+     * enforced by properties)\n+     * @throws InvalidPinException if the provided pin code does not follow the TokenPinPolicy (if token pin policy is\n+     * enforced by properties)\n+     * @throws SoftwareTokenInitException if something goes wrong with the token init\n+     */\n+    public void initialize(String securityServerCode, String ownerMemberClass, String ownerMemberCode,\n+            String softwareTokenPin, boolean ignoreWarnings) throws AnchorNotFoundException, InitializationException,\n+            UnhandledWarningsException, WeakPinException, InvalidPinException, SoftwareTokenInitException {\n+        if (!systemService.isAnchorImported()) {\n+            throw new AnchorNotFoundException(\"Configuration anchor was not found.\");\n+        }\n+        verifyInitializationPrerequisites();\n+        String instanceIdentifier = globalConfFacade.getInstanceIdentifier();\n+        // get id from db if exists - this is for partial init support since no client ids should yet exist\n+        ClientId ownerClientId = clientService.getPossiblyManagedEntity(ClientId.create(instanceIdentifier,\n+                ownerMemberClass, ownerMemberCode));\n+        if (!ignoreWarnings) {\n+            checkForWarnings(ownerClientId, securityServerCode);\n+        }\n+        // --- Start the init ---\n+        ServerConfType serverConf = createInitialServerConf(ownerClientId, securityServerCode);\n+        initializeSoftwareToken(softwareTokenPin);\n+        serverConfService.saveOrUpdate(serverConf);\n+    }\n+\n+    /**\n+     * Helper to create a software token\n+     * @param softwareTokenPin the pin of the token\n+     * @throws InvalidPinException\n+     * @throws WeakPinException\n+     * @throws SoftwareTokenInitException\n+     */\n+    private void initializeSoftwareToken(String softwareTokenPin) throws InvalidPinException, WeakPinException,\n+            SoftwareTokenInitException {\n+        char[] pin = softwareTokenPin.toCharArray();\n+        if (isTokenPinEnforced) {\n+            TokenPinPolicy.Description description = TokenPinPolicy.describe(pin);\n+            if (!description.isValid()) {\n+                if (description.hasInvalidCharacters()) {\n+                    throw new InvalidPinException(\"The provided pin code does not match with the pin code policy\");\n+                }\n+                List<String> metadata = new ArrayList<>();\n+                metadata.add(METADATA_PIN_MIN_LENGTH);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_PASSWORD_LENGTH));\n+                metadata.add(METADATA_PIN_MIN_CHAR_CLASSES);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_CHARACTER_CLASS_COUNT));\n+                throw new WeakPinException(\"The provided pin code was too weak\", metadata);\n+            }\n+        }\n+        try {\n+            signerProxyFacade.initSoftwareToken(pin);\n+        } catch (Exception e) {\n+            // not good\n+            throw new SoftwareTokenInitException(\"Error initializing software token\", e);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create the initial server conf\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @return ServerConfType\n+     */\n+    private ServerConfType createInitialServerConf(ClientId ownerClientId, String securityServerCode) {\n+        /* get serverconf from db if exists\n+           - this is for partial init support since no server confs should yet exist\n+         */\n+        ServerConfType serverConf = serverConfService.getOrCreateServerConf();\n+        ClientType ownerClient = null;\n+        // get client from db if exists - this is for partial init support since no clients should yet exist\n+        Optional<ClientType> foundClient = serverConf.getClient().stream()\n+                .filter(clientType -> clientType.getIdentifier().equals(ownerClientId))\n+                .findFirst();\n+        ownerClient = foundClient.orElse(getInitialClient(ownerClientId));\n+        ownerClient.setConf(serverConf);\n+        // again for partial init support: if the client already exists there is no reason to add it again\n+        if (!serverConf.getClient().contains(ownerClient)) {\n+            serverConf.getClient().add(ownerClient);\n+        }\n+        serverConf.setOwner(ownerClient);\n+        serverConf.setServerCode(securityServerCode);\n+        return serverConf;\n+    }\n+\n+    /**\n+     * Helper to check for warnings\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @throws UnhandledWarningsException\n+     */\n+    private void checkForWarnings(ClientId ownerClientId, String securityServerCode)\n+            throws UnhandledWarningsException {\n+        String ownerMemberName = globalConfFacade.getMemberName(ownerClientId);\n+        SecurityServerId serverId = SecurityServerId.create(ownerClientId, securityServerCode);\n+        List<WarningDeviation> warnings = new ArrayList<>();\n+        if (StringUtils.isEmpty(ownerMemberName)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_UNREGISTERED_MEMBER,\n+                    ownerClientId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (globalConfFacade.existsSecurityServer(serverId)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_SERVER_ID_EXISTS,\n+                    serverId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (!warnings.isEmpty()) {\n+            throw new UnhandledWarningsException(warnings);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create an initial client\n+     * @param clientId\n+     * @return\n+     */\n+    private ClientType getInitialClient(ClientId clientId) {\n+        ClientType localClient = clientService.getLocalClient(clientId);\n+        if (localClient == null) {\n+            localClient = new ClientType();\n+            localClient.setIdentifier(clientId);\n+            localClient.setClientStatus(ClientType.STATUS_SAVED);\n+            localClient.setIsAuthentication(IsAuthentication.SSLAUTH.name());\n+        }\n+        return localClient;\n+    }\n+\n+    /**\n+     * Verify that the initialization process can proceed and that the security server has not already been\n+     * initialized. This means verifying that an anchor has been imported,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAwMDIzNQ==", "bodyText": "Same comment as in isServerConfInitialized about CodedExceptions.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423000235", "createdAt": "2020-05-11T12:22:45Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/ServerConfService.java", "diffHunk": "@@ -62,6 +63,22 @@ public ServerConfType getServerConf() {\n         return serverConfRepository.getServerConf();\n     }\n \n+    /**\n+     * Get a server conf; an existing server conf will be returned if one exists. Otherwise\n+     * a new transient instance is returned.\n+     * @return\n+     */\n+    public ServerConfType getOrCreateServerConf() {\n+        ServerConfType serverConfType = null;\n+        try {\n+            serverConfType = getServerConf();\n+        } catch (CodedException ce) {\n+            // server conf doesn't exist which is fine - let's just create one", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAwNjI4MA==", "bodyText": "Should AnchorAlreadyExistsException be a conflict?", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423006280", "createdAt": "2020-05-11T12:34:04Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/openapi/SystemApiController.java", "diffHunk": "@@ -235,14 +235,36 @@ public SystemApiController(InternalTlsCertificateService internalTlsCertificateS\n \n     @Override\n     @PreAuthorize(\"hasAuthority('UPLOAD_ANCHOR')\")\n-    public ResponseEntity<Anchor> previewAnchor(Resource anchorResource) {\n+    public ResponseEntity<Anchor> previewAnchor(Boolean verifyInstance, Resource anchorResource) {\n         byte[] anchorBytes = ResourceUtils.springResourceToBytesOrThrowBadRequest(anchorResource);\n         AnchorFile anchorFile = null;\n         try {\n-            anchorFile = systemService.getAnchorFileFromBytes(anchorBytes);\n+            anchorFile = systemService.getAnchorFileFromBytes(anchorBytes, verifyInstance);\n         } catch (SystemService.InvalidAnchorInstanceException | SystemService.MalformedAnchorException e) {\n             throw new BadRequestException(e);\n         }\n         return new ResponseEntity<>(anchorConverter.convert(anchorFile), HttpStatus.OK);\n     }\n+\n+    /**\n+     * For uploading an initial configuration anchor. The difference between this and {@link #uploadAnchor(Resource)}\n+     * is that the anchor's instance does not get verified\n+     * @param anchorResource\n+     * @return\n+     */\n+    @Override\n+    @PreAuthorize(\"hasAuthority('INIT_CONFIG')\")\n+    public ResponseEntity<Void> uploadInitialAnchor(Resource anchorResource) {\n+        byte[] anchorBytes = ResourceUtils.springResourceToBytesOrThrowBadRequest(anchorResource);\n+        try {\n+            systemService.uploadInitialAnchor(anchorBytes);\n+        } catch (SystemService.InvalidAnchorInstanceException | SystemService.MalformedAnchorException\n+                | SystemService.AnchorAlreadyExistsException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTY5Ng==", "bodyText": "Maybe a couple of words about ignoreWarnings and UnhandledWarningsException would be good, since it is a kind of complicated concept.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423011696", "createdAt": "2020-05-11T12:43:59Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMzc2Mg==", "bodyText": "nitpick: maybe instead of \"going south\" something more neutral, since it is a bit conversational and codebase is sort of official and open source (this was an extreme nitpick, sorry)", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423013762", "createdAt": "2020-05-11T12:47:33Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is\n+     * enforced by properties)\n+     * @throws InvalidPinException if the provided pin code does not follow the TokenPinPolicy (if token pin policy is\n+     * enforced by properties)\n+     * @throws SoftwareTokenInitException if something goes wrong with the token init\n+     */\n+    public void initialize(String securityServerCode, String ownerMemberClass, String ownerMemberCode,\n+            String softwareTokenPin, boolean ignoreWarnings) throws AnchorNotFoundException, InitializationException,\n+            UnhandledWarningsException, WeakPinException, InvalidPinException, SoftwareTokenInitException {\n+        if (!systemService.isAnchorImported()) {\n+            throw new AnchorNotFoundException(\"Configuration anchor was not found.\");\n+        }\n+        verifyInitializationPrerequisites();\n+        String instanceIdentifier = globalConfFacade.getInstanceIdentifier();\n+        // get id from db if exists - this is for partial init support since no client ids should yet exist\n+        ClientId ownerClientId = clientService.getPossiblyManagedEntity(ClientId.create(instanceIdentifier,\n+                ownerMemberClass, ownerMemberCode));\n+        if (!ignoreWarnings) {\n+            checkForWarnings(ownerClientId, securityServerCode);\n+        }\n+        // --- Start the init ---\n+        ServerConfType serverConf = createInitialServerConf(ownerClientId, securityServerCode);\n+        initializeSoftwareToken(softwareTokenPin);\n+        serverConfService.saveOrUpdate(serverConf);\n+    }\n+\n+    /**\n+     * Helper to create a software token\n+     * @param softwareTokenPin the pin of the token\n+     * @throws InvalidPinException\n+     * @throws WeakPinException\n+     * @throws SoftwareTokenInitException\n+     */\n+    private void initializeSoftwareToken(String softwareTokenPin) throws InvalidPinException, WeakPinException,\n+            SoftwareTokenInitException {\n+        char[] pin = softwareTokenPin.toCharArray();\n+        if (isTokenPinEnforced) {\n+            TokenPinPolicy.Description description = TokenPinPolicy.describe(pin);\n+            if (!description.isValid()) {\n+                if (description.hasInvalidCharacters()) {\n+                    throw new InvalidPinException(\"The provided pin code does not match with the pin code policy\");\n+                }\n+                List<String> metadata = new ArrayList<>();\n+                metadata.add(METADATA_PIN_MIN_LENGTH);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_PASSWORD_LENGTH));\n+                metadata.add(METADATA_PIN_MIN_CHAR_CLASSES);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_CHARACTER_CLASS_COUNT));\n+                throw new WeakPinException(\"The provided pin code was too weak\", metadata);\n+            }\n+        }\n+        try {\n+            signerProxyFacade.initSoftwareToken(pin);\n+        } catch (Exception e) {\n+            // not good\n+            throw new SoftwareTokenInitException(\"Error initializing software token\", e);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create the initial server conf\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @return ServerConfType\n+     */\n+    private ServerConfType createInitialServerConf(ClientId ownerClientId, String securityServerCode) {\n+        /* get serverconf from db if exists\n+           - this is for partial init support since no server confs should yet exist\n+         */\n+        ServerConfType serverConf = serverConfService.getOrCreateServerConf();\n+        ClientType ownerClient = null;\n+        // get client from db if exists - this is for partial init support since no clients should yet exist\n+        Optional<ClientType> foundClient = serverConf.getClient().stream()\n+                .filter(clientType -> clientType.getIdentifier().equals(ownerClientId))\n+                .findFirst();\n+        ownerClient = foundClient.orElse(getInitialClient(ownerClientId));\n+        ownerClient.setConf(serverConf);\n+        // again for partial init support: if the client already exists there is no reason to add it again\n+        if (!serverConf.getClient().contains(ownerClient)) {\n+            serverConf.getClient().add(ownerClient);\n+        }\n+        serverConf.setOwner(ownerClient);\n+        serverConf.setServerCode(securityServerCode);\n+        return serverConf;\n+    }\n+\n+    /**\n+     * Helper to check for warnings\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @throws UnhandledWarningsException\n+     */\n+    private void checkForWarnings(ClientId ownerClientId, String securityServerCode)\n+            throws UnhandledWarningsException {\n+        String ownerMemberName = globalConfFacade.getMemberName(ownerClientId);\n+        SecurityServerId serverId = SecurityServerId.create(ownerClientId, securityServerCode);\n+        List<WarningDeviation> warnings = new ArrayList<>();\n+        if (StringUtils.isEmpty(ownerMemberName)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_UNREGISTERED_MEMBER,\n+                    ownerClientId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (globalConfFacade.existsSecurityServer(serverId)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_SERVER_ID_EXISTS,\n+                    serverId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (!warnings.isEmpty()) {\n+            throw new UnhandledWarningsException(warnings);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create an initial client\n+     * @param clientId\n+     * @return\n+     */\n+    private ClientType getInitialClient(ClientId clientId) {\n+        ClientType localClient = clientService.getLocalClient(clientId);\n+        if (localClient == null) {\n+            localClient = new ClientType();\n+            localClient.setIdentifier(clientId);\n+            localClient.setClientStatus(ClientType.STATUS_SAVED);\n+            localClient.setIsAuthentication(IsAuthentication.SSLAUTH.name());\n+        }\n+        return localClient;\n+    }\n+\n+    /**\n+     * Verify that the initialization process can proceed and that the security server has not already been\n+     * initialized. This means verifying that an anchor has been imported,\n+     * server conf does not exist and a software token has not yet been initialized. This method could also be\n+     * changed into throwing an UnhandledWarningsException with warning metadata instead of the current\n+     * InitializationException if partial init needs to be supported in the future\n+     * @throws InitializationException if server conf exists OR software token is already initialized\n+     */\n+    private void verifyInitializationPrerequisites() throws InitializationException {\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        List<String> metadata = new ArrayList<>();\n+        if (isServerConfInitialized) {\n+            metadata.add(METADATA_SERVERCONF_EXISTS);\n+        }\n+        if (isSoftwareTokenInitialized) {\n+            metadata.add(METADATA_SOFTWARE_TOKEN_INITIALIZED);\n+        }\n+        if (!metadata.isEmpty()) {\n+            throw new InitializationException(\"Error initializing security server\", metadata);\n+        }\n+    }\n+\n+    /**\n+     * If something goes south with the initialization", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxNTk3Nw==", "bodyText": "Hmm, is this a misleading log entry, will it look like an error for system admins, with the stacktrace? Could it maybe be reworded?", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423015977", "createdAt": "2020-05-11T12:51:33Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/SystemService.java", "diffHunk": "@@ -268,6 +304,44 @@ public void uploadAnchor(byte[] anchorBytes) throws InvalidAnchorInstanceExcepti\n         }\n     }\n \n+    /**\n+     * Is global conf initialized -> it is if whe can find a Configuration anchor\n+     * @return\n+     */\n+    public boolean isAnchorImported() {\n+        boolean isGlobalConfInitialized = false;\n+        try {\n+            AnchorFile anchorFile = getAnchorFile();\n+            if (anchorFile != null) {\n+                isGlobalConfInitialized = true;\n+            }\n+        } catch (AnchorNotFoundException e) {\n+            log.info(\"SystemService#isAnchorImported: could not find Global Configuration Anchor\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxNzk4NA==", "bodyText": "Maybe should not be required (also default value is meaningless if it is), other endpoints do not require ignore_warnings parameters.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423017984", "createdAt": "2020-05-11T12:55:13Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/resources/openapi-definition.yaml", "diffHunk": "@@ -4885,6 +5049,49 @@ components:\n           example: '2018-12-15T00:00:00.001Z'\n           minLength: 24\n           maxLength: 24\n+    InitialServerConf: # ok\n+      type: object\n+      description: security server initial configuration\n+      required:\n+        - member_class\n+        - member_code\n+        - security_server_code\n+        - software_token_pin\n+        - ignore_warnings", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxODYwNg==", "bodyText": "Nicely tested validation \ud83d\udc4d", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423018606", "createdAt": "2020-05-11T12:56:20Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/openapi/IdentifierValidationRestTemplateTest.java", "diffHunk": "@@ -184,4 +184,44 @@ private void assertUpdateServiceDescriptionValidationFailure(String restServiceC\n         assertEquals(\"validation_failure\", errors.get(\"code\"));\n     }\n \n+    @Test\n+    public void initialServerConf() {\n+        assertInitialServerConfValidationError(HAS_COLON, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_SEMICOLON, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_PERCENT, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_NON_NORMALIZED, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_BACKSLASH, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_COLON, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_SEMICOLON, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_PERCENT, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_NON_NORMALIZED, \"aa\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxOTgyNg==", "bodyText": "Nice effort put into testing across the board \ud83d\udc4d", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423019826", "createdAt": "2020-05-11T12:58:25Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/service/InitializationServiceTest.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.context.junit4.SpringRunner;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.when;\n+import static org.niis.xroad.restapi.service.InitializationService.METADATA_PIN_MIN_CHAR_CLASSES;\n+import static org.niis.xroad.restapi.service.InitializationService.METADATA_PIN_MIN_LENGTH;\n+import static org.niis.xroad.restapi.service.InitializationService.METADATA_SERVERCONF_EXISTS;\n+import static org.niis.xroad.restapi.service.InitializationService.METADATA_SOFTWARE_TOKEN_INITIALIZED;\n+import static org.niis.xroad.restapi.service.InitializationService.WARNING_INIT_SERVER_ID_EXISTS;\n+import static org.niis.xroad.restapi.service.InitializationService.WARNING_INIT_UNREGISTERED_MEMBER;\n+import static org.niis.xroad.restapi.service.InitializationService.WeakPinException.WEAK_PIN;\n+import static org.niis.xroad.restapi.util.DeviationTestUtils.assertErrorWithMetadata;\n+import static org.niis.xroad.restapi.util.DeviationTestUtils.assertWarning;\n+\n+@RunWith(SpringRunner.class)\n+@SpringBootTest\n+@AutoConfigureTestDatabase\n+@Slf4j\n+@Transactional\n+@WithMockUser\n+public class InitializationServiceTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 69}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb156821f6fa20008ded244c7b20f802a2425185", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/cb156821f6fa20008ded244c7b20f802a2425185", "committedDate": "2020-05-12T11:30:57Z", "message": "XRDDEV-904 PR comment fixes 1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b56c8752ddd14308d44348289e362e37654ef7a", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/5b56c8752ddd14308d44348289e362e37654ef7a", "committedDate": "2020-05-12T13:49:45Z", "message": "XRDDEV-904 Add more validation and verifying"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "067a223fc45d93ac85cb2d18ce94d86272bc598b", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/067a223fc45d93ac85cb2d18ce94d86272bc598b", "committedDate": "2020-05-13T10:58:02Z", "message": "XRDDEV-904 Update javadocs and add partial init tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f3f6c15d40fbe0139a7702b35c69e9544bb2194", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/1f3f6c15d40fbe0139a7702b35c69e9544bb2194", "committedDate": "2020-05-13T10:58:37Z", "message": "Merge branch 'develop' into XRDDEV-904-initial-configuration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c822c2053c98bce0cd154eff6193f571ce1f628b", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/c822c2053c98bce0cd154eff6193f571ce1f628b", "committedDate": "2020-05-13T12:30:54Z", "message": "XRDDEV-904 Increase IP Throttling rate for tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46c0c032f19f7b960a87ed9c90967cb913263ece", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/46c0c032f19f7b960a87ed9c90967cb913263ece", "committedDate": "2020-05-13T13:01:11Z", "message": "XRDDEV-904 API definition version bump"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNDkwMzIy", "url": "https://github.com/nordic-institute/X-Road/pull/468#pullrequestreview-411490322", "createdAt": "2020-05-14T06:11:54Z", "commit": {"oid": "46c0c032f19f7b960a87ed9c90967cb913263ece"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b870dd94d4e586bb32d171cc9327ddd1f15b7a1", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/8b870dd94d4e586bb32d171cc9327ddd1f15b7a1", "committedDate": "2020-05-14T07:52:16Z", "message": "XRDDEV-904 Exclude IP Throttling Filter from tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc9698cf8009c2e144eef6dffbe5f9d3d99410b3", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/dc9698cf8009c2e144eef6dffbe5f9d3d99410b3", "committedDate": "2020-05-14T08:09:40Z", "message": "Merge branch 'develop' into XRDDEV-904-initial-configuration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bedc5414a216da3a7068b5896ee33d27293dc445", "author": {"user": {"login": "carohauta", "name": "Caro Hautam\u00e4ki"}}, "url": "https://github.com/nordic-institute/X-Road/commit/bedc5414a216da3a7068b5896ee33d27293dc445", "committedDate": "2020-05-14T10:50:54Z", "message": "Merge branch 'develop' into XRDDEV-904-initial-configuration"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4213, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}