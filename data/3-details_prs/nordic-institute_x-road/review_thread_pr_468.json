{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0NDE5ODgz", "number": 468, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMToxMjozM1rOD7Mftg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo1ODoyNVrOD7OlQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMzk3MzAyOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMToxMjozM1rOGTXwVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMTowNzozMFrOGUsjjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2NTMzNQ==", "bodyText": "Requirements about partial init are currently unclear: https://app.slack.com/client/T80PN5RE2/GGBHVCYSY/thread/GGBHVCYSY-1586845272.007700", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422965335", "createdAt": "2020-05-11T11:12:33Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is\n+     * enforced by properties)\n+     * @throws InvalidPinException if the provided pin code does not follow the TokenPinPolicy (if token pin policy is\n+     * enforced by properties)\n+     * @throws SoftwareTokenInitException if something goes wrong with the token init\n+     */\n+    public void initialize(String securityServerCode, String ownerMemberClass, String ownerMemberCode,\n+            String softwareTokenPin, boolean ignoreWarnings) throws AnchorNotFoundException, InitializationException,\n+            UnhandledWarningsException, WeakPinException, InvalidPinException, SoftwareTokenInitException {\n+        if (!systemService.isAnchorImported()) {\n+            throw new AnchorNotFoundException(\"Configuration anchor was not found.\");\n+        }\n+        verifyInitializationPrerequisites();\n+        String instanceIdentifier = globalConfFacade.getInstanceIdentifier();\n+        // get id from db if exists - this is for partial init support since no client ids should yet exist\n+        ClientId ownerClientId = clientService.getPossiblyManagedEntity(ClientId.create(instanceIdentifier,\n+                ownerMemberClass, ownerMemberCode));\n+        if (!ignoreWarnings) {\n+            checkForWarnings(ownerClientId, securityServerCode);\n+        }\n+        // --- Start the init ---\n+        ServerConfType serverConf = createInitialServerConf(ownerClientId, securityServerCode);\n+        initializeSoftwareToken(softwareTokenPin);\n+        serverConfService.saveOrUpdate(serverConf);\n+    }\n+\n+    /**\n+     * Helper to create a software token\n+     * @param softwareTokenPin the pin of the token\n+     * @throws InvalidPinException\n+     * @throws WeakPinException\n+     * @throws SoftwareTokenInitException\n+     */\n+    private void initializeSoftwareToken(String softwareTokenPin) throws InvalidPinException, WeakPinException,\n+            SoftwareTokenInitException {\n+        char[] pin = softwareTokenPin.toCharArray();\n+        if (isTokenPinEnforced) {\n+            TokenPinPolicy.Description description = TokenPinPolicy.describe(pin);\n+            if (!description.isValid()) {\n+                if (description.hasInvalidCharacters()) {\n+                    throw new InvalidPinException(\"The provided pin code does not match with the pin code policy\");\n+                }\n+                List<String> metadata = new ArrayList<>();\n+                metadata.add(METADATA_PIN_MIN_LENGTH);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_PASSWORD_LENGTH));\n+                metadata.add(METADATA_PIN_MIN_CHAR_CLASSES);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_CHARACTER_CLASS_COUNT));\n+                throw new WeakPinException(\"The provided pin code was too weak\", metadata);\n+            }\n+        }\n+        try {\n+            signerProxyFacade.initSoftwareToken(pin);\n+        } catch (Exception e) {\n+            // not good\n+            throw new SoftwareTokenInitException(\"Error initializing software token\", e);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create the initial server conf\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @return ServerConfType\n+     */\n+    private ServerConfType createInitialServerConf(ClientId ownerClientId, String securityServerCode) {\n+        /* get serverconf from db if exists\n+           - this is for partial init support since no server confs should yet exist\n+         */\n+        ServerConfType serverConf = serverConfService.getOrCreateServerConf();\n+        ClientType ownerClient = null;\n+        // get client from db if exists - this is for partial init support since no clients should yet exist\n+        Optional<ClientType> foundClient = serverConf.getClient().stream()\n+                .filter(clientType -> clientType.getIdentifier().equals(ownerClientId))\n+                .findFirst();\n+        ownerClient = foundClient.orElse(getInitialClient(ownerClientId));\n+        ownerClient.setConf(serverConf);\n+        // again for partial init support: if the client already exists there is no reason to add it again\n+        if (!serverConf.getClient().contains(ownerClient)) {\n+            serverConf.getClient().add(ownerClient);\n+        }\n+        serverConf.setOwner(ownerClient);\n+        serverConf.setServerCode(securityServerCode);\n+        return serverConf;\n+    }\n+\n+    /**\n+     * Helper to check for warnings\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @throws UnhandledWarningsException\n+     */\n+    private void checkForWarnings(ClientId ownerClientId, String securityServerCode)\n+            throws UnhandledWarningsException {\n+        String ownerMemberName = globalConfFacade.getMemberName(ownerClientId);\n+        SecurityServerId serverId = SecurityServerId.create(ownerClientId, securityServerCode);\n+        List<WarningDeviation> warnings = new ArrayList<>();\n+        if (StringUtils.isEmpty(ownerMemberName)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_UNREGISTERED_MEMBER,\n+                    ownerClientId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (globalConfFacade.existsSecurityServer(serverId)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_SERVER_ID_EXISTS,\n+                    serverId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (!warnings.isEmpty()) {\n+            throw new UnhandledWarningsException(warnings);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create an initial client\n+     * @param clientId\n+     * @return\n+     */\n+    private ClientType getInitialClient(ClientId clientId) {\n+        ClientType localClient = clientService.getLocalClient(clientId);\n+        if (localClient == null) {\n+            localClient = new ClientType();\n+            localClient.setIdentifier(clientId);\n+            localClient.setClientStatus(ClientType.STATUS_SAVED);\n+            localClient.setIsAuthentication(IsAuthentication.SSLAUTH.name());\n+        }\n+        return localClient;\n+    }\n+\n+    /**\n+     * Verify that the initialization process can proceed and that the security server has not already been\n+     * initialized. This means verifying that an anchor has been imported,\n+     * server conf does not exist and a software token has not yet been initialized. This method could also be\n+     * changed into throwing an UnhandledWarningsException with warning metadata instead of the current\n+     * InitializationException if partial init needs to be supported in the future\n+     * @throws InitializationException if server conf exists OR software token is already initialized\n+     */\n+    private void verifyInitializationPrerequisites() throws InitializationException {\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda6994499a830df4da99e64feabdd7afff679e8"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ3NzE4Nw==", "bodyText": "Based on the discussion, it seems that partial init should be implemented", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423477187", "createdAt": "2020-05-12T05:52:29Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is\n+     * enforced by properties)\n+     * @throws InvalidPinException if the provided pin code does not follow the TokenPinPolicy (if token pin policy is\n+     * enforced by properties)\n+     * @throws SoftwareTokenInitException if something goes wrong with the token init\n+     */\n+    public void initialize(String securityServerCode, String ownerMemberClass, String ownerMemberCode,\n+            String softwareTokenPin, boolean ignoreWarnings) throws AnchorNotFoundException, InitializationException,\n+            UnhandledWarningsException, WeakPinException, InvalidPinException, SoftwareTokenInitException {\n+        if (!systemService.isAnchorImported()) {\n+            throw new AnchorNotFoundException(\"Configuration anchor was not found.\");\n+        }\n+        verifyInitializationPrerequisites();\n+        String instanceIdentifier = globalConfFacade.getInstanceIdentifier();\n+        // get id from db if exists - this is for partial init support since no client ids should yet exist\n+        ClientId ownerClientId = clientService.getPossiblyManagedEntity(ClientId.create(instanceIdentifier,\n+                ownerMemberClass, ownerMemberCode));\n+        if (!ignoreWarnings) {\n+            checkForWarnings(ownerClientId, securityServerCode);\n+        }\n+        // --- Start the init ---\n+        ServerConfType serverConf = createInitialServerConf(ownerClientId, securityServerCode);\n+        initializeSoftwareToken(softwareTokenPin);\n+        serverConfService.saveOrUpdate(serverConf);\n+    }\n+\n+    /**\n+     * Helper to create a software token\n+     * @param softwareTokenPin the pin of the token\n+     * @throws InvalidPinException\n+     * @throws WeakPinException\n+     * @throws SoftwareTokenInitException\n+     */\n+    private void initializeSoftwareToken(String softwareTokenPin) throws InvalidPinException, WeakPinException,\n+            SoftwareTokenInitException {\n+        char[] pin = softwareTokenPin.toCharArray();\n+        if (isTokenPinEnforced) {\n+            TokenPinPolicy.Description description = TokenPinPolicy.describe(pin);\n+            if (!description.isValid()) {\n+                if (description.hasInvalidCharacters()) {\n+                    throw new InvalidPinException(\"The provided pin code does not match with the pin code policy\");\n+                }\n+                List<String> metadata = new ArrayList<>();\n+                metadata.add(METADATA_PIN_MIN_LENGTH);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_PASSWORD_LENGTH));\n+                metadata.add(METADATA_PIN_MIN_CHAR_CLASSES);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_CHARACTER_CLASS_COUNT));\n+                throw new WeakPinException(\"The provided pin code was too weak\", metadata);\n+            }\n+        }\n+        try {\n+            signerProxyFacade.initSoftwareToken(pin);\n+        } catch (Exception e) {\n+            // not good\n+            throw new SoftwareTokenInitException(\"Error initializing software token\", e);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create the initial server conf\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @return ServerConfType\n+     */\n+    private ServerConfType createInitialServerConf(ClientId ownerClientId, String securityServerCode) {\n+        /* get serverconf from db if exists\n+           - this is for partial init support since no server confs should yet exist\n+         */\n+        ServerConfType serverConf = serverConfService.getOrCreateServerConf();\n+        ClientType ownerClient = null;\n+        // get client from db if exists - this is for partial init support since no clients should yet exist\n+        Optional<ClientType> foundClient = serverConf.getClient().stream()\n+                .filter(clientType -> clientType.getIdentifier().equals(ownerClientId))\n+                .findFirst();\n+        ownerClient = foundClient.orElse(getInitialClient(ownerClientId));\n+        ownerClient.setConf(serverConf);\n+        // again for partial init support: if the client already exists there is no reason to add it again\n+        if (!serverConf.getClient().contains(ownerClient)) {\n+            serverConf.getClient().add(ownerClient);\n+        }\n+        serverConf.setOwner(ownerClient);\n+        serverConf.setServerCode(securityServerCode);\n+        return serverConf;\n+    }\n+\n+    /**\n+     * Helper to check for warnings\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @throws UnhandledWarningsException\n+     */\n+    private void checkForWarnings(ClientId ownerClientId, String securityServerCode)\n+            throws UnhandledWarningsException {\n+        String ownerMemberName = globalConfFacade.getMemberName(ownerClientId);\n+        SecurityServerId serverId = SecurityServerId.create(ownerClientId, securityServerCode);\n+        List<WarningDeviation> warnings = new ArrayList<>();\n+        if (StringUtils.isEmpty(ownerMemberName)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_UNREGISTERED_MEMBER,\n+                    ownerClientId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (globalConfFacade.existsSecurityServer(serverId)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_SERVER_ID_EXISTS,\n+                    serverId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (!warnings.isEmpty()) {\n+            throw new UnhandledWarningsException(warnings);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create an initial client\n+     * @param clientId\n+     * @return\n+     */\n+    private ClientType getInitialClient(ClientId clientId) {\n+        ClientType localClient = clientService.getLocalClient(clientId);\n+        if (localClient == null) {\n+            localClient = new ClientType();\n+            localClient.setIdentifier(clientId);\n+            localClient.setClientStatus(ClientType.STATUS_SAVED);\n+            localClient.setIsAuthentication(IsAuthentication.SSLAUTH.name());\n+        }\n+        return localClient;\n+    }\n+\n+    /**\n+     * Verify that the initialization process can proceed and that the security server has not already been\n+     * initialized. This means verifying that an anchor has been imported,\n+     * server conf does not exist and a software token has not yet been initialized. This method could also be\n+     * changed into throwing an UnhandledWarningsException with warning metadata instead of the current\n+     * InitializationException if partial init needs to be supported in the future\n+     * @throws InitializationException if server conf exists OR software token is already initialized\n+     */\n+    private void verifyInitializationPrerequisites() throws InitializationException {\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2NTMzNQ=="}, "originalCommit": {"oid": "dda6994499a830df4da99e64feabdd7afff679e8"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1NDcwMw==", "bodyText": "Partial init has been implemented.\nPrimary changes:\nThe init endpoint itself does not have any mandatory parameters anymore because the user must be able to initialize for example only the software token (while skipping other init parts such as server code and server owner). However the parameters are required for each missing part of the initialization. For example: if server owner has not been initialized, the server owner parameters are mandatory in the request, otherwise a MissingInitParamsException is thrown.\nAlso prerequisite check now throws warnings (depending on ignore_warnings flag) if the Security Server already has some initialized parts.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424354703", "createdAt": "2020-05-13T11:07:30Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is\n+     * enforced by properties)\n+     * @throws InvalidPinException if the provided pin code does not follow the TokenPinPolicy (if token pin policy is\n+     * enforced by properties)\n+     * @throws SoftwareTokenInitException if something goes wrong with the token init\n+     */\n+    public void initialize(String securityServerCode, String ownerMemberClass, String ownerMemberCode,\n+            String softwareTokenPin, boolean ignoreWarnings) throws AnchorNotFoundException, InitializationException,\n+            UnhandledWarningsException, WeakPinException, InvalidPinException, SoftwareTokenInitException {\n+        if (!systemService.isAnchorImported()) {\n+            throw new AnchorNotFoundException(\"Configuration anchor was not found.\");\n+        }\n+        verifyInitializationPrerequisites();\n+        String instanceIdentifier = globalConfFacade.getInstanceIdentifier();\n+        // get id from db if exists - this is for partial init support since no client ids should yet exist\n+        ClientId ownerClientId = clientService.getPossiblyManagedEntity(ClientId.create(instanceIdentifier,\n+                ownerMemberClass, ownerMemberCode));\n+        if (!ignoreWarnings) {\n+            checkForWarnings(ownerClientId, securityServerCode);\n+        }\n+        // --- Start the init ---\n+        ServerConfType serverConf = createInitialServerConf(ownerClientId, securityServerCode);\n+        initializeSoftwareToken(softwareTokenPin);\n+        serverConfService.saveOrUpdate(serverConf);\n+    }\n+\n+    /**\n+     * Helper to create a software token\n+     * @param softwareTokenPin the pin of the token\n+     * @throws InvalidPinException\n+     * @throws WeakPinException\n+     * @throws SoftwareTokenInitException\n+     */\n+    private void initializeSoftwareToken(String softwareTokenPin) throws InvalidPinException, WeakPinException,\n+            SoftwareTokenInitException {\n+        char[] pin = softwareTokenPin.toCharArray();\n+        if (isTokenPinEnforced) {\n+            TokenPinPolicy.Description description = TokenPinPolicy.describe(pin);\n+            if (!description.isValid()) {\n+                if (description.hasInvalidCharacters()) {\n+                    throw new InvalidPinException(\"The provided pin code does not match with the pin code policy\");\n+                }\n+                List<String> metadata = new ArrayList<>();\n+                metadata.add(METADATA_PIN_MIN_LENGTH);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_PASSWORD_LENGTH));\n+                metadata.add(METADATA_PIN_MIN_CHAR_CLASSES);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_CHARACTER_CLASS_COUNT));\n+                throw new WeakPinException(\"The provided pin code was too weak\", metadata);\n+            }\n+        }\n+        try {\n+            signerProxyFacade.initSoftwareToken(pin);\n+        } catch (Exception e) {\n+            // not good\n+            throw new SoftwareTokenInitException(\"Error initializing software token\", e);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create the initial server conf\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @return ServerConfType\n+     */\n+    private ServerConfType createInitialServerConf(ClientId ownerClientId, String securityServerCode) {\n+        /* get serverconf from db if exists\n+           - this is for partial init support since no server confs should yet exist\n+         */\n+        ServerConfType serverConf = serverConfService.getOrCreateServerConf();\n+        ClientType ownerClient = null;\n+        // get client from db if exists - this is for partial init support since no clients should yet exist\n+        Optional<ClientType> foundClient = serverConf.getClient().stream()\n+                .filter(clientType -> clientType.getIdentifier().equals(ownerClientId))\n+                .findFirst();\n+        ownerClient = foundClient.orElse(getInitialClient(ownerClientId));\n+        ownerClient.setConf(serverConf);\n+        // again for partial init support: if the client already exists there is no reason to add it again\n+        if (!serverConf.getClient().contains(ownerClient)) {\n+            serverConf.getClient().add(ownerClient);\n+        }\n+        serverConf.setOwner(ownerClient);\n+        serverConf.setServerCode(securityServerCode);\n+        return serverConf;\n+    }\n+\n+    /**\n+     * Helper to check for warnings\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @throws UnhandledWarningsException\n+     */\n+    private void checkForWarnings(ClientId ownerClientId, String securityServerCode)\n+            throws UnhandledWarningsException {\n+        String ownerMemberName = globalConfFacade.getMemberName(ownerClientId);\n+        SecurityServerId serverId = SecurityServerId.create(ownerClientId, securityServerCode);\n+        List<WarningDeviation> warnings = new ArrayList<>();\n+        if (StringUtils.isEmpty(ownerMemberName)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_UNREGISTERED_MEMBER,\n+                    ownerClientId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (globalConfFacade.existsSecurityServer(serverId)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_SERVER_ID_EXISTS,\n+                    serverId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (!warnings.isEmpty()) {\n+            throw new UnhandledWarningsException(warnings);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create an initial client\n+     * @param clientId\n+     * @return\n+     */\n+    private ClientType getInitialClient(ClientId clientId) {\n+        ClientType localClient = clientService.getLocalClient(clientId);\n+        if (localClient == null) {\n+            localClient = new ClientType();\n+            localClient.setIdentifier(clientId);\n+            localClient.setClientStatus(ClientType.STATUS_SAVED);\n+            localClient.setIsAuthentication(IsAuthentication.SSLAUTH.name());\n+        }\n+        return localClient;\n+    }\n+\n+    /**\n+     * Verify that the initialization process can proceed and that the security server has not already been\n+     * initialized. This means verifying that an anchor has been imported,\n+     * server conf does not exist and a software token has not yet been initialized. This method could also be\n+     * changed into throwing an UnhandledWarningsException with warning metadata instead of the current\n+     * InitializationException if partial init needs to be supported in the future\n+     * @throws InitializationException if server conf exists OR software token is already initialized\n+     */\n+    private void verifyInitializationPrerequisites() throws InitializationException {\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2NTMzNQ=="}, "originalCommit": {"oid": "dda6994499a830df4da99e64feabdd7afff679e8"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMzk5NzU0OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMToyMDoxNlrOGTX-5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMTowOTozMVrOGUsnGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2OTA2Mg==", "bodyText": "nitpick: isSecurityServerInitialized typically returns boolean. E.g. getSecurityServerInitializationStatus might be more idiomatic naming", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422969062", "createdAt": "2020-05-11T11:20:16Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda6994499a830df4da99e64feabdd7afff679e8"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1NTYwOA==", "bodyText": "Fixed. Originally this returned one boolean. In the current and newest implementation this returns four different booleans in the form of a dto.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424355608", "createdAt": "2020-05-13T11:09:31Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2OTA2Mg=="}, "originalCommit": {"oid": "dda6994499a830df4da99e64feabdd7afff679e8"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDA1NzY4OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/ServerConfService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTozODozOFrOGTYi-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMToxODo0N1rOGUs4Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODI5OQ==", "bodyText": "If we intend to ignore specifically X_MALFORMED_SERVERCONF, it would be even better to check against the faultCode, and rethrow others. Otherwise there's a possibility for hiding errors, if other types of CodedExceptions happen (which is unlikely, but not impossible, could be a result of some unrelated future change in ServerConfDAOImpl).", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422978299", "createdAt": "2020-05-11T11:38:38Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/ServerConfService.java", "diffHunk": "@@ -91,4 +108,30 @@ public ClientId getSecurityServerOwnerId() {\n         Hibernate.initialize(tsp);\n         return tsp;\n     }\n+\n+    /**\n+     * Is server conf initialized -> it is if whe can find one\n+     * @return\n+     */\n+    public boolean isServerConfInitialized() {\n+        boolean isServerConfInitialized = false;\n+        try {\n+            ServerConfType serverConfType = getServerConf();\n+            if (serverConfType != null) {\n+                isServerConfInitialized = true;\n+            }\n+        } catch (CodedException ce) { // -> this is X_MALFORMED_SERVERCONF, \"Server conf is not initialized!\"\n+            log.info(\"ServerConfService#isServerConfInitialized: CodedException thrown when getting Server Conf\", ce);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1OTk3OA==", "bodyText": "Fixed. The faultCode is now checked and if it is something else than X_MALFORMED_SERVERCONF -> rethrow the CodedException.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424359978", "createdAt": "2020-05-13T11:18:47Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/ServerConfService.java", "diffHunk": "@@ -91,4 +108,30 @@ public ClientId getSecurityServerOwnerId() {\n         Hibernate.initialize(tsp);\n         return tsp;\n     }\n+\n+    /**\n+     * Is server conf initialized -> it is if whe can find one\n+     * @return\n+     */\n+    public boolean isServerConfInitialized() {\n+        boolean isServerConfInitialized = false;\n+        try {\n+            ServerConfType serverConfType = getServerConf();\n+            if (serverConfType != null) {\n+                isServerConfInitialized = true;\n+            }\n+        } catch (CodedException ce) { // -> this is X_MALFORMED_SERVERCONF, \"Server conf is not initialized!\"\n+            log.info(\"ServerConfService#isServerConfInitialized: CodedException thrown when getting Server Conf\", ce);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODI5OQ=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDA3NDIxOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTo0Mzo1OVrOGTYtcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMToyNDoxNFrOGUtCuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4MDk3Nw==", "bodyText": "Why is dto's isServerConfInitialized a combination of isServerConfInitialized and isSoftwareTokenInitialized? It feels a bit weird. Should dto.isServerConfInitialized maybe be renamed, or should dto contain both isServerConfInitialized and isSoftwareTokenInitialized separately? Maybe also not in sync with javadoc, which describes init status as consisting of 3 parts.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422980977", "createdAt": "2020-05-11T11:43:59Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2MjY4MQ==", "bodyText": "This was due to the partial init not being supported. Now that it is supported we also return each individual boolean in the dto.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424362681", "createdAt": "2020-05-13T11:24:14Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4MDk3Nw=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDA3NjEzOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTo0NDo0MlrOGTYuoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTo0NDo0MlrOGTYuoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4MTI4MA==", "bodyText": "Pro level javadocs here and elsewhere, too \ud83d\udc4d", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422981280", "createdAt": "2020-05-11T11:44:42Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDE2NzA2OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjoxNDo0MVrOGTZn7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMToyODoxNVrOGUtKiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5NTk1MA==", "bodyText": "Had some trouble understanding WeakPinException and InvalidPinException initially. Reading the exception names and javadocs made me think \"Isn't a weak pin also an invalid PIN? And what is InvalidPinException about, if not length and complexity requirements\".\nI guess the idea is that frontend will be able to show proper error messages based on classification to error types invalid_pin and weak_pin? And that there will likely be two different error messages?\nThe difference between invalid_pin and weak_pin does not seem too obvious. Could also do some renaming and updating of javadocs to make it more clear? To me it looks like bad characters in PIN is invalid_pin and too few characters or too few character classes is weak_pin. But it took a few rereads to understand that.\nThere's also the possibility of using one single exception class InvalidPinException and using the same metadata-based way of specifying how exactly was it invalid as is already used for weak / METADATA_PIN_MIN_LENGTH and weak / METADATA_PIN_MIN_CHAR_CLASSES. I am not sure if it would be better or worse.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422995950", "createdAt": "2020-05-11T12:14:41Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2NDY4MQ==", "bodyText": "I just renamed the InvalidPinException to InvalidCharactersException and added javadocs for further explanation", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424364681", "createdAt": "2020-05-13T11:28:15Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5NTk1MA=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDE3NTY3OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjoxNzoxOFrOGTZtdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMjozNzowMlrOGUvdQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5NzM2NA==", "bodyText": "This method does not verify that anchor has been imported, but javadoc days it does?", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r422997364", "createdAt": "2020-05-11T12:17:18Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is\n+     * enforced by properties)\n+     * @throws InvalidPinException if the provided pin code does not follow the TokenPinPolicy (if token pin policy is\n+     * enforced by properties)\n+     * @throws SoftwareTokenInitException if something goes wrong with the token init\n+     */\n+    public void initialize(String securityServerCode, String ownerMemberClass, String ownerMemberCode,\n+            String softwareTokenPin, boolean ignoreWarnings) throws AnchorNotFoundException, InitializationException,\n+            UnhandledWarningsException, WeakPinException, InvalidPinException, SoftwareTokenInitException {\n+        if (!systemService.isAnchorImported()) {\n+            throw new AnchorNotFoundException(\"Configuration anchor was not found.\");\n+        }\n+        verifyInitializationPrerequisites();\n+        String instanceIdentifier = globalConfFacade.getInstanceIdentifier();\n+        // get id from db if exists - this is for partial init support since no client ids should yet exist\n+        ClientId ownerClientId = clientService.getPossiblyManagedEntity(ClientId.create(instanceIdentifier,\n+                ownerMemberClass, ownerMemberCode));\n+        if (!ignoreWarnings) {\n+            checkForWarnings(ownerClientId, securityServerCode);\n+        }\n+        // --- Start the init ---\n+        ServerConfType serverConf = createInitialServerConf(ownerClientId, securityServerCode);\n+        initializeSoftwareToken(softwareTokenPin);\n+        serverConfService.saveOrUpdate(serverConf);\n+    }\n+\n+    /**\n+     * Helper to create a software token\n+     * @param softwareTokenPin the pin of the token\n+     * @throws InvalidPinException\n+     * @throws WeakPinException\n+     * @throws SoftwareTokenInitException\n+     */\n+    private void initializeSoftwareToken(String softwareTokenPin) throws InvalidPinException, WeakPinException,\n+            SoftwareTokenInitException {\n+        char[] pin = softwareTokenPin.toCharArray();\n+        if (isTokenPinEnforced) {\n+            TokenPinPolicy.Description description = TokenPinPolicy.describe(pin);\n+            if (!description.isValid()) {\n+                if (description.hasInvalidCharacters()) {\n+                    throw new InvalidPinException(\"The provided pin code does not match with the pin code policy\");\n+                }\n+                List<String> metadata = new ArrayList<>();\n+                metadata.add(METADATA_PIN_MIN_LENGTH);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_PASSWORD_LENGTH));\n+                metadata.add(METADATA_PIN_MIN_CHAR_CLASSES);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_CHARACTER_CLASS_COUNT));\n+                throw new WeakPinException(\"The provided pin code was too weak\", metadata);\n+            }\n+        }\n+        try {\n+            signerProxyFacade.initSoftwareToken(pin);\n+        } catch (Exception e) {\n+            // not good\n+            throw new SoftwareTokenInitException(\"Error initializing software token\", e);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create the initial server conf\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @return ServerConfType\n+     */\n+    private ServerConfType createInitialServerConf(ClientId ownerClientId, String securityServerCode) {\n+        /* get serverconf from db if exists\n+           - this is for partial init support since no server confs should yet exist\n+         */\n+        ServerConfType serverConf = serverConfService.getOrCreateServerConf();\n+        ClientType ownerClient = null;\n+        // get client from db if exists - this is for partial init support since no clients should yet exist\n+        Optional<ClientType> foundClient = serverConf.getClient().stream()\n+                .filter(clientType -> clientType.getIdentifier().equals(ownerClientId))\n+                .findFirst();\n+        ownerClient = foundClient.orElse(getInitialClient(ownerClientId));\n+        ownerClient.setConf(serverConf);\n+        // again for partial init support: if the client already exists there is no reason to add it again\n+        if (!serverConf.getClient().contains(ownerClient)) {\n+            serverConf.getClient().add(ownerClient);\n+        }\n+        serverConf.setOwner(ownerClient);\n+        serverConf.setServerCode(securityServerCode);\n+        return serverConf;\n+    }\n+\n+    /**\n+     * Helper to check for warnings\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @throws UnhandledWarningsException\n+     */\n+    private void checkForWarnings(ClientId ownerClientId, String securityServerCode)\n+            throws UnhandledWarningsException {\n+        String ownerMemberName = globalConfFacade.getMemberName(ownerClientId);\n+        SecurityServerId serverId = SecurityServerId.create(ownerClientId, securityServerCode);\n+        List<WarningDeviation> warnings = new ArrayList<>();\n+        if (StringUtils.isEmpty(ownerMemberName)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_UNREGISTERED_MEMBER,\n+                    ownerClientId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (globalConfFacade.existsSecurityServer(serverId)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_SERVER_ID_EXISTS,\n+                    serverId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (!warnings.isEmpty()) {\n+            throw new UnhandledWarningsException(warnings);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create an initial client\n+     * @param clientId\n+     * @return\n+     */\n+    private ClientType getInitialClient(ClientId clientId) {\n+        ClientType localClient = clientService.getLocalClient(clientId);\n+        if (localClient == null) {\n+            localClient = new ClientType();\n+            localClient.setIdentifier(clientId);\n+            localClient.setClientStatus(ClientType.STATUS_SAVED);\n+            localClient.setIsAuthentication(IsAuthentication.SSLAUTH.name());\n+        }\n+        return localClient;\n+    }\n+\n+    /**\n+     * Verify that the initialization process can proceed and that the security server has not already been\n+     * initialized. This means verifying that an anchor has been imported,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwMjI0Mw==", "bodyText": "The anchor is verified before this. The whole prerequisite check is now different - so fixed", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424402243", "createdAt": "2020-05-13T12:37:02Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is\n+     * enforced by properties)\n+     * @throws InvalidPinException if the provided pin code does not follow the TokenPinPolicy (if token pin policy is\n+     * enforced by properties)\n+     * @throws SoftwareTokenInitException if something goes wrong with the token init\n+     */\n+    public void initialize(String securityServerCode, String ownerMemberClass, String ownerMemberCode,\n+            String softwareTokenPin, boolean ignoreWarnings) throws AnchorNotFoundException, InitializationException,\n+            UnhandledWarningsException, WeakPinException, InvalidPinException, SoftwareTokenInitException {\n+        if (!systemService.isAnchorImported()) {\n+            throw new AnchorNotFoundException(\"Configuration anchor was not found.\");\n+        }\n+        verifyInitializationPrerequisites();\n+        String instanceIdentifier = globalConfFacade.getInstanceIdentifier();\n+        // get id from db if exists - this is for partial init support since no client ids should yet exist\n+        ClientId ownerClientId = clientService.getPossiblyManagedEntity(ClientId.create(instanceIdentifier,\n+                ownerMemberClass, ownerMemberCode));\n+        if (!ignoreWarnings) {\n+            checkForWarnings(ownerClientId, securityServerCode);\n+        }\n+        // --- Start the init ---\n+        ServerConfType serverConf = createInitialServerConf(ownerClientId, securityServerCode);\n+        initializeSoftwareToken(softwareTokenPin);\n+        serverConfService.saveOrUpdate(serverConf);\n+    }\n+\n+    /**\n+     * Helper to create a software token\n+     * @param softwareTokenPin the pin of the token\n+     * @throws InvalidPinException\n+     * @throws WeakPinException\n+     * @throws SoftwareTokenInitException\n+     */\n+    private void initializeSoftwareToken(String softwareTokenPin) throws InvalidPinException, WeakPinException,\n+            SoftwareTokenInitException {\n+        char[] pin = softwareTokenPin.toCharArray();\n+        if (isTokenPinEnforced) {\n+            TokenPinPolicy.Description description = TokenPinPolicy.describe(pin);\n+            if (!description.isValid()) {\n+                if (description.hasInvalidCharacters()) {\n+                    throw new InvalidPinException(\"The provided pin code does not match with the pin code policy\");\n+                }\n+                List<String> metadata = new ArrayList<>();\n+                metadata.add(METADATA_PIN_MIN_LENGTH);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_PASSWORD_LENGTH));\n+                metadata.add(METADATA_PIN_MIN_CHAR_CLASSES);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_CHARACTER_CLASS_COUNT));\n+                throw new WeakPinException(\"The provided pin code was too weak\", metadata);\n+            }\n+        }\n+        try {\n+            signerProxyFacade.initSoftwareToken(pin);\n+        } catch (Exception e) {\n+            // not good\n+            throw new SoftwareTokenInitException(\"Error initializing software token\", e);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create the initial server conf\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @return ServerConfType\n+     */\n+    private ServerConfType createInitialServerConf(ClientId ownerClientId, String securityServerCode) {\n+        /* get serverconf from db if exists\n+           - this is for partial init support since no server confs should yet exist\n+         */\n+        ServerConfType serverConf = serverConfService.getOrCreateServerConf();\n+        ClientType ownerClient = null;\n+        // get client from db if exists - this is for partial init support since no clients should yet exist\n+        Optional<ClientType> foundClient = serverConf.getClient().stream()\n+                .filter(clientType -> clientType.getIdentifier().equals(ownerClientId))\n+                .findFirst();\n+        ownerClient = foundClient.orElse(getInitialClient(ownerClientId));\n+        ownerClient.setConf(serverConf);\n+        // again for partial init support: if the client already exists there is no reason to add it again\n+        if (!serverConf.getClient().contains(ownerClient)) {\n+            serverConf.getClient().add(ownerClient);\n+        }\n+        serverConf.setOwner(ownerClient);\n+        serverConf.setServerCode(securityServerCode);\n+        return serverConf;\n+    }\n+\n+    /**\n+     * Helper to check for warnings\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @throws UnhandledWarningsException\n+     */\n+    private void checkForWarnings(ClientId ownerClientId, String securityServerCode)\n+            throws UnhandledWarningsException {\n+        String ownerMemberName = globalConfFacade.getMemberName(ownerClientId);\n+        SecurityServerId serverId = SecurityServerId.create(ownerClientId, securityServerCode);\n+        List<WarningDeviation> warnings = new ArrayList<>();\n+        if (StringUtils.isEmpty(ownerMemberName)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_UNREGISTERED_MEMBER,\n+                    ownerClientId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (globalConfFacade.existsSecurityServer(serverId)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_SERVER_ID_EXISTS,\n+                    serverId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (!warnings.isEmpty()) {\n+            throw new UnhandledWarningsException(warnings);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create an initial client\n+     * @param clientId\n+     * @return\n+     */\n+    private ClientType getInitialClient(ClientId clientId) {\n+        ClientType localClient = clientService.getLocalClient(clientId);\n+        if (localClient == null) {\n+            localClient = new ClientType();\n+            localClient.setIdentifier(clientId);\n+            localClient.setClientStatus(ClientType.STATUS_SAVED);\n+            localClient.setIsAuthentication(IsAuthentication.SSLAUTH.name());\n+        }\n+        return localClient;\n+    }\n+\n+    /**\n+     * Verify that the initialization process can proceed and that the security server has not already been\n+     * initialized. This means verifying that an anchor has been imported,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5NzM2NA=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDE5MzEwOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/ServerConfService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjoyMjo0NVrOGTZ4qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMjozODoyN1rOGUvgnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAwMDIzNQ==", "bodyText": "Same comment as in isServerConfInitialized about CodedExceptions.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423000235", "createdAt": "2020-05-11T12:22:45Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/ServerConfService.java", "diffHunk": "@@ -62,6 +63,22 @@ public ServerConfType getServerConf() {\n         return serverConfRepository.getServerConf();\n     }\n \n+    /**\n+     * Get a server conf; an existing server conf will be returned if one exists. Otherwise\n+     * a new transient instance is returned.\n+     * @return\n+     */\n+    public ServerConfType getOrCreateServerConf() {\n+        ServerConfType serverConfType = null;\n+        try {\n+            serverConfType = getServerConf();\n+        } catch (CodedException ce) {\n+            // server conf doesn't exist which is fine - let's just create one", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwMzEwMA==", "bodyText": "Fixed", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424403100", "createdAt": "2020-05-13T12:38:27Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/ServerConfService.java", "diffHunk": "@@ -62,6 +63,22 @@ public ServerConfType getServerConf() {\n         return serverConfRepository.getServerConf();\n     }\n \n+    /**\n+     * Get a server conf; an existing server conf will be returned if one exists. Otherwise\n+     * a new transient instance is returned.\n+     * @return\n+     */\n+    public ServerConfType getOrCreateServerConf() {\n+        ServerConfType serverConfType = null;\n+        try {\n+            serverConfType = getServerConf();\n+        } catch (CodedException ce) {\n+            // server conf doesn't exist which is fine - let's just create one", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAwMDIzNQ=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDIzMDQ5OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/openapi/SystemApiController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjozNDowNFrOGTaQSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMjozODo1MFrOGUvheQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAwNjI4MA==", "bodyText": "Should AnchorAlreadyExistsException be a conflict?", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423006280", "createdAt": "2020-05-11T12:34:04Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/openapi/SystemApiController.java", "diffHunk": "@@ -235,14 +235,36 @@ public SystemApiController(InternalTlsCertificateService internalTlsCertificateS\n \n     @Override\n     @PreAuthorize(\"hasAuthority('UPLOAD_ANCHOR')\")\n-    public ResponseEntity<Anchor> previewAnchor(Resource anchorResource) {\n+    public ResponseEntity<Anchor> previewAnchor(Boolean verifyInstance, Resource anchorResource) {\n         byte[] anchorBytes = ResourceUtils.springResourceToBytesOrThrowBadRequest(anchorResource);\n         AnchorFile anchorFile = null;\n         try {\n-            anchorFile = systemService.getAnchorFileFromBytes(anchorBytes);\n+            anchorFile = systemService.getAnchorFileFromBytes(anchorBytes, verifyInstance);\n         } catch (SystemService.InvalidAnchorInstanceException | SystemService.MalformedAnchorException e) {\n             throw new BadRequestException(e);\n         }\n         return new ResponseEntity<>(anchorConverter.convert(anchorFile), HttpStatus.OK);\n     }\n+\n+    /**\n+     * For uploading an initial configuration anchor. The difference between this and {@link #uploadAnchor(Resource)}\n+     * is that the anchor's instance does not get verified\n+     * @param anchorResource\n+     * @return\n+     */\n+    @Override\n+    @PreAuthorize(\"hasAuthority('INIT_CONFIG')\")\n+    public ResponseEntity<Void> uploadInitialAnchor(Resource anchorResource) {\n+        byte[] anchorBytes = ResourceUtils.springResourceToBytesOrThrowBadRequest(anchorResource);\n+        try {\n+            systemService.uploadInitialAnchor(anchorBytes);\n+        } catch (SystemService.InvalidAnchorInstanceException | SystemService.MalformedAnchorException\n+                | SystemService.AnchorAlreadyExistsException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwMzMyMQ==", "bodyText": "It probably should! Changed", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424403321", "createdAt": "2020-05-13T12:38:50Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/openapi/SystemApiController.java", "diffHunk": "@@ -235,14 +235,36 @@ public SystemApiController(InternalTlsCertificateService internalTlsCertificateS\n \n     @Override\n     @PreAuthorize(\"hasAuthority('UPLOAD_ANCHOR')\")\n-    public ResponseEntity<Anchor> previewAnchor(Resource anchorResource) {\n+    public ResponseEntity<Anchor> previewAnchor(Boolean verifyInstance, Resource anchorResource) {\n         byte[] anchorBytes = ResourceUtils.springResourceToBytesOrThrowBadRequest(anchorResource);\n         AnchorFile anchorFile = null;\n         try {\n-            anchorFile = systemService.getAnchorFileFromBytes(anchorBytes);\n+            anchorFile = systemService.getAnchorFileFromBytes(anchorBytes, verifyInstance);\n         } catch (SystemService.InvalidAnchorInstanceException | SystemService.MalformedAnchorException e) {\n             throw new BadRequestException(e);\n         }\n         return new ResponseEntity<>(anchorConverter.convert(anchorFile), HttpStatus.OK);\n     }\n+\n+    /**\n+     * For uploading an initial configuration anchor. The difference between this and {@link #uploadAnchor(Resource)}\n+     * is that the anchor's instance does not get verified\n+     * @param anchorResource\n+     * @return\n+     */\n+    @Override\n+    @PreAuthorize(\"hasAuthority('INIT_CONFIG')\")\n+    public ResponseEntity<Void> uploadInitialAnchor(Resource anchorResource) {\n+        byte[] anchorBytes = ResourceUtils.springResourceToBytesOrThrowBadRequest(anchorResource);\n+        try {\n+            systemService.uploadInitialAnchor(anchorBytes);\n+        } catch (SystemService.InvalidAnchorInstanceException | SystemService.MalformedAnchorException\n+                | SystemService.AnchorAlreadyExistsException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAwNjI4MA=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDI2MzUyOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0Mzo1OVrOGTalcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMjozOToxMlrOGUviUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTY5Ng==", "bodyText": "Maybe a couple of words about ignoreWarnings and UnhandledWarningsException would be good, since it is a kind of complicated concept.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423011696", "createdAt": "2020-05-11T12:43:59Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwMzUzOA==", "bodyText": "Added some better explanations in javadocs", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424403538", "createdAt": "2020-05-13T12:39:12Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTY5Ng=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDI3Njc3OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0NzozM1rOGTatgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNjowODo1MlrOGVNR_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMzc2Mg==", "bodyText": "nitpick: maybe instead of \"going south\" something more neutral, since it is a bit conversational and codebase is sort of official and open source (this was an extreme nitpick, sorry)", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423013762", "createdAt": "2020-05-11T12:47:33Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is\n+     * enforced by properties)\n+     * @throws InvalidPinException if the provided pin code does not follow the TokenPinPolicy (if token pin policy is\n+     * enforced by properties)\n+     * @throws SoftwareTokenInitException if something goes wrong with the token init\n+     */\n+    public void initialize(String securityServerCode, String ownerMemberClass, String ownerMemberCode,\n+            String softwareTokenPin, boolean ignoreWarnings) throws AnchorNotFoundException, InitializationException,\n+            UnhandledWarningsException, WeakPinException, InvalidPinException, SoftwareTokenInitException {\n+        if (!systemService.isAnchorImported()) {\n+            throw new AnchorNotFoundException(\"Configuration anchor was not found.\");\n+        }\n+        verifyInitializationPrerequisites();\n+        String instanceIdentifier = globalConfFacade.getInstanceIdentifier();\n+        // get id from db if exists - this is for partial init support since no client ids should yet exist\n+        ClientId ownerClientId = clientService.getPossiblyManagedEntity(ClientId.create(instanceIdentifier,\n+                ownerMemberClass, ownerMemberCode));\n+        if (!ignoreWarnings) {\n+            checkForWarnings(ownerClientId, securityServerCode);\n+        }\n+        // --- Start the init ---\n+        ServerConfType serverConf = createInitialServerConf(ownerClientId, securityServerCode);\n+        initializeSoftwareToken(softwareTokenPin);\n+        serverConfService.saveOrUpdate(serverConf);\n+    }\n+\n+    /**\n+     * Helper to create a software token\n+     * @param softwareTokenPin the pin of the token\n+     * @throws InvalidPinException\n+     * @throws WeakPinException\n+     * @throws SoftwareTokenInitException\n+     */\n+    private void initializeSoftwareToken(String softwareTokenPin) throws InvalidPinException, WeakPinException,\n+            SoftwareTokenInitException {\n+        char[] pin = softwareTokenPin.toCharArray();\n+        if (isTokenPinEnforced) {\n+            TokenPinPolicy.Description description = TokenPinPolicy.describe(pin);\n+            if (!description.isValid()) {\n+                if (description.hasInvalidCharacters()) {\n+                    throw new InvalidPinException(\"The provided pin code does not match with the pin code policy\");\n+                }\n+                List<String> metadata = new ArrayList<>();\n+                metadata.add(METADATA_PIN_MIN_LENGTH);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_PASSWORD_LENGTH));\n+                metadata.add(METADATA_PIN_MIN_CHAR_CLASSES);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_CHARACTER_CLASS_COUNT));\n+                throw new WeakPinException(\"The provided pin code was too weak\", metadata);\n+            }\n+        }\n+        try {\n+            signerProxyFacade.initSoftwareToken(pin);\n+        } catch (Exception e) {\n+            // not good\n+            throw new SoftwareTokenInitException(\"Error initializing software token\", e);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create the initial server conf\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @return ServerConfType\n+     */\n+    private ServerConfType createInitialServerConf(ClientId ownerClientId, String securityServerCode) {\n+        /* get serverconf from db if exists\n+           - this is for partial init support since no server confs should yet exist\n+         */\n+        ServerConfType serverConf = serverConfService.getOrCreateServerConf();\n+        ClientType ownerClient = null;\n+        // get client from db if exists - this is for partial init support since no clients should yet exist\n+        Optional<ClientType> foundClient = serverConf.getClient().stream()\n+                .filter(clientType -> clientType.getIdentifier().equals(ownerClientId))\n+                .findFirst();\n+        ownerClient = foundClient.orElse(getInitialClient(ownerClientId));\n+        ownerClient.setConf(serverConf);\n+        // again for partial init support: if the client already exists there is no reason to add it again\n+        if (!serverConf.getClient().contains(ownerClient)) {\n+            serverConf.getClient().add(ownerClient);\n+        }\n+        serverConf.setOwner(ownerClient);\n+        serverConf.setServerCode(securityServerCode);\n+        return serverConf;\n+    }\n+\n+    /**\n+     * Helper to check for warnings\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @throws UnhandledWarningsException\n+     */\n+    private void checkForWarnings(ClientId ownerClientId, String securityServerCode)\n+            throws UnhandledWarningsException {\n+        String ownerMemberName = globalConfFacade.getMemberName(ownerClientId);\n+        SecurityServerId serverId = SecurityServerId.create(ownerClientId, securityServerCode);\n+        List<WarningDeviation> warnings = new ArrayList<>();\n+        if (StringUtils.isEmpty(ownerMemberName)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_UNREGISTERED_MEMBER,\n+                    ownerClientId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (globalConfFacade.existsSecurityServer(serverId)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_SERVER_ID_EXISTS,\n+                    serverId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (!warnings.isEmpty()) {\n+            throw new UnhandledWarningsException(warnings);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create an initial client\n+     * @param clientId\n+     * @return\n+     */\n+    private ClientType getInitialClient(ClientId clientId) {\n+        ClientType localClient = clientService.getLocalClient(clientId);\n+        if (localClient == null) {\n+            localClient = new ClientType();\n+            localClient.setIdentifier(clientId);\n+            localClient.setClientStatus(ClientType.STATUS_SAVED);\n+            localClient.setIsAuthentication(IsAuthentication.SSLAUTH.name());\n+        }\n+        return localClient;\n+    }\n+\n+    /**\n+     * Verify that the initialization process can proceed and that the security server has not already been\n+     * initialized. This means verifying that an anchor has been imported,\n+     * server conf does not exist and a software token has not yet been initialized. This method could also be\n+     * changed into throwing an UnhandledWarningsException with warning metadata instead of the current\n+     * InitializationException if partial init needs to be supported in the future\n+     * @throws InitializationException if server conf exists OR software token is already initialized\n+     */\n+    private void verifyInitializationPrerequisites() throws InitializationException {\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        List<String> metadata = new ArrayList<>();\n+        if (isServerConfInitialized) {\n+            metadata.add(METADATA_SERVERCONF_EXISTS);\n+        }\n+        if (isSoftwareTokenInitialized) {\n+            metadata.add(METADATA_SOFTWARE_TOKEN_INITIALIZED);\n+        }\n+        if (!metadata.isEmpty()) {\n+            throw new InitializationException(\"Error initializing security server\", metadata);\n+        }\n+    }\n+\n+    /**\n+     * If something goes south with the initialization", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMTQ2NA==", "bodyText": "Did not even think about this. Fixed.\nChecking from Wiktionary, the idiom seems to have quite a few different meanings - some of which have darker or otherwise inappropriate tone to them.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424411464", "createdAt": "2020-05-13T12:51:45Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is\n+     * enforced by properties)\n+     * @throws InvalidPinException if the provided pin code does not follow the TokenPinPolicy (if token pin policy is\n+     * enforced by properties)\n+     * @throws SoftwareTokenInitException if something goes wrong with the token init\n+     */\n+    public void initialize(String securityServerCode, String ownerMemberClass, String ownerMemberCode,\n+            String softwareTokenPin, boolean ignoreWarnings) throws AnchorNotFoundException, InitializationException,\n+            UnhandledWarningsException, WeakPinException, InvalidPinException, SoftwareTokenInitException {\n+        if (!systemService.isAnchorImported()) {\n+            throw new AnchorNotFoundException(\"Configuration anchor was not found.\");\n+        }\n+        verifyInitializationPrerequisites();\n+        String instanceIdentifier = globalConfFacade.getInstanceIdentifier();\n+        // get id from db if exists - this is for partial init support since no client ids should yet exist\n+        ClientId ownerClientId = clientService.getPossiblyManagedEntity(ClientId.create(instanceIdentifier,\n+                ownerMemberClass, ownerMemberCode));\n+        if (!ignoreWarnings) {\n+            checkForWarnings(ownerClientId, securityServerCode);\n+        }\n+        // --- Start the init ---\n+        ServerConfType serverConf = createInitialServerConf(ownerClientId, securityServerCode);\n+        initializeSoftwareToken(softwareTokenPin);\n+        serverConfService.saveOrUpdate(serverConf);\n+    }\n+\n+    /**\n+     * Helper to create a software token\n+     * @param softwareTokenPin the pin of the token\n+     * @throws InvalidPinException\n+     * @throws WeakPinException\n+     * @throws SoftwareTokenInitException\n+     */\n+    private void initializeSoftwareToken(String softwareTokenPin) throws InvalidPinException, WeakPinException,\n+            SoftwareTokenInitException {\n+        char[] pin = softwareTokenPin.toCharArray();\n+        if (isTokenPinEnforced) {\n+            TokenPinPolicy.Description description = TokenPinPolicy.describe(pin);\n+            if (!description.isValid()) {\n+                if (description.hasInvalidCharacters()) {\n+                    throw new InvalidPinException(\"The provided pin code does not match with the pin code policy\");\n+                }\n+                List<String> metadata = new ArrayList<>();\n+                metadata.add(METADATA_PIN_MIN_LENGTH);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_PASSWORD_LENGTH));\n+                metadata.add(METADATA_PIN_MIN_CHAR_CLASSES);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_CHARACTER_CLASS_COUNT));\n+                throw new WeakPinException(\"The provided pin code was too weak\", metadata);\n+            }\n+        }\n+        try {\n+            signerProxyFacade.initSoftwareToken(pin);\n+        } catch (Exception e) {\n+            // not good\n+            throw new SoftwareTokenInitException(\"Error initializing software token\", e);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create the initial server conf\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @return ServerConfType\n+     */\n+    private ServerConfType createInitialServerConf(ClientId ownerClientId, String securityServerCode) {\n+        /* get serverconf from db if exists\n+           - this is for partial init support since no server confs should yet exist\n+         */\n+        ServerConfType serverConf = serverConfService.getOrCreateServerConf();\n+        ClientType ownerClient = null;\n+        // get client from db if exists - this is for partial init support since no clients should yet exist\n+        Optional<ClientType> foundClient = serverConf.getClient().stream()\n+                .filter(clientType -> clientType.getIdentifier().equals(ownerClientId))\n+                .findFirst();\n+        ownerClient = foundClient.orElse(getInitialClient(ownerClientId));\n+        ownerClient.setConf(serverConf);\n+        // again for partial init support: if the client already exists there is no reason to add it again\n+        if (!serverConf.getClient().contains(ownerClient)) {\n+            serverConf.getClient().add(ownerClient);\n+        }\n+        serverConf.setOwner(ownerClient);\n+        serverConf.setServerCode(securityServerCode);\n+        return serverConf;\n+    }\n+\n+    /**\n+     * Helper to check for warnings\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @throws UnhandledWarningsException\n+     */\n+    private void checkForWarnings(ClientId ownerClientId, String securityServerCode)\n+            throws UnhandledWarningsException {\n+        String ownerMemberName = globalConfFacade.getMemberName(ownerClientId);\n+        SecurityServerId serverId = SecurityServerId.create(ownerClientId, securityServerCode);\n+        List<WarningDeviation> warnings = new ArrayList<>();\n+        if (StringUtils.isEmpty(ownerMemberName)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_UNREGISTERED_MEMBER,\n+                    ownerClientId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (globalConfFacade.existsSecurityServer(serverId)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_SERVER_ID_EXISTS,\n+                    serverId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (!warnings.isEmpty()) {\n+            throw new UnhandledWarningsException(warnings);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create an initial client\n+     * @param clientId\n+     * @return\n+     */\n+    private ClientType getInitialClient(ClientId clientId) {\n+        ClientType localClient = clientService.getLocalClient(clientId);\n+        if (localClient == null) {\n+            localClient = new ClientType();\n+            localClient.setIdentifier(clientId);\n+            localClient.setClientStatus(ClientType.STATUS_SAVED);\n+            localClient.setIsAuthentication(IsAuthentication.SSLAUTH.name());\n+        }\n+        return localClient;\n+    }\n+\n+    /**\n+     * Verify that the initialization process can proceed and that the security server has not already been\n+     * initialized. This means verifying that an anchor has been imported,\n+     * server conf does not exist and a software token has not yet been initialized. This method could also be\n+     * changed into throwing an UnhandledWarningsException with warning metadata instead of the current\n+     * InitializationException if partial init needs to be supported in the future\n+     * @throws InitializationException if server conf exists OR software token is already initialized\n+     */\n+    private void verifyInitializationPrerequisites() throws InitializationException {\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        List<String> metadata = new ArrayList<>();\n+        if (isServerConfInitialized) {\n+            metadata.add(METADATA_SERVERCONF_EXISTS);\n+        }\n+        if (isSoftwareTokenInitialized) {\n+            metadata.add(METADATA_SOFTWARE_TOKEN_INITIALIZED);\n+        }\n+        if (!metadata.isEmpty()) {\n+            throw new InitializationException(\"Error initializing security server\", metadata);\n+        }\n+    }\n+\n+    /**\n+     * If something goes south with the initialization", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMzc2Mg=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5MDg3OQ==", "bodyText": ":)", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424890879", "createdAt": "2020-05-14T06:08:52Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/InitializationService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.SystemProperties;\n+import ee.ria.xroad.common.conf.serverconf.IsAuthentication;\n+import ee.ria.xroad.common.conf.serverconf.model.ClientType;\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.exceptions.ErrorDeviation;\n+import org.niis.xroad.restapi.exceptions.WarningDeviation;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * service for initializing the security server\n+ */\n+@Slf4j\n+@Service\n+@Transactional\n+@PreAuthorize(\"isAuthenticated()\")\n+public class InitializationService {\n+    public static final String WARNING_INIT_UNREGISTERED_MEMBER = \"init_unregistered_member\";\n+    public static final String WARNING_INIT_SERVER_ID_EXISTS = \"init_server_id_exists\";\n+    public static final String METADATA_SERVERCONF_EXISTS = \"init_serverconf_exists\";\n+    public static final String METADATA_SOFTWARE_TOKEN_INITIALIZED = \"init_software_token_initialized\";\n+    public static final String METADATA_PIN_MIN_LENGTH = \"pin_min_length\";\n+    public static final String METADATA_PIN_MIN_CHAR_CLASSES = \"pin_min_char_classes_count\";\n+\n+    private final SystemService systemService;\n+    private final ServerConfService serverConfService;\n+    private final TokenService tokenService;\n+    private final GlobalConfFacade globalConfFacade;\n+    private final ClientService clientService;\n+    private final SignerProxyFacade signerProxyFacade;\n+\n+    @Setter\n+    private boolean isTokenPinEnforced = SystemProperties.shouldEnforceTokenPinPolicy();\n+\n+    @Autowired\n+    public InitializationService(SystemService systemService, ServerConfService serverConfService,\n+            TokenService tokenService, GlobalConfFacade globalConfFacade, ClientService clientService,\n+            SignerProxyFacade signerProxyFacade) {\n+        this.systemService = systemService;\n+        this.serverConfService = serverConfService;\n+        this.tokenService = tokenService;\n+        this.globalConfFacade = globalConfFacade;\n+        this.clientService = clientService;\n+        this.signerProxyFacade = signerProxyFacade;\n+    }\n+\n+    /**\n+     * Check the whole init status of the Security Server. The init status consists of the following:\n+     * 1. is anchor imported - whether or not a configuration anchor has been imported\n+     * 2. is server conf initialized - whether or not a server conf exists\n+     * 3. is software token initialized - whether or not a software token exists AND\n+     * it's status != TokenStatusInfo.NOT_INITIALIZED\n+     * @return\n+     */\n+    public InitializationStatusDto isSecurityServerInitialized() {\n+        boolean isAnchorImported = systemService.isAnchorImported();\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        InitializationStatusDto initializationStatusDto = new InitializationStatusDto();\n+        initializationStatusDto.setAnchorImported(isAnchorImported);\n+        initializationStatusDto.setServerConfInitialized(isServerConfInitialized && isSoftwareTokenInitialized);\n+        return initializationStatusDto;\n+    }\n+\n+    /**\n+     * Initialize a new Security Server with the provided parameters. The method will throw an exception if the\n+     * server has already been initialized. The method does support partial initialization (e.g. server conf has\n+     * been created but software token has not) BUT taking that into use will require changing\n+     * {@link #verifyInitializationPrerequisites()} to throw UnhandledWarningsException with warning metadata\n+     * instead of InitializationException.\n+     * @param securityServerCode server code for the new Security Server\n+     * @param ownerMemberClass member class of the new owner member\n+     * @param ownerMemberCode member code of the new owner member\n+     * @param softwareTokenPin pin code for the initial software token (softToken-0)\n+     * @param ignoreWarnings\n+     * @throws AnchorNotFoundException if an anchor has not been imported\n+     * @throws InitializationException if prerequisite check fails: if a server conf already exists OR if a\n+     * software token has already been initialized\n+     * @throws UnhandledWarningsException\n+     * @throws WeakPinException if the pin does not meet the length and complexity requirements (if token pin policy is\n+     * enforced by properties)\n+     * @throws InvalidPinException if the provided pin code does not follow the TokenPinPolicy (if token pin policy is\n+     * enforced by properties)\n+     * @throws SoftwareTokenInitException if something goes wrong with the token init\n+     */\n+    public void initialize(String securityServerCode, String ownerMemberClass, String ownerMemberCode,\n+            String softwareTokenPin, boolean ignoreWarnings) throws AnchorNotFoundException, InitializationException,\n+            UnhandledWarningsException, WeakPinException, InvalidPinException, SoftwareTokenInitException {\n+        if (!systemService.isAnchorImported()) {\n+            throw new AnchorNotFoundException(\"Configuration anchor was not found.\");\n+        }\n+        verifyInitializationPrerequisites();\n+        String instanceIdentifier = globalConfFacade.getInstanceIdentifier();\n+        // get id from db if exists - this is for partial init support since no client ids should yet exist\n+        ClientId ownerClientId = clientService.getPossiblyManagedEntity(ClientId.create(instanceIdentifier,\n+                ownerMemberClass, ownerMemberCode));\n+        if (!ignoreWarnings) {\n+            checkForWarnings(ownerClientId, securityServerCode);\n+        }\n+        // --- Start the init ---\n+        ServerConfType serverConf = createInitialServerConf(ownerClientId, securityServerCode);\n+        initializeSoftwareToken(softwareTokenPin);\n+        serverConfService.saveOrUpdate(serverConf);\n+    }\n+\n+    /**\n+     * Helper to create a software token\n+     * @param softwareTokenPin the pin of the token\n+     * @throws InvalidPinException\n+     * @throws WeakPinException\n+     * @throws SoftwareTokenInitException\n+     */\n+    private void initializeSoftwareToken(String softwareTokenPin) throws InvalidPinException, WeakPinException,\n+            SoftwareTokenInitException {\n+        char[] pin = softwareTokenPin.toCharArray();\n+        if (isTokenPinEnforced) {\n+            TokenPinPolicy.Description description = TokenPinPolicy.describe(pin);\n+            if (!description.isValid()) {\n+                if (description.hasInvalidCharacters()) {\n+                    throw new InvalidPinException(\"The provided pin code does not match with the pin code policy\");\n+                }\n+                List<String> metadata = new ArrayList<>();\n+                metadata.add(METADATA_PIN_MIN_LENGTH);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_PASSWORD_LENGTH));\n+                metadata.add(METADATA_PIN_MIN_CHAR_CLASSES);\n+                metadata.add(String.valueOf(TokenPinPolicy.MIN_CHARACTER_CLASS_COUNT));\n+                throw new WeakPinException(\"The provided pin code was too weak\", metadata);\n+            }\n+        }\n+        try {\n+            signerProxyFacade.initSoftwareToken(pin);\n+        } catch (Exception e) {\n+            // not good\n+            throw new SoftwareTokenInitException(\"Error initializing software token\", e);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create the initial server conf\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @return ServerConfType\n+     */\n+    private ServerConfType createInitialServerConf(ClientId ownerClientId, String securityServerCode) {\n+        /* get serverconf from db if exists\n+           - this is for partial init support since no server confs should yet exist\n+         */\n+        ServerConfType serverConf = serverConfService.getOrCreateServerConf();\n+        ClientType ownerClient = null;\n+        // get client from db if exists - this is for partial init support since no clients should yet exist\n+        Optional<ClientType> foundClient = serverConf.getClient().stream()\n+                .filter(clientType -> clientType.getIdentifier().equals(ownerClientId))\n+                .findFirst();\n+        ownerClient = foundClient.orElse(getInitialClient(ownerClientId));\n+        ownerClient.setConf(serverConf);\n+        // again for partial init support: if the client already exists there is no reason to add it again\n+        if (!serverConf.getClient().contains(ownerClient)) {\n+            serverConf.getClient().add(ownerClient);\n+        }\n+        serverConf.setOwner(ownerClient);\n+        serverConf.setServerCode(securityServerCode);\n+        return serverConf;\n+    }\n+\n+    /**\n+     * Helper to check for warnings\n+     * @param ownerClientId\n+     * @param securityServerCode\n+     * @throws UnhandledWarningsException\n+     */\n+    private void checkForWarnings(ClientId ownerClientId, String securityServerCode)\n+            throws UnhandledWarningsException {\n+        String ownerMemberName = globalConfFacade.getMemberName(ownerClientId);\n+        SecurityServerId serverId = SecurityServerId.create(ownerClientId, securityServerCode);\n+        List<WarningDeviation> warnings = new ArrayList<>();\n+        if (StringUtils.isEmpty(ownerMemberName)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_UNREGISTERED_MEMBER,\n+                    ownerClientId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (globalConfFacade.existsSecurityServer(serverId)) {\n+            WarningDeviation memberWarning = new WarningDeviation(WARNING_INIT_SERVER_ID_EXISTS,\n+                    serverId.toShortString());\n+            warnings.add(memberWarning);\n+        }\n+        if (!warnings.isEmpty()) {\n+            throw new UnhandledWarningsException(warnings);\n+        }\n+    }\n+\n+    /**\n+     * Helper to create an initial client\n+     * @param clientId\n+     * @return\n+     */\n+    private ClientType getInitialClient(ClientId clientId) {\n+        ClientType localClient = clientService.getLocalClient(clientId);\n+        if (localClient == null) {\n+            localClient = new ClientType();\n+            localClient.setIdentifier(clientId);\n+            localClient.setClientStatus(ClientType.STATUS_SAVED);\n+            localClient.setIsAuthentication(IsAuthentication.SSLAUTH.name());\n+        }\n+        return localClient;\n+    }\n+\n+    /**\n+     * Verify that the initialization process can proceed and that the security server has not already been\n+     * initialized. This means verifying that an anchor has been imported,\n+     * server conf does not exist and a software token has not yet been initialized. This method could also be\n+     * changed into throwing an UnhandledWarningsException with warning metadata instead of the current\n+     * InitializationException if partial init needs to be supported in the future\n+     * @throws InitializationException if server conf exists OR software token is already initialized\n+     */\n+    private void verifyInitializationPrerequisites() throws InitializationException {\n+        boolean isServerConfInitialized = serverConfService.isServerConfInitialized();\n+        boolean isSoftwareTokenInitialized = tokenService.isSoftwareTokenInitialized();\n+        List<String> metadata = new ArrayList<>();\n+        if (isServerConfInitialized) {\n+            metadata.add(METADATA_SERVERCONF_EXISTS);\n+        }\n+        if (isSoftwareTokenInitialized) {\n+            metadata.add(METADATA_SOFTWARE_TOKEN_INITIALIZED);\n+        }\n+        if (!metadata.isEmpty()) {\n+            throw new InitializationException(\"Error initializing security server\", metadata);\n+        }\n+    }\n+\n+    /**\n+     * If something goes south with the initialization", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMzc2Mg=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDI5MDU5OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/SystemService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo1MTozM1rOGTa2KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMjo1NDozM1rOGUwIlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxNTk3Nw==", "bodyText": "Hmm, is this a misleading log entry, will it look like an error for system admins, with the stacktrace? Could it maybe be reworded?", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423015977", "createdAt": "2020-05-11T12:51:33Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/SystemService.java", "diffHunk": "@@ -268,6 +304,44 @@ public void uploadAnchor(byte[] anchorBytes) throws InvalidAnchorInstanceExcepti\n         }\n     }\n \n+    /**\n+     * Is global conf initialized -> it is if whe can find a Configuration anchor\n+     * @return\n+     */\n+    public boolean isAnchorImported() {\n+        boolean isGlobalConfInitialized = false;\n+        try {\n+            AnchorFile anchorFile = getAnchorFile();\n+            if (anchorFile != null) {\n+                isGlobalConfInitialized = true;\n+            }\n+        } catch (AnchorNotFoundException e) {\n+            log.info(\"SystemService#isAnchorImported: could not find Global Configuration Anchor\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMzMzMw==", "bodyText": "Removed the logging since there is really nothing to log here. Just swallow the exception and continue", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424413333", "createdAt": "2020-05-13T12:54:33Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/SystemService.java", "diffHunk": "@@ -268,6 +304,44 @@ public void uploadAnchor(byte[] anchorBytes) throws InvalidAnchorInstanceExcepti\n         }\n     }\n \n+    /**\n+     * Is global conf initialized -> it is if whe can find a Configuration anchor\n+     * @return\n+     */\n+    public boolean isAnchorImported() {\n+        boolean isGlobalConfInitialized = false;\n+        try {\n+            AnchorFile anchorFile = getAnchorFile();\n+            if (anchorFile != null) {\n+                isGlobalConfInitialized = true;\n+            }\n+        } catch (AnchorNotFoundException e) {\n+            log.info(\"SystemService#isAnchorImported: could not find Global Configuration Anchor\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxNTk3Nw=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDMwMzMyOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/resources/openapi-definition.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo1NToxM1rOGTa-AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMjo1NjoyNFrOGUwNSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxNzk4NA==", "bodyText": "Maybe should not be required (also default value is meaningless if it is), other endpoints do not require ignore_warnings parameters.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423017984", "createdAt": "2020-05-11T12:55:13Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/resources/openapi-definition.yaml", "diffHunk": "@@ -4885,6 +5049,49 @@ components:\n           example: '2018-12-15T00:00:00.001Z'\n           minLength: 24\n           maxLength: 24\n+    InitialServerConf: # ok\n+      type: object\n+      description: security server initial configuration\n+      required:\n+        - member_class\n+        - member_code\n+        - security_server_code\n+        - software_token_pin\n+        - ignore_warnings", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxNDUzNw==", "bodyText": "Due to the partial init refactoring there are not required parameters anymore in this action (including the ignore_warnings flag)", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424414537", "createdAt": "2020-05-13T12:56:24Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/main/resources/openapi-definition.yaml", "diffHunk": "@@ -4885,6 +5049,49 @@ components:\n           example: '2018-12-15T00:00:00.001Z'\n           minLength: 24\n           maxLength: 24\n+    InitialServerConf: # ok\n+      type: object\n+      description: security server initial configuration\n+      required:\n+        - member_class\n+        - member_code\n+        - security_server_code\n+        - software_token_pin\n+        - ignore_warnings", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxNzk4NA=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDMwNzMyOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/openapi/IdentifierValidationRestTemplateTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo1NjoyMFrOGTbAbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo1NjoyNlrOGVY0Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxODYwNg==", "bodyText": "Nicely tested validation \ud83d\udc4d", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423018606", "createdAt": "2020-05-11T12:56:20Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/openapi/IdentifierValidationRestTemplateTest.java", "diffHunk": "@@ -184,4 +184,44 @@ private void assertUpdateServiceDescriptionValidationFailure(String restServiceC\n         assertEquals(\"validation_failure\", errors.get(\"code\"));\n     }\n \n+    @Test\n+    public void initialServerConf() {\n+        assertInitialServerConfValidationError(HAS_COLON, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_SEMICOLON, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_PERCENT, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_NON_NORMALIZED, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_BACKSLASH, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_COLON, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_SEMICOLON, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_PERCENT, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_NON_NORMALIZED, \"aa\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxNzc3OQ==", "bodyText": "Also seemed to (randomly, not always) exhaust the default 20 requests per second IP throttling rate. Increased the rate to 60/second for tests.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424417779", "createdAt": "2020-05-13T13:01:23Z", "author": {"login": "carohauta"}, "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/openapi/IdentifierValidationRestTemplateTest.java", "diffHunk": "@@ -184,4 +184,44 @@ private void assertUpdateServiceDescriptionValidationFailure(String restServiceC\n         assertEquals(\"validation_failure\", errors.get(\"code\"));\n     }\n \n+    @Test\n+    public void initialServerConf() {\n+        assertInitialServerConfValidationError(HAS_COLON, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_SEMICOLON, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_PERCENT, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_NON_NORMALIZED, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_BACKSLASH, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_COLON, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_SEMICOLON, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_PERCENT, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_NON_NORMALIZED, \"aa\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxODYwNg=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5MTgwMg==", "bodyText": "Oh, did not realize that could become an issue. Good change then. Hopefully that wont randomly fail even with the increased limit. Might also think about removing throttle for the tests altogether.", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r424891802", "createdAt": "2020-05-14T06:11:29Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/openapi/IdentifierValidationRestTemplateTest.java", "diffHunk": "@@ -184,4 +184,44 @@ private void assertUpdateServiceDescriptionValidationFailure(String restServiceC\n         assertEquals(\"validation_failure\", errors.get(\"code\"));\n     }\n \n+    @Test\n+    public void initialServerConf() {\n+        assertInitialServerConfValidationError(HAS_COLON, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_SEMICOLON, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_PERCENT, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_NON_NORMALIZED, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_BACKSLASH, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_COLON, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_SEMICOLON, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_PERCENT, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_NON_NORMALIZED, \"aa\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxODYwNg=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3OTg3OA==", "bodyText": "throttle filter was disabled altogether from tests by @carohauta", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r425079878", "createdAt": "2020-05-14T11:56:26Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/openapi/IdentifierValidationRestTemplateTest.java", "diffHunk": "@@ -184,4 +184,44 @@ private void assertUpdateServiceDescriptionValidationFailure(String restServiceC\n         assertEquals(\"validation_failure\", errors.get(\"code\"));\n     }\n \n+    @Test\n+    public void initialServerConf() {\n+        assertInitialServerConfValidationError(HAS_COLON, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_SEMICOLON, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_PERCENT, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_NON_NORMALIZED, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(HAS_BACKSLASH, \"aa\", \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_COLON, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_SEMICOLON, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_PERCENT, \"aa\");\n+        assertInitialServerConfValidationError(\"aa\", HAS_NON_NORMALIZED, \"aa\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxODYwNg=="}, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDMxNDkxOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/service/InitializationServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo1ODoyNVrOGTbFMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo1ODoyNVrOGTbFMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxOTgyNg==", "bodyText": "Nice effort put into testing across the board \ud83d\udc4d", "url": "https://github.com/nordic-institute/X-Road/pull/468#discussion_r423019826", "createdAt": "2020-05-11T12:58:25Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/service/InitializationServiceTest.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/**\n+ * The MIT License\n+ * Copyright (c) 2018 Estonian Information System Authority (RIA),\n+ * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n+ * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.niis.xroad.restapi.service;\n+\n+import ee.ria.xroad.common.conf.serverconf.model.ServerConfType;\n+import ee.ria.xroad.common.identifier.ClientId;\n+import ee.ria.xroad.common.identifier.SecurityServerId;\n+import ee.ria.xroad.common.util.TokenPinPolicy;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.niis.xroad.restapi.dto.InitializationStatusDto;\n+import org.niis.xroad.restapi.facade.GlobalConfFacade;\n+import org.niis.xroad.restapi.facade.SignerProxyFacade;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.context.junit4.SpringRunner;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.when;\n+import static org.niis.xroad.restapi.service.InitializationService.METADATA_PIN_MIN_CHAR_CLASSES;\n+import static org.niis.xroad.restapi.service.InitializationService.METADATA_PIN_MIN_LENGTH;\n+import static org.niis.xroad.restapi.service.InitializationService.METADATA_SERVERCONF_EXISTS;\n+import static org.niis.xroad.restapi.service.InitializationService.METADATA_SOFTWARE_TOKEN_INITIALIZED;\n+import static org.niis.xroad.restapi.service.InitializationService.WARNING_INIT_SERVER_ID_EXISTS;\n+import static org.niis.xroad.restapi.service.InitializationService.WARNING_INIT_UNREGISTERED_MEMBER;\n+import static org.niis.xroad.restapi.service.InitializationService.WeakPinException.WEAK_PIN;\n+import static org.niis.xroad.restapi.util.DeviationTestUtils.assertErrorWithMetadata;\n+import static org.niis.xroad.restapi.util.DeviationTestUtils.assertWarning;\n+\n+@RunWith(SpringRunner.class)\n+@SpringBootTest\n+@AutoConfigureTestDatabase\n+@Slf4j\n+@Transactional\n+@WithMockUser\n+public class InitializationServiceTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c2419007b445d7f7582140934c675dca9ab2db"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2832, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}