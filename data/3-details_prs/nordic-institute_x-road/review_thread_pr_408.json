{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2MDcyOTEz", "number": 408, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzozMDoxN1rODmraVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMzozMDo1MlrODqyq_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODgzNzM0OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/frontend/src/locales/en.json", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzozMDoxN1rOF0Ox-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMToxOToxM1rOF8s6lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxMjQ0Mw==", "bodyText": "What concept does the category \"access\" specifically refer to? Could we find a better name for it? I find references elsewhere, such as access.memberName or access.accessRights slightly unclear. As in \"access, whaat, whose access, and to where?\"", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r390312443", "createdAt": "2020-03-10T13:30:17Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/frontend/src/locales/en.json", "diffHunk": "@@ -188,7 +188,15 @@\n   \"access\": {\n     \"accessRights\": \"Access Rights\",\n     \"addSubjects\": \"Add subjects\",\n-    \"addSubjectsTitle\": \"Add Subjects\"\n+    \"addSubjectsTitle\": \"Add Subjects\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU2ODAwMQ==", "bodyText": "I guess a better name would be accessRightsView and then inner accessRights could be just 'title'", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r398568001", "createdAt": "2020-03-26T13:24:17Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/frontend/src/locales/en.json", "diffHunk": "@@ -188,7 +188,15 @@\n   \"access\": {\n     \"accessRights\": \"Access Rights\",\n     \"addSubjects\": \"Add subjects\",\n-    \"addSubjectsTitle\": \"Add Subjects\"\n+    \"addSubjectsTitle\": \"Add Subjects\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxMjQ0Mw=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE5NDc3NQ==", "bodyText": "Changed access key word to accessRights instead of accessRightsView as these localizations are used also in serviceparameters vie.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r399194775", "createdAt": "2020-03-27T11:19:13Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/frontend/src/locales/en.json", "diffHunk": "@@ -188,7 +188,15 @@\n   \"access\": {\n     \"accessRights\": \"Access Rights\",\n     \"addSubjects\": \"Add subjects\",\n-    \"addSubjectsTitle\": \"Add Subjects\"\n+    \"addSubjectsTitle\": \"Add Subjects\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxMjQ0Mw=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDU5NzgzOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/openapi/EndpointsApiController.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNjo0NjozMFrOF6ixNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDo1NjoyN1rOF_l59g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkzMTM4Mg==", "bodyText": "Hmm, is this some mistake, or are there some changes to the license header? This is different from other files.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r396931382", "createdAt": "2020-03-24T06:46:30Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/openapi/EndpointsApiController.java", "diffHunk": "@@ -3,17 +3,17 @@\n  * Copyright (c) 2018 Estonian Information System Authority (RIA),\n  * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n  * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n- *\n+ * <p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3NDUzMQ==", "bodyText": "Same <p> thing is also in some other files, not commenting those", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397074531", "createdAt": "2020-03-24T11:15:06Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/openapi/EndpointsApiController.java", "diffHunk": "@@ -3,17 +3,17 @@\n  * Copyright (c) 2018 Estonian Information System Authority (RIA),\n  * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n  * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n- *\n+ * <p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkzMTM4Mg=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMTUzOA==", "bodyText": "Don't know where did those come from. Removed from 3 files.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r398631538", "createdAt": "2020-03-26T14:48:15Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/openapi/EndpointsApiController.java", "diffHunk": "@@ -3,17 +3,17 @@\n  * Copyright (c) 2018 Estonian Information System Authority (RIA),\n  * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n  * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n- *\n+ * <p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkzMTM4Mg=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyNTY1NA==", "bodyText": "Actually this <p> is in 20+ files. There's both classes with <p>s and classes without. Maybe a separate ticket to put those in order.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r402225654", "createdAt": "2020-04-02T10:56:27Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/openapi/EndpointsApiController.java", "diffHunk": "@@ -3,17 +3,17 @@\n  * Copyright (c) 2018 Estonian Information System Authority (RIA),\n  * Nordic Institute for Interoperability Solutions (NIIS), Population Register Centre (VRK)\n  * Copyright (c) 2015-2017 Estonian Information System Authority (RIA), Population Register Centre (VRK)\n- *\n+ * <p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkzMTM4Mg=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTQzNDUzOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/openapi/EndpointsApiController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMTowMDoyM1rOF6rA1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwODo1Mzo0NlrOF8oEzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA2NjQ1Mg==", "bodyText": "I found this comment a bit confusing.\nThe client-provided Subjects only contain id and subjectType when adding or deleting access rights. - maybe remove when adding or deleting access rights, it made me think that client-provided Subjects sometimes do contain other properties. They don't AFAIK?\nOr maybe just say \"service layer does not identify local groups by XroadIds\" or something.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397066452", "createdAt": "2020-03-24T11:00:23Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/openapi/EndpointsApiController.java", "diffHunk": "@@ -97,12 +126,99 @@ public EndpointsApiController(\n         try {\n             ep = endpointConverter.convert(endpointService.updateEndpoint(endpointId, endpoint));\n         } catch (EndpointService.EndpointNotFoundException e) {\n-            throw new ResourceNotFoundException(NOT_FOUND_ERROR_MSG + \" \" + id);\n+            throw new ResourceNotFoundException(e);\n         } catch (EndpointService.IllegalGeneratedEndpointUpdateException e) {\n             throw new BadRequestException(\"Updating is not allowed for generated endpoint \" + id);\n         }\n \n         return new ResponseEntity<>(ep, HttpStatus.OK);\n     }\n \n+    @Override\n+    @PreAuthorize(\"hasAuthority('VIEW_ENDPOINT_ACL')\")\n+    public ResponseEntity<List<ServiceClient>> getEndpointAccessRights(String id) {\n+        Long endpointId = parseLongIdOrThrowNotFound(id);\n+        List<AccessRightHolderDto> accessRightHoldersByEndpoint;\n+        try {\n+            accessRightHoldersByEndpoint = accessRightService.getAccessRightHoldersByEndpoint(endpointId);\n+        } catch (EndpointService.EndpointNotFoundException e) {\n+            throw new ResourceNotFoundException(NOT_FOUND_ERROR_MSG + \" \" + id);\n+        } catch (ClientNotFoundException e) {\n+            throw new ConflictException(e);\n+        }\n+        List<ServiceClient> serviceClients = serviceClientConverter\n+                .convertAccessRightHolderDtos(accessRightHoldersByEndpoint);\n+        return new ResponseEntity<>(serviceClients, HttpStatus.OK);\n+    }\n+\n+    @Override\n+    @PreAuthorize(\"hasAuthority('EDIT_ENDPOINT_ACL')\")\n+    public ResponseEntity<List<ServiceClient>> addEndpointAccessRights(String id, Subjects subjects) {\n+        Long endpointId = parseLongIdOrThrowNotFound(id);\n+        Set<Long> localGroupIds = getLocalGroupIds(subjects);\n+        List<XRoadId> xRoadIds = getXRoadIdsButSkipLocalGroups(subjects);\n+        List<AccessRightHolderDto> accessRightHoldersByEndpoint = null;\n+\n+        try {\n+            accessRightHoldersByEndpoint = accessRightService.addEndpointAccessRights(endpointId,\n+                    new HashSet<>(xRoadIds), localGroupIds);\n+        } catch (EndpointService.EndpointNotFoundException e) {\n+            throw new ResourceNotFoundException(e);\n+        } catch (ClientNotFoundException | AccessRightService.DuplicateAccessRightException  e) {\n+            throw new ConflictException(e);\n+        } catch (IdentifierNotFoundException | LocalGroupNotFoundException e) {\n+            throw new BadRequestException(e);\n+        }\n+\n+        List<ServiceClient> serviceClients = serviceClientConverter\n+                .convertAccessRightHolderDtos(accessRightHoldersByEndpoint);\n+        return new ResponseEntity<>(serviceClients, HttpStatus.CREATED);\n+    }\n+\n+    @Override\n+    @PreAuthorize(\"hasAuthority('EDIT_ENDPOINT_ACL')\")\n+    public ResponseEntity<Void> deleteEndpointAccessRights(String id, Subjects subjects) {\n+        Long endpointId = parseLongIdOrThrowNotFound(id);\n+        Set<Long> localGroupIds = getLocalGroupIds(subjects);\n+        HashSet<XRoadId> xRoadIds = new HashSet<>(getXRoadIdsButSkipLocalGroups(subjects));\n+        try {\n+            accessRightService.deleteEndpointAccessRights(endpointId, xRoadIds, localGroupIds);\n+        } catch (LocalGroupNotFoundException e) {\n+            throw new BadRequestException(e);\n+        } catch (EndpointService.EndpointNotFoundException | AccessRightService.AccessRightNotFoundException e) {\n+            throw new ResourceNotFoundException(e);\n+        } catch (ClientNotFoundException e) {\n+            throw new ConflictException(e);\n+        }\n+\n+        return new ResponseEntity<>(HttpStatus.NO_CONTENT);\n+    }\n+\n+    private List<XRoadId> getXRoadIdsButSkipLocalGroups(Subjects subjects) {\n+        // SubjectConverter cannot resolve the correct XRoadId from LocalGroup subject's numeric id\n+        subjects.getItems().removeIf(hasNumericIdAndIsLocalGroup);\n+        return subjectConverter.convertId(subjects.getItems());\n+    }\n+\n+    private Set<Long> getLocalGroupIds(Subjects subjects) {\n+        return subjects.getItems()\n+                .stream()\n+                .filter(hasNumericIdAndIsLocalGroup)\n+                .map(subject -> Long.parseLong(subject.getId()))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * The client-provided Subjects only contain id and subjectType when adding or deleting access rights.\n+     * The id of a LocalGroup is numeric so SubjectConverter cannot resolve the correct XRoadId from it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTExNTQ2OA==", "bodyText": "I just removed the 'when adding or deleting access rights' part.\nThis code and comments were actually copy-pasted from existing implementation. They were 1-to-1 duplicate. I did some refactoring and moved these three private methods to a new SubjectHelper -method so duplication is also removed.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r399115468", "createdAt": "2020-03-27T08:53:46Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/openapi/EndpointsApiController.java", "diffHunk": "@@ -97,12 +126,99 @@ public EndpointsApiController(\n         try {\n             ep = endpointConverter.convert(endpointService.updateEndpoint(endpointId, endpoint));\n         } catch (EndpointService.EndpointNotFoundException e) {\n-            throw new ResourceNotFoundException(NOT_FOUND_ERROR_MSG + \" \" + id);\n+            throw new ResourceNotFoundException(e);\n         } catch (EndpointService.IllegalGeneratedEndpointUpdateException e) {\n             throw new BadRequestException(\"Updating is not allowed for generated endpoint \" + id);\n         }\n \n         return new ResponseEntity<>(ep, HttpStatus.OK);\n     }\n \n+    @Override\n+    @PreAuthorize(\"hasAuthority('VIEW_ENDPOINT_ACL')\")\n+    public ResponseEntity<List<ServiceClient>> getEndpointAccessRights(String id) {\n+        Long endpointId = parseLongIdOrThrowNotFound(id);\n+        List<AccessRightHolderDto> accessRightHoldersByEndpoint;\n+        try {\n+            accessRightHoldersByEndpoint = accessRightService.getAccessRightHoldersByEndpoint(endpointId);\n+        } catch (EndpointService.EndpointNotFoundException e) {\n+            throw new ResourceNotFoundException(NOT_FOUND_ERROR_MSG + \" \" + id);\n+        } catch (ClientNotFoundException e) {\n+            throw new ConflictException(e);\n+        }\n+        List<ServiceClient> serviceClients = serviceClientConverter\n+                .convertAccessRightHolderDtos(accessRightHoldersByEndpoint);\n+        return new ResponseEntity<>(serviceClients, HttpStatus.OK);\n+    }\n+\n+    @Override\n+    @PreAuthorize(\"hasAuthority('EDIT_ENDPOINT_ACL')\")\n+    public ResponseEntity<List<ServiceClient>> addEndpointAccessRights(String id, Subjects subjects) {\n+        Long endpointId = parseLongIdOrThrowNotFound(id);\n+        Set<Long> localGroupIds = getLocalGroupIds(subjects);\n+        List<XRoadId> xRoadIds = getXRoadIdsButSkipLocalGroups(subjects);\n+        List<AccessRightHolderDto> accessRightHoldersByEndpoint = null;\n+\n+        try {\n+            accessRightHoldersByEndpoint = accessRightService.addEndpointAccessRights(endpointId,\n+                    new HashSet<>(xRoadIds), localGroupIds);\n+        } catch (EndpointService.EndpointNotFoundException e) {\n+            throw new ResourceNotFoundException(e);\n+        } catch (ClientNotFoundException | AccessRightService.DuplicateAccessRightException  e) {\n+            throw new ConflictException(e);\n+        } catch (IdentifierNotFoundException | LocalGroupNotFoundException e) {\n+            throw new BadRequestException(e);\n+        }\n+\n+        List<ServiceClient> serviceClients = serviceClientConverter\n+                .convertAccessRightHolderDtos(accessRightHoldersByEndpoint);\n+        return new ResponseEntity<>(serviceClients, HttpStatus.CREATED);\n+    }\n+\n+    @Override\n+    @PreAuthorize(\"hasAuthority('EDIT_ENDPOINT_ACL')\")\n+    public ResponseEntity<Void> deleteEndpointAccessRights(String id, Subjects subjects) {\n+        Long endpointId = parseLongIdOrThrowNotFound(id);\n+        Set<Long> localGroupIds = getLocalGroupIds(subjects);\n+        HashSet<XRoadId> xRoadIds = new HashSet<>(getXRoadIdsButSkipLocalGroups(subjects));\n+        try {\n+            accessRightService.deleteEndpointAccessRights(endpointId, xRoadIds, localGroupIds);\n+        } catch (LocalGroupNotFoundException e) {\n+            throw new BadRequestException(e);\n+        } catch (EndpointService.EndpointNotFoundException | AccessRightService.AccessRightNotFoundException e) {\n+            throw new ResourceNotFoundException(e);\n+        } catch (ClientNotFoundException e) {\n+            throw new ConflictException(e);\n+        }\n+\n+        return new ResponseEntity<>(HttpStatus.NO_CONTENT);\n+    }\n+\n+    private List<XRoadId> getXRoadIdsButSkipLocalGroups(Subjects subjects) {\n+        // SubjectConverter cannot resolve the correct XRoadId from LocalGroup subject's numeric id\n+        subjects.getItems().removeIf(hasNumericIdAndIsLocalGroup);\n+        return subjectConverter.convertId(subjects.getItems());\n+    }\n+\n+    private Set<Long> getLocalGroupIds(Subjects subjects) {\n+        return subjects.getItems()\n+                .stream()\n+                .filter(hasNumericIdAndIsLocalGroup)\n+                .map(subject -> Long.parseLong(subject.getId()))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * The client-provided Subjects only contain id and subjectType when adding or deleting access rights.\n+     * The id of a LocalGroup is numeric so SubjectConverter cannot resolve the correct XRoadId from it.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA2NjQ1Mg=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTQ1MzIxOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMTowNjowMFrOF6rMvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDoyMzo1N1rOF_ttrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA2OTUwMw==", "bodyText": "Idea marks this as duplicate code, looks like it repeats in 5 places. Maybe refactor into a helper method.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397069503", "createdAt": "2020-03-24T11:06:00Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE5NTM1MA==", "bodyText": "This part went inside getBaseEndpoint method", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r399195350", "createdAt": "2020-03-27T11:20:28Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA2OTUwMw=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI0Mzc5MA==", "bodyText": "getAccessRightHoldersByEndpoint and deleteEndpointAccessRights still complain about duplicate code. Not a must-fix, but check that your IDE shows the same warning?", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r402243790", "createdAt": "2020-04-02T11:32:36Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA2OTUwMw=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM1MzU4MA==", "bodyText": "Renamed getBaseEndpoint to getServiceBaseEndpoint and removed client parameter as ServiceType is the only object needed to handle the functionality\nRemoved duplication", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r402353580", "createdAt": "2020-04-02T14:23:57Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA2OTUwMw=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTQ3NDU3OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMToxMjowOVrOF6raFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMToxODowM1rOF8s4Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3MjkxNw==", "bodyText": "Do we need to separate between this and EndpointService.EndpointNotFoundException? Maybe one exception type would be enough (it is also possible to have a default error code and a way to override the default, e.g. default code being endpoint_not_found and then overriding it with value endpoint_not_found_by_service_name)\nEndpointService.EndpointNotFoundException should probably be top-level but making the proper comment about it elsewhere.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397072917", "createdAt": "2020-03-24T11:12:09Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -377,11 +506,11 @@ public void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceC\n     /**\n      * If endpoint was not found\n      */\n-    public static class EndpointNotFoundException extends NotFoundException {\n+    public static class EndpointNotFoundByServiceNameException extends NotFoundException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 529}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE5NDE0Nw==", "bodyText": "Removed EndpoinNotFoundByServiceNameException by modifying EndpointNotFoundException.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r399194147", "createdAt": "2020-03-27T11:18:03Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -377,11 +506,11 @@ public void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceC\n     /**\n      * If endpoint was not found\n      */\n-    public static class EndpointNotFoundException extends NotFoundException {\n+    public static class EndpointNotFoundByServiceNameException extends NotFoundException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3MjkxNw=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 529}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTQ4MDM1OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/EndpointService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMToxMzo0NFrOF6rdmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMDo0MDoxMlrOF8ZjRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3MzgxOA==", "bodyText": "This should probably be an independent class (not an inner class) since it is also thrown from AccessRightService", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397073818", "createdAt": "2020-03-24T11:13:44Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/EndpointService.java", "diffHunk": "@@ -160,4 +151,12 @@ public IllegalGeneratedEndpointRemoveException(String id) {\n         }\n     }\n \n+    public static class EndpointNotFoundException extends NotFoundException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg3NzUxMQ==", "bodyText": "Extracted to an independent class", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r398877511", "createdAt": "2020-03-26T20:40:12Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/EndpointService.java", "diffHunk": "@@ -160,4 +151,12 @@ public IllegalGeneratedEndpointRemoveException(String id) {\n         }\n     }\n \n+    public static class EndpointNotFoundException extends NotFoundException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3MzgxOA=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTQ5OTk5OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMToxOTo0NFrOF6rqIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMToxOTo1OFrOF8s7_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3NzAyNw==", "bodyText": "I would love to see a wrapper / helper method getBaseEndpoint (what is the correct term?), it would make the purpose of ANY_METHOD, ANY_PATH combination more obvious. Now those values are a bit magical (huh? why ANY_METHOD & ANY_PATH?)", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397077027", "createdAt": "2020-03-24T11:19:44Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE5NTEzNA==", "bodyText": "getBaseEndpoint-method created", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r399195134", "createdAt": "2020-03-27T11:19:58Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3NzAyNw=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTUwOTY3OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMToyMjoxOFrOF6rwAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNToyNDozN1rOGAFgeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3ODUyOA==", "bodyText": "is this check unnecessary? (and if not it should 1. be in controller, and if that would not work, 2. annotating method would be better unless some conditional programmatic check is needed)", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397078528", "createdAt": "2020-03-24T11:22:18Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n+        return getAccessRightsHoldersByEndpoint(clientType, endpointType);\n+    }\n \n-        List<AccessRightHolderDto> accessRightHolderDtos = new ArrayList<>();\n+    /**\n+     * Get access right holders for Endpoint\n+     *\n+     * @param id\n+     * @return\n+     * @throws EndpointService.EndpointNotFoundException    if no endpoint is found with given id\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     */\n+    public List<AccessRightHolderDto> getAccessRightHoldersByEndpoint(Long id)\n+            throws EndpointService.EndpointNotFoundException, ClientNotFoundException {\n+        verifyAuthority(\"VIEW_ENDPOINT_ACL\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIyOTY3Ng==", "bodyText": "This and other verifyAuthority checks have been removed from AccessRightService", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r399229676", "createdAt": "2020-03-27T12:29:47Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n+        return getAccessRightsHoldersByEndpoint(clientType, endpointType);\n+    }\n \n-        List<AccessRightHolderDto> accessRightHolderDtos = new ArrayList<>();\n+    /**\n+     * Get access right holders for Endpoint\n+     *\n+     * @param id\n+     * @return\n+     * @throws EndpointService.EndpointNotFoundException    if no endpoint is found with given id\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     */\n+    public List<AccessRightHolderDto> getAccessRightHoldersByEndpoint(Long id)\n+            throws EndpointService.EndpointNotFoundException, ClientNotFoundException {\n+        verifyAuthority(\"VIEW_ENDPOINT_ACL\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3ODUyOA=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI0OTM0MQ==", "bodyText": "There is still 3 verifyAuthorities in EndpointService and 1 in ServiceService, that seem unnecessary.\nThere is also a bunch in ServiceDescriptionService, but I think they are not unnecessary, since controller layer does not know which permissions it needs. For example ADD_WSDL vs ADD_OPENAPI3 is not determined until we know which type it is. But a better way to do that would be to add for example\n    @PreAuthorize(\"hasAuthority('ADD_OPENAPI3')\")\nto addOpenApi3ServiceDescription instead of verifyAuthority, no real reason why SecurityHelper.verifyAuthority should be used there. Security annotations should be the primary way and verifyAuthority reserved only for exceptional cases.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r402249341", "createdAt": "2020-04-02T11:43:59Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n+        return getAccessRightsHoldersByEndpoint(clientType, endpointType);\n+    }\n \n-        List<AccessRightHolderDto> accessRightHolderDtos = new ArrayList<>();\n+    /**\n+     * Get access right holders for Endpoint\n+     *\n+     * @param id\n+     * @return\n+     * @throws EndpointService.EndpointNotFoundException    if no endpoint is found with given id\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     */\n+    public List<AccessRightHolderDto> getAccessRightHoldersByEndpoint(Long id)\n+            throws EndpointService.EndpointNotFoundException, ClientNotFoundException {\n+        verifyAuthority(\"VIEW_ENDPOINT_ACL\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3ODUyOA=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI5NjEyMw==", "bodyText": "Removed verifyAuthority-calls from EndpointService & ServiceService", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r402296123", "createdAt": "2020-04-02T13:04:32Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n+        return getAccessRightsHoldersByEndpoint(clientType, endpointType);\n+    }\n \n-        List<AccessRightHolderDto> accessRightHolderDtos = new ArrayList<>();\n+    /**\n+     * Get access right holders for Endpoint\n+     *\n+     * @param id\n+     * @return\n+     * @throws EndpointService.EndpointNotFoundException    if no endpoint is found with given id\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     */\n+    public List<AccessRightHolderDto> getAccessRightHoldersByEndpoint(Long id)\n+            throws EndpointService.EndpointNotFoundException, ClientNotFoundException {\n+        verifyAuthority(\"VIEW_ENDPOINT_ACL\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3ODUyOA=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Mjk2Mw==", "bodyText": "Thanks! How about that ServiceDescriptionService ?", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r402742963", "createdAt": "2020-04-03T05:22:53Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n+        return getAccessRightsHoldersByEndpoint(clientType, endpointType);\n+    }\n \n-        List<AccessRightHolderDto> accessRightHolderDtos = new ArrayList<>();\n+    /**\n+     * Get access right holders for Endpoint\n+     *\n+     * @param id\n+     * @return\n+     * @throws EndpointService.EndpointNotFoundException    if no endpoint is found with given id\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     */\n+    public List<AccessRightHolderDto> getAccessRightHoldersByEndpoint(Long id)\n+            throws EndpointService.EndpointNotFoundException, ClientNotFoundException {\n+        verifyAuthority(\"VIEW_ENDPOINT_ACL\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3ODUyOA=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MzQxNg==", "bodyText": "Probably my comment was unclear, I though it should replace those verifyAuthority(\"EDIT_REST\"); snippets with method level annotations @PreAuthorize(\"hasAuthority('EDIT_REST')\") \nRationale being, PreAuthorize annotations should be the primary way, and verifyAuthority reserved to exceptional cases where annotation does not work, and programmatic check is needed for some reason.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r402743416", "createdAt": "2020-04-03T05:24:37Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n+        return getAccessRightsHoldersByEndpoint(clientType, endpointType);\n+    }\n \n-        List<AccessRightHolderDto> accessRightHolderDtos = new ArrayList<>();\n+    /**\n+     * Get access right holders for Endpoint\n+     *\n+     * @param id\n+     * @return\n+     * @throws EndpointService.EndpointNotFoundException    if no endpoint is found with given id\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     */\n+    public List<AccessRightHolderDto> getAccessRightHoldersByEndpoint(Long id)\n+            throws EndpointService.EndpointNotFoundException, ClientNotFoundException {\n+        verifyAuthority(\"VIEW_ENDPOINT_ACL\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3ODUyOA=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTUyNzgxOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMToyNzoyN1rOF6r7Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMjozMTowOVrOF8vFdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MTQzMQ==", "bodyText": "Wait a minute.....this looks a lot like getAccessRightHolderDtosForEndpoint? Is it the same?", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397081431", "createdAt": "2020-03-24T11:27:27Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n+        return getAccessRightsHoldersByEndpoint(clientType, endpointType);\n+    }\n \n-        List<AccessRightHolderDto> accessRightHolderDtos = new ArrayList<>();\n+    /**\n+     * Get access right holders for Endpoint\n+     *\n+     * @param id\n+     * @return\n+     * @throws EndpointService.EndpointNotFoundException    if no endpoint is found with given id\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     */\n+    public List<AccessRightHolderDto> getAccessRightHoldersByEndpoint(Long id)\n+            throws EndpointService.EndpointNotFoundException, ClientNotFoundException {\n+        verifyAuthority(\"VIEW_ENDPOINT_ACL\");\n \n-        Map<String, LocalGroupType> localGroupMap = new HashMap<>();\n+        ClientType clientType = clientRepository.getClientByEndpointId(id);\n+        if (clientType == null) {\n+            throw new ClientNotFoundException(CLIENT_NOT_FOUND_FOR_ENDPOINT_WITH_ID + id.toString());\n+        }\n+\n+        EndpointType endpointType = endpointRepository.getEndpoint(id);\n+        if (endpointType == null) {\n+            throw new EndpointService.EndpointNotFoundException(id.toString());\n+        }\n \n+        return getAccessRightsHoldersByEndpoint(clientType, endpointType);\n+\n+    }\n+\n+    /**\n+     * Get access rights for endpoint\n+     *\n+     * @param clientType\n+     * @param endpointType\n+     * @return\n+     */\n+    private List<AccessRightHolderDto> getAccessRightsHoldersByEndpoint(ClientType clientType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIzMDMyNA==", "bodyText": "Yes, nicely spotted. This is probably due to refactoring I made and forgot to remove one usage of this method.\nRemoved getAccessRightHolderDtosForEndpoint.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r399230324", "createdAt": "2020-03-27T12:31:09Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -120,25 +104,63 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n      * @return\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws EndpointNotFoundByServiceNameException if base endpoint for this service is not found from the client\n      */\n     public List<AccessRightHolderDto> getAccessRightHoldersByService(ClientId clientId, String fullServiceCode)\n-            throws ClientNotFoundException, ServiceNotFoundException {\n+            throws ClientNotFoundException, ServiceNotFoundException, EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n+        return getAccessRightsHoldersByEndpoint(clientType, endpointType);\n+    }\n \n-        List<AccessRightHolderDto> accessRightHolderDtos = new ArrayList<>();\n+    /**\n+     * Get access right holders for Endpoint\n+     *\n+     * @param id\n+     * @return\n+     * @throws EndpointService.EndpointNotFoundException    if no endpoint is found with given id\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     */\n+    public List<AccessRightHolderDto> getAccessRightHoldersByEndpoint(Long id)\n+            throws EndpointService.EndpointNotFoundException, ClientNotFoundException {\n+        verifyAuthority(\"VIEW_ENDPOINT_ACL\");\n \n-        Map<String, LocalGroupType> localGroupMap = new HashMap<>();\n+        ClientType clientType = clientRepository.getClientByEndpointId(id);\n+        if (clientType == null) {\n+            throw new ClientNotFoundException(CLIENT_NOT_FOUND_FOR_ENDPOINT_WITH_ID + id.toString());\n+        }\n+\n+        EndpointType endpointType = endpointRepository.getEndpoint(id);\n+        if (endpointType == null) {\n+            throw new EndpointService.EndpointNotFoundException(id.toString());\n+        }\n \n+        return getAccessRightsHoldersByEndpoint(clientType, endpointType);\n+\n+    }\n+\n+    /**\n+     * Get access rights for endpoint\n+     *\n+     * @param clientType\n+     * @param endpointType\n+     * @return\n+     */\n+    private List<AccessRightHolderDto> getAccessRightsHoldersByEndpoint(ClientType clientType,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MTQzMQ=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTU0ODgxOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMTozMzo0MVrOF6sIXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMzozNzowNVrOF8xdHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4NDc2Nw==", "bodyText": "Do we really want a separate LocalGroupNotFoundException? If I understand correctly, we get\n\nAccessRightNotFoundException if we try to remove access right granted for a global group or subsystem\nLocalGroupNotFoundException if we try to remove access right granted for a local group\n\nWhy does the caller want a separate exception for local groups, but not for global groups and subsystems? Would just AccessRightNotFoundException be enough?", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397084767", "createdAt": "2020-03-24T11:33:41Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -147,92 +169,212 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n         return accessRightHolderDtos;\n     }\n \n+    /**\n+     * Makes an {@link AccessRightHolderDto} out of {@link AccessRightType}\n+     * @param accessRightType The AccessRightType to convert from\n+     * @param localGroupMap A Map containing {@link LocalGroupType LocalGroupTypes} mapped by\n+     * their corresponding {@link LocalGroupType#groupCode}\n+     * @return\n+     */\n+    private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightType,\n+                                                      Map<String, LocalGroupType> localGroupMap) {\n+        AccessRightHolderDto accessRightHolderDto = new AccessRightHolderDto();\n+        XRoadId subjectId = accessRightType.getSubjectId();\n+        accessRightHolderDto.setRightsGiven(\n+                FormatUtils.fromDateToOffsetDateTime(accessRightType.getRightsGiven()));\n+        accessRightHolderDto.setSubjectId(subjectId);\n+        if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n+            LocalGroupId localGroupId = (LocalGroupId) subjectId;\n+            LocalGroupType localGroupType = localGroupMap.get(localGroupId.getGroupCode());\n+            accessRightHolderDto.setLocalGroupId(localGroupType.getId().toString());\n+            accessRightHolderDto.setLocalGroupCode(localGroupType.getGroupCode());\n+            accessRightHolderDto.setLocalGroupDescription(localGroupType.getDescription());\n+        }\n+        return accessRightHolderDto;\n+    }\n+\n     /**\n      * Remove AccessRights from a Service\n      * @param clientId\n      * @param fullServiceCode\n      * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException if tried to remove local group access right\n+     * for a local group that does not exist\n+     * @throws AccessRightNotFoundException if tried to remove access rights that did not exist for the service\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n-     * @throws AccessRightNotFoundException if attempted to delete access right that did not exist for the service\n+     * @throws EndpointNotFoundByServiceNameException if the base endpoint for the service is not found\n      */\n-    private void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds)\n-            throws ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException {\n+    public void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds,\n+                                              Set<Long> localGroupIds) throws LocalGroupNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException,\n+            EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n \n-        List<AccessRightType> accessRightsToBeRemoved = clientType.getAcl()\n-                .stream()\n-                .filter(accessRightType -> accessRightType.getEndpoint().getServiceCode()\n-                        .equals(serviceType.getServiceCode()) && subjectIds.contains(accessRightType.getSubjectId()))\n-                .collect(Collectors.toList());\n+        deleteEndpointAccessRights(clientType, endpointType, subjectIds, localGroupIds);\n+    }\n \n-        List<XRoadId> subjectsToBeRemoved = accessRightsToBeRemoved\n-                .stream()\n-                .map(AccessRightType::getSubjectId)\n-                .collect(Collectors.toList());\n+    /**\n+     * Remove access rights from endpoint\n+     *\n+     * @param endpointId\n+     * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException                  if localgroups is not found\n+     * @throws EndpointService.EndpointNotFoundException    if endpoint by given id is not found\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     * @throws AccessRightNotFoundException                 if at least one access right expected is not found\n+     */\n+    public void deleteEndpointAccessRights(Long endpointId, Set<XRoadId> subjectIds, Set<Long> localGroupIds)\n+            throws LocalGroupNotFoundException, EndpointService.EndpointNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException {\n+        verifyAuthority(\"EDIT_ENDPOINT_ACL\");\n \n-        if (!subjectsToBeRemoved.containsAll(subjectIds)) {\n-            throw new AccessRightNotFoundException();\n+        ClientType clientType = clientRepository.getClientByEndpointId(endpointId);\n+        if (clientType == null) {\n+            throw new ClientNotFoundException(CLIENT_NOT_FOUND_FOR_ENDPOINT_WITH_ID + endpointId.toString());\n+        }\n+        EndpointType endpointType = endpointRepository.getEndpoint(endpointId);\n+        if (endpointType == null) {\n+            throw new EndpointService.EndpointNotFoundException(endpointId.toString());\n         }\n \n-        clientType.getAcl().removeAll(accessRightsToBeRemoved);\n-\n-        clientRepository.saveOrUpdate(clientType);\n+        deleteEndpointAccessRights(clientType, endpointType, subjectIds, localGroupIds);\n     }\n \n     /**\n-     * Remove AccessRights from a Service\n-     * @param clientId\n-     * @param fullServiceCode\n+     * Remove access rights from endpoint\n+     *\n+     * @param clientType\n+     * @param endpointType\n      * @param subjectIds\n      * @param localGroupIds\n-     * @throws LocalGroupNotFoundException if tried to remove local group access right\n-     * for a local group that does not exist\n-     * @throws AccessRightNotFoundException if tried to remove access rights that did not exist for the service\n-     * @throws ClientNotFoundException if client with given id was not found\n-     * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws LocalGroupNotFoundException  if localgroup is not found\n+     * @throws AccessRightNotFoundException if access right is not found", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI2MjIwOQ==", "bodyText": "LocalGroupNotFoundException is used in LocalGroupService too so I think the Exception class shouldn't be removed. In this file it originates only from method 'getLocalGroupsAsXroadIds' and there is part where localGroups are fetched by id so it sounds like the right exception to throw if fetching fails.\nI guess we could change this exception to AccessRightNotFoundException in the caller?", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r399262209", "createdAt": "2020-03-27T13:27:03Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -147,92 +169,212 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n         return accessRightHolderDtos;\n     }\n \n+    /**\n+     * Makes an {@link AccessRightHolderDto} out of {@link AccessRightType}\n+     * @param accessRightType The AccessRightType to convert from\n+     * @param localGroupMap A Map containing {@link LocalGroupType LocalGroupTypes} mapped by\n+     * their corresponding {@link LocalGroupType#groupCode}\n+     * @return\n+     */\n+    private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightType,\n+                                                      Map<String, LocalGroupType> localGroupMap) {\n+        AccessRightHolderDto accessRightHolderDto = new AccessRightHolderDto();\n+        XRoadId subjectId = accessRightType.getSubjectId();\n+        accessRightHolderDto.setRightsGiven(\n+                FormatUtils.fromDateToOffsetDateTime(accessRightType.getRightsGiven()));\n+        accessRightHolderDto.setSubjectId(subjectId);\n+        if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n+            LocalGroupId localGroupId = (LocalGroupId) subjectId;\n+            LocalGroupType localGroupType = localGroupMap.get(localGroupId.getGroupCode());\n+            accessRightHolderDto.setLocalGroupId(localGroupType.getId().toString());\n+            accessRightHolderDto.setLocalGroupCode(localGroupType.getGroupCode());\n+            accessRightHolderDto.setLocalGroupDescription(localGroupType.getDescription());\n+        }\n+        return accessRightHolderDto;\n+    }\n+\n     /**\n      * Remove AccessRights from a Service\n      * @param clientId\n      * @param fullServiceCode\n      * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException if tried to remove local group access right\n+     * for a local group that does not exist\n+     * @throws AccessRightNotFoundException if tried to remove access rights that did not exist for the service\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n-     * @throws AccessRightNotFoundException if attempted to delete access right that did not exist for the service\n+     * @throws EndpointNotFoundByServiceNameException if the base endpoint for the service is not found\n      */\n-    private void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds)\n-            throws ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException {\n+    public void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds,\n+                                              Set<Long> localGroupIds) throws LocalGroupNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException,\n+            EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n \n-        List<AccessRightType> accessRightsToBeRemoved = clientType.getAcl()\n-                .stream()\n-                .filter(accessRightType -> accessRightType.getEndpoint().getServiceCode()\n-                        .equals(serviceType.getServiceCode()) && subjectIds.contains(accessRightType.getSubjectId()))\n-                .collect(Collectors.toList());\n+        deleteEndpointAccessRights(clientType, endpointType, subjectIds, localGroupIds);\n+    }\n \n-        List<XRoadId> subjectsToBeRemoved = accessRightsToBeRemoved\n-                .stream()\n-                .map(AccessRightType::getSubjectId)\n-                .collect(Collectors.toList());\n+    /**\n+     * Remove access rights from endpoint\n+     *\n+     * @param endpointId\n+     * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException                  if localgroups is not found\n+     * @throws EndpointService.EndpointNotFoundException    if endpoint by given id is not found\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     * @throws AccessRightNotFoundException                 if at least one access right expected is not found\n+     */\n+    public void deleteEndpointAccessRights(Long endpointId, Set<XRoadId> subjectIds, Set<Long> localGroupIds)\n+            throws LocalGroupNotFoundException, EndpointService.EndpointNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException {\n+        verifyAuthority(\"EDIT_ENDPOINT_ACL\");\n \n-        if (!subjectsToBeRemoved.containsAll(subjectIds)) {\n-            throw new AccessRightNotFoundException();\n+        ClientType clientType = clientRepository.getClientByEndpointId(endpointId);\n+        if (clientType == null) {\n+            throw new ClientNotFoundException(CLIENT_NOT_FOUND_FOR_ENDPOINT_WITH_ID + endpointId.toString());\n+        }\n+        EndpointType endpointType = endpointRepository.getEndpoint(endpointId);\n+        if (endpointType == null) {\n+            throw new EndpointService.EndpointNotFoundException(endpointId.toString());\n         }\n \n-        clientType.getAcl().removeAll(accessRightsToBeRemoved);\n-\n-        clientRepository.saveOrUpdate(clientType);\n+        deleteEndpointAccessRights(clientType, endpointType, subjectIds, localGroupIds);\n     }\n \n     /**\n-     * Remove AccessRights from a Service\n-     * @param clientId\n-     * @param fullServiceCode\n+     * Remove access rights from endpoint\n+     *\n+     * @param clientType\n+     * @param endpointType\n      * @param subjectIds\n      * @param localGroupIds\n-     * @throws LocalGroupNotFoundException if tried to remove local group access right\n-     * for a local group that does not exist\n-     * @throws AccessRightNotFoundException if tried to remove access rights that did not exist for the service\n-     * @throws ClientNotFoundException if client with given id was not found\n-     * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws LocalGroupNotFoundException  if localgroup is not found\n+     * @throws AccessRightNotFoundException if access right is not found", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4NDc2Nw=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI2OTE1MA==", "bodyText": "Yeah, we should not remove the exception class itself. You could maybe\ntry {\n   doTheThing();\n} catch (LocalGroupNotFoundException e) {\n  throw new AccessRightNotFoundException(e);\n}\n\n?", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r399269150", "createdAt": "2020-03-27T13:37:05Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -147,92 +169,212 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n         return accessRightHolderDtos;\n     }\n \n+    /**\n+     * Makes an {@link AccessRightHolderDto} out of {@link AccessRightType}\n+     * @param accessRightType The AccessRightType to convert from\n+     * @param localGroupMap A Map containing {@link LocalGroupType LocalGroupTypes} mapped by\n+     * their corresponding {@link LocalGroupType#groupCode}\n+     * @return\n+     */\n+    private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightType,\n+                                                      Map<String, LocalGroupType> localGroupMap) {\n+        AccessRightHolderDto accessRightHolderDto = new AccessRightHolderDto();\n+        XRoadId subjectId = accessRightType.getSubjectId();\n+        accessRightHolderDto.setRightsGiven(\n+                FormatUtils.fromDateToOffsetDateTime(accessRightType.getRightsGiven()));\n+        accessRightHolderDto.setSubjectId(subjectId);\n+        if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n+            LocalGroupId localGroupId = (LocalGroupId) subjectId;\n+            LocalGroupType localGroupType = localGroupMap.get(localGroupId.getGroupCode());\n+            accessRightHolderDto.setLocalGroupId(localGroupType.getId().toString());\n+            accessRightHolderDto.setLocalGroupCode(localGroupType.getGroupCode());\n+            accessRightHolderDto.setLocalGroupDescription(localGroupType.getDescription());\n+        }\n+        return accessRightHolderDto;\n+    }\n+\n     /**\n      * Remove AccessRights from a Service\n      * @param clientId\n      * @param fullServiceCode\n      * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException if tried to remove local group access right\n+     * for a local group that does not exist\n+     * @throws AccessRightNotFoundException if tried to remove access rights that did not exist for the service\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n-     * @throws AccessRightNotFoundException if attempted to delete access right that did not exist for the service\n+     * @throws EndpointNotFoundByServiceNameException if the base endpoint for the service is not found\n      */\n-    private void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds)\n-            throws ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException {\n+    public void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds,\n+                                              Set<Long> localGroupIds) throws LocalGroupNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException,\n+            EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n \n-        List<AccessRightType> accessRightsToBeRemoved = clientType.getAcl()\n-                .stream()\n-                .filter(accessRightType -> accessRightType.getEndpoint().getServiceCode()\n-                        .equals(serviceType.getServiceCode()) && subjectIds.contains(accessRightType.getSubjectId()))\n-                .collect(Collectors.toList());\n+        deleteEndpointAccessRights(clientType, endpointType, subjectIds, localGroupIds);\n+    }\n \n-        List<XRoadId> subjectsToBeRemoved = accessRightsToBeRemoved\n-                .stream()\n-                .map(AccessRightType::getSubjectId)\n-                .collect(Collectors.toList());\n+    /**\n+     * Remove access rights from endpoint\n+     *\n+     * @param endpointId\n+     * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException                  if localgroups is not found\n+     * @throws EndpointService.EndpointNotFoundException    if endpoint by given id is not found\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     * @throws AccessRightNotFoundException                 if at least one access right expected is not found\n+     */\n+    public void deleteEndpointAccessRights(Long endpointId, Set<XRoadId> subjectIds, Set<Long> localGroupIds)\n+            throws LocalGroupNotFoundException, EndpointService.EndpointNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException {\n+        verifyAuthority(\"EDIT_ENDPOINT_ACL\");\n \n-        if (!subjectsToBeRemoved.containsAll(subjectIds)) {\n-            throw new AccessRightNotFoundException();\n+        ClientType clientType = clientRepository.getClientByEndpointId(endpointId);\n+        if (clientType == null) {\n+            throw new ClientNotFoundException(CLIENT_NOT_FOUND_FOR_ENDPOINT_WITH_ID + endpointId.toString());\n+        }\n+        EndpointType endpointType = endpointRepository.getEndpoint(endpointId);\n+        if (endpointType == null) {\n+            throw new EndpointService.EndpointNotFoundException(endpointId.toString());\n         }\n \n-        clientType.getAcl().removeAll(accessRightsToBeRemoved);\n-\n-        clientRepository.saveOrUpdate(clientType);\n+        deleteEndpointAccessRights(clientType, endpointType, subjectIds, localGroupIds);\n     }\n \n     /**\n-     * Remove AccessRights from a Service\n-     * @param clientId\n-     * @param fullServiceCode\n+     * Remove access rights from endpoint\n+     *\n+     * @param clientType\n+     * @param endpointType\n      * @param subjectIds\n      * @param localGroupIds\n-     * @throws LocalGroupNotFoundException if tried to remove local group access right\n-     * for a local group that does not exist\n-     * @throws AccessRightNotFoundException if tried to remove access rights that did not exist for the service\n-     * @throws ClientNotFoundException if client with given id was not found\n-     * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws LocalGroupNotFoundException  if localgroup is not found\n+     * @throws AccessRightNotFoundException if access right is not found", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4NDc2Nw=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 278}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTU1NTg3OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMTozNTo1M1rOF6sNFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMjozMToxOVrOF8vFww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4NTk3Mg==", "bodyText": "Probably not needed?", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397085972", "createdAt": "2020-03-24T11:35:53Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -147,92 +169,212 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n         return accessRightHolderDtos;\n     }\n \n+    /**\n+     * Makes an {@link AccessRightHolderDto} out of {@link AccessRightType}\n+     * @param accessRightType The AccessRightType to convert from\n+     * @param localGroupMap A Map containing {@link LocalGroupType LocalGroupTypes} mapped by\n+     * their corresponding {@link LocalGroupType#groupCode}\n+     * @return\n+     */\n+    private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightType,\n+                                                      Map<String, LocalGroupType> localGroupMap) {\n+        AccessRightHolderDto accessRightHolderDto = new AccessRightHolderDto();\n+        XRoadId subjectId = accessRightType.getSubjectId();\n+        accessRightHolderDto.setRightsGiven(\n+                FormatUtils.fromDateToOffsetDateTime(accessRightType.getRightsGiven()));\n+        accessRightHolderDto.setSubjectId(subjectId);\n+        if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n+            LocalGroupId localGroupId = (LocalGroupId) subjectId;\n+            LocalGroupType localGroupType = localGroupMap.get(localGroupId.getGroupCode());\n+            accessRightHolderDto.setLocalGroupId(localGroupType.getId().toString());\n+            accessRightHolderDto.setLocalGroupCode(localGroupType.getGroupCode());\n+            accessRightHolderDto.setLocalGroupDescription(localGroupType.getDescription());\n+        }\n+        return accessRightHolderDto;\n+    }\n+\n     /**\n      * Remove AccessRights from a Service\n      * @param clientId\n      * @param fullServiceCode\n      * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException if tried to remove local group access right\n+     * for a local group that does not exist\n+     * @throws AccessRightNotFoundException if tried to remove access rights that did not exist for the service\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n-     * @throws AccessRightNotFoundException if attempted to delete access right that did not exist for the service\n+     * @throws EndpointNotFoundByServiceNameException if the base endpoint for the service is not found\n      */\n-    private void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds)\n-            throws ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException {\n+    public void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds,\n+                                              Set<Long> localGroupIds) throws LocalGroupNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException,\n+            EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n \n-        List<AccessRightType> accessRightsToBeRemoved = clientType.getAcl()\n-                .stream()\n-                .filter(accessRightType -> accessRightType.getEndpoint().getServiceCode()\n-                        .equals(serviceType.getServiceCode()) && subjectIds.contains(accessRightType.getSubjectId()))\n-                .collect(Collectors.toList());\n+        deleteEndpointAccessRights(clientType, endpointType, subjectIds, localGroupIds);\n+    }\n \n-        List<XRoadId> subjectsToBeRemoved = accessRightsToBeRemoved\n-                .stream()\n-                .map(AccessRightType::getSubjectId)\n-                .collect(Collectors.toList());\n+    /**\n+     * Remove access rights from endpoint\n+     *\n+     * @param endpointId\n+     * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException                  if localgroups is not found\n+     * @throws EndpointService.EndpointNotFoundException    if endpoint by given id is not found\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     * @throws AccessRightNotFoundException                 if at least one access right expected is not found\n+     */\n+    public void deleteEndpointAccessRights(Long endpointId, Set<XRoadId> subjectIds, Set<Long> localGroupIds)\n+            throws LocalGroupNotFoundException, EndpointService.EndpointNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException {\n+        verifyAuthority(\"EDIT_ENDPOINT_ACL\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIzMDQwMw==", "bodyText": "Removed.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r399230403", "createdAt": "2020-03-27T12:31:19Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -147,92 +169,212 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n         return accessRightHolderDtos;\n     }\n \n+    /**\n+     * Makes an {@link AccessRightHolderDto} out of {@link AccessRightType}\n+     * @param accessRightType The AccessRightType to convert from\n+     * @param localGroupMap A Map containing {@link LocalGroupType LocalGroupTypes} mapped by\n+     * their corresponding {@link LocalGroupType#groupCode}\n+     * @return\n+     */\n+    private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightType,\n+                                                      Map<String, LocalGroupType> localGroupMap) {\n+        AccessRightHolderDto accessRightHolderDto = new AccessRightHolderDto();\n+        XRoadId subjectId = accessRightType.getSubjectId();\n+        accessRightHolderDto.setRightsGiven(\n+                FormatUtils.fromDateToOffsetDateTime(accessRightType.getRightsGiven()));\n+        accessRightHolderDto.setSubjectId(subjectId);\n+        if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n+            LocalGroupId localGroupId = (LocalGroupId) subjectId;\n+            LocalGroupType localGroupType = localGroupMap.get(localGroupId.getGroupCode());\n+            accessRightHolderDto.setLocalGroupId(localGroupType.getId().toString());\n+            accessRightHolderDto.setLocalGroupCode(localGroupType.getGroupCode());\n+            accessRightHolderDto.setLocalGroupDescription(localGroupType.getDescription());\n+        }\n+        return accessRightHolderDto;\n+    }\n+\n     /**\n      * Remove AccessRights from a Service\n      * @param clientId\n      * @param fullServiceCode\n      * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException if tried to remove local group access right\n+     * for a local group that does not exist\n+     * @throws AccessRightNotFoundException if tried to remove access rights that did not exist for the service\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n-     * @throws AccessRightNotFoundException if attempted to delete access right that did not exist for the service\n+     * @throws EndpointNotFoundByServiceNameException if the base endpoint for the service is not found\n      */\n-    private void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds)\n-            throws ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException {\n+    public void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds,\n+                                              Set<Long> localGroupIds) throws LocalGroupNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException,\n+            EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n \n-        List<AccessRightType> accessRightsToBeRemoved = clientType.getAcl()\n-                .stream()\n-                .filter(accessRightType -> accessRightType.getEndpoint().getServiceCode()\n-                        .equals(serviceType.getServiceCode()) && subjectIds.contains(accessRightType.getSubjectId()))\n-                .collect(Collectors.toList());\n+        deleteEndpointAccessRights(clientType, endpointType, subjectIds, localGroupIds);\n+    }\n \n-        List<XRoadId> subjectsToBeRemoved = accessRightsToBeRemoved\n-                .stream()\n-                .map(AccessRightType::getSubjectId)\n-                .collect(Collectors.toList());\n+    /**\n+     * Remove access rights from endpoint\n+     *\n+     * @param endpointId\n+     * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException                  if localgroups is not found\n+     * @throws EndpointService.EndpointNotFoundException    if endpoint by given id is not found\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     * @throws AccessRightNotFoundException                 if at least one access right expected is not found\n+     */\n+    public void deleteEndpointAccessRights(Long endpointId, Set<XRoadId> subjectIds, Set<Long> localGroupIds)\n+            throws LocalGroupNotFoundException, EndpointService.EndpointNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException {\n+        verifyAuthority(\"EDIT_ENDPOINT_ACL\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4NTk3Mg=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTU4MTgwOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMTo0NDowMVrOF6sdbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMToyNjowMVrOF8tIGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA5MDE1OA==", "bodyText": "This is probably not required. If you can, verify by testing, and remove it if it is unnecessary? There's some amount of unnecessary saveOrUpdate calls in the code, and recently we have tried to get rid of them. JPA stack should detect changes to the managed clientType and persist automatically. It is better to not have calls that do not serve any function.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397090158", "createdAt": "2020-03-24T11:44:01Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -147,92 +169,212 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n         return accessRightHolderDtos;\n     }\n \n+    /**\n+     * Makes an {@link AccessRightHolderDto} out of {@link AccessRightType}\n+     * @param accessRightType The AccessRightType to convert from\n+     * @param localGroupMap A Map containing {@link LocalGroupType LocalGroupTypes} mapped by\n+     * their corresponding {@link LocalGroupType#groupCode}\n+     * @return\n+     */\n+    private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightType,\n+                                                      Map<String, LocalGroupType> localGroupMap) {\n+        AccessRightHolderDto accessRightHolderDto = new AccessRightHolderDto();\n+        XRoadId subjectId = accessRightType.getSubjectId();\n+        accessRightHolderDto.setRightsGiven(\n+                FormatUtils.fromDateToOffsetDateTime(accessRightType.getRightsGiven()));\n+        accessRightHolderDto.setSubjectId(subjectId);\n+        if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n+            LocalGroupId localGroupId = (LocalGroupId) subjectId;\n+            LocalGroupType localGroupType = localGroupMap.get(localGroupId.getGroupCode());\n+            accessRightHolderDto.setLocalGroupId(localGroupType.getId().toString());\n+            accessRightHolderDto.setLocalGroupCode(localGroupType.getGroupCode());\n+            accessRightHolderDto.setLocalGroupDescription(localGroupType.getDescription());\n+        }\n+        return accessRightHolderDto;\n+    }\n+\n     /**\n      * Remove AccessRights from a Service\n      * @param clientId\n      * @param fullServiceCode\n      * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException if tried to remove local group access right\n+     * for a local group that does not exist\n+     * @throws AccessRightNotFoundException if tried to remove access rights that did not exist for the service\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n-     * @throws AccessRightNotFoundException if attempted to delete access right that did not exist for the service\n+     * @throws EndpointNotFoundByServiceNameException if the base endpoint for the service is not found\n      */\n-    private void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds)\n-            throws ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException {\n+    public void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds,\n+                                              Set<Long> localGroupIds) throws LocalGroupNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException,\n+            EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n \n-        List<AccessRightType> accessRightsToBeRemoved = clientType.getAcl()\n-                .stream()\n-                .filter(accessRightType -> accessRightType.getEndpoint().getServiceCode()\n-                        .equals(serviceType.getServiceCode()) && subjectIds.contains(accessRightType.getSubjectId()))\n-                .collect(Collectors.toList());\n+        deleteEndpointAccessRights(clientType, endpointType, subjectIds, localGroupIds);\n+    }\n \n-        List<XRoadId> subjectsToBeRemoved = accessRightsToBeRemoved\n-                .stream()\n-                .map(AccessRightType::getSubjectId)\n-                .collect(Collectors.toList());\n+    /**\n+     * Remove access rights from endpoint\n+     *\n+     * @param endpointId\n+     * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException                  if localgroups is not found\n+     * @throws EndpointService.EndpointNotFoundException    if endpoint by given id is not found\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     * @throws AccessRightNotFoundException                 if at least one access right expected is not found\n+     */\n+    public void deleteEndpointAccessRights(Long endpointId, Set<XRoadId> subjectIds, Set<Long> localGroupIds)\n+            throws LocalGroupNotFoundException, EndpointService.EndpointNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException {\n+        verifyAuthority(\"EDIT_ENDPOINT_ACL\");\n \n-        if (!subjectsToBeRemoved.containsAll(subjectIds)) {\n-            throw new AccessRightNotFoundException();\n+        ClientType clientType = clientRepository.getClientByEndpointId(endpointId);\n+        if (clientType == null) {\n+            throw new ClientNotFoundException(CLIENT_NOT_FOUND_FOR_ENDPOINT_WITH_ID + endpointId.toString());\n+        }\n+        EndpointType endpointType = endpointRepository.getEndpoint(endpointId);\n+        if (endpointType == null) {\n+            throw new EndpointService.EndpointNotFoundException(endpointId.toString());\n         }\n \n-        clientType.getAcl().removeAll(accessRightsToBeRemoved);\n-\n-        clientRepository.saveOrUpdate(clientType);\n+        deleteEndpointAccessRights(clientType, endpointType, subjectIds, localGroupIds);\n     }\n \n     /**\n-     * Remove AccessRights from a Service\n-     * @param clientId\n-     * @param fullServiceCode\n+     * Remove access rights from endpoint\n+     *\n+     * @param clientType\n+     * @param endpointType\n      * @param subjectIds\n      * @param localGroupIds\n-     * @throws LocalGroupNotFoundException if tried to remove local group access right\n-     * for a local group that does not exist\n-     * @throws AccessRightNotFoundException if tried to remove access rights that did not exist for the service\n-     * @throws ClientNotFoundException if client with given id was not found\n-     * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws LocalGroupNotFoundException  if localgroup is not found\n+     * @throws AccessRightNotFoundException if access right is not found\n      */\n-    public void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds,\n-            Set<Long> localGroupIds) throws LocalGroupNotFoundException, ClientNotFoundException,\n-            AccessRightNotFoundException, ServiceNotFoundException {\n-        Set<XRoadId> idsToDelete = new HashSet<>();\n+    private void deleteEndpointAccessRights(ClientType clientType, EndpointType endpointType, Set<XRoadId> subjectIds,\n+            Set<Long> localGroupIds) throws LocalGroupNotFoundException, AccessRightNotFoundException {\n+\n+        Set<XRoadId> subjectsToDelete = new HashSet<>();\n         if (localGroupIds != null) {\n-            idsToDelete.addAll(getLocalGroupsAsXroadIds(localGroupIds));\n+            subjectsToDelete.addAll(getLocalGroupsAsXroadIds(localGroupIds));\n         }\n         if (subjectIds != null) {\n-            idsToDelete.addAll(subjectIds);\n+            subjectsToDelete.addAll(subjectIds);\n+        }\n+\n+        List<AccessRightType> accessRightsToBeRemoved = clientType.getAcl().stream()\n+                .filter(acl -> acl.getEndpoint().getId().equals(endpointType.getId())\n+                        && subjectsToDelete.contains(acl.getSubjectId()))\n+                .collect(Collectors.toList());\n+        if (accessRightsToBeRemoved.size() != subjectsToDelete.size()) {\n+            throw new AccessRightNotFoundException();\n         }\n-        deleteSoapServiceAccessRights(clientId, fullServiceCode, idsToDelete);\n+\n+        clientType.getAcl().removeAll(accessRightsToBeRemoved);\n+        clientRepository.saveOrUpdate(clientType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE5ODIzMw==", "bodyText": "Removed saveOrUpdate. Wasn't necessary.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r399198233", "createdAt": "2020-03-27T11:26:01Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -147,92 +169,212 @@ private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightTyp\n         return accessRightHolderDtos;\n     }\n \n+    /**\n+     * Makes an {@link AccessRightHolderDto} out of {@link AccessRightType}\n+     * @param accessRightType The AccessRightType to convert from\n+     * @param localGroupMap A Map containing {@link LocalGroupType LocalGroupTypes} mapped by\n+     * their corresponding {@link LocalGroupType#groupCode}\n+     * @return\n+     */\n+    private AccessRightHolderDto accessRightTypeToDto(AccessRightType accessRightType,\n+                                                      Map<String, LocalGroupType> localGroupMap) {\n+        AccessRightHolderDto accessRightHolderDto = new AccessRightHolderDto();\n+        XRoadId subjectId = accessRightType.getSubjectId();\n+        accessRightHolderDto.setRightsGiven(\n+                FormatUtils.fromDateToOffsetDateTime(accessRightType.getRightsGiven()));\n+        accessRightHolderDto.setSubjectId(subjectId);\n+        if (subjectId.getObjectType() == XRoadObjectType.LOCALGROUP) {\n+            LocalGroupId localGroupId = (LocalGroupId) subjectId;\n+            LocalGroupType localGroupType = localGroupMap.get(localGroupId.getGroupCode());\n+            accessRightHolderDto.setLocalGroupId(localGroupType.getId().toString());\n+            accessRightHolderDto.setLocalGroupCode(localGroupType.getGroupCode());\n+            accessRightHolderDto.setLocalGroupDescription(localGroupType.getDescription());\n+        }\n+        return accessRightHolderDto;\n+    }\n+\n     /**\n      * Remove AccessRights from a Service\n      * @param clientId\n      * @param fullServiceCode\n      * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException if tried to remove local group access right\n+     * for a local group that does not exist\n+     * @throws AccessRightNotFoundException if tried to remove access rights that did not exist for the service\n      * @throws ClientNotFoundException if client with given id was not found\n      * @throws ServiceNotFoundException if service with given fullServicecode was not found\n-     * @throws AccessRightNotFoundException if attempted to delete access right that did not exist for the service\n+     * @throws EndpointNotFoundByServiceNameException if the base endpoint for the service is not found\n      */\n-    private void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds)\n-            throws ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException {\n+    public void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds,\n+                                              Set<Long> localGroupIds) throws LocalGroupNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException, ServiceNotFoundException,\n+            EndpointNotFoundByServiceNameException {\n         ClientType clientType = clientRepository.getClient(clientId);\n         if (clientType == null) {\n             throw new ClientNotFoundException(\"Client \" + clientId.toShortString() + \" not found\");\n         }\n \n         ServiceType serviceType = serviceService.getServiceFromClient(clientType, fullServiceCode);\n+        EndpointType endpointType = getEndpoint(clientType, serviceType, EndpointType.ANY_METHOD, EndpointType.ANY_PATH)\n+                .orElseThrow(() -> new EndpointNotFoundByServiceNameException(fullServiceCode));\n \n-        List<AccessRightType> accessRightsToBeRemoved = clientType.getAcl()\n-                .stream()\n-                .filter(accessRightType -> accessRightType.getEndpoint().getServiceCode()\n-                        .equals(serviceType.getServiceCode()) && subjectIds.contains(accessRightType.getSubjectId()))\n-                .collect(Collectors.toList());\n+        deleteEndpointAccessRights(clientType, endpointType, subjectIds, localGroupIds);\n+    }\n \n-        List<XRoadId> subjectsToBeRemoved = accessRightsToBeRemoved\n-                .stream()\n-                .map(AccessRightType::getSubjectId)\n-                .collect(Collectors.toList());\n+    /**\n+     * Remove access rights from endpoint\n+     *\n+     * @param endpointId\n+     * @param subjectIds\n+     * @param localGroupIds\n+     * @throws LocalGroupNotFoundException                  if localgroups is not found\n+     * @throws EndpointService.EndpointNotFoundException    if endpoint by given id is not found\n+     * @throws ClientNotFoundException                      if client attached to endpoint is not found\n+     * @throws AccessRightNotFoundException                 if at least one access right expected is not found\n+     */\n+    public void deleteEndpointAccessRights(Long endpointId, Set<XRoadId> subjectIds, Set<Long> localGroupIds)\n+            throws LocalGroupNotFoundException, EndpointService.EndpointNotFoundException,\n+            ClientNotFoundException, AccessRightNotFoundException {\n+        verifyAuthority(\"EDIT_ENDPOINT_ACL\");\n \n-        if (!subjectsToBeRemoved.containsAll(subjectIds)) {\n-            throw new AccessRightNotFoundException();\n+        ClientType clientType = clientRepository.getClientByEndpointId(endpointId);\n+        if (clientType == null) {\n+            throw new ClientNotFoundException(CLIENT_NOT_FOUND_FOR_ENDPOINT_WITH_ID + endpointId.toString());\n+        }\n+        EndpointType endpointType = endpointRepository.getEndpoint(endpointId);\n+        if (endpointType == null) {\n+            throw new EndpointService.EndpointNotFoundException(endpointId.toString());\n         }\n \n-        clientType.getAcl().removeAll(accessRightsToBeRemoved);\n-\n-        clientRepository.saveOrUpdate(clientType);\n+        deleteEndpointAccessRights(clientType, endpointType, subjectIds, localGroupIds);\n     }\n \n     /**\n-     * Remove AccessRights from a Service\n-     * @param clientId\n-     * @param fullServiceCode\n+     * Remove access rights from endpoint\n+     *\n+     * @param clientType\n+     * @param endpointType\n      * @param subjectIds\n      * @param localGroupIds\n-     * @throws LocalGroupNotFoundException if tried to remove local group access right\n-     * for a local group that does not exist\n-     * @throws AccessRightNotFoundException if tried to remove access rights that did not exist for the service\n-     * @throws ClientNotFoundException if client with given id was not found\n-     * @throws ServiceNotFoundException if service with given fullServicecode was not found\n+     * @throws LocalGroupNotFoundException  if localgroup is not found\n+     * @throws AccessRightNotFoundException if access right is not found\n      */\n-    public void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceCode, Set<XRoadId> subjectIds,\n-            Set<Long> localGroupIds) throws LocalGroupNotFoundException, ClientNotFoundException,\n-            AccessRightNotFoundException, ServiceNotFoundException {\n-        Set<XRoadId> idsToDelete = new HashSet<>();\n+    private void deleteEndpointAccessRights(ClientType clientType, EndpointType endpointType, Set<XRoadId> subjectIds,\n+            Set<Long> localGroupIds) throws LocalGroupNotFoundException, AccessRightNotFoundException {\n+\n+        Set<XRoadId> subjectsToDelete = new HashSet<>();\n         if (localGroupIds != null) {\n-            idsToDelete.addAll(getLocalGroupsAsXroadIds(localGroupIds));\n+            subjectsToDelete.addAll(getLocalGroupsAsXroadIds(localGroupIds));\n         }\n         if (subjectIds != null) {\n-            idsToDelete.addAll(subjectIds);\n+            subjectsToDelete.addAll(subjectIds);\n+        }\n+\n+        List<AccessRightType> accessRightsToBeRemoved = clientType.getAcl().stream()\n+                .filter(acl -> acl.getEndpoint().getId().equals(endpointType.getId())\n+                        && subjectsToDelete.contains(acl.getSubjectId()))\n+                .collect(Collectors.toList());\n+        if (accessRightsToBeRemoved.size() != subjectsToDelete.size()) {\n+            throw new AccessRightNotFoundException();\n         }\n-        deleteSoapServiceAccessRights(clientId, fullServiceCode, idsToDelete);\n+\n+        clientType.getAcl().removeAll(accessRightsToBeRemoved);\n+        clientRepository.saveOrUpdate(clientType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA5MDE1OA=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTU5Nzc1OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/frontend/src/views/Service/Service.vue", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMTo0ODo1OVrOF6snjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo0MTozM1rOF8KOMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA5Mjc1MQ==", "bodyText": "Cant find where this should go - but service level access rights table should contain \"access rights given\" info: https://niis.slack.com/archives/GGBHVCYSY/p1585046751023500", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397092751", "createdAt": "2020-03-24T11:48:59Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/frontend/src/views/Service/Service.vue", "diffHunk": "@@ -57,7 +57,7 @@ export default Vue.extend({\n           key: 'endpoints',\n           name: 'tab.services.endpoints',\n           to: {\n-            name: RouteName.ServiceEndpoints,\n+            name: RouteName.Endpoints,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYyNjM1Mg==", "bodyText": "Added.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r398626352", "createdAt": "2020-03-26T14:41:33Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/frontend/src/views/Service/Service.vue", "diffHunk": "@@ -57,7 +57,7 @@ export default Vue.extend({\n           key: 'endpoints',\n           name: 'tab.services.endpoints',\n           to: {\n-            name: RouteName.ServiceEndpoints,\n+            name: RouteName.Endpoints,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA5Mjc1MQ=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTg4NzE0OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/resources/openapi-definition.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMzoxMTowNFrOF6vdkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxOToyOToyOVrOF8XGuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzOTM0Nw==", "bodyText": "maxLength is not really 255 since this maps to endpoint table PK which is BIGINT, which is -9223372036854775808 to 9223372036854775807.\nSo I guess maxLength(20) or maxLength(19) would be more correct. 20 if negatives are possible, I guess they could be.\nI would probably either leave maxLength out (since Endpoint schema object does not define it either) or use maxLength(20), I can't see the argument for using the wrong value (even if it may have originally been selected by me sometime long ago). Maybe there is a possibility that we could be using a different database in some future scenario, but I doubt 255 would be certain to be correct in that case, either.\nAlso localGroup and serviceDescription endpoints suffer from the same.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397139347", "createdAt": "2020-03-24T13:11:04Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/resources/openapi-definition.yaml", "diffHunk": "@@ -2532,6 +2535,130 @@ paths:\n           description: request specified an invalid format\n         '500':\n           description: internal server error\n+  /endpoints/{id}/access-rights:\n+    get:\n+      tags:\n+        - security server\n+      summary: get access rights for the selected endpoint\n+      operationId: getEndpointAccessRights\n+      description: Administrator views endpoints access rights\n+      parameters:\n+        - in: path\n+          name: id\n+          description: id of the endpoint\n+          required: true\n+          schema:\n+            type: string\n+            format: text\n+            minLength: 1\n+            maxLength: 255", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgzNzQzMw==", "bodyText": "Removed maxLength", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r398837433", "createdAt": "2020-03-26T19:29:29Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/resources/openapi-definition.yaml", "diffHunk": "@@ -2532,6 +2535,130 @@ paths:\n           description: request specified an invalid format\n         '500':\n           description: internal server error\n+  /endpoints/{id}/access-rights:\n+    get:\n+      tags:\n+        - security server\n+      summary: get access rights for the selected endpoint\n+      operationId: getEndpointAccessRights\n+      description: Administrator views endpoints access rights\n+      parameters:\n+        - in: path\n+          name: id\n+          description: id of the endpoint\n+          required: true\n+          schema:\n+            type: string\n+            format: text\n+            minLength: 1\n+            maxLength: 255", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzOTM0Nw=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTk1NzA4OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMzoyODowMFrOF6wJHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMToyMzoxMlrOF8tCNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE1MDQ5NA==", "bodyText": "nitpick: Sonar suggests \"Use isEmpty() to check whether the collection is empty or not\" https://sonarqube.niis.org/project/issues?id=xroad&issues=AXDETU4aBW8O1Uq1Fo6y&open=AXDETU4aBW8O1Uq1Fo6y&pullRequest=408", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397150494", "createdAt": "2020-03-24T13:28:00Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -270,58 +415,42 @@ public void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceC\n         return accessRightHolderDtos;\n     }\n \n-    /**\n-     * Get matching {@link EndpointType endpoint} from {@link ClientType#endpoint client's list of endpoints}.\n-     * @param clientType\n-     * @param serviceType\n-     * @param endpointMethod\n-     * @param endpointPath\n-     * @return\n-     */\n-    private Optional<EndpointType> getEndpoint(ClientType clientType, ServiceType serviceType, String endpointMethod,\n-            String endpointPath) {\n-        return clientType.getEndpoint().stream()\n-                .filter(endpointType -> endpointType.getServiceCode().equals(serviceType.getServiceCode())\n-                        && endpointType.getMethod().equals(endpointMethod)\n-                        && endpointType.getPath().equals(endpointPath))\n-                .findFirst();\n-    }\n-\n-    /**\n-     * Adds access rights to SOAP services. If the provided {@code subjectIds} do not exist in the serverconf db\n-     * they will first be validated (that they exist in global conf) and then saved into the serverconf db.\n-     * LocalGroup ids will also be verified and if they don't exist in the serverconf db they will be saved\n-     * @param clientId\n-     * @param fullServiceCode\n-     * @param subjectIds\n-     * @param localGroupIds\n-     * @return List of {@link AccessRightHolderDto AccessRightHolderDtos}\n-     * @throws LocalGroupNotFoundException\n-     * @throws ClientNotFoundException\n-     * @throws ServiceNotFoundException\n-     * @throws EndpointNotFoundException\n-     */\n-    public List<AccessRightHolderDto> addSoapServiceAccessRights(ClientId clientId, String fullServiceCode,\n-            Set<XRoadId> subjectIds, Set<Long> localGroupIds) throws LocalGroupNotFoundException,\n-            ClientNotFoundException, ServiceNotFoundException, DuplicateAccessRightException,\n-            IdentifierNotFoundException, EndpointNotFoundException {\n+    private Set<XRoadId> mergeSubjectIdsWithLocalgroups(Set<XRoadId> subjectIds, Set<Long> localGroupIds)\n+            throws IdentifierNotFoundException, LocalGroupNotFoundException {\n         // Get persistent entities in order to change relations\n         Set<XRoadId> txSubjects = new HashSet<>();\n-        if (subjectIds != null) {\n+        if (subjectIds != null && subjectIds.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 487}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE5NjcyNg==", "bodyText": "Fixed.", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r399196726", "createdAt": "2020-03-27T11:23:12Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/src/main/java/org/niis/xroad/restapi/service/AccessRightService.java", "diffHunk": "@@ -270,58 +415,42 @@ public void deleteSoapServiceAccessRights(ClientId clientId, String fullServiceC\n         return accessRightHolderDtos;\n     }\n \n-    /**\n-     * Get matching {@link EndpointType endpoint} from {@link ClientType#endpoint client's list of endpoints}.\n-     * @param clientType\n-     * @param serviceType\n-     * @param endpointMethod\n-     * @param endpointPath\n-     * @return\n-     */\n-    private Optional<EndpointType> getEndpoint(ClientType clientType, ServiceType serviceType, String endpointMethod,\n-            String endpointPath) {\n-        return clientType.getEndpoint().stream()\n-                .filter(endpointType -> endpointType.getServiceCode().equals(serviceType.getServiceCode())\n-                        && endpointType.getMethod().equals(endpointMethod)\n-                        && endpointType.getPath().equals(endpointPath))\n-                .findFirst();\n-    }\n-\n-    /**\n-     * Adds access rights to SOAP services. If the provided {@code subjectIds} do not exist in the serverconf db\n-     * they will first be validated (that they exist in global conf) and then saved into the serverconf db.\n-     * LocalGroup ids will also be verified and if they don't exist in the serverconf db they will be saved\n-     * @param clientId\n-     * @param fullServiceCode\n-     * @param subjectIds\n-     * @param localGroupIds\n-     * @return List of {@link AccessRightHolderDto AccessRightHolderDtos}\n-     * @throws LocalGroupNotFoundException\n-     * @throws ClientNotFoundException\n-     * @throws ServiceNotFoundException\n-     * @throws EndpointNotFoundException\n-     */\n-    public List<AccessRightHolderDto> addSoapServiceAccessRights(ClientId clientId, String fullServiceCode,\n-            Set<XRoadId> subjectIds, Set<Long> localGroupIds) throws LocalGroupNotFoundException,\n-            ClientNotFoundException, ServiceNotFoundException, DuplicateAccessRightException,\n-            IdentifierNotFoundException, EndpointNotFoundException {\n+    private Set<XRoadId> mergeSubjectIdsWithLocalgroups(Set<XRoadId> subjectIds, Set<Long> localGroupIds)\n+            throws IdentifierNotFoundException, LocalGroupNotFoundException {\n         // Get persistent entities in order to change relations\n         Set<XRoadId> txSubjects = new HashSet<>();\n-        if (subjectIds != null) {\n+        if (subjectIds != null && subjectIds.size() > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE1MDQ5NA=="}, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 487}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTk2OTg4OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/openapi/EndpointsApiControllerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMzozMDo1MlrOF6wQ6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMzozMDo1MlrOF6wQ6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE1MjQ5MA==", "bodyText": "Sonar says Coverage on New Code 82.2%, that is pretty good \ud83d\udc4d", "url": "https://github.com/nordic-institute/X-Road/pull/408#discussion_r397152490", "createdAt": "2020-03-24T13:30:52Z", "author": {"login": "jansu76"}, "path": "src/proxy-ui-api/src/test/java/org/niis/xroad/restapi/openapi/EndpointsApiControllerTest.java", "diffHunk": "@@ -116,7 +138,94 @@ public void updateEndpoint() {\n         assertTrue(endpointType.getServiceCode().equals(\"TestServiceCode\"));\n         assertTrue(endpointType.getMethod().equals(\"*\"));\n         assertTrue(endpointType.getPath().equals(\"/test\"));\n+    }\n \n+    @Test(expected = ResourceNotFoundException.class)\n+    @WithMockUser(authorities = {\"VIEW_ENDPOINT_ACL\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5bedf56206aae88f7d96f2865c070d2c3bba11"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2984, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}