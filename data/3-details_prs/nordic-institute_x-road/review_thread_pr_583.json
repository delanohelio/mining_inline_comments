{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1MzczMTU2", "number": 583, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjoyMzo1NVrOEOO_2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjoyOTo1OVrOEOPJnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzYxMjQzOnYy", "diffSide": "RIGHT", "path": "src/signer-protocol/src/main/java/ee/ria/xroad/signer/protocol/SignerClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjoyMzo1NVrOGxRRsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjoyMzo1NVrOGxRRsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMxNjQ2Ng==", "bodyText": "The code related to SignerClient, SignerWatcher and signer requestProcessor tracking is pretty complex. I read it for some time and was barely able to grasp what is happening, and would be a bit scared if I had to update it.\nI think ideally some sort of diagram would be great aid to help understanding the implementation, so that people can later update the implementation with better confidence. Perhaps it could show things like the actual client, SignerClient, SignerWatcher, Signer, and the different messages that flow between these (Watch, Identify, ActorIdentity, Terminated).\nIf not a diagram, then maybe consider adding some textual comments to make it easier to understand the mechanism.\nAlso behavior of correlationId and signerRef might benefit from more explanation.", "url": "https://github.com/nordic-institute/X-Road/pull/583#discussion_r454316466", "createdAt": "2020-07-14T12:23:55Z", "author": {"login": "jansu76"}, "path": "src/signer-protocol/src/main/java/ee/ria/xroad/signer/protocol/SignerClient.java", "diffHunk": "@@ -65,95 +72,191 @@ private SignerClient() {\n      * @param system the actor system\n      * @throws Exception if an error occurs\n      */\n-    public static void init(ActorSystem system) throws Exception {\n+    public static void init(ActorSystem system) {\n         init(system, LOCALHOST_IP);\n     }\n \n     /**\n      * Initializes the client with the provided actor system.\n-     * @param system the actor system\n+     * @param system          the actor system\n      * @param signerIpAddress IP address for remote signer\n-     *                         or 127.0.0.1 for local signer\n+     *                        or 127.0.0.1 for local signer\n      * @throws Exception if an error occurs\n      */\n-    public static void init(ActorSystem system,\n-                            String signerIpAddress) throws Exception {\n-        log.trace(\"init()\");\n-\n-        if (SignerClient.actorSystem == null) {\n-            SignerClient.actorSystem = system;\n-\n-            requestProcessor = system.actorSelection(\n-                    getSignerPath(signerIpAddress) + \"/user/\" + REQUEST_PROCESSOR);\n-\n-        }\n+    public static void init(ActorSystem system, String signerIpAddress) {\n+        SignerWatcher.init(system, signerIpAddress);\n     }\n \n     /**\n      * Forwards a message to the signer.\n-     * @param message the message\n+     * @param message  the message\n      * @param receiver the receiver actor\n      */\n     public static void execute(Object message, ActorRef receiver) {\n-        verifyInitialized();\n-        requestProcessor.tell(message, receiver);\n+        signerRef().tell(message, receiver);\n     }\n \n     /**\n      * Sends a message and waits for a response, returning it. If the response\n      * is an exception, throws it.\n-     * @param <T> the type of result\n+     * @param <T>     the type of result\n      * @param message the message\n      * @return the response\n      * @throws Exception if the response is an exception\n      */\n     public static <T> T execute(Object message) throws Exception {\n-        verifyInitialized();\n-\n-        final Timeout timeout = Timeout.apply(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n         try {\n-            return result(Await.result(Patterns.ask(requestProcessor, message, timeout), timeout.duration()));\n-        } catch (TimeoutException te) {\n-            throw connectionTimeoutException(te);\n+            return result(Await.result(Patterns.ask(signerRef(), message, TIMEOUT), TIMEOUT.duration()));\n+        } catch (TimeoutException e) {\n+            throw new CodedException(X_INTERNAL_ERROR, e, \"Request to Signer timed out\");\n         }\n     }\n \n     /**\n      * Returns the object as the instance or throws exception, if the object\n      * is throwable.\n-     * @param <T> the type of result\n+     * @param <T>    the type of result\n      * @param result the result object\n      * @return result\n      * @throws Exception if the object is throwable\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <T> T result(Object result) throws Exception {\n         if (result instanceof Throwable) {\n-            throw (Exception) result;\n+            throw (Exception)result;\n         } else {\n-            return (T) result;\n+            return (T)result;\n         }\n     }\n \n-    private static String getSignerPath() {\n-        return getSignerPath(\"127.0.0.1\");\n-    }\n+    static class SignerWatcher extends UntypedAbstractActor {\n \n-    private static String getSignerPath(String signerIpAddress) {\n-        return \"akka://\" + SIGNER + \"@\" + signerIpAddress + \":\"\n-                + SystemProperties.getSignerPort();\n-    }\n+        /*\n+         * Implementation notes.\n+         *\n+         * The requestProcessor future will be completed by the internally used\n+         * SignerWatcher actor, and replaced with a new one in case the Signer is restarted. The purpose is to avoid\n+         * long request timeouts when the signer is not (yet) available, and to detect restarts.\n+         *\n+         */\n+        private static volatile CompletableFuture<ActorRef> requestProcessor = null;\n+        private static final Duration WATCH_DELAY = Duration.ofSeconds(1);\n+        private static final int REF_GET_TIMEOUT = 7;\n \n-    private static void verifyInitialized() {\n-        if (actorSystem == null) {\n-            throw new IllegalStateException(\"SignerClient is not initialized\");\n+        static ActorRef signerRef() {\n+            final CompletableFuture<ActorRef> processor = requestProcessor;\n+            if (processor == null) {\n+                throw new IllegalStateException(\"SignerClient is not initialized\");\n+            }\n+            try {\n+                return processor.get(REF_GET_TIMEOUT, TimeUnit.SECONDS);\n+            } catch (ExecutionException | TimeoutException | CancellationException e) {\n+                throw new CodedException(X_INTERNAL_ERROR, e, \"Signer is unreachable\");\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new CodedException(X_INTERNAL_ERROR, e, \"Request to signer was interrupted\");\n+            }\n         }\n-    }\n \n-    private static CodedException connectionTimeoutException(Exception e) {\n-        return new CodedException(X_HTTP_ERROR, e,\n-                \"Connection to Signer (port %s) timed out\",\n-                SystemProperties.getSignerPort());\n-    }\n+        static synchronized void init(ActorSystem system, String signerIpAddress) {\n+            if (requestProcessor == null) {\n+                requestProcessor = new CompletableFuture<>();\n+                system.actorOf(Props.create(SignerWatcher.class, signerIpAddress));\n+            }\n+        }\n+\n+        private static synchronized void resetRequestProcessor(CompletableFuture<ActorRef> processor) {\n+            if (requestProcessor != null && !requestProcessor.isDone()) {\n+                requestProcessor.cancel(true);\n+            }\n+            requestProcessor = processor;\n+        }\n+\n+        private long correlationId = 0;\n+        private ActorRef signerRef;\n+        private ActorSelection signer;\n+        private final String signerIpAddress;\n+\n+        interface Watch {\n+        }\n \n+        SignerWatcher(String signerIpAddress) {\n+            this.signerIpAddress = signerIpAddress;\n+        }\n+\n+        @Override\n+        public void preStart() {\n+            signer = context().actorSelection(getSignerPath() + \"/user/\" + REQUEST_PROCESSOR);\n+            self().tell(Watch.class, self());\n+        }\n+\n+        @Override\n+        public void postStop() {\n+            if (signerRef != null) {\n+                context().unwatch(signerRef);\n+            }\n+            resetRequestProcessor(null);\n+        }\n+\n+        @Override\n+        public void onReceive(final Object message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe13ccab6021d8cc8b71070570b1d7266b0809c7"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzYzNzQxOnYy", "diffSide": "RIGHT", "path": "src/common-util/src/main/resources/akka-global.conf", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjoyOTo1OVrOGxRgJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjoyOTo1OVrOGxRgJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyMDE2Nw==", "bodyText": "After the branch has been merged, it would be good to follow how long term testing, if it shows any changes in memory usage?", "url": "https://github.com/nordic-institute/X-Road/pull/583#discussion_r454320167", "createdAt": "2020-07-14T12:29:59Z", "author": {"login": "jansu76"}, "path": "src/common-util/src/main/resources/akka-global.conf", "diffHunk": "@@ -1,40 +1,55 @@\n akka {\n-    stdout-loglevel = \"OFF\"\n-    loggers = [\"akka.event.slf4j.Slf4jLogger\"]\n-    loglevel = \"DEBUG\"\n-    logging-filter = \"akka.event.slf4j.Slf4jLoggingFilter\"\n-\n-    actor {\n-        # for now, using java serialization\n-        allow-java-serialization = true\n-        warn-about-java-serializer-usage = false\n-    }\n+  stdout-loglevel = \"OFF\"\n+  loggers = [\"akka.event.slf4j.Slf4jLogger\"]\n+  loglevel = \"DEBUG\"\n+  logging-filter = \"akka.event.slf4j.Slf4jLoggingFilter\"\n+\n+  actor {\n+    # for now, using java serialization\n+    allow-java-serialization = true\n+    warn-about-java-serializer-usage = false\n+  }\n+\n+  remote {\n+    artery {\n+      transport = tcp\n \n-    remote {\n-        artery {\n-            transport = tcp\n+      canonical {\n+        port = 0\n+        hostname = \"127.0.0.1\"\n+      }\n \n-            canonical {\n-                port = 0\n-                hostname = \"127.0.0.1\"\n-            }\n+      advanced {\n+        # Maximum serialized message size, including header data.\n+        maximum-frame-size = 256 KiB\n \n-            advanced {\n-                # Maximum serialized message size, including header data.\n-                maximum-frame-size = 256 KiB\n-            }\n+        # Disable compression:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe13ccab6021d8cc8b71070570b1d7266b0809c7"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2746, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}