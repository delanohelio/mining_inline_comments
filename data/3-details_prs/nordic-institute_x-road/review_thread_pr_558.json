{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1NjMyMzM4", "number": 558, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwOTo1NzoxMlrOEGSBlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMDo0NjoxNVrOEGTBaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDIyMjMwOnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/frontend/src/views/AddSubsystem/AddSubsystem.vue", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwOTo1NzoxMlrOGk-ppw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzo0Njo0OVrOGlGjgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQyODM5MQ==", "bodyText": "I think adding internal_search=false here doesn't make a difference to the logic as I'm pretty sure that missing field will be interpreted as false anyway. It's not wrong but I guess if it's futile then it could be removed.", "url": "https://github.com/nordic-institute/X-Road/pull/558#discussion_r441428391", "createdAt": "2020-06-17T09:57:12Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/frontend/src/views/AddSubsystem/AddSubsystem.vue", "diffHunk": "@@ -255,7 +255,7 @@ export default Vue.extend({\n       // Fetch selectable subsystems\n       api\n         .get(\n-          `/clients?instance=${this.instanceId}&member_class=${this.memberClass}&member_code=${this.memberCode}&show_members=false&exclude_local=true`,\n+          `/clients?instance=${this.instanceId}&member_class=${this.memberClass}&member_code=${this.memberCode}&show_members=false&exclude_local=true&internal_search=false`,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b30304c30e5e0ede95f97d6f191dc13fe1dc00d0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU1Nzg4OA==", "bodyText": "By default internal_search is actually true:\n\n  \n    \n      X-Road/src/proxy-ui-api/src/main/resources/openapi-definition.yaml\n    \n    \n         Line 657\n      in\n      bc20e9a\n    \n    \n    \n    \n\n        \n          \n           default: true \n        \n    \n  \n\n\nThe original problem was that the parameter was missing and the default value (true) was used which led to incorrect query.", "url": "https://github.com/nordic-institute/X-Road/pull/558#discussion_r441557888", "createdAt": "2020-06-17T13:46:49Z", "author": {"login": "petkivim"}, "path": "src/proxy-ui-api/frontend/src/views/AddSubsystem/AddSubsystem.vue", "diffHunk": "@@ -255,7 +255,7 @@ export default Vue.extend({\n       // Fetch selectable subsystems\n       api\n         .get(\n-          `/clients?instance=${this.instanceId}&member_class=${this.memberClass}&member_code=${this.memberCode}&show_members=false&exclude_local=true`,\n+          `/clients?instance=${this.instanceId}&member_class=${this.memberClass}&member_code=${this.memberCode}&show_members=false&exclude_local=true&internal_search=false`,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQyODM5MQ=="}, "originalCommit": {"oid": "b30304c30e5e0ede95f97d6f191dc13fe1dc00d0"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDMyMjI3OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/frontend/src/store/modules/addClient.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMDoyNjowNFrOGk_pdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDoyMzo1N1rOGlIPjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0NDcyNQ==", "bodyText": "Making an async call inside anothers success-block creates what is called a callback hell. This also introduces an extra period of waiting as the latter call is created after the first has been successfully completed.\nWith Promise.all we can send multiple rest calls and wait for ALL of them have completed successfully. The code sample of how this is done is below. I didn't test it but it's at least nearly there...\n// Fetch list of local clients and filter out global clients\n    // that have local relatives\n    return Promise.all([globalClientsPromise, localClientsPromise])\n      .then( (response) => {\n        const globalClients = response[0];\n        const localClients = response[1];\n        commit('storeSelectableClients', excludeClientsWithLocalRelatives(globalClients.data, localClients.data));\n      })\n      .catch( error => {\n        throw error;\n      });", "url": "https://github.com/nordic-institute/X-Road/pull/558#discussion_r441444725", "createdAt": "2020-06-17T10:26:04Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/frontend/src/store/modules/addClient.ts", "diffHunk": "@@ -143,13 +161,21 @@ export const actions: ActionTree<AddClientState, RootState> = {\n     // Fetch clients from backend that can be selected\n     return api\n       .get(\n-        '/clients?exclude_local=true&member_missing_sign_cert=true&internal_search=false&show_members=false',\n+        '/clients?exclude_local=true&internal_search=false&show_members=false',\n       )\n-      .then((res) => {\n-        commit('storeSelectableClients', res.data);\n+      .then((globalClientsRes) => {\n+        // Fetch list of local clients and filter out global clients\n+        // that have local relatives\n+        api.get('/clients').then((localClientsRes) => {\n+            commit('storeSelectableClients',\n+            excludeClientsWithLocalRelatives(globalClientsRes.data, localClientsRes.data));\n+          })\n+          .catch((localClientsError) => {\n+            throw localClientsError;\n+          });\n       })\n-      .catch((error) => {\n-        throw error;\n+      .catch((globalClientsError) => {\n+        throw globalClientsError;\n       });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b30304c30e5e0ede95f97d6f191dc13fe1dc00d0"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU4NTU1MQ==", "bodyText": "Thanks for the suggestion! I updated the implementation accordingly. It worked almost directly - just to had to define globalClientsPromise and localClientsPromise.", "url": "https://github.com/nordic-institute/X-Road/pull/558#discussion_r441585551", "createdAt": "2020-06-17T14:23:57Z", "author": {"login": "petkivim"}, "path": "src/proxy-ui-api/frontend/src/store/modules/addClient.ts", "diffHunk": "@@ -143,13 +161,21 @@ export const actions: ActionTree<AddClientState, RootState> = {\n     // Fetch clients from backend that can be selected\n     return api\n       .get(\n-        '/clients?exclude_local=true&member_missing_sign_cert=true&internal_search=false&show_members=false',\n+        '/clients?exclude_local=true&internal_search=false&show_members=false',\n       )\n-      .then((res) => {\n-        commit('storeSelectableClients', res.data);\n+      .then((globalClientsRes) => {\n+        // Fetch list of local clients and filter out global clients\n+        // that have local relatives\n+        api.get('/clients').then((localClientsRes) => {\n+            commit('storeSelectableClients',\n+            excludeClientsWithLocalRelatives(globalClientsRes.data, localClientsRes.data));\n+          })\n+          .catch((localClientsError) => {\n+            throw localClientsError;\n+          });\n       })\n-      .catch((error) => {\n-        throw error;\n+      .catch((globalClientsError) => {\n+        throw globalClientsError;\n       });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0NDcyNQ=="}, "originalCommit": {"oid": "b30304c30e5e0ede95f97d6f191dc13fe1dc00d0"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDM4NTY4OnYy", "diffSide": "RIGHT", "path": "src/proxy-ui-api/frontend/src/store/modules/addClient.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMDo0NjoxNVrOGlAR1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDoyNzo1OVrOGlIbsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1NTA2Mw==", "bodyText": "Although this code works correctly I think it could be optimized and made in more currently idiomatic javascript way by using array operation some (which is a for loop which will quit looping through if true is returned inside it. Also some will return a false or true value, false is true is not returned).\nHere's an example showing how I would try to make this to be easier to read:\n`\nconst memberEquals = (client: Client, other: Client): boolean =>\nclient.member_class === other.member_class &&\nclient.member_code === other.member_code &&\nclient.instance_id === other.instance_id;\n// Filters out clients that have local relatives.\n// If the member owning the client or another subsystem\n// of the same member is already present locally,\n// the client is excluded.\nconst excludeClientsWithLocalRelatives = (clients: Client[], localClients: Client[]): Client[] => {\nreturn clients.filter((client: Client) => {\nreturn !localClients.some( (localClient: Client) => memberEquals(localClient, client))\n});\n}\n`\nIf memberEquals (not sure if this is a good function name here) returns true then loop is short circuited and false (negated) is returned to the wrapping filter function.\nI didn't test whether this works by just replacing the existing implementation but it should.", "url": "https://github.com/nordic-institute/X-Road/pull/558#discussion_r441455063", "createdAt": "2020-06-17T10:46:15Z", "author": {"login": "TJaakkola"}, "path": "src/proxy-ui-api/frontend/src/store/modules/addClient.ts", "diffHunk": "@@ -134,6 +134,24 @@ export const mutations: MutationTree<AddClientState> = {\n   },\n };\n \n+// Filters out clients that have local relatives.\n+// If the member owning the client or another subsystem\n+// of the same member is already present locally,\n+// the client is excluded.\n+const excludeClientsWithLocalRelatives = (clients: Client[], localClients: Client[]): Client[] => {\n+  return clients.filter((client: Client) => {\n+    let showClient = true;\n+    localClients.forEach((localClient: Client) => {\n+      if (localClient.member_class === client.member_class &&\n+          localClient.member_code === client.member_code &&\n+          localClient.instance_id === client.instance_id) {\n+        showClient = false;\n+      }\n+    });\n+    return showClient;\n+  });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b30304c30e5e0ede95f97d6f191dc13fe1dc00d0"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU4ODY1Ng==", "bodyText": "Thanks for the suggestion. I updated the implementation accordingly.\nI think that memberEquals is a descriptive name for the function. However, I added some comments for clarification just in case.", "url": "https://github.com/nordic-institute/X-Road/pull/558#discussion_r441588656", "createdAt": "2020-06-17T14:27:59Z", "author": {"login": "petkivim"}, "path": "src/proxy-ui-api/frontend/src/store/modules/addClient.ts", "diffHunk": "@@ -134,6 +134,24 @@ export const mutations: MutationTree<AddClientState> = {\n   },\n };\n \n+// Filters out clients that have local relatives.\n+// If the member owning the client or another subsystem\n+// of the same member is already present locally,\n+// the client is excluded.\n+const excludeClientsWithLocalRelatives = (clients: Client[], localClients: Client[]): Client[] => {\n+  return clients.filter((client: Client) => {\n+    let showClient = true;\n+    localClients.forEach((localClient: Client) => {\n+      if (localClient.member_class === client.member_class &&\n+          localClient.member_code === client.member_code &&\n+          localClient.instance_id === client.instance_id) {\n+        showClient = false;\n+      }\n+    });\n+    return showClient;\n+  });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1NTA2Mw=="}, "originalCommit": {"oid": "b30304c30e5e0ede95f97d6f191dc13fe1dc00d0"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2733, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}