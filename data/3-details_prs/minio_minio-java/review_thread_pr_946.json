{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5Mzg2Mzc3", "number": 946, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMzo1Mzo0NlrOD9Z4bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDowNTowN1rOD9aMBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzEzNzcyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/ListObjectsArgs.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMzo1Mzo0NlrOGW4Nxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTo1NjozMVrOGXY5YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY0Mjg4Nw==", "bodyText": "startAfter is used in ListObjectsV2 and marker is used in ListObjectV1, but both serve same functionality. We can remove one argument.", "url": "https://github.com/minio/minio-java/pull/946#discussion_r426642887", "createdAt": "2020-05-18T13:53:46Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/ListObjectsArgs.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.minio;\n+\n+/** Argument class of @see #listObjects(ListObjectsArgs args). */\n+public class ListObjectsArgs extends BucketArgs {\n+  private String continuationToken;\n+  private String delimiter;\n+  private boolean fetchOwner;\n+  private Integer maxKeys;\n+  private String prefix;\n+  private String startAfter;\n+  private boolean includeUserMetadata;\n+  private String marker;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "365c8e88134965876e63f4a3393206faec356712"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3ODMzNw==", "bodyText": "Thanks, will change to start using startAfter in both places.", "url": "https://github.com/minio/minio-java/pull/946#discussion_r427178337", "createdAt": "2020-05-19T09:56:31Z", "author": {"login": "anjalshireesh"}, "path": "api/src/main/java/io/minio/ListObjectsArgs.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.minio;\n+\n+/** Argument class of @see #listObjects(ListObjectsArgs args). */\n+public class ListObjectsArgs extends BucketArgs {\n+  private String continuationToken;\n+  private String delimiter;\n+  private boolean fetchOwner;\n+  private Integer maxKeys;\n+  private String prefix;\n+  private String startAfter;\n+  private boolean includeUserMetadata;\n+  private String marker;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY0Mjg4Nw=="}, "originalCommit": {"oid": "365c8e88134965876e63f4a3393206faec356712"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzE1Njk0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/MinioClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMzo1ODowMVrOGW4aOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDowNzo1NlrOGXZUQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY0NjA3NA==", "bodyText": "As we follow google-style, we could use like the way in the code.", "url": "https://github.com/minio/minio-java/pull/946#discussion_r426646074", "createdAt": "2020-05-18T13:58:01Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2872,293 +2877,250 @@ public void remove() {\n    * @see #listObjects(String bucketName)\n    * @see #listObjects(String bucketName, String prefix)\n    * @see #listObjects(String bucketName, String prefix, boolean recursive)\n+   * @deprecated use {@link #listObjects(ListObjectsArgs)}\n    */\n   public Iterable<Result<Item>> listObjects(\n       final String bucketName,\n       final String prefix,\n       final boolean recursive,\n       final boolean includeUserMetadata,\n       final boolean useVersion1) {\n-    if (useVersion1) {\n-      if (includeUserMetadata) {\n+    return listObjects(\n+        ListObjectsArgs.builder()\n+            .bucket(bucketName)\n+            .prefix(prefix)\n+            .recursive(recursive)\n+            .includeUserMetadata(includeUserMetadata)\n+            .build());\n+  }\n+\n+  /**\n+   * Lists objects information of a bucket. Supports both the versions 1 and 2 of the S3 API. By\n+   * default, the <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html\">\n+   * version 2</a> API is used. <br>\n+   * <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html\">version 1</a>\n+   * can be used by passing the optional argument `useVersion1` as `true`.\n+   *\n+   * <pre>Example:{@code\n+   * Iterable<Result<Item>> results = minioClient.listObjects(\n+   *   ListObjectsArgs.builder().\n+   *   bucket(\"my-bucketname\").\n+   *   includeUserMetadata(true).\n+   *   startAfter(\"start-after-entry\").\n+   *   prefix(\"my-obj\").\n+   *   maxKeys(100).\n+   *   fetchOwner(true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "365c8e88134965876e63f4a3393206faec356712"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4NTIxOA==", "bodyText": "Will change as suggested", "url": "https://github.com/minio/minio-java/pull/946#discussion_r427185218", "createdAt": "2020-05-19T10:07:56Z", "author": {"login": "anjalshireesh"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2872,293 +2877,250 @@ public void remove() {\n    * @see #listObjects(String bucketName)\n    * @see #listObjects(String bucketName, String prefix)\n    * @see #listObjects(String bucketName, String prefix, boolean recursive)\n+   * @deprecated use {@link #listObjects(ListObjectsArgs)}\n    */\n   public Iterable<Result<Item>> listObjects(\n       final String bucketName,\n       final String prefix,\n       final boolean recursive,\n       final boolean includeUserMetadata,\n       final boolean useVersion1) {\n-    if (useVersion1) {\n-      if (includeUserMetadata) {\n+    return listObjects(\n+        ListObjectsArgs.builder()\n+            .bucket(bucketName)\n+            .prefix(prefix)\n+            .recursive(recursive)\n+            .includeUserMetadata(includeUserMetadata)\n+            .build());\n+  }\n+\n+  /**\n+   * Lists objects information of a bucket. Supports both the versions 1 and 2 of the S3 API. By\n+   * default, the <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html\">\n+   * version 2</a> API is used. <br>\n+   * <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html\">version 1</a>\n+   * can be used by passing the optional argument `useVersion1` as `true`.\n+   *\n+   * <pre>Example:{@code\n+   * Iterable<Result<Item>> results = minioClient.listObjects(\n+   *   ListObjectsArgs.builder().\n+   *   bucket(\"my-bucketname\").\n+   *   includeUserMetadata(true).\n+   *   startAfter(\"start-after-entry\").\n+   *   prefix(\"my-obj\").\n+   *   maxKeys(100).\n+   *   fetchOwner(true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY0NjA3NA=="}, "originalCommit": {"oid": "365c8e88134965876e63f4a3393206faec356712"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzE4NDE2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/MinioClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDowNDoxOFrOGW4rbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoyNzozOVrOGXZ_jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1MDQ3OQ==", "bodyText": "We need use delimiter from args.delimiter() if it is null and we can default to /", "url": "https://github.com/minio/minio-java/pull/946#discussion_r426650479", "createdAt": "2020-05-18T14:04:18Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2872,293 +2877,250 @@ public void remove() {\n    * @see #listObjects(String bucketName)\n    * @see #listObjects(String bucketName, String prefix)\n    * @see #listObjects(String bucketName, String prefix, boolean recursive)\n+   * @deprecated use {@link #listObjects(ListObjectsArgs)}\n    */\n   public Iterable<Result<Item>> listObjects(\n       final String bucketName,\n       final String prefix,\n       final boolean recursive,\n       final boolean includeUserMetadata,\n       final boolean useVersion1) {\n-    if (useVersion1) {\n-      if (includeUserMetadata) {\n+    return listObjects(\n+        ListObjectsArgs.builder()\n+            .bucket(bucketName)\n+            .prefix(prefix)\n+            .recursive(recursive)\n+            .includeUserMetadata(includeUserMetadata)\n+            .build());\n+  }\n+\n+  /**\n+   * Lists objects information of a bucket. Supports both the versions 1 and 2 of the S3 API. By\n+   * default, the <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html\">\n+   * version 2</a> API is used. <br>\n+   * <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html\">version 1</a>\n+   * can be used by passing the optional argument `useVersion1` as `true`.\n+   *\n+   * <pre>Example:{@code\n+   * Iterable<Result<Item>> results = minioClient.listObjects(\n+   *   ListObjectsArgs.builder().\n+   *   bucket(\"my-bucketname\").\n+   *   includeUserMetadata(true).\n+   *   startAfter(\"start-after-entry\").\n+   *   prefix(\"my-obj\").\n+   *   maxKeys(100).\n+   *   fetchOwner(true)\n+   * );\n+   * for (Result<Item> result : results) {\n+   *   Item item = result.get();\n+   *   System.out.println(\n+   *       item.lastModified() + \", \" + item.size() + \", \" + item.objectName());\n+   * }\n+   * }</pre>\n+   *\n+   * @param args Instance of {@link ListObjectsArgs} built using the builder\n+   * @return Iterable&ltResult&ltItem&gt&gt - Lazy iterator contains object information.\n+   * @throws XmlParserException upon parsing response xml\n+   */\n+  public Iterable<Result<Item>> listObjects(ListObjectsArgs args) {\n+    if (args.useVersion1()) {\n+      if (args.includeUserMetadata()) {\n         throw new IllegalArgumentException(\n             \"include user metadata flag is not supported in version 1\");\n       }\n-\n-      return listObjectsV1(bucketName, prefix, recursive);\n+      return listObjectsV1(args);\n+    } else {\n+      return listObjectsV2(args);\n     }\n-\n-    return listObjectsV2(bucketName, prefix, recursive, includeUserMetadata);\n   }\n \n-  private Iterable<Result<Item>> listObjectsV2(\n-      final String bucketName,\n-      final String prefix,\n-      final boolean recursive,\n-      final boolean includeUserMetadata) {\n-    return new Iterable<Result<Item>>() {\n-      @Override\n-      public Iterator<Result<Item>> iterator() {\n-        return new Iterator<Result<Item>>() {\n-          private ListBucketResult listBucketResult;\n-          private Result<Item> error;\n-          private Iterator<Item> itemIterator;\n-          private Iterator<Prefix> prefixIterator;\n-          private boolean completed = false;\n+  private abstract class ObjectIterator implements Iterator<Result<Item>> {\n+    protected Result<Item> error;\n+    protected Iterator<Item> itemIterator;\n+    protected Iterator<Prefix> prefixIterator;\n+    protected boolean completed = false;\n+    protected ListBucketResult listBucketResult;\n+    protected String lastObjectName;\n \n-          private synchronized void populate() {\n-            String delimiter = \"/\";\n-            if (recursive) {\n-              delimiter = null;\n-            }\n+    protected abstract void populateResult()\n+        throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+            NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+            ErrorResponseException, InternalException, InvalidResponseException, IOException;\n \n-            String continuationToken = null;\n-            if (this.listBucketResult != null) {\n-              continuationToken = listBucketResult.nextContinuationToken();\n-            }\n+    protected synchronized void populate() {\n+      try {\n+        populateResult();\n+      } catch (ErrorResponseException\n+          | IllegalArgumentException\n+          | InsufficientDataException\n+          | InternalException\n+          | InvalidBucketNameException\n+          | InvalidKeyException\n+          | InvalidResponseException\n+          | IOException\n+          | NoSuchAlgorithmException\n+          | XmlParserException e) {\n+        this.error = new Result<>(e);\n+      } finally {\n+        if (this.listBucketResult != null) {\n+          this.itemIterator = this.listBucketResult.contents().iterator();\n+          this.prefixIterator = this.listBucketResult.commonPrefixes().iterator();\n+        } else {\n+          this.itemIterator = new LinkedList<Item>().iterator();\n+          this.prefixIterator = new LinkedList<Prefix>().iterator();\n+        }\n+      }\n+    }\n \n-            this.listBucketResult = null;\n-            this.itemIterator = null;\n-            this.prefixIterator = null;\n+    @Override\n+    public boolean hasNext() {\n+      if (this.completed) {\n+        return false;\n+      }\n \n-            try {\n-              this.listBucketResult =\n-                  listObjectsV2(\n-                      bucketName,\n-                      continuationToken,\n-                      delimiter,\n-                      false,\n-                      null,\n-                      prefix,\n-                      null,\n-                      includeUserMetadata);\n-            } catch (ErrorResponseException\n-                | IllegalArgumentException\n-                | InsufficientDataException\n-                | InternalException\n-                | InvalidBucketNameException\n-                | InvalidKeyException\n-                | InvalidResponseException\n-                | IOException\n-                | NoSuchAlgorithmException\n-                | XmlParserException e) {\n-              this.error = new Result<>(e);\n-            } finally {\n-              if (this.listBucketResult != null) {\n-                this.itemIterator = this.listBucketResult.contents().iterator();\n-                this.prefixIterator = this.listBucketResult.commonPrefixes().iterator();\n-              } else {\n-                this.itemIterator = new LinkedList<Item>().iterator();\n-                this.prefixIterator = new LinkedList<Prefix>().iterator();\n-              }\n-            }\n-          }\n+      if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n+        populate();\n+      }\n \n-          @Override\n-          public boolean hasNext() {\n-            if (this.completed) {\n-              return false;\n-            }\n+      if (this.error == null\n+          && !this.itemIterator.hasNext()\n+          && !this.prefixIterator.hasNext()\n+          && this.listBucketResult.isTruncated()) {\n+        populate();\n+      }\n \n-            if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n-              populate();\n-            }\n+      if (this.error != null) {\n+        return true;\n+      }\n \n-            if (this.error == null\n-                && !this.itemIterator.hasNext()\n-                && !this.prefixIterator.hasNext()\n-                && this.listBucketResult.isTruncated()) {\n-              populate();\n-            }\n+      if (this.itemIterator.hasNext()) {\n+        return true;\n+      }\n \n-            if (this.error != null) {\n-              return true;\n-            }\n+      if (this.prefixIterator.hasNext()) {\n+        return true;\n+      }\n \n-            if (this.itemIterator.hasNext()) {\n-              return true;\n-            }\n+      this.completed = true;\n+      return false;\n+    }\n \n-            if (this.prefixIterator.hasNext()) {\n-              return true;\n-            }\n+    @Override\n+    public Result<Item> next() {\n+      if (this.completed) {\n+        throw new NoSuchElementException();\n+      }\n \n-            this.completed = true;\n-            return false;\n-          }\n+      if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n+        populate();\n+      }\n \n-          @Override\n-          public Result<Item> next() {\n-            if (this.completed) {\n-              throw new NoSuchElementException();\n-            }\n+      if (this.error == null\n+          && !this.itemIterator.hasNext()\n+          && !this.prefixIterator.hasNext()\n+          && this.listBucketResult.isTruncated()) {\n+        populate();\n+      }\n \n-            if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n-              populate();\n-            }\n+      if (this.error != null) {\n+        this.completed = true;\n+        return this.error;\n+      }\n \n-            if (this.error == null\n-                && !this.itemIterator.hasNext()\n-                && !this.prefixIterator.hasNext()\n-                && this.listBucketResult.isTruncated()) {\n-              populate();\n-            }\n+      if (this.itemIterator.hasNext()) {\n+        Item item = this.itemIterator.next();\n+        this.lastObjectName = item.objectName();\n+        return new Result<>(item);\n+      }\n+      if (this.prefixIterator.hasNext()) {\n+        return new Result<>(this.prefixIterator.next().toItem());\n+      }\n \n-            if (this.error != null) {\n-              this.completed = true;\n-              return this.error;\n-            }\n+      this.completed = true;\n+      throw new NoSuchElementException();\n+    }\n \n-            if (this.itemIterator.hasNext()) {\n-              Item item = this.itemIterator.next();\n-              return new Result<>(item);\n+    @Override\n+    public void remove() {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  private Iterable<Result<Item>> listObjectsV2(ListObjectsArgs args) {\n+    return new Iterable<Result<Item>>() {\n+      @Override\n+      public Iterator<Result<Item>> iterator() {\n+        return new ObjectIterator() {\n+          protected void populateResult()\n+              throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+                  NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+                  ErrorResponseException, InternalException, InvalidResponseException, IOException {\n+            String delimiter = \"/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "365c8e88134965876e63f4a3393206faec356712"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5NjMwMg==", "bodyText": "I had kept the code as is and just refactored to reduce duplication. However, your suggestion seems like an improvement over the existing code - so I will change the code accordingly.", "url": "https://github.com/minio/minio-java/pull/946#discussion_r427196302", "createdAt": "2020-05-19T10:27:39Z", "author": {"login": "anjalshireesh"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2872,293 +2877,250 @@ public void remove() {\n    * @see #listObjects(String bucketName)\n    * @see #listObjects(String bucketName, String prefix)\n    * @see #listObjects(String bucketName, String prefix, boolean recursive)\n+   * @deprecated use {@link #listObjects(ListObjectsArgs)}\n    */\n   public Iterable<Result<Item>> listObjects(\n       final String bucketName,\n       final String prefix,\n       final boolean recursive,\n       final boolean includeUserMetadata,\n       final boolean useVersion1) {\n-    if (useVersion1) {\n-      if (includeUserMetadata) {\n+    return listObjects(\n+        ListObjectsArgs.builder()\n+            .bucket(bucketName)\n+            .prefix(prefix)\n+            .recursive(recursive)\n+            .includeUserMetadata(includeUserMetadata)\n+            .build());\n+  }\n+\n+  /**\n+   * Lists objects information of a bucket. Supports both the versions 1 and 2 of the S3 API. By\n+   * default, the <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html\">\n+   * version 2</a> API is used. <br>\n+   * <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html\">version 1</a>\n+   * can be used by passing the optional argument `useVersion1` as `true`.\n+   *\n+   * <pre>Example:{@code\n+   * Iterable<Result<Item>> results = minioClient.listObjects(\n+   *   ListObjectsArgs.builder().\n+   *   bucket(\"my-bucketname\").\n+   *   includeUserMetadata(true).\n+   *   startAfter(\"start-after-entry\").\n+   *   prefix(\"my-obj\").\n+   *   maxKeys(100).\n+   *   fetchOwner(true)\n+   * );\n+   * for (Result<Item> result : results) {\n+   *   Item item = result.get();\n+   *   System.out.println(\n+   *       item.lastModified() + \", \" + item.size() + \", \" + item.objectName());\n+   * }\n+   * }</pre>\n+   *\n+   * @param args Instance of {@link ListObjectsArgs} built using the builder\n+   * @return Iterable&ltResult&ltItem&gt&gt - Lazy iterator contains object information.\n+   * @throws XmlParserException upon parsing response xml\n+   */\n+  public Iterable<Result<Item>> listObjects(ListObjectsArgs args) {\n+    if (args.useVersion1()) {\n+      if (args.includeUserMetadata()) {\n         throw new IllegalArgumentException(\n             \"include user metadata flag is not supported in version 1\");\n       }\n-\n-      return listObjectsV1(bucketName, prefix, recursive);\n+      return listObjectsV1(args);\n+    } else {\n+      return listObjectsV2(args);\n     }\n-\n-    return listObjectsV2(bucketName, prefix, recursive, includeUserMetadata);\n   }\n \n-  private Iterable<Result<Item>> listObjectsV2(\n-      final String bucketName,\n-      final String prefix,\n-      final boolean recursive,\n-      final boolean includeUserMetadata) {\n-    return new Iterable<Result<Item>>() {\n-      @Override\n-      public Iterator<Result<Item>> iterator() {\n-        return new Iterator<Result<Item>>() {\n-          private ListBucketResult listBucketResult;\n-          private Result<Item> error;\n-          private Iterator<Item> itemIterator;\n-          private Iterator<Prefix> prefixIterator;\n-          private boolean completed = false;\n+  private abstract class ObjectIterator implements Iterator<Result<Item>> {\n+    protected Result<Item> error;\n+    protected Iterator<Item> itemIterator;\n+    protected Iterator<Prefix> prefixIterator;\n+    protected boolean completed = false;\n+    protected ListBucketResult listBucketResult;\n+    protected String lastObjectName;\n \n-          private synchronized void populate() {\n-            String delimiter = \"/\";\n-            if (recursive) {\n-              delimiter = null;\n-            }\n+    protected abstract void populateResult()\n+        throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+            NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+            ErrorResponseException, InternalException, InvalidResponseException, IOException;\n \n-            String continuationToken = null;\n-            if (this.listBucketResult != null) {\n-              continuationToken = listBucketResult.nextContinuationToken();\n-            }\n+    protected synchronized void populate() {\n+      try {\n+        populateResult();\n+      } catch (ErrorResponseException\n+          | IllegalArgumentException\n+          | InsufficientDataException\n+          | InternalException\n+          | InvalidBucketNameException\n+          | InvalidKeyException\n+          | InvalidResponseException\n+          | IOException\n+          | NoSuchAlgorithmException\n+          | XmlParserException e) {\n+        this.error = new Result<>(e);\n+      } finally {\n+        if (this.listBucketResult != null) {\n+          this.itemIterator = this.listBucketResult.contents().iterator();\n+          this.prefixIterator = this.listBucketResult.commonPrefixes().iterator();\n+        } else {\n+          this.itemIterator = new LinkedList<Item>().iterator();\n+          this.prefixIterator = new LinkedList<Prefix>().iterator();\n+        }\n+      }\n+    }\n \n-            this.listBucketResult = null;\n-            this.itemIterator = null;\n-            this.prefixIterator = null;\n+    @Override\n+    public boolean hasNext() {\n+      if (this.completed) {\n+        return false;\n+      }\n \n-            try {\n-              this.listBucketResult =\n-                  listObjectsV2(\n-                      bucketName,\n-                      continuationToken,\n-                      delimiter,\n-                      false,\n-                      null,\n-                      prefix,\n-                      null,\n-                      includeUserMetadata);\n-            } catch (ErrorResponseException\n-                | IllegalArgumentException\n-                | InsufficientDataException\n-                | InternalException\n-                | InvalidBucketNameException\n-                | InvalidKeyException\n-                | InvalidResponseException\n-                | IOException\n-                | NoSuchAlgorithmException\n-                | XmlParserException e) {\n-              this.error = new Result<>(e);\n-            } finally {\n-              if (this.listBucketResult != null) {\n-                this.itemIterator = this.listBucketResult.contents().iterator();\n-                this.prefixIterator = this.listBucketResult.commonPrefixes().iterator();\n-              } else {\n-                this.itemIterator = new LinkedList<Item>().iterator();\n-                this.prefixIterator = new LinkedList<Prefix>().iterator();\n-              }\n-            }\n-          }\n+      if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n+        populate();\n+      }\n \n-          @Override\n-          public boolean hasNext() {\n-            if (this.completed) {\n-              return false;\n-            }\n+      if (this.error == null\n+          && !this.itemIterator.hasNext()\n+          && !this.prefixIterator.hasNext()\n+          && this.listBucketResult.isTruncated()) {\n+        populate();\n+      }\n \n-            if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n-              populate();\n-            }\n+      if (this.error != null) {\n+        return true;\n+      }\n \n-            if (this.error == null\n-                && !this.itemIterator.hasNext()\n-                && !this.prefixIterator.hasNext()\n-                && this.listBucketResult.isTruncated()) {\n-              populate();\n-            }\n+      if (this.itemIterator.hasNext()) {\n+        return true;\n+      }\n \n-            if (this.error != null) {\n-              return true;\n-            }\n+      if (this.prefixIterator.hasNext()) {\n+        return true;\n+      }\n \n-            if (this.itemIterator.hasNext()) {\n-              return true;\n-            }\n+      this.completed = true;\n+      return false;\n+    }\n \n-            if (this.prefixIterator.hasNext()) {\n-              return true;\n-            }\n+    @Override\n+    public Result<Item> next() {\n+      if (this.completed) {\n+        throw new NoSuchElementException();\n+      }\n \n-            this.completed = true;\n-            return false;\n-          }\n+      if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n+        populate();\n+      }\n \n-          @Override\n-          public Result<Item> next() {\n-            if (this.completed) {\n-              throw new NoSuchElementException();\n-            }\n+      if (this.error == null\n+          && !this.itemIterator.hasNext()\n+          && !this.prefixIterator.hasNext()\n+          && this.listBucketResult.isTruncated()) {\n+        populate();\n+      }\n \n-            if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n-              populate();\n-            }\n+      if (this.error != null) {\n+        this.completed = true;\n+        return this.error;\n+      }\n \n-            if (this.error == null\n-                && !this.itemIterator.hasNext()\n-                && !this.prefixIterator.hasNext()\n-                && this.listBucketResult.isTruncated()) {\n-              populate();\n-            }\n+      if (this.itemIterator.hasNext()) {\n+        Item item = this.itemIterator.next();\n+        this.lastObjectName = item.objectName();\n+        return new Result<>(item);\n+      }\n+      if (this.prefixIterator.hasNext()) {\n+        return new Result<>(this.prefixIterator.next().toItem());\n+      }\n \n-            if (this.error != null) {\n-              this.completed = true;\n-              return this.error;\n-            }\n+      this.completed = true;\n+      throw new NoSuchElementException();\n+    }\n \n-            if (this.itemIterator.hasNext()) {\n-              Item item = this.itemIterator.next();\n-              return new Result<>(item);\n+    @Override\n+    public void remove() {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  private Iterable<Result<Item>> listObjectsV2(ListObjectsArgs args) {\n+    return new Iterable<Result<Item>>() {\n+      @Override\n+      public Iterator<Result<Item>> iterator() {\n+        return new ObjectIterator() {\n+          protected void populateResult()\n+              throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+                  NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+                  ErrorResponseException, InternalException, InvalidResponseException, IOException {\n+            String delimiter = \"/\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1MDQ3OQ=="}, "originalCommit": {"oid": "365c8e88134965876e63f4a3393206faec356712"}, "originalPosition": 342}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzE4NzkxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/MinioClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDowNTowN1rOGW4trQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDo0ODo1MlrOGXaraw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1MTA1Mw==", "bodyText": "same as above", "url": "https://github.com/minio/minio-java/pull/946#discussion_r426651053", "createdAt": "2020-05-18T14:05:07Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2872,293 +2877,250 @@ public void remove() {\n    * @see #listObjects(String bucketName)\n    * @see #listObjects(String bucketName, String prefix)\n    * @see #listObjects(String bucketName, String prefix, boolean recursive)\n+   * @deprecated use {@link #listObjects(ListObjectsArgs)}\n    */\n   public Iterable<Result<Item>> listObjects(\n       final String bucketName,\n       final String prefix,\n       final boolean recursive,\n       final boolean includeUserMetadata,\n       final boolean useVersion1) {\n-    if (useVersion1) {\n-      if (includeUserMetadata) {\n+    return listObjects(\n+        ListObjectsArgs.builder()\n+            .bucket(bucketName)\n+            .prefix(prefix)\n+            .recursive(recursive)\n+            .includeUserMetadata(includeUserMetadata)\n+            .build());\n+  }\n+\n+  /**\n+   * Lists objects information of a bucket. Supports both the versions 1 and 2 of the S3 API. By\n+   * default, the <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html\">\n+   * version 2</a> API is used. <br>\n+   * <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html\">version 1</a>\n+   * can be used by passing the optional argument `useVersion1` as `true`.\n+   *\n+   * <pre>Example:{@code\n+   * Iterable<Result<Item>> results = minioClient.listObjects(\n+   *   ListObjectsArgs.builder().\n+   *   bucket(\"my-bucketname\").\n+   *   includeUserMetadata(true).\n+   *   startAfter(\"start-after-entry\").\n+   *   prefix(\"my-obj\").\n+   *   maxKeys(100).\n+   *   fetchOwner(true)\n+   * );\n+   * for (Result<Item> result : results) {\n+   *   Item item = result.get();\n+   *   System.out.println(\n+   *       item.lastModified() + \", \" + item.size() + \", \" + item.objectName());\n+   * }\n+   * }</pre>\n+   *\n+   * @param args Instance of {@link ListObjectsArgs} built using the builder\n+   * @return Iterable&ltResult&ltItem&gt&gt - Lazy iterator contains object information.\n+   * @throws XmlParserException upon parsing response xml\n+   */\n+  public Iterable<Result<Item>> listObjects(ListObjectsArgs args) {\n+    if (args.useVersion1()) {\n+      if (args.includeUserMetadata()) {\n         throw new IllegalArgumentException(\n             \"include user metadata flag is not supported in version 1\");\n       }\n-\n-      return listObjectsV1(bucketName, prefix, recursive);\n+      return listObjectsV1(args);\n+    } else {\n+      return listObjectsV2(args);\n     }\n-\n-    return listObjectsV2(bucketName, prefix, recursive, includeUserMetadata);\n   }\n \n-  private Iterable<Result<Item>> listObjectsV2(\n-      final String bucketName,\n-      final String prefix,\n-      final boolean recursive,\n-      final boolean includeUserMetadata) {\n-    return new Iterable<Result<Item>>() {\n-      @Override\n-      public Iterator<Result<Item>> iterator() {\n-        return new Iterator<Result<Item>>() {\n-          private ListBucketResult listBucketResult;\n-          private Result<Item> error;\n-          private Iterator<Item> itemIterator;\n-          private Iterator<Prefix> prefixIterator;\n-          private boolean completed = false;\n+  private abstract class ObjectIterator implements Iterator<Result<Item>> {\n+    protected Result<Item> error;\n+    protected Iterator<Item> itemIterator;\n+    protected Iterator<Prefix> prefixIterator;\n+    protected boolean completed = false;\n+    protected ListBucketResult listBucketResult;\n+    protected String lastObjectName;\n \n-          private synchronized void populate() {\n-            String delimiter = \"/\";\n-            if (recursive) {\n-              delimiter = null;\n-            }\n+    protected abstract void populateResult()\n+        throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+            NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+            ErrorResponseException, InternalException, InvalidResponseException, IOException;\n \n-            String continuationToken = null;\n-            if (this.listBucketResult != null) {\n-              continuationToken = listBucketResult.nextContinuationToken();\n-            }\n+    protected synchronized void populate() {\n+      try {\n+        populateResult();\n+      } catch (ErrorResponseException\n+          | IllegalArgumentException\n+          | InsufficientDataException\n+          | InternalException\n+          | InvalidBucketNameException\n+          | InvalidKeyException\n+          | InvalidResponseException\n+          | IOException\n+          | NoSuchAlgorithmException\n+          | XmlParserException e) {\n+        this.error = new Result<>(e);\n+      } finally {\n+        if (this.listBucketResult != null) {\n+          this.itemIterator = this.listBucketResult.contents().iterator();\n+          this.prefixIterator = this.listBucketResult.commonPrefixes().iterator();\n+        } else {\n+          this.itemIterator = new LinkedList<Item>().iterator();\n+          this.prefixIterator = new LinkedList<Prefix>().iterator();\n+        }\n+      }\n+    }\n \n-            this.listBucketResult = null;\n-            this.itemIterator = null;\n-            this.prefixIterator = null;\n+    @Override\n+    public boolean hasNext() {\n+      if (this.completed) {\n+        return false;\n+      }\n \n-            try {\n-              this.listBucketResult =\n-                  listObjectsV2(\n-                      bucketName,\n-                      continuationToken,\n-                      delimiter,\n-                      false,\n-                      null,\n-                      prefix,\n-                      null,\n-                      includeUserMetadata);\n-            } catch (ErrorResponseException\n-                | IllegalArgumentException\n-                | InsufficientDataException\n-                | InternalException\n-                | InvalidBucketNameException\n-                | InvalidKeyException\n-                | InvalidResponseException\n-                | IOException\n-                | NoSuchAlgorithmException\n-                | XmlParserException e) {\n-              this.error = new Result<>(e);\n-            } finally {\n-              if (this.listBucketResult != null) {\n-                this.itemIterator = this.listBucketResult.contents().iterator();\n-                this.prefixIterator = this.listBucketResult.commonPrefixes().iterator();\n-              } else {\n-                this.itemIterator = new LinkedList<Item>().iterator();\n-                this.prefixIterator = new LinkedList<Prefix>().iterator();\n-              }\n-            }\n-          }\n+      if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n+        populate();\n+      }\n \n-          @Override\n-          public boolean hasNext() {\n-            if (this.completed) {\n-              return false;\n-            }\n+      if (this.error == null\n+          && !this.itemIterator.hasNext()\n+          && !this.prefixIterator.hasNext()\n+          && this.listBucketResult.isTruncated()) {\n+        populate();\n+      }\n \n-            if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n-              populate();\n-            }\n+      if (this.error != null) {\n+        return true;\n+      }\n \n-            if (this.error == null\n-                && !this.itemIterator.hasNext()\n-                && !this.prefixIterator.hasNext()\n-                && this.listBucketResult.isTruncated()) {\n-              populate();\n-            }\n+      if (this.itemIterator.hasNext()) {\n+        return true;\n+      }\n \n-            if (this.error != null) {\n-              return true;\n-            }\n+      if (this.prefixIterator.hasNext()) {\n+        return true;\n+      }\n \n-            if (this.itemIterator.hasNext()) {\n-              return true;\n-            }\n+      this.completed = true;\n+      return false;\n+    }\n \n-            if (this.prefixIterator.hasNext()) {\n-              return true;\n-            }\n+    @Override\n+    public Result<Item> next() {\n+      if (this.completed) {\n+        throw new NoSuchElementException();\n+      }\n \n-            this.completed = true;\n-            return false;\n-          }\n+      if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n+        populate();\n+      }\n \n-          @Override\n-          public Result<Item> next() {\n-            if (this.completed) {\n-              throw new NoSuchElementException();\n-            }\n+      if (this.error == null\n+          && !this.itemIterator.hasNext()\n+          && !this.prefixIterator.hasNext()\n+          && this.listBucketResult.isTruncated()) {\n+        populate();\n+      }\n \n-            if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n-              populate();\n-            }\n+      if (this.error != null) {\n+        this.completed = true;\n+        return this.error;\n+      }\n \n-            if (this.error == null\n-                && !this.itemIterator.hasNext()\n-                && !this.prefixIterator.hasNext()\n-                && this.listBucketResult.isTruncated()) {\n-              populate();\n-            }\n+      if (this.itemIterator.hasNext()) {\n+        Item item = this.itemIterator.next();\n+        this.lastObjectName = item.objectName();\n+        return new Result<>(item);\n+      }\n+      if (this.prefixIterator.hasNext()) {\n+        return new Result<>(this.prefixIterator.next().toItem());\n+      }\n \n-            if (this.error != null) {\n-              this.completed = true;\n-              return this.error;\n-            }\n+      this.completed = true;\n+      throw new NoSuchElementException();\n+    }\n \n-            if (this.itemIterator.hasNext()) {\n-              Item item = this.itemIterator.next();\n-              return new Result<>(item);\n+    @Override\n+    public void remove() {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  private Iterable<Result<Item>> listObjectsV2(ListObjectsArgs args) {\n+    return new Iterable<Result<Item>>() {\n+      @Override\n+      public Iterator<Result<Item>> iterator() {\n+        return new ObjectIterator() {\n+          protected void populateResult()\n+              throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+                  NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+                  ErrorResponseException, InternalException, InvalidResponseException, IOException {\n+            String delimiter = \"/\";\n+            if (args.recursive()) {\n+              delimiter = null;\n             }\n \n-            if (this.prefixIterator.hasNext()) {\n-              return new Result<>(this.prefixIterator.next().toItem());\n+            String continuationToken = null;\n+            if (this.listBucketResult != null) {\n+              continuationToken = listBucketResult.nextContinuationToken();\n             }\n \n-            this.completed = true;\n-            throw new NoSuchElementException();\n-          }\n+            this.listBucketResult = null;\n+            this.itemIterator = null;\n+            this.prefixIterator = null;\n \n-          @Override\n-          public void remove() {\n-            throw new UnsupportedOperationException();\n+            this.listBucketResult =\n+                invokeListObjectsV2(\n+                    ListObjectsArgs.builder()\n+                        .bucket(args.bucketName())\n+                        .continuationToken(continuationToken)\n+                        .delimiter(delimiter)\n+                        .fetchOwner(args.fetchOwner())\n+                        .prefix(args.prefix())\n+                        .includeUserMetadata(args.includeUserMetadata())\n+                        .build());\n           }\n         };\n       }\n     };\n   }\n \n-  private Iterable<Result<Item>> listObjectsV1(\n-      final String bucketName, final String prefix, final boolean recursive) {\n+  private Iterable<Result<Item>> listObjectsV1(ListObjectsArgs args) {\n     return new Iterable<Result<Item>>() {\n       @Override\n       public Iterator<Result<Item>> iterator() {\n-        return new Iterator<Result<Item>>() {\n-          private String lastObjectName;\n-          private ListBucketResultV1 listBucketResult;\n-          private Result<Item> error;\n-          private Iterator<Item> itemIterator;\n-          private Iterator<Prefix> prefixIterator;\n-          private boolean completed = false;\n-\n-          private synchronized void populate() {\n+        return new ObjectIterator() {\n+          @Override\n+          protected void populateResult()\n+              throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+                  NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+                  ErrorResponseException, InternalException, InvalidResponseException, IOException {\n             String delimiter = \"/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "365c8e88134965876e63f4a3393206faec356712"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIwNzUzMQ==", "bodyText": "Will change as suggested", "url": "https://github.com/minio/minio-java/pull/946#discussion_r427207531", "createdAt": "2020-05-19T10:48:52Z", "author": {"login": "anjalshireesh"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2872,293 +2877,250 @@ public void remove() {\n    * @see #listObjects(String bucketName)\n    * @see #listObjects(String bucketName, String prefix)\n    * @see #listObjects(String bucketName, String prefix, boolean recursive)\n+   * @deprecated use {@link #listObjects(ListObjectsArgs)}\n    */\n   public Iterable<Result<Item>> listObjects(\n       final String bucketName,\n       final String prefix,\n       final boolean recursive,\n       final boolean includeUserMetadata,\n       final boolean useVersion1) {\n-    if (useVersion1) {\n-      if (includeUserMetadata) {\n+    return listObjects(\n+        ListObjectsArgs.builder()\n+            .bucket(bucketName)\n+            .prefix(prefix)\n+            .recursive(recursive)\n+            .includeUserMetadata(includeUserMetadata)\n+            .build());\n+  }\n+\n+  /**\n+   * Lists objects information of a bucket. Supports both the versions 1 and 2 of the S3 API. By\n+   * default, the <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html\">\n+   * version 2</a> API is used. <br>\n+   * <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html\">version 1</a>\n+   * can be used by passing the optional argument `useVersion1` as `true`.\n+   *\n+   * <pre>Example:{@code\n+   * Iterable<Result<Item>> results = minioClient.listObjects(\n+   *   ListObjectsArgs.builder().\n+   *   bucket(\"my-bucketname\").\n+   *   includeUserMetadata(true).\n+   *   startAfter(\"start-after-entry\").\n+   *   prefix(\"my-obj\").\n+   *   maxKeys(100).\n+   *   fetchOwner(true)\n+   * );\n+   * for (Result<Item> result : results) {\n+   *   Item item = result.get();\n+   *   System.out.println(\n+   *       item.lastModified() + \", \" + item.size() + \", \" + item.objectName());\n+   * }\n+   * }</pre>\n+   *\n+   * @param args Instance of {@link ListObjectsArgs} built using the builder\n+   * @return Iterable&ltResult&ltItem&gt&gt - Lazy iterator contains object information.\n+   * @throws XmlParserException upon parsing response xml\n+   */\n+  public Iterable<Result<Item>> listObjects(ListObjectsArgs args) {\n+    if (args.useVersion1()) {\n+      if (args.includeUserMetadata()) {\n         throw new IllegalArgumentException(\n             \"include user metadata flag is not supported in version 1\");\n       }\n-\n-      return listObjectsV1(bucketName, prefix, recursive);\n+      return listObjectsV1(args);\n+    } else {\n+      return listObjectsV2(args);\n     }\n-\n-    return listObjectsV2(bucketName, prefix, recursive, includeUserMetadata);\n   }\n \n-  private Iterable<Result<Item>> listObjectsV2(\n-      final String bucketName,\n-      final String prefix,\n-      final boolean recursive,\n-      final boolean includeUserMetadata) {\n-    return new Iterable<Result<Item>>() {\n-      @Override\n-      public Iterator<Result<Item>> iterator() {\n-        return new Iterator<Result<Item>>() {\n-          private ListBucketResult listBucketResult;\n-          private Result<Item> error;\n-          private Iterator<Item> itemIterator;\n-          private Iterator<Prefix> prefixIterator;\n-          private boolean completed = false;\n+  private abstract class ObjectIterator implements Iterator<Result<Item>> {\n+    protected Result<Item> error;\n+    protected Iterator<Item> itemIterator;\n+    protected Iterator<Prefix> prefixIterator;\n+    protected boolean completed = false;\n+    protected ListBucketResult listBucketResult;\n+    protected String lastObjectName;\n \n-          private synchronized void populate() {\n-            String delimiter = \"/\";\n-            if (recursive) {\n-              delimiter = null;\n-            }\n+    protected abstract void populateResult()\n+        throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+            NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+            ErrorResponseException, InternalException, InvalidResponseException, IOException;\n \n-            String continuationToken = null;\n-            if (this.listBucketResult != null) {\n-              continuationToken = listBucketResult.nextContinuationToken();\n-            }\n+    protected synchronized void populate() {\n+      try {\n+        populateResult();\n+      } catch (ErrorResponseException\n+          | IllegalArgumentException\n+          | InsufficientDataException\n+          | InternalException\n+          | InvalidBucketNameException\n+          | InvalidKeyException\n+          | InvalidResponseException\n+          | IOException\n+          | NoSuchAlgorithmException\n+          | XmlParserException e) {\n+        this.error = new Result<>(e);\n+      } finally {\n+        if (this.listBucketResult != null) {\n+          this.itemIterator = this.listBucketResult.contents().iterator();\n+          this.prefixIterator = this.listBucketResult.commonPrefixes().iterator();\n+        } else {\n+          this.itemIterator = new LinkedList<Item>().iterator();\n+          this.prefixIterator = new LinkedList<Prefix>().iterator();\n+        }\n+      }\n+    }\n \n-            this.listBucketResult = null;\n-            this.itemIterator = null;\n-            this.prefixIterator = null;\n+    @Override\n+    public boolean hasNext() {\n+      if (this.completed) {\n+        return false;\n+      }\n \n-            try {\n-              this.listBucketResult =\n-                  listObjectsV2(\n-                      bucketName,\n-                      continuationToken,\n-                      delimiter,\n-                      false,\n-                      null,\n-                      prefix,\n-                      null,\n-                      includeUserMetadata);\n-            } catch (ErrorResponseException\n-                | IllegalArgumentException\n-                | InsufficientDataException\n-                | InternalException\n-                | InvalidBucketNameException\n-                | InvalidKeyException\n-                | InvalidResponseException\n-                | IOException\n-                | NoSuchAlgorithmException\n-                | XmlParserException e) {\n-              this.error = new Result<>(e);\n-            } finally {\n-              if (this.listBucketResult != null) {\n-                this.itemIterator = this.listBucketResult.contents().iterator();\n-                this.prefixIterator = this.listBucketResult.commonPrefixes().iterator();\n-              } else {\n-                this.itemIterator = new LinkedList<Item>().iterator();\n-                this.prefixIterator = new LinkedList<Prefix>().iterator();\n-              }\n-            }\n-          }\n+      if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n+        populate();\n+      }\n \n-          @Override\n-          public boolean hasNext() {\n-            if (this.completed) {\n-              return false;\n-            }\n+      if (this.error == null\n+          && !this.itemIterator.hasNext()\n+          && !this.prefixIterator.hasNext()\n+          && this.listBucketResult.isTruncated()) {\n+        populate();\n+      }\n \n-            if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n-              populate();\n-            }\n+      if (this.error != null) {\n+        return true;\n+      }\n \n-            if (this.error == null\n-                && !this.itemIterator.hasNext()\n-                && !this.prefixIterator.hasNext()\n-                && this.listBucketResult.isTruncated()) {\n-              populate();\n-            }\n+      if (this.itemIterator.hasNext()) {\n+        return true;\n+      }\n \n-            if (this.error != null) {\n-              return true;\n-            }\n+      if (this.prefixIterator.hasNext()) {\n+        return true;\n+      }\n \n-            if (this.itemIterator.hasNext()) {\n-              return true;\n-            }\n+      this.completed = true;\n+      return false;\n+    }\n \n-            if (this.prefixIterator.hasNext()) {\n-              return true;\n-            }\n+    @Override\n+    public Result<Item> next() {\n+      if (this.completed) {\n+        throw new NoSuchElementException();\n+      }\n \n-            this.completed = true;\n-            return false;\n-          }\n+      if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n+        populate();\n+      }\n \n-          @Override\n-          public Result<Item> next() {\n-            if (this.completed) {\n-              throw new NoSuchElementException();\n-            }\n+      if (this.error == null\n+          && !this.itemIterator.hasNext()\n+          && !this.prefixIterator.hasNext()\n+          && this.listBucketResult.isTruncated()) {\n+        populate();\n+      }\n \n-            if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n-              populate();\n-            }\n+      if (this.error != null) {\n+        this.completed = true;\n+        return this.error;\n+      }\n \n-            if (this.error == null\n-                && !this.itemIterator.hasNext()\n-                && !this.prefixIterator.hasNext()\n-                && this.listBucketResult.isTruncated()) {\n-              populate();\n-            }\n+      if (this.itemIterator.hasNext()) {\n+        Item item = this.itemIterator.next();\n+        this.lastObjectName = item.objectName();\n+        return new Result<>(item);\n+      }\n+      if (this.prefixIterator.hasNext()) {\n+        return new Result<>(this.prefixIterator.next().toItem());\n+      }\n \n-            if (this.error != null) {\n-              this.completed = true;\n-              return this.error;\n-            }\n+      this.completed = true;\n+      throw new NoSuchElementException();\n+    }\n \n-            if (this.itemIterator.hasNext()) {\n-              Item item = this.itemIterator.next();\n-              return new Result<>(item);\n+    @Override\n+    public void remove() {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  private Iterable<Result<Item>> listObjectsV2(ListObjectsArgs args) {\n+    return new Iterable<Result<Item>>() {\n+      @Override\n+      public Iterator<Result<Item>> iterator() {\n+        return new ObjectIterator() {\n+          protected void populateResult()\n+              throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+                  NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+                  ErrorResponseException, InternalException, InvalidResponseException, IOException {\n+            String delimiter = \"/\";\n+            if (args.recursive()) {\n+              delimiter = null;\n             }\n \n-            if (this.prefixIterator.hasNext()) {\n-              return new Result<>(this.prefixIterator.next().toItem());\n+            String continuationToken = null;\n+            if (this.listBucketResult != null) {\n+              continuationToken = listBucketResult.nextContinuationToken();\n             }\n \n-            this.completed = true;\n-            throw new NoSuchElementException();\n-          }\n+            this.listBucketResult = null;\n+            this.itemIterator = null;\n+            this.prefixIterator = null;\n \n-          @Override\n-          public void remove() {\n-            throw new UnsupportedOperationException();\n+            this.listBucketResult =\n+                invokeListObjectsV2(\n+                    ListObjectsArgs.builder()\n+                        .bucket(args.bucketName())\n+                        .continuationToken(continuationToken)\n+                        .delimiter(delimiter)\n+                        .fetchOwner(args.fetchOwner())\n+                        .prefix(args.prefix())\n+                        .includeUserMetadata(args.includeUserMetadata())\n+                        .build());\n           }\n         };\n       }\n     };\n   }\n \n-  private Iterable<Result<Item>> listObjectsV1(\n-      final String bucketName, final String prefix, final boolean recursive) {\n+  private Iterable<Result<Item>> listObjectsV1(ListObjectsArgs args) {\n     return new Iterable<Result<Item>>() {\n       @Override\n       public Iterator<Result<Item>> iterator() {\n-        return new Iterator<Result<Item>>() {\n-          private String lastObjectName;\n-          private ListBucketResultV1 listBucketResult;\n-          private Result<Item> error;\n-          private Iterator<Item> itemIterator;\n-          private Iterator<Prefix> prefixIterator;\n-          private boolean completed = false;\n-\n-          private synchronized void populate() {\n+        return new ObjectIterator() {\n+          @Override\n+          protected void populateResult()\n+              throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+                  NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+                  ErrorResponseException, InternalException, InvalidResponseException, IOException {\n             String delimiter = \"/\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1MTA1Mw=="}, "originalCommit": {"oid": "365c8e88134965876e63f4a3393206faec356712"}, "originalPosition": 401}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 709, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}