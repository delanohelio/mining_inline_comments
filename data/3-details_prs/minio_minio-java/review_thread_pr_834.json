{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5NDMwNzkz", "number": 834, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwMTo1Njo0OVrODWImCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTowODowNFrODY6TAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTM2MDc0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/MinioClient.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwMTo1Njo0OVrOFauHsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxNzoxNjoxOFrOFbd8Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2MjkyOQ==", "bodyText": "My suggestion is to deprecate this style of API and introduce lazy eval'ed style like\npublic Iterable<Result<NotificationInfo>> listenBucketNotification(String bucketName, String prefix, String suffix, String[] events)\nIf we stick with current style, the fix is just while (continueListening || scanner.hasNext())", "url": "https://github.com/minio/minio-java/pull/834#discussion_r363562929", "createdAt": "2020-01-07T01:56:49Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5741,12 +5743,16 @@ public void listenBucketNotification(String bucketName, String prefix, String su\n       scanner = new Scanner(response.body().charStream());\n       scanner.useDelimiter(\"\\n\");\n       while (scanner.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f4146b1d1727af0f73a71183b0e0a227cdd6d30"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3NjgwNg==", "bodyText": "A more idiomatic Java style is preferred, so I think lazy evaled style is better and bump the version for breakage", "url": "https://github.com/minio/minio-java/pull/834#discussion_r363576806", "createdAt": "2020-01-07T03:17:08Z", "author": {"login": "harshavardhana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5741,12 +5743,16 @@ public void listenBucketNotification(String bucketName, String prefix, String su\n       scanner = new Scanner(response.body().charStream());\n       scanner.useDelimiter(\"\\n\");\n       while (scanner.hasNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2MjkyOQ=="}, "originalCommit": {"oid": "3f4146b1d1727af0f73a71183b0e0a227cdd6d30"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMyMTQ4Ng==", "bodyText": "@balamurugana  need your input on this . I have implemented the listenBucketNotification as below but it waits at scanner.next() .Please review the below code.\npublic Iterable<Result<NotificationInfo>> listenBucketNotification(String bucketName, String prefix,\n      String suffix, String[] events) {\n    return new Iterable<Result<NotificationInfo>>() {\n\n      @Override\n      public Iterator<Result<NotificationInfo>> iterator() {\n        return new Iterator<Result<NotificationInfo>>() {\n\n          private Result<NotificationInfo> error;\n          NotificationInfo ni;\n          private boolean completed = false;\n\n          private synchronized void populate() {\n            Multimap<String,String> queryParamMap = HashMultimap.create();\n            queryParamMap.put(\"prefix\", prefix);\n            queryParamMap.put(\"suffix\", suffix);\n            for (String event: events) {\n              queryParamMap.put(\"events\", event);\n            }\n\n            String bodyContent = \"\";\n            Scanner scanner = null;\n            HttpResponse response = null;\n            ObjectMapper mapper = new ObjectMapper();\n\n            try {\n              response = executeReq(Method.GET, getRegion(bucketName),\n                bucketName, \"\", null, queryParamMap, null, 0);\n              scanner = new Scanner(response.body().charStream());\n              scanner.useDelimiter(\"\\n\");\n              if (scanner.hasNext()) {\n                bodyContent = scanner.next().trim();\n                if (!bodyContent.equals(\"\")) {\n                  ni = mapper.readValue(bodyContent, NotificationInfo.class);\n                }\n              }\n            } catch (InvalidBucketNameException | NoSuchAlgorithmException | InsufficientDataException | IOException\n              | InvalidKeyException | NoResponseException | XmlPullParserException | ErrorResponseException\n              | InternalException | InvalidResponseException | RuntimeException e) {\n              this.error = new Result<>(null, e);\n            }             finally {\n              if (response != null) {\n                response.body().close();\n              }\n              if (scanner != null) {\n                scanner.close();\n              }\n            }\n\n          }\n\n\n          @Override\n          public boolean hasNext() {\n            if (this.completed) {\n              return false;\n            }\n\n            if (this.error == null ) {\n              populate();\n            }\n\n            if (this.ni == null ) {\n              populate();\n            }\n\n            this.completed = true;\n            return false;\n          }\n\n          @Override\n          public Result<NotificationInfo> next() {\n            if (this.completed) {\n              throw new NoSuchElementException();\n            }\n            if (this.error == null ) {\n              populate();\n            }\n            this.completed = true;\n            throw new NoSuchElementException();\n          }\n\n          @Override\n          public void remove() {\n            throw new UnsupportedOperationException();\n          }\n        };\n      }\n    };\n  }", "url": "https://github.com/minio/minio-java/pull/834#discussion_r364321486", "createdAt": "2020-01-08T16:26:02Z", "author": {"login": "sinhaashish"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5741,12 +5743,16 @@ public void listenBucketNotification(String bucketName, String prefix, String su\n       scanner = new Scanner(response.body().charStream());\n       scanner.useDelimiter(\"\\n\");\n       while (scanner.hasNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2MjkyOQ=="}, "originalCommit": {"oid": "3f4146b1d1727af0f73a71183b0e0a227cdd6d30"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM0NjQxNQ==", "bodyText": "This looks neat \ud83d\udc4d @sinhaashish unless @balamurugana has any concerns", "url": "https://github.com/minio/minio-java/pull/834#discussion_r364346415", "createdAt": "2020-01-08T17:16:18Z", "author": {"login": "harshavardhana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5741,12 +5743,16 @@ public void listenBucketNotification(String bucketName, String prefix, String su\n       scanner = new Scanner(response.body().charStream());\n       scanner.useDelimiter(\"\\n\");\n       while (scanner.hasNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2MjkyOQ=="}, "originalCommit": {"oid": "3f4146b1d1727af0f73a71183b0e0a227cdd6d30"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1ODA1OTgyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/MinioClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQyMDo0NzowNVrOFcm3uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQyMDo0NzowNVrOFcm3uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0MTMwNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               *  client.listenBucketNotification(\"sinha1\", \"\", \"\", events).iterator();\n          \n          \n            \n               *  client.listenBucketNotification(\"bucketname\", \"\", \"\", events).iterator();", "url": "https://github.com/minio/minio-java/pull/834#discussion_r365541305", "createdAt": "2020-01-11T20:47:05Z", "author": {"login": "kannappanr"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5692,77 +5693,110 @@ public void removeIncompleteUpload(String bucketName, String objectName)\n     }\n   }\n \n+\n   /**\n-   * Listen to bucket notifications.\n+   * Listen to bucket notifications. As bucket notification are lazily executed, its required\n+   * to iterate the returned Iterable.\n+   *\n+   * </p><b>Example:</b><br>\n+\n+   * <pre>{@code\n+   * Iterator<Result<NotificationInfo>> it =\n+   *  client.listenBucketNotification(\"sinha1\", \"\", \"\", events).iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d56034ae65e5693f62944d8b2e98fa48cbd8eb0f"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1ODg0MzIyOnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwNDo0Mzo1MVrOFctQow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMzozMDoyMVrOFc238w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY0NTk4Nw==", "bodyText": "major version change should remove all deprecated methods. you need to do in separate PR. current listenBucketNotification() should be retained and deprecated.", "url": "https://github.com/minio/minio-java/pull/834#discussion_r365645987", "createdAt": "2020-01-13T04:43:51Z", "author": {"login": "balamurugana"}, "path": "build.gradle", "diffHunk": "@@ -35,7 +35,7 @@ apply plugin: 'io.codearte.nexus-staging'\n \n allprojects {\n     group = 'io.minio'\n-    version = '6.0.12'\n+    version = '7.0.0'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd86d9d10141632371b21ab4f4ea1c183c6d9d4c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgwMzUwNw==", "bodyText": "@balamurugana  ptal", "url": "https://github.com/minio/minio-java/pull/834#discussion_r365803507", "createdAt": "2020-01-13T13:30:21Z", "author": {"login": "sinhaashish"}, "path": "build.gradle", "diffHunk": "@@ -35,7 +35,7 @@ apply plugin: 'io.codearte.nexus-staging'\n \n allprojects {\n     group = 'io.minio'\n-    version = '6.0.12'\n+    version = '7.0.0'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY0NTk4Nw=="}, "originalCommit": {"oid": "cd86d9d10141632371b21ab4f4ea1c183c6d9d4c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MTA0MDE5OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxOToyNDo1OFrOFdB37A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxOToyNDo1OFrOFdB37A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk4MzcyNA==", "bodyText": "This is not required if you are not having a breaking change", "url": "https://github.com/minio/minio-java/pull/834#discussion_r365983724", "createdAt": "2020-01-13T19:24:58Z", "author": {"login": "kannappanr"}, "path": "build.gradle", "diffHunk": "@@ -35,7 +35,7 @@ apply plugin: 'io.codearte.nexus-staging'\n \n allprojects {\n     group = 'io.minio'\n-    version = '6.0.12'\n+    version = '6.0.13'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba39dca2d167a3dc3685ce62e6e09fe97ebc63af"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MTA0MTQ5OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxOToyNToyMFrOFdB4rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwMTo1NjoyNVrOFdKMAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk4MzkxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                version = '6.0.13'\n          \n          \n            \n                version = '6.0.12'", "url": "https://github.com/minio/minio-java/pull/834#discussion_r365983917", "createdAt": "2020-01-13T19:25:20Z", "author": {"login": "kannappanr"}, "path": "build.gradle", "diffHunk": "@@ -35,7 +35,7 @@ apply plugin: 'io.codearte.nexus-staging'\n \n allprojects {\n     group = 'io.minio'\n-    version = '6.0.12'\n+    version = '6.0.13'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba39dca2d167a3dc3685ce62e6e09fe97ebc63af"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjExOTkzOA==", "bodyText": "As per discussion with @balamurugana  we will have two listenBucketNotification method. Old one will be depricated. After some time we can have a major release in which all the deprecated methods will be removed .", "url": "https://github.com/minio/minio-java/pull/834#discussion_r366119938", "createdAt": "2020-01-14T01:56:25Z", "author": {"login": "sinhaashish"}, "path": "build.gradle", "diffHunk": "@@ -35,7 +35,7 @@ apply plugin: 'io.codearte.nexus-staging'\n \n allprojects {\n     group = 'io.minio'\n-    version = '6.0.12'\n+    version = '6.0.13'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk4MzkxNw=="}, "originalCommit": {"oid": "ba39dca2d167a3dc3685ce62e6e09fe97ebc63af"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjkyMjM0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/MinioClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDoyNDozN1rOFd58Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDoyNDozN1rOFd58Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkwMjI4Ng==", "bodyText": "do not make changes in deprecated methods instead you remove them in separate PR", "url": "https://github.com/minio/minio-java/pull/834#discussion_r366902286", "createdAt": "2020-01-15T14:24:37Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5717,6 +5719,7 @@ public void removeIncompleteUpload(String bucketName, String objectName)\n    *\n    */\n \n+  @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e12e64cae1fcff6ce166078dba24d7d6f7cf03ea"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjkyNjkxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/MinioClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDoyNTo1M1rOFd5-8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDoyNTo1M1rOFd5-8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkwMzAyNQ==", "bodyText": "this is wrong message. you would need to print the event", "url": "https://github.com/minio/minio-java/pull/834#discussion_r366903025", "createdAt": "2020-01-15T14:25:53Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5763,6 +5770,56 @@ public void listenBucketNotification(String bucketName, String prefix, String su\n   }\n \n \n+\n+\n+  /**\n+   * Listen to bucket notifications. As bucket notification are lazily executed, its required\n+   * to iterate.\n+   *\n+   * </p><b>Example:</b><br>\n+   * <pre>{@code\n+   * String[] events = {\"s3:ObjectCreated:*\", \"s3:ObjectAccessed:*\"};\n+   *   try (CloseableIterator<Result<NotificationInfo>> ci = client\n+   *     .listenBucketNotification(\"bucket-name\", \"\", \"\", events).getMyCloseableIterator()) {\n+   *      while (ci.hasNext()) {\n+   *        NotificationInfo info = ci.next().get();\n+   *        if ( info != null) {\n+   *\n+   *      System.out.println(info.records[0].s3.bucket.name + \"/\"\n+   *          + info.records[0].s3.object.key + \" has been created\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e12e64cae1fcff6ce166078dba24d7d6f7cf03ea"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjkyOTg4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/MinioClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDoyNjo0M1rOFd6A1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNjozODo0MFrOFef_SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkwMzUxMQ==", "bodyText": "you could use executeGet()", "url": "https://github.com/minio/minio-java/pull/834#discussion_r366903511", "createdAt": "2020-01-15T14:26:43Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5763,6 +5770,56 @@ public void listenBucketNotification(String bucketName, String prefix, String su\n   }\n \n \n+\n+\n+  /**\n+   * Listen to bucket notifications. As bucket notification are lazily executed, its required\n+   * to iterate.\n+   *\n+   * </p><b>Example:</b><br>\n+   * <pre>{@code\n+   * String[] events = {\"s3:ObjectCreated:*\", \"s3:ObjectAccessed:*\"};\n+   *   try (CloseableIterator<Result<NotificationInfo>> ci = client\n+   *     .listenBucketNotification(\"bucket-name\", \"\", \"\", events).getMyCloseableIterator()) {\n+   *      while (ci.hasNext()) {\n+   *        NotificationInfo info = ci.next().get();\n+   *        if ( info != null) {\n+   *\n+   *      System.out.println(info.records[0].s3.bucket.name + \"/\"\n+   *          + info.records[0].s3.object.key + \" has been created\");\n+   *       break;\n+   *      }\n+   *    }\n+   *  }\n+   *  }</pre>\n+   *\n+   * @param bucketName Bucket name.\n+   * @param prefix Prefix of concerned objects events.\n+   * @param suffix Suffix of concerned objects events.\n+   * @param events List of events to watch.\n+   *\n+   * @return NotificationListener\n+   */\n+  public NotificationListener listenBucketNotification(String bucketName, String prefix,\n+      String suffix, String[] events)\n+    throws IOException, InvalidKeyException, NoSuchAlgorithmException, InsufficientDataException,\n+    InvalidResponseException, InternalException, NoResponseException, InvalidBucketNameException,\n+    XmlPullParserException, ErrorResponseException {\n+\n+    Multimap<String, String> queryParamMap = HashMultimap.create();\n+    queryParamMap.put(\"prefix\", prefix);\n+    queryParamMap.put(\"suffix\", suffix);\n+    for (String event : events) {\n+      queryParamMap.put(\"events\", event);\n+    }\n+    HttpResponse response = executeReq(Method.GET, getRegion(bucketName),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e12e64cae1fcff6ce166078dba24d7d6f7cf03ea"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUyNTcwNQ==", "bodyText": "we cant use executeGet as it uses a HashMap for queryParameter. While using a hashmap the values are overridden in the below code . that is for the key the values will be replaced if events array has more than one entry.\nfor (String event : events) {\n      queryParamMap.put(\"events\", event);\n    }\n\nwhile executeReq uses Multimap in which the values are appended for the key events.", "url": "https://github.com/minio/minio-java/pull/834#discussion_r367525705", "createdAt": "2020-01-16T16:38:40Z", "author": {"login": "sinhaashish"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5763,6 +5770,56 @@ public void listenBucketNotification(String bucketName, String prefix, String su\n   }\n \n \n+\n+\n+  /**\n+   * Listen to bucket notifications. As bucket notification are lazily executed, its required\n+   * to iterate.\n+   *\n+   * </p><b>Example:</b><br>\n+   * <pre>{@code\n+   * String[] events = {\"s3:ObjectCreated:*\", \"s3:ObjectAccessed:*\"};\n+   *   try (CloseableIterator<Result<NotificationInfo>> ci = client\n+   *     .listenBucketNotification(\"bucket-name\", \"\", \"\", events).getMyCloseableIterator()) {\n+   *      while (ci.hasNext()) {\n+   *        NotificationInfo info = ci.next().get();\n+   *        if ( info != null) {\n+   *\n+   *      System.out.println(info.records[0].s3.bucket.name + \"/\"\n+   *          + info.records[0].s3.object.key + \" has been created\");\n+   *       break;\n+   *      }\n+   *    }\n+   *  }\n+   *  }</pre>\n+   *\n+   * @param bucketName Bucket name.\n+   * @param prefix Prefix of concerned objects events.\n+   * @param suffix Suffix of concerned objects events.\n+   * @param events List of events to watch.\n+   *\n+   * @return NotificationListener\n+   */\n+  public NotificationListener listenBucketNotification(String bucketName, String prefix,\n+      String suffix, String[] events)\n+    throws IOException, InvalidKeyException, NoSuchAlgorithmException, InsufficientDataException,\n+    InvalidResponseException, InternalException, NoResponseException, InvalidBucketNameException,\n+    XmlPullParserException, ErrorResponseException {\n+\n+    Multimap<String, String> queryParamMap = HashMultimap.create();\n+    queryParamMap.put(\"prefix\", prefix);\n+    queryParamMap.put(\"suffix\", suffix);\n+    for (String event : events) {\n+      queryParamMap.put(\"events\", event);\n+    }\n+    HttpResponse response = executeReq(Method.GET, getRegion(bucketName),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkwMzUxMQ=="}, "originalCommit": {"oid": "e12e64cae1fcff6ce166078dba24d7d6f7cf03ea"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjkzNjU0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/NotificationListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDoyODozOVrOFd6FCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDoyODozOVrOFd6FCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkwNDU4NQ==", "bodyText": "cleanup all spacing and styling", "url": "https://github.com/minio/minio-java/pull/834#discussion_r366904585", "createdAt": "2020-01-15T14:28:39Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/NotificationListener.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+package io.minio;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.minio.notification.NotificationInfo;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.Scanner;\n+\n+/**\n+ * NotificationListener is used for listening notification.\n+ */\n+public class NotificationListener  {\n+\n+  Scanner sc = null;\n+  String notificationString = \"\";\n+  NotificationInfo ni = null;\n+  Reader inputReader;\n+  boolean isClosed = false;\n+  ObjectMapper mapper = new ObjectMapper();\n+\n+  NotificationListener( Reader reader) {\n+    this.inputReader = reader;\n+\n+    this.sc = new Scanner(inputReader);\n+    this.sc.useDelimiter(\"\\n\");\n+  }\n+  /**\n+   * Return a closeable iterator.\n+   */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e12e64cae1fcff6ce166078dba24d7d6f7cf03ea"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Njk0MjgwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/NotificationListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDozMDoyN1rOFd6I_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDozMDoyN1rOFd6I_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkwNTU5Nw==", "bodyText": "this is incorrect. this class supposes to have implemented ClosableIterable", "url": "https://github.com/minio/minio-java/pull/834#discussion_r366905597", "createdAt": "2020-01-15T14:30:27Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/NotificationListener.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+package io.minio;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.minio.notification.NotificationInfo;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.Scanner;\n+\n+/**\n+ * NotificationListener is used for listening notification.\n+ */\n+public class NotificationListener  {\n+\n+  Scanner sc = null;\n+  String notificationString = \"\";\n+  NotificationInfo ni = null;\n+  Reader inputReader;\n+  boolean isClosed = false;\n+  ObjectMapper mapper = new ObjectMapper();\n+\n+  NotificationListener( Reader reader) {\n+    this.inputReader = reader;\n+\n+    this.sc = new Scanner(inputReader);\n+    this.sc.useDelimiter(\"\\n\");\n+  }\n+  /**\n+   * Return a closeable iterator.\n+   */\n+\n+  public  CloseableIterator<Result<NotificationInfo>> getMyCloseableIterator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e12e64cae1fcff6ce166078dba24d7d6f7cf03ea"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Njk1MTgyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/NotificationListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDozMjo1MVrOFd6OOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDozMjo1MVrOFd6OOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkwNjkzNw==", "bodyText": "its not good to print exceptions", "url": "https://github.com/minio/minio-java/pull/834#discussion_r366906937", "createdAt": "2020-01-15T14:32:51Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/NotificationListener.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+package io.minio;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.minio.notification.NotificationInfo;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.Scanner;\n+\n+/**\n+ * NotificationListener is used for listening notification.\n+ */\n+public class NotificationListener  {\n+\n+  Scanner sc = null;\n+  String notificationString = \"\";\n+  NotificationInfo ni = null;\n+  Reader inputReader;\n+  boolean isClosed = false;\n+  ObjectMapper mapper = new ObjectMapper();\n+\n+  NotificationListener( Reader reader) {\n+    this.inputReader = reader;\n+\n+    this.sc = new Scanner(inputReader);\n+    this.sc.useDelimiter(\"\\n\");\n+  }\n+  /**\n+   * Return a closeable iterator.\n+   */\n+\n+  public  CloseableIterator<Result<NotificationInfo>> getMyCloseableIterator() {\n+    return new CloseableIterator<Result<NotificationInfo>>() {\n+\n+      @Override\n+      public boolean hasNext() {\n+        if (isClosed) {\n+          return false;\n+        }\n+        if (!NotificationListener.this.sc.hasNext()) {\n+          try {\n+            close();\n+          } catch (IOException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e12e64cae1fcff6ce166078dba24d7d6f7cf03ea"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Njk1NDE3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/NotificationListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDozMzozM1rOFd6Pwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDozMzozM1rOFd6Pwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkwNzMzMA==", "bodyText": "you would need to also check for empty events and ignore them here", "url": "https://github.com/minio/minio-java/pull/834#discussion_r366907330", "createdAt": "2020-01-15T14:33:33Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/NotificationListener.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+package io.minio;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.minio.notification.NotificationInfo;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.Scanner;\n+\n+/**\n+ * NotificationListener is used for listening notification.\n+ */\n+public class NotificationListener  {\n+\n+  Scanner sc = null;\n+  String notificationString = \"\";\n+  NotificationInfo ni = null;\n+  Reader inputReader;\n+  boolean isClosed = false;\n+  ObjectMapper mapper = new ObjectMapper();\n+\n+  NotificationListener( Reader reader) {\n+    this.inputReader = reader;\n+\n+    this.sc = new Scanner(inputReader);\n+    this.sc.useDelimiter(\"\\n\");\n+  }\n+  /**\n+   * Return a closeable iterator.\n+   */\n+\n+  public  CloseableIterator<Result<NotificationInfo>> getMyCloseableIterator() {\n+    return new CloseableIterator<Result<NotificationInfo>>() {\n+\n+      @Override\n+      public boolean hasNext() {\n+        if (isClosed) {\n+          return false;\n+        }\n+        if (!NotificationListener.this.sc.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e12e64cae1fcff6ce166078dba24d7d6f7cf03ea"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Njk1NzMxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/NotificationListener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDozNDozMFrOFd6Rvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo0Nzo0NlrOFeiJkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkwNzgzOQ==", "bodyText": "this while should be in hasNext()", "url": "https://github.com/minio/minio-java/pull/834#discussion_r366907839", "createdAt": "2020-01-15T14:34:30Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/NotificationListener.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+package io.minio;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.minio.notification.NotificationInfo;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.Scanner;\n+\n+/**\n+ * NotificationListener is used for listening notification.\n+ */\n+public class NotificationListener  {\n+\n+  Scanner sc = null;\n+  String notificationString = \"\";\n+  NotificationInfo ni = null;\n+  Reader inputReader;\n+  boolean isClosed = false;\n+  ObjectMapper mapper = new ObjectMapper();\n+\n+  NotificationListener( Reader reader) {\n+    this.inputReader = reader;\n+\n+    this.sc = new Scanner(inputReader);\n+    this.sc.useDelimiter(\"\\n\");\n+  }\n+  /**\n+   * Return a closeable iterator.\n+   */\n+\n+  public  CloseableIterator<Result<NotificationInfo>> getMyCloseableIterator() {\n+    return new CloseableIterator<Result<NotificationInfo>>() {\n+\n+      @Override\n+      public boolean hasNext() {\n+        if (isClosed) {\n+          return false;\n+        }\n+        if (!NotificationListener.this.sc.hasNext()) {\n+          try {\n+            close();\n+          } catch (IOException e) {\n+            e.printStackTrace();\n+          }\n+          return false;\n+        }\n+        return true;\n+      }\n+\n+      @Override\n+      public Result<NotificationInfo> next() {\n+        try {\n+          while (sc.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e12e64cae1fcff6ce166078dba24d7d6f7cf03ea"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MTEwNg==", "bodyText": "When i tried to have the while in hasNext() as shown in the code below\n@Override\n      public boolean hasNext()  {\n        if (isClosed) {\n          return false;\n        }\n        if (!scanner.hasNext()) {\n          try {\n            close();\n          } catch (IOException e) {\n            exception = e;\n          }\n          return false;\n        }\n\n        while (scanner.hasNext()) {\n          notificationString = scanner.next().trim();\n          if (notificationString.equals(\"\")) {\n            continue;\n          } else {\n            break;\n          }\n\n        }\n        return true;\n      }\n\n      @Override\n      public Result<NotificationInfo> next() {\n        try {\n          notificationInfo = mapper.readValue(notificationString, NotificationInfo.class);\n        } catch (JsonParseException e) {\n          exception = e;\n        } catch (  JsonMappingException mappingEx) {\n          exception = mappingEx;\n        } catch ( IOException ioexception) {\n          exception = ioexception;\n        }\n        if ( exception != null ) {\n          return new Result<>(null, exception);\n        }\n        return new Result<>(notificationInfo, null);\n      }\n\nGot a build error as shown\nio.minio.MinioClient$8.next() can't throw NoSuchElementException\n\nThus while is not a part of hasNext", "url": "https://github.com/minio/minio-java/pull/834#discussion_r367561106", "createdAt": "2020-01-16T17:47:46Z", "author": {"login": "sinhaashish"}, "path": "api/src/main/java/io/minio/NotificationListener.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+package io.minio;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.minio.notification.NotificationInfo;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.Scanner;\n+\n+/**\n+ * NotificationListener is used for listening notification.\n+ */\n+public class NotificationListener  {\n+\n+  Scanner sc = null;\n+  String notificationString = \"\";\n+  NotificationInfo ni = null;\n+  Reader inputReader;\n+  boolean isClosed = false;\n+  ObjectMapper mapper = new ObjectMapper();\n+\n+  NotificationListener( Reader reader) {\n+    this.inputReader = reader;\n+\n+    this.sc = new Scanner(inputReader);\n+    this.sc.useDelimiter(\"\\n\");\n+  }\n+  /**\n+   * Return a closeable iterator.\n+   */\n+\n+  public  CloseableIterator<Result<NotificationInfo>> getMyCloseableIterator() {\n+    return new CloseableIterator<Result<NotificationInfo>>() {\n+\n+      @Override\n+      public boolean hasNext() {\n+        if (isClosed) {\n+          return false;\n+        }\n+        if (!NotificationListener.this.sc.hasNext()) {\n+          try {\n+            close();\n+          } catch (IOException e) {\n+            e.printStackTrace();\n+          }\n+          return false;\n+        }\n+        return true;\n+      }\n+\n+      @Override\n+      public Result<NotificationInfo> next() {\n+        try {\n+          while (sc.hasNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkwNzgzOQ=="}, "originalCommit": {"oid": "e12e64cae1fcff6ce166078dba24d7d6f7cf03ea"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Njk3OTUzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/NotificationListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDo0MDozMlrOFd6fVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDo0MDozMlrOFd6fVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkxMTMxOA==", "bodyText": "below logic is crisp and clear\nif (!isClosed) {\n    try {\n        reader.close();\n        scanner.close();\n    } finally {\n        reader = null;\n        scanner = null;\n        isClosed = true;\n    }\n}", "url": "https://github.com/minio/minio-java/pull/834#discussion_r366911318", "createdAt": "2020-01-15T14:40:32Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/NotificationListener.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+package io.minio;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.minio.notification.NotificationInfo;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.Scanner;\n+\n+/**\n+ * NotificationListener is used for listening notification.\n+ */\n+public class NotificationListener  {\n+\n+  Scanner sc = null;\n+  String notificationString = \"\";\n+  NotificationInfo ni = null;\n+  Reader inputReader;\n+  boolean isClosed = false;\n+  ObjectMapper mapper = new ObjectMapper();\n+\n+  NotificationListener( Reader reader) {\n+    this.inputReader = reader;\n+\n+    this.sc = new Scanner(inputReader);\n+    this.sc.useDelimiter(\"\\n\");\n+  }\n+  /**\n+   * Return a closeable iterator.\n+   */\n+\n+  public  CloseableIterator<Result<NotificationInfo>> getMyCloseableIterator() {\n+    return new CloseableIterator<Result<NotificationInfo>>() {\n+\n+      @Override\n+      public boolean hasNext() {\n+        if (isClosed) {\n+          return false;\n+        }\n+        if (!NotificationListener.this.sc.hasNext()) {\n+          try {\n+            close();\n+          } catch (IOException e) {\n+            e.printStackTrace();\n+          }\n+          return false;\n+        }\n+        return true;\n+      }\n+\n+      @Override\n+      public Result<NotificationInfo> next() {\n+        try {\n+          while (sc.hasNext()) {\n+            notificationString = NotificationListener.this.sc.next().trim();\n+            if (!notificationString.equals(\"\")) {\n+              ni = mapper.readValue(notificationString, NotificationInfo.class);\n+              break;\n+            } else {\n+              continue;\n+            }\n+          }\n+        } catch (IOException e) {\n+          return new Result<>(null, e);\n+        }\n+        return new Result<>(ni, null);\n+      }\n+\n+      @Override\n+      public void close() throws IOException {\n+        if (!isClosed) {\n+          if (NotificationListener.this.inputReader != null) {\n+            inputReader.close();\n+          }\n+\n+          if (NotificationListener.this.sc != null) {\n+            sc.close();\n+          }\n+          isClosed = true;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e12e64cae1fcff6ce166078dba24d7d6f7cf03ea"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Njk5MzM2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/NotificationListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDo0NDo0MVrOFd6oDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDo0NDo0MVrOFd6oDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkxMzU1MQ==", "bodyText": "use reader, scanner, notificationInfo instead of inputReader, sc, ni\ngroup relevant fields together reader, scanner and mapper, notificationInfo, then isClosed", "url": "https://github.com/minio/minio-java/pull/834#discussion_r366913551", "createdAt": "2020-01-15T14:44:41Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/NotificationListener.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+package io.minio;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.minio.notification.NotificationInfo;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.Scanner;\n+\n+/**\n+ * NotificationListener is used for listening notification.\n+ */\n+public class NotificationListener  {\n+\n+  Scanner sc = null;\n+  String notificationString = \"\";\n+  NotificationInfo ni = null;\n+  Reader inputReader;\n+  boolean isClosed = false;\n+  ObjectMapper mapper = new ObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e12e64cae1fcff6ce166078dba24d7d6f7cf03ea"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDM0NTc4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/MinioClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxODoxNTo1MlrOFfBMuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxODoxNTo1MlrOFfBMuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2OTgxOQ==", "bodyText": "you could remove this if block i.e. let it run indefinitely in the example.", "url": "https://github.com/minio/minio-java/pull/834#discussion_r368069819", "createdAt": "2020-01-17T18:15:52Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5762,6 +5763,131 @@ public void listenBucketNotification(String bucketName, String prefix, String su\n     }\n   }\n \n+  /**\n+   * Listen to bucket notifications. As bucket notification are lazily executed,\n+   * its required to iterate. The returned closeable iterator must be used with\n+   * try with resource or else the stream will not be closed.\n+   *\n+   * </p><b>Example:</b><br>\n+   * <pre>{@code\n+   *  try (CloseableIterator<Result<NotificationInfo>> ci = client\n+   * .listenBucketNotification(\"my-bucket\", \"\", \"\", events)) {\n+   *  while (ci.hasNext()) {\n+   *    NotificationInfo info = ci.next().get();\n+   *    System.out.println(info.toString());\n+   *    if (info != null) {\n+   *      break;\n+   *      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5851e2c49e0edcd38ac64d99082da3cbe0a0fa06"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDQ3NTUzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/minio/MinioClient.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTowODowNFrOFfCfHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwMzoyOTozNFrOFfM-_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5MDkwOA==", "bodyText": "below code is correct.\n} catch (JsonParseException | JsonMappingException | IOException e) {\n    return new Result(null, e);\n}\nIn Result.java, you need to have get() like below (Note: I modified if block better)\n  public T get()\n    throws InvalidBucketNameException, NoSuchAlgorithmException, InsufficientDataException, IOException,\n           InvalidKeyException, NoResponseException, XmlPullParserException, ErrorResponseException,\n           JsonParseException, JsonMappingException, InternalException {\n    if (ex == null) {\n      return type;\n    }\n\n    if (ex instanceof InvalidBucketNameException) {\n      throw (InvalidBucketNameException) ex;\n    }\n\n    if (ex instanceof NoSuchAlgorithmException) {\n      throw (NoSuchAlgorithmException) ex;\n    }\n\n    if (ex instanceof InsufficientDataException) {\n      throw (InsufficientDataException) ex;\n    }\n\n    if (ex instanceof IOException) {\n      throw (IOException) ex;\n    }\n\n    if (ex instanceof InvalidKeyException) {\n      throw (InvalidKeyException) ex;\n    }\n\n    if (ex instanceof NoResponseException) {\n      throw (NoResponseException) ex;\n    }\n\n    if (ex instanceof XmlPullParserException) {\n      throw (XmlPullParserException) ex;\n    }\n\n    if (ex instanceof ErrorResponseException) {\n      throw (ErrorResponseException) ex;\n    }\n\n    if (ex instanceof JsonParseException) {\n      throw (JsonParseException) ex;\n    }\n\n    if (ex instanceof JsonMappingException) {\n      throw (JsonMappingException) ex;\n    }\n\n    throw (InternalException) ex;\n  }\n}", "url": "https://github.com/minio/minio-java/pull/834#discussion_r368090908", "createdAt": "2020-01-17T19:08:04Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5762,6 +5763,131 @@ public void listenBucketNotification(String bucketName, String prefix, String su\n     }\n   }\n \n+  /**\n+   * Listen to bucket notifications. As bucket notification are lazily executed,\n+   * its required to iterate. The returned closeable iterator must be used with\n+   * try with resource or else the stream will not be closed.\n+   *\n+   * </p><b>Example:</b><br>\n+   * <pre>{@code\n+   *  try (CloseableIterator<Result<NotificationInfo>> ci = client\n+   * .listenBucketNotification(\"my-bucket\", \"\", \"\", events)) {\n+   *  while (ci.hasNext()) {\n+   *    NotificationInfo info = ci.next().get();\n+   *    System.out.println(info.toString());\n+   *    if (info != null) {\n+   *      break;\n+   *      }\n+   *   }\n+   *  } catch (IOException e) {\n+   *    System.out.println(\"Error occurred: \" + e);\n+   *  }\n+   * }\n+   * </pre>\n+   *\n+   * @param bucketName Bucket name.\n+   * @param prefix Prefix of concerned objects events.\n+   * @param suffix Suffix of concerned objects events.\n+   * @param events List of events to watch.\n+   *\n+   * @return (lazy) CloseableIterator of the Result NotificationInfo.\n+   *\n+   */\n+  public CloseableIterator<Result<NotificationInfo>> listenBucketNotification(String bucketName, String prefix,\n+      String suffix, String[] events)\n+    throws IOException, InvalidKeyException, NoSuchAlgorithmException, InsufficientDataException,\n+    InvalidResponseException, InternalException, NoResponseException, InvalidBucketNameException,\n+    XmlPullParserException, ErrorResponseException {\n+\n+    Multimap<String, String> queryParamMap = HashMultimap.create();\n+    queryParamMap.put(\"prefix\", prefix);\n+    queryParamMap.put(\"suffix\", suffix);\n+    for (String event : events) {\n+      queryParamMap.put(\"events\", event);\n+    }\n+\n+    HttpResponse response = executeReq(Method.GET, getRegion(bucketName),\n+        bucketName, \"\", null, queryParamMap, null, 0);\n+\n+    return new CloseableIterator<Result<NotificationInfo>>() {\n+      Scanner scanner  = new Scanner(response.body().charStream()).useDelimiter(\"\\n\");\n+\n+      String notificationString = null;\n+      ObjectMapper mapper = new ObjectMapper();\n+      NotificationInfo notificationInfo = null;\n+      boolean isClosed = false;\n+\n+      @Override\n+      public void close() throws IOException {\n+        if (!isClosed) {\n+          try {\n+            response.body().close();\n+            scanner.close();\n+          } finally {\n+            isClosed = true;\n+          }\n+        }\n+      }\n+\n+      public boolean populate()  {\n+        if (isClosed) {\n+          return false;\n+        }\n+\n+        if (notificationString != null) {\n+          return true;\n+        }\n+\n+        while (scanner.hasNext()) {\n+          notificationString = scanner.next().trim();\n+          if ( !notificationString.equals(\"\")) {\n+            break;\n+          }\n+        }\n+\n+        if (notificationString  == null || notificationString.equals(\"\")) {\n+          try {\n+            close();\n+          } catch (IOException e) {\n+            isClosed = true;\n+          }\n+          return false;\n+        }\n+        return true;\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        return populate();\n+      }\n+\n+      @Override\n+      public Result<NotificationInfo> next() {\n+        if (isClosed) {\n+          throw new NoSuchElementException();\n+        }\n+        if ((notificationString  == null || notificationString.equals(\"\")) &&  !populate() ) {\n+              throw  new NoSuchElementException();\n+        }\n+\n+        try {\n+              notificationInfo = mapper.readValue(notificationString, NotificationInfo.class);\n+              return new Result<>(notificationInfo, null);\n+            } catch ( IOException ex ) {\n+              if ( ex instanceof JsonParseException) {\n+                return new Result<>(null, (JsonParseException)ex);\n+              } else if ( ex instanceof  JsonMappingException) {\n+                return new Result<>(null, (JsonMappingException)ex);\n+              } else {\n+                return new Result<>(null, ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5851e2c49e0edcd38ac64d99082da3cbe0a0fa06"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTgxMQ==", "bodyText": "Since JsonParseException  and JsonMappingException are sub classes of IOException , the pipe in catch would not work. So i have caught the child class exception first and then the parent class.\nRefer https://stackoverflow.com/questions/11116853/declare-method-to-throw-an-exception-and-subclass-of-this-exception\n            } catch (JsonParseException e) {\n              return new Result<>(null, e);\n            } catch ( JsonMappingException e) {\n              return new Result<>(null, e);\n            } catch ( IOException e) {\n              return new Result<>(null, e);", "url": "https://github.com/minio/minio-java/pull/834#discussion_r368191811", "createdAt": "2020-01-18T00:55:38Z", "author": {"login": "sinhaashish"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5762,6 +5763,131 @@ public void listenBucketNotification(String bucketName, String prefix, String su\n     }\n   }\n \n+  /**\n+   * Listen to bucket notifications. As bucket notification are lazily executed,\n+   * its required to iterate. The returned closeable iterator must be used with\n+   * try with resource or else the stream will not be closed.\n+   *\n+   * </p><b>Example:</b><br>\n+   * <pre>{@code\n+   *  try (CloseableIterator<Result<NotificationInfo>> ci = client\n+   * .listenBucketNotification(\"my-bucket\", \"\", \"\", events)) {\n+   *  while (ci.hasNext()) {\n+   *    NotificationInfo info = ci.next().get();\n+   *    System.out.println(info.toString());\n+   *    if (info != null) {\n+   *      break;\n+   *      }\n+   *   }\n+   *  } catch (IOException e) {\n+   *    System.out.println(\"Error occurred: \" + e);\n+   *  }\n+   * }\n+   * </pre>\n+   *\n+   * @param bucketName Bucket name.\n+   * @param prefix Prefix of concerned objects events.\n+   * @param suffix Suffix of concerned objects events.\n+   * @param events List of events to watch.\n+   *\n+   * @return (lazy) CloseableIterator of the Result NotificationInfo.\n+   *\n+   */\n+  public CloseableIterator<Result<NotificationInfo>> listenBucketNotification(String bucketName, String prefix,\n+      String suffix, String[] events)\n+    throws IOException, InvalidKeyException, NoSuchAlgorithmException, InsufficientDataException,\n+    InvalidResponseException, InternalException, NoResponseException, InvalidBucketNameException,\n+    XmlPullParserException, ErrorResponseException {\n+\n+    Multimap<String, String> queryParamMap = HashMultimap.create();\n+    queryParamMap.put(\"prefix\", prefix);\n+    queryParamMap.put(\"suffix\", suffix);\n+    for (String event : events) {\n+      queryParamMap.put(\"events\", event);\n+    }\n+\n+    HttpResponse response = executeReq(Method.GET, getRegion(bucketName),\n+        bucketName, \"\", null, queryParamMap, null, 0);\n+\n+    return new CloseableIterator<Result<NotificationInfo>>() {\n+      Scanner scanner  = new Scanner(response.body().charStream()).useDelimiter(\"\\n\");\n+\n+      String notificationString = null;\n+      ObjectMapper mapper = new ObjectMapper();\n+      NotificationInfo notificationInfo = null;\n+      boolean isClosed = false;\n+\n+      @Override\n+      public void close() throws IOException {\n+        if (!isClosed) {\n+          try {\n+            response.body().close();\n+            scanner.close();\n+          } finally {\n+            isClosed = true;\n+          }\n+        }\n+      }\n+\n+      public boolean populate()  {\n+        if (isClosed) {\n+          return false;\n+        }\n+\n+        if (notificationString != null) {\n+          return true;\n+        }\n+\n+        while (scanner.hasNext()) {\n+          notificationString = scanner.next().trim();\n+          if ( !notificationString.equals(\"\")) {\n+            break;\n+          }\n+        }\n+\n+        if (notificationString  == null || notificationString.equals(\"\")) {\n+          try {\n+            close();\n+          } catch (IOException e) {\n+            isClosed = true;\n+          }\n+          return false;\n+        }\n+        return true;\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        return populate();\n+      }\n+\n+      @Override\n+      public Result<NotificationInfo> next() {\n+        if (isClosed) {\n+          throw new NoSuchElementException();\n+        }\n+        if ((notificationString  == null || notificationString.equals(\"\")) &&  !populate() ) {\n+              throw  new NoSuchElementException();\n+        }\n+\n+        try {\n+              notificationInfo = mapper.readValue(notificationString, NotificationInfo.class);\n+              return new Result<>(notificationInfo, null);\n+            } catch ( IOException ex ) {\n+              if ( ex instanceof JsonParseException) {\n+                return new Result<>(null, (JsonParseException)ex);\n+              } else if ( ex instanceof  JsonMappingException) {\n+                return new Result<>(null, (JsonMappingException)ex);\n+              } else {\n+                return new Result<>(null, ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5MDkwOA=="}, "originalCommit": {"oid": "5851e2c49e0edcd38ac64d99082da3cbe0a0fa06"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMTc4NQ==", "bodyText": "\ud83d\udc4d You would need to do the same in Result.get()", "url": "https://github.com/minio/minio-java/pull/834#discussion_r368201785", "createdAt": "2020-01-18T03:02:29Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5762,6 +5763,131 @@ public void listenBucketNotification(String bucketName, String prefix, String su\n     }\n   }\n \n+  /**\n+   * Listen to bucket notifications. As bucket notification are lazily executed,\n+   * its required to iterate. The returned closeable iterator must be used with\n+   * try with resource or else the stream will not be closed.\n+   *\n+   * </p><b>Example:</b><br>\n+   * <pre>{@code\n+   *  try (CloseableIterator<Result<NotificationInfo>> ci = client\n+   * .listenBucketNotification(\"my-bucket\", \"\", \"\", events)) {\n+   *  while (ci.hasNext()) {\n+   *    NotificationInfo info = ci.next().get();\n+   *    System.out.println(info.toString());\n+   *    if (info != null) {\n+   *      break;\n+   *      }\n+   *   }\n+   *  } catch (IOException e) {\n+   *    System.out.println(\"Error occurred: \" + e);\n+   *  }\n+   * }\n+   * </pre>\n+   *\n+   * @param bucketName Bucket name.\n+   * @param prefix Prefix of concerned objects events.\n+   * @param suffix Suffix of concerned objects events.\n+   * @param events List of events to watch.\n+   *\n+   * @return (lazy) CloseableIterator of the Result NotificationInfo.\n+   *\n+   */\n+  public CloseableIterator<Result<NotificationInfo>> listenBucketNotification(String bucketName, String prefix,\n+      String suffix, String[] events)\n+    throws IOException, InvalidKeyException, NoSuchAlgorithmException, InsufficientDataException,\n+    InvalidResponseException, InternalException, NoResponseException, InvalidBucketNameException,\n+    XmlPullParserException, ErrorResponseException {\n+\n+    Multimap<String, String> queryParamMap = HashMultimap.create();\n+    queryParamMap.put(\"prefix\", prefix);\n+    queryParamMap.put(\"suffix\", suffix);\n+    for (String event : events) {\n+      queryParamMap.put(\"events\", event);\n+    }\n+\n+    HttpResponse response = executeReq(Method.GET, getRegion(bucketName),\n+        bucketName, \"\", null, queryParamMap, null, 0);\n+\n+    return new CloseableIterator<Result<NotificationInfo>>() {\n+      Scanner scanner  = new Scanner(response.body().charStream()).useDelimiter(\"\\n\");\n+\n+      String notificationString = null;\n+      ObjectMapper mapper = new ObjectMapper();\n+      NotificationInfo notificationInfo = null;\n+      boolean isClosed = false;\n+\n+      @Override\n+      public void close() throws IOException {\n+        if (!isClosed) {\n+          try {\n+            response.body().close();\n+            scanner.close();\n+          } finally {\n+            isClosed = true;\n+          }\n+        }\n+      }\n+\n+      public boolean populate()  {\n+        if (isClosed) {\n+          return false;\n+        }\n+\n+        if (notificationString != null) {\n+          return true;\n+        }\n+\n+        while (scanner.hasNext()) {\n+          notificationString = scanner.next().trim();\n+          if ( !notificationString.equals(\"\")) {\n+            break;\n+          }\n+        }\n+\n+        if (notificationString  == null || notificationString.equals(\"\")) {\n+          try {\n+            close();\n+          } catch (IOException e) {\n+            isClosed = true;\n+          }\n+          return false;\n+        }\n+        return true;\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        return populate();\n+      }\n+\n+      @Override\n+      public Result<NotificationInfo> next() {\n+        if (isClosed) {\n+          throw new NoSuchElementException();\n+        }\n+        if ((notificationString  == null || notificationString.equals(\"\")) &&  !populate() ) {\n+              throw  new NoSuchElementException();\n+        }\n+\n+        try {\n+              notificationInfo = mapper.readValue(notificationString, NotificationInfo.class);\n+              return new Result<>(notificationInfo, null);\n+            } catch ( IOException ex ) {\n+              if ( ex instanceof JsonParseException) {\n+                return new Result<>(null, (JsonParseException)ex);\n+              } else if ( ex instanceof  JsonMappingException) {\n+                return new Result<>(null, (JsonMappingException)ex);\n+              } else {\n+                return new Result<>(null, ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5MDkwOA=="}, "originalCommit": {"oid": "5851e2c49e0edcd38ac64d99082da3cbe0a0fa06"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzNzY2Nw==", "bodyText": "@sinhaashish Is the change requested in Result.get() done?", "url": "https://github.com/minio/minio-java/pull/834#discussion_r368237667", "createdAt": "2020-01-18T17:15:40Z", "author": {"login": "kannappanr"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5762,6 +5763,131 @@ public void listenBucketNotification(String bucketName, String prefix, String su\n     }\n   }\n \n+  /**\n+   * Listen to bucket notifications. As bucket notification are lazily executed,\n+   * its required to iterate. The returned closeable iterator must be used with\n+   * try with resource or else the stream will not be closed.\n+   *\n+   * </p><b>Example:</b><br>\n+   * <pre>{@code\n+   *  try (CloseableIterator<Result<NotificationInfo>> ci = client\n+   * .listenBucketNotification(\"my-bucket\", \"\", \"\", events)) {\n+   *  while (ci.hasNext()) {\n+   *    NotificationInfo info = ci.next().get();\n+   *    System.out.println(info.toString());\n+   *    if (info != null) {\n+   *      break;\n+   *      }\n+   *   }\n+   *  } catch (IOException e) {\n+   *    System.out.println(\"Error occurred: \" + e);\n+   *  }\n+   * }\n+   * </pre>\n+   *\n+   * @param bucketName Bucket name.\n+   * @param prefix Prefix of concerned objects events.\n+   * @param suffix Suffix of concerned objects events.\n+   * @param events List of events to watch.\n+   *\n+   * @return (lazy) CloseableIterator of the Result NotificationInfo.\n+   *\n+   */\n+  public CloseableIterator<Result<NotificationInfo>> listenBucketNotification(String bucketName, String prefix,\n+      String suffix, String[] events)\n+    throws IOException, InvalidKeyException, NoSuchAlgorithmException, InsufficientDataException,\n+    InvalidResponseException, InternalException, NoResponseException, InvalidBucketNameException,\n+    XmlPullParserException, ErrorResponseException {\n+\n+    Multimap<String, String> queryParamMap = HashMultimap.create();\n+    queryParamMap.put(\"prefix\", prefix);\n+    queryParamMap.put(\"suffix\", suffix);\n+    for (String event : events) {\n+      queryParamMap.put(\"events\", event);\n+    }\n+\n+    HttpResponse response = executeReq(Method.GET, getRegion(bucketName),\n+        bucketName, \"\", null, queryParamMap, null, 0);\n+\n+    return new CloseableIterator<Result<NotificationInfo>>() {\n+      Scanner scanner  = new Scanner(response.body().charStream()).useDelimiter(\"\\n\");\n+\n+      String notificationString = null;\n+      ObjectMapper mapper = new ObjectMapper();\n+      NotificationInfo notificationInfo = null;\n+      boolean isClosed = false;\n+\n+      @Override\n+      public void close() throws IOException {\n+        if (!isClosed) {\n+          try {\n+            response.body().close();\n+            scanner.close();\n+          } finally {\n+            isClosed = true;\n+          }\n+        }\n+      }\n+\n+      public boolean populate()  {\n+        if (isClosed) {\n+          return false;\n+        }\n+\n+        if (notificationString != null) {\n+          return true;\n+        }\n+\n+        while (scanner.hasNext()) {\n+          notificationString = scanner.next().trim();\n+          if ( !notificationString.equals(\"\")) {\n+            break;\n+          }\n+        }\n+\n+        if (notificationString  == null || notificationString.equals(\"\")) {\n+          try {\n+            close();\n+          } catch (IOException e) {\n+            isClosed = true;\n+          }\n+          return false;\n+        }\n+        return true;\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        return populate();\n+      }\n+\n+      @Override\n+      public Result<NotificationInfo> next() {\n+        if (isClosed) {\n+          throw new NoSuchElementException();\n+        }\n+        if ((notificationString  == null || notificationString.equals(\"\")) &&  !populate() ) {\n+              throw  new NoSuchElementException();\n+        }\n+\n+        try {\n+              notificationInfo = mapper.readValue(notificationString, NotificationInfo.class);\n+              return new Result<>(notificationInfo, null);\n+            } catch ( IOException ex ) {\n+              if ( ex instanceof JsonParseException) {\n+                return new Result<>(null, (JsonParseException)ex);\n+              } else if ( ex instanceof  JsonMappingException) {\n+                return new Result<>(null, (JsonMappingException)ex);\n+              } else {\n+                return new Result<>(null, ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5MDkwOA=="}, "originalCommit": {"oid": "5851e2c49e0edcd38ac64d99082da3cbe0a0fa06"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MjkxMA==", "bodyText": "@balamurugana  this code is already added in Result.java.\n\n    if (ex instanceof JsonParseException) {\n      throw (JsonParseException) ex;\n    }\n\n    if (ex instanceof JsonMappingException) {\n      throw (JsonMappingException) ex;\n    }\n\n    if (ex instanceof IOException) {\n      throw (IOException) ex;\n    }", "url": "https://github.com/minio/minio-java/pull/834#discussion_r368262910", "createdAt": "2020-01-19T03:29:34Z", "author": {"login": "sinhaashish"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -5762,6 +5763,131 @@ public void listenBucketNotification(String bucketName, String prefix, String su\n     }\n   }\n \n+  /**\n+   * Listen to bucket notifications. As bucket notification are lazily executed,\n+   * its required to iterate. The returned closeable iterator must be used with\n+   * try with resource or else the stream will not be closed.\n+   *\n+   * </p><b>Example:</b><br>\n+   * <pre>{@code\n+   *  try (CloseableIterator<Result<NotificationInfo>> ci = client\n+   * .listenBucketNotification(\"my-bucket\", \"\", \"\", events)) {\n+   *  while (ci.hasNext()) {\n+   *    NotificationInfo info = ci.next().get();\n+   *    System.out.println(info.toString());\n+   *    if (info != null) {\n+   *      break;\n+   *      }\n+   *   }\n+   *  } catch (IOException e) {\n+   *    System.out.println(\"Error occurred: \" + e);\n+   *  }\n+   * }\n+   * </pre>\n+   *\n+   * @param bucketName Bucket name.\n+   * @param prefix Prefix of concerned objects events.\n+   * @param suffix Suffix of concerned objects events.\n+   * @param events List of events to watch.\n+   *\n+   * @return (lazy) CloseableIterator of the Result NotificationInfo.\n+   *\n+   */\n+  public CloseableIterator<Result<NotificationInfo>> listenBucketNotification(String bucketName, String prefix,\n+      String suffix, String[] events)\n+    throws IOException, InvalidKeyException, NoSuchAlgorithmException, InsufficientDataException,\n+    InvalidResponseException, InternalException, NoResponseException, InvalidBucketNameException,\n+    XmlPullParserException, ErrorResponseException {\n+\n+    Multimap<String, String> queryParamMap = HashMultimap.create();\n+    queryParamMap.put(\"prefix\", prefix);\n+    queryParamMap.put(\"suffix\", suffix);\n+    for (String event : events) {\n+      queryParamMap.put(\"events\", event);\n+    }\n+\n+    HttpResponse response = executeReq(Method.GET, getRegion(bucketName),\n+        bucketName, \"\", null, queryParamMap, null, 0);\n+\n+    return new CloseableIterator<Result<NotificationInfo>>() {\n+      Scanner scanner  = new Scanner(response.body().charStream()).useDelimiter(\"\\n\");\n+\n+      String notificationString = null;\n+      ObjectMapper mapper = new ObjectMapper();\n+      NotificationInfo notificationInfo = null;\n+      boolean isClosed = false;\n+\n+      @Override\n+      public void close() throws IOException {\n+        if (!isClosed) {\n+          try {\n+            response.body().close();\n+            scanner.close();\n+          } finally {\n+            isClosed = true;\n+          }\n+        }\n+      }\n+\n+      public boolean populate()  {\n+        if (isClosed) {\n+          return false;\n+        }\n+\n+        if (notificationString != null) {\n+          return true;\n+        }\n+\n+        while (scanner.hasNext()) {\n+          notificationString = scanner.next().trim();\n+          if ( !notificationString.equals(\"\")) {\n+            break;\n+          }\n+        }\n+\n+        if (notificationString  == null || notificationString.equals(\"\")) {\n+          try {\n+            close();\n+          } catch (IOException e) {\n+            isClosed = true;\n+          }\n+          return false;\n+        }\n+        return true;\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        return populate();\n+      }\n+\n+      @Override\n+      public Result<NotificationInfo> next() {\n+        if (isClosed) {\n+          throw new NoSuchElementException();\n+        }\n+        if ((notificationString  == null || notificationString.equals(\"\")) &&  !populate() ) {\n+              throw  new NoSuchElementException();\n+        }\n+\n+        try {\n+              notificationInfo = mapper.readValue(notificationString, NotificationInfo.class);\n+              return new Result<>(notificationInfo, null);\n+            } catch ( IOException ex ) {\n+              if ( ex instanceof JsonParseException) {\n+                return new Result<>(null, (JsonParseException)ex);\n+              } else if ( ex instanceof  JsonMappingException) {\n+                return new Result<>(null, (JsonMappingException)ex);\n+              } else {\n+                return new Result<>(null, ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5MDkwOA=="}, "originalCommit": {"oid": "5851e2c49e0edcd38ac64d99082da3cbe0a0fa06"}, "originalPosition": 137}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 760, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}