{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5Mzg2Mzc3", "number": 946, "title": "Implement Args builder for listObjects API", "bodyText": "Added the new args class ListObjectsArgs to be used with the\nlistObjects API. Example usage:\nIterable<Result<Item>> results = minioClient.listObjects(\n  ListObjectsArgs.builder().\n    bucket(\"my-bucketname\").\n    includeUserMetadata(true).\n    startAfter(\"start-after-entry\").\n    prefix(\"my-obj\").\n    maxKeys(100).\n    fetchOwner(true)\n  );\n\nAlso refactored some of the existing code to reduce duplication of code:\n\n\nExtract common part of the result of both V1 and V2 API into\nListBucketResult, and made the two specific classes\n(ListBucketResultV1 and ListBucketResultV2) extend from it. The main\ndifference between the two is the naming of the continuation token\n(continuationToken in V2 vs marker in V1). Since this is only a\nnaming difference, both results can be treated the same way by\nabstracting out the methods related to these result fields.\n\n\nSimilarly, most of the logic of the iterators for the response of V1\nand V2 was also common. Extracted it out into a new abstract class\ncalled ObjectIterator.", "createdAt": "2020-05-18T09:48:02Z", "url": "https://github.com/minio/minio-java/pull/946", "merged": true, "mergeCommit": {"oid": "dc9306b7f68c0b38485bbb14541347f8bdacaf3c"}, "closed": true, "closedAt": "2020-05-19T16:03:45Z", "author": {"login": "anjalshireesh"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcigkQKAFqTQxMzYxNjIwNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABci2eu8gFqTQxNDU4NDc0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzNjE2MjA0", "url": "https://github.com/minio/minio-java/pull/946#pullrequestreview-413616204", "createdAt": "2020-05-18T13:53:46Z", "commit": {"oid": "365c8e88134965876e63f4a3393206faec356712"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMzo1Mzo0NlrOGW4Nxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDowNTowN1rOGW4trQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY0Mjg4Nw==", "bodyText": "startAfter is used in ListObjectsV2 and marker is used in ListObjectV1, but both serve same functionality. We can remove one argument.", "url": "https://github.com/minio/minio-java/pull/946#discussion_r426642887", "createdAt": "2020-05-18T13:53:46Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/ListObjectsArgs.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.minio;\n+\n+/** Argument class of @see #listObjects(ListObjectsArgs args). */\n+public class ListObjectsArgs extends BucketArgs {\n+  private String continuationToken;\n+  private String delimiter;\n+  private boolean fetchOwner;\n+  private Integer maxKeys;\n+  private String prefix;\n+  private String startAfter;\n+  private boolean includeUserMetadata;\n+  private String marker;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "365c8e88134965876e63f4a3393206faec356712"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY0NjA3NA==", "bodyText": "As we follow google-style, we could use like the way in the code.", "url": "https://github.com/minio/minio-java/pull/946#discussion_r426646074", "createdAt": "2020-05-18T13:58:01Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2872,293 +2877,250 @@ public void remove() {\n    * @see #listObjects(String bucketName)\n    * @see #listObjects(String bucketName, String prefix)\n    * @see #listObjects(String bucketName, String prefix, boolean recursive)\n+   * @deprecated use {@link #listObjects(ListObjectsArgs)}\n    */\n   public Iterable<Result<Item>> listObjects(\n       final String bucketName,\n       final String prefix,\n       final boolean recursive,\n       final boolean includeUserMetadata,\n       final boolean useVersion1) {\n-    if (useVersion1) {\n-      if (includeUserMetadata) {\n+    return listObjects(\n+        ListObjectsArgs.builder()\n+            .bucket(bucketName)\n+            .prefix(prefix)\n+            .recursive(recursive)\n+            .includeUserMetadata(includeUserMetadata)\n+            .build());\n+  }\n+\n+  /**\n+   * Lists objects information of a bucket. Supports both the versions 1 and 2 of the S3 API. By\n+   * default, the <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html\">\n+   * version 2</a> API is used. <br>\n+   * <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html\">version 1</a>\n+   * can be used by passing the optional argument `useVersion1` as `true`.\n+   *\n+   * <pre>Example:{@code\n+   * Iterable<Result<Item>> results = minioClient.listObjects(\n+   *   ListObjectsArgs.builder().\n+   *   bucket(\"my-bucketname\").\n+   *   includeUserMetadata(true).\n+   *   startAfter(\"start-after-entry\").\n+   *   prefix(\"my-obj\").\n+   *   maxKeys(100).\n+   *   fetchOwner(true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "365c8e88134965876e63f4a3393206faec356712"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1MDQ3OQ==", "bodyText": "We need use delimiter from args.delimiter() if it is null and we can default to /", "url": "https://github.com/minio/minio-java/pull/946#discussion_r426650479", "createdAt": "2020-05-18T14:04:18Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2872,293 +2877,250 @@ public void remove() {\n    * @see #listObjects(String bucketName)\n    * @see #listObjects(String bucketName, String prefix)\n    * @see #listObjects(String bucketName, String prefix, boolean recursive)\n+   * @deprecated use {@link #listObjects(ListObjectsArgs)}\n    */\n   public Iterable<Result<Item>> listObjects(\n       final String bucketName,\n       final String prefix,\n       final boolean recursive,\n       final boolean includeUserMetadata,\n       final boolean useVersion1) {\n-    if (useVersion1) {\n-      if (includeUserMetadata) {\n+    return listObjects(\n+        ListObjectsArgs.builder()\n+            .bucket(bucketName)\n+            .prefix(prefix)\n+            .recursive(recursive)\n+            .includeUserMetadata(includeUserMetadata)\n+            .build());\n+  }\n+\n+  /**\n+   * Lists objects information of a bucket. Supports both the versions 1 and 2 of the S3 API. By\n+   * default, the <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html\">\n+   * version 2</a> API is used. <br>\n+   * <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html\">version 1</a>\n+   * can be used by passing the optional argument `useVersion1` as `true`.\n+   *\n+   * <pre>Example:{@code\n+   * Iterable<Result<Item>> results = minioClient.listObjects(\n+   *   ListObjectsArgs.builder().\n+   *   bucket(\"my-bucketname\").\n+   *   includeUserMetadata(true).\n+   *   startAfter(\"start-after-entry\").\n+   *   prefix(\"my-obj\").\n+   *   maxKeys(100).\n+   *   fetchOwner(true)\n+   * );\n+   * for (Result<Item> result : results) {\n+   *   Item item = result.get();\n+   *   System.out.println(\n+   *       item.lastModified() + \", \" + item.size() + \", \" + item.objectName());\n+   * }\n+   * }</pre>\n+   *\n+   * @param args Instance of {@link ListObjectsArgs} built using the builder\n+   * @return Iterable&ltResult&ltItem&gt&gt - Lazy iterator contains object information.\n+   * @throws XmlParserException upon parsing response xml\n+   */\n+  public Iterable<Result<Item>> listObjects(ListObjectsArgs args) {\n+    if (args.useVersion1()) {\n+      if (args.includeUserMetadata()) {\n         throw new IllegalArgumentException(\n             \"include user metadata flag is not supported in version 1\");\n       }\n-\n-      return listObjectsV1(bucketName, prefix, recursive);\n+      return listObjectsV1(args);\n+    } else {\n+      return listObjectsV2(args);\n     }\n-\n-    return listObjectsV2(bucketName, prefix, recursive, includeUserMetadata);\n   }\n \n-  private Iterable<Result<Item>> listObjectsV2(\n-      final String bucketName,\n-      final String prefix,\n-      final boolean recursive,\n-      final boolean includeUserMetadata) {\n-    return new Iterable<Result<Item>>() {\n-      @Override\n-      public Iterator<Result<Item>> iterator() {\n-        return new Iterator<Result<Item>>() {\n-          private ListBucketResult listBucketResult;\n-          private Result<Item> error;\n-          private Iterator<Item> itemIterator;\n-          private Iterator<Prefix> prefixIterator;\n-          private boolean completed = false;\n+  private abstract class ObjectIterator implements Iterator<Result<Item>> {\n+    protected Result<Item> error;\n+    protected Iterator<Item> itemIterator;\n+    protected Iterator<Prefix> prefixIterator;\n+    protected boolean completed = false;\n+    protected ListBucketResult listBucketResult;\n+    protected String lastObjectName;\n \n-          private synchronized void populate() {\n-            String delimiter = \"/\";\n-            if (recursive) {\n-              delimiter = null;\n-            }\n+    protected abstract void populateResult()\n+        throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+            NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+            ErrorResponseException, InternalException, InvalidResponseException, IOException;\n \n-            String continuationToken = null;\n-            if (this.listBucketResult != null) {\n-              continuationToken = listBucketResult.nextContinuationToken();\n-            }\n+    protected synchronized void populate() {\n+      try {\n+        populateResult();\n+      } catch (ErrorResponseException\n+          | IllegalArgumentException\n+          | InsufficientDataException\n+          | InternalException\n+          | InvalidBucketNameException\n+          | InvalidKeyException\n+          | InvalidResponseException\n+          | IOException\n+          | NoSuchAlgorithmException\n+          | XmlParserException e) {\n+        this.error = new Result<>(e);\n+      } finally {\n+        if (this.listBucketResult != null) {\n+          this.itemIterator = this.listBucketResult.contents().iterator();\n+          this.prefixIterator = this.listBucketResult.commonPrefixes().iterator();\n+        } else {\n+          this.itemIterator = new LinkedList<Item>().iterator();\n+          this.prefixIterator = new LinkedList<Prefix>().iterator();\n+        }\n+      }\n+    }\n \n-            this.listBucketResult = null;\n-            this.itemIterator = null;\n-            this.prefixIterator = null;\n+    @Override\n+    public boolean hasNext() {\n+      if (this.completed) {\n+        return false;\n+      }\n \n-            try {\n-              this.listBucketResult =\n-                  listObjectsV2(\n-                      bucketName,\n-                      continuationToken,\n-                      delimiter,\n-                      false,\n-                      null,\n-                      prefix,\n-                      null,\n-                      includeUserMetadata);\n-            } catch (ErrorResponseException\n-                | IllegalArgumentException\n-                | InsufficientDataException\n-                | InternalException\n-                | InvalidBucketNameException\n-                | InvalidKeyException\n-                | InvalidResponseException\n-                | IOException\n-                | NoSuchAlgorithmException\n-                | XmlParserException e) {\n-              this.error = new Result<>(e);\n-            } finally {\n-              if (this.listBucketResult != null) {\n-                this.itemIterator = this.listBucketResult.contents().iterator();\n-                this.prefixIterator = this.listBucketResult.commonPrefixes().iterator();\n-              } else {\n-                this.itemIterator = new LinkedList<Item>().iterator();\n-                this.prefixIterator = new LinkedList<Prefix>().iterator();\n-              }\n-            }\n-          }\n+      if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n+        populate();\n+      }\n \n-          @Override\n-          public boolean hasNext() {\n-            if (this.completed) {\n-              return false;\n-            }\n+      if (this.error == null\n+          && !this.itemIterator.hasNext()\n+          && !this.prefixIterator.hasNext()\n+          && this.listBucketResult.isTruncated()) {\n+        populate();\n+      }\n \n-            if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n-              populate();\n-            }\n+      if (this.error != null) {\n+        return true;\n+      }\n \n-            if (this.error == null\n-                && !this.itemIterator.hasNext()\n-                && !this.prefixIterator.hasNext()\n-                && this.listBucketResult.isTruncated()) {\n-              populate();\n-            }\n+      if (this.itemIterator.hasNext()) {\n+        return true;\n+      }\n \n-            if (this.error != null) {\n-              return true;\n-            }\n+      if (this.prefixIterator.hasNext()) {\n+        return true;\n+      }\n \n-            if (this.itemIterator.hasNext()) {\n-              return true;\n-            }\n+      this.completed = true;\n+      return false;\n+    }\n \n-            if (this.prefixIterator.hasNext()) {\n-              return true;\n-            }\n+    @Override\n+    public Result<Item> next() {\n+      if (this.completed) {\n+        throw new NoSuchElementException();\n+      }\n \n-            this.completed = true;\n-            return false;\n-          }\n+      if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n+        populate();\n+      }\n \n-          @Override\n-          public Result<Item> next() {\n-            if (this.completed) {\n-              throw new NoSuchElementException();\n-            }\n+      if (this.error == null\n+          && !this.itemIterator.hasNext()\n+          && !this.prefixIterator.hasNext()\n+          && this.listBucketResult.isTruncated()) {\n+        populate();\n+      }\n \n-            if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n-              populate();\n-            }\n+      if (this.error != null) {\n+        this.completed = true;\n+        return this.error;\n+      }\n \n-            if (this.error == null\n-                && !this.itemIterator.hasNext()\n-                && !this.prefixIterator.hasNext()\n-                && this.listBucketResult.isTruncated()) {\n-              populate();\n-            }\n+      if (this.itemIterator.hasNext()) {\n+        Item item = this.itemIterator.next();\n+        this.lastObjectName = item.objectName();\n+        return new Result<>(item);\n+      }\n+      if (this.prefixIterator.hasNext()) {\n+        return new Result<>(this.prefixIterator.next().toItem());\n+      }\n \n-            if (this.error != null) {\n-              this.completed = true;\n-              return this.error;\n-            }\n+      this.completed = true;\n+      throw new NoSuchElementException();\n+    }\n \n-            if (this.itemIterator.hasNext()) {\n-              Item item = this.itemIterator.next();\n-              return new Result<>(item);\n+    @Override\n+    public void remove() {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  private Iterable<Result<Item>> listObjectsV2(ListObjectsArgs args) {\n+    return new Iterable<Result<Item>>() {\n+      @Override\n+      public Iterator<Result<Item>> iterator() {\n+        return new ObjectIterator() {\n+          protected void populateResult()\n+              throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+                  NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+                  ErrorResponseException, InternalException, InvalidResponseException, IOException {\n+            String delimiter = \"/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "365c8e88134965876e63f4a3393206faec356712"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1MTA1Mw==", "bodyText": "same as above", "url": "https://github.com/minio/minio-java/pull/946#discussion_r426651053", "createdAt": "2020-05-18T14:05:07Z", "author": {"login": "balamurugana"}, "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2872,293 +2877,250 @@ public void remove() {\n    * @see #listObjects(String bucketName)\n    * @see #listObjects(String bucketName, String prefix)\n    * @see #listObjects(String bucketName, String prefix, boolean recursive)\n+   * @deprecated use {@link #listObjects(ListObjectsArgs)}\n    */\n   public Iterable<Result<Item>> listObjects(\n       final String bucketName,\n       final String prefix,\n       final boolean recursive,\n       final boolean includeUserMetadata,\n       final boolean useVersion1) {\n-    if (useVersion1) {\n-      if (includeUserMetadata) {\n+    return listObjects(\n+        ListObjectsArgs.builder()\n+            .bucket(bucketName)\n+            .prefix(prefix)\n+            .recursive(recursive)\n+            .includeUserMetadata(includeUserMetadata)\n+            .build());\n+  }\n+\n+  /**\n+   * Lists objects information of a bucket. Supports both the versions 1 and 2 of the S3 API. By\n+   * default, the <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html\">\n+   * version 2</a> API is used. <br>\n+   * <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html\">version 1</a>\n+   * can be used by passing the optional argument `useVersion1` as `true`.\n+   *\n+   * <pre>Example:{@code\n+   * Iterable<Result<Item>> results = minioClient.listObjects(\n+   *   ListObjectsArgs.builder().\n+   *   bucket(\"my-bucketname\").\n+   *   includeUserMetadata(true).\n+   *   startAfter(\"start-after-entry\").\n+   *   prefix(\"my-obj\").\n+   *   maxKeys(100).\n+   *   fetchOwner(true)\n+   * );\n+   * for (Result<Item> result : results) {\n+   *   Item item = result.get();\n+   *   System.out.println(\n+   *       item.lastModified() + \", \" + item.size() + \", \" + item.objectName());\n+   * }\n+   * }</pre>\n+   *\n+   * @param args Instance of {@link ListObjectsArgs} built using the builder\n+   * @return Iterable&ltResult&ltItem&gt&gt - Lazy iterator contains object information.\n+   * @throws XmlParserException upon parsing response xml\n+   */\n+  public Iterable<Result<Item>> listObjects(ListObjectsArgs args) {\n+    if (args.useVersion1()) {\n+      if (args.includeUserMetadata()) {\n         throw new IllegalArgumentException(\n             \"include user metadata flag is not supported in version 1\");\n       }\n-\n-      return listObjectsV1(bucketName, prefix, recursive);\n+      return listObjectsV1(args);\n+    } else {\n+      return listObjectsV2(args);\n     }\n-\n-    return listObjectsV2(bucketName, prefix, recursive, includeUserMetadata);\n   }\n \n-  private Iterable<Result<Item>> listObjectsV2(\n-      final String bucketName,\n-      final String prefix,\n-      final boolean recursive,\n-      final boolean includeUserMetadata) {\n-    return new Iterable<Result<Item>>() {\n-      @Override\n-      public Iterator<Result<Item>> iterator() {\n-        return new Iterator<Result<Item>>() {\n-          private ListBucketResult listBucketResult;\n-          private Result<Item> error;\n-          private Iterator<Item> itemIterator;\n-          private Iterator<Prefix> prefixIterator;\n-          private boolean completed = false;\n+  private abstract class ObjectIterator implements Iterator<Result<Item>> {\n+    protected Result<Item> error;\n+    protected Iterator<Item> itemIterator;\n+    protected Iterator<Prefix> prefixIterator;\n+    protected boolean completed = false;\n+    protected ListBucketResult listBucketResult;\n+    protected String lastObjectName;\n \n-          private synchronized void populate() {\n-            String delimiter = \"/\";\n-            if (recursive) {\n-              delimiter = null;\n-            }\n+    protected abstract void populateResult()\n+        throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+            NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+            ErrorResponseException, InternalException, InvalidResponseException, IOException;\n \n-            String continuationToken = null;\n-            if (this.listBucketResult != null) {\n-              continuationToken = listBucketResult.nextContinuationToken();\n-            }\n+    protected synchronized void populate() {\n+      try {\n+        populateResult();\n+      } catch (ErrorResponseException\n+          | IllegalArgumentException\n+          | InsufficientDataException\n+          | InternalException\n+          | InvalidBucketNameException\n+          | InvalidKeyException\n+          | InvalidResponseException\n+          | IOException\n+          | NoSuchAlgorithmException\n+          | XmlParserException e) {\n+        this.error = new Result<>(e);\n+      } finally {\n+        if (this.listBucketResult != null) {\n+          this.itemIterator = this.listBucketResult.contents().iterator();\n+          this.prefixIterator = this.listBucketResult.commonPrefixes().iterator();\n+        } else {\n+          this.itemIterator = new LinkedList<Item>().iterator();\n+          this.prefixIterator = new LinkedList<Prefix>().iterator();\n+        }\n+      }\n+    }\n \n-            this.listBucketResult = null;\n-            this.itemIterator = null;\n-            this.prefixIterator = null;\n+    @Override\n+    public boolean hasNext() {\n+      if (this.completed) {\n+        return false;\n+      }\n \n-            try {\n-              this.listBucketResult =\n-                  listObjectsV2(\n-                      bucketName,\n-                      continuationToken,\n-                      delimiter,\n-                      false,\n-                      null,\n-                      prefix,\n-                      null,\n-                      includeUserMetadata);\n-            } catch (ErrorResponseException\n-                | IllegalArgumentException\n-                | InsufficientDataException\n-                | InternalException\n-                | InvalidBucketNameException\n-                | InvalidKeyException\n-                | InvalidResponseException\n-                | IOException\n-                | NoSuchAlgorithmException\n-                | XmlParserException e) {\n-              this.error = new Result<>(e);\n-            } finally {\n-              if (this.listBucketResult != null) {\n-                this.itemIterator = this.listBucketResult.contents().iterator();\n-                this.prefixIterator = this.listBucketResult.commonPrefixes().iterator();\n-              } else {\n-                this.itemIterator = new LinkedList<Item>().iterator();\n-                this.prefixIterator = new LinkedList<Prefix>().iterator();\n-              }\n-            }\n-          }\n+      if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n+        populate();\n+      }\n \n-          @Override\n-          public boolean hasNext() {\n-            if (this.completed) {\n-              return false;\n-            }\n+      if (this.error == null\n+          && !this.itemIterator.hasNext()\n+          && !this.prefixIterator.hasNext()\n+          && this.listBucketResult.isTruncated()) {\n+        populate();\n+      }\n \n-            if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n-              populate();\n-            }\n+      if (this.error != null) {\n+        return true;\n+      }\n \n-            if (this.error == null\n-                && !this.itemIterator.hasNext()\n-                && !this.prefixIterator.hasNext()\n-                && this.listBucketResult.isTruncated()) {\n-              populate();\n-            }\n+      if (this.itemIterator.hasNext()) {\n+        return true;\n+      }\n \n-            if (this.error != null) {\n-              return true;\n-            }\n+      if (this.prefixIterator.hasNext()) {\n+        return true;\n+      }\n \n-            if (this.itemIterator.hasNext()) {\n-              return true;\n-            }\n+      this.completed = true;\n+      return false;\n+    }\n \n-            if (this.prefixIterator.hasNext()) {\n-              return true;\n-            }\n+    @Override\n+    public Result<Item> next() {\n+      if (this.completed) {\n+        throw new NoSuchElementException();\n+      }\n \n-            this.completed = true;\n-            return false;\n-          }\n+      if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n+        populate();\n+      }\n \n-          @Override\n-          public Result<Item> next() {\n-            if (this.completed) {\n-              throw new NoSuchElementException();\n-            }\n+      if (this.error == null\n+          && !this.itemIterator.hasNext()\n+          && !this.prefixIterator.hasNext()\n+          && this.listBucketResult.isTruncated()) {\n+        populate();\n+      }\n \n-            if (this.error == null && this.itemIterator == null && this.prefixIterator == null) {\n-              populate();\n-            }\n+      if (this.error != null) {\n+        this.completed = true;\n+        return this.error;\n+      }\n \n-            if (this.error == null\n-                && !this.itemIterator.hasNext()\n-                && !this.prefixIterator.hasNext()\n-                && this.listBucketResult.isTruncated()) {\n-              populate();\n-            }\n+      if (this.itemIterator.hasNext()) {\n+        Item item = this.itemIterator.next();\n+        this.lastObjectName = item.objectName();\n+        return new Result<>(item);\n+      }\n+      if (this.prefixIterator.hasNext()) {\n+        return new Result<>(this.prefixIterator.next().toItem());\n+      }\n \n-            if (this.error != null) {\n-              this.completed = true;\n-              return this.error;\n-            }\n+      this.completed = true;\n+      throw new NoSuchElementException();\n+    }\n \n-            if (this.itemIterator.hasNext()) {\n-              Item item = this.itemIterator.next();\n-              return new Result<>(item);\n+    @Override\n+    public void remove() {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  private Iterable<Result<Item>> listObjectsV2(ListObjectsArgs args) {\n+    return new Iterable<Result<Item>>() {\n+      @Override\n+      public Iterator<Result<Item>> iterator() {\n+        return new ObjectIterator() {\n+          protected void populateResult()\n+              throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+                  NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+                  ErrorResponseException, InternalException, InvalidResponseException, IOException {\n+            String delimiter = \"/\";\n+            if (args.recursive()) {\n+              delimiter = null;\n             }\n \n-            if (this.prefixIterator.hasNext()) {\n-              return new Result<>(this.prefixIterator.next().toItem());\n+            String continuationToken = null;\n+            if (this.listBucketResult != null) {\n+              continuationToken = listBucketResult.nextContinuationToken();\n             }\n \n-            this.completed = true;\n-            throw new NoSuchElementException();\n-          }\n+            this.listBucketResult = null;\n+            this.itemIterator = null;\n+            this.prefixIterator = null;\n \n-          @Override\n-          public void remove() {\n-            throw new UnsupportedOperationException();\n+            this.listBucketResult =\n+                invokeListObjectsV2(\n+                    ListObjectsArgs.builder()\n+                        .bucket(args.bucketName())\n+                        .continuationToken(continuationToken)\n+                        .delimiter(delimiter)\n+                        .fetchOwner(args.fetchOwner())\n+                        .prefix(args.prefix())\n+                        .includeUserMetadata(args.includeUserMetadata())\n+                        .build());\n           }\n         };\n       }\n     };\n   }\n \n-  private Iterable<Result<Item>> listObjectsV1(\n-      final String bucketName, final String prefix, final boolean recursive) {\n+  private Iterable<Result<Item>> listObjectsV1(ListObjectsArgs args) {\n     return new Iterable<Result<Item>>() {\n       @Override\n       public Iterator<Result<Item>> iterator() {\n-        return new Iterator<Result<Item>>() {\n-          private String lastObjectName;\n-          private ListBucketResultV1 listBucketResult;\n-          private Result<Item> error;\n-          private Iterator<Item> itemIterator;\n-          private Iterator<Prefix> prefixIterator;\n-          private boolean completed = false;\n-\n-          private synchronized void populate() {\n+        return new ObjectIterator() {\n+          @Override\n+          protected void populateResult()\n+              throws InvalidKeyException, InvalidBucketNameException, IllegalArgumentException,\n+                  NoSuchAlgorithmException, InsufficientDataException, XmlParserException,\n+                  ErrorResponseException, InternalException, InvalidResponseException, IOException {\n             String delimiter = \"/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "365c8e88134965876e63f4a3393206faec356712"}, "originalPosition": 401}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aed7807c0f6bd82978466d0fbded2c1a34ec95fc", "author": {"user": {"login": "anjalshireesh", "name": "Shireesh Anjal"}}, "url": "https://github.com/minio/minio-java/commit/aed7807c0f6bd82978466d0fbded2c1a34ec95fc", "committedDate": "2020-05-19T11:13:00Z", "message": "Implement Args builder for listObjects API\n\nAdded the new args class `ListObjectsArgs` to be used with the\nlistObjects API. Example usage:\n\n```\nIterable<Result<Item>> results = minioClient.listObjects(\n  ListObjectsArgs.builder().\n    bucket(\"my-bucketname\").\n    includeUserMetadata(true).\n    startAfter(\"start-after-entry\").\n    prefix(\"my-obj\").\n    maxKeys(100).\n    fetchOwner(true)\n  );\n```\n\nAlso refactored some of the existing code to reduce duplication of code:\n\n- Extract common part of the result of both V1 and V2 API into\n`ListBucketResult`, and made the two specific classes\n(`ListBucketResultV1` and `ListBucketResultV2`) extend from it. The main\ndifference between the two is the naming of the continuation token\n(`continuationToken` in V2 vs `marker` in V1). Since this is only a\nnaming difference, both results can be treated the same way by\nabstracting out the methods related to these result fields.\n\n- Similarly, most of the logic of the iterators for the response of V1\nand V2 was also common. Extracted it out into a new abstract class\ncalled `ObjectIterator`."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67b97d80de0417e56195cf349c315737f14bc9b5", "author": {"user": {"login": "anjalshireesh", "name": "Shireesh Anjal"}}, "url": "https://github.com/minio/minio-java/commit/67b97d80de0417e56195cf349c315737f14bc9b5", "committedDate": "2020-05-19T11:13:00Z", "message": "Few improvements in ListObjectsArgs\n\n- `startAfter` is used in `ListObjectsV2` and `marker` is used in\n  `ListObjectV1`, but both serve same functionality. So removed `marker`\n  and started using `startAfter` in both places.\n- Better syntax in javadoc comment for `MinioClient#listObjects`\n- Use delimiter from args instead of hard coding to \"/\"\n- Add documentation in API.md"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "365c8e88134965876e63f4a3393206faec356712", "author": {"user": {"login": "anjalshireesh", "name": "Shireesh Anjal"}}, "url": "https://github.com/minio/minio-java/commit/365c8e88134965876e63f4a3393206faec356712", "committedDate": "2020-05-18T09:40:57Z", "message": "Implement Args builder for listObjects API\n\nAdded the new args class `ListObjectsArgs` to be used with the\nlistObjects API. Example usage:\n\n```\nIterable<Result<Item>> results = minioClient.listObjects(\n  ListObjectsArgs.builder().\n    bucket(\"my-bucketname\").\n    includeUserMetadata(true).\n    startAfter(\"start-after-entry\").\n    prefix(\"my-obj\").\n    maxKeys(100).\n    fetchOwner(true)\n  );\n```\n\nAlso refactored some of the existing code to reduce duplication of code:\n\n- Extract common part of the result of both V1 and V2 API into\n`ListBucketResult`, and made the two specific classes\n(`ListBucketResultV1` and `ListBucketResultV2`) extend from it. The main\ndifference between the two is the naming of the continuation token\n(`continuationToken` in V2 vs `marker` in V1). Since this is only a\nnaming difference, both results can be treated the same way by\nabstracting out the methods related to these result fields.\n\n- Similarly, most of the logic of the iterators for the response of V1\nand V2 was also common. Extracted it out into a new abstract class\ncalled `ObjectIterator`."}, "afterCommit": {"oid": "67b97d80de0417e56195cf349c315737f14bc9b5", "author": {"user": {"login": "anjalshireesh", "name": "Shireesh Anjal"}}, "url": "https://github.com/minio/minio-java/commit/67b97d80de0417e56195cf349c315737f14bc9b5", "committedDate": "2020-05-19T11:13:00Z", "message": "Few improvements in ListObjectsArgs\n\n- `startAfter` is used in `ListObjectsV2` and `marker` is used in\n  `ListObjectV1`, but both serve same functionality. So removed `marker`\n  and started using `startAfter` in both places.\n- Better syntax in javadoc comment for `MinioClient#listObjects`\n- Use delimiter from args instead of hard coding to \"/\"\n- Add documentation in API.md"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NTA0MDc3", "url": "https://github.com/minio/minio-java/pull/946#pullrequestreview-414504077", "createdAt": "2020-05-19T14:28:28Z", "commit": {"oid": "67b97d80de0417e56195cf349c315737f14bc9b5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NTg0NzQy", "url": "https://github.com/minio/minio-java/pull/946#pullrequestreview-414584742", "createdAt": "2020-05-19T15:47:57Z", "commit": {"oid": "67b97d80de0417e56195cf349c315737f14bc9b5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1894, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}