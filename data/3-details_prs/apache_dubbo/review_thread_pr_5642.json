{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxOTE0MDg5", "number": 5642, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODo0NzozNlrODdQEsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwOToyMjozNVrODdQuIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxOTk4NjQwOnYy", "diffSide": "RIGHT", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODo0NzozNlrOFlvtsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODo0NzozNlrOFlvtsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyMzM3Ng==", "bodyText": "\u8fd9\u91cc\u662f\u4e0d\u662f\u4e5f\u589e\u52a0\u4e00\u4e2agetObjectAttachment(xxx)", "url": "https://github.com/apache/dubbo/pull/5642#discussion_r375123376", "createdAt": "2020-02-05T08:47:36Z", "author": {"login": "cvictory"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java", "diffHunk": "@@ -97,8 +97,8 @@ public URL getUrl() {\n         }\n \n         List<Invoker<T>> result = invokers;\n-        String tag = StringUtils.isEmpty((String) invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n-                (String) invocation.getAttachment(TAG_KEY);\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34a8ba9bf0e8aa5ad0a9232ba57b05e1aca58bb8"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxOTk4ODAzOnYy", "diffSide": "RIGHT", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODo0ODoxMlrOFlvusg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODo0ODoxMlrOFlvusg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyMzYzNA==", "bodyText": "\u540c\u4e0a", "url": "https://github.com/apache/dubbo/pull/5642#discussion_r375123634", "createdAt": "2020-02-05T08:48:12Z", "author": {"login": "cvictory"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java", "diffHunk": "@@ -163,8 +163,8 @@ public URL getUrl() {\n     private <T> List<Invoker<T>> filterUsingStaticTag(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n         List<Invoker<T>> result = invokers;\n         // Dynamic param\n-        String tag = StringUtils.isEmpty((String) invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n-                (String) invocation.getAttachment(TAG_KEY);\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34a8ba9bf0e8aa5ad0a9232ba57b05e1aca58bb8"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDAxMTk2OnYy", "diffSide": "RIGHT", "path": "dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODo1NTo1MlrOFlv83w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwODo0MjoxM1rOFndqCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNzI2Mw==", "bodyText": "\u8fd9\u4e2a\u8fd4\u56denull\u8fd8\u662f\u7a7amap\uff1f", "url": "https://github.com/apache/dubbo/pull/5642#discussion_r375127263", "createdAt": "2020-02-05T08:55:52Z", "author": {"login": "cvictory"}, "path": "dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java", "diffHunk": "@@ -68,6 +68,21 @@ default Object get(Object key) {\n         return null;\n     }\n \n+    @Override\n+    default Map<String, Object> getObjectAttachments() {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f696de60446c93f6c3972be775e6434c939b1665"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkyNDY4MA==", "bodyText": "\u6211\u7ed9\u6539\u4e3a empty map \u5427\uff0c\u4e0d\u8fc7\u5b9e\u9645\u4e0a alibaba.invocation \u662f\u4e0d\u4f1a\u7528\u5230 ObjectAttachment \u63a5\u53e3\u7684", "url": "https://github.com/apache/dubbo/pull/5642#discussion_r376924680", "createdAt": "2020-02-10T08:42:13Z", "author": {"login": "chickenlj"}, "path": "dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java", "diffHunk": "@@ -68,6 +68,21 @@ default Object get(Object key) {\n         return null;\n     }\n \n+    @Override\n+    default Map<String, Object> getObjectAttachments() {\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNzI2Mw=="}, "originalCommit": {"oid": "f696de60446c93f6c3972be775e6434c939b1665"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDAyNDU3OnYy", "diffSide": "RIGHT", "path": "dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Result.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwOTowMDowMlrOFlwEqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwOTowMDowMlrOFlwEqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyOTI1Ng==", "bodyText": "\u7a7a\u4f1a\u4e0d\u4f1a\u6709\u5f71\u54cd\uff1f", "url": "https://github.com/apache/dubbo/pull/5642#discussion_r375129256", "createdAt": "2020-02-05T09:00:02Z", "author": {"login": "cvictory"}, "path": "dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Result.java", "diffHunk": "@@ -38,6 +38,31 @@ default void setException(Throwable t) {\n \n     }\n \n+    @Override\n+    default Map<String, Object> getObjectAttachments() {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f696de60446c93f6c3972be775e6434c939b1665"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDA0NjM5OnYy", "diffSide": "RIGHT", "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AttachmentsAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwOTowNzo1NVrOFlwSUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTowMDo1MVrOFneKfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEzMjc1Mg==", "bodyText": "\u8fd9\u4e2a\u7c7b\u662f\u4e0d\u662f\u53ef\u4ee5\u5220\u9664\uff1f", "url": "https://github.com/apache/dubbo/pull/5642#discussion_r375132752", "createdAt": "2020-02-05T09:07:55Z", "author": {"login": "cvictory"}, "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AttachmentsAdapter.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class AttachmentsAdapter {\n+\n+    public static class ObjectToStringMap extends HashMap<String, String> {\n+        private Map<String, Object> attachments;\n+\n+        public ObjectToStringMap(Map<String, Object> attachments) {\n+            this.attachments = attachments;\n+        }\n+\n+        @Override\n+        public String get(Object key) {\n+            Object obj = attachments.get(key);\n+            return convert(obj);\n+        }\n+\n+        @Override\n+        public String put(String key, String value) {\n+            Object obj = attachments.put(key, value);\n+            return convert(obj);\n+        }\n+\n+        @Override\n+        public String remove(Object key) {\n+            Object obj = attachments.remove(key);\n+            return convert(obj);\n+        }\n+\n+        private String convert(Object obj) {\n+            if (obj instanceof String) {\n+                return (String) obj;\n+            }\n+            return null; // or JSON.toString(obj);\n+        }\n+    }\n+\n+    public static class StringToObjectMap extends HashMap<String, Object> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f696de60446c93f6c3972be775e6434c939b1665"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzMjk4OA==", "bodyText": "\u6211\u89c9\u5f97\u6211\u4eec\u53ef\u4ee5\u6682\u4e14\u628a\u5b83\u7559\u5728\u8fd9\u91cc\uff0c\u53ef\u80fd\u6709\u4e00\u4e9b String \u5230 Object \u8f6c\u6362\u7684\u573a\u666f", "url": "https://github.com/apache/dubbo/pull/5642#discussion_r376932988", "createdAt": "2020-02-10T09:00:51Z", "author": {"login": "chickenlj"}, "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AttachmentsAdapter.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class AttachmentsAdapter {\n+\n+    public static class ObjectToStringMap extends HashMap<String, String> {\n+        private Map<String, Object> attachments;\n+\n+        public ObjectToStringMap(Map<String, Object> attachments) {\n+            this.attachments = attachments;\n+        }\n+\n+        @Override\n+        public String get(Object key) {\n+            Object obj = attachments.get(key);\n+            return convert(obj);\n+        }\n+\n+        @Override\n+        public String put(String key, String value) {\n+            Object obj = attachments.put(key, value);\n+            return convert(obj);\n+        }\n+\n+        @Override\n+        public String remove(Object key) {\n+            Object obj = attachments.remove(key);\n+            return convert(obj);\n+        }\n+\n+        private String convert(Object obj) {\n+            if (obj instanceof String) {\n+                return (String) obj;\n+            }\n+            return null; // or JSON.toString(obj);\n+        }\n+    }\n+\n+    public static class StringToObjectMap extends HashMap<String, Object> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEzMjc1Mg=="}, "originalCommit": {"oid": "f696de60446c93f6c3972be775e6434c939b1665"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDA2ODA4OnYy", "diffSide": "RIGHT", "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AppResponse.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwOToxNToxMlrOFlwfug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwODo0NTo0OFrOFndwPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEzNjE4Ng==", "bodyText": "\u8fd9\u91cc\u662f\u4e0d\u662f\u9700\u8981\u52a0\u4e0a\u7a7a\u5b57\u7b26\u7684\u5224\u65ad\uff0c\u539f\u6765\u7684\u903b\u8f91\u91cc\u6709\u3002", "url": "https://github.com/apache/dubbo/pull/5642#discussion_r375136186", "createdAt": "2020-02-05T09:15:12Z", "author": {"login": "cvictory"}, "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AppResponse.java", "diffHunk": "@@ -127,34 +132,72 @@ public boolean hasException() {\n      * @param map contains all key-value pairs to append\n      */\n     public void setAttachments(Map<String, String> map) {\n-        this.attachments = map == null ? new HashMap<String, String>() : map;\n+        this.attachments = map == null ? new HashMap<>() : new HashMap<>(map);\n+    }\n+\n+    @Override\n+    public void setObjectAttachments(Map<String, Object> map) {\n+        this.attachments = map == null ? new HashMap<>() : map;\n     }\n \n     public void addAttachments(Map<String, String> map) {\n         if (map == null) {\n             return;\n         }\n         if (this.attachments == null) {\n-            this.attachments = new HashMap<String, String>();\n+            this.attachments = new HashMap<>();\n+        }\n+        this.attachments.putAll(map);\n+    }\n+\n+    @Override\n+    public void addObjectAttachments(Map<String, Object> map) {\n+        if (map == null) {\n+            return;\n+        }\n+        if (this.attachments == null) {\n+            this.attachments = new HashMap<>();\n         }\n         this.attachments.putAll(map);\n     }\n \n     @Override\n     public String getAttachment(String key) {\n+        Object value = attachments.get(key);\n+        if (value instanceof String) {\n+            return (String) value;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Object getObjectAttachment(String key) {\n         return attachments.get(key);\n     }\n \n     @Override\n     public String getAttachment(String key, String defaultValue) {\n-        String result = attachments.get(key);\n-        if (result == null || result.length() == 0) {\n+        Object result = attachments.get(key);\n+        if (result == null) {\n+            return defaultValue;\n+        }\n+        if (result instanceof String) {\n+            return (String) result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f696de60446c93f6c3972be775e6434c939b1665"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkyNjI2OA==", "bodyText": "\u4e0a\u9762\u5df2\u7ecf\u6709 null \u5224\u65ad\u4e86", "url": "https://github.com/apache/dubbo/pull/5642#discussion_r376926268", "createdAt": "2020-02-10T08:45:48Z", "author": {"login": "chickenlj"}, "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AppResponse.java", "diffHunk": "@@ -127,34 +132,72 @@ public boolean hasException() {\n      * @param map contains all key-value pairs to append\n      */\n     public void setAttachments(Map<String, String> map) {\n-        this.attachments = map == null ? new HashMap<String, String>() : map;\n+        this.attachments = map == null ? new HashMap<>() : new HashMap<>(map);\n+    }\n+\n+    @Override\n+    public void setObjectAttachments(Map<String, Object> map) {\n+        this.attachments = map == null ? new HashMap<>() : map;\n     }\n \n     public void addAttachments(Map<String, String> map) {\n         if (map == null) {\n             return;\n         }\n         if (this.attachments == null) {\n-            this.attachments = new HashMap<String, String>();\n+            this.attachments = new HashMap<>();\n+        }\n+        this.attachments.putAll(map);\n+    }\n+\n+    @Override\n+    public void addObjectAttachments(Map<String, Object> map) {\n+        if (map == null) {\n+            return;\n+        }\n+        if (this.attachments == null) {\n+            this.attachments = new HashMap<>();\n         }\n         this.attachments.putAll(map);\n     }\n \n     @Override\n     public String getAttachment(String key) {\n+        Object value = attachments.get(key);\n+        if (value instanceof String) {\n+            return (String) value;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Object getObjectAttachment(String key) {\n         return attachments.get(key);\n     }\n \n     @Override\n     public String getAttachment(String key, String defaultValue) {\n-        String result = attachments.get(key);\n-        if (result == null || result.length() == 0) {\n+        Object result = attachments.get(key);\n+        if (result == null) {\n+            return defaultValue;\n+        }\n+        if (result instanceof String) {\n+            return (String) result;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEzNjE4Ng=="}, "originalCommit": {"oid": "f696de60446c93f6c3972be775e6434c939b1665"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDA5MjUwOnYy", "diffSide": "RIGHT", "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwOToyMjozNVrOFlwuZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwOToyMjozNVrOFlwuZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEzOTk0MA==", "bodyText": "\u6574\u4e2a\u7c7b\u7684\u6587\u4ef6\u90fd\u53d8\u5316\u4e86\uff0c\u6539\u52a8\u70b9\u5f88\u96be\u770b\u6e05\u3002", "url": "https://github.com/apache/dubbo/pull/5642#discussion_r375139940", "createdAt": "2020-02-05T09:22:35Z", "author": {"login": "cvictory"}, "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java", "diffHunk": "@@ -1,766 +1,806 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.dubbo.rpc;\r\n-\r\n-import org.apache.dubbo.common.URL;\r\n-import org.apache.dubbo.common.threadlocal.InternalThreadLocal;\r\n-import org.apache.dubbo.common.utils.CollectionUtils;\r\n-import org.apache.dubbo.common.utils.NetUtils;\r\n-import org.apache.dubbo.common.utils.StringUtils;\r\n-\r\n-import java.net.InetSocketAddress;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.concurrent.Callable;\r\n-import java.util.concurrent.CompletableFuture;\r\n-import java.util.concurrent.ExecutionException;\r\n-import java.util.concurrent.Future;\r\n-import java.util.concurrent.TimeUnit;\r\n-import java.util.concurrent.TimeoutException;\r\n-\r\n-import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;\r\n-import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;\r\n-import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\r\n-import static org.apache.dubbo.rpc.Constants.ASYNC_KEY;\r\n-import static org.apache.dubbo.rpc.Constants.RETURN_KEY;\r\n-\r\n-\r\n-/**\r\n- * Thread local context. (API, ThreadLocal, ThreadSafe)\r\n- * <p>\r\n- * Note: RpcContext is a temporary state holder. States in RpcContext changes every time when request is sent or received.\r\n- * For example: A invokes B, then B invokes C. On service B, RpcContext saves invocation info from A to B before B\r\n- * starts invoking C, and saves invocation info from B to C after B invokes C.\r\n- *\r\n- * @export\r\n- * @see org.apache.dubbo.rpc.filter.ContextFilter\r\n- */\r\n-public class RpcContext {\r\n-\r\n-    /**\r\n-     * use internal thread local to improve performance\r\n-     */\r\n-    // FIXME REQUEST_CONTEXT\r\n-    private static final InternalThreadLocal<RpcContext> LOCAL = new InternalThreadLocal<RpcContext>() {\r\n-        @Override\r\n-        protected RpcContext initialValue() {\r\n-            return new RpcContext();\r\n-        }\r\n-    };\r\n-\r\n-    // FIXME RESPONSE_CONTEXT\r\n-    private static final InternalThreadLocal<RpcContext> SERVER_LOCAL = new InternalThreadLocal<RpcContext>() {\r\n-        @Override\r\n-        protected RpcContext initialValue() {\r\n-            return new RpcContext();\r\n-        }\r\n-    };\r\n-\r\n-    private final Map<String, String> attachments = new HashMap<String, String>();\r\n-    private final Map<String, Object> values = new HashMap<String, Object>();\r\n-\r\n-    private List<URL> urls;\r\n-\r\n-    private URL url;\r\n-\r\n-    private String methodName;\r\n-\r\n-    private Class<?>[] parameterTypes;\r\n-\r\n-    private Object[] arguments;\r\n-\r\n-    private InetSocketAddress localAddress;\r\n-\r\n-    private InetSocketAddress remoteAddress;\r\n-\r\n-    private String remoteApplicationName;\r\n-\r\n-    @Deprecated\r\n-    private List<Invoker<?>> invokers;\r\n-    @Deprecated\r\n-    private Invoker<?> invoker;\r\n-    @Deprecated\r\n-    private Invocation invocation;\r\n-\r\n-    // now we don't use the 'values' map to hold these objects\r\n-    // we want these objects to be as generic as possible\r\n-    private Object request;\r\n-    private Object response;\r\n-    private AsyncContext asyncContext;\r\n-\r\n-    private boolean remove = true;\r\n-\r\n-\r\n-    protected RpcContext() {\r\n-    }\r\n-\r\n-    /**\r\n-     * get server side context.\r\n-     *\r\n-     * @return server context\r\n-     */\r\n-    public static RpcContext getServerContext() {\r\n-        return SERVER_LOCAL.get();\r\n-    }\r\n-\r\n-    public static void restoreServerContext(RpcContext oldServerContext) {\r\n-        SERVER_LOCAL.set(oldServerContext);\r\n-    }\r\n-\r\n-    /**\r\n-     * remove server side context.\r\n-     *\r\n-     * @see org.apache.dubbo.rpc.filter.ContextFilter\r\n-     */\r\n-    public static void removeServerContext() {\r\n-        SERVER_LOCAL.remove();\r\n-    }\r\n-\r\n-    /**\r\n-     * get context.\r\n-     *\r\n-     * @return context\r\n-     */\r\n-    public static RpcContext getContext() {\r\n-        return LOCAL.get();\r\n-    }\r\n-\r\n-    public boolean canRemove() {\r\n-        return remove;\r\n-    }\r\n-\r\n-    public void clearAfterEachInvoke(boolean remove) {\r\n-        this.remove = remove;\r\n-    }\r\n-\r\n-    public static void restoreContext(RpcContext oldContext) {\r\n-        LOCAL.set(oldContext);\r\n-    }\r\n-\r\n-    /**\r\n-     * remove context.\r\n-     *\r\n-     * @see org.apache.dubbo.rpc.filter.ContextFilter\r\n-     */\r\n-    public static void removeContext() {\r\n-        if (LOCAL.get().canRemove()) {\r\n-            LOCAL.remove();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the request object of the underlying RPC protocol, e.g. HttpServletRequest\r\n-     *\r\n-     * @return null if the underlying protocol doesn't provide support for getting request\r\n-     */\r\n-    public Object getRequest() {\r\n-        return request;\r\n-    }\r\n-\r\n-    public void setRequest(Object request) {\r\n-        this.request = request;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the request object of the underlying RPC protocol, e.g. HttpServletRequest\r\n-     *\r\n-     * @return null if the underlying protocol doesn't provide support for getting request or the request is not of the specified type\r\n-     */\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    public <T> T getRequest(Class<T> clazz) {\r\n-        return (request != null && clazz.isAssignableFrom(request.getClass())) ? (T) request : null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the response object of the underlying RPC protocol, e.g. HttpServletResponse\r\n-     *\r\n-     * @return null if the underlying protocol doesn't provide support for getting response\r\n-     */\r\n-    public Object getResponse() {\r\n-        return response;\r\n-    }\r\n-\r\n-    public void setResponse(Object response) {\r\n-        this.response = response;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the response object of the underlying RPC protocol, e.g. HttpServletResponse\r\n-     *\r\n-     * @return null if the underlying protocol doesn't provide support for getting response or the response is not of the specified type\r\n-     */\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    public <T> T getResponse(Class<T> clazz) {\r\n-        return (response != null && clazz.isAssignableFrom(response.getClass())) ? (T) response : null;\r\n-    }\r\n-\r\n-    /**\r\n-     * is provider side.\r\n-     *\r\n-     * @return provider side.\r\n-     */\r\n-    public boolean isProviderSide() {\r\n-        return !isConsumerSide();\r\n-    }\r\n-\r\n-    /**\r\n-     * is consumer side.\r\n-     *\r\n-     * @return consumer side.\r\n-     */\r\n-    public boolean isConsumerSide() {\r\n-        return getUrl().getParameter(SIDE_KEY, PROVIDER_SIDE).equals(CONSUMER_SIDE);\r\n-    }\r\n-\r\n-    /**\r\n-     * get CompletableFuture.\r\n-     *\r\n-     * @param <T>\r\n-     * @return future\r\n-     */\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    public <T> CompletableFuture<T> getCompletableFuture() {\r\n-        return FutureContext.getContext().getCompletableFuture();\r\n-    }\r\n-\r\n-    /**\r\n-     * get future.\r\n-     *\r\n-     * @param <T>\r\n-     * @return future\r\n-     */\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    public <T> Future<T> getFuture() {\r\n-        return FutureContext.getContext().getCompletableFuture();\r\n-    }\r\n-\r\n-    /**\r\n-     * set future.\r\n-     *\r\n-     * @param future\r\n-     */\r\n-    public void setFuture(CompletableFuture<?> future) {\r\n-        FutureContext.getContext().setFuture(future);\r\n-    }\r\n-\r\n-    public List<URL> getUrls() {\r\n-        return urls == null && url != null ? (List<URL>) Arrays.asList(url) : urls;\r\n-    }\r\n-\r\n-    public void setUrls(List<URL> urls) {\r\n-        this.urls = urls;\r\n-    }\r\n-\r\n-    public URL getUrl() {\r\n-        return url;\r\n-    }\r\n-\r\n-    public void setUrl(URL url) {\r\n-        this.url = url;\r\n-    }\r\n-\r\n-    /**\r\n-     * get method name.\r\n-     *\r\n-     * @return method name.\r\n-     */\r\n-    public String getMethodName() {\r\n-        return methodName;\r\n-    }\r\n-\r\n-    public void setMethodName(String methodName) {\r\n-        this.methodName = methodName;\r\n-    }\r\n-\r\n-    /**\r\n-     * get parameter types.\r\n-     *\r\n-     * @serial\r\n-     */\r\n-    public Class<?>[] getParameterTypes() {\r\n-        return parameterTypes;\r\n-    }\r\n-\r\n-    public void setParameterTypes(Class<?>[] parameterTypes) {\r\n-        this.parameterTypes = parameterTypes;\r\n-    }\r\n-\r\n-    /**\r\n-     * get arguments.\r\n-     *\r\n-     * @return arguments.\r\n-     */\r\n-    public Object[] getArguments() {\r\n-        return arguments;\r\n-    }\r\n-\r\n-    public void setArguments(Object[] arguments) {\r\n-        this.arguments = arguments;\r\n-    }\r\n-\r\n-    /**\r\n-     * set local address.\r\n-     *\r\n-     * @param host\r\n-     * @param port\r\n-     * @return context\r\n-     */\r\n-    public RpcContext setLocalAddress(String host, int port) {\r\n-        if (port < 0) {\r\n-            port = 0;\r\n-        }\r\n-        this.localAddress = InetSocketAddress.createUnresolved(host, port);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * get local address.\r\n-     *\r\n-     * @return local address\r\n-     */\r\n-    public InetSocketAddress getLocalAddress() {\r\n-        return localAddress;\r\n-    }\r\n-\r\n-    /**\r\n-     * set local address.\r\n-     *\r\n-     * @param address\r\n-     * @return context\r\n-     */\r\n-    public RpcContext setLocalAddress(InetSocketAddress address) {\r\n-        this.localAddress = address;\r\n-        return this;\r\n-    }\r\n-\r\n-    public String getLocalAddressString() {\r\n-        return getLocalHost() + \":\" + getLocalPort();\r\n-    }\r\n-\r\n-    /**\r\n-     * get local host name.\r\n-     *\r\n-     * @return local host name\r\n-     */\r\n-    public String getLocalHostName() {\r\n-        String host = localAddress == null ? null : localAddress.getHostName();\r\n-        if (StringUtils.isEmpty(host)) {\r\n-            return getLocalHost();\r\n-        }\r\n-        return host;\r\n-    }\r\n-\r\n-    /**\r\n-     * set remote address.\r\n-     *\r\n-     * @param host\r\n-     * @param port\r\n-     * @return context\r\n-     */\r\n-    public RpcContext setRemoteAddress(String host, int port) {\r\n-        if (port < 0) {\r\n-            port = 0;\r\n-        }\r\n-        this.remoteAddress = InetSocketAddress.createUnresolved(host, port);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * get remote address.\r\n-     *\r\n-     * @return remote address\r\n-     */\r\n-    public InetSocketAddress getRemoteAddress() {\r\n-        return remoteAddress;\r\n-    }\r\n-\r\n-    /**\r\n-     * set remote address.\r\n-     *\r\n-     * @param address\r\n-     * @return context\r\n-     */\r\n-    public RpcContext setRemoteAddress(InetSocketAddress address) {\r\n-        this.remoteAddress = address;\r\n-        return this;\r\n-    }\r\n-\r\n-    public String getRemoteApplicationName() {\r\n-        return remoteApplicationName;\r\n-    }\r\n-\r\n-    public RpcContext setRemoteApplicationName(String remoteApplicationName) {\r\n-        this.remoteApplicationName = remoteApplicationName;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * get remote address string.\r\n-     *\r\n-     * @return remote address string.\r\n-     */\r\n-    public String getRemoteAddressString() {\r\n-        return getRemoteHost() + \":\" + getRemotePort();\r\n-    }\r\n-\r\n-    /**\r\n-     * get remote host name.\r\n-     *\r\n-     * @return remote host name\r\n-     */\r\n-    public String getRemoteHostName() {\r\n-        return remoteAddress == null ? null : remoteAddress.getHostName();\r\n-    }\r\n-\r\n-    /**\r\n-     * get local host.\r\n-     *\r\n-     * @return local host\r\n-     */\r\n-    public String getLocalHost() {\r\n-        String host = localAddress == null ? null :\r\n-                localAddress.getAddress() == null ? localAddress.getHostName()\r\n-                        : NetUtils.filterLocalHost(localAddress.getAddress().getHostAddress());\r\n-        if (host == null || host.length() == 0) {\r\n-            return NetUtils.getLocalHost();\r\n-        }\r\n-        return host;\r\n-    }\r\n-\r\n-    /**\r\n-     * get local port.\r\n-     *\r\n-     * @return port\r\n-     */\r\n-    public int getLocalPort() {\r\n-        return localAddress == null ? 0 : localAddress.getPort();\r\n-    }\r\n-\r\n-    /**\r\n-     * get remote host.\r\n-     *\r\n-     * @return remote host\r\n-     */\r\n-    public String getRemoteHost() {\r\n-        return remoteAddress == null ? null :\r\n-                remoteAddress.getAddress() == null ? remoteAddress.getHostName()\r\n-                        : NetUtils.filterLocalHost(remoteAddress.getAddress().getHostAddress());\r\n-    }\r\n-\r\n-    /**\r\n-     * get remote port.\r\n-     *\r\n-     * @return remote port\r\n-     */\r\n-    public int getRemotePort() {\r\n-        return remoteAddress == null ? 0 : remoteAddress.getPort();\r\n-    }\r\n-\r\n-    /**\r\n-     * get attachment.\r\n-     *\r\n-     * @param key\r\n-     * @return attachment\r\n-     */\r\n-    public String getAttachment(String key) {\r\n-        return attachments.get(key);\r\n-    }\r\n-\r\n-    /**\r\n-     * set attachment.\r\n-     *\r\n-     * @param key\r\n-     * @param value\r\n-     * @return context\r\n-     */\r\n-    public RpcContext setAttachment(String key, String value) {\r\n-        if (value == null) {\r\n-            attachments.remove(key);\r\n-        } else {\r\n-            attachments.put(key, value);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * remove attachment.\r\n-     *\r\n-     * @param key\r\n-     * @return context\r\n-     */\r\n-    public RpcContext removeAttachment(String key) {\r\n-        attachments.remove(key);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * get attachments.\r\n-     *\r\n-     * @return attachments\r\n-     */\r\n-    public Map<String, String> getAttachments() {\r\n-        return attachments;\r\n-    }\r\n-\r\n-    /**\r\n-     * set attachments\r\n-     *\r\n-     * @param attachment\r\n-     * @return context\r\n-     */\r\n-    public RpcContext setAttachments(Map<String, String> attachment) {\r\n-        this.attachments.clear();\r\n-        if (attachment != null && attachment.size() > 0) {\r\n-            this.attachments.putAll(attachment);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    public void clearAttachments() {\r\n-        this.attachments.clear();\r\n-    }\r\n-\r\n-    /**\r\n-     * get values.\r\n-     *\r\n-     * @return values\r\n-     */\r\n-    public Map<String, Object> get() {\r\n-        return values;\r\n-    }\r\n-\r\n-    /**\r\n-     * set value.\r\n-     *\r\n-     * @param key\r\n-     * @param value\r\n-     * @return context\r\n-     */\r\n-    public RpcContext set(String key, Object value) {\r\n-        if (value == null) {\r\n-            values.remove(key);\r\n-        } else {\r\n-            values.put(key, value);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * remove value.\r\n-     *\r\n-     * @param key\r\n-     * @return value\r\n-     */\r\n-    public RpcContext remove(String key) {\r\n-        values.remove(key);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * get value.\r\n-     *\r\n-     * @param key\r\n-     * @return value\r\n-     */\r\n-    public Object get(String key) {\r\n-        return values.get(key);\r\n-    }\r\n-\r\n-    /**\r\n-     * @deprecated Replace to isProviderSide()\r\n-     */\r\n-    @Deprecated\r\n-    public boolean isServerSide() {\r\n-        return isProviderSide();\r\n-    }\r\n-\r\n-    /**\r\n-     * @deprecated Replace to isConsumerSide()\r\n-     */\r\n-    @Deprecated\r\n-    public boolean isClientSide() {\r\n-        return isConsumerSide();\r\n-    }\r\n-\r\n-    /**\r\n-     * @deprecated Replace to getUrls()\r\n-     */\r\n-    @Deprecated\r\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\r\n-    public List<Invoker<?>> getInvokers() {\r\n-        return invokers == null && invoker != null ? (List) Arrays.asList(invoker) : invokers;\r\n-    }\r\n-\r\n-    public RpcContext setInvokers(List<Invoker<?>> invokers) {\r\n-        this.invokers = invokers;\r\n-        if (CollectionUtils.isNotEmpty(invokers)) {\r\n-            List<URL> urls = new ArrayList<URL>(invokers.size());\r\n-            for (Invoker<?> invoker : invokers) {\r\n-                urls.add(invoker.getUrl());\r\n-            }\r\n-            setUrls(urls);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * @deprecated Replace to getUrl()\r\n-     */\r\n-    @Deprecated\r\n-    public Invoker<?> getInvoker() {\r\n-        return invoker;\r\n-    }\r\n-\r\n-    public RpcContext setInvoker(Invoker<?> invoker) {\r\n-        this.invoker = invoker;\r\n-        if (invoker != null) {\r\n-            setUrl(invoker.getUrl());\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * @deprecated Replace to getMethodName(), getParameterTypes(), getArguments()\r\n-     */\r\n-    @Deprecated\r\n-    public Invocation getInvocation() {\r\n-        return invocation;\r\n-    }\r\n-\r\n-    public RpcContext setInvocation(Invocation invocation) {\r\n-        this.invocation = invocation;\r\n-        if (invocation != null) {\r\n-            setMethodName(invocation.getMethodName());\r\n-            setParameterTypes(invocation.getParameterTypes());\r\n-            setArguments(invocation.getArguments());\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * Async invocation. Timeout will be handled even if <code>Future.get()</code> is not called.\r\n-     *\r\n-     * @param callable\r\n-     * @return get the return result from <code>future.get()</code>\r\n-     */\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    public <T> CompletableFuture<T> asyncCall(Callable<T> callable) {\r\n-        try {\r\n-            try {\r\n-                setAttachment(ASYNC_KEY, Boolean.TRUE.toString());\r\n-                final T o = callable.call();\r\n-                //local invoke will return directly\r\n-                if (o != null) {\r\n-                    if (o instanceof CompletableFuture) {\r\n-                        return (CompletableFuture<T>) o;\r\n-                    }\r\n-                    return CompletableFuture.completedFuture(o);\r\n-                } else {\r\n-                    // The service has a normal sync method signature, should get future from RpcContext.\r\n-                }\r\n-            } catch (Exception e) {\r\n-                throw new RpcException(e);\r\n-            } finally {\r\n-                removeAttachment(ASYNC_KEY);\r\n-            }\r\n-        } catch (final RpcException e) {\r\n-            return new CompletableFuture<T>() {\r\n-                @Override\r\n-                public boolean cancel(boolean mayInterruptIfRunning) {\r\n-                    return false;\r\n-                }\r\n-\r\n-                @Override\r\n-                public boolean isCancelled() {\r\n-                    return false;\r\n-                }\r\n-\r\n-                @Override\r\n-                public boolean isDone() {\r\n-                    return true;\r\n-                }\r\n-\r\n-                @Override\r\n-                public T get() throws InterruptedException, ExecutionException {\r\n-                    throw new ExecutionException(e.getCause());\r\n-                }\r\n-\r\n-                @Override\r\n-                public T get(long timeout, TimeUnit unit)\r\n-                        throws InterruptedException, ExecutionException,\r\n-                        TimeoutException {\r\n-                    return get();\r\n-                }\r\n-            };\r\n-        }\r\n-        return ((CompletableFuture<T>) getContext().getFuture());\r\n-    }\r\n-\r\n-    /**\r\n-     * one way async call, send request only, and result is not required\r\n-     *\r\n-     * @param runnable\r\n-     */\r\n-    public void asyncCall(Runnable runnable) {\r\n-        try {\r\n-            setAttachment(RETURN_KEY, Boolean.FALSE.toString());\r\n-            runnable.run();\r\n-        } catch (Throwable e) {\r\n-            // FIXME should put exception in future?\r\n-            throw new RpcException(\"oneway call error .\" + e.getMessage(), e);\r\n-        } finally {\r\n-            removeAttachment(RETURN_KEY);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return\r\n-     * @throws IllegalStateException\r\n-     */\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    public static AsyncContext startAsync() throws IllegalStateException {\r\n-        RpcContext currentContext = getContext();\r\n-        if (currentContext.asyncContext == null) {\r\n-            currentContext.asyncContext = new AsyncContextImpl();\r\n-        }\r\n-        currentContext.asyncContext.start();\r\n-        return currentContext.asyncContext;\r\n-    }\r\n-\r\n-    protected void setAsyncContext(AsyncContext asyncContext) {\r\n-        this.asyncContext = asyncContext;\r\n-    }\r\n-\r\n-    public boolean isAsyncStarted() {\r\n-        if (this.asyncContext == null) {\r\n-            return false;\r\n-        }\r\n-        return asyncContext.isAsyncStarted();\r\n-    }\r\n-\r\n-    public boolean stopAsync() {\r\n-        return asyncContext.stop();\r\n-    }\r\n-\r\n-    public AsyncContext getAsyncContext() {\r\n-        return asyncContext;\r\n-    }\r\n-\r\n-}\r\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f696de60446c93f6c3972be775e6434c939b1665"}, "originalPosition": 767}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2083, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}