{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgzNDM3ODk3", "number": 6720, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNFQwMjoyMjoyMVrOFxyGxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xMVQwMjowMjozOFrOGJMYuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg3NzQ1NDc5OnYy", "diffSide": "RIGHT", "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProxyProtocol.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNFQwMjoyMjoyMVrOJIgAGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNFQwMjoyMjoyMVrOJIgAGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg5MjY5OA==", "bodyText": "please recover file endline format of this file", "url": "https://github.com/apache/dubbo/pull/6720#discussion_r612892698", "createdAt": "2021-04-14T02:22:21Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProxyProtocol.java", "diffHunk": "@@ -1,281 +1,279 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-\r\n-package org.apache.dubbo.rpc.protocol;\r\n-\r\n-import org.apache.dubbo.common.Parameters;\r\n-import org.apache.dubbo.common.URL;\r\n-import org.apache.dubbo.common.utils.NetUtils;\r\n-import org.apache.dubbo.common.utils.StringUtils;\r\n-import org.apache.dubbo.remoting.Channel;\r\n-import org.apache.dubbo.remoting.ChannelHandler;\r\n-import org.apache.dubbo.remoting.Constants;\r\n-import org.apache.dubbo.remoting.RemotingException;\r\n-import org.apache.dubbo.remoting.RemotingServer;\r\n-import org.apache.dubbo.rpc.Exporter;\r\n-import org.apache.dubbo.rpc.Invocation;\r\n-import org.apache.dubbo.rpc.Invoker;\r\n-import org.apache.dubbo.rpc.ProtocolServer;\r\n-import org.apache.dubbo.rpc.ProxyFactory;\r\n-import org.apache.dubbo.rpc.Result;\r\n-import org.apache.dubbo.rpc.RpcException;\r\n-\r\n-import java.net.InetSocketAddress;\r\n-import java.util.Collection;\r\n-import java.util.List;\r\n-import java.util.Objects;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_KEY;\r\n-import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;\r\n-\r\n-/**\r\n- * AbstractProxyProtocol\r\n- */\r\n-public abstract class AbstractProxyProtocol extends AbstractProtocol {\r\n-\r\n-    private final List<Class<?>> rpcExceptions = new CopyOnWriteArrayList<Class<?>>();\r\n-\r\n-    protected ProxyFactory proxyFactory;\r\n-\r\n-    public AbstractProxyProtocol() {\r\n-    }\r\n-\r\n-    public AbstractProxyProtocol(Class<?>... exceptions) {\r\n-        for (Class<?> exception : exceptions) {\r\n-            addRpcException(exception);\r\n-        }\r\n-    }\r\n-\r\n-    public void addRpcException(Class<?> exception) {\r\n-        this.rpcExceptions.add(exception);\r\n-    }\r\n-\r\n-    public ProxyFactory getProxyFactory() {\r\n-        return proxyFactory;\r\n-    }\r\n-\r\n-    public void setProxyFactory(ProxyFactory proxyFactory) {\r\n-        this.proxyFactory = proxyFactory;\r\n-    }\r\n-\r\n-    @Override\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {\r\n-        final String uri = serviceKey(invoker.getUrl());\r\n-        Exporter<T> exporter = (Exporter<T>) exporterMap.get(uri);\r\n-        if (exporter != null) {\r\n-            // When modifying the configuration through override, you need to re-expose the newly modified service.\r\n-            if (Objects.equals(exporter.getInvoker().getUrl(), invoker.getUrl())) {\r\n-                return exporter;\r\n-            }\r\n-        }\r\n-        final Runnable runnable = doExport(proxyFactory.getProxy(invoker, true), invoker.getInterface(), invoker.getUrl());\r\n-        exporter = new AbstractExporter<T>(invoker) {\r\n-            @Override\r\n-            public void afterUnExport() {\r\n-                exporterMap.remove(uri);\r\n-                if (runnable != null) {\r\n-                    try {\r\n-                        runnable.run();\r\n-                    } catch (Throwable t) {\r\n-                        logger.warn(t.getMessage(), t);\r\n-                    }\r\n-                }\r\n-            }\r\n-        };\r\n-        exporterMap.put(uri, exporter);\r\n-        return exporter;\r\n-    }\r\n-\r\n-    @Override\r\n-    protected <T> Invoker<T> protocolBindingRefer(final Class<T> type, final URL url) throws RpcException {\r\n-        final Invoker<T> target = proxyFactory.getInvoker(doRefer(type, url), type, url);\r\n-        Invoker<T> invoker = new AbstractInvoker<T>(type, url) {\r\n-            @Override\r\n-            protected Result doInvoke(Invocation invocation) throws Throwable {\r\n-                try {\r\n-                    Result result = target.invoke(invocation);\r\n-                    // FIXME result is an AsyncRpcResult instance.\r\n-                    Throwable e = result.getException();\r\n-                    if (e != null) {\r\n-                        for (Class<?> rpcException : rpcExceptions) {\r\n-                            if (rpcException.isAssignableFrom(e.getClass())) {\r\n-                                throw getRpcException(type, url, invocation, e);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    return result;\r\n-                } catch (RpcException e) {\r\n-                    if (e.getCode() == RpcException.UNKNOWN_EXCEPTION) {\r\n-                        e.setCode(getErrorCode(e.getCause()));\r\n-                    }\r\n-                    throw e;\r\n-                } catch (Throwable e) {\r\n-                    throw getRpcException(type, url, invocation, e);\r\n-                }\r\n-            }\r\n-\r\n-            @Override\r\n-            public void destroy() {\r\n-                super.destroy();\r\n-                target.destroy();\r\n-                invokers.remove(this);\r\n-            }\r\n-        };\r\n-        invokers.add(invoker);\r\n-        return invoker;\r\n-    }\r\n-\r\n-    protected RpcException getRpcException(Class<?> type, URL url, Invocation invocation, Throwable e) {\r\n-        RpcException re = new RpcException(\"Failed to invoke remote service: \" + type + \", method: \"\r\n-                + invocation.getMethodName() + \", cause: \" + e.getMessage(), e);\r\n-        re.setCode(getErrorCode(e));\r\n-        return re;\r\n-    }\r\n-\r\n-    protected String getAddr(URL url) {\r\n-        String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());\r\n-        if (url.getParameter(ANYHOST_KEY, false)) {\r\n-            bindIp = ANYHOST_VALUE;\r\n-        }\r\n-        return NetUtils.getIpByHost(bindIp) + \":\" + url.getParameter(Constants.BIND_PORT_KEY, url.getPort());\r\n-    }\r\n-\r\n-    protected int getErrorCode(Throwable e) {\r\n-        return RpcException.UNKNOWN_EXCEPTION;\r\n-    }\r\n-\r\n-    protected abstract <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException;\r\n-\r\n-    protected abstract <T> T doRefer(Class<T> type, URL url) throws RpcException;\r\n-\r\n-    protected class ProxyProtocolServer implements ProtocolServer {\r\n-\r\n-        private RemotingServer server;\r\n-        private String address;\r\n-\r\n-        public ProxyProtocolServer(RemotingServer server) {\r\n-            this.server = server;\r\n-        }\r\n-\r\n-        @Override\r\n-        public RemotingServer getRemotingServer() {\r\n-            return server;\r\n-        }\r\n-\r\n-        @Override\r\n-        public String getAddress() {\r\n-            return StringUtils.isNotEmpty(address) ? address : server.getUrl().getAddress();\r\n-        }\r\n-\r\n-        @Override\r\n-        public void setAddress(String address) {\r\n-            this.address = address;\r\n-        }\r\n-\r\n-        @Override\r\n-        public URL getUrl() {\r\n-            return server.getUrl();\r\n-        }\r\n-\r\n-        @Override\r\n-        public void close() {\r\n-            server.close();\r\n-        }\r\n-    }\r\n-\r\n-    protected abstract class RemotingServerAdapter implements RemotingServer {\r\n-\r\n-        public abstract Object getDelegateServer();\r\n-\r\n-        /**\r\n-         * @return\r\n-         */\r\n-        @Override\r\n-        public boolean isBound() {\r\n-            return false;\r\n-        }\r\n-\r\n-        @Override\r\n-        public Collection<Channel> getChannels() {\r\n-            return null;\r\n-        }\r\n-\r\n-        @Override\r\n-        public Channel getChannel(InetSocketAddress remoteAddress) {\r\n-            return null;\r\n-        }\r\n-\r\n-        @Override\r\n-        public void reset(Parameters parameters) {\r\n-\r\n-        }\r\n-\r\n-        @Override\r\n-        public void reset(URL url) {\r\n-\r\n-        }\r\n-\r\n-        @Override\r\n-        public URL getUrl() {\r\n-            return null;\r\n-        }\r\n-\r\n-        @Override\r\n-        public ChannelHandler getChannelHandler() {\r\n-            return null;\r\n-        }\r\n-\r\n-        @Override\r\n-        public InetSocketAddress getLocalAddress() {\r\n-            return null;\r\n-        }\r\n-\r\n-        @Override\r\n-        public void send(Object message) throws RemotingException {\r\n-\r\n-        }\r\n-\r\n-        @Override\r\n-        public void send(Object message, boolean sent) throws RemotingException {\r\n-\r\n-        }\r\n-\r\n-        @Override\r\n-        public void close() {\r\n-\r\n-        }\r\n-\r\n-        @Override\r\n-        public void close(int timeout) {\r\n-\r\n-        }\r\n-\r\n-        @Override\r\n-        public void startClose() {\r\n-\r\n-        }\r\n-\r\n-        @Override\r\n-        public boolean isClosed() {\r\n-            return false;\r\n-        }\r\n-    }\r\n-\r\n-\r\n-}\r\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "396a94ab3a1761634993e0778e0ce339a27c3135"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg3NzQ1NTE1OnYy", "diffSide": "RIGHT", "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/DelegateExporterMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNFQwMjoyMjozMVrOJIgASw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNFQwMjoyMjozMVrOJIgASw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg5Mjc0Nw==", "bodyText": "also for this file", "url": "https://github.com/apache/dubbo/pull/6720#discussion_r612892747", "createdAt": "2021-04-14T02:22:31Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/DelegateExporterMap.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "396a94ab3a1761634993e0778e0ce339a27c3135"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg3NzQ1NTU0OnYy", "diffSide": "RIGHT", "path": "dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNFQwMjoyMjo0NVrOJIgAjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNFQwMjoyMjo0NVrOJIgAjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg5MjgxMw==", "bodyText": "also", "url": "https://github.com/apache/dubbo/pull/6720#discussion_r612892813", "createdAt": "2021-04-14T02:22:45Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmExporter.java", "diffHunk": "@@ -1,46 +1,42 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.dubbo.rpc.protocol.injvm;\r\n-\r\n-import org.apache.dubbo.rpc.Exporter;\r\n-import org.apache.dubbo.rpc.Invoker;\r\n-import org.apache.dubbo.rpc.protocol.AbstractExporter;\r\n-\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * InjvmExporter\r\n- */\r\n-class InjvmExporter<T> extends AbstractExporter<T> {\r\n-\r\n-    private final String key;\r\n-\r\n-    private final Map<String, Exporter<?>> exporterMap;\r\n-\r\n-    InjvmExporter(Invoker<T> invoker, String key, Map<String, Exporter<?>> exporterMap) {\r\n-        super(invoker);\r\n-        this.key = key;\r\n-        this.exporterMap = exporterMap;\r\n-        exporterMap.put(key, this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void afterUnExport() {\r\n-        exporterMap.remove(key);\r\n-    }\r\n-\r\n-}\r\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "396a94ab3a1761634993e0778e0ce339a27c3135"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDExMjAzMjU5OnYy", "diffSide": "RIGHT", "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0wOVQwNDowNjowMVrOJp7tcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0wOVQwNDowNjowMVrOJp7tcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0Nzk0OTY4MQ==", "bodyText": "I think it's better to make DelegateExporterMap as AbstractProtocol's property than as its super interface.\nThat is, AbstractProtocol has a DelegateExporterMap rather is a DelegateExporterMap", "url": "https://github.com/apache/dubbo/pull/6720#discussion_r647949681", "createdAt": "2021-06-09T04:06:01Z", "author": {"login": "chickenlj"}, "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java", "diffHunk": "@@ -42,7 +43,7 @@\n /**\n  * abstract ProtocolSupport.\n  */\n-public abstract class AbstractProtocol implements Protocol {\n+public abstract class AbstractProtocol implements DelegateExporterMap, Protocol {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "793d10fe00300e2fcdeff0161e55803b90de6220"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyMjkzMzA3OnYy", "diffSide": "RIGHT", "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xMVQwMjowMjozOFrOJri0_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xMVQwMjowNToyOFrOJri37Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0OTYzOTE2NQ==", "bodyText": "Can we merge exporterMap and delegateExporterMap by defining DelegateExporterMap as a Map or have it referencing a map?", "url": "https://github.com/apache/dubbo/pull/6720#discussion_r649639165", "createdAt": "2021-06-11T02:02:38Z", "author": {"login": "chickenlj"}, "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java", "diffHunk": "@@ -1,116 +1,148 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.rpc.protocol;\n-\n-import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.logger.Logger;\n-import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.utils.ConcurrentHashSet;\n-import org.apache.dubbo.remoting.Constants;\n-import org.apache.dubbo.rpc.Exporter;\n-import org.apache.dubbo.rpc.Invoker;\n-import org.apache.dubbo.rpc.Protocol;\n-import org.apache.dubbo.rpc.ProtocolServer;\n-import org.apache.dubbo.rpc.RpcException;\n-import org.apache.dubbo.rpc.support.ProtocolUtils;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\n-\n-/**\n- * abstract ProtocolSupport.\n- */\n-public abstract class AbstractProtocol implements Protocol {\n-\n-    protected final Logger logger = LoggerFactory.getLogger(getClass());\n-\n-    protected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>();\n-\n-    /**\n-     * <host:port, ProtocolServer>\n-     */\n-    protected final Map<String, ProtocolServer> serverMap = new ConcurrentHashMap<>();\n-\n-    //TODO SoftReference\n-    protected final Set<Invoker<?>> invokers = new ConcurrentHashSet<Invoker<?>>();\n-\n-    protected static String serviceKey(URL url) {\n-        int port = url.getParameter(Constants.BIND_PORT_KEY, url.getPort());\n-        return serviceKey(port, url.getPath(), url.getParameter(VERSION_KEY), url.getParameter(GROUP_KEY));\n-    }\n-\n-    protected static String serviceKey(int port, String serviceName, String serviceVersion, String serviceGroup) {\n-        return ProtocolUtils.serviceKey(port, serviceName, serviceVersion, serviceGroup);\n-    }\n-\n-    public List<ProtocolServer> getServers() {\n-        return Collections.unmodifiableList(new ArrayList<>(serverMap.values()));\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        for (Invoker<?> invoker : invokers) {\n-            if (invoker != null) {\n-                invokers.remove(invoker);\n-                try {\n-                    if (logger.isInfoEnabled()) {\n-                        logger.info(\"Destroy reference: \" + invoker.getUrl());\n-                    }\n-                    invoker.destroy();\n-                } catch (Throwable t) {\n-                    logger.warn(t.getMessage(), t);\n-                }\n-            }\n-        }\n-        for (String key : new ArrayList<String>(exporterMap.keySet())) {\n-            Exporter<?> exporter = exporterMap.remove(key);\n-            if (exporter != null) {\n-                try {\n-                    if (logger.isInfoEnabled()) {\n-                        logger.info(\"Unexport service: \" + exporter.getInvoker().getUrl());\n-                    }\n-                    exporter.unexport();\n-                } catch (Throwable t) {\n-                    logger.warn(t.getMessage(), t);\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n-        return new AsyncToSyncInvoker<>(protocolBindingRefer(type, url));\n-    }\n-\n-    protected abstract <T> Invoker<T> protocolBindingRefer(Class<T> type, URL url) throws RpcException;\n-\n-    public Map<String, Exporter<?>> getExporterMap() {\n-        return exporterMap;\n-    }\n-\n-    public Collection<Exporter<?>> getExporters() {\n-        return Collections.unmodifiableCollection(exporterMap.values());\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.dubbo.rpc.protocol;\r\n+\r\n+import org.apache.dubbo.common.URL;\r\n+import org.apache.dubbo.common.logger.Logger;\r\n+import org.apache.dubbo.common.logger.LoggerFactory;\r\n+import org.apache.dubbo.common.utils.CollectionUtils;\r\n+import org.apache.dubbo.common.utils.ConcurrentHashSet;\r\n+import org.apache.dubbo.remoting.Constants;\r\n+import org.apache.dubbo.rpc.Exporter;\r\n+import org.apache.dubbo.rpc.Invoker;\r\n+import org.apache.dubbo.rpc.Protocol;\r\n+import org.apache.dubbo.rpc.ProtocolServer;\r\n+import org.apache.dubbo.rpc.RpcException;\r\n+import org.apache.dubbo.rpc.support.ProtocolUtils;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+\r\n+import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\r\n+\r\n+/**\r\n+ * abstract ProtocolSupport.\r\n+ */\r\n+public abstract class AbstractProtocol implements Protocol {\r\n+\r\n+    protected final Logger logger = LoggerFactory.getLogger(getClass());\r\n+\r\n+    protected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>();\r\n+\r\n+    protected final DelegateExporterMap delegateExporterMap = new DelegateExporterMap() {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11a533075018f601eceb1b0859e24ee28ea94d3f"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0OTYzOTkxNw==", "bodyText": "Pls., also check the failed unit tests. We'll try to merge it quickly this time once ready, thanks.", "url": "https://github.com/apache/dubbo/pull/6720#discussion_r649639917", "createdAt": "2021-06-11T02:05:28Z", "author": {"login": "chickenlj"}, "path": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java", "diffHunk": "@@ -1,116 +1,148 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.rpc.protocol;\n-\n-import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.logger.Logger;\n-import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.utils.ConcurrentHashSet;\n-import org.apache.dubbo.remoting.Constants;\n-import org.apache.dubbo.rpc.Exporter;\n-import org.apache.dubbo.rpc.Invoker;\n-import org.apache.dubbo.rpc.Protocol;\n-import org.apache.dubbo.rpc.ProtocolServer;\n-import org.apache.dubbo.rpc.RpcException;\n-import org.apache.dubbo.rpc.support.ProtocolUtils;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\n-\n-/**\n- * abstract ProtocolSupport.\n- */\n-public abstract class AbstractProtocol implements Protocol {\n-\n-    protected final Logger logger = LoggerFactory.getLogger(getClass());\n-\n-    protected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>();\n-\n-    /**\n-     * <host:port, ProtocolServer>\n-     */\n-    protected final Map<String, ProtocolServer> serverMap = new ConcurrentHashMap<>();\n-\n-    //TODO SoftReference\n-    protected final Set<Invoker<?>> invokers = new ConcurrentHashSet<Invoker<?>>();\n-\n-    protected static String serviceKey(URL url) {\n-        int port = url.getParameter(Constants.BIND_PORT_KEY, url.getPort());\n-        return serviceKey(port, url.getPath(), url.getParameter(VERSION_KEY), url.getParameter(GROUP_KEY));\n-    }\n-\n-    protected static String serviceKey(int port, String serviceName, String serviceVersion, String serviceGroup) {\n-        return ProtocolUtils.serviceKey(port, serviceName, serviceVersion, serviceGroup);\n-    }\n-\n-    public List<ProtocolServer> getServers() {\n-        return Collections.unmodifiableList(new ArrayList<>(serverMap.values()));\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        for (Invoker<?> invoker : invokers) {\n-            if (invoker != null) {\n-                invokers.remove(invoker);\n-                try {\n-                    if (logger.isInfoEnabled()) {\n-                        logger.info(\"Destroy reference: \" + invoker.getUrl());\n-                    }\n-                    invoker.destroy();\n-                } catch (Throwable t) {\n-                    logger.warn(t.getMessage(), t);\n-                }\n-            }\n-        }\n-        for (String key : new ArrayList<String>(exporterMap.keySet())) {\n-            Exporter<?> exporter = exporterMap.remove(key);\n-            if (exporter != null) {\n-                try {\n-                    if (logger.isInfoEnabled()) {\n-                        logger.info(\"Unexport service: \" + exporter.getInvoker().getUrl());\n-                    }\n-                    exporter.unexport();\n-                } catch (Throwable t) {\n-                    logger.warn(t.getMessage(), t);\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n-        return new AsyncToSyncInvoker<>(protocolBindingRefer(type, url));\n-    }\n-\n-    protected abstract <T> Invoker<T> protocolBindingRefer(Class<T> type, URL url) throws RpcException;\n-\n-    public Map<String, Exporter<?>> getExporterMap() {\n-        return exporterMap;\n-    }\n-\n-    public Collection<Exporter<?>> getExporters() {\n-        return Collections.unmodifiableCollection(exporterMap.values());\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.dubbo.rpc.protocol;\r\n+\r\n+import org.apache.dubbo.common.URL;\r\n+import org.apache.dubbo.common.logger.Logger;\r\n+import org.apache.dubbo.common.logger.LoggerFactory;\r\n+import org.apache.dubbo.common.utils.CollectionUtils;\r\n+import org.apache.dubbo.common.utils.ConcurrentHashSet;\r\n+import org.apache.dubbo.remoting.Constants;\r\n+import org.apache.dubbo.rpc.Exporter;\r\n+import org.apache.dubbo.rpc.Invoker;\r\n+import org.apache.dubbo.rpc.Protocol;\r\n+import org.apache.dubbo.rpc.ProtocolServer;\r\n+import org.apache.dubbo.rpc.RpcException;\r\n+import org.apache.dubbo.rpc.support.ProtocolUtils;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+\r\n+import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\r\n+\r\n+/**\r\n+ * abstract ProtocolSupport.\r\n+ */\r\n+public abstract class AbstractProtocol implements Protocol {\r\n+\r\n+    protected final Logger logger = LoggerFactory.getLogger(getClass());\r\n+\r\n+    protected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>();\r\n+\r\n+    protected final DelegateExporterMap delegateExporterMap = new DelegateExporterMap() {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0OTYzOTE2NQ=="}, "originalCommit": {"oid": "11a533075018f601eceb1b0859e24ee28ea94d3f"}, "originalPosition": 168}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2029, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}