{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5OTA2NjU1", "number": 5880, "title": "[Dubbo-Performance] Reduce memory allocation for URL parse", "bodyText": "What is the purpose of the change\nReduce memory allocation for URL parse.\nBrief changelog\n\nAdd URLStrParser to parse encodedURLString and decodedURLString.\nUse URLStrParser#parseEncodedStr(String) to replace URL#valueOf(URL#decode(String)).\nUse URLStrParser#parseDecodedStr(String) to replace URL#valueOf(String).\nOptimize URL#toMethodParameters.\n\nVerifying this change\nDetail information can see: URLParseOptimize\nJMH result:\nBenchmark                                Mode  Cnt    Score    Error   Units\nURLDecodeBenchmark.testDecodedOptimize  thrpt    5  652.419 \u00b1 14.828  ops/ms\nURLDecodeBenchmark.testDecodedOriginal  thrpt    5  517.530 \u00b1  5.144  ops/ms\nURLDecodeBenchmark.testEncodedOptimize  thrpt    5  401.168 \u00b1  5.407  ops/ms\nURLDecodeBenchmark.testEncodedOriginal  thrpt    5  163.323 \u00b1  0.640  ops/ms\n\nAprof result:\nBenchmark                                Allocated\nMeasureURLDecodeGC.testDecodedOptimize   95,171MB\nMeasureURLDecodeGC.testDecodedOriginal   273,073MB  \nMeasureURLDecodeGC.testEncodedOptimize   95,171MB\nMeasureURLDecodeGC.testEncodedOriginal   382,050MB\n\nFollow this checklist to help us incorporate your contribution quickly and easily:\n\n[] Make sure there is a GITHUB_issue field for the change (usually before you start working on it). Trivial changes like typos do not require a GITHUB issue. Your pull request should address just this issue, without pulling in other changes - one PR resolves one issue.\n Format the pull request title like [Dubbo-XXX] Fix UnknownException when host config not exist #XXX. Each commit in the pull request should have a meaningful subject line and body.\n Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\n Write necessary unit-test to verify your logic correction, more mock a little better when cross module dependency exist. If the new feature or significant change is committed, please remember to add sample in dubbo samples project.\n Run mvn clean install -DskipTests=false & mvn clean test-compile failsafe:integration-test to make sure unit-test and integration-test pass.\n If this contribution is large, please follow the Software Donation Guide.", "createdAt": "2020-03-17T15:27:50Z", "url": "https://github.com/apache/dubbo/pull/5880", "merged": true, "mergeCommit": {"oid": "afa2dc9a1ea2cd8e3cb292a47e7fc34f2acca036"}, "closed": true, "closedAt": "2020-04-14T03:40:07Z", "author": {"login": "LinShunKang"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcNl02tgH2gAyMzg5OTA2NjU1OjVlYzgwMTJkOTg1MjYzOTM4MzAxOTg2ZWU5YTM1MjIxNzU1NzgwMjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcUCAkeAH2gAyMzg5OTA2NjU1OjVjZTRmNWQ5OWFiZGNiZGRjMDdkMzc5ZmVmZTM4ZjI0YjMxNWE2OWE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5ec8012d985263938301986ee9a3522175578021", "author": {"user": {"login": "LinShunKang", "name": "LinShunKang"}}, "url": "https://github.com/apache/dubbo/commit/5ec8012d985263938301986ee9a3522175578021", "committedDate": "2020-03-14T14:31:19Z", "message": "perf: optimize URL decode and parse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40b082271c4a37562b41293db689aef40995e301", "author": {"user": {"login": "LinShunKang", "name": "LinShunKang"}}, "url": "https://github.com/apache/dubbo/commit/40b082271c4a37562b41293db689aef40995e301", "committedDate": "2020-03-14T17:03:21Z", "message": "refactor: Refactor URLStrDecoder for readable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16154f540fa520e11a23ec47a66cae596b61fd48", "author": {"user": {"login": "LinShunKang", "name": "LinShunKang"}}, "url": "https://github.com/apache/dubbo/commit/16154f540fa520e11a23ec47a66cae596b61fd48", "committedDate": "2020-03-16T16:16:55Z", "message": "perf: add URLStrParser#parseDecodedStr(String) to replace URL.valueOf(String)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2662e186f68849040f7a323d9b5ec890528ae9f0", "author": {"user": {"login": "LinShunKang", "name": "LinShunKang"}}, "url": "https://github.com/apache/dubbo/commit/2662e186f68849040f7a323d9b5ec890528ae9f0", "committedDate": "2020-03-17T15:06:45Z", "message": "perf: add short path for decodedParams"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c", "author": {"user": {"login": "LinShunKang", "name": "LinShunKang"}}, "url": "https://github.com/apache/dubbo/commit/48b0c9de6e1dac941ed43b25708f5ddd4a86e91c", "committedDate": "2020-03-18T15:47:54Z", "message": "fix: Remove .* import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NTEyNjc4", "url": "https://github.com/apache/dubbo/pull/5880#pullrequestreview-378512678", "createdAt": "2020-03-20T14:07:14Z", "commit": {"oid": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNDowNzoxNFrOF5VIrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNDowNzoxNFrOF5VIrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1OTQzNw==", "bodyText": "Line 98 - 115\n\u8fd9\u91cc\u5148\u7528 idx = indexOf(\":/\")\n\u7136\u540e\u5224\u65ad idx + 1 \u7684\u5b57\u7b26\u662f\u5426\u4e3a '/' \u53ef\u4ee5\u5728 file:/path \u7684\u60c5\u51b5\u4e0b\u51cf\u5c11\u4e00\u6b21 indexOf", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395659437", "createdAt": "2020-03-20T14:07:14Z", "author": {"login": "guohao"}, "path": "dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;\n+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;\n+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;\n+\n+public final class URLStrParser {\n+\n+    private static final char SPACE = 0x20;\n+\n+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));\n+\n+    private URLStrParser() {\n+        //empty\n+    }\n+\n+    /**\n+     * @param decodedURLStr : after {@link URL#decode} string\n+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2\n+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n+     */\n+    public static URL parseDecodedStr(String decodedURLStr) {\n+        Map<String, String> parameters = null;\n+        int pathEndIdx = decodedURLStr.indexOf('?');\n+        if (pathEndIdx >= 0) {\n+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);\n+        } else {\n+            pathEndIdx = decodedURLStr.length();\n+        }\n+\n+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);\n+        return parseURLBody(decodedURLStr, decodedBody, parameters);\n+    }\n+\n+    private static Map<String, String> parseDecodedParams(String str, int from) {\n+        int len = str.length();\n+        if (from >= len) {\n+            return Collections.emptyMap();\n+        }\n+\n+        TempBuf tempBuf = DECODE_TEMP_BUF.get();\n+        Map<String, String> params = new HashMap<>();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        for (i = from; i < len; i++) {\n+            char ch = str.charAt(i);\n+            switch (ch) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case ';':\n+                case '&':\n+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+                    nameStart = i + 1;\n+                    break;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+        return params;\n+    }\n+\n+    /**\n+     * @param fullURLStr  : fullURLString\n+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]\n+     * @param parameters  :\n+     * @return URL\n+     */\n+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {\n+        int starIdx = 0, endIdx = decodedBody.length();\n+        String protocol = null;\n+        int protoEndIdx = decodedBody.indexOf(\"://\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NTE1OTQz", "url": "https://github.com/apache/dubbo/pull/5880#pullrequestreview-378515943", "createdAt": "2020-03-20T14:11:18Z", "commit": {"oid": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNDoxMToxOFrOF5VSUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNTozODozN1rOF5Y3XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY2MTkwNw==", "bodyText": "\u8fd9\u91cc\u662f\u5426\u53ef\u4ee5\u76f4\u63a5\u7528decodedBoyd.indexOf('/',startIdx)", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395661907", "createdAt": "2020-03-20T14:11:18Z", "author": {"login": "guohao"}, "path": "dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;\n+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;\n+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;\n+\n+public final class URLStrParser {\n+\n+    private static final char SPACE = 0x20;\n+\n+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));\n+\n+    private URLStrParser() {\n+        //empty\n+    }\n+\n+    /**\n+     * @param decodedURLStr : after {@link URL#decode} string\n+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2\n+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n+     */\n+    public static URL parseDecodedStr(String decodedURLStr) {\n+        Map<String, String> parameters = null;\n+        int pathEndIdx = decodedURLStr.indexOf('?');\n+        if (pathEndIdx >= 0) {\n+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);\n+        } else {\n+            pathEndIdx = decodedURLStr.length();\n+        }\n+\n+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);\n+        return parseURLBody(decodedURLStr, decodedBody, parameters);\n+    }\n+\n+    private static Map<String, String> parseDecodedParams(String str, int from) {\n+        int len = str.length();\n+        if (from >= len) {\n+            return Collections.emptyMap();\n+        }\n+\n+        TempBuf tempBuf = DECODE_TEMP_BUF.get();\n+        Map<String, String> params = new HashMap<>();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        for (i = from; i < len; i++) {\n+            char ch = str.charAt(i);\n+            switch (ch) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case ';':\n+                case '&':\n+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+                    nameStart = i + 1;\n+                    break;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+        return params;\n+    }\n+\n+    /**\n+     * @param fullURLStr  : fullURLString\n+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]\n+     * @param parameters  :\n+     * @return URL\n+     */\n+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {\n+        int starIdx = 0, endIdx = decodedBody.length();\n+        String protocol = null;\n+        int protoEndIdx = decodedBody.indexOf(\"://\");\n+        if (protoEndIdx >= 0) {\n+            if (protoEndIdx == 0) {\n+                throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+            }\n+            protocol = decodedBody.substring(0, protoEndIdx);\n+            starIdx = protoEndIdx + 3;\n+        } else {\n+            // case: file:/path/to/file.txt\n+            protoEndIdx = decodedBody.indexOf(\":/\");\n+            if (protoEndIdx >= 0) {\n+                if (protoEndIdx == 0) {\n+                    throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+                }\n+                protocol = decodedBody.substring(0, protoEndIdx);\n+                starIdx = protoEndIdx + 1;\n+            }\n+        }\n+\n+        String path = null;\n+        int pathStartIdx = indexOf(decodedBody, '/', starIdx, endIdx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY2MzE3NQ==", "bodyText": "protocol \u8fd9\u79cd\u57fa\u672c\u4e0d\u53d8\u6216\u7c7b\u578b\u53ef\u679a\u4e3e\u7684\u5c5e\u6027\u503c\uff0c\u53ef\u4ee5\u8003\u8651\u4f7f\u7528\u7f13\u5b58\uff0c\u51cf\u5c11 substring \u751f\u6210\u65b0\u5bf9\u8c61\u6570\u91cf", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395663175", "createdAt": "2020-03-20T14:13:14Z", "author": {"login": "guohao"}, "path": "dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;\n+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;\n+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;\n+\n+public final class URLStrParser {\n+\n+    private static final char SPACE = 0x20;\n+\n+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));\n+\n+    private URLStrParser() {\n+        //empty\n+    }\n+\n+    /**\n+     * @param decodedURLStr : after {@link URL#decode} string\n+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2\n+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n+     */\n+    public static URL parseDecodedStr(String decodedURLStr) {\n+        Map<String, String> parameters = null;\n+        int pathEndIdx = decodedURLStr.indexOf('?');\n+        if (pathEndIdx >= 0) {\n+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);\n+        } else {\n+            pathEndIdx = decodedURLStr.length();\n+        }\n+\n+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);\n+        return parseURLBody(decodedURLStr, decodedBody, parameters);\n+    }\n+\n+    private static Map<String, String> parseDecodedParams(String str, int from) {\n+        int len = str.length();\n+        if (from >= len) {\n+            return Collections.emptyMap();\n+        }\n+\n+        TempBuf tempBuf = DECODE_TEMP_BUF.get();\n+        Map<String, String> params = new HashMap<>();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        for (i = from; i < len; i++) {\n+            char ch = str.charAt(i);\n+            switch (ch) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case ';':\n+                case '&':\n+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+                    nameStart = i + 1;\n+                    break;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+        return params;\n+    }\n+\n+    /**\n+     * @param fullURLStr  : fullURLString\n+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]\n+     * @param parameters  :\n+     * @return URL\n+     */\n+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {\n+        int starIdx = 0, endIdx = decodedBody.length();\n+        String protocol = null;\n+        int protoEndIdx = decodedBody.indexOf(\"://\");\n+        if (protoEndIdx >= 0) {\n+            if (protoEndIdx == 0) {\n+                throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+            }\n+            protocol = decodedBody.substring(0, protoEndIdx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5MjgyMQ==", "bodyText": "\u6309\u7167 [ipv6\u5730\u5740%zoneId]:port \u7684\u683c\u5f0f\n\u8fd9\u4e2a\u5206\u652f\u5e94\u8be5\u4e0d\u4f1a\u8d70\u5230\u5427", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395692821", "createdAt": "2020-03-20T14:57:13Z", "author": {"login": "guohao"}, "path": "dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;\n+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;\n+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;\n+\n+public final class URLStrParser {\n+\n+    private static final char SPACE = 0x20;\n+\n+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));\n+\n+    private URLStrParser() {\n+        //empty\n+    }\n+\n+    /**\n+     * @param decodedURLStr : after {@link URL#decode} string\n+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2\n+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n+     */\n+    public static URL parseDecodedStr(String decodedURLStr) {\n+        Map<String, String> parameters = null;\n+        int pathEndIdx = decodedURLStr.indexOf('?');\n+        if (pathEndIdx >= 0) {\n+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);\n+        } else {\n+            pathEndIdx = decodedURLStr.length();\n+        }\n+\n+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);\n+        return parseURLBody(decodedURLStr, decodedBody, parameters);\n+    }\n+\n+    private static Map<String, String> parseDecodedParams(String str, int from) {\n+        int len = str.length();\n+        if (from >= len) {\n+            return Collections.emptyMap();\n+        }\n+\n+        TempBuf tempBuf = DECODE_TEMP_BUF.get();\n+        Map<String, String> params = new HashMap<>();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        for (i = from; i < len; i++) {\n+            char ch = str.charAt(i);\n+            switch (ch) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case ';':\n+                case '&':\n+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+                    nameStart = i + 1;\n+                    break;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+        return params;\n+    }\n+\n+    /**\n+     * @param fullURLStr  : fullURLString\n+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]\n+     * @param parameters  :\n+     * @return URL\n+     */\n+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {\n+        int starIdx = 0, endIdx = decodedBody.length();\n+        String protocol = null;\n+        int protoEndIdx = decodedBody.indexOf(\"://\");\n+        if (protoEndIdx >= 0) {\n+            if (protoEndIdx == 0) {\n+                throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+            }\n+            protocol = decodedBody.substring(0, protoEndIdx);\n+            starIdx = protoEndIdx + 3;\n+        } else {\n+            // case: file:/path/to/file.txt\n+            protoEndIdx = decodedBody.indexOf(\":/\");\n+            if (protoEndIdx >= 0) {\n+                if (protoEndIdx == 0) {\n+                    throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+                }\n+                protocol = decodedBody.substring(0, protoEndIdx);\n+                starIdx = protoEndIdx + 1;\n+            }\n+        }\n+\n+        String path = null;\n+        int pathStartIdx = indexOf(decodedBody, '/', starIdx, endIdx);\n+        if (pathStartIdx >= 0) {\n+            path = decodedBody.substring(pathStartIdx + 1);\n+            endIdx = pathStartIdx;\n+        }\n+\n+        String username = null;\n+        String password = null;\n+        int pwdEndIdx = lastIndexOf(decodedBody, '@', starIdx, endIdx);\n+        if (pwdEndIdx > 0) {\n+            int userNameEndIdx = indexOf(decodedBody, ':', starIdx, pwdEndIdx);\n+            username = decodedBody.substring(starIdx, userNameEndIdx);\n+            password = decodedBody.substring(userNameEndIdx + 1, pwdEndIdx);\n+            starIdx = pwdEndIdx + 1;\n+        }\n+\n+        String host = null;\n+        int port = 0;\n+        int hostEndIdx = lastIndexOf(decodedBody, ':', starIdx, endIdx);\n+        if (hostEndIdx > 0 && hostEndIdx < decodedBody.length() - 1) {\n+            if (lastIndexOf(decodedBody, '%', starIdx, endIdx) > hostEndIdx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwMjk1Ng==", "bodyText": "\u770b\u4e86\u4e0b org.apache.dubbo.common.utils.NetUtils#normalizeV6Address \uff0c\u83b7\u53d6\u5730\u5740\u6ce8\u518c\u7684\u65f6\u5019\u4e5f\u6ca1\u52a0 [ ] \u3002\n\u5982\u679c\u6ce8\u518c\u65f6\u9ed8\u8ba4\u7ea6\u5b9a ipv6 \u90fd\u4e0d\u52a0 [] \uff0c\u5f53\u524d\u8fd9\u79cd\u6a21\u5f0f\u662f\u6ca1\u95ee\u9898\u7684\u3002\n\u4f46\u662f\u6309\u7167 https://tools.ietf.org/html/rfc3986#section-3.2.2 \uff0cipv6 \u7684 host \u662f\u8981\u52a0 [] \u7684\u3002\n\u5982\u679c\u52a0\u4e86[] \uff0cconnect \u7684\u65f6\u5019\u9700\u8981\u628a [] \u53bb\u6389\u3002\n\u53ef\u4ee5\u5355\u72ec\u5f00\u4e2a issue \u8ba8\u8bba\u4e0b\u8fd9\u4e2a\u95ee\u9898", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395702956", "createdAt": "2020-03-20T15:12:22Z", "author": {"login": "guohao"}, "path": "dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;\n+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;\n+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;\n+\n+public final class URLStrParser {\n+\n+    private static final char SPACE = 0x20;\n+\n+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));\n+\n+    private URLStrParser() {\n+        //empty\n+    }\n+\n+    /**\n+     * @param decodedURLStr : after {@link URL#decode} string\n+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2\n+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n+     */\n+    public static URL parseDecodedStr(String decodedURLStr) {\n+        Map<String, String> parameters = null;\n+        int pathEndIdx = decodedURLStr.indexOf('?');\n+        if (pathEndIdx >= 0) {\n+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);\n+        } else {\n+            pathEndIdx = decodedURLStr.length();\n+        }\n+\n+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);\n+        return parseURLBody(decodedURLStr, decodedBody, parameters);\n+    }\n+\n+    private static Map<String, String> parseDecodedParams(String str, int from) {\n+        int len = str.length();\n+        if (from >= len) {\n+            return Collections.emptyMap();\n+        }\n+\n+        TempBuf tempBuf = DECODE_TEMP_BUF.get();\n+        Map<String, String> params = new HashMap<>();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        for (i = from; i < len; i++) {\n+            char ch = str.charAt(i);\n+            switch (ch) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case ';':\n+                case '&':\n+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+                    nameStart = i + 1;\n+                    break;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+        return params;\n+    }\n+\n+    /**\n+     * @param fullURLStr  : fullURLString\n+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]\n+     * @param parameters  :\n+     * @return URL\n+     */\n+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {\n+        int starIdx = 0, endIdx = decodedBody.length();\n+        String protocol = null;\n+        int protoEndIdx = decodedBody.indexOf(\"://\");\n+        if (protoEndIdx >= 0) {\n+            if (protoEndIdx == 0) {\n+                throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+            }\n+            protocol = decodedBody.substring(0, protoEndIdx);\n+            starIdx = protoEndIdx + 3;\n+        } else {\n+            // case: file:/path/to/file.txt\n+            protoEndIdx = decodedBody.indexOf(\":/\");\n+            if (protoEndIdx >= 0) {\n+                if (protoEndIdx == 0) {\n+                    throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+                }\n+                protocol = decodedBody.substring(0, protoEndIdx);\n+                starIdx = protoEndIdx + 1;\n+            }\n+        }\n+\n+        String path = null;\n+        int pathStartIdx = indexOf(decodedBody, '/', starIdx, endIdx);\n+        if (pathStartIdx >= 0) {\n+            path = decodedBody.substring(pathStartIdx + 1);\n+            endIdx = pathStartIdx;\n+        }\n+\n+        String username = null;\n+        String password = null;\n+        int pwdEndIdx = lastIndexOf(decodedBody, '@', starIdx, endIdx);\n+        if (pwdEndIdx > 0) {\n+            int userNameEndIdx = indexOf(decodedBody, ':', starIdx, pwdEndIdx);\n+            username = decodedBody.substring(starIdx, userNameEndIdx);\n+            password = decodedBody.substring(userNameEndIdx + 1, pwdEndIdx);\n+            starIdx = pwdEndIdx + 1;\n+        }\n+\n+        String host = null;\n+        int port = 0;\n+        int hostEndIdx = lastIndexOf(decodedBody, ':', starIdx, endIdx);\n+        if (hostEndIdx > 0 && hostEndIdx < decodedBody.length() - 1) {\n+            if (lastIndexOf(decodedBody, '%', starIdx, endIdx) > hostEndIdx) {\n+                // ipv6 address with scope id\n+                // e.g. fe80:0:0:0:894:aeec:f37d:23e1%en0\n+                // see https://howdoesinternetwork.com/2013/ipv6-zone-id\n+                // ignore\n+            } else {\n+                port = Integer.parseInt(decodedBody.substring(hostEndIdx + 1, endIdx));\n+                endIdx = hostEndIdx;\n+            }\n+        }\n+\n+        if (endIdx > starIdx) {\n+            host = decodedBody.substring(starIdx, endIdx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyMDU0MA==", "bodyText": "128 \u5c31\u591f\u4e86\uff0c\u7528\u4e0d\u5230 65536", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395720540", "createdAt": "2020-03-20T15:38:37Z", "author": {"login": "guohao"}, "path": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java", "diffHunk": "@@ -88,6 +91,33 @@\n \r\n     public static final String HYPHEN = valueOf(HYPHEN_CHAR);\r\n \r\n+    static {\r\n+        HEX2B = new byte[Character.MAX_VALUE + 1];\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4676cb52eaeec60583cb0073508fb75dddb842c0", "author": {"user": {"login": "LinShunKang", "name": "LinShunKang"}}, "url": "https://github.com/apache/dubbo/commit/4676cb52eaeec60583cb0073508fb75dddb842c0", "committedDate": "2020-03-21T06:00:10Z", "message": "perf: Reduce String and StringBuilder allocation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f4d728188e2c11283d87a98cefb3f904cf052a7", "author": {"user": {"login": "LinShunKang", "name": "LinShunKang"}}, "url": "https://github.com/apache/dubbo/commit/4f4d728188e2c11283d87a98cefb3f904cf052a7", "committedDate": "2020-03-21T07:33:42Z", "message": "perf: Reduce StringUtils#HEX2B size to 128"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4OTAwMTEy", "url": "https://github.com/apache/dubbo/pull/5880#pullrequestreview-378900112", "createdAt": "2020-03-21T07:40:00Z", "commit": {"oid": "4f4d728188e2c11283d87a98cefb3f904cf052a7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2OTEwNzQx", "url": "https://github.com/apache/dubbo/pull/5880#pullrequestreview-386910741", "createdAt": "2020-04-03T03:11:27Z", "commit": {"oid": "4f4d728188e2c11283d87a98cefb3f904cf052a7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMzoxMToyN1rOGADqxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMzoxMToyN1rOGADqxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcxMzI4NA==", "bodyText": "Please keep the original License header as it is.", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r402713284", "createdAt": "2020-04-03T03:11:27Z", "author": {"login": "chickenlj"}, "path": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/Utf8Utils.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+// Protocol Buffers - Google's data interchange format\n+// Copyright 2008 Google Inc.  All rights reserved.\n+// https://developers.google.com/protocol-buffers/\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+// notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+// copyright notice, this list of conditions and the following disclaimer\n+// in the documentation and/or other materials provided with the\n+// distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+// contributors may be used to endorse or promote products derived from\n+// this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+package org.apache.dubbo.common.utils;\n+\n+import static java.lang.Character.MIN_HIGH_SURROGATE;\n+import static java.lang.Character.MIN_LOW_SURROGATE;\n+import static java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT;\n+\n+/**\n+ * See original <a href=\n+ * \"https://github.com/protocolbuffers/protobuf/blob/master/java/core/src/main/java/com/google/protobuf/Utf8.java\"\n+ * >Utf8.java</a>\n+ */\n+public final class Utf8Utils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f4d728188e2c11283d87a98cefb3f904cf052a7"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ce4f5d99abdcbddc07d379fefe38f24b315a69a", "author": {"user": {"login": "LinShunKang", "name": "LinShunKang"}}, "url": "https://github.com/apache/dubbo/commit/5ce4f5d99abdcbddc07d379fefe38f24b315a69a", "committedDate": "2020-04-03T14:45:00Z", "message": "license: Remove Apache License from Utf8Utils"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2107, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}