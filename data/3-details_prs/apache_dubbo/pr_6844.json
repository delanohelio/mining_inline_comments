{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExNDgzMDMy", "number": 6844, "title": "[3.0] Feature/state router", "bodyText": "What is the purpose of the change\nXXXXX\nBrief changelog\nXXXXX\nVerifying this change\nXXXXX\nFollow this checklist to help us incorporate your contribution quickly and easily:\n\n Make sure there is a GITHUB_issue field for the change (usually before you start working on it). Trivial changes like typos do not require a GITHUB issue. Your pull request should address just this issue, without pulling in other changes - one PR resolves one issue.\n Format the pull request title like [Dubbo-XXX] Fix UnknownException when host config not exist #XXX. Each commit in the pull request should have a meaningful subject line and body.\n Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\n Write necessary unit-test to verify your logic correction, more mock a little better when cross module dependency exist. If the new feature or significant change is committed, please remember to add sample in dubbo samples project.\n Run mvn clean install -DskipTests=false & mvn clean test-compile failsafe:integration-test to make sure unit-test and integration-test pass.\n If this contribution is large, please follow the Software Donation Guide.", "createdAt": "2020-10-28T11:41:14Z", "url": "https://github.com/apache/dubbo/pull/6844", "merged": true, "mergeCommit": {"oid": "3531a7d681da5574f31609beeb2ed288af7aaebc"}, "closed": true, "closedAt": "2021-05-18T09:13:51Z", "author": {"login": "panxiaojun233"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdW8l8VgBqjM5MzA5NDAyOTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeXqZ5qgH2gAyNTExNDgzMDMyOjc5YTkxMzFmZWExN2Q3N2YzMTJjYjViMzRkMWQ3NGNmN2IxNjAyMmU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4c68005c7d0f17f6b960cea5b163f3036848f24c", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/4c68005c7d0f17f6b960cea5b163f3036848f24c", "committedDate": "2020-10-28T11:38:11Z", "message": "import stateTagRouter"}, "afterCommit": {"oid": "c047d2c1f102d9380a65a29127d4ba1b387d6901", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/c047d2c1f102d9380a65a29127d4ba1b387d6901", "committedDate": "2020-10-28T12:18:46Z", "message": "import stateTagRouter"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c047d2c1f102d9380a65a29127d4ba1b387d6901", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/c047d2c1f102d9380a65a29127d4ba1b387d6901", "committedDate": "2020-10-28T12:18:46Z", "message": "import stateTagRouter"}, "afterCommit": {"oid": "7ff8971b27b483fec71ae7b2caaeefd5b0c8bf55", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/7ff8971b27b483fec71ae7b2caaeefd5b0c8bf55", "committedDate": "2020-10-28T12:27:15Z", "message": "import stateTagRouter"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7ff8971b27b483fec71ae7b2caaeefd5b0c8bf55", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/7ff8971b27b483fec71ae7b2caaeefd5b0c8bf55", "committedDate": "2020-10-28T12:27:15Z", "message": "import stateTagRouter"}, "afterCommit": {"oid": "9e4737615a92f525b2a6f89eba5912d91266e33d", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/9e4737615a92f525b2a6f89eba5912d91266e33d", "committedDate": "2020-10-29T02:33:57Z", "message": "import stateTagRouter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca1ad9cbd797075bd9c337834af91ba3c3244412", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/ca1ad9cbd797075bd9c337834af91ba3c3244412", "committedDate": "2021-04-27T07:21:45Z", "message": "state router"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "593026c0381fb38d6a606ce00737e53fc34a96be", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/593026c0381fb38d6a606ce00737e53fc34a96be", "committedDate": "2021-04-28T09:12:05Z", "message": "fix router chain"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "committedDate": "2021-04-29T02:27:59Z", "message": "fix router chain"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9e4737615a92f525b2a6f89eba5912d91266e33d", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/9e4737615a92f525b2a6f89eba5912d91266e33d", "committedDate": "2020-10-29T02:33:57Z", "message": "import stateTagRouter"}, "afterCommit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "committedDate": "2021-04-29T02:27:59Z", "message": "fix router chain"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ4ODc4ODg5", "url": "https://github.com/apache/dubbo/pull/6844#pullrequestreview-648878889", "createdAt": "2021-04-30T04:48:39Z", "commit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0zMFQwNDo0ODozOVrOJSt18g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0zMFQwNDo1NDoxOFrOJSuFTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwNTIzNA==", "bodyText": "pls move this field to dubbo-dependencies module", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623605234", "createdAt": "2021-04-30T04:48:39Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-cluster/pom.xml", "diffHunk": "@@ -31,6 +31,11 @@\n         <skip_maven_deploy>false</skip_maven_deploy>\n     </properties>\n     <dependencies>\n+        <dependency>\n+            <groupId>org.roaringbitmap</groupId>\n+            <artifactId>RoaringBitmap</artifactId>\n+            <version>0.9.0</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwNTY3NQ==", "bodyText": "pls comment in English", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623605675", "createdAt": "2021-04-30T04:49:18Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -98,7 +167,30 @@ private void sort() {\n      * @return\n      */\n     public List<Invoker<T>> route(URL url, Invocation invocation) {\n-        List<Invoker<T>> finalInvokers = invokers;\n+\n+        AddrCache cache = this.cache.get();\n+        if (cache == null) {\n+            throw new RpcException(RpcException.ROUTER_CACHE_NOT_BUILD, \"Failed to invoke the method \"\n+                + invocation.getMethodName() + \" in the service \" + url.getServiceInterface()\n+                + \". address cache not build \"\n+                + \" on the consumer \" + NetUtils.getLocalHost()\n+                + \" using the dubbo version \" + Version.getVersion()\n+                + \".\");\n+        }\n+        BitList<Invoker<T>> finalBitListInvokers = new BitList<Invoker<T>>(invokers, false);\n+        for (StateRouter stateRouter : stateRouters) {\n+            if (stateRouter.isEnable()) {\n+                finalBitListInvokers = stateRouter.route(finalBitListInvokers, cache.getCache().get(stateRouter.getName()), url, invocation);\n+            }\n+        }\n+\n+        // FIXME \u770b\u4e00\u4e0b\u9ad8\u7248\u672c\u7684RoaringBitMap\uff0c\u662f\u5426\u6709\u5185\u7f6e\u51fd\u6570\u652f\u6301\u66f4\u9ad8\u6548\u7684\u904d\u5386", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwNjE4NQ==", "bodyText": "is this executor necessary?", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623606185", "createdAt": "2021-04-30T04:50:01Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -111,6 +203,96 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List copyInvokers = new ArrayList<>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {\n+            if (stateRouter.isEnable()) {\n+                executorRepository.getPoolRouterExecutor().execute(new Runnable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwNjc3Mg==", "bodyText": "is this works? Just wrapped with RPCException and throw it would be better?", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623606772", "createdAt": "2021-04-30T04:50:54Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -111,6 +203,96 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List copyInvokers = new ArrayList<>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {\n+            if (stateRouter.isEnable()) {\n+                executorRepository.getPoolRouterExecutor().execute(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        RouterCache routerCache = null;\n+                        try {\n+                            routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);\n+                            //file cache\n+                            newCache.getCache().put(stateRouter.getName(), routerCache);\n+                        } catch (Throwable t) {\n+                            poolSuccess.set(false);\n+                            logger.error(\"Failed to pool router: \" + stateRouter.getUrl() + \", cause: \" + t.getMessage(), t);\n+                        } finally {\n+                            cdl.countDown();\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+        try {\n+            cdl.await();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwNjk4NA==", "bodyText": "Please comment in English", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623606984", "createdAt": "2021-04-30T04:51:12Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -111,6 +203,96 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List copyInvokers = new ArrayList<>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {\n+            if (stateRouter.isEnable()) {\n+                executorRepository.getPoolRouterExecutor().execute(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        RouterCache routerCache = null;\n+                        try {\n+                            routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);\n+                            //file cache\n+                            newCache.getCache().put(stateRouter.getName(), routerCache);\n+                        } catch (Throwable t) {\n+                            poolSuccess.set(false);\n+                            logger.error(\"Failed to pool router: \" + stateRouter.getUrl() + \", cause: \" + t.getMessage(), t);\n+                        } finally {\n+                            cdl.countDown();\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+        try {\n+            cdl.await();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+\n+        if (poolSuccess.get()) {\n+            this.cache.set(newCache);\n+        }\n+    }\n+\n+    private RouterCache poolRouter(StateRouter router, AddrCache orign, List<Invoker<T>> invokers, boolean notify) {\n+        String routerName = router.getName();\n+        RouterCache routerCache = null;\n+        if (isCacheMiss(orign, routerName) || router.shouldRePool() || notify) {\n+            return router.pool(invokers);\n+        } else {\n+            routerCache = orign.getCache().get(routerName);\n+        }\n+        if (routerCache == null) {\n+            return new RouterCache();\n+        }\n+        return routerCache;\n+    }\n+\n+    private boolean isCacheMiss(AddrCache cache, String routerName) {\n+        if (cache == null || cache.getCache() == null || cache.getInvokers() == null || cache.getCache().get(routerName) == null) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public void loop(boolean notify) {\n+        // 1\u3001\u591a\u4e2a\u670d\u52a1\u5e76\u884c\u6267\u884c buildCache", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwNzgyMA==", "bodyText": "Try make this Runnable as a static class reference or lambda reference. Reduce inner class creation.", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623607820", "createdAt": "2021-04-30T04:52:20Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -111,6 +203,96 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List copyInvokers = new ArrayList<>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {\n+            if (stateRouter.isEnable()) {\n+                executorRepository.getPoolRouterExecutor().execute(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        RouterCache routerCache = null;\n+                        try {\n+                            routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);\n+                            //file cache\n+                            newCache.getCache().put(stateRouter.getName(), routerCache);\n+                        } catch (Throwable t) {\n+                            poolSuccess.set(false);\n+                            logger.error(\"Failed to pool router: \" + stateRouter.getUrl() + \", cause: \" + t.getMessage(), t);\n+                        } finally {\n+                            cdl.countDown();\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+        try {\n+            cdl.await();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+\n+        if (poolSuccess.get()) {\n+            this.cache.set(newCache);\n+        }\n+    }\n+\n+    private RouterCache poolRouter(StateRouter router, AddrCache orign, List<Invoker<T>> invokers, boolean notify) {\n+        String routerName = router.getName();\n+        RouterCache routerCache = null;\n+        if (isCacheMiss(orign, routerName) || router.shouldRePool() || notify) {\n+            return router.pool(invokers);\n+        } else {\n+            routerCache = orign.getCache().get(routerName);\n+        }\n+        if (routerCache == null) {\n+            return new RouterCache();\n+        }\n+        return routerCache;\n+    }\n+\n+    private boolean isCacheMiss(AddrCache cache, String routerName) {\n+        if (cache == null || cache.getCache() == null || cache.getInvokers() == null || cache.getCache().get(routerName) == null) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public void loop(boolean notify) {\n+        // 1\u3001\u591a\u4e2a\u670d\u52a1\u5e76\u884c\u6267\u884c buildCache\n+        // 2\u3001notify true/false\n+        if (notify) {\n+            if (loopPermitNotify.tryAcquire()) {\n+                LOOP_THREAD_POOL.submit(new Runnable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwODEzMA==", "bodyText": "Please add Apache License header", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623608130", "createdAt": "2021-04-30T04:52:47Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package org.apache.dubbo.rpc.cluster.router.state;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwODE2OQ==", "bodyText": "Please add Apache License header", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623608169", "createdAt": "2021-04-30T04:52:50Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/BitList.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.apache.dubbo.rpc.cluster.router.state;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwODM3NA==", "bodyText": "Please add Apache License header", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623608374", "createdAt": "2021-04-30T04:53:08Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/RouterCache.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.apache.dubbo.rpc.cluster.router.state;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwODQyOQ==", "bodyText": "Please add Apache License header", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623608429", "createdAt": "2021-04-30T04:53:14Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouterFactory.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package org.apache.dubbo.rpc.cluster.router.state;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwODcxMw==", "bodyText": "Please comment in English", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623608713", "createdAt": "2021-04-30T04:53:37Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;\n+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;\n+import org.apache.dubbo.common.config.configcenter.ConfigurationListener;\n+import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;\n+import org.apache.dubbo.common.constants.CommonConstants;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRuleParser;\n+\n+import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+import static org.apache.dubbo.rpc.Constants.FORCE_USE_TAG;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagDynamicStateRouter extends AbstractStateRouter implements ConfigurationListener {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagDynamicStateRouter.class);\n+    private static final String RULE_SUFFIX = \".tag-router\";\n+    private static final String NO_TAG = \"noTag\";\n+\n+    private TagRouterRule tagRouterRule;\n+    private String application;\n+\n+    public TagDynamicStateRouter(URL url, RouterChain chain) {\n+        super(url, chain);\n+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;\n+    }\n+\n+    @Override\n+    public synchronized void process(ConfigChangedEvent event) {\n+        setForce(true);\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Notification of tag rule, change type is: \" + event.getChangeType() + \", raw rule is:\\n \" +\n+                    event.getContent());\n+        }\n+\n+        try {\n+            if (event.getChangeType().equals(ConfigChangeType.DELETED)) {\n+                this.tagRouterRule = null;\n+            } else {\n+                this.tagRouterRule = TagRuleParser.parse(event.getContent());\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Failed to parse the raw tag router rule and it will not take effect, please check if the \" +\n+                    \"rule matches with the template, the raw rule is:\\n \", e);\n+        }\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url,\n+        Invocation invocation) throws RpcException {\n+\n+\n+        final TagRouterRule tagRouterRuleCopy = (TagRouterRule)cache.getAddrMetadata();\n+\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+\n+        ConcurrentHashMap<String, BitList<Invoker>> addrPool = cache.getAddrPool();\n+\n+        if (StringUtils.isEmpty(tag)) {\n+            return invokers.intersect((BitList)addrPool.get(NO_TAG), invokers.getUnmodifiableList());\n+        } else {\n+            BitList<Invoker> result = addrPool.get(tag);\n+\n+            if (CollectionUtils.isNotEmpty(result) || (tagRouterRuleCopy != null && tagRouterRuleCopy.isForce())\n+                || isForceUseTag(invocation)) {\n+                return invokers.intersect((BitList)result, invokers.getUnmodifiableList());\n+            } else {\n+                invocation.setAttachment(TAG_KEY, NO_TAG);\n+                return invokers;\n+            }\n+        }\n+    }\n+\n+    private boolean isForceUseTag(Invocation invocation) {\n+        return Boolean.valueOf(invocation.getAttachment(FORCE_USE_TAG, url.getParameter(FORCE_USE_TAG, \"false\")));\n+    }\n+\n+    @Override\n+    public boolean isRuntime() {\n+        return tagRouterRule != null && tagRouterRule.isRuntime();\n+    }\n+\n+    @Override\n+    public boolean isEnable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isForce() {\n+        return tagRouterRule != null && tagRouterRule.isForce();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"TagDynamic\";\n+    }\n+\n+    @Override\n+    public boolean shouldRePool() {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> RouterCache pool(List<Invoker<T>> invokers) {\n+\n+        RouterCache routerCache = new RouterCache();\n+        ConcurrentHashMap<String, BitList<Invoker<T>>> addrPool = new ConcurrentHashMap<>();\n+\n+        final TagRouterRule tagRouterRuleCopy = tagRouterRule;\n+\n+\n+        if (tagRouterRuleCopy == null || !tagRouterRuleCopy.isValid() || !tagRouterRuleCopy.isEnabled()) {\n+            return routerCache;\n+        }\n+\n+        List<String> tagNames = tagRouterRuleCopy.getTagNames();\n+        Map<String, List<String>> tagnameToAddresses = tagRouterRuleCopy.getTagnameToAddresses();\n+\n+        for (String tag : tagNames) {\n+            List<String> addresses = tagnameToAddresses.get(tag);\n+            BitList<Invoker<T>> list = new BitList<>(invokers, true);\n+            // \u5730\u5740\u4e3a\u7a7a\uff0c\u5219\u52a8\u6001\u8def\u7531\u4e0d\u751f\u6548\uff0c\u76f4\u63a5\u770b\u9759\u6001\u8def\u7531", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwOTE2Nw==", "bodyText": "try specify inital size", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623609167", "createdAt": "2021-04-30T04:54:18Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;\n+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;\n+import org.apache.dubbo.common.config.configcenter.ConfigurationListener;\n+import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;\n+import org.apache.dubbo.common.constants.CommonConstants;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRuleParser;\n+\n+import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+import static org.apache.dubbo.rpc.Constants.FORCE_USE_TAG;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagDynamicStateRouter extends AbstractStateRouter implements ConfigurationListener {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagDynamicStateRouter.class);\n+    private static final String RULE_SUFFIX = \".tag-router\";\n+    private static final String NO_TAG = \"noTag\";\n+\n+    private TagRouterRule tagRouterRule;\n+    private String application;\n+\n+    public TagDynamicStateRouter(URL url, RouterChain chain) {\n+        super(url, chain);\n+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;\n+    }\n+\n+    @Override\n+    public synchronized void process(ConfigChangedEvent event) {\n+        setForce(true);\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Notification of tag rule, change type is: \" + event.getChangeType() + \", raw rule is:\\n \" +\n+                    event.getContent());\n+        }\n+\n+        try {\n+            if (event.getChangeType().equals(ConfigChangeType.DELETED)) {\n+                this.tagRouterRule = null;\n+            } else {\n+                this.tagRouterRule = TagRuleParser.parse(event.getContent());\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Failed to parse the raw tag router rule and it will not take effect, please check if the \" +\n+                    \"rule matches with the template, the raw rule is:\\n \", e);\n+        }\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url,\n+        Invocation invocation) throws RpcException {\n+\n+\n+        final TagRouterRule tagRouterRuleCopy = (TagRouterRule)cache.getAddrMetadata();\n+\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+\n+        ConcurrentHashMap<String, BitList<Invoker>> addrPool = cache.getAddrPool();\n+\n+        if (StringUtils.isEmpty(tag)) {\n+            return invokers.intersect((BitList)addrPool.get(NO_TAG), invokers.getUnmodifiableList());\n+        } else {\n+            BitList<Invoker> result = addrPool.get(tag);\n+\n+            if (CollectionUtils.isNotEmpty(result) || (tagRouterRuleCopy != null && tagRouterRuleCopy.isForce())\n+                || isForceUseTag(invocation)) {\n+                return invokers.intersect((BitList)result, invokers.getUnmodifiableList());\n+            } else {\n+                invocation.setAttachment(TAG_KEY, NO_TAG);\n+                return invokers;\n+            }\n+        }\n+    }\n+\n+    private boolean isForceUseTag(Invocation invocation) {\n+        return Boolean.valueOf(invocation.getAttachment(FORCE_USE_TAG, url.getParameter(FORCE_USE_TAG, \"false\")));\n+    }\n+\n+    @Override\n+    public boolean isRuntime() {\n+        return tagRouterRule != null && tagRouterRule.isRuntime();\n+    }\n+\n+    @Override\n+    public boolean isEnable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isForce() {\n+        return tagRouterRule != null && tagRouterRule.isForce();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"TagDynamic\";\n+    }\n+\n+    @Override\n+    public boolean shouldRePool() {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> RouterCache pool(List<Invoker<T>> invokers) {\n+\n+        RouterCache routerCache = new RouterCache();\n+        ConcurrentHashMap<String, BitList<Invoker<T>>> addrPool = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9dfe5469c762d5f354aa9f9bf99325f4bba67e2b", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/9dfe5469c762d5f354aa9f9bf99325f4bba67e2b", "committedDate": "2021-05-11T07:58:52Z", "message": "fix comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54f3970065ecc99e862811cdb851503e25207b5b", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/54f3970065ecc99e862811cdb851503e25207b5b", "committedDate": "2021-05-11T08:16:53Z", "message": "fix comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90f2923d82438ac0be0336442ca03628e2054b56", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/90f2923d82438ac0be0336442ca03628e2054b56", "committedDate": "2021-05-11T08:36:19Z", "message": "Merge remote-tracking branch 'origin/3.0' into staterouter-0427"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d3c31f72b3eb970f4f2785951809c25b858aca3", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/3d3c31f72b3eb970f4f2785951809c25b858aca3", "committedDate": "2021-05-12T02:31:53Z", "message": "format files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/b6239270334178742fe512cb4738d6b1b3e27fc7", "committedDate": "2021-05-12T02:49:20Z", "message": "deal dependecy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3NDE5NTMz", "url": "https://github.com/apache/dubbo/pull/6844#pullrequestreview-657419533", "createdAt": "2021-05-12T02:51:55Z", "commit": {"oid": "90f2923d82438ac0be0336442ca03628e2054b56"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMlQwMjo1MTo1NVrOJZeLyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMlQwMzoyMjozMlrOJZeuYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY4ODcxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();\n          \n          \n            \n                private static final ExecutorRepository REPO = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630688713", "createdAt": "2021-05-12T02:51:55Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -45,11 +69,27 @@\n     // instance will never delete or recreate.\n     private List<Router> builtinRouters = Collections.emptyList();\n \n+    private List<StateRouter> builtinStateRouters = Collections.emptyList();\n+    private List<StateRouter> stateRouters = Collections.emptyList();\n+    private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f2923d82438ac0be0336442ca03628e2054b56"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY4ODg4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final ExecutorService LOOP_THREAD_POOL;\n          \n          \n            \n                private final ExecutorService  loopPool;", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630688887", "createdAt": "2021-05-12T02:52:32Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -45,11 +69,27 @@\n     // instance will never delete or recreate.\n     private List<Router> builtinRouters = Collections.emptyList();\n \n+    private List<StateRouter> builtinStateRouters = Collections.emptyList();\n+    private List<StateRouter> stateRouters = Collections.emptyList();\n+    private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();\n+\n+    protected URL url;\n+\n+    protected AtomicReference<AddrCache> cache = new AtomicReference<>();\n+\n+    private Semaphore loopPermit = new Semaphore(1);\n+    private Semaphore loopPermitNotify = new Semaphore(1);\n+\n+    private final ExecutorService LOOP_THREAD_POOL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f2923d82438ac0be0336442ca03628e2054b56"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY4OTAxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Semaphore loopPermit = new Semaphore(1);\n          \n          \n            \n                private final Semaphore loopPermit = new Semaphore(1);", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630689012", "createdAt": "2021-05-12T02:52:57Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -45,11 +69,27 @@\n     // instance will never delete or recreate.\n     private List<Router> builtinRouters = Collections.emptyList();\n \n+    private List<StateRouter> builtinStateRouters = Collections.emptyList();\n+    private List<StateRouter> stateRouters = Collections.emptyList();\n+    private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();\n+\n+    protected URL url;\n+\n+    protected AtomicReference<AddrCache> cache = new AtomicReference<>();\n+\n+    private Semaphore loopPermit = new Semaphore(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f2923d82438ac0be0336442ca03628e2054b56"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY4OTE4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Semaphore loopPermitNotify = new Semaphore(1);\n          \n          \n            \n                private final Semaphore loopPermitNotify = new Semaphore(1);", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630689186", "createdAt": "2021-05-12T02:53:31Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -45,11 +69,27 @@\n     // instance will never delete or recreate.\n     private List<Router> builtinRouters = Collections.emptyList();\n \n+    private List<StateRouter> builtinStateRouters = Collections.emptyList();\n+    private List<StateRouter> stateRouters = Collections.emptyList();\n+    private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();\n+\n+    protected URL url;\n+\n+    protected AtomicReference<AddrCache> cache = new AtomicReference<>();\n+\n+    private Semaphore loopPermit = new Semaphore(1);\n+    private Semaphore loopPermitNotify = new Semaphore(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f2923d82438ac0be0336442ca03628e2054b56"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY4OTY4OA==", "bodyText": "unused method", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630689688", "createdAt": "2021-05-12T02:55:12Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -70,6 +121,15 @@ public void initWithRouters(List<Router> builtinRouters) {\n         this.sort();\n     }\n \n+    public void initWithStateRouters(List<StateRouter> builtinRouters) {\n+        this.builtinStateRouters = builtinRouters;\n+        this.stateRouters = new ArrayList<>(builtinRouters);\n+    }\n+\n+    private void sortStateRouters() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f2923d82438ac0be0336442ca03628e2054b56"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY4OTc2Mg==", "bodyText": "unused method", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630689762", "createdAt": "2021-05-12T02:55:32Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -86,6 +146,13 @@ public void addRouters(List<Router> routers) {\n         this.routers = newRouters;\n     }\n \n+    public void addStateRouters(List<StateRouter> stateRouters) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90f2923d82438ac0be0336442ca03628e2054b56"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MDg1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    while (iter.hasNext()) {\n          \n          \n            \n                    for(Invoker<T> invoker: finalBitListInvokers)", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630690854", "createdAt": "2021-05-12T02:59:09Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -95,13 +157,35 @@ private void sort() {\n     }\n \n     /**\n-     *\n      * @param url\n      * @param invocation\n      * @return\n      */\n     public List<Invoker<T>> route(URL url, Invocation invocation) {\n-        List<Invoker<T>> finalInvokers = invokers;\n+\n+        AddrCache cache = this.cache.get();\n+        if (cache == null) {\n+            throw new RpcException(RpcException.ROUTER_CACHE_NOT_BUILD, \"Failed to invoke the method \"\n+                + invocation.getMethodName() + \" in the service \" + url.getServiceInterface()\n+                + \". address cache not build \"\n+                + \" on the consumer \" + NetUtils.getLocalHost()\n+                + \" using the dubbo version \" + Version.getVersion()\n+                + \".\");\n+        }\n+        BitList<Invoker<T>> finalBitListInvokers = new BitList<Invoker<T>>(invokers, false);\n+        for (StateRouter stateRouter : stateRouters) {\n+            if (stateRouter.isEnable()) {\n+                finalBitListInvokers = stateRouter.route(finalBitListInvokers,\n+                    cache.getCache().get(stateRouter.getName()), url, invocation);\n+            }\n+        }\n+\n+        List<Invoker<T>> finalInvokers = new ArrayList<>(finalBitListInvokers.size());\n+        Iterator<Invoker<T>> iter = finalBitListInvokers.iterator();\n+        while (iter.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MDk0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);\n          \n          \n            \n                    List<Invoker<T>> copyInvokers = new ArrayList<>(this.invokers);", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630690948", "createdAt": "2021-05-12T02:59:31Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -114,7 +198,87 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MTc2OQ==", "bodyText": "unused var", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630691769", "createdAt": "2021-05-12T03:02:16Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -114,7 +198,87 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MjA2Mg==", "bodyText": "remove this var", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630692062", "createdAt": "2021-05-12T03:03:13Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -114,7 +198,87 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MjcxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        RouterCache routerCache;\n          \n          \n            \n                      \n          \n          \n            \n                        try{\n          \n          \n            \n                          for(;;)\n          \n          \n            \n                          this.cache.set()\n          \n          \n            \n                          }catch{\n          \n          \n            \n                          }", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630692718", "createdAt": "2021-05-12T03:05:32Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -114,7 +198,87 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : stateRouters) {\n+            RouterCache routerCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MjgyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RouterCache routerCache = null;\n          \n          \n            \n                    RouterCache routerCache ;", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630692823", "createdAt": "2021-05-12T03:05:52Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -114,7 +198,87 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : stateRouters) {\n+            RouterCache routerCache;\n+            try {\n+                routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);\n+                //file cache\n+                newCache.getCache().put(stateRouter.getName(), routerCache);\n+            } catch (Throwable t) {\n+                poolSuccess.set(false);\n+                logger.error(\"Failed to pool router: \" + stateRouter.getUrl() + \", cause: \" + t.getMessage(), t);\n+            } finally {\n+                cdl.countDown();\n+            }\n+        }\n+\n+        if (poolSuccess.get()) {\n+            this.cache.set(newCache);\n+        }\n+    }\n+\n+    private RouterCache poolRouter(StateRouter router, AddrCache orign, List<Invoker<T>> invokers, boolean notify) {\n+        String routerName = router.getName();\n+        RouterCache routerCache = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5Mjk1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (cache == null || cache.getCache() == null || cache.getInvokers() == null || cache.getCache().get(routerName)\n          \n          \n            \n                          return cache == null || cache.getCache() == null || cache.getInvokers() == null || \n          \n          \n            \n                            cache.getCache().get(routerName) == null;", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630692958", "createdAt": "2021-05-12T03:06:28Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -114,7 +198,87 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : stateRouters) {\n+            RouterCache routerCache;\n+            try {\n+                routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);\n+                //file cache\n+                newCache.getCache().put(stateRouter.getName(), routerCache);\n+            } catch (Throwable t) {\n+                poolSuccess.set(false);\n+                logger.error(\"Failed to pool router: \" + stateRouter.getUrl() + \", cause: \" + t.getMessage(), t);\n+            } finally {\n+                cdl.countDown();\n+            }\n+        }\n+\n+        if (poolSuccess.get()) {\n+            this.cache.set(newCache);\n+        }\n+    }\n+\n+    private RouterCache poolRouter(StateRouter router, AddrCache orign, List<Invoker<T>> invokers, boolean notify) {\n+        String routerName = router.getName();\n+        RouterCache routerCache = null;\n+        if (isCacheMiss(orign, routerName) || router.shouldRePool() || notify) {\n+            return router.pool(invokers);\n+        } else {\n+            routerCache = orign.getCache().get(routerName);\n+        }\n+        if (routerCache == null) {\n+            return new RouterCache();\n+        }\n+        return routerCache;\n+    }\n+\n+    private boolean isCacheMiss(AddrCache cache, String routerName) {\n+        if (cache == null || cache.getCache() == null || cache.getInvokers() == null || cache.getCache().get(routerName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MzYwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public interface StateRouter extends Comparable<StateRouter> {\n          \n          \n            \n            public interface StateRouter<T> extends Comparable<StateRouter<T>>", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630693605", "createdAt": "2021-05-12T03:08:34Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.dubbo.rpc.cluster.router.state;\r\n+\r\n+import java.util.List;\r\n+\r\n+import org.apache.dubbo.common.URL;\r\n+import org.apache.dubbo.rpc.Invocation;\r\n+import org.apache.dubbo.rpc.Invoker;\r\n+import org.apache.dubbo.rpc.RpcException;\r\n+import org.apache.dubbo.rpc.cluster.Directory;\r\n+\r\n+/**\r\n+ * Router. (SPI, Prototype, ThreadSafe)\r\n+ * <p>\r\n+ * <a href=\"http://en.wikipedia.org/wiki/Routing\">Routing</a>\r\n+ *\r\n+ * @see org.apache.dubbo.rpc.cluster.Cluster#join(Directory)\r\n+ * @see Directory#list(Invocation)\r\n+ */\r\n+public interface StateRouter extends Comparable<StateRouter> {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MzY3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url, Invocation invocation)\n          \n          \n            \n            BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url, Invocation invocation)", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630693675", "createdAt": "2021-05-12T03:08:48Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.dubbo.rpc.cluster.router.state;\r\n+\r\n+import java.util.List;\r\n+\r\n+import org.apache.dubbo.common.URL;\r\n+import org.apache.dubbo.rpc.Invocation;\r\n+import org.apache.dubbo.rpc.Invoker;\r\n+import org.apache.dubbo.rpc.RpcException;\r\n+import org.apache.dubbo.rpc.cluster.Directory;\r\n+\r\n+/**\r\n+ * Router. (SPI, Prototype, ThreadSafe)\r\n+ * <p>\r\n+ * <a href=\"http://en.wikipedia.org/wiki/Routing\">Routing</a>\r\n+ *\r\n+ * @see org.apache.dubbo.rpc.cluster.Cluster#join(Directory)\r\n+ * @see Directory#list(Invocation)\r\n+ */\r\n+public interface StateRouter extends Comparable<StateRouter> {\r\n+\r\n+    int DEFAULT_PRIORITY = Integer.MAX_VALUE;\r\n+\r\n+    /**\r\n+     * Get the router url.\r\n+     *\r\n+     * @return url\r\n+     */\r\n+    URL getUrl();\r\n+\r\n+    /**\r\n+     * Filter invokers with current routing rule and only return the invokers that comply with the rule.\r\n+     *\r\n+     * @param invokers   invoker list\r\n+     * @param url        refer url\r\n+     * @param invocation invocation\r\n+     * @return routed invokers\r\n+     * @throws RpcException\r\n+     */\r\n+    <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url, Invocation invocation)\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5Mzk0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <T> RouterCache pool(List<Invoker<T>> invokers);\n          \n          \n            \n                 RouterCache pool(List<Invoker<T>> invokers);", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630693941", "createdAt": "2021-05-12T03:09:32Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.dubbo.rpc.cluster.router.state;\r\n+\r\n+import java.util.List;\r\n+\r\n+import org.apache.dubbo.common.URL;\r\n+import org.apache.dubbo.rpc.Invocation;\r\n+import org.apache.dubbo.rpc.Invoker;\r\n+import org.apache.dubbo.rpc.RpcException;\r\n+import org.apache.dubbo.rpc.cluster.Directory;\r\n+\r\n+/**\r\n+ * Router. (SPI, Prototype, ThreadSafe)\r\n+ * <p>\r\n+ * <a href=\"http://en.wikipedia.org/wiki/Routing\">Routing</a>\r\n+ *\r\n+ * @see org.apache.dubbo.rpc.cluster.Cluster#join(Directory)\r\n+ * @see Directory#list(Invocation)\r\n+ */\r\n+public interface StateRouter extends Comparable<StateRouter> {\r\n+\r\n+    int DEFAULT_PRIORITY = Integer.MAX_VALUE;\r\n+\r\n+    /**\r\n+     * Get the router url.\r\n+     *\r\n+     * @return url\r\n+     */\r\n+    URL getUrl();\r\n+\r\n+    /**\r\n+     * Filter invokers with current routing rule and only return the invokers that comply with the rule.\r\n+     *\r\n+     * @param invokers   invoker list\r\n+     * @param url        refer url\r\n+     * @param invocation invocation\r\n+     * @return routed invokers\r\n+     * @throws RpcException\r\n+     */\r\n+    <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url, Invocation invocation)\r\n+        throws\r\n+        RpcException;\r\n+\r\n+    default <T> void notify(List<Invoker<T>> invokers) {\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * To decide whether this router need to execute every time an RPC comes or should only execute when addresses or\r\n+     * rule change.\r\n+     *\r\n+     * @return true if the router need to execute every time.\r\n+     */\r\n+    boolean isRuntime();\r\n+\r\n+    boolean isEnable();\r\n+\r\n+    boolean isForce();\r\n+\r\n+    int getPriority();\r\n+\r\n+    @Override\r\n+    default int compareTo(StateRouter o) {\r\n+        if (o == null) {\r\n+            throw new IllegalArgumentException();\r\n+        }\r\n+        return Integer.compare(this.getPriority(), o.getPriority());\r\n+    }\r\n+\r\n+    String getName();\r\n+\r\n+    boolean shouldRePool();\r\n+\r\n+    <T> RouterCache pool(List<Invoker<T>> invokers);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NDE0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                StateRouter getRouter(URL url, RouterChain chain);\n          \n          \n            \n                   <T> StateRouter<T> getRouter(URL url, RouterChain<T> chain);", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630694146", "createdAt": "2021-05-12T03:10:21Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouterFactory.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.Adaptive;\n+import org.apache.dubbo.common.extension.SPI;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+\n+@SPI\n+public interface StateRouterFactory {\n+    /**\n+     * Create router.\n+     * Since 2.7.0, most of the time, we will not use @Adaptive feature, so it's kept only for compatibility.\n+     *\n+     * @param url url\n+     * @return router instance\n+     */\n+    @Adaptive(\"protocol\")\n+    StateRouter getRouter(URL url, RouterChain chain);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NDUzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class RouterCache {\n          \n          \n            \n            RouterCache<T>", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630694539", "createdAt": "2021-05-12T03:11:42Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/RouterCache.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class RouterCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NTAwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void setAddrPool(\n          \n          \n            \n                   public void setAddrPool(ConcurrentHashMap<String, BitList<Invoker<T>>> addrPool) {", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630695003", "createdAt": "2021-05-12T03:13:19Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/RouterCache.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class RouterCache {\n+    protected ConcurrentHashMap<String, BitList<Invoker>> addrPool = new ConcurrentHashMap<>();\n+    protected Object addrMetadata;\n+\n+    public ConcurrentHashMap<String, BitList<Invoker>> getAddrPool() {\n+        return addrPool;\n+    }\n+\n+    public void setAddrPool(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NTQxMw==", "bodyText": "Use a constant empty map instead of creating a new one", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630695413", "createdAt": "2021-05-12T03:14:47Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/RouterCache.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class RouterCache {\n+    protected ConcurrentHashMap<String, BitList<Invoker>> addrPool = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NTQ5Ng==", "bodyText": "ConcurrentHashMap -> ConcurrentMap", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630695496", "createdAt": "2021-05-12T03:15:06Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/RouterCache.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class RouterCache {\n+    protected ConcurrentHashMap<String, BitList<Invoker>> addrPool = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NTQxMw=="}, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NTY4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    routerCache.setAddrPool((ConcurrentHashMap)addrPool);\n          \n          \n            \n                    routerCache.setAddrPool(addrPool);", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630695685", "createdAt": "2021-05-12T03:15:47Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;\n+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;\n+import org.apache.dubbo.common.config.configcenter.ConfigurationListener;\n+import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;\n+import org.apache.dubbo.common.constants.CommonConstants;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRuleParser;\n+\n+import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+import static org.apache.dubbo.rpc.Constants.FORCE_USE_TAG;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagDynamicStateRouter extends AbstractStateRouter implements ConfigurationListener {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagDynamicStateRouter.class);\n+    private static final String RULE_SUFFIX = \".tag-router\";\n+    private static final String NO_TAG = \"noTag\";\n+\n+    private TagRouterRule tagRouterRule;\n+    private String application;\n+\n+    public TagDynamicStateRouter(URL url, RouterChain chain) {\n+        super(url, chain);\n+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;\n+    }\n+\n+    @Override\n+    public synchronized void process(ConfigChangedEvent event) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Notification of tag rule, change type is: \" + event.getChangeType() + \", raw rule is:\\n \" +\n+                event.getContent());\n+        }\n+\n+        try {\n+            if (event.getChangeType().equals(ConfigChangeType.DELETED)) {\n+                this.tagRouterRule = null;\n+            } else {\n+                this.tagRouterRule = TagRuleParser.parse(event.getContent());\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Failed to parse the raw tag router rule and it will not take effect, please check if the \" +\n+                \"rule matches with the template, the raw rule is:\\n \", e);\n+        }\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url,\n+        Invocation invocation) throws RpcException {\n+\n+\n+        final TagRouterRule tagRouterRuleCopy = (TagRouterRule)cache.getAddrMetadata();\n+\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+\n+        ConcurrentHashMap<String, BitList<Invoker>> addrPool = cache.getAddrPool();\n+\n+        if (StringUtils.isEmpty(tag)) {\n+            return invokers.intersect((BitList)addrPool.get(NO_TAG), invokers.getUnmodifiableList());\n+        } else {\n+            BitList<Invoker> result = addrPool.get(tag);\n+\n+            if (CollectionUtils.isNotEmpty(result) || (tagRouterRuleCopy != null && tagRouterRuleCopy.isForce())\n+                || isForceUseTag(invocation)) {\n+                return invokers.intersect((BitList)result, invokers.getUnmodifiableList());\n+            } else {\n+                invocation.setAttachment(TAG_KEY, NO_TAG);\n+                return invokers;\n+            }\n+        }\n+    }\n+\n+    private boolean isForceUseTag(Invocation invocation) {\n+        return Boolean.valueOf(invocation.getAttachment(FORCE_USE_TAG, url.getParameter(FORCE_USE_TAG, \"false\")));\n+    }\n+\n+    @Override\n+    public boolean isRuntime() {\n+        return tagRouterRule != null && tagRouterRule.isRuntime();\n+    }\n+\n+    @Override\n+    public boolean isEnable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isForce() {\n+        return tagRouterRule != null && tagRouterRule.isForce();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"TagDynamic\";\n+    }\n+\n+    @Override\n+    public boolean shouldRePool() {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> RouterCache pool(List<Invoker<T>> invokers) {\n+\n+        RouterCache routerCache = new RouterCache();\n+        ConcurrentHashMap<String, BitList<Invoker<T>>> addrPool = new ConcurrentHashMap<>();\n+\n+        final TagRouterRule tagRouterRuleCopy = tagRouterRule;\n+\n+\n+        if (tagRouterRuleCopy == null || !tagRouterRuleCopy.isValid() || !tagRouterRuleCopy.isEnabled()) {\n+            return routerCache;\n+        }\n+\n+        List<String> tagNames = tagRouterRuleCopy.getTagNames();\n+        Map<String, List<String>> tagnameToAddresses = tagRouterRuleCopy.getTagnameToAddresses();\n+\n+        for (String tag : tagNames) {\n+            List<String> addresses = tagnameToAddresses.get(tag);\n+            BitList<Invoker<T>> list = new BitList<>(invokers, true);\n+\n+            if (CollectionUtils.isEmpty(addresses)) {\n+                list.addAll(invokers);\n+            } else {\n+                for (int index = 0; index < invokers.size(); index++) {\n+                    Invoker<T> invoker = invokers.get(index);\n+                    if (addressMatches(invoker.getUrl(), addresses)) {\n+                        list.addIndex(index);\n+                    }\n+                }\n+            }\n+\n+            addrPool.put(tag, list);\n+        }\n+\n+        List<String> addresses = tagRouterRuleCopy.getAddresses();\n+        BitList<Invoker<T>> noTagList = new BitList<>(invokers, true);\n+\n+        for (int index = 0; index < invokers.size(); index++) {\n+            Invoker<T> invoker = invokers.get(index);\n+            if (addressNotMatches(invoker.getUrl(), addresses)) {\n+                noTagList.addIndex(index);\n+            }\n+        }\n+        addrPool.put(NO_TAG, noTagList);\n+        routerCache.setAddrPool((ConcurrentHashMap)addrPool);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NjA4NA==", "bodyText": "unused field", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630696084", "createdAt": "2021-05-12T03:17:04Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagStaticStateRouter extends AbstractStateRouter {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagStaticStateRouter.class);\n+    private static final String RULE_SUFFIX = \".tag-router\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NjA5Ng==", "bodyText": "unused field", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630696096", "createdAt": "2021-05-12T03:17:09Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagStaticStateRouter extends AbstractStateRouter {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagStaticStateRouter.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NjE2MA==", "bodyText": "Fix what?", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630696160", "createdAt": "2021-05-12T03:17:27Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagStaticStateRouter extends AbstractStateRouter {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagStaticStateRouter.class);\n+    private static final String RULE_SUFFIX = \".tag-router\";\n+    private static final String NO_TAG = \"noTag\";\n+\n+    private TagRouterRule tagRouterRule;\n+\n+    public TagStaticStateRouter(URL url, RouterChain chain) {\n+        super(url, chain);\n+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache routerCache, URL url, Invocation invocation)\n+        throws RpcException {\n+\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+        if (StringUtils.isEmpty(tag)) {\n+            tag = NO_TAG;\n+        }\n+\n+        ConcurrentHashMap<String, BitList<Invoker>> pool = routerCache.getAddrPool();\n+        BitList res = pool.get(tag);\n+        if (res == null) {\n+            return invokers;\n+        }\n+        return invokers.intersect((BitList)res, invokers.getUnmodifiableList());\n+    }\n+\n+    @Override\n+    protected List<String> getTags(URL url, Invocation invocation) {\n+        List<String> tags = new ArrayList<>();\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+        if (StringUtils.isEmpty(tag)) {\n+            tag = NO_TAG;\n+        }\n+        tags.add(tag);\n+        return tags;\n+    }\n+\n+    @Override\n+    public boolean isRuntime() {\n+        return tagRouterRule != null && tagRouterRule.isRuntime();\n+    }\n+\n+    @Override\n+    public boolean isEnable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isForce() {\n+        // FIXME", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NjI1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    routerCache.setAddrPool((ConcurrentHashMap)addrPool);\n          \n          \n            \n                    routerCache.setAddrPool(addrPool);", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630696258", "createdAt": "2021-05-12T03:17:43Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagStaticStateRouter extends AbstractStateRouter {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagStaticStateRouter.class);\n+    private static final String RULE_SUFFIX = \".tag-router\";\n+    private static final String NO_TAG = \"noTag\";\n+\n+    private TagRouterRule tagRouterRule;\n+\n+    public TagStaticStateRouter(URL url, RouterChain chain) {\n+        super(url, chain);\n+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache routerCache, URL url, Invocation invocation)\n+        throws RpcException {\n+\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+        if (StringUtils.isEmpty(tag)) {\n+            tag = NO_TAG;\n+        }\n+\n+        ConcurrentHashMap<String, BitList<Invoker>> pool = routerCache.getAddrPool();\n+        BitList res = pool.get(tag);\n+        if (res == null) {\n+            return invokers;\n+        }\n+        return invokers.intersect((BitList)res, invokers.getUnmodifiableList());\n+    }\n+\n+    @Override\n+    protected List<String> getTags(URL url, Invocation invocation) {\n+        List<String> tags = new ArrayList<>();\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+        if (StringUtils.isEmpty(tag)) {\n+            tag = NO_TAG;\n+        }\n+        tags.add(tag);\n+        return tags;\n+    }\n+\n+    @Override\n+    public boolean isRuntime() {\n+        return tagRouterRule != null && tagRouterRule.isRuntime();\n+    }\n+\n+    @Override\n+    public boolean isEnable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isForce() {\n+        // FIXME\n+        return false;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"TagStatic\";\n+    }\n+\n+    @Override\n+    public boolean shouldRePool() {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> RouterCache pool(List<Invoker<T>> invokers) {\n+\n+        RouterCache routerCache = new RouterCache();\n+        ConcurrentHashMap<String, BitList<Invoker<T>>> addrPool = new ConcurrentHashMap<>();\n+\n+        for (int index = 0; index < invokers.size(); index++) {\n+            Invoker<T> invoker = invokers.get(index);\n+            String tag = invoker.getUrl().getParameter(TAG_KEY);\n+            if (StringUtils.isEmpty(tag)) {\n+                BitList<Invoker<T>> noTagList = addrPool.putIfAbsent(NO_TAG, new BitList<>(invokers, true));\n+                if (noTagList == null) {\n+                    noTagList = addrPool.get(NO_TAG);\n+                }\n+                noTagList.addIndex(index);\n+            } else {\n+                BitList<Invoker<T>> list = addrPool.putIfAbsent(tag, new BitList<>(invokers, true));\n+                if (list == null) {\n+                    list = addrPool.get(tag);\n+                }\n+                list.addIndex(index);\n+            }\n+        }\n+\n+        routerCache.setAddrPool((ConcurrentHashMap)addrPool);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5Njk2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class AddrCache {\n          \n          \n            \n            public class AddrCache<T> {", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630696964", "createdAt": "2021-05-12T03:20:32Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class AddrCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NzAyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected List<Invoker> invokers;\n          \n          \n            \n                   protected List<Invoker<T>> invokers;", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630697026", "createdAt": "2021-05-12T03:20:49Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class AddrCache {\n+    protected List<Invoker> invokers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NzE0NA==", "bodyText": "Use constant empty map", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630697144", "createdAt": "2021-05-12T03:21:09Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class AddrCache {\n+    protected List<Invoker> invokers;\n+    protected ConcurrentHashMap<String, RouterCache> cache = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NzIzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void setCache(\n          \n          \n            \n                   public void setCache(ConcurrentHashMap<String, RouterCache> cache) {", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630697237", "createdAt": "2021-05-12T03:21:28Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class AddrCache {\n+    protected List<Invoker> invokers;\n+    protected ConcurrentHashMap<String, RouterCache> cache = new ConcurrentHashMap<>();\n+\n+    public List<Invoker> getInvokers() {\n+        return invokers;\n+    }\n+\n+    public void setInvokers(List<Invoker> invokers) {\n+        this.invokers = invokers;\n+    }\n+\n+    public ConcurrentHashMap<String, RouterCache> getCache() {\n+        return cache;\n+    }\n+\n+    public void setCache(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NzU2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return invokers == null || invokers.size() <= 0;\n          \n          \n            \n                    return invokers == null || invokers.isEmpty();", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630697569", "createdAt": "2021-05-12T03:22:32Z", "author": {"login": "guohao"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AbstractStateRouter.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.ExtensionLoader;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.governance.GovernanceRuleRepository;\n+\n+public abstract class AbstractStateRouter implements StateRouter {\n+    final protected RouterChain chain;\n+    protected int priority = DEFAULT_PRIORITY;\n+    protected boolean force = false;\n+    protected URL url;\n+    protected List<Invoker> invokers;\n+    protected AtomicReference<AddrCache> cache;\n+    protected GovernanceRuleRepository ruleRepository;\n+\n+    public AbstractStateRouter(URL url, RouterChain chain) {\n+        this.ruleRepository = ExtensionLoader.getExtensionLoader(GovernanceRuleRepository.class).getDefaultExtension();\n+        this.chain = chain;\n+        this.url = url;\n+    }\n+\n+    @Override\n+    public <T> void notify(List<Invoker<T>> invokers) {\n+        this.invokers = (List)invokers;\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    public void setUrl(URL url) {\n+        this.url = url;\n+    }\n+\n+    @Override\n+    public boolean isRuntime() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isForce() {\n+        return force;\n+    }\n+\n+    public void setForce(boolean force) {\n+        this.force = force;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+        return priority;\n+    }\n+\n+    public void setPriority(int priority) {\n+        this.priority = priority;\n+    }\n+\n+    @Override\n+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url,\n+        Invocation invocation) throws RpcException {\n+\n+        List<String> tags = getTags(url, invocation);\n+\n+        if (tags == null) {\n+            return invokers;\n+        }\n+        for (String tag : tags) {\n+            BitList tagInvokers = cache.getAddrPool().get(tag);\n+            if (tagMatchFail(tagInvokers)) {\n+                continue;\n+            }\n+            return tagInvokers.intersect(invokers, invokers.getUnmodifiableList());\n+        }\n+\n+        return invokers;\n+    }\n+\n+    protected List<String> getTags(URL url, Invocation invocation) {\n+        return new ArrayList<String>();\n+    }\n+\n+    public <T> Boolean tagMatchFail(BitList<Invoker<T>> invokers) {\n+        return invokers == null || invokers.size() <= 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3NDI5OTQ4", "url": "https://github.com/apache/dubbo/pull/6844#pullrequestreview-657429948", "createdAt": "2021-05-12T03:24:35Z", "commit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMlQwMzoyNDozNVrOJZewjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xMlQwMzoyNDozNVrOJZewjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5ODEyNA==", "bodyText": "unused", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630698124", "createdAt": "2021-05-12T03:24:35Z", "author": {"login": "guohao"}, "path": "dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java", "diffHunk": "@@ -16,20 +16,24 @@\n  */\n package org.apache.dubbo.common.threadpool.manager;\n \n-import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.extension.ExtensionLoader;\n-import org.apache.dubbo.common.logger.Logger;\n-import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.threadpool.ThreadPool;\n-import org.apache.dubbo.common.utils.NamedThreadFactory;\n-\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4959c23f3200044e4987315248826fa98ede53fb", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/4959c23f3200044e4987315248826fa98ede53fb", "committedDate": "2021-05-12T06:58:30Z", "message": "fix comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b33bb702c28019230fe030f4228702943d4479f8", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/b33bb702c28019230fe030f4228702943d4479f8", "committedDate": "2021-05-12T07:21:39Z", "message": "fix comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08852f75d1567883331314a25087cdfef62a1d93", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/08852f75d1567883331314a25087cdfef62a1d93", "committedDate": "2021-05-12T11:26:54Z", "message": "fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f349c9d92775dfa035405cd76190e7035611e215", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/f349c9d92775dfa035405cd76190e7035611e215", "committedDate": "2021-05-13T08:02:18Z", "message": "fix ut"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c52c63828629bf6cda5c6f1c46df057f77e9f1e", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/0c52c63828629bf6cda5c6f1c46df057f77e9f1e", "committedDate": "2021-05-13T09:47:19Z", "message": "fix ut"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70b36fb3b8f722a8f0a84681d2261e56530bac48", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/70b36fb3b8f722a8f0a84681d2261e56530bac48", "committedDate": "2021-05-14T07:27:29Z", "message": "Merge remote-tracking branch 'origin/3.0' into feature/state-router"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8e4e0983d241aeec277f2ec4f29e404a501205d", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/c8e4e0983d241aeec277f2ec4f29e404a501205d", "committedDate": "2021-05-14T08:38:07Z", "message": "fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5NjYyNTY2", "url": "https://github.com/apache/dubbo/pull/6844#pullrequestreview-659662566", "createdAt": "2021-05-14T09:11:24Z", "commit": {"oid": "c8e4e0983d241aeec277f2ec4f29e404a501205d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYwMDAxOTcy", "url": "https://github.com/apache/dubbo/pull/6844#pullrequestreview-660001972", "createdAt": "2021-05-14T16:25:15Z", "commit": {"oid": "c8e4e0983d241aeec277f2ec4f29e404a501205d"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xNFQxNjoyNToxNlrOJbVuAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xNFQxNjoyNToxNlrOJbVuAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMjY0NzE3MA==", "bodyText": "the NAME should be tag-static", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r632647170", "createdAt": "2021-05-14T16:25:16Z", "author": {"login": "AlbumenJ"}, "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouterFactory.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.Activate;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.CacheableStateRouterFactory;\n+import org.apache.dubbo.rpc.cluster.router.state.StateRouter;\n+\n+/**\n+ * Tag router factory\n+ */\n+@Activate(order = 100)\n+public class TagStaticStateRouterFactory extends CacheableStateRouterFactory {\n+\n+    public static final String NAME = \"tag-dynamic\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8e4e0983d241aeec277f2ec4f29e404a501205d"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0165959ecddb25a3a2f69b560ad3bd6512125c4e", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/0165959ecddb25a3a2f69b560ad3bd6512125c4e", "committedDate": "2021-05-15T02:58:20Z", "message": "fix comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5adf586cb0ed2f99157da2bcd68fe3da3283a3e8", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/5adf586cb0ed2f99157da2bcd68fe3da3283a3e8", "committedDate": "2021-05-16T08:59:15Z", "message": "add code comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a793346395748a01bc243c0250043a0c0850640e", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/a793346395748a01bc243c0250043a0c0850640e", "committedDate": "2021-05-17T13:43:23Z", "message": "add code comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07e140131c442c9c83bd3c8541ee214a784fbce5", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/07e140131c442c9c83bd3c8541ee214a784fbce5", "committedDate": "2021-05-17T13:48:41Z", "message": "add code comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79a9131fea17d77f312cb5b34d1d74cf7b16022e", "author": {"user": {"login": "panxiaojun233", "name": null}}, "url": "https://github.com/apache/dubbo/commit/79a9131fea17d77f312cb5b34d1d74cf7b16022e", "committedDate": "2021-05-17T13:52:57Z", "message": "add code comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2249, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}