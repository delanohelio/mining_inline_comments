{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyOTc3MTE4", "number": 675, "title": "Nanopore fast5 upload and display interface", "bodyText": "Description of changes\nUpdated the Sample > Files interface to allow for the upload and display of FAST5 files.\nRelated issue\nN/A\nChecklist\nThings for the developer to confirm they've done before the PR should be accepted:\n* [ ] CHANGELOG.md (and UPGRADING.md if necessary) updated with information for new change.\n* [ ] Tests added (or description of how to test) for any new features.\n* [ ] User documentation updated for UI or technical changes.", "createdAt": "2020-05-04T14:12:52Z", "url": "https://github.com/phac-nml/irida/pull/675", "merged": true, "mergeCommit": {"oid": "869c2ed42faa49ca9d4640a5e2a4764f195915c1"}, "closed": true, "closedAt": "2020-05-05T15:44:35Z", "author": {"login": "joshsadam"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcc-cazgH2gAyNDEyOTc3MTE4OmQzZjAzNTkzZjMwOWMzMDVjNGJjNmI3YjJjZDA4MTM0NmRiYTRkZGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABceWCe5AFqTQwNTkxNjUzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d3f03593f309c305c4bc6b7b2cd081346dba4ddf", "author": {"user": {"login": "joshsadam", "name": "Josh Adam"}}, "url": "https://github.com/phac-nml/irida/commit/d3f03593f309c305c4bc6b7b2cd081346dba4ddf", "committedDate": "2020-05-01T09:41:07Z", "message": "Merge branch 'fast5-model' into fast5-UI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e780aedeb2680708c51051aed208de1acc62cab4", "author": {"user": {"login": "joshsadam", "name": "Josh Adam"}}, "url": "https://github.com/phac-nml/irida/commit/e780aedeb2680708c51051aed208de1acc62cab4", "committedDate": "2020-05-01T13:56:50Z", "message": "\u2728\ufe0f Upload, download and delete FAST5 through UI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea665b3f935305809366b1b6494f541edc3e3f75", "author": {"user": {"login": "tom114", "name": "Tom Matthews"}}, "url": "https://github.com/phac-nml/irida/commit/ea665b3f935305809366b1b6494f541edc3e3f75", "committedDate": "2020-05-01T15:40:47Z", "message": "added changes to samplepairer to detect fast5 files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f691120aab2dcfeaff6fcfd33c2d43f6c738f91", "author": {"user": {"login": "tom114", "name": "Tom Matthews"}}, "url": "https://github.com/phac-nml/irida/commit/3f691120aab2dcfeaff6fcfd33c2d43f6c738f91", "committedDate": "2020-05-04T13:44:33Z", "message": "Merge branch 'nanopore-fast5' into fast5-ui-upload"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78ae6d53e8cadf002dcead2ae1f4232060ca42b5", "author": {"user": {"login": "joshsadam", "name": "Josh Adam"}}, "url": "https://github.com/phac-nml/irida/commit/78ae6d53e8cadf002dcead2ae1f4232060ca42b5", "committedDate": "2020-05-04T13:56:37Z", "message": "Merge branch 'nanopore-fast5' into nanopore-fast5-UI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1464cc304355d49f21ede2f9652ba7050e4ed81b", "author": {"user": {"login": "joshsadam", "name": "Josh Adam"}}, "url": "https://github.com/phac-nml/irida/commit/1464cc304355d49f21ede2f9652ba7050e4ed81b", "committedDate": "2020-05-04T14:46:58Z", "message": "Merge branch 'fast5-ui-upload' into nanopore-fast5-UI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f", "author": {"user": {"login": "joshsadam", "name": "Josh Adam"}}, "url": "https://github.com/phac-nml/irida/commit/4c0c7429470b3322017cc9bc046704487a90306f", "committedDate": "2020-05-04T15:05:36Z", "message": "Updated to work with tom's SamplePairer code."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MjEwNTk3", "url": "https://github.com/phac-nml/irida/pull/675#pullrequestreview-405210597", "createdAt": "2020-05-04T17:49:07Z", "commit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo0OTowN1rOGQLR6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo1ODoyMFrOGQLpPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNTIwOA==", "bodyText": "Can you pull this commented code.  Sorry that's on me I had them in my other branch.", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419615208", "createdAt": "2020-05-04T17:49:07Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplePairer.java", "diffHunk": "@@ -12,136 +13,136 @@\n import java.util.stream.Stream;\n \n /**\n-* \tUtility class for pairing up sequence files with\n-*\tcommon prefixes and expected characters for forward\n-*\tand reverse sequence files. \n-*/\n+ * Utility class for pairing up sequence files with\n+ * common prefixes and expected characters for forward\n+ * and reverse sequence files.\n+ */\n \n public class SamplePairer {\n-\tprivate static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n-\n-\tprivate static DiffMatchPatch diff = new DiffMatchPatch();\n-\t\n-\tprivate static String[] forwardMatches = SequenceFilePair.forwardMatches;\n-\tprivate static String[] reverseMatches = SequenceFilePair.reverseMatches;\n-\n-\t/**\n-\t * Organize files according to whether they should be paired up\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to uploaded sequence files,\n-\t * \t\t\twhere the key is the common prefix of two paired files,\n-\t * \t\t\tor the full file name of a single sequence file\n-\t */\n-\tprivate static Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n-\n-\n-\t\tMultipartFile file1, file2;\n-\n-\t\t//Want to skip files that have already been organized\n-\t\tSet<MultipartFile> wasChecked = new HashSet<>();\n-\n-\t\t//check all uploaded files to see if they should be paired or left single\n-\t\tfor (int i = 0; i < files.size(); i++) {\n-\t\t\tfile1 = files.get(i);\n-\n-\t\t\tboolean pair = false;\n-\t\t\tif (!wasChecked.contains(file1)) {\n-\t\t\t\tfor (int j = i + 1; j < files.size() && !pair; j++) {\n-\t\t\t\t\tfile2 = files.get(j);\n-\n-\t\t\t\t\tif (!wasChecked.contains(file2)) {\n-\t\t\t\t\t\tMultipartFile[] filePair = null;\n-\n-\t\t\t\t\t\tList<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n-\t\t\t\t\t\t//The size of `diffs` is 4 when only 1 character differs between the two strings\n-\t\t\t\t\t\t//if the two files should be paired, this would be the list of diffs between the file names:\n-\t\t\t\t\t\t//\t\tdiffs[0] = common prefix\n-\t\t\t\t\t\t//\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n-\t\t\t\t\t\t//\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n-\t\t\t\t\t\t//\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n-\t\t\t\t\t\tif (diffs.size() == 4) {\n-\t\t\t\t\t\t\tString file1ID = diffs.get(1).text;\n-\t\t\t\t\t\t\tString file2ID = diffs.get(2).text;\n-\t\t\t\t\t\t\t//Sometimes files uploaded get put in a different ordering such that\n-\t\t\t\t\t\t\t//the first file is the \"reverse\" sequence file and the last file is\n-\t\t\t\t\t\t\t//the \"forward\" sequence file. This long condition checks for that\n-\t\t\t\t\t\t\t//situation.\n-\t\t\t\t\t\t\tif ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n-\t\t\t\t\t\t\t\t\t|| (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n-\t\t\t\t\t\t\t\tfilePair = new MultipartFile[]{file1, file2};\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif (filePair != null) {\n-\t\t\t\t\t\t\tpair = true;\n-\t\t\t\t\t\t\torganizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n-\t\t\t\t\t\t\tlogger.trace(\"Uploaded files [\" + filePair[0].getName() + \", \" + filePair[1].getName()\n-\t\t\t\t\t\t\t\t+ \"] were paired.\");\n-\t\t\t\t\t\t\twasChecked.add(file2);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (!pair) {\n-\t\t\t\t\tMultipartFile[] singleFile = {file1};\n-\t\t\t\t\torganizedFiles.put(file1.getOriginalFilename(), Arrays.asList(singleFile));\n-\t\t\t\t\tlogger.trace(\"Uploaded file [\" + file1.getName() +\"] was not paired\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\twasChecked.add(file1);\n-\t\t}\n-\n-\t\treturn organizedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all paired sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to paired sequence files.\n-\t */\n-\tpublic static Map<String, List<MultipartFile>> getPairedFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> pairedFiles = new HashMap<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() > 1) {\n-\t\t\t\tpairedFiles.put(key, item);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn pairedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all single sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return List of {@link Path}s to single sequence files.\n-\t */\n-\tpublic static List<MultipartFile> getSingleFiles(List<MultipartFile> files) {\n-\n-\t\tList<MultipartFile> singleFilePaths = new ArrayList<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() == 1) {\n-\t\t\t\tsingleFilePaths.add(item.get(0));\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn singleFilePaths;\n-\t}\n+    private static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n+\n+    private static DiffMatchPatch diff = new DiffMatchPatch();\n+\n+    private static String[] forwardMatches = SequenceFilePair.forwardMatches;\n+    private static String[] reverseMatches = SequenceFilePair.reverseMatches;\n+\n+    private static String FAST5_EXTENSION = \"fast5\";\n+\n+    private Map<String, List<MultipartFile>> pairedFiles;\n+    private List<MultipartFile> fast5Files;\n+    private List<MultipartFile> singleFiles;\n+\n+    public SamplePairer(List<MultipartFile> files) {\n+        this.singleFiles = new ArrayList<>();\n+        this.pairedFiles = new HashMap<>();\n+        this.fast5Files = new ArrayList<>();\n+\n+        organizeFiles(files);\n+    }\n+\n+    /**\n+     * Organize files according to whether they should be paired up\n+     *\n+     * @param files List of {@link MultipartFile}s uploaded\n+     * @return Map of {@link Path}s to uploaded sequence files,\n+     * where the key is the common prefix of two paired files,\n+     * or the full file name of a single sequence file\n+     */\n+    private Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n+\n+        Map<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n+\n+        MultipartFile file1, file2;\n+\n+        //Want to skip files that have already been organized\n+        Set<MultipartFile> wasChecked = new HashSet<>();\n+\n+        //check all uploaded files to see if they should be paired or left single\n+        for (int i = 0; i < files.size(); i++) {\n+            file1 = files.get(i);\n+\n+            boolean pair = false;\n+            if (!wasChecked.contains(file1)) {\n+                for (int j = i + 1; j < files.size() && !pair; j++) {\n+                    file2 = files.get(j);\n+\n+                    if (!wasChecked.contains(file2)) {\n+                        MultipartFile[] filePair = null;\n+\n+                        List<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n+                        //The size of `diffs` is 4 when only 1 character differs between the two strings\n+                        //if the two files should be paired, this would be the list of diffs between the file names:\n+                        //\t\tdiffs[0] = common prefix\n+                        //\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n+                        //\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n+                        //\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n+                        if (diffs.size() == 4) {\n+                            String file1ID = diffs.get(1).text;\n+                            String file2ID = diffs.get(2).text;\n+                            //Sometimes files uploaded get put in a different ordering such that\n+                            //the first file is the \"reverse\" sequence file and the last file is\n+                            //the \"forward\" sequence file. This long condition checks for that\n+                            //situation.\n+                            if ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n+                                    || (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n+                                filePair = new MultipartFile[]{file1, file2};\n+                            }\n+                        }\n+\n+                        if (filePair != null) {\n+                            pair = true;\n+                            //organizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNTMwOA==", "bodyText": "Same here.  Delete it please.", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419615308", "createdAt": "2020-05-04T17:49:17Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplePairer.java", "diffHunk": "@@ -12,136 +13,136 @@\n import java.util.stream.Stream;\n \n /**\n-* \tUtility class for pairing up sequence files with\n-*\tcommon prefixes and expected characters for forward\n-*\tand reverse sequence files. \n-*/\n+ * Utility class for pairing up sequence files with\n+ * common prefixes and expected characters for forward\n+ * and reverse sequence files.\n+ */\n \n public class SamplePairer {\n-\tprivate static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n-\n-\tprivate static DiffMatchPatch diff = new DiffMatchPatch();\n-\t\n-\tprivate static String[] forwardMatches = SequenceFilePair.forwardMatches;\n-\tprivate static String[] reverseMatches = SequenceFilePair.reverseMatches;\n-\n-\t/**\n-\t * Organize files according to whether they should be paired up\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to uploaded sequence files,\n-\t * \t\t\twhere the key is the common prefix of two paired files,\n-\t * \t\t\tor the full file name of a single sequence file\n-\t */\n-\tprivate static Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n-\n-\n-\t\tMultipartFile file1, file2;\n-\n-\t\t//Want to skip files that have already been organized\n-\t\tSet<MultipartFile> wasChecked = new HashSet<>();\n-\n-\t\t//check all uploaded files to see if they should be paired or left single\n-\t\tfor (int i = 0; i < files.size(); i++) {\n-\t\t\tfile1 = files.get(i);\n-\n-\t\t\tboolean pair = false;\n-\t\t\tif (!wasChecked.contains(file1)) {\n-\t\t\t\tfor (int j = i + 1; j < files.size() && !pair; j++) {\n-\t\t\t\t\tfile2 = files.get(j);\n-\n-\t\t\t\t\tif (!wasChecked.contains(file2)) {\n-\t\t\t\t\t\tMultipartFile[] filePair = null;\n-\n-\t\t\t\t\t\tList<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n-\t\t\t\t\t\t//The size of `diffs` is 4 when only 1 character differs between the two strings\n-\t\t\t\t\t\t//if the two files should be paired, this would be the list of diffs between the file names:\n-\t\t\t\t\t\t//\t\tdiffs[0] = common prefix\n-\t\t\t\t\t\t//\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n-\t\t\t\t\t\t//\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n-\t\t\t\t\t\t//\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n-\t\t\t\t\t\tif (diffs.size() == 4) {\n-\t\t\t\t\t\t\tString file1ID = diffs.get(1).text;\n-\t\t\t\t\t\t\tString file2ID = diffs.get(2).text;\n-\t\t\t\t\t\t\t//Sometimes files uploaded get put in a different ordering such that\n-\t\t\t\t\t\t\t//the first file is the \"reverse\" sequence file and the last file is\n-\t\t\t\t\t\t\t//the \"forward\" sequence file. This long condition checks for that\n-\t\t\t\t\t\t\t//situation.\n-\t\t\t\t\t\t\tif ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n-\t\t\t\t\t\t\t\t\t|| (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n-\t\t\t\t\t\t\t\tfilePair = new MultipartFile[]{file1, file2};\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif (filePair != null) {\n-\t\t\t\t\t\t\tpair = true;\n-\t\t\t\t\t\t\torganizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n-\t\t\t\t\t\t\tlogger.trace(\"Uploaded files [\" + filePair[0].getName() + \", \" + filePair[1].getName()\n-\t\t\t\t\t\t\t\t+ \"] were paired.\");\n-\t\t\t\t\t\t\twasChecked.add(file2);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (!pair) {\n-\t\t\t\t\tMultipartFile[] singleFile = {file1};\n-\t\t\t\t\torganizedFiles.put(file1.getOriginalFilename(), Arrays.asList(singleFile));\n-\t\t\t\t\tlogger.trace(\"Uploaded file [\" + file1.getName() +\"] was not paired\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\twasChecked.add(file1);\n-\t\t}\n-\n-\t\treturn organizedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all paired sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to paired sequence files.\n-\t */\n-\tpublic static Map<String, List<MultipartFile>> getPairedFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> pairedFiles = new HashMap<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() > 1) {\n-\t\t\t\tpairedFiles.put(key, item);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn pairedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all single sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return List of {@link Path}s to single sequence files.\n-\t */\n-\tpublic static List<MultipartFile> getSingleFiles(List<MultipartFile> files) {\n-\n-\t\tList<MultipartFile> singleFilePaths = new ArrayList<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() == 1) {\n-\t\t\t\tsingleFilePaths.add(item.get(0));\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn singleFilePaths;\n-\t}\n+    private static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n+\n+    private static DiffMatchPatch diff = new DiffMatchPatch();\n+\n+    private static String[] forwardMatches = SequenceFilePair.forwardMatches;\n+    private static String[] reverseMatches = SequenceFilePair.reverseMatches;\n+\n+    private static String FAST5_EXTENSION = \"fast5\";\n+\n+    private Map<String, List<MultipartFile>> pairedFiles;\n+    private List<MultipartFile> fast5Files;\n+    private List<MultipartFile> singleFiles;\n+\n+    public SamplePairer(List<MultipartFile> files) {\n+        this.singleFiles = new ArrayList<>();\n+        this.pairedFiles = new HashMap<>();\n+        this.fast5Files = new ArrayList<>();\n+\n+        organizeFiles(files);\n+    }\n+\n+    /**\n+     * Organize files according to whether they should be paired up\n+     *\n+     * @param files List of {@link MultipartFile}s uploaded\n+     * @return Map of {@link Path}s to uploaded sequence files,\n+     * where the key is the common prefix of two paired files,\n+     * or the full file name of a single sequence file\n+     */\n+    private Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n+\n+        Map<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n+\n+        MultipartFile file1, file2;\n+\n+        //Want to skip files that have already been organized\n+        Set<MultipartFile> wasChecked = new HashSet<>();\n+\n+        //check all uploaded files to see if they should be paired or left single\n+        for (int i = 0; i < files.size(); i++) {\n+            file1 = files.get(i);\n+\n+            boolean pair = false;\n+            if (!wasChecked.contains(file1)) {\n+                for (int j = i + 1; j < files.size() && !pair; j++) {\n+                    file2 = files.get(j);\n+\n+                    if (!wasChecked.contains(file2)) {\n+                        MultipartFile[] filePair = null;\n+\n+                        List<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n+                        //The size of `diffs` is 4 when only 1 character differs between the two strings\n+                        //if the two files should be paired, this would be the list of diffs between the file names:\n+                        //\t\tdiffs[0] = common prefix\n+                        //\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n+                        //\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n+                        //\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n+                        if (diffs.size() == 4) {\n+                            String file1ID = diffs.get(1).text;\n+                            String file2ID = diffs.get(2).text;\n+                            //Sometimes files uploaded get put in a different ordering such that\n+                            //the first file is the \"reverse\" sequence file and the last file is\n+                            //the \"forward\" sequence file. This long condition checks for that\n+                            //situation.\n+                            if ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n+                                    || (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n+                                filePair = new MultipartFile[]{file1, file2};\n+                            }\n+                        }\n+\n+                        if (filePair != null) {\n+                            pair = true;\n+                            //organizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n+\n+                            pairedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n+\n+                            logger.trace(\"Uploaded files [\" + filePair[0].getName() + \", \" + filePair[1].getName()\n+                                    + \"] were paired.\");\n+                            wasChecked.add(file2);\n+                        }\n+                    }\n+                }\n+                if (!pair) {\n+                    MultipartFile[] singleFile = {file1};\n+                    //organizedFiles.put(file1.getOriginalFilename(), Arrays.asList(singleFile));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNzA1Nw==", "bodyText": "No need to cast here.  You're not doing anything with them after they're cast. It cna just be a List of SequencingObject I think.", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419617057", "createdAt": "2020-05-04T17:51:56Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplesController.java", "diffHunk": "@@ -286,16 +287,24 @@ public String getSampleFiles(final Model model, @PathVariable Long projectId, @P\n \t\tSample sample = sampleService.read(sampleId);\n \t\tmodel.addAttribute(\"sampleId\", sampleId);\n \n-\t\tCollection<SampleSequencingObjectJoin> filePairJoins = sequencingObjectService\n-\t\t\t\t.getSequencesForSampleOfType(sample, SequenceFilePair.class);\n-\t\tCollection<SampleSequencingObjectJoin> singleFileJoins = sequencingObjectService\n-\t\t\t\t.getSequencesForSampleOfType(sample, SingleEndSequenceFile.class);\n+\t\tCollection<SampleSequencingObjectJoin> filePairJoins = sequencingObjectService.getSequencesForSampleOfType(\n+\t\t\t\tsample, SequenceFilePair.class);\n+\t\tCollection<SampleSequencingObjectJoin> singleFileJoins = sequencingObjectService.getSequencesForSampleOfType(\n+\t\t\t\tsample, SingleEndSequenceFile.class);\n+\t\tCollection<SampleSequencingObjectJoin> fast5FileJoins = sequencingObjectService.getSequencesForSampleOfType(\n+\t\t\t\tsample, Fast5Object.class);\n+\t\tList<Fast5Object> fast5 = fast5FileJoins.stream()\n+\t\t\t\t.map(j -> (Fast5Object) j.getObject())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyMDY0NQ==", "bodyText": "If we have fast5 files in here it still shows the \"No sequencing data\" message.  This should be hidden if there are fast5 files.", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419620645", "createdAt": "2020-05-04T17:57:33Z", "author": {"login": "tom114"}, "path": "src/main/webapp/pages/samples/sample_files.html", "diffHunk": "@@ -182,6 +182,58 @@ <h4 class=\"media-heading\" th:text=\"#{samples.files.empty.title}\"></h4>\n \t\t\t</table>\n \t\t</div>\n \t</div>\n+\n+\t<div class=\"row\" th:if=\"${not #lists.isEmpty(fast5)}\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyMTE4MA==", "bodyText": "Need the link to the fastqc results here.  It's exaclty the same as for sequence files.", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419621180", "createdAt": "2020-05-04T17:58:20Z", "author": {"login": "tom114"}, "path": "src/main/webapp/pages/samples/sample_files.html", "diffHunk": "@@ -182,6 +182,58 @@ <h4 class=\"media-heading\" th:text=\"#{samples.files.empty.title}\"></h4>\n \t\t\t</table>\n \t\t</div>\n \t</div>\n+\n+\t<div class=\"row\" th:if=\"${not #lists.isEmpty(fast5)}\">\n+\t\t<div class=\"col-md-12\">\n+\t\t\t<h2 th:text=\"#{sample.files.fast5}\">FAST5 Files</h2>\n+\t\t\t<table class=\"table fast5\" th:with=\"dateFormat=#{locale.date.short}, url=@{${#httpServletRequest.requestURI}}\">\n+\t\t\t\t<tr class=\"fast5_row\" th:each=\"file : ${fast5}\">\n+\t\t\t\t\t<td class=\"td_icon fast5_icon\">\n+\t\t\t\t\t\t<i class=\"far fa-file-alt\"></i>\n+\t\t\t\t\t</td>\n+\t\t\t\t\t<td>\n+\t\t\t\t\t\t<div class=\"file-name td_info--value\"\n+\t\t\t\t\t\t\t style=\"display: flex; align-items: center; height: 35px;\">\n+\t\t\t\t\t\t\t<div th:text=\"${file.label}\"></div>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea379e563c249e785d87b7b7906dd0ef1aa37909", "author": {"user": {"login": "joshsadam", "name": "Josh Adam"}}, "url": "https://github.com/phac-nml/irida/commit/ea379e563c249e785d87b7b7906dd0ef1aa37909", "committedDate": "2020-05-05T09:52:44Z", "message": ":ok_hand: Removed commented out code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d74082a0fff036d27cdfcfa1007c91abbd9cee6", "author": {"user": {"login": "joshsadam", "name": "Josh Adam"}}, "url": "https://github.com/phac-nml/irida/commit/0d74082a0fff036d27cdfcfa1007c91abbd9cee6", "committedDate": "2020-05-05T10:03:27Z", "message": ":ok_hand: Removed unnecessary cast to fast5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04448d4847cb221c0c8cc7f3cffd2e242c5054ed", "author": {"user": {"login": "joshsadam", "name": "Josh Adam"}}, "url": "https://github.com/phac-nml/irida/commit/04448d4847cb221c0c8cc7f3cffd2e242c5054ed", "committedDate": "2020-05-05T10:05:15Z", "message": ":ok_hand: Don't show no sequence file message when fat5 are available."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82d3f5f5397234fcc0b347bf1e8f669743627243", "author": {"user": {"login": "joshsadam", "name": "Josh Adam"}}, "url": "https://github.com/phac-nml/irida/commit/82d3f5f5397234fcc0b347bf1e8f669743627243", "committedDate": "2020-05-05T10:13:43Z", "message": ":ok_hand: Added link to fast5 fastqc page."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NzkxMTEz", "url": "https://github.com/phac-nml/irida/pull/675#pullrequestreview-405791113", "createdAt": "2020-05-05T13:33:01Z", "commit": {"oid": "82d3f5f5397234fcc0b347bf1e8f669743627243"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzozMzowMVrOGQpk6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzozMzowMVrOGQpk6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDExMTU5Mw==", "bodyText": "do we need this url variable for anything?  doesn't seem to be used anywhere", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r420111593", "createdAt": "2020-05-05T13:33:01Z", "author": {"login": "tom114"}, "path": "src/main/webapp/pages/samples/sample_files.html", "diffHunk": "@@ -182,6 +182,58 @@ <h4 class=\"media-heading\" th:text=\"#{samples.files.empty.title}\"></h4>\n \t\t\t</table>\n \t\t</div>\n \t</div>\n+\n+\t<div class=\"row\" th:if=\"${not #lists.isEmpty(fast5)}\">\n+\t\t<div class=\"col-md-12\">\n+\t\t\t<h2 th:text=\"#{sample.files.fast5}\">FAST5 Files</h2>\n+\t\t\t<table class=\"table fast5\" th:with=\"dateFormat=#{locale.date.short}, url=@{${#httpServletRequest.requestURI}}\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d3f5f5397234fcc0b347bf1e8f669743627243"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fbbf5f28d102ec8438c3e2ce9477e8ff2a9be5cf", "author": {"user": {"login": "joshsadam", "name": "Josh Adam"}}, "url": "https://github.com/phac-nml/irida/commit/fbbf5f28d102ec8438c3e2ce9477e8ff2a9be5cf", "committedDate": "2020-05-05T14:58:01Z", "message": "Remove unused `url` variables"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1OTE2NTM2", "url": "https://github.com/phac-nml/irida/pull/675#pullrequestreview-405916536", "createdAt": "2020-05-05T15:44:26Z", "commit": {"oid": "fbbf5f28d102ec8438c3e2ce9477e8ff2a9be5cf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 240, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}