{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwOTczMzMw", "number": 650, "reviewThreads": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNTozNjoxN1rODwdTCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTo0NzoyNlrOEPMPPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTM4MjUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/FilesystemSupplementedRepositoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNTozNjoxN1rOGDeM-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMzoyMDowNlrOGE4kPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5Mzc1Mw==", "bodyText": "Avoid getSuperClass if you can.  That gets us into dodgy places.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r406293753", "createdAt": "2020-04-09T15:36:17Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/FilesystemSupplementedRepositoryImpl.java", "diffHunk": "@@ -215,9 +220,14 @@ private Type writeFilesToDisk(Path baseDirectory, Type objectToWrite) {\n \n \t\tPredicate<Field> pathFilter = f -> f.getType().equals(Path.class);\n \t\t// now find any members that are of type Path and shuffle them around:\n-\t\tSet<Field> pathFields = Arrays.stream(objectToWrite.getClass().getDeclaredFields()).filter(pathFilter)\n+\t\tSet<Field> pathFields = Arrays.stream(objectToWrite.getClass().getSuperclass().getDeclaredFields()).filter(pathFilter)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba008ae0e244fc7c938a58e9c9988c16e95e1060"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc3NDI3MQ==", "bodyText": "Updated in 3569c6b", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r407774271", "createdAt": "2020-04-13T23:20:06Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/FilesystemSupplementedRepositoryImpl.java", "diffHunk": "@@ -215,9 +220,14 @@ private Type writeFilesToDisk(Path baseDirectory, Type objectToWrite) {\n \n \t\tPredicate<Field> pathFilter = f -> f.getType().equals(Path.class);\n \t\t// now find any members that are of type Path and shuffle them around:\n-\t\tSet<Field> pathFields = Arrays.stream(objectToWrite.getClass().getDeclaredFields()).filter(pathFilter)\n+\t\tSet<Field> pathFields = Arrays.stream(objectToWrite.getClass().getSuperclass().getDeclaredFields()).filter(pathFilter)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5Mzc1Mw=="}, "originalCommit": {"oid": "ba008ae0e244fc7c938a58e9c9988c16e95e1060"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTM4ODAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/FilesystemSupplementedRepositoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNTozNzozOVrOGDeQeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTo1Mzo1MVrOGE2sVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5NDY1MA==", "bodyText": "As much as we can avoid this if the better.  If the repo level can just call the filestorageservice to do its directory creation and such that would be better.  Keep the responsibility of managing files to that level if we can.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r406294650", "createdAt": "2020-04-09T15:37:39Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/FilesystemSupplementedRepositoryImpl.java", "diffHunk": "@@ -238,28 +248,28 @@ private Type writeFilesToDisk(Path baseDirectory, Type objectToWrite) {\n \t\t\t\tPath source = (Path) ReflectionUtils.getField(field, objectToWrite);\n \t\t\t\tPath target = sequenceFileDirWithRevision.resolve(source.getFileName());\n \t\t\t\tlogger.debug(\"Target is [\" + target.toString() + \"]\");\n-\t\t\t\ttry {\n-\t\t\t\t\tif (!Files.exists(sequenceFileDir)) {\n-\t\t\t\t\t\tFiles.createDirectory(sequenceFileDir);\n-\t\t\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDir.toString() + \"]\");\n-\t\t\t\t\t}\n \n-\t\t\t\t\tif (!Files.exists(sequenceFileDirWithRevision)) {\n-\t\t\t\t\t\tFiles.createDirectory(sequenceFileDirWithRevision);\n-\t\t\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDirWithRevision.toString() + \"]\");\n-\t\t\t\t\t}\n+\t\t\t\tif(iridaFileStorageService.storageTypeIsLocal()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba008ae0e244fc7c938a58e9c9988c16e95e1060"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc0MzU3NQ==", "bodyText": "Updated in e9d5d85", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r407743575", "createdAt": "2020-04-13T21:53:51Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/FilesystemSupplementedRepositoryImpl.java", "diffHunk": "@@ -238,28 +248,28 @@ private Type writeFilesToDisk(Path baseDirectory, Type objectToWrite) {\n \t\t\t\tPath source = (Path) ReflectionUtils.getField(field, objectToWrite);\n \t\t\t\tPath target = sequenceFileDirWithRevision.resolve(source.getFileName());\n \t\t\t\tlogger.debug(\"Target is [\" + target.toString() + \"]\");\n-\t\t\t\ttry {\n-\t\t\t\t\tif (!Files.exists(sequenceFileDir)) {\n-\t\t\t\t\t\tFiles.createDirectory(sequenceFileDir);\n-\t\t\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDir.toString() + \"]\");\n-\t\t\t\t\t}\n \n-\t\t\t\t\tif (!Files.exists(sequenceFileDirWithRevision)) {\n-\t\t\t\t\t\tFiles.createDirectory(sequenceFileDirWithRevision);\n-\t\t\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDirWithRevision.toString() + \"]\");\n-\t\t\t\t\t}\n+\t\t\t\tif(iridaFileStorageService.storageTypeIsLocal()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5NDY1MA=="}, "originalCommit": {"oid": "ba008ae0e244fc7c938a58e9c9988c16e95e1060"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTM5MzAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageAzureServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNTozODo1MlrOGDeTug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTo1MzowM1rOGE2rDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5NTQ4Mg==", "bodyText": "Really like what's happening with this class.  That's exactly what I'd hope to see with the interface and multiple implementations.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r406295482", "createdAt": "2020-04-09T15:38:52Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageAzureServiceImpl.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.Date;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import com.azure.storage.blob.BlobClient;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.BlobServiceClient;\n+import com.azure.storage.blob.BlobServiceClientBuilder;\n+import com.azure.storage.blob.models.BlobStorageException;\n+\n+/**\n+ * Component implementation of file utitlities for azure storage\n+ */\n+@Component\n+public class IridaFileStorageAzureServiceImpl implements IridaFileStorageService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba008ae0e244fc7c938a58e9c9988c16e95e1060"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc0MzI0NQ==", "bodyText": "Thanks :)", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r407743245", "createdAt": "2020-04-13T21:53:03Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageAzureServiceImpl.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.Date;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import com.azure.storage.blob.BlobClient;\n+import com.azure.storage.blob.BlobContainerClient;\n+import com.azure.storage.blob.BlobServiceClient;\n+import com.azure.storage.blob.BlobServiceClientBuilder;\n+import com.azure.storage.blob.models.BlobStorageException;\n+\n+/**\n+ * Component implementation of file utitlities for azure storage\n+ */\n+@Component\n+public class IridaFileStorageAzureServiceImpl implements IridaFileStorageService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5NTQ4Mg=="}, "originalCommit": {"oid": "ba008ae0e244fc7c938a58e9c9988c16e95e1060"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTQwNjY2OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/service/impl/IridaFileStorageFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNTo0MjowNlrOGDeciQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTo1Mjo1M1rOGE2qww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5NzczNw==", "bodyText": "You can check to see but this might not be necessary if you could do all the stuff from this file in the IridaFileStorageService instead.  You could maybe use that as the factory.  Play with it to see though.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r406297737", "createdAt": "2020-04-09T15:42:06Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/service/impl/IridaFileStorageFactoryImpl.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package ca.corefacility.bioinformatics.irida.service.impl;\n+\n+import java.nio.file.Path;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.CloudSequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.LocalSequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageService;\n+\n+/**\n+ * Service implementation for creating SequenceFiles {@link LocalSequenceFile} and {@link CloudSequenceFile}\n+ */\n+@Service\n+public class IridaFileStorageFactoryImpl {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba008ae0e244fc7c938a58e9c9988c16e95e1060"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc0MzE3MQ==", "bodyText": "Removed the factory and moved the code to the iridafilestorageservice implementations in\nc8672d6", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r407743171", "createdAt": "2020-04-13T21:52:53Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/service/impl/IridaFileStorageFactoryImpl.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package ca.corefacility.bioinformatics.irida.service.impl;\n+\n+import java.nio.file.Path;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.CloudSequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.LocalSequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageService;\n+\n+/**\n+ * Service implementation for creating SequenceFiles {@link LocalSequenceFile} and {@link CloudSequenceFile}\n+ */\n+@Service\n+public class IridaFileStorageFactoryImpl {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5NzczNw=="}, "originalCommit": {"oid": "ba008ae0e244fc7c938a58e9c9988c16e95e1060"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTQzNTYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNTo0OTowOFrOGDevHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTo1Mzo0M1rOGE2sFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMwMjQ5NA==", "bodyText": "We haven't been using the @DiscriminatorColumn in our other inheritance strategies.  If you just leave it off, it automatically creates a DTYPE column with the class name`.\nI'll leave it to you whether to use the SINGLE_TABLE or JOINED approach.  In general we've preferred the JOINED approach because it means less unnecessary blank columns.  If it's just 1 or 2 empty columns it's not a big deal though.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r406302494", "createdAt": "2020-04-09T15:49:08Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "diffHunk": "@@ -56,10 +37,15 @@\n  * particular {@link Sample}.\n  */\n @Entity\n+@Inheritance(strategy=InheritanceType.SINGLE_TABLE)\n+@DiscriminatorColumn(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba008ae0e244fc7c938a58e9c9988c16e95e1060"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NTA0NA==", "bodyText": "For this case it's probably best to use a SINGLE_TABLE approach as there are no extra fields being declared in the LocalSequenceFile or CloudSequenceFile classes", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r407095044", "createdAt": "2020-04-11T18:24:26Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "diffHunk": "@@ -56,10 +37,15 @@\n  * particular {@link Sample}.\n  */\n @Entity\n+@Inheritance(strategy=InheritanceType.SINGLE_TABLE)\n+@DiscriminatorColumn(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMwMjQ5NA=="}, "originalCommit": {"oid": "ba008ae0e244fc7c938a58e9c9988c16e95e1060"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc0MzUwOQ==", "bodyText": "Updated in e9d5d85", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r407743509", "createdAt": "2020-04-13T21:53:43Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "diffHunk": "@@ -56,10 +37,15 @@\n  * particular {@link Sample}.\n  */\n @Entity\n+@Inheritance(strategy=InheritanceType.SINGLE_TABLE)\n+@DiscriminatorColumn(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMwMjQ5NA=="}, "originalCommit": {"oid": "ba008ae0e244fc7c938a58e9c9988c16e95e1060"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODI4NTg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/entity/listeners/IridaFileStorageListener.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDoyODo0MFrOGkr-Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNzo0OTozMlrOGlQl1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyMjMzNA==", "bodyText": "Is this here because VersionedFileFields doesn't have the setIridaFileStorageService method?  If so we can avoid the reflection by adding that method to the interface, or creating a different interface that has that method.  It would be much cleaner than having this reflection stuff.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441122334", "createdAt": "2020-06-16T20:28:40Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/entity/listeners/IridaFileStorageListener.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package ca.corefacility.bioinformatics.irida.repositories.entity.listeners;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import javax.persistence.PostLoad;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.context.support.SpringBeanAutowiringSupport;\n+\n+import ca.corefacility.bioinformatics.irida.model.VersionedFileFields;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageService;\n+\n+/**\n+ * Component implementation to run on an entity after it is has been accessed from the db.\n+ */\n+@Component\n+public class IridaFileStorageListener {\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageListener.class);\n+\n+\t@Autowired\n+\tprivate IridaFileStorageService iridaFileStorageService;\n+\n+\t/**\n+\t * After the entity is loaded this method will provide\n+\t * the entity access to the iridaFileStorageService\n+\t *\n+\t * @param fileSystemEntity The entity to provide the iridaFileStorageService to\n+\t */\n+\t@PostLoad\n+\tpublic void afterEntityLoad(final VersionedFileFields<Long> fileSystemEntity) {\n+\t\ttry {\n+\t\t\tSpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this);\n+\t\t\t// Use reflection to get the setIridaFileStorageService method, make it accessible, and invoke it\n+\t\t\tMethod iridaFileStorageServiceSetter = fileSystemEntity.getClass()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NjQ4OA==", "bodyText": "That plus we can't autowire in the IridaFileStorageService into the model classes so I added this file to provide that access to it after the entity is loaded. If we add it to the VersionedFileFields wouldn't we still have the issue of not being able to access it? I hope I'm talking about the same thing as your are :)", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441186488", "createdAt": "2020-06-16T22:54:39Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/entity/listeners/IridaFileStorageListener.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package ca.corefacility.bioinformatics.irida.repositories.entity.listeners;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import javax.persistence.PostLoad;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.context.support.SpringBeanAutowiringSupport;\n+\n+import ca.corefacility.bioinformatics.irida.model.VersionedFileFields;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageService;\n+\n+/**\n+ * Component implementation to run on an entity after it is has been accessed from the db.\n+ */\n+@Component\n+public class IridaFileStorageListener {\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageListener.class);\n+\n+\t@Autowired\n+\tprivate IridaFileStorageService iridaFileStorageService;\n+\n+\t/**\n+\t * After the entity is loaded this method will provide\n+\t * the entity access to the iridaFileStorageService\n+\t *\n+\t * @param fileSystemEntity The entity to provide the iridaFileStorageService to\n+\t */\n+\t@PostLoad\n+\tpublic void afterEntityLoad(final VersionedFileFields<Long> fileSystemEntity) {\n+\t\ttry {\n+\t\t\tSpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this);\n+\t\t\t// Use reflection to get the setIridaFileStorageService method, make it accessible, and invoke it\n+\t\t\tMethod iridaFileStorageServiceSetter = fileSystemEntity.getClass()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyMjMzNA=="}, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNjUyNw==", "bodyText": "Sorry I wasn't clear  I understand the listener, just I think you could get away from the reflection if you added a method setIridaFileStorageService in VersionedFileFields.  That way you wouldn't need the reflection stuff and could just call the method on fileSystemEntity.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441216527", "createdAt": "2020-06-17T00:38:30Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/entity/listeners/IridaFileStorageListener.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package ca.corefacility.bioinformatics.irida.repositories.entity.listeners;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import javax.persistence.PostLoad;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.context.support.SpringBeanAutowiringSupport;\n+\n+import ca.corefacility.bioinformatics.irida.model.VersionedFileFields;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageService;\n+\n+/**\n+ * Component implementation to run on an entity after it is has been accessed from the db.\n+ */\n+@Component\n+public class IridaFileStorageListener {\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageListener.class);\n+\n+\t@Autowired\n+\tprivate IridaFileStorageService iridaFileStorageService;\n+\n+\t/**\n+\t * After the entity is loaded this method will provide\n+\t * the entity access to the iridaFileStorageService\n+\t *\n+\t * @param fileSystemEntity The entity to provide the iridaFileStorageService to\n+\t */\n+\t@PostLoad\n+\tpublic void afterEntityLoad(final VersionedFileFields<Long> fileSystemEntity) {\n+\t\ttry {\n+\t\t\tSpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this);\n+\t\t\t// Use reflection to get the setIridaFileStorageService method, make it accessible, and invoke it\n+\t\t\tMethod iridaFileStorageServiceSetter = fileSystemEntity.getClass()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyMjMzNA=="}, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcwODA0OQ==", "bodyText": "I think I had just misunderstood you the first time! Thanks it all makes sense now", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441708049", "createdAt": "2020-06-17T17:25:46Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/entity/listeners/IridaFileStorageListener.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package ca.corefacility.bioinformatics.irida.repositories.entity.listeners;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import javax.persistence.PostLoad;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.context.support.SpringBeanAutowiringSupport;\n+\n+import ca.corefacility.bioinformatics.irida.model.VersionedFileFields;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageService;\n+\n+/**\n+ * Component implementation to run on an entity after it is has been accessed from the db.\n+ */\n+@Component\n+public class IridaFileStorageListener {\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageListener.class);\n+\n+\t@Autowired\n+\tprivate IridaFileStorageService iridaFileStorageService;\n+\n+\t/**\n+\t * After the entity is loaded this method will provide\n+\t * the entity access to the iridaFileStorageService\n+\t *\n+\t * @param fileSystemEntity The entity to provide the iridaFileStorageService to\n+\t */\n+\t@PostLoad\n+\tpublic void afterEntityLoad(final VersionedFileFields<Long> fileSystemEntity) {\n+\t\ttry {\n+\t\t\tSpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this);\n+\t\t\t// Use reflection to get the setIridaFileStorageService method, make it accessible, and invoke it\n+\t\t\tMethod iridaFileStorageServiceSetter = fileSystemEntity.getClass()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyMjMzNA=="}, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcyMjMyNg==", "bodyText": "Updated in 8477bb9", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441722326", "createdAt": "2020-06-17T17:49:32Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/entity/listeners/IridaFileStorageListener.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package ca.corefacility.bioinformatics.irida.repositories.entity.listeners;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import javax.persistence.PostLoad;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.context.support.SpringBeanAutowiringSupport;\n+\n+import ca.corefacility.bioinformatics.irida.model.VersionedFileFields;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageService;\n+\n+/**\n+ * Component implementation to run on an entity after it is has been accessed from the db.\n+ */\n+@Component\n+public class IridaFileStorageListener {\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageListener.class);\n+\n+\t@Autowired\n+\tprivate IridaFileStorageService iridaFileStorageService;\n+\n+\t/**\n+\t * After the entity is loaded this method will provide\n+\t * the entity access to the iridaFileStorageService\n+\t *\n+\t * @param fileSystemEntity The entity to provide the iridaFileStorageService to\n+\t */\n+\t@PostLoad\n+\tpublic void afterEntityLoad(final VersionedFileFields<Long> fileSystemEntity) {\n+\t\ttry {\n+\t\t\tSpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this);\n+\t\t\t// Use reflection to get the setIridaFileStorageService method, make it accessible, and invoke it\n+\t\t\tMethod iridaFileStorageServiceSetter = fileSystemEntity.getClass()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyMjMzNA=="}, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODI5Mjg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDozMDo0N1rOGksCjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNzo0OTo0MVrOGlQmLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyMzQ2OA==", "bodyText": "Can we name this something other than a Service?  The way it functions is nice, but the name Service imples it's in the service layer of our tiers.  Since we use it all over the place it feels like it has a dependency cycle.  Even just something like IridaFileStorageUtility.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441123468", "createdAt": "2020-06-16T20:30:47Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageService.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * Interface describing methods for performing storage actions\n+ */\n+\n+public interface IridaFileStorageService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NjY0Mg==", "bodyText": "Good idea!", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441186642", "createdAt": "2020-06-16T22:55:03Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageService.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * Interface describing methods for performing storage actions\n+ */\n+\n+public interface IridaFileStorageService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyMzQ2OA=="}, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcyMjQxMw==", "bodyText": "Updated in 8477bb9", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441722413", "createdAt": "2020-06-17T17:49:41Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageService.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * Interface describing methods for performing storage actions\n+ */\n+\n+public interface IridaFileStorageService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyMzQ2OA=="}, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODMwMDU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDozMjo1M1rOGksHEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNzo0OTo0OVrOGlQmdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyNDYyNg==", "bodyText": "Will we ever want a getter for this?  I feel like it should just be an internal thing of the class.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441124626", "createdAt": "2020-06-16T20:32:53Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "diffHunk": "@@ -307,4 +297,13 @@ public String getUploadSha256() {\n \tpublic void setUploadSha256(String uploadSha256) {\n \t\tthis.uploadSha256 = uploadSha256;\n \t}\n+\n+\tpublic IridaFileStorageService getIridaFileStorageService() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NzAyOA==", "bodyText": "Nope I think this might be something I forgot to remove. I think I auto generated that", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441187028", "createdAt": "2020-06-16T22:56:11Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "diffHunk": "@@ -307,4 +297,13 @@ public String getUploadSha256() {\n \tpublic void setUploadSha256(String uploadSha256) {\n \t\tthis.uploadSha256 = uploadSha256;\n \t}\n+\n+\tpublic IridaFileStorageService getIridaFileStorageService() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyNDYyNg=="}, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcyMjQ4Ng==", "bodyText": "Removed in 8477bb9", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441722486", "createdAt": "2020-06-17T17:49:49Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "diffHunk": "@@ -307,4 +297,13 @@ public String getUploadSha256() {\n \tpublic void setUploadSha256(String uploadSha256) {\n \t\tthis.uploadSha256 = uploadSha256;\n \t}\n+\n+\tpublic IridaFileStorageService getIridaFileStorageService() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyNDYyNg=="}, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODM2Njg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalServiceImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1Mjo0NlrOGksv0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNzo0OTo1N1rOGlQmtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTA1OQ==", "bodyText": "Why the blank methods?  If they're not to be used I think they should be removed from the interface and these implemetations until we need them.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441135059", "createdAt": "2020-06-16T20:52:46Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalServiceImpl.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.exceptions.StorageException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+import ca.corefacility.bioinformatics.irida.processing.FileProcessorException;\n+\n+/**\n+ * Component implementation of file utitlities for local storage\n+ */\n+@Component\n+public class IridaFileStorageLocalServiceImpl implements IridaFileStorageService{\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageLocalServiceImpl.class);\n+\n+\t@Autowired\n+\tpublic IridaFileStorageLocalServiceImpl(){\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic File getTemporaryFile(Path file) {\n+\t\tFile fileToProcess = null;\n+\t\tfileToProcess = file.toFile();\n+\t\treturn fileToProcess;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic Long getFileSize(Path file) {\n+\t\tLong fileSize = 0L;\n+\t\ttry {\n+\t\t\tfileSize = Files.size(file);\n+\t\t} catch (NoSuchFileException e) {\n+\t\t\tlogger.error(\"Could not find file \" + file);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Could not calculate file size: \", e);\n+\t\t}\n+\n+\t\treturn fileSize;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision) {\n+\t\ttry {\n+\t\t\tif (!Files.exists(sequenceFileDir)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDir);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDir.toString() + \"]\");\n+\t\t\t}\n+\n+\t\t\tif (!Files.exists(sequenceFileDirWithRevision)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDirWithRevision);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDirWithRevision.toString() + \"]\");\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to create new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to create new directory.\", e);\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tFiles.move(source, target);\n+\t\t\tlogger.trace(\"Moved file \" + source + \" to \" + target);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to move file into new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to move file into new directory.\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void deleteFile() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NzIxNQ==", "bodyText": "Another thing I forgot to remove. I added these before I was made aware of how deleting files would be a pain. I will remove them", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441187215", "createdAt": "2020-06-16T22:56:47Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalServiceImpl.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.exceptions.StorageException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+import ca.corefacility.bioinformatics.irida.processing.FileProcessorException;\n+\n+/**\n+ * Component implementation of file utitlities for local storage\n+ */\n+@Component\n+public class IridaFileStorageLocalServiceImpl implements IridaFileStorageService{\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageLocalServiceImpl.class);\n+\n+\t@Autowired\n+\tpublic IridaFileStorageLocalServiceImpl(){\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic File getTemporaryFile(Path file) {\n+\t\tFile fileToProcess = null;\n+\t\tfileToProcess = file.toFile();\n+\t\treturn fileToProcess;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic Long getFileSize(Path file) {\n+\t\tLong fileSize = 0L;\n+\t\ttry {\n+\t\t\tfileSize = Files.size(file);\n+\t\t} catch (NoSuchFileException e) {\n+\t\t\tlogger.error(\"Could not find file \" + file);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Could not calculate file size: \", e);\n+\t\t}\n+\n+\t\treturn fileSize;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision) {\n+\t\ttry {\n+\t\t\tif (!Files.exists(sequenceFileDir)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDir);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDir.toString() + \"]\");\n+\t\t\t}\n+\n+\t\t\tif (!Files.exists(sequenceFileDirWithRevision)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDirWithRevision);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDirWithRevision.toString() + \"]\");\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to create new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to create new directory.\", e);\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tFiles.move(source, target);\n+\t\t\tlogger.trace(\"Moved file \" + source + \" to \" + target);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to move file into new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to move file into new directory.\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void deleteFile() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTA1OQ=="}, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcyMjU1MQ==", "bodyText": "Removed in 8477bb9", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441722551", "createdAt": "2020-06-17T17:49:57Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalServiceImpl.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.exceptions.StorageException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+import ca.corefacility.bioinformatics.irida.processing.FileProcessorException;\n+\n+/**\n+ * Component implementation of file utitlities for local storage\n+ */\n+@Component\n+public class IridaFileStorageLocalServiceImpl implements IridaFileStorageService{\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageLocalServiceImpl.class);\n+\n+\t@Autowired\n+\tpublic IridaFileStorageLocalServiceImpl(){\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic File getTemporaryFile(Path file) {\n+\t\tFile fileToProcess = null;\n+\t\tfileToProcess = file.toFile();\n+\t\treturn fileToProcess;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic Long getFileSize(Path file) {\n+\t\tLong fileSize = 0L;\n+\t\ttry {\n+\t\t\tfileSize = Files.size(file);\n+\t\t} catch (NoSuchFileException e) {\n+\t\t\tlogger.error(\"Could not find file \" + file);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Could not calculate file size: \", e);\n+\t\t}\n+\n+\t\treturn fileSize;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision) {\n+\t\ttry {\n+\t\t\tif (!Files.exists(sequenceFileDir)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDir);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDir.toString() + \"]\");\n+\t\t\t}\n+\n+\t\t\tif (!Files.exists(sequenceFileDirWithRevision)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDirWithRevision);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDirWithRevision.toString() + \"]\");\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to create new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to create new directory.\", e);\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tFiles.move(source, target);\n+\t\t\tlogger.trace(\"Moved file \" + source + \" to \" + target);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to move file into new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to move file into new directory.\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void deleteFile() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTA1OQ=="}, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODM3MjM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1NDozMlrOGkszUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMjo1NzoxMVrOGkv8Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTk1NQ==", "bodyText": "I love how the concern was moved here from the FilesystemSupplementedRepositoryImpl.  I think this was a good way to go with things.  When this all gets done we'll likely need to rename that file to something less \"filesystem\".", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441135955", "createdAt": "2020-06-16T20:54:32Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalServiceImpl.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.exceptions.StorageException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+import ca.corefacility.bioinformatics.irida.processing.FileProcessorException;\n+\n+/**\n+ * Component implementation of file utitlities for local storage\n+ */\n+@Component\n+public class IridaFileStorageLocalServiceImpl implements IridaFileStorageService{\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageLocalServiceImpl.class);\n+\n+\t@Autowired\n+\tpublic IridaFileStorageLocalServiceImpl(){\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic File getTemporaryFile(Path file) {\n+\t\tFile fileToProcess = null;\n+\t\tfileToProcess = file.toFile();\n+\t\treturn fileToProcess;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic Long getFileSize(Path file) {\n+\t\tLong fileSize = 0L;\n+\t\ttry {\n+\t\t\tfileSize = Files.size(file);\n+\t\t} catch (NoSuchFileException e) {\n+\t\t\tlogger.error(\"Could not find file \" + file);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Could not calculate file size: \", e);\n+\t\t}\n+\n+\t\treturn fileSize;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision) {\n+\t\ttry {\n+\t\t\tif (!Files.exists(sequenceFileDir)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NzM1OQ==", "bodyText": "Awesome thanks. Yeah it's going to need a rename for sure", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441187359", "createdAt": "2020-06-16T22:57:11Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalServiceImpl.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.exceptions.StorageException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+import ca.corefacility.bioinformatics.irida.processing.FileProcessorException;\n+\n+/**\n+ * Component implementation of file utitlities for local storage\n+ */\n+@Component\n+public class IridaFileStorageLocalServiceImpl implements IridaFileStorageService{\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageLocalServiceImpl.class);\n+\n+\t@Autowired\n+\tpublic IridaFileStorageLocalServiceImpl(){\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic File getTemporaryFile(Path file) {\n+\t\tFile fileToProcess = null;\n+\t\tfileToProcess = file.toFile();\n+\t\treturn fileToProcess;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic Long getFileSize(Path file) {\n+\t\tLong fileSize = 0L;\n+\t\ttry {\n+\t\t\tfileSize = Files.size(file);\n+\t\t} catch (NoSuchFileException e) {\n+\t\t\tlogger.error(\"Could not find file \" + file);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Could not calculate file size: \", e);\n+\t\t}\n+\n+\t\treturn fileSize;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision) {\n+\t\ttry {\n+\t\t\tif (!Files.exists(sequenceFileDir)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTk1NQ=="}, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODM5MzExOnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/projects/settings/ProjectReferenceFileController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTowMTowM1rOGktArg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNzo1MDoxMVrOGlQnSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzOTM3NA==", "bodyText": "Should we maybe add some of these file methods into the model classes?  That way we don't need to wire the IridaFileStorageService into some places it maybe doesn't belong (like this class).\nSome examples I can see: getFileSize, getFileInputStream, maybe some of the other things that are like \"read\" operations on the file.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441139374", "createdAt": "2020-06-16T21:01:03Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/projects/settings/ProjectReferenceFileController.java", "diffHunk": "@@ -93,12 +94,7 @@ public String getProjectReferenceFilesPage(final Model model, final Principal pr\n \t\t\tmap.put(\"label\", file.getLabel());\n \t\t\tmap.put(\"createdDate\", file.getCreatedDate());\n \t\t\tPath path = file.getFile();\n-\t\t\ttry {\n-\t\t\t\tmap.put(\"size\", Files.size(path));\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tlogger.error(\"Cannot find the size of file \" + file.getLabel());\n-\t\t\t\tmap.put(\"size\", messageSource.getMessage(\"projects.reference-file.not-found\", new Object[] {}, locale));\n-\t\t\t}\n+\t\t\tmap.put(\"size\", iridaFileStorageService.getFileSize(path));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NzU0MA==", "bodyText": "Yup that's a good idea!", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441187540", "createdAt": "2020-06-16T22:57:45Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/projects/settings/ProjectReferenceFileController.java", "diffHunk": "@@ -93,12 +94,7 @@ public String getProjectReferenceFilesPage(final Model model, final Principal pr\n \t\t\tmap.put(\"label\", file.getLabel());\n \t\t\tmap.put(\"createdDate\", file.getCreatedDate());\n \t\t\tPath path = file.getFile();\n-\t\t\ttry {\n-\t\t\t\tmap.put(\"size\", Files.size(path));\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tlogger.error(\"Cannot find the size of file \" + file.getLabel());\n-\t\t\t\tmap.put(\"size\", messageSource.getMessage(\"projects.reference-file.not-found\", new Object[] {}, locale));\n-\t\t\t}\n+\t\t\tmap.put(\"size\", iridaFileStorageService.getFileSize(path));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzOTM3NA=="}, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcyMjY5OQ==", "bodyText": "Updated in 8477bb9", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441722699", "createdAt": "2020-06-17T17:50:11Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/projects/settings/ProjectReferenceFileController.java", "diffHunk": "@@ -93,12 +94,7 @@ public String getProjectReferenceFilesPage(final Model model, final Principal pr\n \t\t\tmap.put(\"label\", file.getLabel());\n \t\t\tmap.put(\"createdDate\", file.getCreatedDate());\n \t\t\tPath path = file.getFile();\n-\t\t\ttry {\n-\t\t\t\tmap.put(\"size\", Files.size(path));\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tlogger.error(\"Cannot find the size of file \" + file.getLabel());\n-\t\t\t\tmap.put(\"size\", messageSource.getMessage(\"projects.reference-file.not-found\", new Object[] {}, locale));\n-\t\t\t}\n+\t\t\tmap.put(\"size\", iridaFileStorageService.getFileSize(path));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzOTM3NA=="}, "originalCommit": {"oid": "c572ba62bd15b3b97c6b300722a2efc7affdc6a5"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjQxOTExOnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0MDoxOVrOGlUrDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNjoxMDowMFrOGmaKGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTE5OA==", "bodyText": "This is likely one that should stay with the iridaFileStorageUtility.  It's not really an action on the SequenceFile, it's a filesystem option.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441789198", "createdAt": "2020-06-17T19:40:19Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "diffHunk": "@@ -307,4 +300,25 @@ public String getUploadSha256() {\n \tpublic void setUploadSha256(String uploadSha256) {\n \t\tthis.uploadSha256 = uploadSha256;\n \t}\n+\n+\t@Override\n+\tpublic void setIridaFileStorageUtility(IridaFileStorageUtility iridaFileStorageUtility) {\n+\t\tthis.iridaFileStorageUtility = iridaFileStorageUtility;\n+\t}\n+\n+\tpublic InputStream getFileInputStream() {\n+\t\treturn iridaFileStorageUtility.getFileInputStream(getFile());\n+\t}\n+\n+\tpublic boolean isGzipped() throws Exception {\n+\t\treturn iridaFileStorageUtility.isGzipped(getFile());\n+\t}\n+\n+\tpublic File getTemporaryFile() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxNTczNQ==", "bodyText": "I can have it call the method directly in iridaFileStorageUtility but then we will need to add it to the fileprocessor methods. My reasoning behind it was so we don't need to add it to the files such as FastQcFileProcessor and can call the method getTemporaryFile on a SequenceFile object which would call it in the iridaFileStorageLocalUtility etc", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441815735", "createdAt": "2020-06-17T20:32:22Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "diffHunk": "@@ -307,4 +300,25 @@ public String getUploadSha256() {\n \tpublic void setUploadSha256(String uploadSha256) {\n \t\tthis.uploadSha256 = uploadSha256;\n \t}\n+\n+\t@Override\n+\tpublic void setIridaFileStorageUtility(IridaFileStorageUtility iridaFileStorageUtility) {\n+\t\tthis.iridaFileStorageUtility = iridaFileStorageUtility;\n+\t}\n+\n+\tpublic InputStream getFileInputStream() {\n+\t\treturn iridaFileStorageUtility.getFileInputStream(getFile());\n+\t}\n+\n+\tpublic boolean isGzipped() throws Exception {\n+\t\treturn iridaFileStorageUtility.isGzipped(getFile());\n+\t}\n+\n+\tpublic File getTemporaryFile() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTE5OA=="}, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyMjMxMQ==", "bodyText": "Yeah understood we would have to wire that utility in to those places, but it feels like a big mixing of concerns to have a model object creating temporary files.\nThat said, we should think whether the temp files should just be created with the regular Files object locally anyway.  For cloud systems we likely wouldn't want to create temporary files on the cloud storage service anyway would we?  Maybe a local temp file that's then transferred up to the object store is enough?", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441922311", "createdAt": "2020-06-18T01:45:33Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "diffHunk": "@@ -307,4 +300,25 @@ public String getUploadSha256() {\n \tpublic void setUploadSha256(String uploadSha256) {\n \t\tthis.uploadSha256 = uploadSha256;\n \t}\n+\n+\t@Override\n+\tpublic void setIridaFileStorageUtility(IridaFileStorageUtility iridaFileStorageUtility) {\n+\t\tthis.iridaFileStorageUtility = iridaFileStorageUtility;\n+\t}\n+\n+\tpublic InputStream getFileInputStream() {\n+\t\treturn iridaFileStorageUtility.getFileInputStream(getFile());\n+\t}\n+\n+\tpublic boolean isGzipped() throws Exception {\n+\t\treturn iridaFileStorageUtility.isGzipped(getFile());\n+\t}\n+\n+\tpublic File getTemporaryFile() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTE5OA=="}, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI1MzU3NQ==", "bodyText": "We only use this method to get a temporary file from cloud storage to the local filesystem when we need to do something with the file. Like for example once a file is uploaded to the cloud and then the fastqcfileprocessor needs to run on the file. It will pull the file and run the processor", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r442253575", "createdAt": "2020-06-18T14:06:58Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "diffHunk": "@@ -307,4 +300,25 @@ public String getUploadSha256() {\n \tpublic void setUploadSha256(String uploadSha256) {\n \t\tthis.uploadSha256 = uploadSha256;\n \t}\n+\n+\t@Override\n+\tpublic void setIridaFileStorageUtility(IridaFileStorageUtility iridaFileStorageUtility) {\n+\t\tthis.iridaFileStorageUtility = iridaFileStorageUtility;\n+\t}\n+\n+\tpublic InputStream getFileInputStream() {\n+\t\treturn iridaFileStorageUtility.getFileInputStream(getFile());\n+\t}\n+\n+\tpublic boolean isGzipped() throws Exception {\n+\t\treturn iridaFileStorageUtility.isGzipped(getFile());\n+\t}\n+\n+\tpublic File getTemporaryFile() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTE5OA=="}, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyNzY0MQ==", "bodyText": "Updated in 2f3e957", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r442927641", "createdAt": "2020-06-19T16:10:00Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/sequenceFile/SequenceFile.java", "diffHunk": "@@ -307,4 +300,25 @@ public String getUploadSha256() {\n \tpublic void setUploadSha256(String uploadSha256) {\n \t\tthis.uploadSha256 = uploadSha256;\n \t}\n+\n+\t@Override\n+\tpublic void setIridaFileStorageUtility(IridaFileStorageUtility iridaFileStorageUtility) {\n+\t\tthis.iridaFileStorageUtility = iridaFileStorageUtility;\n+\t}\n+\n+\tpublic InputStream getFileInputStream() {\n+\t\treturn iridaFileStorageUtility.getFileInputStream(getFile());\n+\t}\n+\n+\tpublic boolean isGzipped() throws Exception {\n+\t\treturn iridaFileStorageUtility.isGzipped(getFile());\n+\t}\n+\n+\tpublic File getTemporaryFile() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTE5OA=="}, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjQyMDU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/impl/FastqcFileProcessor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0MDo0NFrOGlUr6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNjoxMDowOVrOGmaKdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTQxNw==", "bodyText": "Is this the right logic here?  Now fileToProcess isn't getting used.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441789417", "createdAt": "2020-06-17T19:40:44Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/impl/FastqcFileProcessor.java", "diffHunk": "@@ -92,7 +97,7 @@ private void processSingleFile(SequenceFile sequenceFile) throws FileProcessorEx\n \t\t\t\t\t\tLocaleContextHolder.getLocale()));\n \t\ttry {\n \t\t\tuk.ac.babraham.FastQC.Sequence.SequenceFile fastQCSequenceFile = SequenceFactory.getSequenceFile(\n-\t\t\t\t\tfileToProcess.toFile());\n+\t\t\t\t\tsequenceFile.getTemporaryFile());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMzIzNA==", "bodyText": "That is correct. But if we want to keep the getTemporaryFile in the iridaFileStorageUtility classes rather than having a getTemporaryFile method in the SequenceFile then we will need to use it.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441813234", "createdAt": "2020-06-17T20:27:29Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/impl/FastqcFileProcessor.java", "diffHunk": "@@ -92,7 +97,7 @@ private void processSingleFile(SequenceFile sequenceFile) throws FileProcessorEx\n \t\t\t\t\t\tLocaleContextHolder.getLocale()));\n \t\ttry {\n \t\t\tuk.ac.babraham.FastQC.Sequence.SequenceFile fastQCSequenceFile = SequenceFactory.getSequenceFile(\n-\t\t\t\t\tfileToProcess.toFile());\n+\t\t\t\t\tsequenceFile.getTemporaryFile());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTQxNw=="}, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyMjQxMQ==", "bodyText": "Yeah understood.  We'll have to finish that conversation first.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441922411", "createdAt": "2020-06-18T01:45:56Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/impl/FastqcFileProcessor.java", "diffHunk": "@@ -92,7 +97,7 @@ private void processSingleFile(SequenceFile sequenceFile) throws FileProcessorEx\n \t\t\t\t\t\tLocaleContextHolder.getLocale()));\n \t\ttry {\n \t\t\tuk.ac.babraham.FastQC.Sequence.SequenceFile fastQCSequenceFile = SequenceFactory.getSequenceFile(\n-\t\t\t\t\tfileToProcess.toFile());\n+\t\t\t\t\tsequenceFile.getTemporaryFile());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTQxNw=="}, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyNzczMw==", "bodyText": "Updated in 2f3e957", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r442927733", "createdAt": "2020-06-19T16:10:09Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/impl/FastqcFileProcessor.java", "diffHunk": "@@ -92,7 +97,7 @@ private void processSingleFile(SequenceFile sequenceFile) throws FileProcessorEx\n \t\t\t\t\t\tLocaleContextHolder.getLocale()));\n \t\ttry {\n \t\t\tuk.ac.babraham.FastQC.Sequence.SequenceFile fastQCSequenceFile = SequenceFactory.getSequenceFile(\n-\t\t\t\t\tfileToProcess.toFile());\n+\t\t\t\t\tsequenceFile.getTemporaryFile());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTQxNw=="}, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjQyMDg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/impl/FastqcFileProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0MDo1MFrOGlUsFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNjoxNDoyM1rOGmaRxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTQ2Mw==", "bodyText": "This isn't being used anymore.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441789463", "createdAt": "2020-06-17T19:40:50Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/impl/FastqcFileProcessor.java", "diffHunk": "@@ -52,6 +54,7 @@\n \tprivate final SequenceFileRepository sequenceFileRepository;\n \tprivate final AnalysisOutputFileRepository outputFileRepository;\n \tprivate final MessageSource messageSource;\n+\tprivate IridaFileStorageUtility iridaFileStorageUtility;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyOTYwNw==", "bodyText": "This is now required as we moved the getTemporaryFile method out of the sequenceFile", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r442929607", "createdAt": "2020-06-19T16:14:23Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/impl/FastqcFileProcessor.java", "diffHunk": "@@ -52,6 +54,7 @@\n \tprivate final SequenceFileRepository sequenceFileRepository;\n \tprivate final AnalysisOutputFileRepository outputFileRepository;\n \tprivate final MessageSource messageSource;\n+\tprivate IridaFileStorageUtility iridaFileStorageUtility;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTQ2Mw=="}, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjQyMzA5OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/impl/GzipFileProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0MTozMFrOGlUtig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0MTozMFrOGlUtig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTgzNA==", "bodyText": "I like this now.  Less cyclic dependencies.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441789834", "createdAt": "2020-06-17T19:41:30Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/impl/GzipFileProcessor.java", "diffHunk": "@@ -111,10 +110,10 @@ public void processSingleFile(SequenceFile sequenceFile) throws FileProcessorExc\n \n \t\ttry {\n \t\t\tlogger.trace(\"About to try handling a gzip file.\");\n-\t\t\tif (FileUtils.isGzipped(file)) {\n+\t\t\tif (sequenceFile.isGzipped()) {\n \t\t\t\tfile = addExtensionToFilename(file, GZIP_EXTENSION);\n \n-\t\t\t\ttry (GZIPInputStream zippedInputStream = new GZIPInputStream(Files.newInputStream(file))) {\n+\t\t\t\ttry (GZIPInputStream zippedInputStream = new GZIPInputStream(sequenceFile.getFileInputStream())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjQyNDk2OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/entity/listeners/IridaFileStorageListener.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0MjowM1rOGlUutQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNjoxMDoyNlrOGmaK7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5MDEzMw==", "bodyText": "Is this line necessary?  If so can you add a comment why it's there?", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441790133", "createdAt": "2020-06-17T19:42:03Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/entity/listeners/IridaFileStorageListener.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package ca.corefacility.bioinformatics.irida.repositories.entity.listeners;\n+\n+import javax.persistence.PostLoad;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.context.support.SpringBeanAutowiringSupport;\n+\n+import ca.corefacility.bioinformatics.irida.model.VersionedFileFields;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageUtility;\n+\n+/**\n+ * Component implementation to run on a versioned entity after it is has been accessed from the db.\n+ */\n+@Component\n+public class IridaFileStorageListener {\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageListener.class);\n+\n+\t@Autowired\n+\tprivate IridaFileStorageUtility iridaFileStorageUtility;\n+\n+\t/**\n+\t * After the versioned entity is loaded this method will provide\n+\t * the entity access to the iridaFileStorageUtility\n+\t *\n+\t * @param fileSystemEntity The versioned entity to provide the iridaFileStorageUtility to\n+\t */\n+\t@PostLoad\n+\tpublic void afterEntityLoad(final VersionedFileFields<Long> fileSystemEntity) {\n+\t\t\tSpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMTg2OA==", "bodyText": "I should be able to remove this now", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441811868", "createdAt": "2020-06-17T20:24:48Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/entity/listeners/IridaFileStorageListener.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package ca.corefacility.bioinformatics.irida.repositories.entity.listeners;\n+\n+import javax.persistence.PostLoad;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.context.support.SpringBeanAutowiringSupport;\n+\n+import ca.corefacility.bioinformatics.irida.model.VersionedFileFields;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageUtility;\n+\n+/**\n+ * Component implementation to run on a versioned entity after it is has been accessed from the db.\n+ */\n+@Component\n+public class IridaFileStorageListener {\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageListener.class);\n+\n+\t@Autowired\n+\tprivate IridaFileStorageUtility iridaFileStorageUtility;\n+\n+\t/**\n+\t * After the versioned entity is loaded this method will provide\n+\t * the entity access to the iridaFileStorageUtility\n+\t *\n+\t * @param fileSystemEntity The versioned entity to provide the iridaFileStorageUtility to\n+\t */\n+\t@PostLoad\n+\tpublic void afterEntityLoad(final VersionedFileFields<Long> fileSystemEntity) {\n+\t\t\tSpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5MDEzMw=="}, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyNzg1NA==", "bodyText": "This ended up being required. Added in 2f3e957", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r442927854", "createdAt": "2020-06-19T16:10:26Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/entity/listeners/IridaFileStorageListener.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package ca.corefacility.bioinformatics.irida.repositories.entity.listeners;\n+\n+import javax.persistence.PostLoad;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.context.support.SpringBeanAutowiringSupport;\n+\n+import ca.corefacility.bioinformatics.irida.model.VersionedFileFields;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageUtility;\n+\n+/**\n+ * Component implementation to run on a versioned entity after it is has been accessed from the db.\n+ */\n+@Component\n+public class IridaFileStorageListener {\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageListener.class);\n+\n+\t@Autowired\n+\tprivate IridaFileStorageUtility iridaFileStorageUtility;\n+\n+\t/**\n+\t * After the versioned entity is loaded this method will provide\n+\t * the entity access to the iridaFileStorageUtility\n+\t *\n+\t * @param fileSystemEntity The versioned entity to provide the iridaFileStorageUtility to\n+\t */\n+\t@PostLoad\n+\tpublic void afterEntityLoad(final VersionedFileFields<Long> fileSystemEntity) {\n+\t\t\tSpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5MDEzMw=="}, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjQyODk0OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageUtility.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0MzoyMFrOGlUxOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNjoxMDo1MlrOGmaLtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5MDc3Nw==", "bodyText": "This isn't used.  Is it used in later branches?", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441790777", "createdAt": "2020-06-17T19:43:20Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageUtility.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * Interface describing methods for performing storage actions\n+ */\n+\n+public interface IridaFileStorageUtility {\n+\t//Valid extensions to try to concatenate with this tool\n+\tpublic static final List<String> VALID_EXTENSIONS = Lists.newArrayList(\"fastq\", \"fastq.gz\");\n+\t/**\n+\t * Get a temporarry file from storage\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link File} which was retrieved from path\n+\t */\n+\tpublic File getTemporaryFile(Path file);\n+\n+\t/**\n+\t * Get file size in bytes\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link Long} size of file retrieved from path\n+\t */\n+\tpublic Long getFileSize(Path file);\n+\n+\t/**\n+\t * Write file to storage (azure, aws, or local)\n+\t *\n+\t * @param source The {@link Path} to the file\n+\t * @param target The {@link Path} to where file should be moved\n+\t * @param sequenceFileDir The {@link Path} to sequence file directory\n+\t * @param sequenceFileDirWithRevision The {@link Path} to sequence file revision directory\n+\t */\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision);\n+\n+\t/**\n+\t * Returns if the storage type is local or not\n+\t *\n+\t * @return {@link Boolean#TRUE} if local, {@link Boolean#FALSE} if not.\n+\t */\n+\tpublic boolean storageTypeIsLocal();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyODA1NQ==", "bodyText": "I think it was used in some later branches. If not I will remove in a future branch", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r442928055", "createdAt": "2020-06-19T16:10:52Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageUtility.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * Interface describing methods for performing storage actions\n+ */\n+\n+public interface IridaFileStorageUtility {\n+\t//Valid extensions to try to concatenate with this tool\n+\tpublic static final List<String> VALID_EXTENSIONS = Lists.newArrayList(\"fastq\", \"fastq.gz\");\n+\t/**\n+\t * Get a temporarry file from storage\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link File} which was retrieved from path\n+\t */\n+\tpublic File getTemporaryFile(Path file);\n+\n+\t/**\n+\t * Get file size in bytes\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link Long} size of file retrieved from path\n+\t */\n+\tpublic Long getFileSize(Path file);\n+\n+\t/**\n+\t * Write file to storage (azure, aws, or local)\n+\t *\n+\t * @param source The {@link Path} to the file\n+\t * @param target The {@link Path} to where file should be moved\n+\t * @param sequenceFileDir The {@link Path} to sequence file directory\n+\t * @param sequenceFileDirWithRevision The {@link Path} to sequence file revision directory\n+\t */\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision);\n+\n+\t/**\n+\t * Returns if the storage type is local or not\n+\t *\n+\t * @return {@link Boolean#TRUE} if local, {@link Boolean#FALSE} if not.\n+\t */\n+\tpublic boolean storageTypeIsLocal();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5MDc3Nw=="}, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjQzMjg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/projects/settings/ProjectReferenceFileController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0NDo0NlrOGlUz2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDoyNDoxMFrOGlWCaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5MTQ0OQ==", "bodyText": "Want to add this method onto the ReferenceFile class the same as you added it to SequenceFile so it can get rid of the IridaFileStorageUtility dependency?", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441791449", "createdAt": "2020-06-17T19:44:46Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/projects/settings/ProjectReferenceFileController.java", "diffHunk": "@@ -93,12 +94,7 @@ public String getProjectReferenceFilesPage(final Model model, final Principal pr\n \t\t\tmap.put(\"label\", file.getLabel());\n \t\t\tmap.put(\"createdDate\", file.getCreatedDate());\n \t\t\tPath path = file.getFile();\n-\t\t\ttry {\n-\t\t\t\tmap.put(\"size\", Files.size(path));\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tlogger.error(\"Cannot find the size of file \" + file.getLabel());\n-\t\t\t\tmap.put(\"size\", messageSource.getMessage(\"projects.reference-file.not-found\", new Object[] {}, locale));\n-\t\t\t}\n+\t\t\tmap.put(\"size\", iridaFileStorageUtility.getFileSize(path));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMTU2MQ==", "bodyText": "I have this added in a separate branch", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441811561", "createdAt": "2020-06-17T20:24:10Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/projects/settings/ProjectReferenceFileController.java", "diffHunk": "@@ -93,12 +94,7 @@ public String getProjectReferenceFilesPage(final Model model, final Principal pr\n \t\t\tmap.put(\"label\", file.getLabel());\n \t\t\tmap.put(\"createdDate\", file.getCreatedDate());\n \t\t\tPath path = file.getFile();\n-\t\t\ttry {\n-\t\t\t\tmap.put(\"size\", Files.size(path));\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tlogger.error(\"Cannot find the size of file \" + file.getLabel());\n-\t\t\t\tmap.put(\"size\", messageSource.getMessage(\"projects.reference-file.not-found\", new Object[] {}, locale));\n-\t\t\t}\n+\t\t\tmap.put(\"size\", iridaFileStorageUtility.getFileSize(path));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5MTQ0OQ=="}, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjQzNTk5OnYy", "diffSide": "RIGHT", "path": "src/test/java/ca/corefacility/bioinformatics/irida/processing/impl/unit/ChecksumFileProcessorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0NTo0NFrOGlU1rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNjoxMzoyNFrOGmaQGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5MTkxOA==", "bodyText": "Not used.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r441791918", "createdAt": "2020-06-17T19:45:44Z", "author": {"login": "tom114"}, "path": "src/test/java/ca/corefacility/bioinformatics/irida/processing/impl/unit/ChecksumFileProcessorTest.java", "diffHunk": "@@ -17,17 +17,21 @@\n import ca.corefacility.bioinformatics.irida.model.sequenceFile.SingleEndSequenceFile;\n import ca.corefacility.bioinformatics.irida.processing.FileProcessorException;\n import ca.corefacility.bioinformatics.irida.processing.impl.ChecksumFileProcessor;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageLocalUtilityImpl;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageUtility;\n import ca.corefacility.bioinformatics.irida.repositories.sequencefile.SequenceFileRepository;\n \n public class ChecksumFileProcessorTest {\n \tprivate ChecksumFileProcessor fileProcessor;\n \tprivate SequenceFileRepository sequenceFileRepository;\n \tprivate static final String FILE_CONTENTS = \">test read\\nACGTACTCATG\";\n \tprivate static final String CHECKSUM = \"aeaa0755dc44b393ffe12f02e9bd42b0169b12ca9c15708085db6a4ac9110ee0\";\n+\tprivate IridaFileStorageUtility iridaFileStorageUtility;\n \n \t@Before\n \tpublic void setUp() {\n \t\tsequenceFileRepository = mock(SequenceFileRepository.class);\n+\t\tiridaFileStorageUtility = new IridaFileStorageLocalUtilityImpl();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyOTE3Nw==", "bodyText": "Ended up needing this to set the iridaFileStorageUtility for the sequence file", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r442929177", "createdAt": "2020-06-19T16:13:24Z", "author": {"login": "deepsidhu85"}, "path": "src/test/java/ca/corefacility/bioinformatics/irida/processing/impl/unit/ChecksumFileProcessorTest.java", "diffHunk": "@@ -17,17 +17,21 @@\n import ca.corefacility.bioinformatics.irida.model.sequenceFile.SingleEndSequenceFile;\n import ca.corefacility.bioinformatics.irida.processing.FileProcessorException;\n import ca.corefacility.bioinformatics.irida.processing.impl.ChecksumFileProcessor;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageLocalUtilityImpl;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageUtility;\n import ca.corefacility.bioinformatics.irida.repositories.sequencefile.SequenceFileRepository;\n \n public class ChecksumFileProcessorTest {\n \tprivate ChecksumFileProcessor fileProcessor;\n \tprivate SequenceFileRepository sequenceFileRepository;\n \tprivate static final String FILE_CONTENTS = \">test read\\nACGTACTCATG\";\n \tprivate static final String CHECKSUM = \"aeaa0755dc44b393ffe12f02e9bd42b0169b12ca9c15708085db6a4ac9110ee0\";\n+\tprivate IridaFileStorageUtility iridaFileStorageUtility;\n \n \t@Before\n \tpublic void setUp() {\n \t\tsequenceFileRepository = mock(SequenceFileRepository.class);\n+\t\tiridaFileStorageUtility = new IridaFileStorageLocalUtilityImpl();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5MTkxOA=="}, "originalCommit": {"oid": "8477bb95ad7d2dd6a2e12591e61c4870bba42f7f"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2Nzk1OTE2OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageUtility.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMzozODoyN1rOGnprMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxOToyNjoyM1rOGqe_RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDIzMDQ0OA==", "bodyText": "Something off with this comment.  Does this methond belong in here?", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r444230448", "createdAt": "2020-06-23T13:38:27Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageUtility.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * Interface describing methods for performing storage actions\n+ */\n+\n+public interface IridaFileStorageUtility {\n+\t//Valid extensions to try to concatenate with this tool\n+\tpublic static final List<String> VALID_EXTENSIONS = Lists.newArrayList(\"fastq\", \"fastq.gz\");\n+\t/**\n+\t * Get a temporarry file from storage\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link File} which was retrieved from path\n+\t */\n+\tpublic File getTemporaryFile(Path file);\n+\n+\t/**\n+\t * Get file size in bytes\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link Long} size of file retrieved from path\n+\t */\n+\tpublic Long getFileSize(Path file);\n+\n+\t/**\n+\t * Write file to storage (azure, aws, or local)\n+\t *\n+\t * @param source The {@link Path} to the file\n+\t * @param target The {@link Path} to where file should be moved\n+\t * @param sequenceFileDir The {@link Path} to sequence file directory\n+\t * @param sequenceFileDirWithRevision The {@link Path} to sequence file revision directory\n+\t */\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision);\n+\n+\t/**\n+\t * Returns if the storage type is local or not\n+\t *\n+\t * @return {@link Boolean#TRUE} if local, {@link Boolean#FALSE} if not.\n+\t */\n+\tpublic boolean storageTypeIsLocal();\n+\n+\t/**\n+\t * Gets the file name from the storage type that the file\n+\t * is saved to (azure, aws, or local disk)\n+\t *\n+\t * @param file The path to the file for which to get name for\n+\t * @return {@link String} The file name for the file\n+\t */\n+\tpublic String getFileName(Path file);\n+\n+\n+\t/**\n+\t * Checks if file exists\n+\t *\n+\t * @param file The path to the file\n+\t * @return true if file exists otherwise false\n+\t *\n+\t */\n+\tpublic boolean fileExists(Path file);\n+\n+\t/**\n+\t * Gets the file inputstream\n+\t *\n+\t * @param file The path to the file\n+\t * @return file inputstream\n+\t *\n+\t */\n+\tpublic InputStream getFileInputStream(Path file);\n+\n+\t/**\n+\t * Checks if file is gzipped\n+\t *\n+\t * @param file The path to the file\n+\t * @return true if file is gzipped otherwise false\n+\t * @throws IOException if file can't be read\n+\t *\n+\t */\n+\tpublic boolean isGzipped(Path file) throws IOException;\n+\n+\t/**\n+\t * Append a {@link SequenceFile} to a {@link Path} on the filesystem\n+\t *\n+\t * @param target the {@link Path} to append to\n+\t * @param file   the {@link SequenceFile} to append to the path\n+\t * @throws ConcatenateException if there is an error appending the file\n+\t */\n+\tpublic void appendToFile(Path target, SequenceFile file) throws ConcatenateException;\n+\n+\t/**\n+\t * Get the extension of the files to concatenate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "410d81be16b34c7bf54227182a20086e78f2ffc9"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5MjkzNw==", "bodyText": "See comment for public String getFileExtension below", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r444492937", "createdAt": "2020-06-23T20:39:17Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageUtility.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * Interface describing methods for performing storage actions\n+ */\n+\n+public interface IridaFileStorageUtility {\n+\t//Valid extensions to try to concatenate with this tool\n+\tpublic static final List<String> VALID_EXTENSIONS = Lists.newArrayList(\"fastq\", \"fastq.gz\");\n+\t/**\n+\t * Get a temporarry file from storage\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link File} which was retrieved from path\n+\t */\n+\tpublic File getTemporaryFile(Path file);\n+\n+\t/**\n+\t * Get file size in bytes\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link Long} size of file retrieved from path\n+\t */\n+\tpublic Long getFileSize(Path file);\n+\n+\t/**\n+\t * Write file to storage (azure, aws, or local)\n+\t *\n+\t * @param source The {@link Path} to the file\n+\t * @param target The {@link Path} to where file should be moved\n+\t * @param sequenceFileDir The {@link Path} to sequence file directory\n+\t * @param sequenceFileDirWithRevision The {@link Path} to sequence file revision directory\n+\t */\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision);\n+\n+\t/**\n+\t * Returns if the storage type is local or not\n+\t *\n+\t * @return {@link Boolean#TRUE} if local, {@link Boolean#FALSE} if not.\n+\t */\n+\tpublic boolean storageTypeIsLocal();\n+\n+\t/**\n+\t * Gets the file name from the storage type that the file\n+\t * is saved to (azure, aws, or local disk)\n+\t *\n+\t * @param file The path to the file for which to get name for\n+\t * @return {@link String} The file name for the file\n+\t */\n+\tpublic String getFileName(Path file);\n+\n+\n+\t/**\n+\t * Checks if file exists\n+\t *\n+\t * @param file The path to the file\n+\t * @return true if file exists otherwise false\n+\t *\n+\t */\n+\tpublic boolean fileExists(Path file);\n+\n+\t/**\n+\t * Gets the file inputstream\n+\t *\n+\t * @param file The path to the file\n+\t * @return file inputstream\n+\t *\n+\t */\n+\tpublic InputStream getFileInputStream(Path file);\n+\n+\t/**\n+\t * Checks if file is gzipped\n+\t *\n+\t * @param file The path to the file\n+\t * @return true if file is gzipped otherwise false\n+\t * @throws IOException if file can't be read\n+\t *\n+\t */\n+\tpublic boolean isGzipped(Path file) throws IOException;\n+\n+\t/**\n+\t * Append a {@link SequenceFile} to a {@link Path} on the filesystem\n+\t *\n+\t * @param target the {@link Path} to append to\n+\t * @param file   the {@link SequenceFile} to append to the path\n+\t * @throws ConcatenateException if there is an error appending the file\n+\t */\n+\tpublic void appendToFile(Path target, SequenceFile file) throws ConcatenateException;\n+\n+\t/**\n+\t * Get the extension of the files to concatenate", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDIzMDQ0OA=="}, "originalCommit": {"oid": "410d81be16b34c7bf54227182a20086e78f2ffc9"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwMjAyMw==", "bodyText": "Ok that's fine.  I think the comment here should be updated to remove \"to concatenate\".  It's a bit confusing since this isn't specifically an concatenation thing.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r444502023", "createdAt": "2020-06-23T20:54:50Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageUtility.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * Interface describing methods for performing storage actions\n+ */\n+\n+public interface IridaFileStorageUtility {\n+\t//Valid extensions to try to concatenate with this tool\n+\tpublic static final List<String> VALID_EXTENSIONS = Lists.newArrayList(\"fastq\", \"fastq.gz\");\n+\t/**\n+\t * Get a temporarry file from storage\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link File} which was retrieved from path\n+\t */\n+\tpublic File getTemporaryFile(Path file);\n+\n+\t/**\n+\t * Get file size in bytes\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link Long} size of file retrieved from path\n+\t */\n+\tpublic Long getFileSize(Path file);\n+\n+\t/**\n+\t * Write file to storage (azure, aws, or local)\n+\t *\n+\t * @param source The {@link Path} to the file\n+\t * @param target The {@link Path} to where file should be moved\n+\t * @param sequenceFileDir The {@link Path} to sequence file directory\n+\t * @param sequenceFileDirWithRevision The {@link Path} to sequence file revision directory\n+\t */\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision);\n+\n+\t/**\n+\t * Returns if the storage type is local or not\n+\t *\n+\t * @return {@link Boolean#TRUE} if local, {@link Boolean#FALSE} if not.\n+\t */\n+\tpublic boolean storageTypeIsLocal();\n+\n+\t/**\n+\t * Gets the file name from the storage type that the file\n+\t * is saved to (azure, aws, or local disk)\n+\t *\n+\t * @param file The path to the file for which to get name for\n+\t * @return {@link String} The file name for the file\n+\t */\n+\tpublic String getFileName(Path file);\n+\n+\n+\t/**\n+\t * Checks if file exists\n+\t *\n+\t * @param file The path to the file\n+\t * @return true if file exists otherwise false\n+\t *\n+\t */\n+\tpublic boolean fileExists(Path file);\n+\n+\t/**\n+\t * Gets the file inputstream\n+\t *\n+\t * @param file The path to the file\n+\t * @return file inputstream\n+\t *\n+\t */\n+\tpublic InputStream getFileInputStream(Path file);\n+\n+\t/**\n+\t * Checks if file is gzipped\n+\t *\n+\t * @param file The path to the file\n+\t * @return true if file is gzipped otherwise false\n+\t * @throws IOException if file can't be read\n+\t *\n+\t */\n+\tpublic boolean isGzipped(Path file) throws IOException;\n+\n+\t/**\n+\t * Append a {@link SequenceFile} to a {@link Path} on the filesystem\n+\t *\n+\t * @param target the {@link Path} to append to\n+\t * @param file   the {@link SequenceFile} to append to the path\n+\t * @throws ConcatenateException if there is an error appending the file\n+\t */\n+\tpublic void appendToFile(Path target, SequenceFile file) throws ConcatenateException;\n+\n+\t/**\n+\t * Get the extension of the files to concatenate", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDIzMDQ0OA=="}, "originalCommit": {"oid": "410d81be16b34c7bf54227182a20086e78f2ffc9"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwNzEzOQ==", "bodyText": "Yeah I totally agree after looking at it. Will update it. Thanks!", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r444507139", "createdAt": "2020-06-23T21:03:20Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageUtility.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * Interface describing methods for performing storage actions\n+ */\n+\n+public interface IridaFileStorageUtility {\n+\t//Valid extensions to try to concatenate with this tool\n+\tpublic static final List<String> VALID_EXTENSIONS = Lists.newArrayList(\"fastq\", \"fastq.gz\");\n+\t/**\n+\t * Get a temporarry file from storage\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link File} which was retrieved from path\n+\t */\n+\tpublic File getTemporaryFile(Path file);\n+\n+\t/**\n+\t * Get file size in bytes\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link Long} size of file retrieved from path\n+\t */\n+\tpublic Long getFileSize(Path file);\n+\n+\t/**\n+\t * Write file to storage (azure, aws, or local)\n+\t *\n+\t * @param source The {@link Path} to the file\n+\t * @param target The {@link Path} to where file should be moved\n+\t * @param sequenceFileDir The {@link Path} to sequence file directory\n+\t * @param sequenceFileDirWithRevision The {@link Path} to sequence file revision directory\n+\t */\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision);\n+\n+\t/**\n+\t * Returns if the storage type is local or not\n+\t *\n+\t * @return {@link Boolean#TRUE} if local, {@link Boolean#FALSE} if not.\n+\t */\n+\tpublic boolean storageTypeIsLocal();\n+\n+\t/**\n+\t * Gets the file name from the storage type that the file\n+\t * is saved to (azure, aws, or local disk)\n+\t *\n+\t * @param file The path to the file for which to get name for\n+\t * @return {@link String} The file name for the file\n+\t */\n+\tpublic String getFileName(Path file);\n+\n+\n+\t/**\n+\t * Checks if file exists\n+\t *\n+\t * @param file The path to the file\n+\t * @return true if file exists otherwise false\n+\t *\n+\t */\n+\tpublic boolean fileExists(Path file);\n+\n+\t/**\n+\t * Gets the file inputstream\n+\t *\n+\t * @param file The path to the file\n+\t * @return file inputstream\n+\t *\n+\t */\n+\tpublic InputStream getFileInputStream(Path file);\n+\n+\t/**\n+\t * Checks if file is gzipped\n+\t *\n+\t * @param file The path to the file\n+\t * @return true if file is gzipped otherwise false\n+\t * @throws IOException if file can't be read\n+\t *\n+\t */\n+\tpublic boolean isGzipped(Path file) throws IOException;\n+\n+\t/**\n+\t * Append a {@link SequenceFile} to a {@link Path} on the filesystem\n+\t *\n+\t * @param target the {@link Path} to append to\n+\t * @param file   the {@link SequenceFile} to append to the path\n+\t * @throws ConcatenateException if there is an error appending the file\n+\t */\n+\tpublic void appendToFile(Path target, SequenceFile file) throws ConcatenateException;\n+\n+\t/**\n+\t * Get the extension of the files to concatenate", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDIzMDQ0OA=="}, "originalCommit": {"oid": "410d81be16b34c7bf54227182a20086e78f2ffc9"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIwMTA5Mg==", "bodyText": "Updated in 660b10c", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r447201092", "createdAt": "2020-06-29T19:26:23Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageUtility.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * Interface describing methods for performing storage actions\n+ */\n+\n+public interface IridaFileStorageUtility {\n+\t//Valid extensions to try to concatenate with this tool\n+\tpublic static final List<String> VALID_EXTENSIONS = Lists.newArrayList(\"fastq\", \"fastq.gz\");\n+\t/**\n+\t * Get a temporarry file from storage\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link File} which was retrieved from path\n+\t */\n+\tpublic File getTemporaryFile(Path file);\n+\n+\t/**\n+\t * Get file size in bytes\n+\t *\n+\t * @param file The {@link Path} to the file\n+\t * @return {@link Long} size of file retrieved from path\n+\t */\n+\tpublic Long getFileSize(Path file);\n+\n+\t/**\n+\t * Write file to storage (azure, aws, or local)\n+\t *\n+\t * @param source The {@link Path} to the file\n+\t * @param target The {@link Path} to where file should be moved\n+\t * @param sequenceFileDir The {@link Path} to sequence file directory\n+\t * @param sequenceFileDirWithRevision The {@link Path} to sequence file revision directory\n+\t */\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision);\n+\n+\t/**\n+\t * Returns if the storage type is local or not\n+\t *\n+\t * @return {@link Boolean#TRUE} if local, {@link Boolean#FALSE} if not.\n+\t */\n+\tpublic boolean storageTypeIsLocal();\n+\n+\t/**\n+\t * Gets the file name from the storage type that the file\n+\t * is saved to (azure, aws, or local disk)\n+\t *\n+\t * @param file The path to the file for which to get name for\n+\t * @return {@link String} The file name for the file\n+\t */\n+\tpublic String getFileName(Path file);\n+\n+\n+\t/**\n+\t * Checks if file exists\n+\t *\n+\t * @param file The path to the file\n+\t * @return true if file exists otherwise false\n+\t *\n+\t */\n+\tpublic boolean fileExists(Path file);\n+\n+\t/**\n+\t * Gets the file inputstream\n+\t *\n+\t * @param file The path to the file\n+\t * @return file inputstream\n+\t *\n+\t */\n+\tpublic InputStream getFileInputStream(Path file);\n+\n+\t/**\n+\t * Checks if file is gzipped\n+\t *\n+\t * @param file The path to the file\n+\t * @return true if file is gzipped otherwise false\n+\t * @throws IOException if file can't be read\n+\t *\n+\t */\n+\tpublic boolean isGzipped(Path file) throws IOException;\n+\n+\t/**\n+\t * Append a {@link SequenceFile} to a {@link Path} on the filesystem\n+\t *\n+\t * @param target the {@link Path} to append to\n+\t * @param file   the {@link SequenceFile} to append to the path\n+\t * @throws ConcatenateException if there is an error appending the file\n+\t */\n+\tpublic void appendToFile(Path target, SequenceFile file) throws ConcatenateException;\n+\n+\t/**\n+\t * Get the extension of the files to concatenate", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDIzMDQ0OA=="}, "originalCommit": {"oid": "410d81be16b34c7bf54227182a20086e78f2ffc9"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2Nzk3NjA1OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalUtilityImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMzo0MjoyM1rOGnp2Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxOToyNjoyOVrOGqe_mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDIzMzIxOQ==", "bodyText": "The Concatenator classes should likely be the ones throwing a ConcatenateException.  The IOException (or another exception) should maybe ride up to those classes before ConcatenateException gets thrown.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r444233219", "createdAt": "2020-06-23T13:42:23Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalUtilityImpl.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.exceptions.StorageException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+import ca.corefacility.bioinformatics.irida.processing.FileProcessorException;\n+\n+/**\n+ * Component implementation of file utitlities for local storage\n+ */\n+@Component\n+public class IridaFileStorageLocalUtilityImpl implements IridaFileStorageUtility{\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageLocalUtilityImpl.class);\n+\n+\t@Autowired\n+\tpublic IridaFileStorageLocalUtilityImpl(){\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic File getTemporaryFile(Path file) {\n+\t\tFile fileToProcess = null;\n+\t\tfileToProcess = file.toFile();\n+\t\treturn fileToProcess;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic Long getFileSize(Path file) {\n+\t\tLong fileSize = 0L;\n+\t\ttry {\n+\t\t\tfileSize = Files.size(file);\n+\t\t} catch (NoSuchFileException e) {\n+\t\t\tlogger.error(\"Could not find file \" + file);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Could not calculate file size: \", e);\n+\t\t}\n+\n+\t\treturn fileSize;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision) {\n+\t\ttry {\n+\t\t\tif (!Files.exists(sequenceFileDir)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDir);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDir.toString() + \"]\");\n+\t\t\t}\n+\n+\t\t\tif (!Files.exists(sequenceFileDirWithRevision)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDirWithRevision);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDirWithRevision.toString() + \"]\");\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to create new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to create new directory.\", e);\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tFiles.move(source, target);\n+\t\t\tlogger.trace(\"Moved file \" + source + \" to \" + target);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to move file into new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to move file into new directory.\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic boolean storageTypeIsLocal(){\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic String getFileName(Path file) {\n+\t\tString fileName = \"\";\n+\t\tfileName = file.getFileName().toString();\n+\t\treturn fileName;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic boolean fileExists(Path file) {\n+\t\treturn Files.exists(file);\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic InputStream getFileInputStream(Path file) {\n+\t\ttry {\n+\t\t\treturn Files.newInputStream(file, StandardOpenOption.READ);\n+\t\t} catch(IOException e) {\n+\t\t\tthrow new FileProcessorException(\"could not read file\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic boolean isGzipped(Path file) throws IOException {\n+\t\ttry (InputStream is = getFileInputStream(file)) {\n+\t\t\tbyte[] bytes = new byte[2];\n+\t\t\tis.read(bytes);\n+\t\t\treturn ((bytes[0] == (byte) (GZIPInputStream.GZIP_MAGIC))\n+\t\t\t\t\t&& (bytes[1] == (byte) (GZIPInputStream.GZIP_MAGIC >> 8)));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic void appendToFile(Path target, SequenceFile file) throws ConcatenateException {\n+\n+\t\ttry (FileChannel out = FileChannel.open(target, StandardOpenOption.CREATE, StandardOpenOption.APPEND,\n+\t\t\t\tStandardOpenOption.WRITE)) {\n+\t\t\ttry (FileChannel in = FileChannel.open(file.getFile(), StandardOpenOption.READ)) {\n+\t\t\t\tfor (long p = 0, l = in.size(); p < l; ) {\n+\t\t\t\t\tp += in.transferTo(p, l - p, out);\n+\t\t\t\t}\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new ConcatenateException(\"Could not open input file for reading\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "410d81be16b34c7bf54227182a20086e78f2ffc9"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5MjY3MA==", "bodyText": "Sure I can update this", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r444492670", "createdAt": "2020-06-23T20:38:47Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalUtilityImpl.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.exceptions.StorageException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+import ca.corefacility.bioinformatics.irida.processing.FileProcessorException;\n+\n+/**\n+ * Component implementation of file utitlities for local storage\n+ */\n+@Component\n+public class IridaFileStorageLocalUtilityImpl implements IridaFileStorageUtility{\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageLocalUtilityImpl.class);\n+\n+\t@Autowired\n+\tpublic IridaFileStorageLocalUtilityImpl(){\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic File getTemporaryFile(Path file) {\n+\t\tFile fileToProcess = null;\n+\t\tfileToProcess = file.toFile();\n+\t\treturn fileToProcess;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic Long getFileSize(Path file) {\n+\t\tLong fileSize = 0L;\n+\t\ttry {\n+\t\t\tfileSize = Files.size(file);\n+\t\t} catch (NoSuchFileException e) {\n+\t\t\tlogger.error(\"Could not find file \" + file);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Could not calculate file size: \", e);\n+\t\t}\n+\n+\t\treturn fileSize;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision) {\n+\t\ttry {\n+\t\t\tif (!Files.exists(sequenceFileDir)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDir);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDir.toString() + \"]\");\n+\t\t\t}\n+\n+\t\t\tif (!Files.exists(sequenceFileDirWithRevision)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDirWithRevision);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDirWithRevision.toString() + \"]\");\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to create new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to create new directory.\", e);\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tFiles.move(source, target);\n+\t\t\tlogger.trace(\"Moved file \" + source + \" to \" + target);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to move file into new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to move file into new directory.\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic boolean storageTypeIsLocal(){\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic String getFileName(Path file) {\n+\t\tString fileName = \"\";\n+\t\tfileName = file.getFileName().toString();\n+\t\treturn fileName;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic boolean fileExists(Path file) {\n+\t\treturn Files.exists(file);\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic InputStream getFileInputStream(Path file) {\n+\t\ttry {\n+\t\t\treturn Files.newInputStream(file, StandardOpenOption.READ);\n+\t\t} catch(IOException e) {\n+\t\t\tthrow new FileProcessorException(\"could not read file\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic boolean isGzipped(Path file) throws IOException {\n+\t\ttry (InputStream is = getFileInputStream(file)) {\n+\t\t\tbyte[] bytes = new byte[2];\n+\t\t\tis.read(bytes);\n+\t\t\treturn ((bytes[0] == (byte) (GZIPInputStream.GZIP_MAGIC))\n+\t\t\t\t\t&& (bytes[1] == (byte) (GZIPInputStream.GZIP_MAGIC >> 8)));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic void appendToFile(Path target, SequenceFile file) throws ConcatenateException {\n+\n+\t\ttry (FileChannel out = FileChannel.open(target, StandardOpenOption.CREATE, StandardOpenOption.APPEND,\n+\t\t\t\tStandardOpenOption.WRITE)) {\n+\t\t\ttry (FileChannel in = FileChannel.open(file.getFile(), StandardOpenOption.READ)) {\n+\t\t\t\tfor (long p = 0, l = in.size(); p < l; ) {\n+\t\t\t\t\tp += in.transferTo(p, l - p, out);\n+\t\t\t\t}\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new ConcatenateException(\"Could not open input file for reading\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDIzMzIxOQ=="}, "originalCommit": {"oid": "410d81be16b34c7bf54227182a20086e78f2ffc9"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIwMTE3OQ==", "bodyText": "Updated in 660b10c", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r447201179", "createdAt": "2020-06-29T19:26:29Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalUtilityImpl.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.exceptions.StorageException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+import ca.corefacility.bioinformatics.irida.processing.FileProcessorException;\n+\n+/**\n+ * Component implementation of file utitlities for local storage\n+ */\n+@Component\n+public class IridaFileStorageLocalUtilityImpl implements IridaFileStorageUtility{\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageLocalUtilityImpl.class);\n+\n+\t@Autowired\n+\tpublic IridaFileStorageLocalUtilityImpl(){\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic File getTemporaryFile(Path file) {\n+\t\tFile fileToProcess = null;\n+\t\tfileToProcess = file.toFile();\n+\t\treturn fileToProcess;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic Long getFileSize(Path file) {\n+\t\tLong fileSize = 0L;\n+\t\ttry {\n+\t\t\tfileSize = Files.size(file);\n+\t\t} catch (NoSuchFileException e) {\n+\t\t\tlogger.error(\"Could not find file \" + file);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Could not calculate file size: \", e);\n+\t\t}\n+\n+\t\treturn fileSize;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision) {\n+\t\ttry {\n+\t\t\tif (!Files.exists(sequenceFileDir)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDir);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDir.toString() + \"]\");\n+\t\t\t}\n+\n+\t\t\tif (!Files.exists(sequenceFileDirWithRevision)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDirWithRevision);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDirWithRevision.toString() + \"]\");\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to create new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to create new directory.\", e);\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tFiles.move(source, target);\n+\t\t\tlogger.trace(\"Moved file \" + source + \" to \" + target);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to move file into new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to move file into new directory.\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic boolean storageTypeIsLocal(){\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic String getFileName(Path file) {\n+\t\tString fileName = \"\";\n+\t\tfileName = file.getFileName().toString();\n+\t\treturn fileName;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic boolean fileExists(Path file) {\n+\t\treturn Files.exists(file);\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic InputStream getFileInputStream(Path file) {\n+\t\ttry {\n+\t\t\treturn Files.newInputStream(file, StandardOpenOption.READ);\n+\t\t} catch(IOException e) {\n+\t\t\tthrow new FileProcessorException(\"could not read file\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic boolean isGzipped(Path file) throws IOException {\n+\t\ttry (InputStream is = getFileInputStream(file)) {\n+\t\t\tbyte[] bytes = new byte[2];\n+\t\t\tis.read(bytes);\n+\t\t\treturn ((bytes[0] == (byte) (GZIPInputStream.GZIP_MAGIC))\n+\t\t\t\t\t&& (bytes[1] == (byte) (GZIPInputStream.GZIP_MAGIC >> 8)));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic void appendToFile(Path target, SequenceFile file) throws ConcatenateException {\n+\n+\t\ttry (FileChannel out = FileChannel.open(target, StandardOpenOption.CREATE, StandardOpenOption.APPEND,\n+\t\t\t\tStandardOpenOption.WRITE)) {\n+\t\t\ttry (FileChannel in = FileChannel.open(file.getFile(), StandardOpenOption.READ)) {\n+\t\t\t\tfor (long p = 0, l = in.size(); p < l; ) {\n+\t\t\t\t\tp += in.transferTo(p, l - p, out);\n+\t\t\t\t}\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new ConcatenateException(\"Could not open input file for reading\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDIzMzIxOQ=="}, "originalCommit": {"oid": "410d81be16b34c7bf54227182a20086e78f2ffc9"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2Nzk4NjkzOnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalUtilityImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMzo0NDo1MVrOGnp9MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDo1NTowMFrOGn6QjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDIzNTA1Ng==", "bodyText": "Should this also stay in the concatenator classes?", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r444235056", "createdAt": "2020-06-23T13:44:51Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalUtilityImpl.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.exceptions.StorageException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+import ca.corefacility.bioinformatics.irida.processing.FileProcessorException;\n+\n+/**\n+ * Component implementation of file utitlities for local storage\n+ */\n+@Component\n+public class IridaFileStorageLocalUtilityImpl implements IridaFileStorageUtility{\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageLocalUtilityImpl.class);\n+\n+\t@Autowired\n+\tpublic IridaFileStorageLocalUtilityImpl(){\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic File getTemporaryFile(Path file) {\n+\t\tFile fileToProcess = null;\n+\t\tfileToProcess = file.toFile();\n+\t\treturn fileToProcess;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic Long getFileSize(Path file) {\n+\t\tLong fileSize = 0L;\n+\t\ttry {\n+\t\t\tfileSize = Files.size(file);\n+\t\t} catch (NoSuchFileException e) {\n+\t\t\tlogger.error(\"Could not find file \" + file);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Could not calculate file size: \", e);\n+\t\t}\n+\n+\t\treturn fileSize;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision) {\n+\t\ttry {\n+\t\t\tif (!Files.exists(sequenceFileDir)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDir);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDir.toString() + \"]\");\n+\t\t\t}\n+\n+\t\t\tif (!Files.exists(sequenceFileDirWithRevision)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDirWithRevision);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDirWithRevision.toString() + \"]\");\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to create new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to create new directory.\", e);\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tFiles.move(source, target);\n+\t\t\tlogger.trace(\"Moved file \" + source + \" to \" + target);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to move file into new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to move file into new directory.\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic boolean storageTypeIsLocal(){\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic String getFileName(Path file) {\n+\t\tString fileName = \"\";\n+\t\tfileName = file.getFileName().toString();\n+\t\treturn fileName;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic boolean fileExists(Path file) {\n+\t\treturn Files.exists(file);\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic InputStream getFileInputStream(Path file) {\n+\t\ttry {\n+\t\t\treturn Files.newInputStream(file, StandardOpenOption.READ);\n+\t\t} catch(IOException e) {\n+\t\t\tthrow new FileProcessorException(\"could not read file\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic boolean isGzipped(Path file) throws IOException {\n+\t\ttry (InputStream is = getFileInputStream(file)) {\n+\t\t\tbyte[] bytes = new byte[2];\n+\t\t\tis.read(bytes);\n+\t\t\treturn ((bytes[0] == (byte) (GZIPInputStream.GZIP_MAGIC))\n+\t\t\t\t\t&& (bytes[1] == (byte) (GZIPInputStream.GZIP_MAGIC >> 8)));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic void appendToFile(Path target, SequenceFile file) throws ConcatenateException {\n+\n+\t\ttry (FileChannel out = FileChannel.open(target, StandardOpenOption.CREATE, StandardOpenOption.APPEND,\n+\t\t\t\tStandardOpenOption.WRITE)) {\n+\t\t\ttry (FileChannel in = FileChannel.open(file.getFile(), StandardOpenOption.READ)) {\n+\t\t\t\tfor (long p = 0, l = in.size(); p < l; ) {\n+\t\t\t\t\tp += in.transferTo(p, l - p, out);\n+\t\t\t\t}\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new ConcatenateException(\"Could not open input file for reading\", e);\n+\t\t\t}\n+\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new ConcatenateException(\"Could not open target file for writing\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic String getFileExtension(List<? extends SequencingObject> toConcatenate) throws ConcatenateException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "410d81be16b34c7bf54227182a20086e78f2ffc9"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5MjUyMA==", "bodyText": "This and appendFile above were moved into the IridaFileStorageUtility*Impl files (Local, Azure, and AWS) as the local and cloud implementations have a different way of getting the file data. So keeping it in the concatenator class (SequencingObjectConcatenator) would not work.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r444492520", "createdAt": "2020-06-23T20:38:30Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalUtilityImpl.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.exceptions.StorageException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+import ca.corefacility.bioinformatics.irida.processing.FileProcessorException;\n+\n+/**\n+ * Component implementation of file utitlities for local storage\n+ */\n+@Component\n+public class IridaFileStorageLocalUtilityImpl implements IridaFileStorageUtility{\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageLocalUtilityImpl.class);\n+\n+\t@Autowired\n+\tpublic IridaFileStorageLocalUtilityImpl(){\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic File getTemporaryFile(Path file) {\n+\t\tFile fileToProcess = null;\n+\t\tfileToProcess = file.toFile();\n+\t\treturn fileToProcess;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic Long getFileSize(Path file) {\n+\t\tLong fileSize = 0L;\n+\t\ttry {\n+\t\t\tfileSize = Files.size(file);\n+\t\t} catch (NoSuchFileException e) {\n+\t\t\tlogger.error(\"Could not find file \" + file);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Could not calculate file size: \", e);\n+\t\t}\n+\n+\t\treturn fileSize;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision) {\n+\t\ttry {\n+\t\t\tif (!Files.exists(sequenceFileDir)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDir);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDir.toString() + \"]\");\n+\t\t\t}\n+\n+\t\t\tif (!Files.exists(sequenceFileDirWithRevision)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDirWithRevision);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDirWithRevision.toString() + \"]\");\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to create new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to create new directory.\", e);\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tFiles.move(source, target);\n+\t\t\tlogger.trace(\"Moved file \" + source + \" to \" + target);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to move file into new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to move file into new directory.\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic boolean storageTypeIsLocal(){\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic String getFileName(Path file) {\n+\t\tString fileName = \"\";\n+\t\tfileName = file.getFileName().toString();\n+\t\treturn fileName;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic boolean fileExists(Path file) {\n+\t\treturn Files.exists(file);\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic InputStream getFileInputStream(Path file) {\n+\t\ttry {\n+\t\t\treturn Files.newInputStream(file, StandardOpenOption.READ);\n+\t\t} catch(IOException e) {\n+\t\t\tthrow new FileProcessorException(\"could not read file\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic boolean isGzipped(Path file) throws IOException {\n+\t\ttry (InputStream is = getFileInputStream(file)) {\n+\t\t\tbyte[] bytes = new byte[2];\n+\t\t\tis.read(bytes);\n+\t\t\treturn ((bytes[0] == (byte) (GZIPInputStream.GZIP_MAGIC))\n+\t\t\t\t\t&& (bytes[1] == (byte) (GZIPInputStream.GZIP_MAGIC >> 8)));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic void appendToFile(Path target, SequenceFile file) throws ConcatenateException {\n+\n+\t\ttry (FileChannel out = FileChannel.open(target, StandardOpenOption.CREATE, StandardOpenOption.APPEND,\n+\t\t\t\tStandardOpenOption.WRITE)) {\n+\t\t\ttry (FileChannel in = FileChannel.open(file.getFile(), StandardOpenOption.READ)) {\n+\t\t\t\tfor (long p = 0, l = in.size(); p < l; ) {\n+\t\t\t\t\tp += in.transferTo(p, l - p, out);\n+\t\t\t\t}\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new ConcatenateException(\"Could not open input file for reading\", e);\n+\t\t\t}\n+\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new ConcatenateException(\"Could not open target file for writing\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic String getFileExtension(List<? extends SequencingObject> toConcatenate) throws ConcatenateException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDIzNTA1Ng=="}, "originalCommit": {"oid": "410d81be16b34c7bf54227182a20086e78f2ffc9"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwMjE1Ng==", "bodyText": "Understood.  Thanks.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r444502156", "createdAt": "2020-06-23T20:55:00Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/repositories/filesystem/IridaFileStorageLocalUtilityImpl.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package ca.corefacility.bioinformatics.irida.repositories.filesystem;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import ca.corefacility.bioinformatics.irida.exceptions.ConcatenateException;\n+import ca.corefacility.bioinformatics.irida.exceptions.StorageException;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFile;\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n+import ca.corefacility.bioinformatics.irida.processing.FileProcessorException;\n+\n+/**\n+ * Component implementation of file utitlities for local storage\n+ */\n+@Component\n+public class IridaFileStorageLocalUtilityImpl implements IridaFileStorageUtility{\n+\tprivate static final Logger logger = LoggerFactory.getLogger(IridaFileStorageLocalUtilityImpl.class);\n+\n+\t@Autowired\n+\tpublic IridaFileStorageLocalUtilityImpl(){\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic File getTemporaryFile(Path file) {\n+\t\tFile fileToProcess = null;\n+\t\tfileToProcess = file.toFile();\n+\t\treturn fileToProcess;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic Long getFileSize(Path file) {\n+\t\tLong fileSize = 0L;\n+\t\ttry {\n+\t\t\tfileSize = Files.size(file);\n+\t\t} catch (NoSuchFileException e) {\n+\t\t\tlogger.error(\"Could not find file \" + file);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Could not calculate file size: \", e);\n+\t\t}\n+\n+\t\treturn fileSize;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void writeFile(Path source, Path target, Path sequenceFileDir, Path sequenceFileDirWithRevision) {\n+\t\ttry {\n+\t\t\tif (!Files.exists(sequenceFileDir)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDir);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDir.toString() + \"]\");\n+\t\t\t}\n+\n+\t\t\tif (!Files.exists(sequenceFileDirWithRevision)) {\n+\t\t\t\tFiles.createDirectory(sequenceFileDirWithRevision);\n+\t\t\t\tlogger.trace(\"Created directory: [\" + sequenceFileDirWithRevision.toString() + \"]\");\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to create new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to create new directory.\", e);\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tFiles.move(source, target);\n+\t\t\tlogger.trace(\"Moved file \" + source + \" to \" + target);\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Unable to move file into new directory\", e);\n+\t\t\tthrow new StorageException(\"Failed to move file into new directory.\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic boolean storageTypeIsLocal(){\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic String getFileName(Path file) {\n+\t\tString fileName = \"\";\n+\t\tfileName = file.getFileName().toString();\n+\t\treturn fileName;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic boolean fileExists(Path file) {\n+\t\treturn Files.exists(file);\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic InputStream getFileInputStream(Path file) {\n+\t\ttry {\n+\t\t\treturn Files.newInputStream(file, StandardOpenOption.READ);\n+\t\t} catch(IOException e) {\n+\t\t\tthrow new FileProcessorException(\"could not read file\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic boolean isGzipped(Path file) throws IOException {\n+\t\ttry (InputStream is = getFileInputStream(file)) {\n+\t\t\tbyte[] bytes = new byte[2];\n+\t\t\tis.read(bytes);\n+\t\t\treturn ((bytes[0] == (byte) (GZIPInputStream.GZIP_MAGIC))\n+\t\t\t\t\t&& (bytes[1] == (byte) (GZIPInputStream.GZIP_MAGIC >> 8)));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic void appendToFile(Path target, SequenceFile file) throws ConcatenateException {\n+\n+\t\ttry (FileChannel out = FileChannel.open(target, StandardOpenOption.CREATE, StandardOpenOption.APPEND,\n+\t\t\t\tStandardOpenOption.WRITE)) {\n+\t\t\ttry (FileChannel in = FileChannel.open(file.getFile(), StandardOpenOption.READ)) {\n+\t\t\t\tfor (long p = 0, l = in.size(); p < l; ) {\n+\t\t\t\t\tp += in.transferTo(p, l - p, out);\n+\t\t\t\t}\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new ConcatenateException(\"Could not open input file for reading\", e);\n+\t\t\t}\n+\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new ConcatenateException(\"Could not open target file for writing\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic String getFileExtension(List<? extends SequencingObject> toConcatenate) throws ConcatenateException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDIzNTA1Ng=="}, "originalCommit": {"oid": "410d81be16b34c7bf54227182a20086e78f2ffc9"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjk4OTA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/project/ReferenceFile.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxODo1ODo0M1rOGs2fXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxOTowNTo1NlrOGs2kcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4MzI5NA==", "bodyText": "Why protected?  Is there subclassing of this anywhere?", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r449683294", "createdAt": "2020-07-03T18:58:43Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/project/ReferenceFile.java", "diffHunk": "@@ -44,7 +44,7 @@\n \n \t@Column(name = \"filePath\", unique = true)\n \t@NotNull(message = \"{reference.file.file.notnull}\")\n-\tprivate Path file;\n+\tprotected Path file;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab225e6d847c88ed6b2ecadc1c167d5e6d634b36"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4MzM2MQ==", "bodyText": "Same deal in UploadedAssembly", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r449683361", "createdAt": "2020-07-03T18:59:09Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/project/ReferenceFile.java", "diffHunk": "@@ -44,7 +44,7 @@\n \n \t@Column(name = \"filePath\", unique = true)\n \t@NotNull(message = \"{reference.file.file.notnull}\")\n-\tprivate Path file;\n+\tprotected Path file;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4MzI5NA=="}, "originalCommit": {"oid": "ab225e6d847c88ed6b2ecadc1c167d5e6d634b36"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4NDU5NA==", "bodyText": "and AnalysisOutputFile.java", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r449684594", "createdAt": "2020-07-03T19:05:56Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/model/project/ReferenceFile.java", "diffHunk": "@@ -44,7 +44,7 @@\n \n \t@Column(name = \"filePath\", unique = true)\n \t@NotNull(message = \"{reference.file.file.notnull}\")\n-\tprivate Path file;\n+\tprotected Path file;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4MzI5NA=="}, "originalCommit": {"oid": "ab225e6d847c88ed6b2ecadc1c167d5e6d634b36"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjk5NzgyOnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplesAjaxController.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxOTowNToxOVrOGs2kEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxOTowNToxOVrOGs2kEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4NDQ5OA==", "bodyText": "Hrm.  Ok now pulling out that utility causes a problem now with creating these files.  The 2 stage creation here of the constructor with the file and setType is a problem because the object isn't valid until both of those are called.\n2 solutions I can think of:\n\nAdd isGzipped to the constructor.\nJust get the type based on the file extension in the constructor.  if ends in .gz, it's Fast5Type.ZIPPED.  if ends in .fast5 its a Fast5Type.SINGLE, etc.\n\nI would lean towards option 2.  We're already pulling the extension to check.  Reading the file to confirm it's a zip file is nice, but probably not really necessary in this case because we can usually rely on the fact that a zipped file will be called .gz.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r449684498", "createdAt": "2020-07-03T19:05:19Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplesAjaxController.java", "diffHunk": "@@ -189,6 +192,8 @@ private void createSequenceFileInSample(MultipartFile file, Sample sample) throw\n \t */\n \tprivate void createFast5FileInSample(MultipartFile file, Sample sample) throws IOException {\n \t\tSequenceFile sequenceFile = createSequenceFile(file);\n+\t\tFast5Object fast5Object = new Fast5Object(sequenceFile);\n+\t\tfast5Object.setType(iridaFileStorageUtility.isGzipped(sequenceFile.getFile()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab225e6d847c88ed6b2ecadc1c167d5e6d634b36"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzAwMTgyOnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/concatenate/impl/SequenceFilePairConcatenator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxOTowODoyOVrOGs2mKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxOTowOTo0N1rOGs2nEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4NTAzNQ==", "bodyText": "If you wrap this line in a 2nd try/catch that re-throws the ConcatenateException, you don't have to worry about this method throwing IOException.  That way everything calling this method doesn't need to also handle IOException", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r449685035", "createdAt": "2020-07-03T19:08:29Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/concatenate/impl/SequenceFilePairConcatenator.java", "diffHunk": "@@ -5,28 +5,37 @@\n import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFilePair;\n import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n import ca.corefacility.bioinformatics.irida.processing.concatenate.SequencingObjectConcatenator;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageUtility;\n \n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.List;\n \n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n /**\n  * {@link SequencingObjectConcatenator} for {@link SequenceFilePair}s\n  */\n+@Component\n public class SequenceFilePairConcatenator extends SequencingObjectConcatenator<SequenceFilePair> {\n-\t\n-\tpublic SequenceFilePairConcatenator() {\n+\n+\tprivate IridaFileStorageUtility iridaFileStorageUtility;\n+\n+\t@Autowired\n+\tpublic SequenceFilePairConcatenator(IridaFileStorageUtility iridaFileStorageUtility) {\n+\t\tthis.iridaFileStorageUtility = iridaFileStorageUtility;\n \t}\n \n \t/**\n \t * {@inheritDoc}\n \t */\n \t@Override\n \tpublic SequenceFilePair concatenateFiles(List<? extends SequencingObject> toConcatenate, String filename)\n-\t\t\tthrows ConcatenateException {\n+\t\t\tthrows ConcatenateException, IOException {\n \n-\t\tString extension = getFileExtension(toConcatenate);\n+\t\tString extension = iridaFileStorageUtility.getFileExtension(toConcatenate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab225e6d847c88ed6b2ecadc1c167d5e6d634b36"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4NTI2NA==", "bodyText": "Same deal with SingleEndSequenceFileConcatenator.java.  Then you can remove it from the method signature in SequencingObjectConcatenator.java and it'll remove all your exception testing changes down below.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r449685264", "createdAt": "2020-07-03T19:09:47Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/concatenate/impl/SequenceFilePairConcatenator.java", "diffHunk": "@@ -5,28 +5,37 @@\n import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequenceFilePair;\n import ca.corefacility.bioinformatics.irida.model.sequenceFile.SequencingObject;\n import ca.corefacility.bioinformatics.irida.processing.concatenate.SequencingObjectConcatenator;\n+import ca.corefacility.bioinformatics.irida.repositories.filesystem.IridaFileStorageUtility;\n \n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.List;\n \n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n /**\n  * {@link SequencingObjectConcatenator} for {@link SequenceFilePair}s\n  */\n+@Component\n public class SequenceFilePairConcatenator extends SequencingObjectConcatenator<SequenceFilePair> {\n-\t\n-\tpublic SequenceFilePairConcatenator() {\n+\n+\tprivate IridaFileStorageUtility iridaFileStorageUtility;\n+\n+\t@Autowired\n+\tpublic SequenceFilePairConcatenator(IridaFileStorageUtility iridaFileStorageUtility) {\n+\t\tthis.iridaFileStorageUtility = iridaFileStorageUtility;\n \t}\n \n \t/**\n \t * {@inheritDoc}\n \t */\n \t@Override\n \tpublic SequenceFilePair concatenateFiles(List<? extends SequencingObject> toConcatenate, String filename)\n-\t\t\tthrows ConcatenateException {\n+\t\t\tthrows ConcatenateException, IOException {\n \n-\t\tString extension = getFileExtension(toConcatenate);\n+\t\tString extension = iridaFileStorageUtility.getFileExtension(toConcatenate);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4NTAzNQ=="}, "originalCommit": {"oid": "ab225e6d847c88ed6b2ecadc1c167d5e6d634b36"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzAwNDg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/impl/GzipFileProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxOToxMDo1M1rOGs2n0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxOToxMDo1M1rOGs2n0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4NTQ1Ng==", "bodyText": "It's too bad we've had to go back and forth on this, but when you look at the change this way I think it makes sense.  It's a direct change to iridaFileStorageUtility.getFileInputStream from Files.newInputStream.  I think that abstraction works.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r449685456", "createdAt": "2020-07-03T19:10:53Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/processing/impl/GzipFileProcessor.java", "diffHunk": "@@ -111,10 +114,12 @@ public void processSingleFile(SequenceFile sequenceFile) throws FileProcessorExc\n \n \t\ttry {\n \t\t\tlogger.trace(\"About to try handling a gzip file.\");\n-\t\t\tif (FileUtils.isGzipped(file)) {\n+\n+\t\t\tif (iridaFileStorageUtility.isGzipped(file)) {\n \t\t\t\tfile = addExtensionToFilename(file, GZIP_EXTENSION);\n+\t\t\t\tsequenceFile.setFile(file);\n \n-\t\t\t\ttry (GZIPInputStream zippedInputStream = new GZIPInputStream(Files.newInputStream(file))) {\n+\t\t\t\ttry (GZIPInputStream zippedInputStream = new GZIPInputStream(iridaFileStorageUtility.getFileInputStream(file))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab225e6d847c88ed6b2ecadc1c167d5e6d634b36"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzAwNjc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/pipelines/PipelineController.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxOToxMjoyOFrOGs2o3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxOToxMjoyOFrOGs2o3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4NTcyNg==", "bodyText": "This sort of stuff is one of the biggest pains with adding the filestorageutility, but I guess it's just something we'll have to deal with.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r449685726", "createdAt": "2020-07-03T19:12:28Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/pipelines/PipelineController.java", "diffHunk": "@@ -225,18 +230,31 @@ public String getSpecifiedPipelinePage(final Model model, Principal principal, L\n \t\t\t\t\t\tif (description.acceptsPairedSequenceFiles()) {\n \t\t\t\t\t\t\tCollection<SampleSequencingObjectJoin> pairs = sequencingObjectService.getSequencesForSampleOfType(\n \t\t\t\t\t\t\t\t\tsample, SequenceFilePair.class);\n-\t\t\t\t\t\t\tfiles.put(\"paired_end\", pairs.stream()\n-\t\t\t\t\t\t\t\t\t.map(SampleSequencingObjectJoin::getObject)\n-\t\t\t\t\t\t\t\t\t.collect(Collectors.toList()));\n+\n+\t\t\t\t\t\t\tList<PairedEndFiles> pairedEndFilesList = new ArrayList<>();\n+\t\t\t\t\t\t\tfor(SampleSequencingObjectJoin p : pairs) {\n+\t\t\t\t\t\t\t\tSequenceFilePair pair = (SequenceFilePair) p.getObject();\n+\t\t\t\t\t\t\t\tString forwardFileSize = iridaFileStorageUtility.getFileSize(pair.getForwardSequenceFile().getFile());\n+\t\t\t\t\t\t\t\tString reverseFileSize = iridaFileStorageUtility.getFileSize(pair.getReverseSequenceFile().getFile());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab225e6d847c88ed6b2ecadc1c167d5e6d634b36"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzAxMDU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/web/controller/api/samples/RESTSampleSequenceFilesController.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxOToxNTozMlrOGs2rBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxOToxNTozMlrOGs2rBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4NjI3OQ==", "bodyText": "Yeah.  Seeing the file creation with 2 steps here just feels like we're begging to miss calling this method.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r449686279", "createdAt": "2020-07-03T19:15:32Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/web/controller/api/samples/RESTSampleSequenceFilesController.java", "diffHunk": "@@ -529,6 +532,8 @@ public ModelMap addNewFast5FileToSample(@PathVariable Long sampleId, @RequestPar\n \t\t\tsf.setFile(target);\n \n \t\t\tFast5Object fast5Object = new Fast5Object(sf);\n+\t\t\tfast5Object.setType(iridaFileStorageUtility.isGzipped(sf.getFile()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab225e6d847c88ed6b2ecadc1c167d5e6d634b36"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzA2NzM3OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/dto/SingleEndFiles.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QyMDowMzoyM1rOGs3J4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QyMDowMzoyM1rOGs3J4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY5NDE3OA==", "bodyText": "These DTO classes are a pain, but I guess no way around them if we need to group some of this stuff together.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r449694178", "createdAt": "2020-07-03T20:03:23Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/dto/SingleEndFiles.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package ca.corefacility.bioinformatics.irida.ria.web.samples.dto;\n+\n+import ca.corefacility.bioinformatics.irida.model.sequenceFile.SingleEndSequenceFile;\n+\n+/**\n+ * Used as a response for encapsulating a single end file and its size\n+ */\n+\n+\n+public class SingleEndFiles {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab225e6d847c88ed6b2ecadc1c167d5e6d634b36"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzYzNjMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplesAjaxController.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTo0NToxNVrOGyxF-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzo0NTozOVrOGy1vLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4NjMzMQ==", "bodyText": "This line isn't used.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r455886331", "createdAt": "2020-07-16T15:45:15Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplesAjaxController.java", "diffHunk": "@@ -189,6 +189,7 @@ private void createSequenceFileInSample(MultipartFile file, Sample sample) throw\n \t */\n \tprivate void createFast5FileInSample(MultipartFile file, Sample sample) throws IOException {\n \t\tSequenceFile sequenceFile = createSequenceFile(file);\n+\t\tFast5Object fast5Object = new Fast5Object(sequenceFile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6a499c11a312a0ac26121da0c6f916113c1099d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2MjQxMw==", "bodyText": "Removed in 56ac519", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r455962413", "createdAt": "2020-07-16T17:45:39Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplesAjaxController.java", "diffHunk": "@@ -189,6 +189,7 @@ private void createSequenceFileInSample(MultipartFile file, Sample sample) throw\n \t */\n \tprivate void createFast5FileInSample(MultipartFile file, Sample sample) throws IOException {\n \t\tSequenceFile sequenceFile = createSequenceFile(file);\n+\t\tFast5Object fast5Object = new Fast5Object(sequenceFile);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4NjMzMQ=="}, "originalCommit": {"oid": "e6a499c11a312a0ac26121da0c6f916113c1099d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzY0MjMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplesController.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTo0NjozNlrOGyxJpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzo0NjowOFrOGy1wag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4NzI2OQ==", "bodyText": "This is just swallowing the exception, should it give the concatenation error and redirect like the catch below?", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r455887269", "createdAt": "2020-07-16T15:46:36Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplesController.java", "diffHunk": "@@ -581,7 +581,10 @@ public String concatenateSequenceFiles(@PathVariable Long sampleId, @RequestPara\n \t\ttry {\n \t\t\tsequencingObjectService.concatenateSequences(Lists.newArrayList(readMultiple), filename, sample,\n \t\t\t\t\tremoveOriginals);\n-\t\t} catch (ConcatenateException ex) {\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Error reading files: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6a499c11a312a0ac26121da0c6f916113c1099d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2MjczMA==", "bodyText": "Removed the IOException catch block in 56ac519 as it is never thrown.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r455962730", "createdAt": "2020-07-16T17:46:08Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplesController.java", "diffHunk": "@@ -581,7 +581,10 @@ public String concatenateSequenceFiles(@PathVariable Long sampleId, @RequestPara\n \t\ttry {\n \t\t\tsequencingObjectService.concatenateSequences(Lists.newArrayList(readMultiple), filename, sample,\n \t\t\t\t\tremoveOriginals);\n-\t\t} catch (ConcatenateException ex) {\n+\t\t} catch (IOException e) {\n+\t\t\tlogger.error(\"Error reading files: \", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4NzI2OQ=="}, "originalCommit": {"oid": "e6a499c11a312a0ac26121da0c6f916113c1099d"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzY0NjA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/service/SequencingObjectService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTo0NzoyNlrOGyxL7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzo0NTo0NVrOGy1vhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4Nzg1Mg==", "bodyText": "This doesn't actually throw IOException anymore.", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r455887852", "createdAt": "2020-07-16T15:47:26Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/service/SequencingObjectService.java", "diffHunk": "@@ -140,7 +141,8 @@\n \t *                        the sample\n \t * @return the new {@link SampleSequencingObjectJoin}\n \t * @throws ConcatenateException if there was an error concatenating the sequences\n+\t * @throws IOException if there was an error reading the sequences to concatenate\n \t */\n \tpublic SampleSequencingObjectJoin concatenateSequences(List<SequencingObject> toJoin, String filename,\n-\t\t\tSample targetSample, boolean removeOriginals) throws ConcatenateException;\n+\t\t\tSample targetSample, boolean removeOriginals) throws ConcatenateException, IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6a499c11a312a0ac26121da0c6f916113c1099d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2MjUwMw==", "bodyText": "Removed in 56ac519", "url": "https://github.com/phac-nml/irida/pull/650#discussion_r455962503", "createdAt": "2020-07-16T17:45:45Z", "author": {"login": "deepsidhu85"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/service/SequencingObjectService.java", "diffHunk": "@@ -140,7 +141,8 @@\n \t *                        the sample\n \t * @return the new {@link SampleSequencingObjectJoin}\n \t * @throws ConcatenateException if there was an error concatenating the sequences\n+\t * @throws IOException if there was an error reading the sequences to concatenate\n \t */\n \tpublic SampleSequencingObjectJoin concatenateSequences(List<SequencingObject> toJoin, String filename,\n-\t\t\tSample targetSample, boolean removeOriginals) throws ConcatenateException;\n+\t\t\tSample targetSample, boolean removeOriginals) throws ConcatenateException, IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4Nzg1Mg=="}, "originalCommit": {"oid": "e6a499c11a312a0ac26121da0c6f916113c1099d"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 852, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}