{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyOTc3MTE4", "number": 675, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo0OTowN1rOD5GMTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzozMzowMVrOD5Z5EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTk2ODc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplePairer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo0OTowN1rOGQLR6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwOTo1NTowMlrOGQiSqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNTIwOA==", "bodyText": "Can you pull this commented code.  Sorry that's on me I had them in my other branch.", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419615208", "createdAt": "2020-05-04T17:49:07Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplePairer.java", "diffHunk": "@@ -12,136 +13,136 @@\n import java.util.stream.Stream;\n \n /**\n-* \tUtility class for pairing up sequence files with\n-*\tcommon prefixes and expected characters for forward\n-*\tand reverse sequence files. \n-*/\n+ * Utility class for pairing up sequence files with\n+ * common prefixes and expected characters for forward\n+ * and reverse sequence files.\n+ */\n \n public class SamplePairer {\n-\tprivate static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n-\n-\tprivate static DiffMatchPatch diff = new DiffMatchPatch();\n-\t\n-\tprivate static String[] forwardMatches = SequenceFilePair.forwardMatches;\n-\tprivate static String[] reverseMatches = SequenceFilePair.reverseMatches;\n-\n-\t/**\n-\t * Organize files according to whether they should be paired up\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to uploaded sequence files,\n-\t * \t\t\twhere the key is the common prefix of two paired files,\n-\t * \t\t\tor the full file name of a single sequence file\n-\t */\n-\tprivate static Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n-\n-\n-\t\tMultipartFile file1, file2;\n-\n-\t\t//Want to skip files that have already been organized\n-\t\tSet<MultipartFile> wasChecked = new HashSet<>();\n-\n-\t\t//check all uploaded files to see if they should be paired or left single\n-\t\tfor (int i = 0; i < files.size(); i++) {\n-\t\t\tfile1 = files.get(i);\n-\n-\t\t\tboolean pair = false;\n-\t\t\tif (!wasChecked.contains(file1)) {\n-\t\t\t\tfor (int j = i + 1; j < files.size() && !pair; j++) {\n-\t\t\t\t\tfile2 = files.get(j);\n-\n-\t\t\t\t\tif (!wasChecked.contains(file2)) {\n-\t\t\t\t\t\tMultipartFile[] filePair = null;\n-\n-\t\t\t\t\t\tList<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n-\t\t\t\t\t\t//The size of `diffs` is 4 when only 1 character differs between the two strings\n-\t\t\t\t\t\t//if the two files should be paired, this would be the list of diffs between the file names:\n-\t\t\t\t\t\t//\t\tdiffs[0] = common prefix\n-\t\t\t\t\t\t//\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n-\t\t\t\t\t\t//\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n-\t\t\t\t\t\t//\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n-\t\t\t\t\t\tif (diffs.size() == 4) {\n-\t\t\t\t\t\t\tString file1ID = diffs.get(1).text;\n-\t\t\t\t\t\t\tString file2ID = diffs.get(2).text;\n-\t\t\t\t\t\t\t//Sometimes files uploaded get put in a different ordering such that\n-\t\t\t\t\t\t\t//the first file is the \"reverse\" sequence file and the last file is\n-\t\t\t\t\t\t\t//the \"forward\" sequence file. This long condition checks for that\n-\t\t\t\t\t\t\t//situation.\n-\t\t\t\t\t\t\tif ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n-\t\t\t\t\t\t\t\t\t|| (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n-\t\t\t\t\t\t\t\tfilePair = new MultipartFile[]{file1, file2};\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif (filePair != null) {\n-\t\t\t\t\t\t\tpair = true;\n-\t\t\t\t\t\t\torganizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n-\t\t\t\t\t\t\tlogger.trace(\"Uploaded files [\" + filePair[0].getName() + \", \" + filePair[1].getName()\n-\t\t\t\t\t\t\t\t+ \"] were paired.\");\n-\t\t\t\t\t\t\twasChecked.add(file2);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (!pair) {\n-\t\t\t\t\tMultipartFile[] singleFile = {file1};\n-\t\t\t\t\torganizedFiles.put(file1.getOriginalFilename(), Arrays.asList(singleFile));\n-\t\t\t\t\tlogger.trace(\"Uploaded file [\" + file1.getName() +\"] was not paired\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\twasChecked.add(file1);\n-\t\t}\n-\n-\t\treturn organizedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all paired sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to paired sequence files.\n-\t */\n-\tpublic static Map<String, List<MultipartFile>> getPairedFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> pairedFiles = new HashMap<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() > 1) {\n-\t\t\t\tpairedFiles.put(key, item);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn pairedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all single sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return List of {@link Path}s to single sequence files.\n-\t */\n-\tpublic static List<MultipartFile> getSingleFiles(List<MultipartFile> files) {\n-\n-\t\tList<MultipartFile> singleFilePaths = new ArrayList<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() == 1) {\n-\t\t\t\tsingleFilePaths.add(item.get(0));\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn singleFilePaths;\n-\t}\n+    private static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n+\n+    private static DiffMatchPatch diff = new DiffMatchPatch();\n+\n+    private static String[] forwardMatches = SequenceFilePair.forwardMatches;\n+    private static String[] reverseMatches = SequenceFilePair.reverseMatches;\n+\n+    private static String FAST5_EXTENSION = \"fast5\";\n+\n+    private Map<String, List<MultipartFile>> pairedFiles;\n+    private List<MultipartFile> fast5Files;\n+    private List<MultipartFile> singleFiles;\n+\n+    public SamplePairer(List<MultipartFile> files) {\n+        this.singleFiles = new ArrayList<>();\n+        this.pairedFiles = new HashMap<>();\n+        this.fast5Files = new ArrayList<>();\n+\n+        organizeFiles(files);\n+    }\n+\n+    /**\n+     * Organize files according to whether they should be paired up\n+     *\n+     * @param files List of {@link MultipartFile}s uploaded\n+     * @return Map of {@link Path}s to uploaded sequence files,\n+     * where the key is the common prefix of two paired files,\n+     * or the full file name of a single sequence file\n+     */\n+    private Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n+\n+        Map<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n+\n+        MultipartFile file1, file2;\n+\n+        //Want to skip files that have already been organized\n+        Set<MultipartFile> wasChecked = new HashSet<>();\n+\n+        //check all uploaded files to see if they should be paired or left single\n+        for (int i = 0; i < files.size(); i++) {\n+            file1 = files.get(i);\n+\n+            boolean pair = false;\n+            if (!wasChecked.contains(file1)) {\n+                for (int j = i + 1; j < files.size() && !pair; j++) {\n+                    file2 = files.get(j);\n+\n+                    if (!wasChecked.contains(file2)) {\n+                        MultipartFile[] filePair = null;\n+\n+                        List<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n+                        //The size of `diffs` is 4 when only 1 character differs between the two strings\n+                        //if the two files should be paired, this would be the list of diffs between the file names:\n+                        //\t\tdiffs[0] = common prefix\n+                        //\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n+                        //\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n+                        //\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n+                        if (diffs.size() == 4) {\n+                            String file1ID = diffs.get(1).text;\n+                            String file2ID = diffs.get(2).text;\n+                            //Sometimes files uploaded get put in a different ordering such that\n+                            //the first file is the \"reverse\" sequence file and the last file is\n+                            //the \"forward\" sequence file. This long condition checks for that\n+                            //situation.\n+                            if ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n+                                    || (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n+                                filePair = new MultipartFile[]{file1, file2};\n+                            }\n+                        }\n+\n+                        if (filePair != null) {\n+                            pair = true;\n+                            //organizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5MjIzNA==", "bodyText": "Updated in ea379e5", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419992234", "createdAt": "2020-05-05T09:55:02Z", "author": {"login": "joshsadam"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplePairer.java", "diffHunk": "@@ -12,136 +13,136 @@\n import java.util.stream.Stream;\n \n /**\n-* \tUtility class for pairing up sequence files with\n-*\tcommon prefixes and expected characters for forward\n-*\tand reverse sequence files. \n-*/\n+ * Utility class for pairing up sequence files with\n+ * common prefixes and expected characters for forward\n+ * and reverse sequence files.\n+ */\n \n public class SamplePairer {\n-\tprivate static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n-\n-\tprivate static DiffMatchPatch diff = new DiffMatchPatch();\n-\t\n-\tprivate static String[] forwardMatches = SequenceFilePair.forwardMatches;\n-\tprivate static String[] reverseMatches = SequenceFilePair.reverseMatches;\n-\n-\t/**\n-\t * Organize files according to whether they should be paired up\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to uploaded sequence files,\n-\t * \t\t\twhere the key is the common prefix of two paired files,\n-\t * \t\t\tor the full file name of a single sequence file\n-\t */\n-\tprivate static Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n-\n-\n-\t\tMultipartFile file1, file2;\n-\n-\t\t//Want to skip files that have already been organized\n-\t\tSet<MultipartFile> wasChecked = new HashSet<>();\n-\n-\t\t//check all uploaded files to see if they should be paired or left single\n-\t\tfor (int i = 0; i < files.size(); i++) {\n-\t\t\tfile1 = files.get(i);\n-\n-\t\t\tboolean pair = false;\n-\t\t\tif (!wasChecked.contains(file1)) {\n-\t\t\t\tfor (int j = i + 1; j < files.size() && !pair; j++) {\n-\t\t\t\t\tfile2 = files.get(j);\n-\n-\t\t\t\t\tif (!wasChecked.contains(file2)) {\n-\t\t\t\t\t\tMultipartFile[] filePair = null;\n-\n-\t\t\t\t\t\tList<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n-\t\t\t\t\t\t//The size of `diffs` is 4 when only 1 character differs between the two strings\n-\t\t\t\t\t\t//if the two files should be paired, this would be the list of diffs between the file names:\n-\t\t\t\t\t\t//\t\tdiffs[0] = common prefix\n-\t\t\t\t\t\t//\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n-\t\t\t\t\t\t//\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n-\t\t\t\t\t\t//\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n-\t\t\t\t\t\tif (diffs.size() == 4) {\n-\t\t\t\t\t\t\tString file1ID = diffs.get(1).text;\n-\t\t\t\t\t\t\tString file2ID = diffs.get(2).text;\n-\t\t\t\t\t\t\t//Sometimes files uploaded get put in a different ordering such that\n-\t\t\t\t\t\t\t//the first file is the \"reverse\" sequence file and the last file is\n-\t\t\t\t\t\t\t//the \"forward\" sequence file. This long condition checks for that\n-\t\t\t\t\t\t\t//situation.\n-\t\t\t\t\t\t\tif ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n-\t\t\t\t\t\t\t\t\t|| (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n-\t\t\t\t\t\t\t\tfilePair = new MultipartFile[]{file1, file2};\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif (filePair != null) {\n-\t\t\t\t\t\t\tpair = true;\n-\t\t\t\t\t\t\torganizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n-\t\t\t\t\t\t\tlogger.trace(\"Uploaded files [\" + filePair[0].getName() + \", \" + filePair[1].getName()\n-\t\t\t\t\t\t\t\t+ \"] were paired.\");\n-\t\t\t\t\t\t\twasChecked.add(file2);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (!pair) {\n-\t\t\t\t\tMultipartFile[] singleFile = {file1};\n-\t\t\t\t\torganizedFiles.put(file1.getOriginalFilename(), Arrays.asList(singleFile));\n-\t\t\t\t\tlogger.trace(\"Uploaded file [\" + file1.getName() +\"] was not paired\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\twasChecked.add(file1);\n-\t\t}\n-\n-\t\treturn organizedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all paired sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to paired sequence files.\n-\t */\n-\tpublic static Map<String, List<MultipartFile>> getPairedFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> pairedFiles = new HashMap<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() > 1) {\n-\t\t\t\tpairedFiles.put(key, item);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn pairedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all single sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return List of {@link Path}s to single sequence files.\n-\t */\n-\tpublic static List<MultipartFile> getSingleFiles(List<MultipartFile> files) {\n-\n-\t\tList<MultipartFile> singleFilePaths = new ArrayList<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() == 1) {\n-\t\t\t\tsingleFilePaths.add(item.get(0));\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn singleFilePaths;\n-\t}\n+    private static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n+\n+    private static DiffMatchPatch diff = new DiffMatchPatch();\n+\n+    private static String[] forwardMatches = SequenceFilePair.forwardMatches;\n+    private static String[] reverseMatches = SequenceFilePair.reverseMatches;\n+\n+    private static String FAST5_EXTENSION = \"fast5\";\n+\n+    private Map<String, List<MultipartFile>> pairedFiles;\n+    private List<MultipartFile> fast5Files;\n+    private List<MultipartFile> singleFiles;\n+\n+    public SamplePairer(List<MultipartFile> files) {\n+        this.singleFiles = new ArrayList<>();\n+        this.pairedFiles = new HashMap<>();\n+        this.fast5Files = new ArrayList<>();\n+\n+        organizeFiles(files);\n+    }\n+\n+    /**\n+     * Organize files according to whether they should be paired up\n+     *\n+     * @param files List of {@link MultipartFile}s uploaded\n+     * @return Map of {@link Path}s to uploaded sequence files,\n+     * where the key is the common prefix of two paired files,\n+     * or the full file name of a single sequence file\n+     */\n+    private Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n+\n+        Map<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n+\n+        MultipartFile file1, file2;\n+\n+        //Want to skip files that have already been organized\n+        Set<MultipartFile> wasChecked = new HashSet<>();\n+\n+        //check all uploaded files to see if they should be paired or left single\n+        for (int i = 0; i < files.size(); i++) {\n+            file1 = files.get(i);\n+\n+            boolean pair = false;\n+            if (!wasChecked.contains(file1)) {\n+                for (int j = i + 1; j < files.size() && !pair; j++) {\n+                    file2 = files.get(j);\n+\n+                    if (!wasChecked.contains(file2)) {\n+                        MultipartFile[] filePair = null;\n+\n+                        List<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n+                        //The size of `diffs` is 4 when only 1 character differs between the two strings\n+                        //if the two files should be paired, this would be the list of diffs between the file names:\n+                        //\t\tdiffs[0] = common prefix\n+                        //\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n+                        //\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n+                        //\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n+                        if (diffs.size() == 4) {\n+                            String file1ID = diffs.get(1).text;\n+                            String file2ID = diffs.get(2).text;\n+                            //Sometimes files uploaded get put in a different ordering such that\n+                            //the first file is the \"reverse\" sequence file and the last file is\n+                            //the \"forward\" sequence file. This long condition checks for that\n+                            //situation.\n+                            if ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n+                                    || (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n+                                filePair = new MultipartFile[]{file1, file2};\n+                            }\n+                        }\n+\n+                        if (filePair != null) {\n+                            pair = true;\n+                            //organizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNTIwOA=="}, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTk2OTQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplePairer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo0OToxN1rOGQLSTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwOTo1NTowN1rOGQiS2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNTMwOA==", "bodyText": "Same here.  Delete it please.", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419615308", "createdAt": "2020-05-04T17:49:17Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplePairer.java", "diffHunk": "@@ -12,136 +13,136 @@\n import java.util.stream.Stream;\n \n /**\n-* \tUtility class for pairing up sequence files with\n-*\tcommon prefixes and expected characters for forward\n-*\tand reverse sequence files. \n-*/\n+ * Utility class for pairing up sequence files with\n+ * common prefixes and expected characters for forward\n+ * and reverse sequence files.\n+ */\n \n public class SamplePairer {\n-\tprivate static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n-\n-\tprivate static DiffMatchPatch diff = new DiffMatchPatch();\n-\t\n-\tprivate static String[] forwardMatches = SequenceFilePair.forwardMatches;\n-\tprivate static String[] reverseMatches = SequenceFilePair.reverseMatches;\n-\n-\t/**\n-\t * Organize files according to whether they should be paired up\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to uploaded sequence files,\n-\t * \t\t\twhere the key is the common prefix of two paired files,\n-\t * \t\t\tor the full file name of a single sequence file\n-\t */\n-\tprivate static Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n-\n-\n-\t\tMultipartFile file1, file2;\n-\n-\t\t//Want to skip files that have already been organized\n-\t\tSet<MultipartFile> wasChecked = new HashSet<>();\n-\n-\t\t//check all uploaded files to see if they should be paired or left single\n-\t\tfor (int i = 0; i < files.size(); i++) {\n-\t\t\tfile1 = files.get(i);\n-\n-\t\t\tboolean pair = false;\n-\t\t\tif (!wasChecked.contains(file1)) {\n-\t\t\t\tfor (int j = i + 1; j < files.size() && !pair; j++) {\n-\t\t\t\t\tfile2 = files.get(j);\n-\n-\t\t\t\t\tif (!wasChecked.contains(file2)) {\n-\t\t\t\t\t\tMultipartFile[] filePair = null;\n-\n-\t\t\t\t\t\tList<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n-\t\t\t\t\t\t//The size of `diffs` is 4 when only 1 character differs between the two strings\n-\t\t\t\t\t\t//if the two files should be paired, this would be the list of diffs between the file names:\n-\t\t\t\t\t\t//\t\tdiffs[0] = common prefix\n-\t\t\t\t\t\t//\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n-\t\t\t\t\t\t//\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n-\t\t\t\t\t\t//\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n-\t\t\t\t\t\tif (diffs.size() == 4) {\n-\t\t\t\t\t\t\tString file1ID = diffs.get(1).text;\n-\t\t\t\t\t\t\tString file2ID = diffs.get(2).text;\n-\t\t\t\t\t\t\t//Sometimes files uploaded get put in a different ordering such that\n-\t\t\t\t\t\t\t//the first file is the \"reverse\" sequence file and the last file is\n-\t\t\t\t\t\t\t//the \"forward\" sequence file. This long condition checks for that\n-\t\t\t\t\t\t\t//situation.\n-\t\t\t\t\t\t\tif ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n-\t\t\t\t\t\t\t\t\t|| (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n-\t\t\t\t\t\t\t\tfilePair = new MultipartFile[]{file1, file2};\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif (filePair != null) {\n-\t\t\t\t\t\t\tpair = true;\n-\t\t\t\t\t\t\torganizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n-\t\t\t\t\t\t\tlogger.trace(\"Uploaded files [\" + filePair[0].getName() + \", \" + filePair[1].getName()\n-\t\t\t\t\t\t\t\t+ \"] were paired.\");\n-\t\t\t\t\t\t\twasChecked.add(file2);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (!pair) {\n-\t\t\t\t\tMultipartFile[] singleFile = {file1};\n-\t\t\t\t\torganizedFiles.put(file1.getOriginalFilename(), Arrays.asList(singleFile));\n-\t\t\t\t\tlogger.trace(\"Uploaded file [\" + file1.getName() +\"] was not paired\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\twasChecked.add(file1);\n-\t\t}\n-\n-\t\treturn organizedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all paired sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to paired sequence files.\n-\t */\n-\tpublic static Map<String, List<MultipartFile>> getPairedFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> pairedFiles = new HashMap<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() > 1) {\n-\t\t\t\tpairedFiles.put(key, item);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn pairedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all single sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return List of {@link Path}s to single sequence files.\n-\t */\n-\tpublic static List<MultipartFile> getSingleFiles(List<MultipartFile> files) {\n-\n-\t\tList<MultipartFile> singleFilePaths = new ArrayList<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() == 1) {\n-\t\t\t\tsingleFilePaths.add(item.get(0));\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn singleFilePaths;\n-\t}\n+    private static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n+\n+    private static DiffMatchPatch diff = new DiffMatchPatch();\n+\n+    private static String[] forwardMatches = SequenceFilePair.forwardMatches;\n+    private static String[] reverseMatches = SequenceFilePair.reverseMatches;\n+\n+    private static String FAST5_EXTENSION = \"fast5\";\n+\n+    private Map<String, List<MultipartFile>> pairedFiles;\n+    private List<MultipartFile> fast5Files;\n+    private List<MultipartFile> singleFiles;\n+\n+    public SamplePairer(List<MultipartFile> files) {\n+        this.singleFiles = new ArrayList<>();\n+        this.pairedFiles = new HashMap<>();\n+        this.fast5Files = new ArrayList<>();\n+\n+        organizeFiles(files);\n+    }\n+\n+    /**\n+     * Organize files according to whether they should be paired up\n+     *\n+     * @param files List of {@link MultipartFile}s uploaded\n+     * @return Map of {@link Path}s to uploaded sequence files,\n+     * where the key is the common prefix of two paired files,\n+     * or the full file name of a single sequence file\n+     */\n+    private Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n+\n+        Map<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n+\n+        MultipartFile file1, file2;\n+\n+        //Want to skip files that have already been organized\n+        Set<MultipartFile> wasChecked = new HashSet<>();\n+\n+        //check all uploaded files to see if they should be paired or left single\n+        for (int i = 0; i < files.size(); i++) {\n+            file1 = files.get(i);\n+\n+            boolean pair = false;\n+            if (!wasChecked.contains(file1)) {\n+                for (int j = i + 1; j < files.size() && !pair; j++) {\n+                    file2 = files.get(j);\n+\n+                    if (!wasChecked.contains(file2)) {\n+                        MultipartFile[] filePair = null;\n+\n+                        List<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n+                        //The size of `diffs` is 4 when only 1 character differs between the two strings\n+                        //if the two files should be paired, this would be the list of diffs between the file names:\n+                        //\t\tdiffs[0] = common prefix\n+                        //\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n+                        //\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n+                        //\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n+                        if (diffs.size() == 4) {\n+                            String file1ID = diffs.get(1).text;\n+                            String file2ID = diffs.get(2).text;\n+                            //Sometimes files uploaded get put in a different ordering such that\n+                            //the first file is the \"reverse\" sequence file and the last file is\n+                            //the \"forward\" sequence file. This long condition checks for that\n+                            //situation.\n+                            if ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n+                                    || (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n+                                filePair = new MultipartFile[]{file1, file2};\n+                            }\n+                        }\n+\n+                        if (filePair != null) {\n+                            pair = true;\n+                            //organizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n+\n+                            pairedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n+\n+                            logger.trace(\"Uploaded files [\" + filePair[0].getName() + \", \" + filePair[1].getName()\n+                                    + \"] were paired.\");\n+                            wasChecked.add(file2);\n+                        }\n+                    }\n+                }\n+                if (!pair) {\n+                    MultipartFile[] singleFile = {file1};\n+                    //organizedFiles.put(file1.getOriginalFilename(), Arrays.asList(singleFile));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5MjI4Mw==", "bodyText": "Updated in ea379e5", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419992283", "createdAt": "2020-05-05T09:55:07Z", "author": {"login": "joshsadam"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplePairer.java", "diffHunk": "@@ -12,136 +13,136 @@\n import java.util.stream.Stream;\n \n /**\n-* \tUtility class for pairing up sequence files with\n-*\tcommon prefixes and expected characters for forward\n-*\tand reverse sequence files. \n-*/\n+ * Utility class for pairing up sequence files with\n+ * common prefixes and expected characters for forward\n+ * and reverse sequence files.\n+ */\n \n public class SamplePairer {\n-\tprivate static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n-\n-\tprivate static DiffMatchPatch diff = new DiffMatchPatch();\n-\t\n-\tprivate static String[] forwardMatches = SequenceFilePair.forwardMatches;\n-\tprivate static String[] reverseMatches = SequenceFilePair.reverseMatches;\n-\n-\t/**\n-\t * Organize files according to whether they should be paired up\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to uploaded sequence files,\n-\t * \t\t\twhere the key is the common prefix of two paired files,\n-\t * \t\t\tor the full file name of a single sequence file\n-\t */\n-\tprivate static Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n-\n-\n-\t\tMultipartFile file1, file2;\n-\n-\t\t//Want to skip files that have already been organized\n-\t\tSet<MultipartFile> wasChecked = new HashSet<>();\n-\n-\t\t//check all uploaded files to see if they should be paired or left single\n-\t\tfor (int i = 0; i < files.size(); i++) {\n-\t\t\tfile1 = files.get(i);\n-\n-\t\t\tboolean pair = false;\n-\t\t\tif (!wasChecked.contains(file1)) {\n-\t\t\t\tfor (int j = i + 1; j < files.size() && !pair; j++) {\n-\t\t\t\t\tfile2 = files.get(j);\n-\n-\t\t\t\t\tif (!wasChecked.contains(file2)) {\n-\t\t\t\t\t\tMultipartFile[] filePair = null;\n-\n-\t\t\t\t\t\tList<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n-\t\t\t\t\t\t//The size of `diffs` is 4 when only 1 character differs between the two strings\n-\t\t\t\t\t\t//if the two files should be paired, this would be the list of diffs between the file names:\n-\t\t\t\t\t\t//\t\tdiffs[0] = common prefix\n-\t\t\t\t\t\t//\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n-\t\t\t\t\t\t//\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n-\t\t\t\t\t\t//\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n-\t\t\t\t\t\tif (diffs.size() == 4) {\n-\t\t\t\t\t\t\tString file1ID = diffs.get(1).text;\n-\t\t\t\t\t\t\tString file2ID = diffs.get(2).text;\n-\t\t\t\t\t\t\t//Sometimes files uploaded get put in a different ordering such that\n-\t\t\t\t\t\t\t//the first file is the \"reverse\" sequence file and the last file is\n-\t\t\t\t\t\t\t//the \"forward\" sequence file. This long condition checks for that\n-\t\t\t\t\t\t\t//situation.\n-\t\t\t\t\t\t\tif ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n-\t\t\t\t\t\t\t\t\t|| (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n-\t\t\t\t\t\t\t\tfilePair = new MultipartFile[]{file1, file2};\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif (filePair != null) {\n-\t\t\t\t\t\t\tpair = true;\n-\t\t\t\t\t\t\torganizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n-\t\t\t\t\t\t\tlogger.trace(\"Uploaded files [\" + filePair[0].getName() + \", \" + filePair[1].getName()\n-\t\t\t\t\t\t\t\t+ \"] were paired.\");\n-\t\t\t\t\t\t\twasChecked.add(file2);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (!pair) {\n-\t\t\t\t\tMultipartFile[] singleFile = {file1};\n-\t\t\t\t\torganizedFiles.put(file1.getOriginalFilename(), Arrays.asList(singleFile));\n-\t\t\t\t\tlogger.trace(\"Uploaded file [\" + file1.getName() +\"] was not paired\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\twasChecked.add(file1);\n-\t\t}\n-\n-\t\treturn organizedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all paired sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to paired sequence files.\n-\t */\n-\tpublic static Map<String, List<MultipartFile>> getPairedFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> pairedFiles = new HashMap<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() > 1) {\n-\t\t\t\tpairedFiles.put(key, item);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn pairedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all single sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return List of {@link Path}s to single sequence files.\n-\t */\n-\tpublic static List<MultipartFile> getSingleFiles(List<MultipartFile> files) {\n-\n-\t\tList<MultipartFile> singleFilePaths = new ArrayList<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() == 1) {\n-\t\t\t\tsingleFilePaths.add(item.get(0));\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn singleFilePaths;\n-\t}\n+    private static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n+\n+    private static DiffMatchPatch diff = new DiffMatchPatch();\n+\n+    private static String[] forwardMatches = SequenceFilePair.forwardMatches;\n+    private static String[] reverseMatches = SequenceFilePair.reverseMatches;\n+\n+    private static String FAST5_EXTENSION = \"fast5\";\n+\n+    private Map<String, List<MultipartFile>> pairedFiles;\n+    private List<MultipartFile> fast5Files;\n+    private List<MultipartFile> singleFiles;\n+\n+    public SamplePairer(List<MultipartFile> files) {\n+        this.singleFiles = new ArrayList<>();\n+        this.pairedFiles = new HashMap<>();\n+        this.fast5Files = new ArrayList<>();\n+\n+        organizeFiles(files);\n+    }\n+\n+    /**\n+     * Organize files according to whether they should be paired up\n+     *\n+     * @param files List of {@link MultipartFile}s uploaded\n+     * @return Map of {@link Path}s to uploaded sequence files,\n+     * where the key is the common prefix of two paired files,\n+     * or the full file name of a single sequence file\n+     */\n+    private Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n+\n+        Map<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n+\n+        MultipartFile file1, file2;\n+\n+        //Want to skip files that have already been organized\n+        Set<MultipartFile> wasChecked = new HashSet<>();\n+\n+        //check all uploaded files to see if they should be paired or left single\n+        for (int i = 0; i < files.size(); i++) {\n+            file1 = files.get(i);\n+\n+            boolean pair = false;\n+            if (!wasChecked.contains(file1)) {\n+                for (int j = i + 1; j < files.size() && !pair; j++) {\n+                    file2 = files.get(j);\n+\n+                    if (!wasChecked.contains(file2)) {\n+                        MultipartFile[] filePair = null;\n+\n+                        List<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n+                        //The size of `diffs` is 4 when only 1 character differs between the two strings\n+                        //if the two files should be paired, this would be the list of diffs between the file names:\n+                        //\t\tdiffs[0] = common prefix\n+                        //\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n+                        //\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n+                        //\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n+                        if (diffs.size() == 4) {\n+                            String file1ID = diffs.get(1).text;\n+                            String file2ID = diffs.get(2).text;\n+                            //Sometimes files uploaded get put in a different ordering such that\n+                            //the first file is the \"reverse\" sequence file and the last file is\n+                            //the \"forward\" sequence file. This long condition checks for that\n+                            //situation.\n+                            if ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n+                                    || (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n+                                filePair = new MultipartFile[]{file1, file2};\n+                            }\n+                        }\n+\n+                        if (filePair != null) {\n+                            pair = true;\n+                            //organizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n+\n+                            pairedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n+\n+                            logger.trace(\"Uploaded files [\" + filePair[0].getName() + \", \" + filePair[1].getName()\n+                                    + \"] were paired.\");\n+                            wasChecked.add(file2);\n+                        }\n+                    }\n+                }\n+                if (!pair) {\n+                    MultipartFile[] singleFile = {file1};\n+                    //organizedFiles.put(file1.getOriginalFilename(), Arrays.asList(singleFile));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNTMwOA=="}, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTk4MDcyOnYy", "diffSide": "RIGHT", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplesController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo1MTo1NlrOGQLZIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDowNDo0OVrOGQinlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNzA1Nw==", "bodyText": "No need to cast here.  You're not doing anything with them after they're cast. It cna just be a List of SequencingObject I think.", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419617057", "createdAt": "2020-05-04T17:51:56Z", "author": {"login": "tom114"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplesController.java", "diffHunk": "@@ -286,16 +287,24 @@ public String getSampleFiles(final Model model, @PathVariable Long projectId, @P\n \t\tSample sample = sampleService.read(sampleId);\n \t\tmodel.addAttribute(\"sampleId\", sampleId);\n \n-\t\tCollection<SampleSequencingObjectJoin> filePairJoins = sequencingObjectService\n-\t\t\t\t.getSequencesForSampleOfType(sample, SequenceFilePair.class);\n-\t\tCollection<SampleSequencingObjectJoin> singleFileJoins = sequencingObjectService\n-\t\t\t\t.getSequencesForSampleOfType(sample, SingleEndSequenceFile.class);\n+\t\tCollection<SampleSequencingObjectJoin> filePairJoins = sequencingObjectService.getSequencesForSampleOfType(\n+\t\t\t\tsample, SequenceFilePair.class);\n+\t\tCollection<SampleSequencingObjectJoin> singleFileJoins = sequencingObjectService.getSequencesForSampleOfType(\n+\t\t\t\tsample, SingleEndSequenceFile.class);\n+\t\tCollection<SampleSequencingObjectJoin> fast5FileJoins = sequencingObjectService.getSequencesForSampleOfType(\n+\t\t\t\tsample, Fast5Object.class);\n+\t\tList<Fast5Object> fast5 = fast5FileJoins.stream()\n+\t\t\t\t.map(j -> (Fast5Object) j.getObject())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5NzU4OQ==", "bodyText": "Updated in 0d74082", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419997589", "createdAt": "2020-05-05T10:04:49Z", "author": {"login": "joshsadam"}, "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplesController.java", "diffHunk": "@@ -286,16 +287,24 @@ public String getSampleFiles(final Model model, @PathVariable Long projectId, @P\n \t\tSample sample = sampleService.read(sampleId);\n \t\tmodel.addAttribute(\"sampleId\", sampleId);\n \n-\t\tCollection<SampleSequencingObjectJoin> filePairJoins = sequencingObjectService\n-\t\t\t\t.getSequencesForSampleOfType(sample, SequenceFilePair.class);\n-\t\tCollection<SampleSequencingObjectJoin> singleFileJoins = sequencingObjectService\n-\t\t\t\t.getSequencesForSampleOfType(sample, SingleEndSequenceFile.class);\n+\t\tCollection<SampleSequencingObjectJoin> filePairJoins = sequencingObjectService.getSequencesForSampleOfType(\n+\t\t\t\tsample, SequenceFilePair.class);\n+\t\tCollection<SampleSequencingObjectJoin> singleFileJoins = sequencingObjectService.getSequencesForSampleOfType(\n+\t\t\t\tsample, SingleEndSequenceFile.class);\n+\t\tCollection<SampleSequencingObjectJoin> fast5FileJoins = sequencingObjectService.getSequencesForSampleOfType(\n+\t\t\t\tsample, Fast5Object.class);\n+\t\tList<Fast5Object> fast5 = fast5FileJoins.stream()\n+\t\t\t\t.map(j -> (Fast5Object) j.getObject())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNzA1Nw=="}, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMjAwMzA5OnYy", "diffSide": "RIGHT", "path": "src/main/webapp/pages/samples/sample_files.html", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo1NzozM1rOGQLnJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDowNTozMVrOGQipBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyMDY0NQ==", "bodyText": "If we have fast5 files in here it still shows the \"No sequencing data\" message.  This should be hidden if there are fast5 files.", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419620645", "createdAt": "2020-05-04T17:57:33Z", "author": {"login": "tom114"}, "path": "src/main/webapp/pages/samples/sample_files.html", "diffHunk": "@@ -182,6 +182,58 @@ <h4 class=\"media-heading\" th:text=\"#{samples.files.empty.title}\"></h4>\n \t\t\t</table>\n \t\t</div>\n \t</div>\n+\n+\t<div class=\"row\" th:if=\"${not #lists.isEmpty(fast5)}\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5Nzk1Ng==", "bodyText": "Updated in 04448d4", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419997956", "createdAt": "2020-05-05T10:05:31Z", "author": {"login": "joshsadam"}, "path": "src/main/webapp/pages/samples/sample_files.html", "diffHunk": "@@ -182,6 +182,58 @@ <h4 class=\"media-heading\" th:text=\"#{samples.files.empty.title}\"></h4>\n \t\t\t</table>\n \t\t</div>\n \t</div>\n+\n+\t<div class=\"row\" th:if=\"${not #lists.isEmpty(fast5)}\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyMDY0NQ=="}, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMjAwNjU0OnYy", "diffSide": "RIGHT", "path": "src/main/webapp/pages/samples/sample_files.html", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo1ODoyMFrOGQLpPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDoxNDowMlrOGQi6GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyMTE4MA==", "bodyText": "Need the link to the fastqc results here.  It's exaclty the same as for sequence files.", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419621180", "createdAt": "2020-05-04T17:58:20Z", "author": {"login": "tom114"}, "path": "src/main/webapp/pages/samples/sample_files.html", "diffHunk": "@@ -182,6 +182,58 @@ <h4 class=\"media-heading\" th:text=\"#{samples.files.empty.title}\"></h4>\n \t\t\t</table>\n \t\t</div>\n \t</div>\n+\n+\t<div class=\"row\" th:if=\"${not #lists.isEmpty(fast5)}\">\n+\t\t<div class=\"col-md-12\">\n+\t\t\t<h2 th:text=\"#{sample.files.fast5}\">FAST5 Files</h2>\n+\t\t\t<table class=\"table fast5\" th:with=\"dateFormat=#{locale.date.short}, url=@{${#httpServletRequest.requestURI}}\">\n+\t\t\t\t<tr class=\"fast5_row\" th:each=\"file : ${fast5}\">\n+\t\t\t\t\t<td class=\"td_icon fast5_icon\">\n+\t\t\t\t\t\t<i class=\"far fa-file-alt\"></i>\n+\t\t\t\t\t</td>\n+\t\t\t\t\t<td>\n+\t\t\t\t\t\t<div class=\"file-name td_info--value\"\n+\t\t\t\t\t\t\t style=\"display: flex; align-items: center; height: 35px;\">\n+\t\t\t\t\t\t\t<div th:text=\"${file.label}\"></div>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwMjMyOA==", "bodyText": "Updated in 82d3f5f", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r420002328", "createdAt": "2020-05-05T10:14:02Z", "author": {"login": "joshsadam"}, "path": "src/main/webapp/pages/samples/sample_files.html", "diffHunk": "@@ -182,6 +182,58 @@ <h4 class=\"media-heading\" th:text=\"#{samples.files.empty.title}\"></h4>\n \t\t\t</table>\n \t\t</div>\n \t</div>\n+\n+\t<div class=\"row\" th:if=\"${not #lists.isEmpty(fast5)}\">\n+\t\t<div class=\"col-md-12\">\n+\t\t\t<h2 th:text=\"#{sample.files.fast5}\">FAST5 Files</h2>\n+\t\t\t<table class=\"table fast5\" th:with=\"dateFormat=#{locale.date.short}, url=@{${#httpServletRequest.requestURI}}\">\n+\t\t\t\t<tr class=\"fast5_row\" th:each=\"file : ${fast5}\">\n+\t\t\t\t\t<td class=\"td_icon fast5_icon\">\n+\t\t\t\t\t\t<i class=\"far fa-file-alt\"></i>\n+\t\t\t\t\t</td>\n+\t\t\t\t\t<td>\n+\t\t\t\t\t\t<div class=\"file-name td_info--value\"\n+\t\t\t\t\t\t\t style=\"display: flex; align-items: center; height: 35px;\">\n+\t\t\t\t\t\t\t<div th:text=\"${file.label}\"></div>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyMTE4MA=="}, "originalCommit": {"oid": "4c0c7429470b3322017cc9bc046704487a90306f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTE5NjMyOnYy", "diffSide": "RIGHT", "path": "src/main/webapp/pages/samples/sample_files.html", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzozMzowMVrOGQpk6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDo1ODozNlrOGQtjRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDExMTU5Mw==", "bodyText": "do we need this url variable for anything?  doesn't seem to be used anywhere", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r420111593", "createdAt": "2020-05-05T13:33:01Z", "author": {"login": "tom114"}, "path": "src/main/webapp/pages/samples/sample_files.html", "diffHunk": "@@ -182,6 +182,58 @@ <h4 class=\"media-heading\" th:text=\"#{samples.files.empty.title}\"></h4>\n \t\t\t</table>\n \t\t</div>\n \t</div>\n+\n+\t<div class=\"row\" th:if=\"${not #lists.isEmpty(fast5)}\">\n+\t\t<div class=\"col-md-12\">\n+\t\t\t<h2 th:text=\"#{sample.files.fast5}\">FAST5 Files</h2>\n+\t\t\t<table class=\"table fast5\" th:with=\"dateFormat=#{locale.date.short}, url=@{${#httpServletRequest.requestURI}}\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d3f5f5397234fcc0b347bf1e8f669743627243"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE3NjcwOA==", "bodyText": "Updated in fbbf5f2", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r420176708", "createdAt": "2020-05-05T14:58:36Z", "author": {"login": "joshsadam"}, "path": "src/main/webapp/pages/samples/sample_files.html", "diffHunk": "@@ -182,6 +182,58 @@ <h4 class=\"media-heading\" th:text=\"#{samples.files.empty.title}\"></h4>\n \t\t\t</table>\n \t\t</div>\n \t</div>\n+\n+\t<div class=\"row\" th:if=\"${not #lists.isEmpty(fast5)}\">\n+\t\t<div class=\"col-md-12\">\n+\t\t\t<h2 th:text=\"#{sample.files.fast5}\">FAST5 Files</h2>\n+\t\t\t<table class=\"table fast5\" th:with=\"dateFormat=#{locale.date.short}, url=@{${#httpServletRequest.requestURI}}\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDExMTU5Mw=="}, "originalCommit": {"oid": "82d3f5f5397234fcc0b347bf1e8f669743627243"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 863, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}